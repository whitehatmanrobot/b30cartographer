------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	msfhead.cxx
//
//  Contents:	Precompiled headers
//
//--------------------------------------------------------------------------

// some of these functions are a nuisance 
#ifdef _MSC_VER
#pragma warning (disable:4127)  // conditional expression is constant
#pragma warning (disable:4514)  // unreferenced inline function
#endif

#include "h/msf.hxx"
#include "h/header.hxx"
#include "h/vect.hxx"
#include "h/page.hxx"
#include "h/vectfunc.hxx"
#include "h/fat.hxx"
#include "h/dir.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\msfiter.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       msfiter.cxx
//
//  Contents:   Iterator code for MSF
//
//  Classes:    None. (Defined in iter.hxx)
//
//--------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "h/msfiter.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CMSFIterator::GetNext, public
//
//  Synposis:   Fill in a stat buffer for the next iteration entry
//
//  Effects:    Modifies _sidCurrent
//
//  Arguments:  [pstat] - Stat buffer
//
//  Returns:    S_OK if call completed OK.
//              STG_E_NOMOREFILES if no next entry was found.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CMSFIterator::GetNext(STATSTGW *pstat)
{
    SCODE sc;
    SID sidNext;
    msfDebugOut((DEB_TRACE,"In CMSFIterator::GetNext()\n"));

    if (_sidChildRoot == NOSTREAM)
        msfChk(STG_E_NOMOREFILES);

    msfChk(_pdir->FindGreaterEntry(_sidChildRoot, &_dfnCurrent, &sidNext));

    //  We found another child
    CDirEntry *pde;

    msfChk(_pdir->GetDirEntry(sidNext, FB_NONE, &pde));
    pstat->type = pde->GetFlags();

    //Note:  The casting below assumes that DfName is always a
    //          wide character string.  If we at some point in
    //          the future convert to a system where this is not
    //          true, this code needs to be updated.

    msfChk(DfAllocWCS((WCHAR *)pde->GetName()->GetBuffer(), &pstat->pwcsName));
    wcscpy(pstat->pwcsName, (WCHAR *)pde->GetName()->GetBuffer());

    pstat->ctime = pde->GetTime(WT_CREATION);
    pstat->mtime = pde->GetTime(WT_MODIFICATION);

    //Don't currently keep access times
    pstat->atime = pstat->mtime;

    if ((pstat->type & STGTY_REAL) == STGTY_STORAGE)
    {
        ULISet32(pstat->cbSize, 0);
        pstat->clsid = pde->GetClassId();
        pstat->grfStateBits = pde->GetUserFlags();
    }
    else
    {
        ULISet32(pstat->cbSize, pde->GetSize());
        pstat->clsid = CLSID_NULL;
        pstat->grfStateBits = 0;
    }

    // update our iterator
    _dfnCurrent.Set(pde->GetName());

    _pdir->ReleaseEntry(sidNext);

    msfDebugOut((DEB_TRACE,"Leaving CMSFIterator::GetNext()\n"));
    // Fall through
Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:	CMSFIterator::BufferGetNext, public
//
//  Synopsis:	Fast, fixed-size buffer version of GetNext
//		for iterations that don't care about having
//		full stat info and an allocated name
//
//  Arguments:	[pib] - Buffer to fill in
//
//  Returns:	Appropriate status code
//
//  Modifies:	[pib]
//
//---------------------------------------------------------------


SCODE CMSFIterator::BufferGetNext(SIterBuffer *pib)
{
    SCODE sc;
    SID sidNext;
    CDirEntry *pdeNext;

    msfDebugOut((DEB_ITRACE, "In  CMSFIterator::BufferGetNext(%p)\n", pib));

    if (_sidChildRoot == NOSTREAM)
        msfChk(STG_E_NOMOREFILES);

    msfChk(_pdir->FindGreaterEntry(_sidChildRoot, &_dfnCurrent, &sidNext));

    msfChk(_pdir->GetDirEntry(sidNext, FB_NONE, &pdeNext));
    pib->type = pdeNext->GetFlags();
    pib->dfnName = *(pdeNext->GetName());

    //  update our iterator
    _dfnCurrent.Set(pdeNext->GetName());

    _pdir->ReleaseEntry(sidNext);
    msfDebugOut((DEB_ITRACE, "Out CMSFIterator::BufferGetNext\n"));
    // Fall through
Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\refilb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	refilb.cxx
//
//  Contents:	Reference ILockBytes class
//
//  Classes:	CFileILB
//
//  Notes:      This Class always call single byte I/O routines
//              because most systems only have support for single byte
//              I/O. This makes the code more portable.
//
//----------------------------------------------------------------------------


#include "msfhead.cxx"
#include <errno.h>
#include "h/refilb.hxx"
#include <stdio.h>
#include <stdlib.h>

#include <sys/stat.h>
#include "time.hxx"
#include "h/tchar.h"

#ifdef _WIN32
#include <io.h> // to get definition of wunlink
#else
#include <unistd.h>
// get the correct stat structure
#endif

#include <stdlib.h>
#include "h/ole.hxx"

DECLARE_INFOLEVEL(ol, DEB_ERROR)

static int filenum = 0;

char * GetTempFileName(void)
{
    char *psz = new char[_MAX_PATH +1];
    strcpy(psz, "dft");

    _itoa(filenum, psz + 3, 10);
    filenum++;
    return psz;
}

CFileILB::CFileILB(const TCHAR *pszName,
                   DWORD grfMode,
                   BOOL fOpenFile/* =TRUE */)
{
    _pszName = NULL;

    _fDelete = FALSE;
    if (pszName == NULL)
    {
         _pszName = GetTempFileName();
         _unlink(_pszName);            // make sure file is over written
         _fDelete |= ILB_DELETEONERR;  // don't want to keep scratch files
    }
    else
    {
        _pszName = new char[_MAX_PATH + 1];
        TTOS(pszName, _pszName, _tcslen(pszName)+1);
    }

    if (grfMode & STGM_DELETEONRELEASE)
        _fDelete |= ILB_DELETEONRELEASE;
    _f = NULL;
    if (fOpenFile)
    {
        // disregard if file is already there
	Create(STGM_CREATE|STGM_READWRITE);
        // got to open the file with this option
        olAssert(_f && "CFileILB could not open the file!");
    }
    _ulRef = 1;
}

static const char pcszReadOnly[] ="rb";
static const char pcszReadWrite[] = "r+b";
static const char pcszWrite[] = "w+b";

SCODE CFileILB::Create(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        olDebugOut((DEB_ITRACE, "CFileILB::Create called with Read Only!!\n"));

    _f = fopen(_pszName, pszMode);
    if (_f)                     // open succeeded
    {
        if ((grfMode & (STGM_CREATE|STGM_CONVERT) ) == STGM_FAILIFTHERE)
            return STG_E_FILEALREADYEXISTS;
    }
    else if (errno==EACCES && (grfMode & STGM_CONVERT))
    {
        olDebugOut((DEB_ERROR,"Access Denied in CFileILB::Create\n"));
        return STG_E_ACCESSDENIED;
    }
    else
    {
        // the file does not exists, create the file
        _f = fopen(_pszName, pcszWrite);
        if (_f==NULL)
        {
            // we could not create the file for some reason
            // return the appropriate error code
            if (errno== EACCES)
                return STG_E_ACCESSDENIED;
            else
            {
                return STG_E_INVALIDNAME; // assume it is an invalid name
            }
        }
        else
        {
            // the newly create file should be deleted on error
            _fDelete |= ILB_DELETEONERR;
        }
    }
    return S_OK;
}

SCODE CFileILB::Open(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    // this means an null named file
    olAssert( (_fDelete & ILB_DELETEONERR)==0 );
                                                  // has been opened
    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        olDebugOut((DEB_ITRACE, "CFileILB::Open called with Read Only!!\n"));

    _f = fopen(_pszName, pszMode);
    if (_f == NULL)
    {
        if (errno==EACCES) return STG_E_ACCESSDENIED;
        else if (errno==ENOENT) return STG_E_FILENOTFOUND;
        else return STG_E_INVALIDNAME; // we assume that the name is invalid
    }

    return S_OK;
}

CFileILB::~CFileILB()
{
    if (_f)
        fclose(_f);
    if (_fDelete & ILB_DELETEONRELEASE)
    {
         // nothing we can do if the file cannot be deleted somehow
         // since the ref impl. is not multi-thread safe
        _unlink(_pszName);
    }
    delete _pszName;
}

STDMETHODIMP CFileILB::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    UNREFERENCED_PARM(riid);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

STDMETHODIMP_(ULONG) CFileILB::AddRef(void)
{
    AtomicInc(&_ulRef);
    return(_ulRef);
}

STDMETHODIMP_(ULONG) CFileILB::Release(void)
{
    AtomicDec(&_ulRef);
    olDebugOut( (DEB_ITRACE, "CFileILB::Release => %lx\n", _ulRef) );
    if (_ulRef > 0)
        return(_ulRef);
    delete this;

    return(0);
}

ULONG CFileILB::ReleaseOnError(void)
{
    // this function should be not used otherwise
    olAssert(_ulRef == 1);

    // Delete the file if it is a file we just created
    if (_fDelete & ILB_DELETEONERR)
        _fDelete |= ILB_DELETEONRELEASE;
    return( Release() );
}

STDMETHODIMP CFileILB::ReadAt(ULARGE_INTEGER ulPosition,

        VOID HUGEP *pb,
        ULONG cb,
        ULONG *pcbRead)
{
    fseek(_f, ULIGetLow(ulPosition), SEEK_SET);

    *pcbRead = fread(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::WriteAt(ULARGE_INTEGER ulPosition,
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG FAR *pcbWritten)
{
    fseek(_f, ULIGetLow(ulPosition), SEEK_SET);

    *pcbWritten = fwrite(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::Flush(void)
{
    fflush(_f);
    return NOERROR;
}

STDMETHODIMP CFileILB::SetSize(ULARGE_INTEGER ulNewSize)
{
    LONG cbNewSize = ULIGetLow(ulNewSize);
    LONG cbCurrentSize = ftell(_f);
    if(-1 == cbCurrentSize)
        return STG_E_SEEKERROR;

    if(cbCurrentSize < cbNewSize)
    {                                       // Increase the Size
        fseek(_f, cbNewSize-1, SEEK_SET);
        if(1 != fwrite("", 1, 1, _f))
            return STG_E_WRITEFAULT;
    }
    else if(cbCurrentSize > cbNewSize)
    {                                       // Decrease the Size
        //  OS specific: file truncation.
    }
    return NOERROR;
}

STDMETHODIMP CFileILB::LockRegion(ULARGE_INTEGER libOffset,
                                  ULARGE_INTEGER cb,
                                  DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    olAssert(FALSE && aMsg("function not implemented!"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
         char pchTemp[_MAX_PATH+1];
        _fullpath(pchTemp, _pszName, _MAX_PATH+1);
        pstatstg->pwcsName = new TCHAR[strlen(pchTemp)+1];
        STOT(pchTemp, pstatstg->pwcsName, strlen(pchTemp)+1);
    }

    pstatstg->type = STGTY_LOCKBYTES;

    ULISetHigh(pstatstg->cbSize, 0);

    fseek(_f, 0, SEEK_END);
    ULISetLow(pstatstg->cbSize, ftell(_f));

    // just return a default, the function that calls this should fill in
    // the structure.
    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    struct _stat buf;
    int result = _stat(_pszName, &buf);
    if (!result)  // fill in zeros
    {
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwHighDateTime = 0;
        pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwHighDateTime = 0;
        pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwHighDateTime = 0;
    }
    else
    {
        TimeTToFileTime(&buf.st_atime, &pstatstg->atime);
        TimeTToFileTime(&buf.st_mtime, &pstatstg->mtime);
        TimeTToFileTime(&buf.st_ctime, &pstatstg->ctime);
    }
    return NOERROR;
}

EXTERN_C STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return (memcmp(&rguid1, &rguid2, sizeof(GUID)) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\mstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           mstream.cxx
//
//  Contents:       Mstream operations
//
//  Classes:        None. (defined in mstream.hxx)
//
//--------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "h/sstream.hxx"
#include "h/difat.hxx"
#include "h/msfiter.hxx"
#include <time.h>
#include "mread.hxx"
#include "h/docfilep.hxx"


#if DEVL == 1

DECLARE_INFOLEVEL(msf, DEB_ERROR)

#endif

#define MINPAGES 6
#define MAXPAGES 12

extern "C" WCHAR const wcsContents[] = 
	{'C','O','N','T','E','N','T','S','\0'};
extern "C" CDfName const dfnContents(wcsContents);
SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache);

//+---------------------------------------------------------------------------
//
//  Function:	GetBuffer, public
//
//  Synopsis:	Gets a chunk of memory to use as a buffer
//
//  Arguments:	[cbMin] - Minimum size for buffer
//              [cbMax] - Maximum size for buffer
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//  Algorithm:  Attempt to dynamically allocate [cbMax] bytes
//              If that fails, halve allocation size and retry
//              If allocation size falls below [cbMin], fail
//
//  Notes:	Buffer should be released with FreeBuffer
//
//----------------------------------------------------------------------------

SCODE GetBuffer(USHORT cbMin, USHORT cbMax, BYTE **ppb, USHORT *pcbActual)
{
    USHORT cbSize;
    BYTE *pb;
    
    msfDebugOut((DEB_ITRACE, "In  GetBuffer(%hu, %hu, %p, %p)\n",
                 cbMin, cbMax, ppb, pcbActual));
    msfAssert(cbMin > 0);
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);
    msfAssert(pcbActual != NULL);
    
    cbSize = cbMax;
    for (;;)
    {
        pb = new BYTE[cbSize];
        if (pb == NULL)
        {
            cbSize >>= 1;
            if (cbSize < cbMin)
                break;
        }
        else
        {
            *pcbActual = cbSize;
            break;
        }
    }

    *ppb = pb;
    
    msfDebugOut((DEB_ITRACE, "Out GetBuffer => %p, %hu\n", *ppb, *pcbActual));
    return pb == NULL ? STG_E_INSUFFICIENTMEMORY : S_OK;
}

// Define the safe buffer size
#define SCRATCHBUFFERSIZE ((USHORT) 4096)
static BYTE s_buf[SCRATCHBUFFERSIZE];
static LONG s_bufRef = 0;



//+---------------------------------------------------------------------------
//
//  Function:	GetSafeBuffer, public
//
//  Synopsis:	Gets a buffer by first trying GetBuffer and if that fails,
//              returning a pointer to statically allocated storage.
//              Guaranteed to return a pointer to some storage.
//
//  Arguments:	[cbMin] - Minimum buffer size
//              [cbMax] - Maximum buffer size
//              [ppb] - Buffer pointer return
//              [pcbActual] - Actual buffer size return
//
//  Modifies:	[ppb]
//              [pcbActual]
//
//----------------------------------------------------------------------------

void GetSafeBuffer(USHORT cbMin, USHORT cbMax, BYTE **ppb, USHORT *pcbActual)
{
    msfAssert(cbMin > 0);
    msfAssert(cbMin <= SCRATCHBUFFERSIZE &&
              aMsg("Minimum too large for GetSafeBuffer"));
    msfAssert(cbMax >= cbMin);
    msfAssert(ppb != NULL);
    msfAssert(s_bufRef == 0 &&
              aMsg("Tried to use scratch buffer twice"));

    if (cbMax <= SCRATCHBUFFERSIZE ||
        FAILED(GetBuffer(cbMin, cbMax, ppb, pcbActual)))
    {
        s_bufRef = 1;
        *ppb = s_buf;
        *pcbActual = min(cbMax, SCRATCHBUFFERSIZE);
    }
    msfAssert(*ppb != NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:	FreeBuffer, public
//
//  Synopsis:	Releases a buffer allocated by GetBuffer or GetSafeBuffer
//
//  Arguments:	[pb] - Buffer
//
//----------------------------------------------------------------------------

void FreeBuffer(BYTE *pb)
{
    if (pb == s_buf)
    {
        msfAssert((s_bufRef == 1) && aMsg("Bad safe buffer ref count"));
        s_bufRef = 0;
    }
    else
        delete [] pb;
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::CMStream, public
//
//  Synopsis:   CMStream constructor
//
//  Arguments:  [pplstParent] -- Pointer to ILockBytes pointer of parent
//              [plGen] -- Pointer to LUID Generator to use.
//                         Note:  May be NULL, in which case a new
//              [uSectorShift] -- Sector shift for this MStream
//
//--------------------------------------------------------------------------


CMStream::CMStream(
    ILockBytes **pplstParent,
    USHORT uSectorShift)
    :_uSectorShift(uSectorShift),
     _uSectorSize( (USHORT) (1 << uSectorShift) ),
     _uSectorMask((USHORT) (_uSectorSize - 1)),
     _pplstParent(pplstParent),
     _hdr(uSectorShift),
     _fatDif( (USHORT) (1<<uSectorShift) ),
     _fat(SIDFAT, (USHORT) (1<<uSectorShift), uSectorShift),
     _dir((USHORT) (1 << uSectorShift)),
     _fatMini(SIDMINIFAT, (USHORT) (1 << uSectorShift), uSectorShift)
{
    
    _pdsministream = NULL;
    _pmpt = NULL;
}




//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitCommon, private
//
//  Synopsis:   Common code for initialization routines.
//
//  Arguments:  None.
//
//  Returns:    S_OK if call completed OK.
//
//  Algorithm: 
//
//--------------------------------------------------------------------------

SCODE  CMStream::InitCommon(VOID)
{
    msfDebugOut((DEB_ITRACE,"In CMStream InitCommon()\n"));
    SCODE sc = S_OK;

    msfAssert(_pmpt == NULL);
    msfMem(_pmpt = new CMSFPageTable(this, MINPAGES, MAXPAGES));
    msfChk(_pmpt->Init());

    msfDebugOut((DEB_ITRACE,"Leaving CMStream InitCommon()\n"));

    return sc;

Err:
    delete _pmpt;
    _pmpt = NULL;        
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMStream::GetESect, private
//
//  Synopsis:   For a given SID and sect, return the location of that
//              sector in the multistream.
//
//  Arguments:  [sid] -- SID of sector to locate
//              [sect] -- Offset into chain to locate
//              [psect] -- Pointer to return location.
//
//  Returns:    Appropriate status code
//
//  Modifies:
//
//  Notes:     
//
//----------------------------------------------------------------------------

SCODE CMStream::GetESect(SID sid, SECT sect, SECT *psect)
{
    SCODE sc = S_OK;

    SECT start;

    if (sid == SIDFAT)
    {
        msfChk(_fatDif.GetFatSect(sect, &start));
    }
    else if (sid == SIDDIF)
    {
        msfChk(_fatDif.GetSect(sect, &start));
    }
    else
    {
        start = GetStart(sid);
        msfChk(_fat.GetESect(start, sect, &start));
    }

    *psect = start;
Err:
    return sc;
										}

//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Empty, public
//
//  Synopsis:	Empty all of the control structures of this CMStream
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------


void CMStream::Empty(void)
{
    _fat.Empty();
    _fatMini.Empty();
    _fatDif.Empty();
    _dir.Empty();
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::~CMStream, public
//
//  Synopsis:   CMStream destructor
//
//--------------------------------------------------------------------------

 CMStream::~CMStream()
{

    msfDebugOut((DEB_ITRACE,"In CMStream destructor\n"));


    if (_pdsministream != NULL)
    {
        _pdsministream->Release();
    }

    if (_pmpt != NULL)
    {
        _pmpt->Release();
    }

    msfDebugOut((DEB_ITRACE,"Leaving CMStream destructor\n"));
}


//+-------------------------------------------------------------------------
//
//  Member:     CMStream::GetIterator, public
//
//  Synposis:   Create a new iterator for a given handle.
//
//  Effects:    Creates a new CMSFIterator
//
//  Arguments:  [sidParent] -- SID of entry to iterate over
//              [ppitRetval] -- Location for return of iterator pointer
//
//  Returns:    S_OK
//
//  Algorithm:  Create new iterator with parent of 'this' and nsi as given
//              by handle.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE  CMStream::GetIterator(
    SID const sidParent,
    CMSFIterator **ppitRetval)
{
    SCODE sc;

    msfDebugOut((DEB_TRACE,"In CMStream::GetIterator()\n"));

    SID sidChild;
    msfChk(_dir.GetChild(sidParent, &sidChild));

    msfDebugOut((DEB_ITRACE, "Getting an iterator for SID = %lu, "
                 "sidChild is %lu\n", sidParent, sidChild));
    msfMem(*ppitRetval = new CMSFIterator(GetDir(), sidChild));
    msfDebugOut((DEB_TRACE,"Leaving CMStream::GetIterator()\n"));

Err:
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CMStream::Init, public
//
//  Synposis:   Set up an mstream instance from an existing stream
//
//  Effects:    Modifies Fat and Directory
//
//  Arguments:  void.
//
//  Returns:    S_OK if call completed OK.
//              Error of Fat or Dir setup otherwise.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE  CMStream::Init(VOID)
{
    ULONG ulTemp;
    SCODE sc;
    ULARGE_INTEGER ulOffset;


    msfDebugOut((DEB_ITRACE,"In CMStream::Init()\n"));


    msfChk(InitCommon());


    ULISet32(ulOffset, 0);
    msfHChk((*_pplstParent)->ReadAt(ulOffset, (BYTE *)(&_hdr),
                                    sizeof(CMSFHeader), &ulTemp));
    _hdr.ByteSwap();  // swap to memory/machine format if neccessary

    _uSectorShift = _hdr.GetSectorShift();
    _uSectorSize = (USHORT) (1 << _uSectorShift);
    _uSectorMask = (USHORT) (_uSectorSize - 1);

    if (ulTemp != sizeof(CMSFHeader))
    {
        msfErr(Err,STG_E_INVALIDHEADER);
    }

    msfChk(_hdr.Validate());

    msfChk(_fatDif.Init(this, _hdr.GetDifLength()));
    msfChk(_fat.Init(this, _hdr.GetFatLength(), 0));

    FSINDEX fsiLen;
    msfChk(_fat.GetLength(_hdr.GetDirStart(), &fsiLen));
    msfChk(_dir.Init(this, fsiLen));

    msfChk(_fatMini.Init(this, _hdr.GetMiniFatLength(), 0));

    ULONG ulSize;
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));
    msfMem(_pdsministream = new CDirectStream(MINISTREAM_LUID));
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);

    msfDebugOut((DEB_TRACE,"Out CMStream::Init()\n"));

Err:
    return sc;
}



//+-------------------------------------------------------------------------
//
//  Member:     CMStream::InitNew, public
//
//  Synposis:   Set up a brand new mstream instance
//
//  Effects:    Modifies FAT and Directory
//
//  Arguments:  [fDelay] -- If TRUE, then the parent LStream
//                  will be truncated at the time of first
//                  entrance to COW, and no writes to the
//                  LStream will happen before then.
//
//  Returns:    S_OK if call completed OK.
//
//---------------------------------------------------------------------------

SCODE CMStream::InitNew(VOID)
{
    SCODE sc;

    msfDebugOut((DEB_ITRACE,"In CMStream::InitNew()\n"));


    msfChk(InitCommon());

    ULARGE_INTEGER ulTmp;

    ULISet32(ulTmp, 0);
    (*_pplstParent)->SetSize(ulTmp);

    msfChk(_fatDif.InitNew(this));
    msfChk(_fat.InitNew(this));
    msfChk(_dir.InitNew(this));

    msfChk(_fatMini.InitNew(this));
        
    ULONG ulSize;
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulSize));

    msfMem(_pdsministream = new CDirectStream(MINISTREAM_LUID));
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulSize);

        
    msfChk(Flush(0));
        

    msfDebugOut((DEB_TRACE,"Out CMStream::InitNew()\n"));
    return S_OK;

Err:
    Empty();

    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::ConvertILB, private
//
//  Synopsis:	Copy the first sector of the underlying ILockBytes
//                      out to the end.
//
//  Arguments:	[sectMax] -- Total number of sectors in the ILockBytes
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE  CMStream::ConvertILB(SECT sectMax)
{
    SCODE sc;
    BYTE *pb;
    USHORT cbNull;

    GetSafeBuffer(GetSectorSize(), GetSectorSize(), &pb, &cbNull);

    ULONG ulTemp;

    ULARGE_INTEGER ulTmp;
    ULISet32(ulTmp, 0);

    msfHChk((*_pplstParent)->ReadAt(ulTmp, pb, GetSectorSize(), &ulTemp));

    ULARGE_INTEGER ulNewPos;
    ULISet32(ulNewPos, sectMax << GetSectorShift());

    msfDebugOut((DEB_ITRACE,"Copying first sector out to %lu\n",
                 ULIGetLow(ulNewPos)));

    msfHChk((*_pplstParent)->WriteAt(
        ulNewPos,
        pb,
        GetSectorSize(),
        &ulTemp));

Err:
    FreeBuffer(pb);
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:     CMStream::InitConvert, public
//
//  Synopsis:   Init function used in conversion of files to multi
//              streams.
//
//  Arguments:  [fDelayConvert] -- If true, the actual file is not
//                                 touched until a BeginCopyOnWrite()
//
//  Returns:    S_OK if everything completed OK.
//
//  Algorithm:  *Finish This*
//
//  Notes:	We are allowed to fail here in low memory
//
//--------------------------------------------------------------------------

SCODE CMStream::InitConvert(VOID)
{
    SCODE sc;

    SECT sectMax;
    
    msfChk(InitCommon());

    STATSTG stat;
    (*_pplstParent)->Stat(&stat, STATFLAG_NONAME);
    msfAssert(ULIGetHigh(stat.cbSize) == 0);
    msfDebugOut((DEB_ITRACE,"Size is: %lu\n",ULIGetLow(stat.cbSize)));


    sectMax = (ULIGetLow(stat.cbSize) + GetSectorSize() - 1) >>
        GetSectorShift();

    SECT sectMaxMini;
    BOOL fIsMini;
    fIsMini = FALSE;

    //If the CONTENTS stream will be in the Minifat, compute
    //  the number of Minifat sectors needed.
    if (ULIGetLow(stat.cbSize) < MINISTREAMSIZE)
    {
        sectMaxMini = (ULIGetLow(stat.cbSize) + 
                       MINISECTORSIZE - 1) >> MINISECTORSHIFT;
        fIsMini = TRUE;
    }

    
    msfChk(_fatDif.InitConvert(this, sectMax));
    msfChk(_fat.InitConvert(this, sectMax));
    msfChk(_dir.InitNew(this));
    msfChk(fIsMini ? _fatMini.InitConvert(this, sectMaxMini)
           : _fatMini.InitNew(this));


    SID sid;

    msfChk(CreateEntry(SIDROOT, &dfnContents, STGTY_STREAM, &sid));
    msfChk(_dir.SetSize(sid, ULIGetLow(stat.cbSize)));

    if (!fIsMini)
        msfChk(_dir.SetStart(sid, sectMax - 1));
    else
    {
        msfChk(_dir.SetStart(sid, 0));
        msfChk(_dir.SetStart(SIDMINISTREAM, sectMax - 1));
        msfChk(_dir.SetSize(SIDMINISTREAM, ULIGetLow(stat.cbSize)));
    } 

    ULONG ulMiniSize;
    msfChk(_dir.GetSize(SIDMINISTREAM, &ulMiniSize));
    msfMem(_pdsministream = new CDirectStream(MINISTREAM_LUID));
    _pdsministream->InitSystem(this, SIDMINISTREAM, ulMiniSize);

    msfChk(ConvertILB(sectMax));

    msfChk(Flush(0));

    return S_OK;

Err:
    Empty();

    return sc;
}




//+-------------------------------------------------------------------------
//
//  Method:     CMStream::GetName, public
//
//  Synopsis:   Given a handle, return the current name of that entry
//
//  Arguments:  [sid] -- SID to find name for.
//
//  Returns:    Pointer to name.
//
//--------------------------------------------------------------------------


SCODE  CMStream::GetName(SID const sid, CDfName *pdfn)
{
    return _dir.GetName(sid, pdfn);
}


//+-------------------------------------------------------------------------
//
//  Method:     CMStream::FlushHeader, public
//
//  Synopsis:   Flush the header to the LStream.
//
//  Arguments:  [uForce] -- Flag to determine if header should be
//                          flushed while in copy on write mode.
//
//  Returns:    S_OK if call completed OK.
//              S_OK if the MStream is in copy on write mode or
//                  is Unconverted and the header was not flushed.
//
//  Algorithm:  Write the complete header out to the 0th position of
//              the LStream.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE  CMStream::FlushHeader(USHORT uForce)
{
    ULONG ulTemp;
    SCODE sc;

    UNREFERENCED_PARM(uForce);
    msfDebugOut((DEB_ITRACE,"In CMStream::FlushHeader()\n"));

    ULARGE_INTEGER ulOffset;
    ULISet32(ulOffset, 0);
    _hdr.ByteSwap(); // swap to disk format if neccessary
    sc = DfGetScode((*_pplstParent)->
		    WriteAt(ulOffset, (BYTE *)(&_hdr),
			    sizeof(CMSFHeader), &ulTemp));
    _hdr.ByteSwap(); // swap to memort/machine format if neccessary
    msfDebugOut((DEB_ITRACE,"Out CMStream::FlushHeader()\n"));
    return sc;
}





//+-------------------------------------------------------------------------
//
//  Member:     CMStream::MWrite, public
//
//  Synposis:   Do multiple sector writes
//
//  Effects:    Causes multiple stream writes.  Modifies fat and directory
//
//  Arguments:  [ph] -- Handle of stream doing write
//              [start] -- Starting sector to write
//              [oStart] -- offset into sector to begin write at
//              [end] -- Last sector to write
//              [oEnd] -- offset into last sector to write to
//              [buffer] -- Pointer to buffer into which data will be written
//              [ulRetVal] -- location to return number of bytes written
//
//  Returns:    Error code of any failed call to parent write
//              S_OK if call completed OK.
//
//  Modifies:   ulRetVal returns the number of bytes written
//
//  Algorithm:  Using a segment table, perform writes on parent stream
//              until call is completed.
//
//  Notes:
//
//---------------------------------------------------------------------------



SCODE CMStream::MWrite(
    SID sid,
    BOOL fIsMini,
    ULONG ulOffset,
    VOID const HUGEP *pvBuffer,
    ULONG ulCount,
    CStreamCache *pstmc,
    ULONG *pulRetval)
{
    SCODE sc;
    BYTE const HUGEP *pbBuffer = (BYTE const HUGEP *) pvBuffer;

    USHORT cbSector = GetSectorSize();
    CFat *pfat = &_fat;
    USHORT uShift = GetSectorShift();
    ULONG ulLastBytes = 0;

    ULARGE_INTEGER ulOff;
    ULISetHigh(ulOff, 0);

    ULONG ulOldSize = 0;
    
    //  Check if it's a small stream and whether this is a real 
    //  multistream.

    if ((fIsMini) &&
        (SIDMINISTREAM != sid))
    {
        msfAssert(sid <= MAXREGSID &&
                  aMsg("Invalid SID in MWrite"));
        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        pfat = GetMiniFat();
    }

    USHORT uMask = (USHORT) (cbSector - 1);

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    msfDebugOut((DEB_ITRACE,"In CMStream::MWrite(%lu,%u,%lu,%u)\n",
                 start,oStart,end,oEnd));

    ULONG bytecount;
    ULONG total = 0;

    msfChk(_dir.GetSize(sid, &ulOldSize));



    msfAssert(end != 0xffffffffL);

    if (end < start)
    {
        *pulRetval = total + ulLastBytes;
        goto Err;
    }

    ULONG ulRunLength;
    ulRunLength = end - start + 1;
    SECT sectSidStart;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        SSegment segtab[CSEG + 1];
        SECT sect;

        if (start > pstmc->GetOffset())
        {
            msfChk(pfat->GetESect(
                pstmc->GetSect(),
                start - pstmc->GetOffset(),
                &sect));
        }
        else if (start == pstmc->GetOffset())
        {
            sect = pstmc->GetSect();
        }
        else
        {
            msfChk(_dir.GetStart(sid, &sectSidStart));
            msfChk(pfat->GetESect(sectSidStart, start, &sect));
        }

        msfChk(pfat->Contig(
            (SSegment STACKBASED *) segtab,
            sect,
            ulRunLength));

        USHORT oend = (USHORT) (cbSector - 1);
        ULONG i;
        SECT sectStart;
        for (USHORT iseg = 0; iseg < CSEG;)
        {
            sectStart = segtab[iseg].sectStart;
            i = segtab[iseg].cSect;

            if (i > ulRunLength)
                i = ulRunLength;

            ulRunLength -= i;
            start += i;

            iseg++;
            if (segtab[iseg].sectStart == ENDOFCHAIN)
            {
                msfAssert(ulRunLength==0);
                oend = oEnd;
            }

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            msfDebugOut((
                DEB_ITRACE,
                "Calling lstream WriteAt(%lu,%p,%lu)\n",
                ConvertSectOffset(sectStart,offset,uShift),
                pbBuffer,
                ulSize));

            if (GetMiniFat() == pfat)
            {
                sc = _pdsministream->CDirectStream::WriteAt(
                    (sectStart << uShift) + offset,
                    pbBuffer, ulSize,
                    (ULONG STACKBASED *)&bytecount);
            }
            else
            {
                ULISetLow(ulOff, ConvertSectOffset(sectStart, offset,
                                                   uShift));
                sc = DfGetScode((*_pplstParent)->WriteAt(ulOff, pbBuffer,
                                                         ulSize, &bytecount));
            }

            total += bytecount;

            //Check if this write is the last one in the stream,
            //   and that the stream ends as a partial sector.
            //If so, fill out the remainder of the sector with
            //   something.
            if ((0 == ulRunLength) && (total + ulOffset > ulOldSize) &&
                (((total + ulOffset) & (GetSectorSize() - 1)) != 0))
            {
                //This is the last sector and the stream has grown.
                ULONG csectOld = (ulOldSize + GetSectorSize() - 1) >>
                    GetSectorShift();

                ULONG csectNew = (total + ulOffset + GetSectorSize() - 1) >>
                    GetSectorShift();

                if (csectNew > csectOld)
                {
                    msfAssert(!fIsMini &&
                              aMsg("Small stream grew in MWrite"));
                    
                    SECT sectLast = sectStart + i - 1;
                    
                    msfVerify(SUCCEEDED(SecureSect(
                        sectLast,
                        total + ulOffset,
                        FALSE)));
                }
            }
            
            if (0 == ulRunLength || FAILED(sc))
            {
                break;
            }

            pbBuffer = pbBuffer + bytecount;
            offset = 0;
        }

        pstmc->SetCache(start -1, sectStart + i - 1);
        
        if (0 == ulRunLength || FAILED(sc))
        {
            *pulRetval = total + ulLastBytes;
            msfDebugOut((
                DEB_TRACE,
                "Out CMStream::MWrite()=>%lu, retval = %lu\n",
                sc,
                total));
            break;
        }
    }

Err:
    //  We need this flush of the directory structures because we may have
    //  remapped the first sector in a chain.

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMStream::Flush, public
//
//  Synopsis:	Flush control structures.
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------


SCODE CMStream::Flush(BOOL fFlushCache)
{
    SCODE sc = S_OK;

    msfChk(_dir.Flush());
    msfChk(_fatMini.Flush());
    msfChk(_fat.Flush());
    msfChk(_fatDif.Flush());
    
    msfChk(FlushHeader(HDR_NOFORCE));
    msfChk(ILBFlush(*_pplstParent, fFlushCache));
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:   ILBFlush
//
//  Synopsis:   Flush as thoroughly as possible
//
//  Effects:    Flushes ILockBytes
//
//  Arguments:  [pilb]        - ILockBytes to flush
//              [fFlushCache] - Flush thoroughly iff TRUE
//
//  Returns:    SCODE
//
//  Algorithm:
//
//--------------------------------------------------------------------------

SCODE ILBFlush(ILockBytes *pilb, BOOL fFlushCache)
{    
    SCODE sc;
    UNREFERENCED_PARM(fFlushCache);  // no cache used here

    msfDebugOut((DEB_ITRACE, "In ILBFlushCache(%p)\n", pilb));

    sc = DfGetScode(pilb->Flush());

    msfDebugOut((DEB_ITRACE, "Out ILBFlushCache()\n"));

    return(sc);
}


//+---------------------------------------------------------------------------
//
//  Member:	CMStream::SecureSect, public
//
//  Synopsis:	Zero out the unused portion of a sector
//
//  Arguments:	[sect] -- Sector to zero out
//              [ulSize] -- Size of stream
//              [fIsMini] -- TRUE if stream is in ministream
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMStream::SecureSect(
    const SECT sect,
    const ULONG ulSize,
    const BOOL fIsMini)
{
    SCODE sc = S_OK;
    BYTE *pb = NULL;
    
    ULONG cbSect = fIsMini ? MINISECTORSIZE : GetSectorSize();
    
    msfAssert(ulSize != 0);
        
    ULONG ulOffset = ((ulSize - 1) % cbSect) + 1;
    
    ULONG cb = cbSect - ulOffset;
    
    msfAssert(cb != 0);
    
    // We can use any initialized block of memory here.  The header
    // is available and is the correct size, so we use that.
    pb = (BYTE *)&_hdr;

    ULONG cbWritten;
    
    if (!fIsMini)
    {
        ULARGE_INTEGER ulOff;
        // justify the casting later 
        msfAssert(ulOffset <= USHRT_MAX);  
        ULISet32(ulOff, 
                 ConvertSectOffset( sect, (USHORT) ulOffset,
                                    GetSectorShift()));
        
        msfChk(DfGetScode((*_pplstParent)->
                          WriteAt( ulOff, pb, cb, &cbWritten)));
    }
    else
    {
        msfChk(_pdsministream->WriteAt(
            (sect << MINISECTORSHIFT) + ulOffset,
            pb, cb, (ULONG STACKBASED *)&cbWritten));
    }
        
    if (cbWritten != cb)
    {
        sc = STG_E_WRITEFAULT;
    }
    
Err:
    
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\page.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	page.cxx
//
//  Contents:	Paging code for MSF
//
//  Classes:	Defined in page.hxx
//
//  Functions:	
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"



#include "mread.hxx"

//+---------------------------------------------------------------------
//
//  Member:	CMSFPage::Byteswap, public
//
//  Synopsis:	Byteswap the elments of the page
//
//  Algorithm:  Call the corresponding byteswap routine depending on the 
//              actual type of the Mutli-stream.
//
//----------------------------------------------------------------------

void CMSFPage::ByteSwap(void)
{
    CPagedVector* pVect = GetVector();
    if (pVect->GetParent()->GetHeader()->DiffByteOrder())
    {
        switch (_sid) 
        {
        case SIDDIR:
            ((CDirSect *)_ab)->
                ByteSwap( ((CDirVector*)pVect)->GetSectorSize() );        
        break;
        case SIDFAT:            
        case SIDMINIFAT:
        case SIDDIF:
            ((CFatSect *)_ab)->
                ByteSwap( ((CFatVector*)pVect)->GetSectBlock() );
            break;
        default:
            break;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable constructor.
//
//  Arguments:	[pmsParent] -- Pointer to multistream for this page table.
//
//  Notes:	
//
//----------------------------------------------------------------------------

CMSFPageTable::CMSFPageTable( CMStream *const pmsParent,
                              const ULONG cMinPages,
                              const ULONG cMaxPages)
    : _pmsParent(pmsParent), _cActivePages(0), _cPages(0),
      _pmpCurrent(NULL),
      _cbSector(pmsParent->GetSectorSize()),
      _cMinPages(cMinPages), _cMaxPages(cMaxPages),
      _cReferences(1)    
{
}

//+---------------------------------------------------------------------------
//
//  Member:	CMSFPage::CMSFPage, public
//
//  Synopsis:	CMSFPage default constructor
//
//----------------------------------------------------------------------------

CMSFPage::CMSFPage(CMSFPage *pmp)
{
    if (pmp == NULL)
    {
        SetChain(this, this);
    }
    else
    {
        SetChain(pmp->GetPrev(), pmp);
        GetPrev()->SetNext(this);
        GetNext()->SetPrev(this);
    }

    SetSid(NOSTREAM);
    SetOffset(0);
    SetSect(ENDOFCHAIN);
    SetFlags(0);
    SetVector(NULL);
    _cReferences = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::~CMSFPageTable, public
//
//  Synopsis:	CMSFPageTable destructor
//
//----------------------------------------------------------------------------

CMSFPageTable::~CMSFPageTable()
{
    if (_pmpCurrent != NULL)
    {
        CMSFPage *pmp = _pmpCurrent;
        CMSFPage *pmpNext;

        while (pmp != pmp->GetNext())
        {
            pmpNext = pmp->GetNext();
#if DBG == 1
            msfAssert(!pmp->IsInUse() &&
                    aMsg("Active page left at page table destruct time."));

#endif
            delete pmp;
            pmp = pmpNext;
        }
        delete pmp;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Init, public
//
//  Synopsis:	Initialize a CMSFPageTable
//
//  Arguments:	[cPages] -- Number of pages to preallocate.
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Init(void)
{
    SCODE sc = S_OK;

    msfDebugOut((DEB_ITRACE, "In  CMSFPageTable::Init:%p()\n", this));

    for (ULONG i = 0; i < _cMinPages; i++)
    {
        CMSFPage *pmp;

        msfMem(pmp = GetNewPage());
        _pmpCurrent = pmp;
    }
    _cPages = _cMinPages;
    _cActivePages = 0;

    msfDebugOut((DEB_ITRACE, "Out CMSFPageTable::Init\n"));

 Err:

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FlushPage, public
//
//  Synopsis:	Flush a page
//
//  Arguments:	[pmp] -- Pointer to page to flush
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FlushPage(CMSFPage *pmp)
{
    SCODE sc = S_OK;

    pmp->AddRef();

    CMStream *pms;
    pms = pmp->GetVector()->GetParent();

    //Flush the page, reset the dirty bit.

    msfAssert((pmp->GetSect() != ENDOFCHAIN) &&
            aMsg("Page location not set - don't know where to flush to."));

    ULONG ulRet;

    ILockBytes *pilb;
    ULARGE_INTEGER ul;
    ULISet32(ul, ConvertSectOffset(
            pmp->GetSect(),
            0,
            pms->GetSectorShift()));

    pilb = pms->GetILB();

    pmp->ByteSwap();            // convert to disk format 
                                // (if neccessary)                 
    msfHChk(pilb->WriteAt(
            ul,
            (BYTE *)(pmp->GetData()),
            _cbSector,
            &ulRet));
    
    pmp->ByteSwap();            // convert to back to machine format 
                                // (if neccessary)
    pmp->ResetDirty();

 Err:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetFreePage, public
//
//  Synopsis:	Return a pointer to a free page.
//
//  Arguments:	[ppmp] -- Pointer to storage for return pointer
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetFreePage(CMSFPage **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;
    if (_cPages > _cActivePages)
    {
        //We have some unused page already allocated.  Find and return it.
        pmp = _pmpCurrent;

        do
        {
            pmp = pmp->GetNext();
        }
        while ((pmp != _pmpCurrent) && (pmp->GetSid() != NOSTREAM));

        msfAssert((pmp->GetSid() == NOSTREAM) &&
                aMsg("Expected empty page, none found."));

        *ppmp = pmp;
        _cActivePages++;
    }
    else if (_cPages == _cMaxPages)
    {
        msfMem(pmp = FindSwapPage());
        msfDebugOut((DEB_IERROR, "Got swap page %p\n",pmp));

        msfAssert((pmp->GetVector() != NULL) &&
                aMsg("FindSwapPage returned unowned page."));

        msfDebugOut((DEB_IERROR, "Freeing page %lu from vector %p\n",
                pmp->GetOffset(), pmp->GetVector()));


        if (pmp->IsDirty())
        {
            msfChk(FlushPage(pmp));
            msfAssert(!pmp->IsDirty() &&
                    aMsg("Page remained dirty after flush call"));
        }

        pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
        pmp->SetVector(NULL);
#endif
        *ppmp = pmp;
    }
    else
    {
        //Create a new page and return it.
        pmp = GetNewPage();
        if (pmp != NULL)
        {
            *ppmp = pmp;
            _cActivePages++;
            _cPages++;
        }
        else
        {
            msfMem(pmp = FindSwapPage());
            if (pmp->IsDirty())
            {
                msfChk(FlushPage(pmp));
                msfAssert(!pmp->IsDirty() &&
                        aMsg("Page remained dirty after flush call"));
            }
            pmp->GetVector()->FreeTable(pmp->GetOffset());
#if DBG == 1
            pmp->SetVector(NULL);
#endif
            *ppmp = pmp;
        }
    }

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:  [ppv] -- Pointer to vector of page to return
//              [sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::FindPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        CMSFPage **ppmp)
{
    SCODE sc;
    CMSFPage *pmp = _pmpCurrent;

    do
    {
        if ((pmp->GetVector() == ppv) && (pmp->GetOffset() == ulOffset))
        {
            //Bingo!

            *ppmp = pmp;
            return STG_S_FOUND;
        }

        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

    //The page isn't currently in memory.  Get a free page and
    //bring it into memory.

    msfChk(GetFreePage(&pmp));

    msfAssert((pmp->GetVector() == NULL) &&
            aMsg("Attempting to reassign owned page."));
    pmp->SetVector(ppv);
    pmp->SetSid(sid);
    pmp->SetOffset(ulOffset);
    pmp->SetSect(ENDOFCHAIN);

    *ppmp = pmp;

 Err:
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::GetPage, public
//
//  Synopsis:	Find and return a given page
//
//  Arguments:	[sid] -- SID of page to return
//              [ulOffset] -- Offset of page to return
//              [ppmp] -- Location to return pointer
//
//  Returns:	Appropriate status code
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::GetPage(
        CPagedVector *ppv,
        SID sid,
        ULONG ulOffset,
        CMSFPage **ppmp)
{
    SCODE sc;

    *ppmp = NULL;
    msfChk(FindPage(ppv, sid, ulOffset, ppmp));

    (*ppmp)->AddRef();

    if (sc != STG_S_FOUND)
    {
        ULONG ulRet;
        SECT sect;

        msfChk(ppv->GetParent()->GetSect(sid, ulOffset, &sect));
        (*ppmp)->SetSect(sect);

        CMStream *pms = (*ppmp)->GetVector()->GetParent();
        
        ULARGE_INTEGER ul;
        ULISet32(ul, ConvertSectOffset(
                (*ppmp)->GetSect(),
                0,
                pms->GetSectorShift()));

        msfAssert(pms->GetILB() != NULL &&
                  aMsg("NULL ILockBytes - missing SetAccess?"));

        msfHChk(pms->GetILB()->ReadAt(ul, (BYTE *)((*ppmp)->GetData()),
                _cbSector, &ulRet));
        (*ppmp)->ByteSwap();
    }

 Err:
    if (*ppmp != NULL)
    {
        (*ppmp)->Release();
    }

    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::ReleasePage, public
//
//  Synopsis:	Release a given page
//
//  Arguments:	[sid] -- SID of page to release
//              [ulOffset] -- Offset of page to release
//
//----------------------------------------------------------------------------

void CMSFPageTable::ReleasePage(CPagedVector *ppv, SID sid, ULONG ulOffset)
{
    SCODE sc;
    CMSFPage *pmp;

    sc = FindPage(ppv, sid, ulOffset, &pmp);

    if (SUCCEEDED(sc))
    {
        pmp->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::Flush, public
//
//  Synopsis:	Flush dirty pages to disk
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CMSFPageTable::Flush(void)
{
    SCODE sc = S_OK;

    CMSFPage *pmp = _pmpCurrent;

    //We use pmpLast in case FlushPage changes _pmpCurrent.
    CMSFPage *pmpLast = _pmpCurrent;

    do
    {
        if ((pmp->IsDirty()) && !(pmp->IsInUse()))
        {
            msfChk(FlushPage(pmp));
        }

        pmp = pmp->GetNext();

    }
    while (pmp != pmpLast);

 Err:
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FreePages, public
//
//  Synopsis:	Free all the pages associated with a vector.
//
//  Arguments:	[ppv] -- Pointer to vector to free pages for.
//
//----------------------------------------------------------------------------

void CMSFPageTable::FreePages(CPagedVector *ppv)
{
    CMSFPage *pmp = _pmpCurrent;

    do
    {
        if (pmp->GetVector() == ppv)
        {
            pmp->SetSid(NOSTREAM);
            pmp->SetVector(NULL);
            pmp->ResetDirty();
            _cActivePages--;
        }
        pmp = pmp->GetNext();
    }
    while (pmp != _pmpCurrent);

}


//+---------------------------------------------------------------------------
//
//  Member:	CMSFPageTable::FindSwapPage, private
//
//  Synopsis:	Find a page to swap out.
//
//  Arguments:	None.
//
//  Returns:	Pointer to page to swap out.
//
//----------------------------------------------------------------------------

CMSFPage * CMSFPageTable::FindSwapPage(void)
{
#if DBG == 1
    ULONG cpInUse = 0;
#endif

    while (TRUE)
    {
        if (!_pmpCurrent->IsInUse())
        {
            DWORD dwFlags;

            dwFlags = _pmpCurrent->GetFlags();
            _pmpCurrent->SetFlags(dwFlags & ~FB_TOUCHED);
            _pmpCurrent = _pmpCurrent->GetNext();

            if (!(dwFlags & FB_TOUCHED))
            {
                return _pmpCurrent->GetPrev();
            }
        }
        else
        {
            _pmpCurrent = _pmpCurrent->GetNext();
        }
#if DBG == 1
        cpInUse++;
        msfAssert((cpInUse < 3 * _cPages) &&
                aMsg("No swappable pages."));
#endif

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\rexpdf.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       rpubdf.cxx
//
//  Contents:   CRootPubDocFile implementation
//
//---------------------------------------------------------------

#include "dfhead.cxx"

#include "h/header.hxx"
#include "h/rexpdf.hxx"
#include "dfbasis.hxx"
#include "h/tchar.h"

// Priority mode lock permissions
#define PRIORITY_PERMS DF_READ

//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::CRootExposedDocFile, public
//
//  Synopsis:   Ctor - Initializes empty object
//
//---------------------------------------------------------------


CRootExposedDocFile::CRootExposedDocFile(CDFBasis *pdfb) :
    CExposedDocFile(NULL, NULL, 0, ROOT_LUID, NULL, NULL, NULL, pdfb)
{
    olDebugOut((DEB_ITRACE, "CRootExposedDocFile constructor called\n"));
}


//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::Init, private
//
//  Synopsis:   Dependent root initialization
//
//  Arguments:  [plstBase] - Base
//              [snbExclude] - Limited instantiation exclusions
//              [dwStartFlags] - Startup flags
//
//  Returns:    Appropriate status code
//
//---------------------------------------------------------------

SCODE CRootExposedDocFile::Init( ILockBytes *plstBase,
                                 SNBW snbExclude,
                                 DWORD const dwStartFlags)
{
    CDocFile *pdf;
    SCODE sc;
    CMStream *pms;

    olDebugOut((DEB_ITRACE, "In  CRootExposedDocFile::Init()\n"));
    if (snbExclude)
    {
        olChk(DllMultiStreamFromStream(&pms, &plstBase, dwStartFlags));
        olMemTo(EH_pms,
                pdf = new CDocFile(pms, SIDROOT, ROOT_LUID, _pilbBase));
        pdf->AddRef();
        olChkTo(EH_pdf, pdf->ExcludeEntries(pdf, snbExclude));
        olChkTo(EH_pdf, pms->Flush(0));
        pdf->Release();
    }
    plstBase->AddRef();
    _pilbBase = plstBase;
    olDebugOut((DEB_ITRACE, "Out CRootExposedDocFile::Init()\n"));
    return S_OK;

EH_pdf:
    pdf->Release();
EH_pms:
    DllReleaseMultiStream(pms);
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::InitRoot, public
//
//  Synopsis:   Initialising a root storage
//
//  Arguments:  [plstBase] - Base LStream
//              [dwStartFlags] - How to start things
//              [df] - Transactioning flags
//              [snbExclude] - Parital instantiation list
//              [ppdfb] - Basis pointer return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdfb]
//
//---------------------------------------------------------------

SCODE CRootExposedDocFile::InitRoot( ILockBytes *plstBase,
                                     DWORD const dwStartFlags,
                                     DFLAGS const df,
                                     SNBW snbExclude)
{
    CDocFile *pdfBase;
    SCODE sc, scConv = S_OK;
    STATSTG statstg;

    olDebugOut((DEB_ITRACE, "In  CRootExposedDocFile::InitRoot("
                "%p, %lX, %lX, %p)\n",
                plstBase, dwStartFlags, df, snbExclude));    

    // Exclusion only works with a plain open
    olAssert(snbExclude == NULL ||
             (dwStartFlags & (RSF_CREATEFLAGS | RSF_CONVERT)) == 0);

    olHChk(plstBase->Stat(&statstg, STATFLAG_NONAME));

    olChkTo(EH_GetPriority,    
            Init(plstBase, snbExclude, dwStartFlags));    
    
    scConv = DllMultiStreamFromStream(&_pmsBase, &_pilbBase,
                                      dwStartFlags);
    if (scConv == STG_E_INVALIDHEADER)
        scConv = STG_E_FILEALREADYEXISTS;
    olChkTo(EH_pfstScratchInit, scConv);
    
    olMemTo(EH_pmsBase,
            pdfBase = new CDocFile(_pmsBase, SIDROOT, ROOT_LUID, _pilbBase));

    pdfBase->AddRef();
    
    _pdf = pdfBase;
    _df = df;
    olDebugOut((DEB_ITRACE, "Out CRootExposedDocFile::InitRoot\n"));
    return scConv;    
    
EH_pmsBase:
    DllReleaseMultiStream(_pmsBase);

EH_pfstScratchInit:
EH_GetPriority:
EH_Err:
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::~CRootExposedDocFile, 
//                                      public virutal
//
//  Synopsis:   dtor (virtual)
//
//---------------------------------------------------------------


CRootExposedDocFile::~CRootExposedDocFile(void)
{
    olDebugOut((DEB_TRACE, "In CRootExposedDocFile::~CRootExposedDocFile\n"));

    olAssert(_cReferences == 0);

    if (SUCCEEDED(CheckReverted()))
    {
        if (_pilbBase) {
            _pilbBase->Release();
            _pilbBase = NULL;
        }
    }
    olDebugOut((DEB_TRACE, "Out CRootExposedDocFile::~CRootExposedDocFile\n"));
}

//+-------------------------------------------------------------------
//
//  Member:     CRootExposedDocFile::Stat, public 
//                                         virtual fr. CExposedDocFile
//
//  Synopsis:   Fills in a stat buffer from the base LStream
//
//  Arguments:  [pstatstg] - Stat buffer
//              [grfStatFlag] - Stat flags
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//--------------------------------------------------------------------


SCODE CRootExposedDocFile::Stat(STATSTGW *pstatstgw, DWORD grfStatFlag)
{
    SCODE sc;
    STATSTG *pstatstg= (STATSTG*)pstatstgw;

    olDebugOut((DEB_ITRACE, "In  CRootExposedDocFile::Stat(%p, %lu)\n",
                pstatstg, grfStatFlag));
    olChk(ValidateOutBuffer(pstatstg, sizeof(STATSTGW)));
    olChk(VerifyStatFlag(grfStatFlag));
    olChk(CheckReverted());
    olHChk(_pilbBase->Stat(pstatstg, grfStatFlag));    
    pstatstg->type = STGTY_STORAGE;
    ULISet32(pstatstg->cbSize, 0);  //  size undefined for storage obj
    pstatstg->grfLocksSupported = 0;
    pstatstg->reserved = 0;
    if (pstatstg->pwcsName)
    {
        // pilbBase returns either wide or ansi names depending on
        // system type, so we have to convert to ANSI char if neccessay
        WCHAR *pwcs;
        olChkTo(EH_pwcsName,
                DfAllocWC(_tcslen(pstatstg->pwcsName)+1, &pwcs));
        TTOW(pstatstg->pwcsName, pwcs, _tcslen(pstatstg->pwcsName)+1);
        delete[] pstatstg->pwcsName;
        pstatstgw->pwcsName = pwcs;
    }
    pstatstg->grfMode = DFlagsToMode(_df);
    olChkTo(EH_pwcsName, _pdf->GetClass(&pstatstg->clsid));
    olChkTo(EH_pwcsName, _pdf->GetStateBits(&pstatstg->grfStateBits));
    olDebugOut((DEB_ITRACE, "Out CRootExposedDocFile::Stat\n"));
    return S_OK;

EH_pwcsName:
    if (pstatstg->pwcsName)
    delete[] pstatstg->pwcsName;
EH_Err:
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\sstream.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:           sstream.cxx
//
//  Contents:       Stream operations for Mstream project
//
//  Classes:        None. (defined in sstream.hxx)
//
//--------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/dirfunc.hxx"
#include "h/sstream.hxx"
#include <time.h>
#include "mread.hxx"

#define DEB_STREAM (DEB_ITRACE | 0x00020000)


//+--------------------------------------------------------------
//
//  Member:	CDirectStream::CDirectStream, public
//
//  Synopsis:	Empty object constructor
//
//  Arguments:  [dl] - LUID
//
//---------------------------------------------------------------

CDirectStream::CDirectStream(DFLUID dl)
    : PEntry(dl) 
{
    _cReferences = 0;
}


//+--------------------------------------------------------------
//
//  Member:	CDirectStream::InitSystem, public
//
//  Synopsis:	Initializes special system streams like the ministream
//
//  Arguments:	[pms] - Multistream
//		[sid] - SID
//		[cbSize] - size
//
//---------------------------------------------------------------

void CDirectStream::InitSystem(CMStream *pms,
			       SID sid,
			       ULONG cbSize)
{
    _stmh.Init(pms, sid);
    _ulSize = _ulOldSize = cbSize;
    AddRef();
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::Init, public
//
//  Synopsis:   CDirectStream constructor
//
//  Arguments:  [pstgh] - Parent
//		[pdfn] - Name of entry
//		[fCreate] - Create or get
//
//  Returns:	Appropriate status code
//
//--------------------------------------------------------------------------

SCODE CDirectStream::Init(
        CStgHandle *pstgh,
        CDfName const *pdfn,
        BOOL const fCreate)
{
    SCODE sc;

    if (fCreate)
        sc = pstgh->CreateEntry(pdfn, STGTY_STREAM, &_stmh);
    else
        sc = pstgh->GetEntry(pdfn, STGTY_STREAM, &_stmh);
    if (SUCCEEDED(sc))
    {
	sc = _stmh.GetSize(&_ulSize);
	_ulOldSize = _ulSize;
        if (SUCCEEDED(sc))
            AddRef();
    }
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CDirectStream::~CDirectStream, public
//
//  Synopsis:   CDirectStream destructor
//
//  Notes:
//
//--------------------------------------------------------------------------

CDirectStream::~CDirectStream()
{
    msfAssert(_cReferences == 0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::ReadAt, public
//
//  Synposis:   Reads binary data from a linear single stream
//
//  Arguments:  [ulOffset] -- Position to be read from
//
//              [pBuffer] -- Pointer to the area into which the data
//                           will be read.
//              [ulCount] --  Indicates the number of bytes to be read
//              [pulRetval] -- Area into which return value will be stored
//
//  Returns:    Error Code of parent MStream call
//
//  Algorithm:  Calculate start and end sectors and offsets, then
//              pass call up to parent MStream.
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CDirectStream::ReadAt(
        ULONG ulOffset,
        VOID HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::ReadAt(%lu,%p,%lu)\n",
                           ulOffset,pBuffer,ulCount));

    SCODE sc = S_OK;

    CMStream *pms = _stmh.GetMS();


    //  Check for offset beyond stream size and zero count

    if ((ulOffset >= _ulSize) || (0 == ulCount))
    {
        *pulRetval = 0;
        return S_OK;
    }

    if (ulOffset + ulCount > _ulSize)
    {
        msfDebugOut((DEB_ITRACE,"Truncating Read: ulOffset = %lu, ulCount = %lu, _ulSize = %lu\n",
                                ulOffset,ulCount,_ulSize));
        ulCount = _ulSize - ulOffset;
    }


    //  Stream is stored in ministream if size < MINISTREAMSIZE
    //  and this is not a scratch stream.


    SID sid = _stmh.GetSid();
    CFat *pfat = pms->GetFat();
    USHORT cbSector = pms->GetSectorSize();
    USHORT uShift = pms->GetSectorShift();
    USHORT uMask = pms->GetSectorMask();



    if ((_ulSize < MINISTREAMSIZE) &&
        (sid != SIDMINISTREAM))
    {
        msfAssert(sid <= MAXREGSID);

        //  This stream is stored in the ministream

        cbSector = MINISECTORSIZE;
        uShift = MINISECTORSHIFT;
        uMask = (USHORT) (cbSector - 1);
        pfat = pms->GetMiniFat();
    }

    SECT start = (SECT)(ulOffset >> uShift);
    OFFSET oStart = (OFFSET)(ulOffset & uMask);

    SECT end = (SECT)((ulOffset + ulCount - 1) >> uShift);
    OFFSET oEnd = (OFFSET)((ulOffset + ulCount - 1) & uMask);

    ULONG total = 0;

    ULONG cSect = end - start + 1;

    SECT sectSidStart;

    USHORT offset;
    offset = oStart;

    while (TRUE)
    {
        SECT sect;
        
        if (start > _stmc.GetOffset())
        {
            msfChk(pfat->GetSect(
                    _stmc.GetSect(),
                    start - _stmc.GetOffset(),
                    &sect));
        }
        else if (start == _stmc.GetOffset())
        {
            sect = _stmc.GetSect();
        }
        else
        {
            msfChk(pms->GetDir()->GetStart(sid, &sectSidStart));
            msfChk(pfat->GetSect(sectSidStart, start, &sect));
        }

        SSegment segtab[CSEG + 1];

        msfChk(pfat->Contig(
            (SSegment STACKBASED *) segtab,
            sect,
            cSect));

        USHORT oend = (USHORT) (cbSector - 1);
        for (USHORT iseg = 0; iseg < CSEG;)
        {
            msfDebugOut((DEB_ITRACE,"Segment:  (%lu,%lu)\n",segtab[iseg].sectStart,segtab[iseg].cSect));
            SECT sectStart = segtab[iseg].sectStart;
            ULONG i = segtab[iseg].cSect;
            cSect -= i;
            start += i;

            iseg++;
            if (segtab[iseg].sectStart == ENDOFCHAIN)
                oend = oEnd;

            ULONG ulSize = ((i - 1) << uShift) - offset + oend + 1;

            ULONG bytecount;
            SCODE sc;

            if (pms->GetMiniFat() == pfat)
            {
                sc = pms->GetMiniStream()->CDirectStream::ReadAt(
                                            (sectStart << uShift) + offset,
                                             pBuffer, ulSize,
					    (ULONG STACKBASED *)&bytecount);
            }
            else
            {
                ULARGE_INTEGER ulOffset;
                ULISet32(ulOffset, ConvertSectOffset(sectStart,offset,uShift));
                sc = DfGetScode(pms->GetILB()->ReadAt(ulOffset,
                                                      (BYTE *)pBuffer, ulSize,
                                                      &bytecount));
            }

            total += bytecount;
            if ((0 == cSect) || (FAILED(sc)))
            {
                _stmc.SetCache(start - 1, sectStart + i - 1);
                *pulRetval = total;
                msfDebugOut((DEB_TRACE,
                    "Leaving CDirectStream::ReadAt()=>%lu, ret is %lu\n",
                     sc,*pulRetval));
                return sc;
            }

            pBuffer = (BYTE HUGEP *)pBuffer + bytecount;
            offset = 0;
        }
    }

    msfDebugOut((DEB_ERROR,"In CDirectStream::ReadAt - reached end of function\n"));
Err:
    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::Write, public
//
//  Synposis:   Writes binary data from a linear single stream
//
//  Effects:    Modifies _ulSeekPos.  May cause modification in parent
//                  MStream.
//
//  Arguments:  [pBuffer] -- Pointer to the area from which the data
//                           will be written.
//              [ulCount] --  Indicates the number of bytes to be written
//              [pulRetval] -- Pointer to area in which number of bytes
//                              will be returned
//
//  Returns:    Error code of MStream call.
//
//  Algorithm:  Calculate sector and offset for beginning and end of
//              write, then pass call up to MStream.
//
//
//  Notes:
//
//---------------------------------------------------------------------------


SCODE CDirectStream::WriteAt(
        ULONG ulOffset,
        VOID const HUGEP *pBuffer,
        ULONG ulCount,
        ULONG STACKBASED *pulRetval)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::WriteAt(%lu,%p,%lu)\n",ulOffset,pBuffer,ulCount));

    *pulRetval = 0;

    if (0 == ulCount)
        return S_OK;

    SCODE sc;
    
    if (ulOffset + ulCount > _ulSize)
    {
        if (_ulSize > MINISTREAMSIZE)
        {
        }
        else
        {
            msfChk(SetSize(ulOffset + ulCount));
        }
    }

    CMStream *pms;
    pms = _stmh.GetMS();
    msfAssert(pms != NULL);

    //  This should be an inline call to MWrite

    msfChk(pms->MWrite(
            _stmh.GetSid(),
            (_ulSize < MINISTREAMSIZE),
            ulOffset,
            pBuffer,
            ulCount,
            &_stmc,
            pulRetval));

    msfAssert(*pulRetval == ulCount);

    msfDebugOut((DEB_TRACE,"Leaving CDirectStream::WriteAt()==>%lu, ret is %lu\n",sc,*pulRetval));

Err:
    if (ulOffset + *pulRetval > _ulSize)
    {
        SCODE scSet;
        
        _ulSize = ulOffset + *pulRetval;
        scSet = pms->GetDir()->SetSize(_stmh.GetSid(), _ulSize);
        if (SUCCEEDED(sc) && FAILED(scSet))
        {
            sc = scSet;
        }
    }
    
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Member:     CDirectStream::SetSize, public
//
//  Synposis:   Set the size of a linear stream
//
//  Effects:    Modifies _ulSize.  May cause change in parent MStream.
//
//  Arguments:  [ulNewSize] -- New size for stream
//
//  Returns:    Error code returned by MStream call.
//
//  Algorithm:  Pass call up to parent.
//
//  Notes:      When changing the size of a stream, we need to be concerned
//              with the cases where each stream is either zero length,
//  stored in the ministream, or stored in a regular stream.  The following
//  grid shows the actions that we must perform in each case:
//
//                      New Sector Count (Cn)
//
//                      0               S               L
//      O       ------------------------------------------------
//      l       | same size     | allocate Cn   | allocate Cn
//      d   0   |  (fast out)   | small sectors | large sectors
//              ------------------------------------------------
//      S       | small         | Co > Cn:      | cbCopy = cbOld
//      e   S   |  setchain(Cn) |  small        | large allocate Cn
//      c       |               |   setchain(Cn)| copy bytes
//      t       |               | Cn > Co:      | small setchain(0)
//      o       |               |  extend small | copy data
//      r       ------------------------------------------------
//          L   | large         | cbCopy = cbNew| Co > Cn:
//      C       |  setchain(Cn) | small         |  large setchain(Cn)
//      o       |               |  allocate Cn  | Cn > Co:
//      u       |               | copy bytes    |  extend large
//      n       |               | large         |
//      t       |               |  setchain(0)  |
//              |               | copy data     |
//     (Co)     ------------------------------------------------
//
//  where S indicates small sectors, L indicates large sectors, and Cx
//  represents count of sectors.  For example, the middle box represents
//  doing a setsize on a stream which is currently stored in a small
//  stream in Co small sectors and which will end up in a large stream
//  with Cn sectors.
//
//---------------------------------------------------------------------------


SCODE CDirectStream::SetSize(ULONG cbNewSize)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::SetSize(%lu)\n",cbNewSize));

    SCODE sc = S_OK;
    BYTE *pBuf = NULL;
    SID sid = _stmh.GetSid();
    CMStream *pms = _stmh.GetMS();
    msfAssert(sid <= MAXREGSID);
    CDirectory *pdir = pms->GetDir();
    SECT sectOldStart;
    
    if (_ulSize == cbNewSize)
    {
        return S_OK;
    }

    USHORT cbpsOld = pms->GetSectorSize();
                                        //  Count of Bytes Per Sector
    USHORT cbpsNew = cbpsOld;
    CFat *pfatOld = pms->GetFat();
    CFat *pfatNew = pfatOld;

    if (SIDMINISTREAM != sid)
    {

        if (cbNewSize < MINISTREAMSIZE)
        {
            cbpsNew = MINISECTORSIZE;
            pfatNew = pms->GetMiniFat();
        }

        if (_ulSize < MINISTREAMSIZE)
        {
            cbpsOld = MINISECTORSIZE;
            pfatOld = pms->GetMiniFat();
        }
    }

    ULONG csectOld = (ULONG)(_ulSize + cbpsOld - 1) / (ULONG) cbpsOld;
    ULONG csectNew = (ULONG)(cbNewSize + cbpsNew - 1) / (ULONG) cbpsNew;

    msfAssert(sid <= MAXREGSID);
    SECT sectstart;
    msfChk(pdir->GetStart(sid, &sectstart));

    msfDebugOut((DEB_ITRACE,"pdbOld size is %lu\n\tSid is %lu\n\tStart is %lu\n",
                _ulSize,sid,sectstart));
    msfDebugOut((DEB_ITRACE,"CMStream::SetSize() needs %lu %u byte sectors\n",
                 csectNew, cbpsNew));
    msfDebugOut((DEB_ITRACE,"SetSize() currently has %lu %u byte sectors\n",
                 csectOld, cbpsOld));

    USHORT cbCopy;
    cbCopy = 0;
    if (cbpsOld != cbpsNew)
    {
        //  Sector sizes are different, so we'll copy the data
        msfAssert((cbNewSize > _ulSize ? _ulSize : cbNewSize) < 0x10000);
        cbCopy =(USHORT)(cbNewSize > _ulSize ? _ulSize : cbNewSize);
    }


    if (cbCopy > 0)
    {
        msfDebugOut((DEB_ITRACE,"Copying between fat and minifat\n"));
        GetSafeBuffer(cbCopy, cbCopy, &pBuf, &cbCopy);
        msfAssert((pBuf != NULL) && aMsg("Couldn't get scratch buffer"));

        ULONG ulRetVal;
        sc = ReadAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal);
        if ((FAILED(sc)) ||
            ((ulRetVal != cbCopy) ? (sc = STG_E_UNKNOWN) : 0))
        {
            msfErr(Err, sc);
        }

        //The cache is no longer valid, so empty it.
        _stmc.SetCache(MAX_ULONG, ENDOFCHAIN);
        
        //Save start sector so we can free it later.
        sectOldStart = sectstart;
        
        msfChk(pfatNew->Allocate(csectNew, &sectstart));
    }
    else
    {
        SECT dummy;

        if ((csectOld > csectNew))
        {
            msfChk(pfatOld->SetChainLength(sectstart, csectNew));
            if (0 == csectNew)
            {
                sectstart = ENDOFCHAIN;
            }

            //If this turns out to be a common case, we can
            //   sometimes keep the cache valid here.
            _stmc.SetCache(MAX_ULONG, ENDOFCHAIN);
        }
        else if (0 == csectOld)
        {
            msfAssert(_stmc.GetOffset() == MAX_ULONG);
            msfChk(pfatNew->Allocate(csectNew, &sectstart));
        }
        else if (csectNew > csectOld)
        {
            ULONG start = csectNew - 1;

            if (start > _stmc.GetOffset())
            {
                msfChk(pfatNew->GetESect(
                        _stmc.GetSect(),
                        start - _stmc.GetOffset(),
                        &dummy));
            }
            else if (start != _stmc.GetOffset())
            {
                msfChk(pfatNew->GetESect(sectstart, start, &dummy));
            }
        }
    }


    //  Resize the ministream, if necessary
    if (((MINISECTORSIZE == cbpsOld) && (csectOld > 0)) ||
        ((MINISECTORSIZE == cbpsNew) && (csectNew > 0)))
    {
        msfChk(pms->SetMiniSize());
    }
    
    msfChk(pms->SetSize());

    //If we fail on either of these operations and cbCopy != 0,
    //   we will have data loss.  Ick.
    msfChk(pdir->SetStart(sid, sectstart));

    //If we fail here, were in trouble.
    msfChk(pdir->SetSize(sid, cbNewSize));

    _ulSize = cbNewSize;

    if (cbCopy > 0)
    {
        //  now copy the data
        ULONG ulRetVal;

        msfAssert(cbCopy <= _ulSize);
        msfChk(WriteAt(0, pBuf, cbCopy, (ULONG STACKBASED *)&ulRetVal));

        if (ulRetVal != cbCopy)
        {
            msfErr(Err, STG_E_UNKNOWN);
        }

        msfChk(pfatOld->SetChainLength(sectOldStart, 0));
        msfChk(pms->SetMiniSize());
        msfChk(pms->SetSize());
    }

    if (((csectNew > csectOld) || (cbCopy > 0)) &&
        ((cbNewSize & (cbpsNew - 1)) != 0))
    {
        SECT sectLast;
        if (csectNew - 1 > _stmc.GetOffset())
        {
            msfChk(pfatNew->GetSect(
                    _stmc.GetSect(),
                    (csectNew - 1) - _stmc.GetOffset(),
                    &sectLast));
        }
        else
        {
            msfChk(pfatNew->GetSect(sectstart, csectNew - 1, &sectLast));
        }
            
        msfVerify(SUCCEEDED(pms->SecureSect(
                sectLast,
                cbNewSize,
                (cbNewSize < MINISTREAMSIZE) && (sid != SIDMINISTREAM))));
    }
Err:
    FreeBuffer(pBuf);
    return sc;
}



//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::Release, public
//
//  Synopsis:	Decrements the ref count and frees if necessary
//
//----------------------------------------------------------------------------


void CDirectStream::Release(VOID)
{
    msfDebugOut((DEB_TRACE,"In CDirectStream::Release()\n"));
    msfAssert(_cReferences > 0);

    AtomicDec(&_cReferences);
    if (_cReferences == 0)
        delete this;
    msfDebugOut((DEB_TRACE,"Out CDirectStream::Release()\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CDirectStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//---------------------------------------------------------------


void CDirectStream::AddRef(void)
{
    msfDebugOut((DEB_ITRACE, "In  CDirectStream::AddRef()\n"));
    AtomicInc(&_cReferences);
    msfDebugOut((DEB_ITRACE, "Out CDirectStream::AddRef, %lu\n",
                 _cReferences));
}

//+---------------------------------------------------------------------------
//
//  Member:	CDirectStream::GetSize, public
//
//  Synopsis:	Gets the size of the stream
//
//  Arguments:	[pulSize] - Size return
//
//  Modifies:	[pulSize]
//
//----------------------------------------------------------------------------

void CDirectStream::GetSize(ULONG *pulSize)
{
    *pulSize = _ulSize;
}

//+--------------------------------------------------------------
//
//  Member:	CDirectStream::GetTime, public
//
//  Synopsis:	Gets a time
//
//  Arguments:	[wt] - Which time
//		[ptm] - Time return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[ptm]
//
//---------------------------------------------------------------

SCODE CDirectStream::GetTime(WHICHTIME wt, TIME_T *ptm)
{
    return _stmh.GetTime(wt, ptm);
}

//+--------------------------------------------------------------
//
//  Member:	CDirectStream::SetTime, public
//
//  Synopsis:	Sets a time
//
//  Arguments:	[wt] - Which time
//		[tm] - New time
//
//  Returns:	Appropriate status code
//
//---------------------------------------------------------------

SCODE CDirectStream::SetTime(WHICHTIME wt, TIME_T tm)
{
    return _stmh.SetTime(wt, tm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\time.cxx ===
#include "h/ref.hxx"
#include "time.hxx"
#include "h/ole.hxx"
#include <limits.h>
#include <assert.h>

// Number of seconds difference betwen FILETIME (since 1601 00:00:00) 
// and time_t (since 1970 00:00:00)
//
// This should be a constant difference between the 2 time formats
//
#ifdef __GNUC__	// cater to differences of compiler syntax
const LONGLONG ci64DiffFTtoTT=11644473600LL; 
#else				//  __GNUC__
const LONGLONG ci64DiffFTtoTT=11644473600;
#endif				//  __GNUC__

STDAPI_(void) FileTimeToTimeT(const FILETIME *pft, time_t *ptt)
{
    ULONGLONG llFT = pft->dwHighDateTime;
    llFT = (llFT << 32) | (pft->dwLowDateTime);
    // convert to seconds 
    // (note that all fractions of seconds will be lost)
    llFT = llFT/10000000;       
    llFT -= ci64DiffFTtoTT;         // convert to time_t 
    assert(llFT <= ULONG_MAX);
    *ptt = (time_t) llFT;
}

STDAPI_(void) TimeTToFileTime(const time_t *ptt, FILETIME *pft)
{
    ULONGLONG llFT = *ptt;
    llFT += ci64DiffFTtoTT;         // convert to file time
    // convert to nano-seconds
    for (int i=0; i<7; i++)         // mulitply by 10 7 times
    {        
        llFT = llFT << 1;           // llFT = 2x
        llFT += (llFT << 2);        // llFT = 4*2x + 2x = 10x
    }
    pft->dwLowDateTime  = (DWORD) (llFT & 0xffffffff);
    pft->dwHighDateTime = (DWORD) (llFT >> 32);
}

#ifdef _MSC_VER
#pragma warning(disable:4514)
// disable warning about unreferenced inline functions
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\storage.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       storage.cxx
//
//  Contents:   Contains generic storage APIs
//
//---------------------------------------------------------------


#include "h/ref.hxx"
#include "h/dfexcept.hxx"
#include "h/msf.hxx"
#include "h/docfile.hxx"
#include "h/storagep.h"
#include "h/refilb.hxx"
#include "h/ole.hxx"
#include "h/funcs.hxx"

#ifdef _MSC_VER
#pragma warning (disable:4514)  // unreferenced inline function 
#endif

#define MAKE_ERR(c) MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, c)

//+--------------------------------------------------------------
//
//  Function:   StgOpenStorage, public
//
//  Synopsis:   Instantiates a root storage from a file
//              by binding to the appropriate implementation
//              and starting things up
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority mode reopen IStorage
//              [grfMode] - Permissions
//              [snbExclude] - Exclusions for priority reopen
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//---------------------------------------------------------------

STDAPI StgOpenStorage(TCHAR const *pwcsName,
		      IStorage *pstgPriority,
		      DWORD grfMode,
		      SNB snbExclude,
		      DWORD reserved,
		      IStorage **ppstgOpen)
{
    SCODE sc;
    int i;

    if (!pwcsName)
        return ResultFromScode(STG_E_INVALIDNAME);

    CFileILB *pilb = new CFileILB(pwcsName, grfMode, FALSE); 
    
    olDebugOut((DEB_TRACE, "In  StgOpenStorage(%p, %p, %lX, %p, %lx, %p)\n",
                pwcsName, pstgPriority, grfMode, snbExclude, 
                reserved, ppstgOpen));    

    if (!pilb) return ResultFromScode(STG_E_INSUFFICIENTMEMORY);
    olChk(VerifyPerms(grfMode));
    olChk(pilb->Open(grfMode));

    sc = GetScode( StgOpenStorageOnILockBytes(
        pilb, pstgPriority, grfMode, snbExclude, reserved, ppstgOpen) );
    
EH_Err:
    if (FAILED(sc)) i=pilb->ReleaseOnError();
    else i=pilb->Release();
    olAssert(SUCCEEDED(sc) ? i==1 : i==0);    
    olDebugOut((DEB_TRACE,"Out StgOpenStorage: ppstgOpen=%p ret=> %lX\n",
        (ppstgOpen)?(*ppstgOpen) : NULL, sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Function:   StgOpenStorageOnILockBytes, public
//
//  Synopsis:   Instantiates a root storage from an ILockBytes
//              by binding to the appropriate implementation
//              and starting things up
//
//  Arguments:  [plkbyt] - Source ILockBytes
//              [pstgPriority] - For priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - For priority reopens
//              [reserved]
//              [ppstgOpen] - Docfile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstgOpen]
//
//---------------------------------------------------------------

STDAPI StgOpenStorageOnILockBytes(ILockBytes *plkbyt,
				  IStorage *pstgPriority,
				  DWORD grfMode,
				  SNB snbExclude,
				  DWORD reserved,
				  IStorage **ppstgOpen)
{
    CLSID cid;
#ifndef _UNICODE
    return DfOpenStorageOnILockBytes(plkbyt, pstgPriority, grfMode,
                                     snbExclude, reserved, ppstgOpen,
                                     &cid);
#else
    return DfOpenStorageOnILockBytesW(plkbyt, pstgPriority, grfMode,
                                     snbExclude, reserved, ppstgOpen,
                                     &cid);
#endif
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageFile, public
//
//  Synopsis:   Determines whether the named file is a storage or not
//
//  Arguments:  [pwcsName] - Filename
//
//  Returns:    S_OK, S_FALSE or error codes
//
//---------------------------------------------------------------

//Identifier for first bytes of Beta 2 Docfiles
const BYTE SIGSTG_B2[] = {0x0e, 0x11, 0xfc, 0x0d, 0xd0, 0xcf, 0x11, 0xe0};
const BYTE CBSIGSTG_B2 = sizeof(SIGSTG_B2);

STDAPI StgIsStorageFile(TCHAR const *pwcsName)
{
    SCODE sc;
    int i=0;
    CFileILB* pilb;

    olChk(ValidateNameW(pwcsName, CBMAXPATHCOMPLEN));
    olMem(pilb = new CFileILB(pwcsName, (DWORD)NULL, FALSE));
    olChk(pilb->Open(STGM_READ));
    sc = GetScode( StgIsStorageILockBytes(pilb) );

EH_Err:
    if (pilb) 
        i=pilb->Release();
    olAssert(i==0);  // should not have any more reference to it
    olDebugOut((DEB_TRACE, "Out StgIsStorageFile: ret=> %lx\n", sc));
    return ResultFromScode(sc);
}

//+--------------------------------------------------------------
//
//  Function:   StgIsStorageILockBytes, public
//
//  Synopsis:   Determines whether the ILockBytes is a storage or not
//
//  Arguments:  [plkbyt] - The ILockBytes
//
//  Returns:    S_OK, S_FALSE or error codes
//
//---------------------------------------------------------------

STDAPI StgIsStorageILockBytes(ILockBytes *plkbyt)
{
    HRESULT hr;
    SCODE sc;
    SStorageFile stgfile;
    ULONG cbRead;
    ULARGE_INTEGER ulOffset;

    TRY
    {
	if (FAILED(sc = ValidateInterface(plkbyt, IID_ILockBytes)))
	    return ResultFromScode(sc);
	ULISet32(ulOffset, 0);
	hr = plkbyt->ReadAt(ulOffset, &stgfile, sizeof(stgfile), &cbRead);
        if (FAILED(GetScode(hr)))
	    return hr;
    }
    CATCH(CException, e)
    {
	return ResultFromScode(e.GetErrorCode());
    }
    END_CATCH

    if (cbRead == sizeof(stgfile))
    {        
        if ((memcmp((void *)stgfile.abSig, SIGSTG, CBSIGSTG) == 0) ||
            (memcmp((void *)stgfile.abSig, SIGSTG_B2, CBSIGSTG_B2) == 0))
            return ResultFromScode(S_OK);
    }
    return ResultFromScode(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\vect.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	vect.cxx
//
//  Contents:	Vector common code.
//
//  Classes:	
//
//  Functions:	
//
//----------------------------------------------------------------------------

#include "msfhead.cxx"


#include "h/vect.hxx"



//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Init, public
//
//  Synopsis:   CPagedVector initialization function
//
//  Arguments:  [ulSize] -- size of vector
//
//  Algorithm:  Allocate an array of pointer of size ulSize
//              For each cell in the array, allocate a CFatSect
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CPagedVector::Init(CMStream *pmsParent, ULONG ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));
    SCODE sc = S_OK;
    _pmsParent = pmsParent;
    _pmpt = _pmsParent->GetPageTable();

    msfAssert(_pmpt != NULL);

    USHORT i;

    //  We don't bother allocating more than necessary here
    _ulAllocSize = _ulSize = ulSize;

    if (_ulSize > 0)
    {

        msfMem(_amp = GetNewPageArray(ulSize));
        for (i = 0; i < _ulSize; i++)
        {
            _amp[i] = NULL;
        }
        msfMem(_avb = GetNewVectBits(ulSize));
    }

    msfDebugOut((DEB_ITRACE,"Out CPagedVector::CPagedVector()\n"));
    return S_OK;

Err:
    //In the error case, discard whatever vectors we were able to allocate
    //   and return S_OK.
    delete [] _amp;
    _amp = NULL;

    delete [] _avb;
    _avb = NULL;

    return S_OK;

}

//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::~CPagedVector, public
//
//  Synopsis:   CPagedVector constructor
//
//  Algorithm:  Delete the pointer array.
//
//  Notes:
//
//--------------------------------------------------------------------------

CPagedVector::~CPagedVector()
{
    delete [] _amp;
    delete [] _avb;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Empty, public
//
//  Synopsis:	Discard the storage associated with this vector.
//
//  Arguments:	None.
//
//  Returns:	void.
//
//----------------------------------------------------------------------------

void CPagedVector::Empty(void)
{
    if (_pmpt != NULL)
    {
        _pmpt->FreePages(this);
    }
    delete [] _amp;
    delete [] _avb;
    _amp = NULL;
    _avb = NULL;
    _pmpt = NULL;
    _ulAllocSize = _ulSize = 0;
    _pmsParent = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::Flush, public
//
//  Synopsis:	Flush the dirty pages for this vector
//
//  Arguments:	None.
//
//  Returns:	Appropriate status code
//
//----------------------------------------------------------------------------

SCODE CPagedVector::Flush(void)
{
    SCODE sc;
    SCODE scRet = S_OK;

    if (_ulSize > 0)
    {
        if (_amp != NULL)
        {
            for (USHORT i = 0; i < _ulSize; i++)
            {
                if ((_amp[i] != NULL) && (_amp[i]->IsDirty()))
                {
                    sc = _pmpt->FlushPage(_amp[i]);
                    if ((FAILED(sc)) && (SUCCEEDED(scRet)))
                    {
                        scRet = sc;
                    }
                }
            }
        }
        else
        {
            scRet = _pmpt->Flush();
        }
    }

    return scRet;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::GetTable, public
//
//  Synopsis:   Return a pointer to a page for the given index
//              into the vector.
//
//  Arguments:  [iTable] -- index into vector
//              [ppmp] -- Pointer to return location
//
//  Returns:    S_OK if call completed OK.
//
//  Notes:
//
//--------------------------------------------------------------------------

SCODE CPagedVector::GetTable(
        const FSINDEX iTable,
        DWORD dwFlags,
        void **ppmp)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    msfAssert((_pmsParent->GetILB() != NULL) &&
            aMsg("Null ILB found on GetTable - need SetAccess call?"));

    // docfile is corrupted with an invalid iTable size
    if (iTable >= _ulSize)
    {
	msfErr(Err, STG_E_DOCFILECORRUPT);
 
    }     

    if ((_amp == NULL) || (_amp[iTable] == NULL))
    {
        if (dwFlags & FB_NEW)
        {
            //We know that the page isn't in the page table,
            //  so we can just get a free page an allocate it
            //  ourselves.

            msfChk(_pmpt->GetFreePage(&pmp));

            pmp->SetVector(this);
            pmp->SetSid(_sid);
            pmp->SetOffset(iTable);
            pmp->SetSect(ENDOFCHAIN);

            sc = STG_S_NEWPAGE;
            dwFlags = (dwFlags & ~FB_NEW) | FB_DIRTY;
        }
        else
        {
            msfChk(_pmpt->GetPage(this, _sid, iTable, &pmp));
            msfAssert((pmp->GetVector() == this) &&
                    aMsg("GetPage returned wrong page."));
        }

        
        if (_amp != NULL)
        {
            _amp[iTable] = pmp;
        }

    }
    else
    {
        pmp = _amp[iTable];
        msfAssert((pmp->GetVector() == this) &&
                aMsg("Cached page has wrong vector pointer"));
    }

    pmp->AddRef();
    
    if (((dwFlags & FB_DIRTY) && !(pmp->IsDirty())) &&
        (sc != STG_S_NEWPAGE))
    {
        //If we are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //
        //Newly created pages have to have their sect set manually
        //  _before_ being released.  This is very important.

            pmp->SetSect(ENDOFCHAIN);
            
            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

            pmp->SetSect(sect);
    }

    pmp->SetFlags(pmp->GetFlags() | dwFlags | FB_TOUCHED);
    msfAssert((pmp->GetVector() == this) &&
            aMsg("GetTable returned wrong page."));    
    *ppmp = pmp->GetData();

Err:
    return sc;
    
Err_Rel:
    pmp->Release();
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:	CPagedVector::SetDirty, public
//
//  Synopsis:	Set the dirty bit on the specified page
//
//  Arguments:	[iTable] -- Table to set bit on
//
//  Notes:  This function is always called on a page with an
//              open reference.  Therefore, the page is
//              guaranteed to be in the page table, and that
//              FindPage call should never return an error.
//
//----------------------------------------------------------------------------

SCODE CPagedVector::SetDirty(ULONG iTable)
{
    SCODE sc = S_OK;
    CMSFPage *pmp;

    
    if (_amp == NULL)
    {

        msfChk(_pmpt->FindPage(this, _sid, iTable, &pmp));
        msfAssert(sc == STG_S_FOUND);
        msfAssert(pmp->IsInUse() &&
                aMsg("Called SetDirty on page not in use."));
    }
    else
    {
        msfAssert(_amp != NULL);
        msfAssert(_amp[iTable] != NULL);
        pmp = _amp[iTable];
    }

    if (!pmp->IsDirty())
    {
        //We are not a newly created page, and we are being
        //   dirtied for the first time, make sure that our
        //   _sect field is correct.
        //

        pmp->AddRef();

            pmp->SetSect(ENDOFCHAIN);
            
            SECT sect;
            msfChkTo(Err_Rel, _pmsParent->GetESect(
                    pmp->GetSid(),
                    pmp->GetOffset(),
                    &sect));

            pmp->SetSect(sect);
        
        pmp->Release();
    }

    pmp->SetDirty();

 Err:
    return sc;
    
 Err_Rel:
    pmp->Release();
    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:     CPagedVector::Resize, public
//
//  Synopsis:   Resize a CPagedVector
//
//  Arguments:  [ulSize] -- Size of new vector
//
//  Algorithm:  Create new pointer array of size ulSize.
//              For each entry in old array, copy the pointer over.
//
//  Notes:
//
//--------------------------------------------------------------------------

#define LARGETHRESHOLD  1024
#define VECTORBLOCK     1024    //  Must be power of 2

SCODE CPagedVector::Resize(FSINDEX ulSize)
{
    msfDebugOut((DEB_ITRACE,"In CPagedVector::CPagedVector(%lu)\n",ulSize));

    msfAssert(ulSize >= _ulSize);
    msfAssert(_ulSize <= _ulAllocSize);
    msfAssert(((VECTORBLOCK & (VECTORBLOCK - 1)) == 0) &&
              aMsg("VECTORBLOCK must be power of 2"));

    msfAssert(!((_amp == NULL) && (_avb != NULL)) &&
            aMsg("Resize precondition failed."));
            
    if (ulSize > _ulAllocSize)
    {
        //  We don't have room in the existing vector;  grow it
        ULONG ulNewAllocSize = ulSize;

        if (ulNewAllocSize > LARGETHRESHOLD)
        {
            //  We're dealing with a large vector;  grow it a VECTORBLOCK
            //  at a time
            ulNewAllocSize = (ulNewAllocSize + VECTORBLOCK - 1) &
                             ~(VECTORBLOCK - 1);
        }

        CMSFPage **amp = GetNewPageArray(ulNewAllocSize);
        CVectBits *avb = GetNewVectBits(ulNewAllocSize);

        //  Can't fail after this point

        _ulAllocSize = ulNewAllocSize;

        //  Copy over the old entries

        
        if ((amp != NULL) && (avb != NULL))
        {
            if ((_amp != NULL) && (_avb != NULL))
            {
                //  Both allocations succeeded
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                    avb[iamp] = _avb[iamp];
                }
            }
            else if (_amp != NULL)
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = _amp[iamp];
                }
            }
            else
            {
                for (ULONG iamp = 0; iamp < _ulSize; iamp++)
                {
                    amp[iamp] = NULL;
                }
            }
        }
        else
        {
            //  At least one of the allocations failed
            delete [] avb;
            avb = NULL;

            delete [] amp;
            amp = NULL;
        }

        //  Delete the old vector and put in the new one (if any).
        //  In the error case, throw away the vectors we are currently
        //  holding (since they are of insufficient size) and return S_OK.

        delete [] _amp;
        _amp = amp;

        delete [] _avb;
        _avb = avb;
    }

    if (_amp != NULL)
    {
        //  Initialize the new elements in the vector

        for (ULONG iamp = _ulSize; iamp < ulSize; iamp++)
            _amp[iamp] = NULL;
    }

    _ulSize = ulSize;

    msfDebugOut((DEB_ITRACE,"Out CPagedVector resize constructor\n"));
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\h\dfver.h ===
#define rmj		3
#define rmm		62
#define rup		0
#define szVerName	""
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\h\storagep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       storagep.h
//
//  Contents:   Internal storage information
//
//--------------------------------------------------------------------------

#ifndef __STORAGEP_H__
#define __STORAGEP_H__

// The byte combination that identifies that a file is a storage of
// some kind

const BYTE SIGSTG[] = {0xd0, 0xcf, 0x11, 0xe0, 0xa1, 0xb1, 0x1a, 0xe1};
const BYTE CBSIGSTG = sizeof(SIGSTG);

// The first portion of a storage file
struct SStorageFile
{
    BYTE	abSig[CBSIGSTG];		//  Signature
    CLSID	_clid;				//  Class Id
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\h\tchar.h ===
/*
 *---------------------------------------------------------------------------
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1996.
 *
 *  File:	tchar.h
 *
 *  Contents:	Mapping between wide characters and normal character types
 *              for functions used in the reference implementation
 *----------------------------------------------------------------------------
 */

#ifndef __TCHAR_DEFINED
#define __TCHAR_DEFINED
#include "ref.hxx"
#include "wchar.h"

#ifdef _UNICODE

typedef WCHAR TCHAR;
#define OLESTR(str) L##str

#else  /* _UNICODE */

typedef char TCHAR;
#define OLESTR(str) str

#endif /* _UNICODE */

typedef TCHAR * LPTSTR;
typedef TCHAR OLECHAR, *LPOLECHAR, *LPOLESTR;

/* Define some macros to handle declaration of strings with literals */
/* Since we stray from the default 4 byte wchar_t in UNIX, we have to
   to something different than the usual L"ssd" literals */

/* #define DECLARE_OLESTR(ocsName, len, contents) \ */
/*         LPOLESTR ocsName[len]=OLESTR(contents) */

/* #else */

#ifdef _UNICODE
#define DECLARE_OLESTR(ocsName, pchContents)                       \
        OLECHAR ocsName[sizeof(pchContents)+1];                    \
        _tbstowcs(ocsName, pchContents, sizeof(pchContents)+1)     

#define INIT_OLESTR(ocsName, pchContents) \
        _tbstowcs(ocsName, pchContents, sizeof(pchContents)+1)     

#define DECLARE_CONST_OLESTR(cocsName, pchContents)                     \
        OLECHAR temp##cocsName[sizeof(pchContents)+1];                  \
        _tbstowcs(temp##cocsName, pchContents, sizeof(pchContents)+1);  \
        const LPOLESTR cocsName = temp##cocsName
        
#else  /* non  _UNICODE */

#define DECLARE_OLESTR(ocsName, pchContents)             \
        OLECHAR ocsName[]=pchContents

#define INIT_OLESTR(ocsName, pchContents) \
        strcpy(ocsName, pchContents);

#define DECLARE_CONST_OLESTR(ocsName, pchContents)       \
        const LPOLESTR ocsName=pchContents 

#endif /* _UNICODE */

#define DECLARE_WIDESTR(wcsName, pchContents)                      \
        WCHAR wcsName[sizeof(pchContents)+1];                      \
        _tbstowcs(wcsName, pchContents, sizeof(pchContents)+1)



#ifndef _UNICODE                /*---- non unicode ------  */

#define _tcscpy   strcpy
#define _tcscmp   strcmp
#define _tcslen   strlen
#define _tcsnicmp _strnicmp
#define _tcscat   strcat
#define _itot     _itoa
#define _T(str)   str

#ifdef _WIN32

/* Io functions */
#define _tfopen    fopen
#define _tunlink   _unlink
#define _tfullpath _fullpath
#define _tstat     _stat

#else /* _WIN32 */

#define _tfopen   fopen
#define _tunlink  unlink        /* T-types mapping */
#define _unlink   unlink        /* non-win32 mapping */
#define _stat stat
#define _tstat stat
#define _strnicmp(s1,s2,n) strncasecmp(s1,s2,n)
 
/* note that we assume there is enough space in this case */
#define _tfullpath(longname, shortname, len)    realpath(shortname, longname) 
#define _fullpath(longname, shortname, len)    realpath(shortname, longname) 

#endif /* _MSC_VER */

/* copying wchar/char and TCHAR */
#ifdef _MSC_VER
#define WTOT(T, W, count) wcstombs(T, W, count) 
#define TTOW(T, W, count) mbstowcs(W, T, count)
#else /* _MSC_VER */
#define WTOT(T, W, count) wcstosbs(T, W, count)
#define TTOW(T, W, count) sbstowcs(W, T, count)
#endif /* _MSC_VER */

#define STOT(S, T, count) strcpy(T, S)
#define TTOS(T, S, count) strcpy(S, T)

#else                          /* _UNICODE   ---- unicode  ------ */

/* NOTE: unicode APIs on non win32 systems are not tested or implemented */

#define _tcscpy   wcscpy
#define _tcscmp   wcscmp
#define _tcslen   wcslen
#define _tcscat   wcscat
#define _tcsnicmp wcsnicmp
#define _itot     _itow
#define _T(str)   L##str

/* Io functions */
#define _tfopen    _wfopen
#define _tunlink   _wunlink
#define _tfullpath _wfullpath
#define _tstat     _wstat

#ifdef _UNIX                    /* map win32 I/O API's to other O.S. */
#define _unlink unlink
#define _fullpath(longname, shortname, len)    realpath(shortname, longname) 
#define _stat stat
#define _strnicmp(s1,s2,n) strncasecmp(s1,s2,n)
#endif

/* converting between wchar and TCHAR */
#define WTOT(T, W, count) wcsncpy(T, W, count) 
#define TTOW(T, W, count) wcsncpy(W, T, count)

/* converting between a char and TCHAR */
#define WTOT(T, W, count) wcsncpy(T, W, count) 
#define TTOW(T, W, count) wcsncpy(W, T, count)

#define STOT(S, T, count) _tbstowcs(T, S, count)
#define TTOS(T, S, count) _wcstotbs(S, T, count)

#endif /* #ifndef _UNICODE, #else ... */



#ifndef _WIN32                /* others */
#define _tbstowcs sbstowcs
#define _wcstotbs wcstosbs 
#else /* _WIN32 */
#define _tbstowcs mbstowcs
#define _wcstotbs wcstombs 
#endif /* _WIN32 */

#ifndef _MSC_VER
#include <assert.h>   
inline void  _itoa(int v, char* string, int radix)
{
	if (radix!=10) assert(FALSE);  /* only handle base 10 */
	sprintf(string, "%d", v);
}
#endif /* _MSC_VER */

#endif  /* #ifndef __TCHAR_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\h\props.h ===
/* FILE: prop.h*/

/* Description: This is the exported include file that should be         */
/*              included to declare and make use of the property         */
/*              set Interfaces (IPropertyStorage and IPropertySetStorage */

#ifndef _PROP_H_
#define _PROP_H_

#include "ref.hxx"
#include "tchar.h"
#include "../props/olechar.h"

typedef double DATE;

typedef union tagCY {
    struct _split {
#if BIGENDIAN                   /* big end in first */
        long Hi;
        unsigned long Lo;
#else                           /* little end in first */
        unsigned long Lo;
        long          Hi;
#endif
    } split;                    /* need to name this to make it portable */
    LONGLONG int64;             /* the above split is need to be compatiable */
                                /* with the def of the union */
} CY;

typedef OLECHAR *BSTR;
typedef BSTR *LPBSTR;
/* 0 == FALSE, -1 == TRUE */

typedef short VARIANT_BOOL;

/* for backward compatibility */
typedef VARIANT_BOOL _VARIANT_BOOL;
#define VARIANT_TRUE ((VARIANT_BOOL)0xffff)
#define VARIANT_FALSE ((VARIANT_BOOL)0)

typedef struct  tagBLOB
{
    ULONG cbSize;
    BYTE *pBlobData;
} BLOB;
typedef struct tagBLOB *LPBLOB;

typedef unsigned short VARTYPE;

typedef struct  tagCLIPDATA
{
    ULONG cbSize;      // includes sizeof(ulClipFmt)
    long ulClipFmt;
    BYTE *pClipData;
} CLIPDATA;


/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 *
 *
 *  VT_EMPTY            [V]   [P]     nothing
 *  VT_NULL             [V]   [P]     SQL style Null
 *  VT_I2               [V][T][P][S]  2 byte signed int
 *  VT_I4               [V][T][P][S]  4 byte signed int
 *  VT_R4               [V][T][P][S]  4 byte real
 *  VT_R8               [V][T][P][S]  8 byte real
 *  VT_CY               [V][T][P][S]  currency
 *  VT_DATE             [V][T][P][S]  date
 *  VT_BSTR             [V][T][P][S]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S]  IDispatch *
 *  VT_ERROR            [V][T][P][S]  SCODE
 *  VT_BOOL             [V][T][P][S]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]  VARIANT *
 *  VT_UNKNOWN          [V][T]   [S]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S]  16 byte fixed point
 *  VT_I1                  [T]        signed char
 *  VT_UI1              [V][T][P][S]  unsigned char
 *  VT_UI2                 [T][P]     unsigned short
 *  VT_UI4                 [T][P]     unsigned short
 *  VT_I8                  [T][P]     signed 64-bit int
 *  VT_UI8                 [T][P]     unsigned 64-bit int
 *  VT_INT                 [T]        signed machine int
 *  VT_UINT                [T]        unsigned machine int
 *  VT_VOID                [T]        C style void
 *  VT_HRESULT             [T]        Standard return type
 *  VT_PTR                 [T]        pointer type
 *  VT_SAFEARRAY           [T]        (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]        C style array
 *  VT_USERDEFINED         [T]        user defined type
 *  VT_LPSTR               [T][P]     null terminated string
 *  VT_LPWSTR              [T][P]     wide null terminated string
 *  VT_FILETIME               [P]     FILETIME
 *  VT_BLOB                   [P]     Length prefixed bytes
 *  VT_STREAM                 [P]     Name of the stream follows
 *  VT_STORAGE                [P]     Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]     Stream contains an object
 *  VT_STORED_OBJECT          [P]     Storage contains an object
 *  VT_BLOB_OBJECT            [P]     Blob contains an object
 *  VT_CF                     [P]     Clipboard format
 *  VT_CLSID                  [P]     A Class ID
 *  VT_VECTOR                 [P]     simple counted array
 *  VT_ARRAY            [V]           SAFEARRAY*
 *  VT_BYREF            [V]           void* for local use
 */

enum VARENUM
{	VT_EMPTY	= 0,
	VT_NULL	= 1,
	VT_I2	= 2,
	VT_I4	= 3,
	VT_R4	= 4,
	VT_R8	= 5,
	VT_CY	= 6,
	VT_DATE	= 7,
	VT_BSTR	= 8,
	VT_DISPATCH	= 9,
	VT_ERROR	= 10,
	VT_BOOL	= 11,
	VT_VARIANT	= 12,
	VT_UNKNOWN	= 13,
	VT_DECIMAL	= 14,
	VT_I1	= 16,
	VT_UI1	= 17,
	VT_UI2	= 18,
	VT_UI4	= 19,
	VT_I8	= 20,
	VT_UI8	= 21,
	VT_INT	= 22,
	VT_UINT	= 23,
	VT_VOID	= 24,
	VT_HRESULT	= 25,
	VT_PTR	= 26,
	VT_SAFEARRAY	= 27,
	VT_CARRAY	= 28,
	VT_USERDEFINED	= 29,
	VT_LPSTR	= 30,
	VT_LPWSTR	= 31,
	VT_FILETIME	= 64,
	VT_BLOB	= 65,
	VT_STREAM	= 66,
	VT_STORAGE	= 67,
	VT_STREAMED_OBJECT	= 68,
	VT_STORED_OBJECT	= 69,
	VT_BLOB_OBJECT	= 70,
	VT_CF	= 71,
	VT_CLSID	= 72,
	VT_VECTOR	= 0x1000,
	VT_ARRAY	= 0x2000,
	VT_BYREF	= 0x4000,
	VT_RESERVED	= 0x8000,
	VT_ILLEGAL	= 0xffff,
	VT_ILLEGALMASKED	= 0xfff,
	VT_TYPEMASK	= 0xfff
};
typedef ULONG PROPID;

/* Macro to calculate the size of the above pClipData */
#define CBPCLIPDATA(clipdata)  \
    ( (clipdata).cbSize - sizeof((clipdata).ulClipFmt) )

typedef GUID   FMTID;
typedef const FMTID& REFFMTID;

/* Well-known Property Set Format IDs*/
extern const FMTID FMTID_SummaryInformation;
extern const FMTID FMTID_DocSummaryInformation;
extern const FMTID FMTID_UserDefinedProperties;

inline BOOL operator==(REFFMTID g1, REFFMTID g2)
{ return IsEqualGUID(g1, g2); }
inline BOOL operator!=(REFFMTID g1, REFFMTID g2)
{ return !IsEqualGUID(g1, g2); }

/* Flags for IPropertySetStorage::Create*/
#define	PROPSETFLAG_DEFAULT	( 0 )

#define	PROPSETFLAG_NONSIMPLE	( 1 )

#define	PROPSETFLAG_ANSI	( 2 )

/* FORWARD REFERENCES */
interface IPropertyStorage;
interface IEnumSTATPROPSTG;
interface IEnumSTATPROPSETSTG;

typedef  IPropertyStorage  *LPPROPERTYSTORAGE;

typedef struct tagPROPVARIANT PROPVARIANT;

typedef struct  tagCAUB
{
    ULONG cElems;
    unsigned char  *pElems;
} CAUB;

typedef struct  tagCAI
{
    ULONG cElems;
    short  *pElems;
} CAI;

typedef struct  tagCAUI
{
    ULONG cElems;
    USHORT  *pElems;
} CAUI;

typedef struct  tagCAL
{
    ULONG cElems;
    long  *pElems;
} CAL;

typedef struct  tagCAUL
{
    ULONG cElems;
    ULONG  *pElems;
} CAUL;

typedef struct  tagCAFLT
{
    ULONG cElems;
    float  *pElems;
} CAFLT;

typedef struct  tagCADBL
{
    ULONG cElems;
    double  *pElems;
} CADBL;

typedef struct  tagCACY
{
    ULONG cElems;
    CY  *pElems;
} CACY;
 
typedef struct  tagCADATE
{
    ULONG cElems;
    DATE  *pElems;
} CADATE;

typedef struct  tagCABSTR
{
    ULONG cElems;
    BSTR  *pElems;
} CABSTR;

typedef struct  tagCABOOL
{
    ULONG cElems;
    VARIANT_BOOL  *pElems;
} CABOOL;

typedef struct  tagCASCODE
{
    ULONG cElems;
    SCODE  *pElems;
} CASCODE;

typedef struct  tagCAPROPVARIANT
{
    ULONG cElems;
    PROPVARIANT  *pElems;
} CAPROPVARIANT;

typedef struct  tagCAH
{
    ULONG cElems;
    LARGE_INTEGER  *pElems;
} CAH;

typedef struct  tagCAUH
{
    ULONG cElems;
    ULARGE_INTEGER  *pElems;
} CAUH;

typedef struct  tagCALPSTR
{
    ULONG cElems;
    LPSTR  *pElems;
} CALPSTR;

typedef struct  tagCALPWSTR
{
    ULONG cElems;
    LPWSTR  *pElems;
} CALPWSTR;

typedef struct  tagCAFILETIME
{
    ULONG cElems;
    FILETIME  *pElems;
} CAFILETIME;

typedef struct  tagCACLIPDATA
{
    ULONG cElems;
    CLIPDATA  *pElems;
} CACLIPDATA;

typedef struct  tagCACLSID
{
    ULONG cElems;
    CLSID  *pElems;
} CACLSID;

/* Disable the warning about the obsolete member named 'bool'*/
/* 'bool', 'true', 'false', 'mutable', 'explicit', & 'typename'*/
/* are reserved keywords*/
#ifdef _MSC_VER
#pragma warning(disable:4237)
#endif

struct  tagPROPVARIANT
{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    union 
    {
        UCHAR bVal;
        short iVal;
        USHORT uiVal;
        VARIANT_BOOL boolVal;
#ifndef __GNUC__	    /* in GCC this obsolete member causes conflicts */
        _VARIANT_BOOL bool;
#endif
        long lVal;
        ULONG ulVal;
        float fltVal;
        SCODE scode;
        LARGE_INTEGER hVal;
        ULARGE_INTEGER uhVal;
        double dblVal;
        CY cyVal;
        DATE date;
        FILETIME filetime;
        CLSID  *puuid;
        BLOB blob;
        CLIPDATA  *pclipdata;
        IStream  *pStream;
        IStorage  *pStorage;
        BSTR bstrVal;
        LPSTR pszVal;
        LPWSTR pwszVal;
        CAUB caub;
        CAI cai;
        CAUI caui;
        CABOOL cabool;
        CAL cal;
        CAUL caul;
        CAFLT caflt;
        CASCODE cascode;
        CAH cah;
        CAUH cauh;
        CADBL cadbl;
        CACY cacy;
        CADATE cadate;
        CAFILETIME cafiletime;
        CACLSID cauuid;
        CACLIPDATA caclipdata;
        CABSTR cabstr;
        CALPSTR calpstr;
        CALPWSTR calpwstr;
        CAPROPVARIANT capropvar;
    };
};
typedef struct tagPROPVARIANT  *LPPROPVARIANT;

/* Reserved global Property IDs */
#define	PID_DICTIONARY	( 0 )

#define	PID_CODEPAGE	( 0x1 )

#define	PID_FIRST_USABLE	( 0x2 )

#define	PID_FIRST_NAME_DEFAULT	( 0xfff )

#define	PID_LOCALE	( 0x80000000 )

#define	PID_MODIFY_TIME	( 0x80000001 )

#define	PID_SECURITY	( 0x80000002 )

#define	PID_ILLEGAL	( 0xffffffff )

/* Property IDs for the SummaryInformation Property Set */

#define PIDSI_TITLE               0x00000002L  /* VT_LPSTR*/
#define PIDSI_SUBJECT             0x00000003L  /* VT_LPSTR*/
#define PIDSI_AUTHOR              0x00000004L  /* VT_LPSTR*/
#define PIDSI_KEYWORDS            0x00000005L  /* VT_LPSTR*/
#define PIDSI_COMMENTS            0x00000006L  /* VT_LPSTR*/
#define PIDSI_TEMPLATE            0x00000007L  /* VT_LPSTR*/
#define PIDSI_LASTAUTHOR          0x00000008L  /* VT_LPSTR*/
#define PIDSI_REVNUMBER           0x00000009L  /* VT_LPSTR*/
#define PIDSI_EDITTIME            0x0000000aL  /* VT_FILETIME (UTC)*/
#define PIDSI_LASTPRINTED         0x0000000bL  /* VT_FILETIME (UTC)*/
#define PIDSI_CREATE_DTM          0x0000000cL  /* VT_FILETIME (UTC)*/
#define PIDSI_LASTSAVE_DTM        0x0000000dL  /* VT_FILETIME (UTC)*/
#define PIDSI_PAGECOUNT           0x0000000eL  /* VT_I4*/
#define PIDSI_WORDCOUNT           0x0000000fL  /* VT_I4*/
#define PIDSI_CHARCOUNT           0x00000010L  /* VT_I4*/
#define PIDSI_THUMBNAIL           0x00000011L  /* VT_CF*/
#define PIDSI_APPNAME             0x00000012L  /* VT_LPSTR*/
#define PIDSI_DOC_SECURITY        0x00000013L  /* VT_I4*/
#define	PRSPEC_INVALID	( 0xffffffff )

#define	PRSPEC_LPWSTR	( 0 )

#define	PRSPEC_PROPID	( 1 )

typedef struct  tagPROPSPEC
{
    ULONG ulKind;
    union 
    {
        PROPID propid;
        LPOLESTR lpwstr;
    };
} PROPSPEC;

typedef struct  tagSTATPROPSTG
{
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
} STATPROPSTG;


inline WORD OSVERHI(DWORD dwOSVer)
{
    return (WORD) (dwOSVer >> 16);
}
inline WORD OSVERLOW(DWORD dwOSVer)
{
    return (WORD) (dwOSVer & ((unsigned)~((DWORD) 0) >> 16));
}

#ifndef LOBYTE  
/* code from MSDN */
#define LOBYTE(a) (BYTE) ((a) & ((unsigned)~0>>CHAR_BIT))
#define HIBYTE(a) (BYTE) ((unsigned)(a) >> CHAR_BIT)
#endif

/* Macros for parsing the OS Version of the Property Set Header*/
#define PROPSETHDR_OSVER_KIND(dwOSVer)      OSVERHI( (dwOSVer) )
#define PROPSETHDR_OSVER_MAJOR(dwOSVer)     LOBYTE( OSVERLOW( (dwOSVer) ))
#define PROPSETHDR_OSVER_MINOR(dwOSVer)     HIBYTE( OSVERLOW( (dwOSVer) ))
#define PROPSETHDR_OSVERSION_UNKNOWN        0xFFFFFFFF

typedef struct  tagSTATPROPSETSTG
{
    FMTID fmtid;
    CLSID clsid;
    DWORD grfFlags;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD dwOSVersion;
} STATPROPSETSTG;


EXTERN_C const IID IID_IPropertyStorage;

/****************************************************************
 *
 *           Header for interface: IPropertyStorage
 *
 ****************************************************************/

interface IPropertyStorage : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE ReadMultiple( 
        /* [in] */ ULONG cpspec,
        /* [in] */ const PROPSPEC  rgpspec[  ],
        /* [out] */ PROPVARIANT  rgpropvar[  ]) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE WriteMultiple( 
        /* [in] */ ULONG cpspec,
        /* [in] */ const PROPSPEC  rgpspec[  ],
        /* [in] */ const PROPVARIANT  rgpropvar[  ],
        /* [in] */ PROPID propidNameFirst) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE DeleteMultiple( 
        /* [in] */ ULONG cpspec,
        /* [in] */ const PROPSPEC  rgpspec[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE ReadPropertyNames( 
        /* [in] */ ULONG cpropid,
        /* [in] */ const PROPID  rgpropid[  ],
        /* [out] */ LPOLESTR  rglpwstrName[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE WritePropertyNames( 
        /* [in] */ ULONG cpropid,
        /* [in] */ const PROPID  rgpropid[  ],
        /* [in] */ const LPOLESTR  rglpwstrName[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE DeletePropertyNames( 
        /* [in] */ ULONG cpropid,
        /* [in] */ const PROPID  rgpropid[  ]) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        /* [in] */ DWORD grfCommitFlags) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Revert( void) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Enum( 
        /* [out] */ IEnumSTATPROPSTG  **ppenum) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE SetTimes( 
        /* [in] */ const FILETIME  *pctime,
        /* [in] */ const FILETIME  *patime,
        /* [in] */ const FILETIME  *pmtime) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE SetClass( 
        /* [in] */ REFCLSID clsid) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        /* [out] */ STATPROPSETSTG  *pstatpsstg) = 0;
        
};

/****************************************************************
 *
 *           Header for interface: IPropertySetStorage
 *
 ****************************************************************/

EXTERN_C const IID IID_IPropertySetStorage;

interface IPropertySetStorage : public IUnknown
{
public:
    virtual HRESULT STDMETHODCALLTYPE Create( 
        /* [in] */ REFFMTID rfmtid,
        /* [in] */ const CLSID  *pclsid,
        /* [in] */ DWORD grfFlags,
        /* [in] */ DWORD grfMode,
        /* [out] */ IPropertyStorage  **ppprstg) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Open( 
        /* [in] */ REFFMTID rfmtid,
        /* [in] */ DWORD grfMode,
        /* [out] */ IPropertyStorage  **ppprstg) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Delete( 
        /* [in] */ REFFMTID rfmtid) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Enum( 
        /* [out] */ IEnumSTATPROPSETSTG  **ppenum) = 0;
        
};

typedef  IPropertySetStorage  *LPPROPERTYSETSTORAGE;

/****************************************************************
 *
 *           Header for interface: IEnumSTATPROPSTG
 *
 ****************************************************************/

typedef  IEnumSTATPROPSTG  *LPENUMSTATPROPSTG;
EXTERN_C const IID IID_IEnumSTATPROPSTG;

interface IEnumSTATPROPSTG : public IUnknown
{
public:
    virtual  HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [out] */ STATPROPSTG  *rgelt,
        /* [out] */ ULONG  *pceltFetched) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumSTATPROPSTG  **ppenum) = 0;
    
};

typedef  IEnumSTATPROPSETSTG  *LPENUMSTATPROPSETSTG;

EXTERN_C const IID IID_IEnumSTATPROPSETSTG;


/****************************************************************
 *
 *           Header for interface: IEnumSTATPROPSETSTG
 *
 ****************************************************************/

interface IEnumSTATPROPSETSTG : public IUnknown
{
public:
    virtual  HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [out] */ STATPROPSETSTG  *rgelt,
        /* [out] */ ULONG  *pceltFetched) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumSTATPROPSETSTG  **ppenum) = 0;
        
};

#ifdef __cplusplus
extern "C" {
#endif

STDAPI PropVariantCopy( PROPVARIANT * pvarDest, 
                        const PROPVARIANT * pvarSrc );
STDAPI PropVariantClear( PROPVARIANT * pvar );

STDAPI FreePropVariantArray( ULONG cVariants, PROPVARIANT * rgvars );

STDAPI_(void) SysFreeString(BSTR bstr);
STDAPI_(BSTR) SysAllocString(LPOLECHAR pwsz);

#ifdef __cplusplus
};
#endif

#include <memory.h>
#ifdef __cplusplus
inline void PropVariantInit ( PROPVARIANT * pvar )
{
    memset ( pvar, 0, sizeof(PROPVARIANT) );
}
#else
#define PropVariantInit(pvar) memset ( pvar, 0, sizeof(PROPVARIANT) )
#endif


#endif /*#ifndef  _PROP_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\wchar.c ===
/*
*
*       Copyright (c) 1985-1996, Microsoft Corporation. All Rights Reserved.
*
*       Character functions (to and from wide characters)
*
******************************************************************************
*/

#include "h/wchar.h"
#include <errno.h>

#ifndef _tbstowcs
#ifndef _WIN32                /* others */
#define _tbstowcs sbstowcs
#define _wcstotbs wcstosbs 
#else /* _WIN32 */
#define _tbstowcs mbstowcs
#define _wcstotbs wcstombs 
#endif /* _WIN32 */
#endif

#define ERROR_INVALID_PARAMETER 87L

/*
** Converts a single byte i.e. ascii string to the wide char format 
**
** NOTE: This function does NOT handle multibyte characters!
**       It should be used only when wchar_t is not 2 bytes and
**       we cannot use the standard functions
**
*/

#ifndef _MSC_VER
size_t sbstowcs(WCHAR *pwcs, const char *s, size_t n )
{
	size_t count=0;

	/* if destintation string exists, fill it in */
	if (pwcs)
	{
		while (count < n)
		{
			*pwcs = (WCHAR) ( (unsigned char)s[count]);
			if (!s[count])
				return count;
			count++;
			pwcs++;
		}
		return count;
	}
	else { /* pwcs == NULL, get size only, s must be NUL-terminated */
		return strlen(s);
	}
}
#endif

/***
*size_t wcstosbs() - Convert wide char string to single byte char string.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string 
*       [ANSI].
*
*Entry:
*       char *s            = pointer to destination char string
*       const WCHAR *pwc = pointer to source wide character string
*       size_t           n = maximum number of bytes to store in s
*
*Exit:
*       If s != NULL, returns    (size_t)-1 (if a wchar cannot be converted)
*       Otherwise:       Number of bytes modified (<=n), not including
*                    the terminating NUL, if any.
* 
*Exceptions
*       Returns (size_t)-1 if s is NULL or invalid mb character encountered.
*
*******************************************************************************/

size_t __cdecl wcstosbs( char * s, const WCHAR * pwcs, size_t n)
{
	size_t count=0;
        /* if destination string exists, fill it in */
 	if (s)
	{
		while(count < n)
		{
		    if (*pwcs > 255)  /* validate high byte */
		    {
			errno = EILSEQ;
			return (size_t)-1;  /* error */
		    }
		    s[count] = (char) *pwcs;

 		    if (!(*pwcs++))
			return count;
    		    count++;
	        }
		return count;
        } else { /* s == NULL, get size only, pwcs must be NUL-terminated */
	        const WCHAR *eos = pwcs;
		while (*eos++);
		return ( (size_t) (eos - pwcs -1));
	}
}


/******
*	WCHAR *wcscat(dst, src) - concatenate (append) one wide character string
*       to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       WCHAR *dst - wide character string to which "src" is to be appended
*       const WCHAR *src - wide character string to append to end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

WCHAR * __cdecl wcscat(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;

    while( *cp )
            ++cp;       /* Find end of dst */

    wcscpy(cp,src);     /* Copy src to end of dst */

    return dst;         /* return dst */

}


/***
*WCHAR *wcscpy(dst, src) - copy one wide character string over another
*
*Purpose:
*       Copies the wide character string src into the spot specified by
*       dest; assumes enough room.
*
*Entry:
*       WCHAR * dst - wide character string over which "src" is to be copied
*       const WCHAR * src - string to be copied over "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*******************************************************************************/

WCHAR * __cdecl wcscpy(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;
#ifdef _MSC_VER
#pragma warning(disable:4706) // assignment within conditional expression
#endif //_MSC_VER

    while( *cp++ = *src++ )
            ;               /* Copy src over dst */

#ifdef _MSC_VER
#pragma warning(default:4706)
#endif //_MSC_VER
    return dst;
}


/***
*wcslen - return the length of a null-terminated string
*
*Purpose:
*       Finds the number of wide characters in the given wide character
*       string, not including the final null character.
*
*Entry:
*       const wchat_t * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null wide character
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen(const WCHAR * str)
{
    WCHAR *string = (WCHAR *) str;

    while( *string )
            string++;

    return string - str;
}




/***
*wcsnicmp.c - compare first n characters of two wide character strings with
*             case insensitivity
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcsnicmp() - compare first n characters of two wide character
*       strings for lexical order with case insensitivity.
*
*Revision History:
*
*******************************************************************************/

/***
*WCHAR wcUp(wc) - upper case wide character
*
*/

static WCHAR wcUp(WCHAR wc)
{
    if ('a' <= wc && wc <= 'z')
        wc += (WCHAR)('A' - 'a');

    return(wc);
}

/***
*int wcsnicmp(first, last, count) - compare first count wide characters of wide
*       character strings with case insensitivity.
*
*Purpose:
*       Compares two wide character strings for lexical order.  The comparison
*       stops after: (1) a difference between the strings is found, (2) the end
*       of the strings is reached, or (3) count characters have been
*       compared.
*
*Entry:
*       char *first, *last - wide character strings to compare
*       unsigned count - maximum number of wide characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns  0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsnicmp(const WCHAR * first, const WCHAR * last, size_t count)
{
      if (!count)
              return 0;

      while (--count && *first && wcUp(*first) == wcUp(*last))
              {
              first++;
              last++;
              }

      return wcUp(*first) - wcUp(*last);
}

/***
*wcscmp - compare two WCHAR string
*        returning less than, equal to, or greater than
* 
*Purpose:
*       wcscmp compares two wide-character strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done wchar_t by wchar_t on an UNSIGNED basis, which is to
*       say that Null wchar_t(0) is less than any other character.
*
*Entry:
*       const WCHAR * src - string for left-hand side of comparison
*       const WCHAR * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
******************************************************************************/

int __cdecl wcscmp ( const WCHAR * src, const WCHAR * dst )
{
    int ret = 0 ;
    
    while( ! (ret = (int)(*src - *dst)) && *dst)
        ++src, ++dst;

    if ( ret < 0 )
        ret = -1 ;
    else if ( ret > 0 )
        ret = 1 ;
    
    return( ret );
}



/***
*WCHAR *wcschr(string, c) - search a string for a WCHAR character
*
*Purpose:
*       Searches a WCHAR string for a given WCHAR character,
*       which may be the null character L'\0'.
*
*Entry:
*       WCHAR *string - WCHAR string to search in
*       WCHAR c - WCHAR character to search for
*
*Exit:
*       returns pointer to the first occurence of c in string
*       returns NULL if c does not occur in string
*
*Exceptions:
*
******************************************************************************/

WCHAR * __cdecl wcschr ( const WCHAR * string, WCHAR ch )
{
    while (*string && *string != (WCHAR)ch)
        string++;
    
    if (*string == (WCHAR)ch)
        return((WCHAR *)string);
    return(NULL);
}

/***
*WCHAR *wcsncpy(dest, source, count) - copy at most n wide characters
*
*Purpose:
*       Copies count characters from the source string to the
*       destination.  If count is less than the length of source,
*       NO NULL CHARACTER is put onto the end of the copied string.
*       If count is greater than the length of sources, dest is padded
*       with null characters to length count (wide-characters).
*
*
*Entry:
*       WCHAR *dest - pointer to destination
*       WCHAR *source - source string for copy
*       size_t count - max number of characters to copy
*
*Exit:
*       returns dest
*
*Exceptions:
*
*******************************************************************************/

WCHAR* __cdecl wcsncpy ( WCHAR * dest, const WCHAR * source, size_t count )
{
    WCHAR *start = dest;
    
    while (count && (*dest++ = *source++))    /* copy string */
        count--;

    if (count)                              /* pad out with zeroes */
        while (--count)
            *dest++ = (WCHAR)'\0';
    
    return(start);
}


#include <assert.h>

/* NOTE: this function is really only converting to US ansi (i.e.
        single byte!)

       Note that the returned values are slightly different,
       but that does not matter in the reference implementation */
 
int STDCALL WideCharToMultiByte(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* performance and mapping flags */
    const WCHAR* lpWideCharStr,	/* address of wide-character string */
    int cchWideChar,            /* number of characters in string */
    char* lpMultiByteStr,	/* address of buffer for new string */
    int cchMultiByte,           /* size of buffer  */
    const char* lpDefaultChar,	/* addr of default for unmappable chars */
    int* lpUsedDefaultChar 	/* addr of flag set when default char. used */
   )
{
    /* only support UNICODE or US ANSI */
    if ((CodePage!=0) && (CodePage!=1252)) 
    {
        /* assert(0); */
        return 0;
    }    
    /* the following 2 parameters are not used */
    dwFlags;
    lpDefaultChar;

    if (lpUsedDefaultChar) 
        *lpUsedDefaultChar=0;

    if (cchMultiByte)
    {
        /* copy upto the smaller of the 2 strings */
        int nConvert = cchMultiByte;
        int nConverted;
        if (cchWideChar!=-1 && nConvert>cchWideChar)
            nConvert = cchWideChar;
        nConverted = _wcstotbs(lpMultiByteStr, lpWideCharStr, nConvert);
        if ( (nConverted < cchMultiByte) && (!lpMultiByteStr[nConverted]))
            nConverted++;
        return nConverted;
    }
    else /* calculate length */
    {
        if (cchWideChar!=-1) 
            return (cchWideChar);
        return (_wcstotbs(NULL, lpWideCharStr, 0)+1);
    }
}

/*
 NOTE: This function is really only converting from US ansi (i.e.
       single byte!) It might not work with other locale

       Note that the returned values are slightly different,
       but that does not matter in the reference implementation 
*/

int STDCALL MultiByteToWideChar(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* character-type options  */
    const char * lpMultiByteStr,	/* address of string to map  */
    int cchMultiByte,           /* number of characters in string  */
    WCHAR* lpWideCharStr,	/* address of wide-character buffer  */
    int cchWideChar             /* size of buffer  */
   )
{
    /* only support UNICODE or US ANSI */
    if ((CodePage!=0) && (CodePage!=1252))
    { 
        /*assert(0); */
        return 0;
    }
    dwFlags;  /* we are not using this parameter */
    if (!cchWideChar)  /* return size required */
    {
        if (cchMultiByte != -1) 
            return cchMultiByte;
        else
            /* plus one to include null character */
            return (_tbstowcs(NULL, lpMultiByteStr, cchWideChar)+1);
    }
    else  
    {
        /* nConvert is the smaller size of the two strings */
        int nConvert=cchWideChar;
        int nConverted;
        if (cchMultiByte!=-1 && nConvert>cchMultiByte) 
            nConvert = cchMultiByte;  /* prevent copying too much */
        nConverted = _tbstowcs(lpWideCharStr, lpMultiByteStr, nConvert);
        if ((nConverted < cchWideChar) && (!lpWideCharStr[nConverted]))
            nConverted++; /* include null character */
        return nConverted;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\h\wchar.h ===
/*+---------------------------------------------------------------------------
**
** File:        WChar.h
**
** Contents:    Defines wide character equivalents for standard functions
**              usually in strings.h and ctypes.h
**
** Note:        These routines uses WCHAR which is unsigned short (2 bytes)
**              They are not compatible with some systems that uses 4 bytes
**              wide characters
**--------------------------------------------------------------------------*/

#ifndef __WCHAR__H__
#define __WCHAR__H__

#define _WSTRING_DEFINED // prevent incompatibility with <string.h>
#include <stdlib.h>

#if !defined(FLAT) || defined(OLE32)
#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned short WCHAR, *LPWSTR;
typedef const WCHAR* LPCWSTR;

/* use an alias */
#define _wcsnicmp wcsnicmp

/* Unicode Byte Order Mark (BOM) for Unicode text files */
#define BOM 0xFEFF

/* Padding constant and macro for localized buffer allocation*/
#define INTL_PADDING_VALUE 3
#define INTL_PADDING(cb) (INTL_PADDING_VALUE * (cb))

long     __cdecl wcsatol(const WCHAR *wsz);
int	 __cdecl wcsatoi(const WCHAR *wsz);
WCHAR *  __cdecl wcscat(WCHAR *wsz1, const WCHAR *wsz2);
WCHAR *  __cdecl wcschr ( const WCHAR * string, WCHAR ch );
int      __cdecl wcscmp(const WCHAR *wsz1, const WCHAR *wsz2);
int      __cdecl wcsicmp(const WCHAR *wsz1, const WCHAR *wsz2);
int      __cdecl wcscoll(const WCHAR * wsz1, const WCHAR * wsz2);
WCHAR *  __cdecl wcscpy(WCHAR *wsz1, WCHAR const *wsz2);
WCHAR *  __cdecl wcsitoa(int ival, WCHAR *wsz, int radix);
size_t   __cdecl wcslen(WCHAR const *wsz);
WCHAR *  __cdecl wcsltoa(long lval, WCHAR *wsz, int radix);
WCHAR *  __cdecl wcslwr(WCHAR *wsz);
int      __cdecl wcsncmp(const WCHAR *wsz1, const WCHAR *wsz2, size_t count);
int      __cdecl wcsnicmp(const WCHAR *wsz1, const WCHAR *wsz2, size_t count);
WCHAR *  __cdecl wcsncpy ( WCHAR * dest, const WCHAR * source, size_t count );
WCHAR *  __cdecl wcsrchr(const WCHAR * wcs, WCHAR wc);
WCHAR *  __cdecl wcsupr(WCHAR *wsz);
WCHAR *  __cdecl wcswcs(const WCHAR *wsz1, const WCHAR *wsz2);
size_t   __cdecl wcstosbs( char * s, const WCHAR * pwcs, size_t n);
size_t   __cdecl sbstowcs(WCHAR *wcstr, const char *mbstr, size_t count);

#ifndef STDCALL
#ifdef _WIN32
#define STDCALL __stdcall
#else
#define STDCALL
#endif
#endif

extern int STDCALL MultiByteToWideChar(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* character-type options  */
    const char * lpMultiByteStr,	/* address of string to map  */
    int cchMultiByte,           /* number of characters in string  */
    WCHAR* lpWideCharStr,	/* address of wide-character buffer  */
    int cchWideChar             /* size of buffer  */
   );	

extern int STDCALL WideCharToMultiByte(
    unsigned int CodePage,              /* code page */
    unsigned long dwFlags,              /* performance and mapping flags */
    const WCHAR* lpWideCharStr,	/* address of wide-character string */
    int cchWideChar,            /* number of characters in string */
    char* lpMultiByteStr,	/* address of buffer for new string */
    int cchMultiByte,           /* size of buffer  */
    const char* lpDefaultChar,	/* addr of default for unmappable chars */
    int* lpUsedDefaultChar 	/* addr of flag set when default char. used */
   );

#ifdef __cplusplus
}
#endif

#endif /* !defined(FLAT) || defined(OLE32) */

#endif  /* __WCHAR__H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\ntprop.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1992-1996
//
// File:        ntprop.cxx
//
// Contents:    OLE Appendix B property set support.
//
//
//---------------------------------------------------------------------------

#include "pch.cxx" 

#define CCH_MAP         (1 << CBIT_CHARMASK)            // 32
#define CHARMASK        (CCH_MAP - 1)                   // 0x1f

// we use static array instead of string literals because some systems
// have 4 bytes string literals, and would not produce the correct result
// for REF's 2 byte Unicode convention
// 
OLECHAR aocMap[CCH_MAP + 1] = {'a','b','c','d','e','f','g',
                               'h','i','j','k','l','m','n',
                               'o','p','q','r','s','t','u',
                               'v','w','x','y','z',
                               '0','1','2','3','4','5','\0'};

#define CALPHACHARS  (1 + (OLECHAR)'z' - (OLECHAR)'a')

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

OLECHAR oszSummary[] = {'S','u','m','m','a','r','y',
                        'I','n','f','o','r','m','a','t','i','o','n','\0'};

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

OLECHAR oszDocumentSummary[] = {'D','o','c','u','m','e','n','t',
                                'S','u','m','m','a','r','y',
                                'I','n','f','o','r','m','a','t','i','o','n',
                                '\0'};

// Note that user defined properties are placed in section 2 with the below
// GUID as the FMTID -- alas, we did not expect Office95 to actually use it.

GUID guidDocumentSummarySection2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

// *Global Info*

OLECHAR oszGlobalInfo[] = {'G','l','o','b','a','l',' ','I','n','f','o','\0'};

GUID guidGlobalInfo =
    { 0x56616F00,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Contents*

OLECHAR oszImageContents[] = {'I','m','a','g','e',' ',
                              'C','o','n','t','e','n','t','s','\0'};

GUID guidImageContents =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };

// *Image Info*

OLECHAR oszImageInfo[] = {'I','m','a','g','e',' ','I','n','f','o'};

GUID guidImageInfo =
    { 0x56616500,
      0xC154, 0x11ce,
      { 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B } };


__inline OLECHAR
MapChar(IN ULONG i)
{
    return((OLECHAR) aocMap[i & CHARMASK]);
}


//+--------------------------------------------------------------------------
// Function:    RtlGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated UNICODE name string.
//
//              The awcname parameter is assumed to be a buffer with room for
//              CWC_PROPSETSZ (28) UNICODE characters.  The first character
//              is always WC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
//
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

#ifdef BIGENDIAN                // since we go thru it byte by byte
    GUID guidSwapped = *pguid;  // we have to swap it for big endian
    ByteSwap(&guidSwapped);
    BYTE *pb = (BYTE *) &guidSwapped;
#else
    BYTE *pb = (BYTE *) pguid;
#endif
    BYTE *pbEnd = pb + sizeof(GUID);    

    *poc++ = OC_PROPSET0;

    //  -----------------------
    //  Check for special-cases
    //  -----------------------

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing '\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    // Is this the SummaryInformation propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));

    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    // Is this The DocumentSummaryInformation or User-Defined propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));

    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummarySection2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    // Is this the Global Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    if (*pguid == guidGlobalInfo)
    {
        RtlCopyMemory(poc, oszGlobalInfo, sizeof(oszGlobalInfo));
        return(sizeof(oszGlobalInfo)/sizeof(OLECHAR));
    }

    // Is this the Image Contents propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageContents)/sizeof(OLECHAR));
    if (*pguid == guidImageContents)
    {
        RtlCopyMemory(poc, oszImageContents, sizeof(oszImageContents));
        return(sizeof(oszImageContents)/sizeof(OLECHAR));
    }

    // Is this the Image Info propset?
    PROPASSERT(CCH_PROPSET >= sizeof(oszImageInfo)/sizeof(OLECHAR));
    if (*pguid == guidImageInfo)
    {
        RtlCopyMemory(poc, oszImageInfo, sizeof(oszImageInfo));
        return(sizeof(oszImageInfo)/sizeof(OLECHAR));
    }


    //  ------------------------------
    //  Calculate the string-ized GUID
    //  ------------------------------

    // If this is a big-endian system, we need to convert
    // the GUID to little-endian for the conversion.
#if BIGENDIAN
    GUID guidByteSwapped = *pguid;
    PropByteSwap( &guidByteSwapped );
    pguid = &guidByteSwapped;
#endif

    // Point to the beginning and ending of the GUID
    pb = (BYTE*) pguid;
    pbEnd = pb + sizeof(*pguid);

    // Walk 'pb' through each byte of the GUID.

    while (pb < pbEnd)
    {
        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        if (cbitRemain >= CBIT_CHARMASK)
        {
            *poc = MapChar(i);
            if (cbitRemain == CBIT_BYTE && *poc >= (OLECHAR)'a' 
                && *poc <= ((OLECHAR)'z'))
            {
                *poc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a') );
            }
            poc++;
            cbitRemain -= CBIT_CHARMASK;
            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }
        else
        {
            if (++pb < pbEnd)
            {
                i |= *pb << cbitRemain;
            }
            *poc++ = MapChar(i);
            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }
    *poc = 0;
    return(CCH_PROPSET);

}


//+--------------------------------------------------------------------------
// Function:    RtlPropertySetNameToGuid
//
// Synopsis:    Map non null-terminated UNICODE string to a property set GUID.
//
//              If the name is not properly formed as per
//              RtlGuidToPropertySetName(), STATUS_INVALID_PARAMETER is
//              returned.  The pguid parameter is assumed to point to a buffer
//              with room for a GUID structure.
//
// Arguments:   IN ULONG cocname     -- count of OLECHARs in string to convert
//              IN OLECHAR aocname[] -- input string to convert
//              OUT GUID *pguid      -- pointer to buffer for converted GUID
//
// Returns:     NTSTATUS
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cocname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    OLECHAR const *poc = aocname;

    if (poc[0] == OC_PROPSET0)
    {
        //  -----------------------
        //  Check for Special-Cases 
        //  -----------------------

        // Note: cocname includes the OC_PROPSET0, and sizeof(osz...)
        // includes the trailing OLESTR('\0'), but the comparison excludes both
        // the leading OC_PROPSET0 and the trailing '\0'.

        // Is this SummaryInformation?
        if (cocname == sizeof(oszSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszSummary, cocname - 1) == 0)
        {
            *pguid = guidSummary;
            return(STATUS_SUCCESS);
        }

        // Is this DocumentSummaryInformation?
        if (cocname == sizeof(oszDocumentSummary)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszDocumentSummary, cocname - 1) == 0)
        {
            *pguid = guidDocumentSummary;
            return(STATUS_SUCCESS);
        }

        // Is this Global Info?
        if (cocname == sizeof(oszGlobalInfo)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszGlobalInfo, cocname - 1) == 0)
        {
            *pguid = guidGlobalInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Info?
        if (cocname == sizeof(oszImageInfo)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageInfo, cocname - 1) == 0)
        {
            *pguid = guidImageInfo;
            return(STATUS_SUCCESS);
        }

        // Is this Image Contents?
        if (cocname == sizeof(oszImageContents)/sizeof(OLECHAR) &&
            ocsnicmp(&poc[1], oszImageContents, cocname - 1) == 0)
        {
            *pguid = guidImageContents;
            return(STATUS_SUCCESS);
        }

        //  ------------------
        //  Calculate the GUID
        //  ------------------

        // None of the special-cases hit, so we must calculate
        // the GUID from the name.

        if (cocname == CCH_PROPSET)
        {
            ULONG cbit;
            BYTE *pb = (BYTE *) pguid - 1;

            RtlZeroMemory(pguid, sizeof(*pguid));
            for (cbit = 0; cbit < CBIT_GUID; cbit += CBIT_CHARMASK)
            {
                ULONG cbitUsed = cbit % CBIT_BYTE;
                ULONG cbitStored;
                OLECHAR oc;

                if (cbitUsed == 0)
                {
                    pb++;
                }

                oc = *++poc - (OLECHAR)'A'; // assume upper case 
                // for wchar (unsigned) -ve values becomes a large number
                // but for char, which is signed, -ve is -ve
                if (oc > CALPHACHARS || oc < 0)
                {
                    // oops, try lower case
                    oc += (OLECHAR) ( ((OLECHAR)'A') - ((OLECHAR)'a'));
                    if (oc > CALPHACHARS || oc < 0)
                    {
                        // must be a digit
                        oc += ((OLECHAR)'a') - ((OLECHAR)'0') + CALPHACHARS;
                        if (oc > CHARMASK)
                        {
                            goto fail;                  // invalid character
                        }
                    }
                }
                *pb |= (BYTE) (oc << cbitUsed);

                cbitStored = min(CBIT_BYTE - cbitUsed, CBIT_CHARMASK);

                // If the translated bits wouldn't all fit in the current byte

                if (cbitStored < CBIT_CHARMASK)
                {
                    oc >>= CBIT_BYTE - cbitUsed;

                    if (cbit + cbitStored == CBIT_GUID)
                    {
                        if (oc != 0)
                        {
                            goto fail;                  // extra bits
                        }
                        break;
                    }
                    pb++;

                    *pb |= (BYTE) oc;
                }
            }
            Status = STATUS_SUCCESS;
        }
    }
#ifdef BIGENDIAN
    ByteSwap(pguid);            // on big endian, we will generate a guid 
                                // with the wrong byteorder, so we have to
                                // swap it  
#endif
    return(Status);

fail:
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\h\storage.h ===
/*
 +---------------------------------------------------------------
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1996.
 *
 *  File:       storage.h
 *
 *  Contents:   This is the main file to include to use the reference
 *              implementation.
 *
 *  Note:       Some of the defintions have been changed to TCHAR
 *              instead of WCHAR, to add support for ANSI APIs.
 *              TCHAR becomes WCHAR with _UNICODE defined, and char
 *              otherwise. (See tchar.h for details).
 *
 *--------------------------------------------------------------- 
 */


#ifndef _STORAGE_H_
#define _STORAGE_H_

#include "ref.hxx"
#include "tchar.h"


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_DOCFILECORRUPT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x109)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

#define STG_S_BUFFEROVERFLOW \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x201)

#define STG_S_TRYOVERWRITE \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x202)    


/****** Storage types *******************************************************/

#ifndef HUGEP
#define HUGEP
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L

/* not used in ref, but defined here for error checking etc. */
#define STGM_TRANSACTED		0x00010000L
#define STGM_SIMPLE             0x08000000L
#define STGM_NOSCRATCH          0x00100000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef TCHAR FAR* FAR* SNB;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif

/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    TCHAR FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#define LPENUMSTATSTG        IEnumSTATSTG FAR*

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IENUMSTATSTG methods *** */
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};


/****** ILockBytes Interface ************************************************/

#define LPLOCKBYTES     ILockBytes FAR*

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** ILockBytes methods *** */
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IStream Interface ***************************************************/


#define LPSTREAM        IStream FAR*

#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IStream methods *** */
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};


/****** IStorage Interface **************************************************/

#define LPSTORAGE       IStorage FAR*

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IStorage methods *** */
    STDMETHOD(CreateStream) (THIS_ const TCHAR FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const TCHAR FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const TCHAR FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const TCHAR FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ TCHAR const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              TCHAR const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const TCHAR FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const TCHAR FAR* pwcsOldName,
                const TCHAR FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const TCHAR FAR *lpszName,
    			        FILETIME const FAR *pctime,
                                FILETIME const FAR *patime,
                                FILETIME const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};


/****** IRootStorage Interface **********************************************/

#define LPROOTSTORAGE       IRootStorage FAR*

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    /* *** IUnknown methods *** */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /* *** IRootStorage methods *** */
    STDMETHOD(SwitchToFile) (THIS_ LPTSTR lpstrFile) PURE;
};

/****** Storage API Prototypes ********************************************/
#ifdef __cplusplus
extern "C" {
#endif

STDAPI StgCreateDocfile(const TCHAR FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const TCHAR FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const TCHAR FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

/****** Malloc API's ********************************************/
interface IMalloc;
#define LPMALLOC  IMalloc FAR*

STDAPI CoGetMalloc( DWORD dwMemContext, LPMALLOC * ppMalloc );
STDAPI_(LPVOID) CoTaskMemAlloc( ULONG cb );
STDAPI_(void) CoTaskMemFree( void* pv );
STDAPI_(LPVOID) CoTaskMemRealloc( LPVOID pv, ULONG cb );

#ifdef __cplusplus
};
#endif

/****** IMalloc Interface **********************************************/
#undef  INTERFACE
#define INTERFACE IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)  (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    /*** IMallic methods ***/
    STDMETHOD_(void*,Alloc)    ( ULONG cb) PURE;
    STDMETHOD_(void *,Realloc) ( void *pv, ULONG cb) PURE;    
    STDMETHOD_(void,Free)      ( void *pv) PURE;
    STDMETHOD_(ULONG,GetSize)  ( void *pv) PURE;
    STDMETHOD_(int,DidAlloc)   ( void *pv) PURE;
    STDMETHOD_(void,HeapMinimize)( void ) PURE;
};

#define MEMCTX_TASK 1  /* the only supported flag for CoGetMalloc */

#endif /* ifndef _STORAGE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\olechar.h ===
/* +======================================================

  File:       olechar.h 

  Purpose:    Provide wrappers for string-related
              functions so that the Ansi or Unicode function
              is called, whichever is appropriate for the
              current OLECHAR definition. 

              This file is similar to "tchar.h", except 
              that it covers OLECHARs rather than TCHARs .

  +====================================================== */


#ifndef _OLECHAR_H_ 
#define _OLECHAR_H_ 


#ifndef _UNICODE 
#define OLE2ANSI   1    /* this 2 macros are synonmous for the reference
                           implementation */  
#endif

#define ocslen      _tcslen
#define ocscpy      _tcscpy
#define ocscmp      _tcscmp
#define ocscat      _tcscat
#define ocschr      _tcschr
#define soprintf    _tprintf
#define oprintf     _tprintf
#define ocsnicmp    _tcsnicmp

#endif /* !_OLECHAR_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\ntpropb.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1994
//
// File:        ntpropb.cxx
//
// Contents:    Property set implementation based on OLE Appendix B.
//
//---------------------------------------------------------------------------

#include "pch.cxx"

#include "h/propvar.hxx"

#define Dbg     DEBTRACE_NTPROP 
#define DbgS(s) (NT_SUCCESS(s)? Dbg : DEBTRACE_ERROR)


#if DBG
ULONG DebugLevel = DEBTRACE_ERROR;
//ULONG DebugLevel = DEBTRACE_ERROR | DEBTRACE_CREATESTREAM;
//ULONG DebugLevel = DEBTRACE_ERROR | MAXULONG;
ULONG DebugIndent;
ULONG cAlloc;
ULONG cFree;
#endif

UNICODECALLOUTS UnicodeCallouts =
{
    WIN32_UNICODECALLOUTS
};


//+---------------------------------------------------------------------------
// Function:    RtlSetUnicodeCallouts, public
//
// Synopsis:    Set the Unicode conversion function pointers
//
// Arguments:   [pUnicodeCallouts]	-- Unicode callouts table
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts)
{
    UnicodeCallouts = *pUnicodeCallouts;
}

//+---------------------------------------------------------------------------
// Function:    RtlCreatePropertySet, public
//
// Synopsis:    Allocate and initialize a property set context
//
// Arguments:   [ms]            -- Nt Mapped Stream
//              [Flags]         -- *one* of READ/WRITE/CREATE/CREATEIF/DELETE
//              [pguid]         -- property set guid (create only)
//              [pclsid]        -- CLASSID of propset code (create only)
//              [ma]            -- caller's memory allocator
//		[LocaleId]	-- Locale Id (create only)
//              [pOSVersion]    -- pointer to the OS Version header field
//              [pCodePage]     -- pointer to new/returned CodePage of propset
//              [pnp]           -- pointer to returned property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,           // Nt Mapped Stream
    IN USHORT Flags,                // *one* of READ/WRITE/CREATE/CREATEIF/DELETE
    OPTIONAL IN GUID const *pguid,  // property set guid (create only)
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN NTMEMORYALLOCATOR ma,	    // caller's memory allocator
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from the propset header
    IN OUT USHORT *pCodePage,       // IN: CodePage of property set (create only)
                                    // OUT: CodePage of property set (always)
    OUT NTPROP *pnp)                // pointer to return prop set context
{
    NTSTATUS Status;
    CMappedStream *pmstm = (CMappedStream *) ms;
    CPropertySetStream *ppsstm = NULL;
    BOOLEAN fOpened = FALSE;

    DebugTrace(0, Dbg, ("RtlCreatePropertySet(ms=%x, f=%x, codepage=%x)\n",
                        ms,
                        Flags,
                        *pCodePage));

    *pnp = NULL;
    Status = STATUS_INVALID_PARAMETER;

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Validate the input flags

    if (Flags & ~(CREATEPROP_MODEMASK | CREATEPROP_NONSIMPLE))
    {
        DebugTrace(0, DbgS(Status), (
            "RtlCreatePropertySet(ms=%x, Flags=%x) ==> bad flags!\n",
             ms,
             Flags));
        goto Exit;
    }

    switch (Flags & CREATEPROP_MODEMASK)
    {
        case CREATEPROP_DELETE:
        case CREATEPROP_CREATE:
        case CREATEPROP_CREATEIF:
        case CREATEPROP_WRITE:
            if (!pmstm->IsWriteable())
            {
                Status = STATUS_ACCESS_DENIED;
                goto Exit;
            }
            // FALLTHROUGH

        case CREATEPROP_READ:
	    if (ma == NULL)
	    {
                goto Exit;
	    }
            break;

        default:
            DebugTrace(0, DbgS(Status), (
                "RtlCreatePropertySet(ms=%x, Flags=%x) ==> invalid mode!\n",
                 ms,
                 Flags));
            goto Exit;
    }

    ppsstm = new CPropertySetStream(
                            Flags,
                            pmstm,
			    (PMemoryAllocator *) ma);
    if (ppsstm == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Exit;
    }
    else
    {
        ppsstm->Open(pguid, pclsid, LocaleId,
                     pOSVersion,
                     *pCodePage,
                     &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        *pCodePage = ppsstm->GetCodePage();
        *pnp = (NTPROP) ppsstm;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // If we created a CPropertySetStream object, but
    // the overall operation failed, we must close/delete
    // the object.  Note that we must do this after
    // the above unlock, since ppsstm will be gone after
    // this.

    if (!NT_SUCCESS(Status) && ppsstm != NULL)
    {
        RtlClosePropertySet((NTPROP) ppsstm);
    }

    DebugTrace(0, DbgS(Status), (
        "RtlCreatePropertySet() ==> ms=%x, s=%x\n--------\n",
        *pnp,
        Status));
    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlClosePropertySet, public
//
// Synopsis:    Delete a property set context
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np)               // property set context
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    DebugTrace(0, Dbg, ("RtlClosePropertySet(np=%x)\n", np));

    ppsstm->Close(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    delete ppsstm;

    DebugTrace(0, DbgS(Status), ("RtlClosePropertySet() ==> s=%x(%x)\n", STATUS_SUCCESS, Status));
    return(STATUS_SUCCESS);
}

//+---------------------------------------------------------------------------
// Function:    RtlOnMappedStreamEvent, public
//
// Synopsis:    Handle a MappedStream event.  Every such
//              event requires a byte-swap of the property set
//              headers.
//
// Arguments:   [np]      -- property set context
//              [pbuf]    -- property set buffer
//              [cbstm]   -- size of mapped stream (or CBSTM_UNKNOWN)
//
// NOTE:        It is assumed that the caller has already taken
//              the CPropertySetStream::Lock.
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID * np,               // property set context (an NTPROP)
    IN VOID *pbuf,              // property set buffer
    IN ULONG cbstm )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    DebugTrace(0, Dbg, ("RtlOnMappedStreamEvent(np=%x)\n", np));

    // Byte-swap the property set headers.
    ppsstm->ByteSwapHeaders((PROPERTYSETHEADER*) pbuf, cbstm, &Status );
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlOnMappedStreamEvent() ==> s=%x\n", Status));
    return(Status);

}   // RtlOnMappedStreamEvent()

//+---------------------------------------------------------------------------
// Function:    RtlFlushPropertySet, public
//
// Synopsis:    Flush property set changes to disk
//
// Arguments:   [np]      -- property set context
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np)               // property set context
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(0, Dbg, ("RtlFlushPropertySet(np=%x)\n", np));

    if (ppsstm->IsModified())
    {
        ppsstm->ReOpen(&Status);           // Reload header/size info
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Flush(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        ppsstm->Validate(&Status);
        if( !NT_SUCCESS(Status) ) goto Exit;
    }

    DebugTrace(0, DbgS(Status), ("RtlFlushPropertySet() ==> s=%x\n--------\n", Status));
Exit:
    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    MapNameToPropId, private
//
// Synopsis:    Find an available propid and map it to the passed name
//
// Arguments:   [ppsstm]        -- property set stream
//              [CodePage]      -- property set codepage
//              [aprs]          -- array of property specifiers
//              [cprop]         -- count of property specifiers
//              [iprop]         -- index of propspec with name to map
//              [pidStart]      -- first PROPID to start mapping attempts
//              [pstatus]       -- NTSTATUS code
//
// Returns:     PROPID mapped to passed name
//
// Note:        Find the first unused propid starting at pidStart.
//---------------------------------------------------------------------------

PROPID
MapNameToPropId(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN USHORT CodePage,
    IN PROPSPEC const aprs[],         // array of property specifiers
    IN ULONG cprop,
    IN ULONG iprop,
    IN PROPID pidStart,
    OUT NTSTATUS *pstatus)
{
    PROPID pid = PID_ILLEGAL;
    OLECHAR const *poszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(aprs[iprop].ulKind == PRSPEC_LPWSTR);
    poszName = aprs[iprop].lpwstr;

#ifdef LITTLEENDIAN             // this check will only work for litte Endian
    PROPASSERT(IsOLECHARString(poszName, MAXULONG));
#endif
    for (pid = pidStart; ; pid++)
    {
        ULONG i;
        OLECHAR aocName[CCH_MAXPROPNAMESZ];
        ULONG cbName = sizeof(aocName);

        // The caller must specify a starting propid of 2 or larger, and we
        // must not increment into the reserved propids.

        if (pid == PID_DICTIONARY ||
            pid == PID_CODEPAGE ||
            pid < PID_FIRST_USABLE)
        {
            *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        // Do not assign any propids that explitly appear in the array of
        // propspecs involved in this RtlSetProperties call, nor any propids
        // that are associated with any names in the propspec array.

        for (i = 0; i < cprop; i++)
        {
            if (i != iprop)             // skip the entry we are mapping
            {
                // Is the current PID in Propspec[]?
                if (aprs[i].ulKind == PRSPEC_PROPID &&
                    aprs[i].propid == pid)
                {
                    goto nextpid;       // skip colliding pid
                }

                // Is the current PID already used in the property set?
                if (aprs[i].ulKind == PRSPEC_LPWSTR &&
                    ppsstm->QueryPropid(aprs[i].lpwstr, pstatus) == pid)
                {
                    goto nextpid;       // skip colliding pid
                }
                if (!NT_SUCCESS(*pstatus)) goto Exit;
            }
        } // for (i = 0; i < cprop; i++)

        // Do not assign any propids that currently map to any name.
        // Note that the property name we are mapping does not appear in the
        // dictionary -- the caller checked for this case already.

        if (!ppsstm->QueryPropertyNameBuf(pid, aocName, &cbName, pstatus))
        {
            // The property name could not be found in the dictionary
            ULONG cbT;
	    SERIALIZEDPROPERTYVALUE const *pprop;

            // was the name not found due to an error in QueryProperyBuf?
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            // Do not assign any propids that currently have a property value.

            pprop = ppsstm->GetValue(pid, &cbT, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            if (pprop == NULL)
            {
                DebugTrace(0, Dbg, (
		    "MapNameToPropId(Set Entry: pid=%x, name=L'%ws')\n",
                    pid,
                    poszName));

                // Add the caller-provided name to the dictionary, using
                // the PID that we now know is nowhere in use.
                ppsstm->SetPropertyNames(1, &pid, &poszName, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                ppsstm->Validate(pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                break;
            }   // if (pprop == NULL)
        }   // if (!ppsstm->QueryPropertyNameBuf(pid, awcName, 
          
nextpid:
        ;
    } // for (pid = pidStart; ; pid++)

Exit:
    return(pid);
}


//+---------------------------------------------------------------------------
// Function:    ConvertVariantToPropInfo, private
//
// Synopsis:    Convert variant property values to PROPERTY_INFORMATION values
//
// Arguments:   [ppsstm]        -- property set stream
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//              [avar]          -- array of PROPVARIANTs
//              [apinfo]        -- output array of property info
//
// Returns:     none
//
//---------------------------------------------------------------------------

VOID
ConvertVariantToPropInfo(
    IN CPropertySetStream *ppsstm,    // property set stream
    IN ULONG cprop,                   // property count
    IN PROPID pidNameFirst,           // first PROPID for new named properties
    IN PROPSPEC const aprs[],         // array of property specifiers
    OPTIONAL OUT PROPID apid[],       // buffer for array of propids
    OPTIONAL IN PROPVARIANT const avar[],// array of properties+values
    OUT PROPERTY_INFORMATION *apinfo, // output array of property info
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;
    USHORT CodePage = ppsstm->GetCodePage();
    PROPID pidStart = pidNameFirst;
    ULONG iprop;

    for (iprop = 0; iprop < cprop; iprop++)
    {
	PROPID pid;
	ULONG cbprop;

	switch(aprs[iprop].ulKind)
	{
	case PRSPEC_LPWSTR:
	{
	    PROPASSERT(IsOLECHARString(aprs[iprop].lpwstr, MAXULONG));
	    pid = ppsstm->QueryPropid(aprs[iprop].lpwstr, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    if (pid == PID_ILLEGAL && avar != NULL)
	    {
		pid = MapNameToPropId(
				ppsstm,
				CodePage,
				aprs,
				cprop,
				iprop,
				pidStart,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

		pidStart = pid + 1;
	    }
	    break;
	}

	case PRSPEC_PROPID:
	    pid = aprs[iprop].propid;
	    break;

	default:
	    PROPASSERT(!"Bad ulKind");
	    *pstatus = STATUS_INVALID_PARAMETER;
            goto Exit;

	    break;
	}

	if (apid != NULL)
	{
	    apid[iprop] = pid;
	}

	// RtlConvertVariantToProperty returns NULL on overflow and
	// Raises on bad data.

	cbprop = 0;             // Assume property deletion
	if (pid != PID_ILLEGAL && avar != NULL)
	{
	    RtlConvertVariantToProperty(
			    &avar[iprop],
			    CodePage,
			    NULL,
			    &cbprop,
			    pid,
			    FALSE,
                            pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    PROPASSERT(cbprop == DwordAlign(cbprop));
	}
	apinfo[iprop].cbprop = cbprop;
	apinfo[iprop].pid = pid;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}

//+---------------------------------------------------------------------------
// Function:    RtlSetProperties, public
//
// Synopsis:    Set property values for a property set
//
// Arguments:   [np]            -- property set context
//              [cprop]         -- property count
//              [pidNameFirst]  -- first PROPID for new named properties
//              [aprs]          -- array of property specifiers
//              [apid]          -- buffer for array of propids
//              [avar]          -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID pidNameFirst,     // first PROPID for new named properties
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    OPTIONAL IN PROPVARIANT const avar[]) // array of properties+values
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    NTSTATUS Status = STATUS_SUCCESS;

    PROPERTY_INFORMATION apinfoStack[6];
    PROPERTY_INFORMATION *apinfo = apinfoStack;

    DebugTrace(0, Dbg, (
        "RtlSetProperties(np=%x,cprop=%x,pidNameFirst=%x,aprs=%x,apid=%x)\n",
        np,
        cprop,
        pidNameFirst,
        aprs,
        apid));

    if( !NT_SUCCESS(Status) ) goto Exit;


    // Is the stack-based apinfo big enough?
    if (cprop > sizeof(apinfoStack)/sizeof(apinfoStack[0]))
    {
        // No - we need to allocate an apinfo.
        apinfo = new PROPERTY_INFORMATION[cprop];
        if (NULL == apinfo)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Exit;
        }
    }

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;
    
    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;
    
    ConvertVariantToPropInfo(
        ppsstm,
        cprop,
        pidNameFirst,
        aprs,
        apid,
        avar,
        apinfo,
        &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;
        
    ppsstm->SetValue(cprop, avar, apinfo, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;
    
    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----
    
Exit:
    // If we allocated a temporary apinfo buffer, free it.
    if (cprop > sizeof(apinfoStack)/sizeof(apinfoStack[0]))
    {
        delete [] apinfo;
    }

    DebugTrace(0, DbgS(Status), (
        "RtlSetProperties() ==> status=%x\n--------\n",
        Status));
    
    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlQueryProperties, public
//
// Synopsis:    Query property values from a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [aprs]           -- array of property specifiers
//              [apid]           -- buffer for array of propids
//              [avar]           -- array of PROPVARIANTs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPSPEC const aprs[],   // array of property specifiers
    OPTIONAL OUT PROPID apid[], // buffer for array of propids
    IN OUT PROPVARIANT *avar,   // IN: array of uninitialized PROPVARIANTs,
                                // OUT: may contain pointers to alloc'd memory
    OUT ULONG *pcpropFound)     // count of property values retrieved
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG iprop;

    DebugTrace(0, Dbg, (
        "RtlQueryProperties(np=%x, cprop=%x, aprs=%x, apid=%x)\n",
        np,
        cprop,
        aprs,
        apid));

    // Initialize the variant array enough to allow it to be cleaned up
    // by the caller (even on partial failure).

    *pcpropFound = 0;

    // Zero-ing out the caller-provided PropVariants, essentially
    // sets them all to VT_EMPTY.  It also zeros out the data portion,
    // which prevents cleanup problems in error paths.

    RtlZeroMemory(avar, cprop * sizeof(avar[0]));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    for (iprop = 0; iprop < cprop; iprop++)
    {
        OLECHAR *poc;
        PROPID pid;
        ULONG cbprop;
    
        switch(aprs[iprop].ulKind)
        {
        case PRSPEC_LPWSTR:
            poc = aprs[iprop].lpwstr;
            pid = ppsstm->QueryPropid(poc, &Status);
            if( !NT_SUCCESS(Status) ) goto Exit;
            break;

        case PRSPEC_PROPID:
            pid = aprs[iprop].propid;
            break;

        default:
            PROPASSERT(!"Bad ulKind");
            Status = STATUS_INVALID_PARAMETER;
            goto Exit;
        }

        pprop = ppsstm->GetValue(pid, &cbprop, &Status);
        if( !NT_SUCCESS(Status) ) goto Exit;

        if (pprop != NULL)
        {
            (*pcpropFound)++;
            RtlConvertPropertyToVariant( pprop,
                                         ppsstm->GetCodePage(),
                                         &avar[iprop],
                                         ppsstm->GetAllocator(),
                                         &Status);
            if( !NT_SUCCESS(Status) ) goto Exit;
        }
        if (apid != NULL)
        {
            apid[iprop] = pid;
        }
    }   // for (iprop = 0; iprop < cprop; iprop++)

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    if( !NT_SUCCESS(Status) )
    {
        CleanupVariants(avar, cprop, ppsstm->GetAllocator());
    }

    DebugTrace(0, DbgS(Status), (
        "RtlQueryProperties() ==> s=%x\n--------\n",
        Status));

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlEnumerateProperties, public
//
// Synopsis:    Enumerate properties in a property set
//
// Arguments:   [np]             -- property set context
//              [cskip]          -- count of properties to skip
//              [pcprop]         -- pointer to property count
//              [Flags]          -- flags: No Names (propids only), etc.
//              [asps]           -- array of STATPROPSTGs
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               // property set context
    IN ULONG Flags,             // flags: No Names (propids only), etc.
    IN ULONG *pkey,             // count of properties to skip
    IN OUT ULONG *pcprop,       // pointer to property count
    OPTIONAL OUT PROPSPEC aprs[],// IN: array of uninitialized PROPSPECs
                                 // OUT: may contain pointers to alloc'd strings
    OPTIONAL OUT STATPROPSTG asps[]) // IN: array of uninitialized STATPROPSTGs
                                // OUT: may contain pointers to alloc'd strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    SERIALIZEDPROPERTYVALUE const *pprop = NULL;
    PROPSPEC *pprs;
    STATPROPSTG *psps;
    PROPID *ppidBase = NULL;
    ULONG i;
    ULONG cpropin;

    PROPID apidStack[20];
    PROPID *ppid;
    ULONG cprop;
    PMemoryAllocator *pma = ppsstm->GetAllocator();

    DebugTrace(0, Dbg, (
        "RtlEnumerateProperties(np=%x, f=%x, key=%x, cprop=%x, aprs=%x, asps=%x)\n",
        np,
        Flags,
        *pkey,
        *pcprop,
        aprs,
        asps));

    cpropin = *pcprop;

    // Eliminate confusion for easy cleanup

    if (aprs != NULL)
    {
        // Set all the PropSpecs to PROPID (which require
        // no cleanup).

        for (i = 0; i < cpropin; i++)
        {
            aprs[i].ulKind = PRSPEC_PROPID;
        }
    }

    // Zero all pointers in the array for easy cleanup

    if (asps != NULL)
    {
        RtlZeroMemory(asps, cpropin * sizeof(asps[0]));
    }

    ppidBase = NULL;

    cprop = ppsstm->ReOpen(&Status);   // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    if (cprop > cpropin)
    {
	cprop = cpropin;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppid = NULL;
    if (aprs != NULL || asps != NULL)
    {
	ppid = apidStack;
	if (cprop > sizeof(apidStack)/sizeof(apidStack[0]))
	{
	    ppidBase = new PROPID[cprop];
	    if (ppidBase == NULL)
	    {
		Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Exit;
	    }
	    ppid = ppidBase;
	}
    }

    ppsstm->EnumeratePropids(pkey, &cprop, ppid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    *pcprop = cprop;

    if (ppid != NULL)
    {
        psps = asps;
	pprs = aprs;
	while (cprop-- > 0)
	{
	    OLECHAR aocName[CCH_MAXPROPNAMESZ];
	    ULONG cbName;
	    ULONG cbprop;
	    BOOLEAN fHasName;
	    
	    PROPASSERT(*ppid != PID_DICTIONARY && *ppid != PID_CODEPAGE);
	    fHasName = FALSE;

	    if ((Flags & ENUMPROP_NONAMES) == 0)
	    {
		cbName = sizeof(aocName);
		fHasName = ppsstm->QueryPropertyNameBuf(
					*ppid,
					aocName,
					&cbName,
                                        &Status);
                if( !NT_SUCCESS(Status) ) goto Exit;
	    }

	    if (pprs != NULL)
	    {
		PROPASSERT(pprs->ulKind == PRSPEC_PROPID);
		if (fHasName)
		{
		    pprs->lpwstr = ppsstm->DuplicatePropertyName(
						aocName,
						cbName,
                                                &Status);
                    if( !NT_SUCCESS(Status) ) goto Exit;
		    PROPASSERT(pprs->lpwstr != NULL);

		    // Make this assignment *after* memory allocation
		    // succeeds so we free only valid pointers in below
		    // cleanup code.
		    pprs->ulKind = PRSPEC_LPWSTR;
		}
		else
		{
		    pprs->propid = *ppid;
		}
		pprs++;

	    }   // if (pprs != NULL)

	    if (psps != NULL)
	    {
		pprop = ppsstm->GetValue(*ppid, &cbprop, &Status);
                if( !NT_SUCCESS(Status) ) goto Exit;

		PROPASSERT(psps->lpwstrName == NULL);
		if (fHasName)
		{
		    psps->lpwstrName = ppsstm->DuplicatePropertyName(
						aocName,
						cbName,
                                                &Status);
                    if( !NT_SUCCESS(Status) ) goto Exit;
                    PROPASSERT(psps->lpwstrName != NULL);
		}
		psps->propid = *ppid;
		psps->vt = (VARTYPE) PropByteSwap(pprop->dwType);
		psps++;

	    }   // if (psps != NULL)
	    
            ppid++;

	}   // while (cprop-- > 0)
    }   // if (ppid != NULL)

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    delete [] ppidBase;

    if (!NT_SUCCESS(Status))
    {
        PMemoryAllocator *pma = ppsstm->GetAllocator();

        if (aprs != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (aprs[i].ulKind == PRSPEC_LPWSTR)
                {
                    pma->Free(aprs[i].lpwstr);
                    aprs[i].ulKind = PRSPEC_PROPID;
                }
            }
        }

        if (asps != NULL)
        {
            for (i = 0; i < cpropin; i++)
            {
                if (asps[i].lpwstrName != NULL)
                {
                    pma->Free(asps[i].lpwstrName);
                    asps[i].lpwstrName = NULL;
                }
            }
        }
    }   // if (!NT_SUCCESS(Status))

#if DBG
    if (NT_SUCCESS(Status))
    {
	if (aprs != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (aprs[i].ulKind == PRSPEC_LPWSTR)
		{
		    PROPASSERT(aprs[i].lpwstr != NULL);
		    PROPASSERT(ocslen(aprs[i].lpwstr) > 0);
		}
	    }
	}
	if (asps != NULL)
	{
	    for (i = 0; i < cpropin; i++)
	    {
		if (asps[i].lpwstrName != NULL)
		{
		    PROPASSERT(ocslen(asps[i].lpwstrName) > 0);
		}
	    }
	}
    }
#endif // DBG

    DebugTrace(0, DbgS(Status), (
        "RtlEnumerateProperties() ==> key=%x, cprop=%x, s=%x\n--------\n",
        *pkey,
        *pcprop,
        Status));

    return(Status);
}


//+---------------------------------------------------------------------------
// Function:    RtlQueryPropertyNames, public
//
// Synopsis:    Read property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to OLECHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    OUT OLECHAR *aposz[])         // OUT pointers to allocated strings
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS StatusQuery = STATUS_SUCCESS;

    DebugTrace(0, Dbg, (
        "RtlQueryPropertyNames(np=%x, cprop=%x, apid=%x, aposz=%x)\n",
        np,
        cprop,
        apid,
        aposz));

    RtlZeroMemory(aposz, cprop * sizeof(aposz[0]));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    // we'will save the status from the following call. If there are no
    // other errors, we'll return it to the caller (it might contain a useful
    // success code
    ppsstm->QueryPropertyNames(cprop, apid, aposz, &StatusQuery);
    if( !NT_SUCCESS(StatusQuery) )
    {
        Status = StatusQuery;
        goto Exit;
    }

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(
        0,
        Status == STATUS_BUFFER_ALL_ZEROS? Dbg : DbgS(Status),
        ("RtlQueryPropertyNames() ==> s=%x\n--------\n", Status));

    if( NT_SUCCESS(Status) )
        Status = StatusQuery;

    return(Status); 


}   // RtlQueryPropertyNames()


//+---------------------------------------------------------------------------
// Function:    RtlSetPropertyNames, public
//
// Synopsis:    Write property names for PROPIDs in a property set
//
// Arguments:   [np]             -- property set context
//              [cprop]          -- property count
//              [apid]           -- array of PROPIDs
//              [aposz]          -- array of pointers to OLECHAR strings
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               // property set context
    IN ULONG cprop,             // property count
    IN PROPID const *apid,      // PROPID array
    IN OLECHAR const * const aposz[]) // pointers to property names
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(0, Dbg, (
        "RtlSetPropertyNames(np=%x, cprop=%x, apid=%x, aposz=%x)\n",
        np,
        cprop,
        apid,
        aposz));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetPropertyNames(cprop, apid, aposz, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlSetPropertyNames() ==> s=%x\n--------\n", Status));
    return(Status);

}   // RtlSetPropertyNames()


//+---------------------------------------------------------------------------
// Function:    RtlSetPropertySetClassId, public
//
// Synopsis:    Set the property set's ClassId
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               // property set context
    IN GUID const *pclsid)      // new CLASSID of propset code
{
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;
    NTSTATUS Status = STATUS_SUCCESS;

    DebugTrace(0, Dbg, ("RtlSetPropertySetClassId(np=%x)\n", np));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->SetClassId(pclsid, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlSetPropertySetClassId() ==> s=%x\n--------\n", Status));
    return(Status);

}   // RtlSetPropertySetClassId()


//+---------------------------------------------------------------------------
// Function:    RtlQueryPropertySet, public
//
// Synopsis:    Query the passed property set
//
// Arguments:   [np]    -- property set context
//              [pspss] -- pointer to STATPROPSETSTG
//
// Returns:     Status code
//---------------------------------------------------------------------------

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               // property set context
    OUT STATPROPSETSTG *pspss)  // buffer for property set stat information
{
    NTSTATUS Status = STATUS_SUCCESS;
    CPropertySetStream *ppsstm = (CPropertySetStream *) np;

    DebugTrace(0, Dbg, ("RtlQueryPropertySet(np=%x, pspss=%x)\n", np, pspss));
    RtlZeroMemory(pspss, sizeof(*pspss));

    ppsstm->ReOpen(&Status);           // Reload header/size info
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->QueryPropertySet(pspss, &Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    ppsstm->Validate(&Status);
    if( !NT_SUCCESS(Status) ) goto Exit;

    //  ----
    //  Exit
    //  ----

Exit:

    DebugTrace(0, DbgS(Status), ("RtlQueryPropertySet() ==> s=%x\n--------\n", Status));
    return(Status);

}   // RtlQueryPropertySet()

inline BOOLEAN
_Compare_VT_BOOL(VARIANT_BOOL bool1, VARIANT_BOOL bool2)
{
    // Allow any non-zero value to match any non-zero value

    return((bool1 == FALSE) == (bool2 == FALSE));
}


BOOLEAN
_Compare_VT_CF(CLIPDATA *pclipdata1, CLIPDATA *pclipdata2)
{
    BOOLEAN fSame;

    if (pclipdata1 != NULL && pclipdata2 != NULL)
    {
        if (fSame =
            pclipdata1->cbSize == pclipdata2->cbSize &&
            pclipdata1->ulClipFmt == pclipdata2->ulClipFmt)
        {
            if (pclipdata1->pClipData != NULL && pclipdata2->pClipData != NULL)
            {
                fSame = memcmp(
                            pclipdata1->pClipData,
                            pclipdata2->pClipData,
                            CBPCLIPDATA(*pclipdata1)
                              ) == 0;
            }
            else
            {
                // They're the same if both are NULL, or if
                // they have a zero length (if they have a zero
                // length, either one may or may not be NULL, but they're
                // still considered the same).

                fSame = pclipdata1->pClipData == pclipdata2->pClipData
                        ||
                        CBPCLIPDATA(*pclipdata1) == 0;
            }
        }
    }
    else
    {
        fSame = pclipdata1 == pclipdata2;
    }
    return(fSame);
}


//+---------------------------------------------------------------------------
// Function:    RtlCompareVariants, public
//
// Synopsis:    Compare two passed PROPVARIANTs -- case sensitive for strings
//
// Arguments:   [CodePage]      -- CodePage
//              [pvar1]         -- pointer to PROPVARIANT
//              [pvar2]         -- pointer to PROPVARIANT
//
// Returns:     TRUE if identical, else FALSE
//---------------------------------------------------------------------------

STDAPI_(BOOLEAN) PROPSYSAPI PROPAPI
RtlCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2)
{
    if (pvar1->vt != pvar2->vt)
    {
        return(FALSE);
    }

    BOOLEAN fSame;
    ULONG i;

    switch (pvar1->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        fSame = TRUE;
        break;

#ifdef PROPVAR_VT_I1
    case VT_I1:
#endif
    case VT_UI1:
        fSame = pvar1->bVal == pvar2->bVal;
        break;

    case VT_I2:
    case VT_UI2:
        fSame = pvar1->iVal == pvar2->iVal;
        break;

    case VT_BOOL:
        fSame = _Compare_VT_BOOL(pvar1->boolVal, pvar2->boolVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        fSame = pvar1->lVal == pvar2->lVal;
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:        
        fSame = ( (pvar1->hVal.LowPart == pvar2->hVal.LowPart) &&
                  (pvar1->hVal.HighPart == pvar2->hVal.HighPart) );
        break;

    case VT_CLSID:
        fSame = memcmp(pvar1->puuid, pvar2->puuid, sizeof(CLSID)) == 0;
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        if (fSame = pvar1->blob.cbSize == pvar2->blob.cbSize)
        {
            fSame = memcmp(
                        pvar1->blob.pBlobData,
                        pvar2->blob.pBlobData,
                        pvar1->blob.cbSize) == 0;
        }
        break;

    case VT_CF:
        fSame = _Compare_VT_CF(pvar1->pclipdata, pvar2->pclipdata);
        break;

    case VT_BSTR:
        if (pvar1->bstrVal != NULL && pvar2->bstrVal != NULL)
        {
            if (fSame = BSTRLEN(pvar1->bstrVal) == BSTRLEN(pvar2->bstrVal))
            {
                fSame = memcmp(
                            pvar1->bstrVal,
                            pvar2->bstrVal,
                            BSTRLEN(pvar1->bstrVal)) == 0;
            }
        }
        else
        {
            fSame = pvar1->bstrVal == pvar2->bstrVal;
        }
        break;

    case VT_LPSTR:
        if (pvar1->pszVal != NULL && pvar2->pszVal != NULL)
        {
            fSame = strcmp(pvar1->pszVal, pvar2->pszVal) == 0;
        }
        else
        {
            fSame = pvar1->pszVal == pvar2->pszVal;
        }
        break;

    case VT_LPWSTR:
        if (pvar1->pwszVal != NULL && pvar2->pwszVal != NULL)
        {
            fSame = Prop_wcscmp(pvar1->pwszVal, pvar2->pwszVal) == 0;
        }
        else
        {
            fSame = pvar1->pwszVal == pvar2->pwszVal;
        }
        break;

#ifdef PROPVAR_VT_I1
    case VT_VECTOR | VT_I1:
#endif
    case VT_VECTOR | VT_UI1:
        if (fSame = pvar1->caub.cElems == pvar2->caub.cElems)
        {
            fSame = memcmp(
                        pvar1->caub.pElems,
                        pvar2->caub.pElems,
                        pvar1->caub.cElems * sizeof(pvar1->caub.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
        if (fSame = pvar1->cai.cElems == pvar2->cai.cElems)
        {
            fSame = memcmp(
                        pvar1->cai.pElems,
                        pvar2->cai.pElems,
                        pvar1->cai.cElems * sizeof(pvar1->cai.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_BOOL:
        if (fSame = pvar1->cabool.cElems == pvar2->cabool.cElems)
        {
            for (i = 0; i < pvar1->cabool.cElems; i++)
            {
                fSame = _Compare_VT_BOOL(
                                pvar1->cabool.pElems[i],
                                pvar2->cabool.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        if (fSame = pvar1->cal.cElems == pvar2->cal.cElems)
        {
            fSame = memcmp(
                        pvar1->cal.pElems,
                        pvar2->cal.pElems,
                        pvar1->cal.cElems * sizeof(pvar1->cal.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        if (fSame = pvar1->cah.cElems == pvar2->cah.cElems)
        {
            fSame = memcmp(
                        pvar1->cah.pElems,
                        pvar2->cah.pElems,
                        pvar1->cah.cElems *
                            sizeof(pvar1->cah.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CLSID:
        if (fSame = (pvar1->cauuid.cElems == pvar2->cauuid.cElems))
        {
            fSame = memcmp(
                        pvar1->cauuid.pElems,
                        pvar2->cauuid.pElems,
                        pvar1->cauuid.cElems *
                            sizeof(pvar1->cauuid.pElems[0])) == 0;
        }
        break;

    case VT_VECTOR | VT_CF:
        if (fSame = pvar1->caclipdata.cElems == pvar2->caclipdata.cElems)
        {
            for (i = 0; i < pvar1->caclipdata.cElems; i++)
            {
                fSame = _Compare_VT_CF(
                                &pvar1->caclipdata.pElems[i],
                                &pvar2->caclipdata.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_BSTR:
        if (fSame = (pvar1->cabstr.cElems == pvar2->cabstr.cElems))
        {
            for (i = 0; i < pvar1->cabstr.cElems; i++)
            {
                if (pvar1->cabstr.pElems[i] != NULL &&
                    pvar2->cabstr.pElems[i] != NULL)
                {
                    if (fSame =
                            BSTRLEN(pvar1->cabstr.pElems[i]) ==
                            BSTRLEN(pvar2->cabstr.pElems[i]))
                    {
                        fSame = memcmp(
                                    pvar1->cabstr.pElems[i],
                                    pvar2->cabstr.pElems[i],
                                    BSTRLEN(pvar1->cabstr.pElems[i])) == 0;
                    }
                }
                else
                {
                    fSame = pvar1->cabstr.pElems[i] == pvar2->cabstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPSTR:
        if (fSame = (pvar1->calpstr.cElems == pvar2->calpstr.cElems))
        {
            for (i = 0; i < pvar1->calpstr.cElems; i++)
            {
                if (pvar1->calpstr.pElems[i] != NULL &&
                    pvar2->calpstr.pElems[i] != NULL)
                {
                    fSame = strcmp(
                                pvar1->calpstr.pElems[i],
                                pvar2->calpstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpstr.pElems[i] == 
                            pvar2->calpstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_LPWSTR:
        if (fSame = pvar1->calpwstr.cElems == pvar2->calpwstr.cElems)
        {
            for (i = 0; i < pvar1->calpwstr.cElems; i++)
            {
                if (pvar1->calpwstr.pElems[i] != NULL &&
                    pvar2->calpwstr.pElems[i] != NULL)
                {
                    fSame = Prop_wcscmp(
                                pvar1->calpwstr.pElems[i],
                                pvar2->calpwstr.pElems[i]) == 0;
                }
                else
                {
                    fSame = pvar1->calpwstr.pElems[i] == 
                            pvar2->calpwstr.pElems[i];
                }
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    case VT_VECTOR | VT_VARIANT:
        if (fSame = pvar1->capropvar.cElems == pvar2->capropvar.cElems)
        {
            for (i = 0; i < pvar1->capropvar.cElems; i++)
            {
                fSame = RtlCompareVariants(
                                CodePage,
                                &pvar1->capropvar.pElems[i],
                                &pvar2->capropvar.pElems[i]);
                if (!fSame)
                {
                    break;
                }
            }
        }
        break;

    default:
        PROPASSERT(!"Invalid type for PROPVARIANT Comparison");
        fSame = FALSE;
        break;

    }
    return(fSame);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\propstm.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propstm.cxx
//
// Contents:    property set value extraction code
//
// The OLE 2.0 Appendix B property set specifies multiple sections in the
// property stream specification.  Multiple sections were intended to allow
// the schema associated with the property set to evolve over a period of
// time, but there is no reason that new PROPIDs cannot serve the same
// purpose.  The current implementation of the property stream is limited to
// one section, except for the Office DocumentSummaryInformation property
// set's specific use of a second section.  Other property sets with multiple
// sections can only be accessed in read-only mode, and then only for the
// first property section. The current implementation of property set stream
// is built around a class called CPropertySetStream.  The various details of
// the OLE property spec is confined to this class. This class encapsulates a
// stream implementation (CMappedStream). This is different from other 
// stream implementations in that the fundamental mechanism provided
// for acessing the contents is Map/Unmap rather than Read/Write.  
//
//---------------------------------------------------------------------------

#include "pch.cxx"

#ifdef _UNIX
#define qsort ref_qsort
#include "qsort.h"
#endif

#define Dbg     DEBTRACE_PROPERTY

#define szX     "x"     // allows radix change for offsets & sizes
//#define szX   "d"     // allows radix change for offsets & sizes

#ifndef newk
#define newk(Tag, pCounter)     new
#endif

#ifndef IsDwordAligned
#define IsDwordAligned(p)       (((ULONG) (p) & (sizeof(ULONG) - 1)) == 0)
#endif

#ifndef DwordRemain
#define DwordRemain(cb) \
        ((sizeof(ULONG) - ((cb) % sizeof(ULONG))) % sizeof(ULONG))
#endif


// Macro to create the OS Version field of the
// property set header.
#define MAKEPSVER(oskind, major, minor)  \
        (((oskind) << 16) | ((minor) << 8) | (major))

// we specify a new 'OS' type for the reference implementation
#define CURRENT_OSKIND OSKIND_REF
// reference implementation starts at version 1.00
#define CURRENT_OSVER 0x01

#define PROPSETVER_CURRENT \
    MAKEPSVER(CURRENT_OSKIND, CURRENT_OSVER >> 8, CURRENT_OSVER & 0xff) 
#define PROPSETVER_WIN310  MAKEPSVER(OSKIND_WINDOWS, 3, 10)
#define PROPSETVER_WIN333  MAKEPSVER(OSKIND_WIN32, 3, 0x33)



extern GUID guidSummary;
extern GUID guidDocumentSummary;
extern GUID guidDocumentSummarySection2;

#define CP_DEFAULT_NONUNICODE   1252 // ANSI Latin1 (US, Western Europe)

extern "C" UNICODECALLOUTS UnicodeCallouts;
#define CP_CREATEDEFAULT(state)	(*UnicodeCallouts.pfnGetACP)()

#if DBGPROP
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(szReason " ", pstatus)
#else
#define StatusCorruption(pstatus, szReason)             \
            _StatusCorruption(pstatus)
#endif


VOID RtlpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus);


#if DBGPROP

#define CB_VALUEDISPLAY 8       // Number of bytes to display
#define CB_VALUESTRING  (CB_VALUEDISPLAY * 3 + 3)       // "xx xx xx xx...\0"

char *
ValueToString(SERIALIZEDPROPERTYVALUE const *pprop, ULONG cbprop, char buf[])
{
    char *p = buf;
    BYTE const *pb = pprop->rgb;
    BOOLEAN fOverflow = FALSE;
    static char szDots[] = "...";

    if (cbprop >= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb))
    {
        cbprop -= FIELD_OFFSET(SERIALIZEDPROPERTYVALUE, rgb);
        if (cbprop > CB_VALUEDISPLAY)
        {
            cbprop = CB_VALUEDISPLAY;
            fOverflow = TRUE;
        }
        while (cbprop-- > 0)
        {
            if (p != buf)
            {
                *p++ = ' ';
            }
            p += PropSprintfA( p, "%02.2x", *pb++ );
        }
    }
    *p =  '\0';
    PROPASSERT(p - buf + sizeof(szDots) <= CB_VALUESTRING);
    if (fOverflow)
    {
        strcpy(p, szDots);
    }
    return(buf);
}


#define CB_VARIANT_TO_STRING 35

char *
VariantToString(PROPVARIANT const &var, char buf[], ULONG cbprop)
{
    char *p = buf;

    PROPASSERT( cbprop >= CB_VARIANT_TO_STRING );


    // Add the VT to the output buffer.

    p += PropSprintfA( p, "vt=%04.4x", var.vt );
    p += PropSprintfA( p, ", val=(%08.8x, %08.8x)", var.uhVal.LowPart, var.uhVal.HighPart );
   
    *p =  '\0';
    PROPASSERT( (p - buf) == CB_VARIANT_TO_STRING);
    return(buf);
}

#endif


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapOffsetToAddress, private
//
// Synopsis:    maps an offset to an address
//
// Arguments:   [Offset]        -- the offset in the section
//
// Returns:     ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapOffsetToAddress(ULONG Offset) const
{
    PROPASSERT(_cSection != 0);

    return(Add2Ptr(_GetSectionHeader(), Offset));
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryEntryLength
//
// Synopsis:    Calculate the length of an entry in the
//              dictionary.  This is non-trivial because
//              it is codepage-dependent.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
//
// Returns:     The entry's length.
//+--------------------------------------------------------------------------


inline ULONG
CPropertySetStream::_DictionaryEntryLength(
    IN ENTRY UNALIGNED const * pentArg
    ) const
{
#if i386 == 0                   // copy into an aligned structure
    ENTRY ent;                  // allocate on stack -> faster
    ENTRY *pent=&ent;
    memcpy(pent, pentArg, sizeof(ENTRY));
#else
    ENTRY UNALIGNED const *pent = pentArg;
#endif
    // If this is a Unicode property set, it should be DWORD-aligned.
    PROPASSERT( _CodePage != CP_WINUNICODE
                ||
                IsDwordAligned( (ULONG) pent ));

    // The size consists of the length of the
    // PROPID and character count ...

    ULONG ulSize = CB_ENTRY;

    // Plus the length of the string ...

    ulSize += PropByteSwap( pent->cch ) * 
            ( _CodePage == CP_WINUNICODE
                          ? sizeof( WCHAR )
                          : sizeof( CHAR )
                         );

    // Plus, possibly, padding to make the entry DWORD-aligned
    // (for Unicode property sets).

    if( _CodePage == CP_WINUNICODE )
    {
        ulSize = DwordAlign( ulSize );
    }

    return( ulSize );
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_NextDictionaryEntry
//
// Synopsis:    Given a pointer to an entry in the dictionary,
//              create a pointer to the next entry.
//
// Arguments:   [pent] -- pointer to a dictionary entry.
//
// Returns:     Pointer to the next entry.  If the input
//              points to the last entry in the dictionary,
//              then return a pointer to just beyond the
//              end of the dictionary.
//+--------------------------------------------------------------------------


inline ENTRY UNALIGNED *
CPropertySetStream::_NextDictionaryEntry(
    IN ENTRY UNALIGNED const * pent
    ) const
{   

    return (ENTRY UNALIGNED *)
           Add2Ptr( pent, _DictionaryEntryLength( pent ));

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_SignalCorruption
//
// Synopsis:    possibly PROPASSERT and return data corrupt error
//
// Arguments:   [szReason]              -- string explanation (DBGPROP only)
//              [pstatus]               -- NTSTATUS code.
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_StatusCorruption(
#if DBGPROP
    char *szReason,
#endif
    OUT NTSTATUS *pstatus
    ) const
{
#if DBGPROP
    DebugTrace(0, DEBTRACE_ERROR, (
        "_StatusCorruption(%s, psstm=%lx, mapstm=%lx, %s, flags=%x)\n",
        szReason,
        this,
        KERNELSELECT(&_mstm, _pmstm),
        KERNELSELECT("Kernel", _MSTM(IsNtMappedStream)()? "Nt" : "DocFile"),
        _Flags));

    PROPASSERTMSG(szReason, FALSE);
    DebugTrace(0, DEBTRACE_WARN, (
        "_StatusCorruption(%s, psstm=%lx, mapstm=%lx, %s, flags=%x)\n",
        szReason,
        this,
        KERNELSELECT(&_mstm, _pmstm),
        KERNELSELECT("Kernel", _MSTM(IsNtMappedStream)()? "Nt" : "DocFile"),
        _Flags));
    if (DebugLevel & DEBTRACE_WARN)
    {
        PROPASSERTMSG(szReason, FALSE);
    }

#endif // DBGPROP

    *pstatus = STATUS_INTERNAL_DB_CORRUPTION;
    return;
}


//+--------------------------------------------------------------------------
// Function:    _PropMoveMemory
//
// Synopsis:    call DebugTrace and RtlMoveMemory
//
// Arguments:   [pszReason]             -- string explanation (Debug only)
//              [pvSection]             -- base of section (Debug only)
//              [pvDst]                 -- destination
//              [pvSrc]                 -- source
//              [cbMove]                -- byte count to move
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove)
#else
#define PropMoveMemory(pszReason, pvSection, pvDst, pvSrc, cbMove) \
        _PropMoveMemory(pvDst, pvSrc, cbMove)
#endif

inline VOID
_PropMoveMemory(
#if DBGPROP
    char *pszReason,
    VOID *pvSection,
#endif
    VOID *pvDst,
    VOID const *pvSrc,
    ULONG cbMove)
{
    DebugTrace(0, Dbg, (
        "%s: Moving Dst=%lx(%l" szX ") Src=%lx(%l" szX ") Size=%l" szX "\n",
        pszReason,
        pvDst,
        (BYTE *) pvDst - (BYTE *) pvSection,
        pvSrc,
        (BYTE *) pvSrc - (BYTE *) pvSection,
        cbMove));
    RtlMoveMemory(pvDst, pvSrc, cbMove);
}


inline BOOLEAN
IsReadOnlyPropertySet(BYTE flags, BYTE state)
{
    return(
	(flags & CREATEPROP_MODEMASK) == CREATEPROP_READ ||
	(state & CPSS_USERDEFINEDDELETED) ||
	(state & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS);
}


inline BOOLEAN
IsReadOnlyPropid(PROPID pid)
{
    return(
        pid == PID_DICTIONARY ||
        pid == PID_CODEPAGE ||
        pid == PID_LOCALE ||
        pid == PID_MODIFY_TIME ||
        pid == PID_SECURITY);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::CStreamChunkList
//
// Synopsis:    constructor
//
// Arguments:   [cChunks]               -- count of chunks that will be needed
//
// Returns:     None
//+--------------------------------------------------------------------------

CStreamChunkList::CStreamChunkList(
    ULONG cChunks,
    CStreamChunk *ascnk) :
    _cMaxChunks(cChunks),
    _cChunks(0),
    _ascnk(ascnk),
    _fDelete(FALSE)
{
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Delete
//
// Synopsis:    destructor
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

inline
VOID
CStreamChunkList::Delete(VOID)
{
    if (_fDelete)
    {
        delete [] _ascnk;
    }
#if DBGPROP
    _cMaxChunks = _cChunks = 0;
    _ascnk = NULL;
    _fDelete = FALSE;
#endif
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetChunk
//
// Synopsis:    retrieves a chunk given the index
//
// Arguments:   [i]          -- index of the chunk to retrieve
//
// Returns:     specified chunk pointer
//+--------------------------------------------------------------------------

inline
CStreamChunk const *
CStreamChunkList::GetChunk(ULONG i) const
{
    PROPASSERT(i < _cChunks);
    PROPASSERT(i < _cMaxChunks);
    PROPASSERT(_ascnk != NULL);
    return(&_ascnk[i]);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::Count
//
// Synopsis:    returns the count of chunks
//
// Arguments:   None
//
// Returns:    the number of chunks.
//+--------------------------------------------------------------------------

inline ULONG
CStreamChunkList::Count(VOID) const
{
    return(_cChunks);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::GetFreeChunk
//
// Synopsis:    gets a unused chunk descriptor
//
// Arguments:   [pstatus]   -- NTSTATUS code
//
// Returns:     a ptr to a stream chunk descriptor.
//              This will be NULL if there was an
//              error.
//+--------------------------------------------------------------------------

CStreamChunk *
CStreamChunkList::GetFreeChunk(OUT NTSTATUS *pstatus)
{
    CStreamChunk *pscnk = NULL;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_cChunks < _cMaxChunks);
    if (_ascnk == NULL)
    {
        PROPASSERT(_cChunks == 0);
        _ascnk = newk(mtPropSetStream, NULL) CStreamChunk[_cMaxChunks];
        if (_ascnk == NULL)
        {
            StatusNoMemory(pstatus, "GetFreeChunk");
            goto Exit;
        }
        _fDelete = TRUE;
    }

    pscnk = &_ascnk[_cChunks++];

    //  ----
    //  Exit
    //  ----

Exit:

    return( pscnk );
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::AssertCbChangeTotal
//
// Synopsis:    make sure the computed cbChangeTotal is correct for the chunk
//
// Arguments:   None
//
// Returns:     Nothing
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CStreamChunkList::AssertCbChangeTotal(
    CStreamChunk const *pscnk,
    ULONG cbChangeTotal) const
{
    ULONG cb = 0;
    ULONG i;

    for (i = 0; i < Count(); i++)
    {
        CStreamChunk const *pscnkT = GetChunk(i);

        cb += pscnkT->cbChange;
        if (pscnk == pscnkT)
        {
            PROPASSERT(cb == cbChangeTotal);
            return;
        }
    }
    PROPASSERT(i < Count());
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnChunkCompare
//
// Synopsis:    qsort helper to compare chunks in the chunk list.
//
// Arguments:   [pscnk1]        -- pointer to chunk1
//              [pscnk2]        -- pointer to chunk2
//
// Returns:     difference
//+--------------------------------------------------------------------------

INT __cdecl
fnChunkCompare(VOID const *pscnk1, VOID const *pscnk2)
{
    return(((CStreamChunk const *) pscnk1)->oOld -
           ((CStreamChunk const *) pscnk2)->oOld);
}


//+--------------------------------------------------------------------------
// Member:      CStreamChunkList::SortByStartAddress
//
// Synopsis:    sort all the chunks that are being modified in a stream in the
//              ascending order.
//
// Arguments:   None
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CStreamChunkList::SortByStartAddress(VOID)
{
    DebugTrace(0, Dbg, ("Sorting %l" szX " Chunks @%lx\n", _cChunks, _ascnk));

    qsort(_ascnk, _cChunks, sizeof(_ascnk[0]), fnChunkCompare);

#if DBGPROP
    LONG cbChangeTotal;
    ULONG i;

    cbChangeTotal = 0;
    for (i = 0; i < _cChunks; i++)
    {
        cbChangeTotal += _ascnk[i].cbChange;

        DebugTrace(0, Dbg, (
            "Chunk[%l" szX "] oOld=%l" szX " cbChange=%s%l" szX
                " cbChangeTotal=%s%l" szX "\n",
            i,
            _ascnk[i].oOld,
            _ascnk[i].cbChange < 0? "-" : "",
            _ascnk[i].cbChange < 0? -_ascnk[i].cbChange : _ascnk[i].cbChange,
            cbChangeTotal < 0? "-" : "",
            cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal));
    }
#endif
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetFormatidOffset
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline FORMATIDOFFSET *
CPropertySetStream::_GetFormatidOffset(ULONG iSection) const
{
    return(&((FORMATIDOFFSET *) Add2Ptr(_pph, sizeof(*_pph)))[iSection]);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the (first) section header
//
// Arguments:   None
//
// Returns:     pointer to section header
//+--------------------------------------------------------------------------

inline PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(VOID) const
{
    return((PROPERTYSECTIONHEADER *) Add2Ptr(_pph, _oSection));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetSectionHeader
//
// Synopsis:    Get a pointer to the specified section header
//
// Arguments:   [iSection]      -- section number
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     pointer to specified section header
//+--------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_GetSectionHeader(ULONG iSection, OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;
    PROPERTYSECTIONHEADER *psh = NULL;

    ULONG oSection = 0;                 // Assume no header
    ULONG cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Don't assume *any* class variables (except _pph) are loaded yet!

    PROPASSERT(_HasPropHeader() || iSection == 0);

    if (_HasPropHeader())
    {
        PROPASSERT(iSection < _pph->reserved );
        oSection = MAXULONG;
        if (cbstm >= CB_PROPERTYSETHEADER + (iSection + 1) * CB_FORMATIDOFFSET)
        {
            oSection = _GetFormatidOffset(iSection)->dwOffset;
        }
    }
    if (oSection != MAXULONG &&
        cbstm >= oSection + CB_PROPERTYSECTIONHEADER)
    {
        psh = (PROPERTYSECTIONHEADER *) Add2Ptr(_pph, oSection);

        if( cbstm >= oSection + psh->cbSection )
        {
            goto Exit;
        }
        else
        {
            psh = NULL;
        }
    }

    StatusCorruption(pstatus, "GetSectionHeader(i): stream size");

    //  ----
    //  Exit
    //  ----

Exit:

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_SearchForCodePage, private
//
// Synopsis:    Searches a section of a property set for the code page.
//
//              This routine searches for the code page by iterating
//              through the PID/Offset array in search of
//              PID_CODEPAGE.  The difference between calling
//              this routine, and calling GetValue(PID_CODEPAGE),
//              is that this routine does not assume that the
//              property set is formatted correctly; it only assumes
//              that the PID/Offset array is correct.
//
//              Note that this routine is like a specialized _LoadProperty(),
//              the important difference is that this routine must use
//              unaligned pointers, since it cannot assume that the
//              property set is aligned properly.
//
// Pre-Conditions:
//              The PID/Offset array is correct.
//              &&
//              _oSection & _cSection are set correctly.
//
// Post-Conditions:
//              If PID_CODEPAGE exists, it is put into _CodePage.
//              If it doesn't exist, _CodePage is left unchanged.
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None.
//+-------------------------------------------------------------------------
VOID
CPropertySetStream::_SearchForCodePage( OUT NTSTATUS *pstatus )
{

    PROPERTYSECTIONHEADER UNALIGNED *psh;
    PROPERTYIDOFFSET UNALIGNED      *ppo;
    PROPERTYIDOFFSET UNALIGNED      *ppoMax;
#if i386 == 0
    PROPERTYSECTIONHEADER shCopy;
#endif
    PROPERTYSECTIONHEADER *pshCopy;
    ULONG cbstm;

    *pstatus = STATUS_SUCCESS;

    // Verify the pre-conditions.

    PROPASSERT( _oSection != 0 );
    PROPASSERT( _cSection != 0 );

    // It's invalid to call any function on a deleted
    // DocSumInfo user-defined (section section) section.

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }

    // Get the section's header and first & last PID/Offset pointers.
    // We can't use _LoadPropertyOffsetPointers, because it assumes
    // alignment.


    psh = _GetSectionHeader();    

#if i386 == 0
    memcpy(&shCopy, psh, sizeof(shCopy));
    // note that the copy should not be used to access rgprop, which
    // is a variable sized char arr.
    pshCopy=&shCopy; 
#else
    pshCopy = psh;   // okay to access unaligned on i386
#endif

    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER
        || cbstm < _oSection + CB_PROPERTYSECTIONHEADER
           + pshCopy->cProperties * CB_PROPERTYIDOFFSET
        || cbstm < _oSection + pshCopy->cbSection)
    {
        StatusCorruption(pstatus, "_SearchForCodePage: stream size");
        goto Exit;
    }

    ppo = (PROPERTYIDOFFSET UNALIGNED *) 
        Add2Ptr(psh, CB_PROPERTYSECTIONHEADER);

    ppoMax = ppo + pshCopy->cProperties;

    // Search the PID/Offset array for PID_CODEPAGE

    for ( ; ppo < ppoMax; ppo++)
    {
        if (PIDOFFSET_GetPropid(ppo) == PID_CODEPAGE)
        {
            SERIALIZEDPROPERTYVALUE UNALIGNED *pprop;
            pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress( PIDOFFSET_GetOffset(ppo) );

            // Get the real address of serialized property.

            // Check for corruption.

            if ( ( ( PIDOFFSET_GetOffset(ppo) + 
                    CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD) )
                   >
                   pshCopy->cbSection
                 )
                 ||
                 PropByteSwap(SPV_GetType(pprop)) != VT_I2
               )
            {
                StatusCorruption(pstatus, "_SearchForCodePage");
                goto Exit;
            }

            // Set the member code page from the serialized property.
            // (The codepage is an I2).

            // we do memcpy to avoid alignment problems
            memcpy(&_CodePage, SPV_GetRgb(pprop), sizeof(_CodePage));
            _CodePage = PropByteSwap(_CodePage);

            break;

        }   // if (PIDOFFSET_GetPropid(ppo) == PID_CODEPAGE)
    }   // for ( ; ppo < ppoMax; ppo++)

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_SearchForCodePage()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address in the section
//
// Returns:     section-relative offset for passed pointer
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToOffset(VOID const *pvAddr) const
{
    PROPASSERT(_cSection != 0);

    // Get a ptr to the section header.
    VOID const *pvSectionHeader = _GetSectionHeader();

    PROPASSERT((BYTE const *) pvAddr >= (BYTE const *) pvSectionHeader);
    return((BYTE const *) pvAddr - (BYTE const *) pvSectionHeader);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAbsOffsetToAddress, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [oAbsolute]      -- the absolute offset
//
// Returns:     a ptr to the offset mapped
//+--------------------------------------------------------------------------

inline VOID *
CPropertySetStream::_MapAbsOffsetToAddress(ULONG oAbsolute) const
{
    return(Add2Ptr(_pph, oAbsolute));
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_MapAddressToAbsOffset, private
//
// Synopsis:    maps an address to an offset
//
// Arguments:   [pvAddr]        -- the address
//
// Returns:     the absolute offset
//+--------------------------------------------------------------------------

inline ULONG
CPropertySetStream::_MapAddressToAbsOffset(VOID const *pvAddr) const
{
    PROPASSERT((BYTE const *) pvAddr >= (BYTE *) _pph);
    return((BYTE const *) pvAddr - (BYTE *) _pph);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::CPropertySetStream
//
// Synopsis:    constructor for property set class
//
// Arguments:UK [Flags] -- NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
//            K [pscb]          -- SCB for property stream
//            K [pirpc]         -- pointer to Irp Context
//            K [State]         -- CPSS_PROPHEADER
//           U  [pmstm]         -- mapped stream implementation
//           U  [pma]           -- caller's memory allocator
//
// Returns:     None
//---------------------------------------------------------------------------

CPropertySetStream::CPropertySetStream(
    IN USHORT Flags,	// NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE
    IN CMappedStream *pmstm,    // mapped stream impelementation
    IN PMemoryAllocator *pma    // caller's memory allocator
    ) 
    :
    _Flags((BYTE) Flags),
    _State(0),
    _pmstm(pmstm),
    _pma(pma),
    _pph(NULL)
{
    _CodePage = CP_CREATEDEFAULT(_State);       // Default if not present
    PROPASSERT(_Flags == Flags);                // Should fit in a byte
    _oSection = 0;
    _cSection = 0;
    _cbTail   = 0;
        
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Close
//
// Synopsis:    shutdown property set prior to calling destructor
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Close(OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    // Validate the byte-order (_pph could be NULL in certain
    // close scenarios, e.g. an RtlCreatePropertySet fails).
    PROPASSERT(NULL == _pph || PROPSET_BYTEORDER == _pph->wByteOrder);
    PROPASSERT(
        (_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ ||
        !IsModified());

    _MSTM(Unmap)(IsModified(), (VOID **) &_pph);

    _MSTM(Close)(pstatus);
//  if( !NT_SUCCESS(*pstatus) ) goto Exit;

//Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Open
//
// Synopsis:    Open property set image
//
// Arguments:   None
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::Open(
    IN GUID const *pfmtid,	    // property set fmtid
    OPTIONAL IN GUID const *pclsid, // CLASSID of propset code (create only)
    IN ULONG LocaleId,		    // Locale Id (create only)
    OPTIONAL OUT ULONG *pOSVersion, // OS Version from header
    IN USHORT CodePage,             // CodePage of property set (create only)
    OUT NTSTATUS *pstatus
    )
{
    *pstatus = STATUS_SUCCESS;
    LOADSTATE LoadState;
    PROPASSERT(!_IsMapped());

    if( pOSVersion != NULL )
        *pOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;

    // Open the underlying stream which holds the property set.
    // We give it a callback pointer so that it can call
    // RtlOnMappedStreamEvent.

    _MSTM(Open)(this, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Load the header, including fixing the in-memory image of
    // poorly-formatted property sets.

    LoadState = _LoadHeader(pfmtid, _Flags & CREATEPROP_MODEMASK, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	switch (_Flags & CREATEPROP_MODEMASK)
	{
	    case CREATEPROP_READ:
	    case CREATEPROP_WRITE:
    		if (LoadState == LOADSTATE_FAIL)
		{
		    StatusCorruption(pstatus, "Open: _LoadHeader");
                    goto Exit;
		}
		PROPASSERT(
		    LoadState == LOADSTATE_BADFMTID ||
		    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
		DebugTrace(0, DEBTRACE_ERROR, (
		    "_LoadHeader: LoadState=%x\n", LoadState));

                *pstatus = STATUS_PROPSET_NOT_FOUND;
		goto Exit;
	}

        _Create(
            pfmtid,
            pclsid,
	    LocaleId,
            CodePage,
	    LoadState,
            pstatus
            );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

    }   // if (LoadState != LOADSTATE_DONE)

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_HasPropHeader() &&
        (_pph->dwOSVer == PROPSETVER_WIN310 ||
         _pph->dwOSVer == PROPSETVER_WIN333))
    {
        DebugTrace(0, DEBTRACE_PROPPATCH, (
            "Open(%s) downlevel: %x\n",
            (_Flags & CREATEPROP_MODEMASK) == CREATEPROP_READ? "Read" : "Write",
            _Flags));
        _State |= CPSS_DOWNLEVEL;
    }

    if ((_Flags & CREATEPROP_MODEMASK) != CREATEPROP_READ)
    {
        if (_State & CPSS_PACKEDPROPERTIES)
        {
            StatusAccessDenied(pstatus, "Open: writing Unaligned propset");
            goto Exit;
        }
        if ((_State & (CPSS_MULTIPLESECTIONS | CPSS_DOCUMENTSUMMARYINFO)) ==
	    CPSS_MULTIPLESECTIONS)
        {
            StatusAccessDenied(pstatus, "Open: writing unknown multiple section propset");
            goto Exit;
        }
    }

    // Return the OS Version to the caller.

    if( pOSVersion != NULL )
        *pOSVersion = _pph->dwOSVer;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ReOpen
//
// Synopsis:    ReOpen property set image
//
// Arguments:   [pstatus]       -- Pointer to NSTATUS code.
//
// Returns:     Number of properties.
//---------------------------------------------------------------------------

ULONG
CPropertySetStream::ReOpen(OUT NTSTATUS *pstatus)
{
    LOADSTATE LoadState;
    PROPERTYSECTIONHEADER const *psh;
    ULONG cProperties = 0;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    _MSTM(ReOpen)((VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	goto Exit;
    }

    LoadState = _LoadHeader(NULL,
                            CREATEPROP_READ,  // all we need is !create
                            pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (LoadState != LOADSTATE_DONE)
    {
	DebugTrace(0, DEBTRACE_ERROR, (
	    "ReOpen: LoadState=%lx\n",
	    LoadState));
        StatusCorruption(pstatus, "ReOpen: _LoadHeader");
        goto Exit;
    }

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    psh = _GetSectionHeader();
    PROPASSERT(psh != NULL);

    cProperties = psh->cProperties;

    //  ----
    //  Exit
    //  ----

Exit:

    return( cProperties );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InitSection
//
// Synopsis:    Initialize a section header and the default properties.
//
// Arguments:   [pfo]		-- pointer to section info
//		[LocaleId]	-- Locale Id
//
// Returns:     None
//---------------------------------------------------------------------------

        // Serialized Code-Page size
#define CB_CODEPAGE         (sizeof(ULONG) + DwordAlign(sizeof(USHORT)))

        // Serialized Locale ID (LCID) size.
#define CB_LOCALE	    (sizeof(ULONG) + sizeof(ULONG))

        // Minimum section size (minimum has Code Page & LCID)
#define CB_MINSECTIONSIZE   (CB_PROPERTYSECTIONHEADER   \
                             + 2 * CB_PROPERTYIDOFFSET  \
                             + CB_CODEPAGE              \
                             + CB_LOCALE)

        // Minimum serialized dictionary size (a dict with no entries).
#define CB_EMPTYDICTSIZE    (sizeof(DWORD)) // Entry count

        // Minimum User-Defined section size (in DocumentSummaryInformation propset).
        // (Must include an empty dictionary & a PID/Offset for it.)
#define CB_MINUSERDEFSECTIONSIZE                    \
                            (CB_MINSECTIONSIZE      \
                             +                      \
                             CB_PROPERTYIDOFFSET    \
                             +                      \
                             CB_EMPTYDICTSIZE)

VOID
CPropertySetStream::_InitSection(
    IN FORMATIDOFFSET *pfo,
    IN ULONG LocaleId,
    IN BOOL  fCreateDictionary  // Create an empty dictionary?
    )
{
    PROPERTYSECTIONHEADER *psh;

    ULONG ulPropIndex;     // Index into the PID/Offset array.
    DWORD dwPropValOffset; // The offset to where the next prop val will be written.
                           // Pointer to a serialized property value.
    SERIALIZEDPROPERTYVALUE *pprop;

    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

    // Set the property count and section size in the section header.
    // This must account for the Code Page and Locale ID properties, and
    // might need to account for an empty dictionary property.
    // dwPropValOffset identifies the location of the next property value
    // to be written.

    if( fCreateDictionary )
    {
        // Three properties:  Code Page, LCID, and Dictionary.

        psh->cProperties = 3;
        dwPropValOffset  = CB_PROPERTYSECTIONHEADER + 3 * CB_PROPERTYIDOFFSET;
        psh->cbSection   = CB_MINUSERDEFSECTIONSIZE;
    }
    else
    {
        // Two properties:  Code Page and LCID (no dictionary).

        psh->cProperties = 2;
        dwPropValOffset  = CB_PROPERTYSECTIONHEADER + 2 * CB_PROPERTYIDOFFSET;
        psh->cbSection   = CB_MINSECTIONSIZE;
    }


    ulPropIndex = 0;

    // If requested by the caller, create a dictionary property, but
    // leave the dictionary empty.  We always create this first.  It shouldn't
    // matter where it's located, but Office95 requires it
    // and it doesn't do any harm to put it there.

    if( fCreateDictionary )
    {
        // Fill in the PID/Offset table.

        psh->rgprop[ ulPropIndex ].propid = PID_DICTIONARY;
        psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

        // Fill in the property value.

        pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
        pprop->dwType = 0L; // For the dictonary, this is actually the entry count.

        // Advance the table & value indices.

        ulPropIndex++;
        dwPropValOffset += CB_EMPTYDICTSIZE;

    }   // if( fCreateDictionary )


    // Write the code page.  We write a zero first to initialize
    // the padding bytes.
    
    psh->rgprop[ ulPropIndex ].propid = PID_CODEPAGE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr( psh, dwPropValOffset );
    pprop->dwType = PropByteSwap((DWORD) VT_I2);
    *(DWORD *) pprop->rgb = 0;   // Zero out extra two bytes.
    *(WORD  *) pprop->rgb = PropByteSwap( _CodePage );
    
    ulPropIndex++;
    dwPropValOffset += CB_CODEPAGE;


    // Write the Locale ID.

    psh->rgprop[ ulPropIndex ].propid = PID_LOCALE;
    psh->rgprop[ ulPropIndex ].dwOffset = dwPropValOffset;

    pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(psh, dwPropValOffset );
    pprop->dwType = PropByteSwap( (DWORD) VT_UI4 );
    *(DWORD *) pprop->rgb = PropByteSwap( (DWORD) LocaleId );

}




//+---------------------------------------------------------------------------
// Member:      CPropertySetStream:: _MultiByteToWideChar, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//                              (-1 if null terminated)
//              [CodePage]   -- Codepage of input string.
//              [ppwc]       -- pointer to pointer to converted string
//                              (if *ppwc is NULL, it will be alloced,
//                              if non-NULL, *ppwc must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppwc
//                              OUT: byte length of Unicode string.
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_MultiByteToWideChar(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppwc?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);

    PROPASSERT(IsAnsiString(pch, ((ULONG)-1 == cb ) ? MAXULONG : cb));

    PROPASSERT(NULL != *ppwc || 0 == *pcb);
    PROPASSERT(UnicodeCallouts.pfnMultiByteToWideChar != NULL);

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt to convert the string.

	*pcb = (*UnicodeCallouts.pfnMultiByteToWideChar)(
				    CodePage,   // Source codepage
				    0,          // Flags
				    pch,        // Source string
				    cb,         // Source string length
				    *ppwc,      // Target string
				    *pcb);      // Size of target string buffer

        // The converted length should never be zero.
	if (0 == *pcb)
	{
            // If we alloced a buffer, free it now.
            if( fAlloc )
            {
	        _pma->Free( *ppwc );
                *ppwc = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // There was no error.  If we provided a non-NULL buffer,
        // then the conversion was performed and we're done.

	*pcb *= sizeof(WCHAR);  // cch => cb
	if (*ppwc != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"_MultiByteToWideChar: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
		pch,
		cb,
		*ppwc,
		*pcb,
		*pcb * sizeof(WCHAR)));
	    break;
	}

        // We haven't actually the string yet.  Now that
        // we know the length, we can allocate a buffer and try the
        // conversion for real.

	*ppwc = (WCHAR *) _pma->Allocate( *pcb );
	if (NULL == *ppwc)
	{
	    StatusNoMemory(pstatus, "_MultiByteToWideChar: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while(TRUE)

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_MultiByteToWideChar



//+---------------------------------------------------------------------------
// Member:      CPropertySetStream::_WideCharToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string,
//              using the _pma memory allocator if necessary.
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cch]        -- character length of Unicode string
//                              (-1 if null terminated)
//              [CodePage]   -- codepage of target string
//              [ppch]       -- pointer to pointer to converted string
//                              (if *ppch is NULL, it will be alloced,
//                              if non-NULL, *ppch must be *pcb bytes long).
//              [pcb]        -- IN:  byte length of *ppch
//                              OUT: byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_WideCharToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cch,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    // Did we allocate *ppch?
    BOOL fAlloc = FALSE;

    //  --------------
    //  Initialization
    //  --------------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);

    PROPASSERT(IsUnicodeString(pwc, ((ULONG)-1 == cch ) ? MAXULONG : cch*sizeof(WCHAR)));

    PROPASSERT(NULL != *ppch || 0 == *pcb);
    PROPASSERT(UnicodeCallouts.pfnWideCharToMultiByte != NULL);

    //  ------------------
    //  Convert the String
    //  ------------------

    // We will pass through this loop once (if the caller provided a buffer
    // or twice (otherwise).

    while (TRUE)
    {
        // Attempt the conversion.
	*pcb = (*UnicodeCallouts.pfnWideCharToMultiByte)(
				    CodePage,       // Codepage to convert to
				    0,              // Flags
				    pwc,            // Source string
				    cch,            // Size of source string
				    *ppch,          // Target string
				    *pcb,           // Size of target string buffer
				    NULL,           // lpDefaultChar
				    NULL);          // lpUsedDefaultChar

        // A converted length of zero indicates an error.
	if (0 == *pcb)
	{
            // If we allocated a buffer in this routine, free it.
            if( fAlloc )
            {
	        _pma->Free( *ppch );
                *ppch = NULL;
            }

            // If there was an error, assume that it was a code-page
            // incompatibility problem.

            StatusError(pstatus, "_WideCharToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}

        // If we have a non-zero length, and we provided a buffer,
        // then we're done (successfully).

	if (*ppch != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"_WideCharToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
		pwc,
		cch,
		*ppch,
		*pcb,
		*pcb));
	    break;
	}

        // There were no errors, but we need to allocate a buffer
        // to do the actual conversion.

	*ppch = (CHAR*) _pma->Allocate( *pcb );
	if (*ppch == NULL)
	{
	    StatusNoMemory(pstatus, "_WideCharToMultiByte: no memory");
            goto Exit;
	}
        fAlloc = TRUE;

    }   // while (TRUE)


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_WideCharToMultiByte


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::ByteSwapHeaders
//
// Synopsis:    Byte-swap the headers of a property set header
//              (both the propset header and any section headers).
//
// Arguments:   [PROPERTYSETHEADER*] pph
//                  Pointer to the beginning of the property set.
//              [ULONG] cbstm
//                  Total size of the property stream.
//              [NTSTATUS*] pstatus
//                  Pointer to NTSTATUS code.
//
// Pre-Conditions:
//              There are no more than two sections.
//
//              Note that this routine does not assume anything
//              about the current state of the CPropertySetStream
//              (it accesses no member variables).
//
// Post-Conditions:
//              If the byte-order indicator is valid, the
//              propset and section headers are byte-swapped
//
// Returns:     None.  *pstatus will only be non-successful
//              if the Stream was too small for the property set
//              (i.e, the property set is corrupt).  If the caller
//              knows this not to be the case, then it can assume
//              that this routine will return STATUS_SUCCESS.
//
//---------------------------------------------------------------------------

VOID
CPropertySetStream::ByteSwapHeaders( IN PROPERTYSETHEADER *pph,
                                     IN DWORD cbstm,
                                     OUT NTSTATUS *pstatus )
{
#if LITTLEENDIAN

    *pstatus = STATUS_SUCCESS;
    return;

#else
    
    //  ------
    //  Locals
    //  ------

    ULONG cSections;
    ULONG ulIndex, ulSectionIndex;

    // pfoPropSet points into pph, pfoReal is a local copy
    // in the system's endian-ness.
    FORMATIDOFFSET *pfoPropSet, pfoReal[2];

    // Pointers into pph.
    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *po = NULL;

    // Are we converting *to* the system's endian-ness?
    BOOL fToSystemEndian;

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( NULL != pph );
    PROPASSERT(PROPSET_BYTEORDER == pph->wByteOrder
               ||
               PROPSET_BYTEORDER == ByteSwap( pph->wByteOrder )
              );


    //  ----------------------------
    //  Swap the Property Set header
    //  ----------------------------

    // Validate the stream length.
    if( sizeof(*pph) > cbstm )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    // Swap the fields in place.
    PropByteSwap( &pph->wByteOrder );
    PropByteSwap( &pph->wFormat );
    PropByteSwap( &pph->dwOSVer );
    PropByteSwap( &pph->clsid );
    PropByteSwap( &pph->reserved );

    // Are we converting to little-endian?
    if( PROPSET_BYTEORDER == pph->wByteOrder)
        fToSystemEndian = TRUE;
    else
    {
        fToSystemEndian = FALSE;
        PROPASSERT( PROPSET_BYTEORDER == PropByteSwap(pph->wByteOrder) );
    }

    // Get the correctly-endianed section count and validate.

    cSections = fToSystemEndian ? pph->reserved
                                : PropByteSwap( pph->reserved );

    if( cSections > 2 )
    {
        StatusCorruption(pstatus, "CPropertySetStream::ByteSwapHeaders: PropertySet header size");
        goto Exit;
    }

    //  -------------------------
    //  Swap the per-section data
    //  -------------------------

    pfoPropSet = (FORMATIDOFFSET*) ((BYTE*) pph + sizeof(*pph));
    
    for( ulSectionIndex = 0; ulSectionIndex < cSections; ulSectionIndex++ )
    {
        ULONG cbSection, cProperties;

        //  ------------------------------
        //  Swap the FormatID/Offset entry
        //  ------------------------------

        // Is the Stream long enough for the array?
        if( cbstm < (ULONG) &pfoPropSet[ulSectionIndex]
                    + sizeof(*pfoPropSet)
                    - (ULONG) pph )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::_ByteSwapHeaders: FormatID/Offset size");
            goto Exit;
        }

        // Swap this FMTID/Offset entry in place.
        PropByteSwap( &pfoPropSet[ulSectionIndex].fmtid );
        PropByteSwap( &pfoPropSet[ulSectionIndex].dwOffset );

        // Get a local copy of this array entry.
        // Since we just swapped these values, we may need to swap the
        // local copies back in order to make them usable.

        pfoReal[ ulSectionIndex ].fmtid    = pfoPropSet[ulSectionIndex].fmtid;
        pfoReal[ ulSectionIndex ].dwOffset = pfoPropSet[ulSectionIndex].dwOffset;

        if( !fToSystemEndian )
        {
            PropByteSwap( &pfoReal[ulSectionIndex].fmtid );
            PropByteSwap( &pfoReal[ulSectionIndex].dwOffset );
        }


        //  -----------------------
        //  Swap the section header
        //  -----------------------

        // Locate the section header and the first entry in the
        // PID/Offset table.

        psh = (PROPERTYSECTIONHEADER*)
              ( (BYTE*) pph + pfoReal[ ulSectionIndex ].dwOffset );
        
        po = (PROPERTYIDOFFSET*)
             ( (BYTE*) psh + sizeof(psh->cbSection) + sizeof(psh->cProperties) );

        // Validate that we can see up to the PID/Offset table.
        if( cbstm < (ULONG) ((BYTE*) po - (BYTE*) pph) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Swap the two fields at the top of the section header,
        // and make local copies.  Again, we may need to swap the
        // local copies to make them usable.

        cbSection = psh->cbSection = PropByteSwap(psh->cbSection);
        cProperties = psh->cProperties = PropByteSwap( psh->cProperties );

        if( !fToSystemEndian)
        {
            PropByteSwap( &cbSection );
            PropByteSwap( &cProperties );
        }

        //  -------------------------
        //  Swap the PID/Offset table
        //  -------------------------

        // Validate that we can see the whole table.
        if( cbstm < (BYTE*) po - (BYTE*) pph + cProperties * sizeof(*po) )
        {
            StatusCorruption(pstatus,
                             "CPropertySetStream::ByteSwapHeaders: Section header size");
            goto Exit;
        }

        // Swap each of the array entries.
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            PropByteSwap( &po[ulIndex].propid );
            PropByteSwap( &po[ulIndex].dwOffset );
        }

    }   // for( ulSectionIndex = 0; ulSectionIndex < cSections, ulIndex++ )

    //  ----
    //  Exit
    //  ----

Exit:

    return;

#endif // #if LITTLEENDIAN ... #else

}   // CPropertySetStream::ByteSwapHeaders


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CreateUserDefinedSection
//
// Synopsis:    Create second property section
//
// Arguments:   [LoadState]	-- _LoadHeader returned state
//		[LocaleId]	-- Locale Id
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     TRUE if LoadState handled successfully.  If TRUE,
//              *pstatus will be STATUS_SUCCESS.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_CreateUserDefinedSection(
    IN LOADSTATE LoadState,
    IN ULONG LocaleId,
    OUT NTSTATUS *pstatus)
{
    BOOL fSuccess = FALSE;
    FORMATIDOFFSET *pfo;
    ULONG cbstmNew;
    PROPERTYSECTIONHEADER *psh;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_State & CPSS_USERDEFINEDPROPERTIES);
    switch (_Flags & CREATEPROP_MODEMASK)
    {
    case CREATEPROP_CREATEIF:
    case CREATEPROP_CREATE:
	if (LoadState == LOADSTATE_USERDEFINEDNOTFOUND)
	{
	    ULONG cbmove;

	    PROPASSERT(_cSection == 1);
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));

            // Get a pointer to the first section header, using the 
            // FmtID/Offset array.

	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

            // Determine if we need to move the first section back in order
            // to make room for this new entry in the FmtID/Offset array.

	    cbmove = 0;
	    if (pfo->dwOffset < CB_PROPERTYSETHEADER + 2 * CB_FORMATIDOFFSET)
	    {
		cbmove = CB_PROPERTYSETHEADER + 2*CB_FORMATIDOFFSET - pfo->dwOffset;
	    }

            // How big should the Stream be?

	    cbstmNew = pfo->dwOffset            // The offset of the first section
                            +
			    cbmove              // Room for new FormatID/Offset array entry
                            +                   // Size of first section
			    DwordAlign(psh->cbSection)
                            +                   // Size of User-Defined section.
			    CB_MINUSERDEFSECTIONSIZE;

            // Set the stream size.

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    pfo = _GetFormatidOffset(0);
	    psh = (PROPERTYSECTIONHEADER *) _MapAbsOffsetToAddress(pfo->dwOffset);

	    if (cbmove != 0)
	    {
		// Move section back to make room for new FORMATIDOFFSET entry

		PropMoveMemory(
			"_AddSection",
			psh,
			Add2Ptr(psh, cbmove),
			psh,
			psh->cbSection);

		pfo->dwOffset += cbmove;
		PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    }

	    psh->cbSection = DwordAlign(psh->cbSection);

            PROPASSERT(_oSection == 0);
	    PROPASSERT(_cSection == 1);
	    PROPASSERT(_pph->reserved == 1);

	    _cSection++;
	    _pph->reserved++;

	    _oSection = pfo->dwOffset + psh->cbSection;
	    pfo = _GetFormatidOffset(1);
	    pfo->fmtid = guidDocumentSummarySection2;
	    pfo->dwOffset = _oSection;
	    _InitSection(pfo,
                         LocaleId,
                         TRUE ); // Create an empty dictionary.

	    fSuccess = TRUE;
	}
	break;

    case CREATEPROP_DELETE:
	PROPASSERT(
	    LoadState == LOADSTATE_USERDEFINEDDELETE ||
	    LoadState == LOADSTATE_USERDEFINEDNOTFOUND);
	if (LoadState == LOADSTATE_USERDEFINEDDELETE)
	{
	    PROPASSERT(_cSection == 2);
	    PROPASSERT(_pph->reserved == 2);
	    pfo = _GetFormatidOffset(1);
	    RtlZeroMemory(pfo, sizeof(*pfo));

	    _cSection--;
	    _pph->reserved--;
	    pfo = _GetFormatidOffset(0);
	    PROPASSERT(pfo->fmtid == guidDocumentSummary);
	    PROPASSERT(IsDwordAligned(pfo->dwOffset));
	    psh = (PROPERTYSECTIONHEADER *)
			_MapAbsOffsetToAddress(pfo->dwOffset);
	    psh->cbSection = DwordAlign(psh->cbSection);
	    cbstmNew = pfo->dwOffset + psh->cbSection;

	    _MSTM(SetSize)(cbstmNew, TRUE, (VOID **) &_pph, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            
	}
	_State |= CPSS_USERDEFINEDDELETED;

	fSuccess = TRUE;
        break;

    default:
	PROPASSERT(!"_Flags: bad open mode");
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return( fSuccess );
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_Create
//
// Synopsis:    Create property set image
//
// Arguments:   [pfmtid]        -- format id
//              [pclsid]        -- class id
//		[LocaleId]	-- Locale Id
//              [CodePage]      -- CodePage
//		[LoadState]	-- _LoadHeader returned state
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::_Create(
    IN GUID const *pfmtid,
    OPTIONAL IN GUID const *pclsid,
    IN ULONG LocaleId,		    // Locale Id (create only)
    IN USHORT CodePage,
    IN LOADSTATE LoadState,
    OUT NTSTATUS *pstatus
    )
{
    ULONG cb;
    FORMATIDOFFSET *pfo;

    *pstatus = STATUS_SUCCESS;

    _SetModified();

    // Set the size of the stream to correspond to the header for the
    // property set as well as the section.

    _CodePage = CodePage;
    ULONG cSectionT = 1;

    // Are we creating the UserDefined property set
    // (the second section of the DocumentSummaryInformation
    // property set)?

    if (_State & CPSS_USERDEFINEDPROPERTIES)
    {
        // Create the UD propset, and set the cSection.
        // If this routine returns TRUE, it means that
        // the first section already existed, and we're done.
        // Otherwise, we must continue and create the first section.

	if (_CreateUserDefinedSection(LoadState, LocaleId, pstatus))
	{
            // If we get here, we know that *pstatus is Success.

	    if (pclsid != NULL)
	    {
		_pph->clsid = *pclsid;
	    }
	    goto Exit;
	}
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

	cSectionT = 2;
    }

    // Calculate the exact size of the Stream (we know exactly
    // what it will be because we only initialize the set(s) with
    // fixed size data).

    PROPASSERT( 1 <= cSectionT && cSectionT <= 2 );
    cb = CB_PROPERTYSETHEADER       // The size of the propset header.
         +                          // The size of the FmtID/Offset array
         cSectionT * CB_FORMATIDOFFSET
         +
         CB_MINSECTIONSIZE          // The size of the first section
         +                          // Maybe the size of the User-Defined section
         ( cSectionT <= 1 ? 0 : CB_MINUSERDEFSECTIONSIZE );


    DebugTrace(0, Dbg, ("SetSize(%x) init\n", cb));

    // Set the size of the stream 
    _MSTM(SetSize)(cb, TRUE, (VOID **) &_pph, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // And get a mapping of the Stream.
    _MSTM(Map)(TRUE, (VOID **) &_pph);
    RtlZeroMemory(_pph, cb);            // Zeros classid, fmtid(s), etc

    // Initialize the header

    _pph->wByteOrder = 0xfffe;
    //_pph->wFormat = 0;                // RtlZeroMemory does this
    PROPASSERT(_pph->wFormat == 0);
    _pph->dwOSVer = PROPSETVER_CURRENT;
    if (pclsid != NULL)
    {
	_pph->clsid = *pclsid;
    }
    _pph->reserved = cSectionT;

    // Initialize the format id offset for the section(s).

    pfo = _GetFormatidOffset(0);
    pfo->dwOffset = CB_PROPERTYSETHEADER + cSectionT * CB_FORMATIDOFFSET;

    // Are we creating the second section of the DocSumInfo property set?

    if (cSectionT == 2)
    {
        // We need to initialize any empty first section.

	pfo->fmtid = guidDocumentSummary;

	_InitSection(pfo,
                     LocaleId,
                     FALSE); // Don't create an empty dictionary.

        // Advance the FmtID/Offset table pointer to the second entry,
        // and set it's offset to just beyond the first section.

	pfo = _GetFormatidOffset(1);
	pfo->dwOffset = CB_PROPERTYSETHEADER +
			cSectionT * CB_FORMATIDOFFSET +
			CB_MINSECTIONSIZE;
    }

    // Initialize the requested property set.

    PROPASSERT(pfmtid != NULL);
    pfo->fmtid = *pfmtid;
    _InitSection(pfo,
                 LocaleId,
                           // TRUE => Create an empty dictionary
                 pfo->fmtid == guidDocumentSummarySection2 );

    _cSection = cSectionT;
    _oSection = pfo->dwOffset;


    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // CPropertySetStream::_Create


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadHeader
//
// Synopsis:    verify header of a property set and read the code page
//
// Arguments:   [pfmtid]        -- format id
//		[Mode]		-- open mode
//              [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     LOADSTATE
//---------------------------------------------------------------------------

LOADSTATE
CPropertySetStream::_LoadHeader(
    OPTIONAL IN GUID const *pfmtid,
    IN BYTE Mode,
    OUT NTSTATUS *pstatus)
{
    LOADSTATE loadstate = LOADSTATE_FAIL;
    ULONG cbstm, cbMin;
    PROPERTYSECTIONHEADER *psh;
    FORMATIDOFFSET const *pfo;
    BOOLEAN fSummaryInformation = FALSE;
#if DBGPROP
    BOOLEAN fFirst = _pph == NULL;
#endif

    *pstatus = STATUS_SUCCESS;

    PROPASSERT((_State & CPSS_USERDEFINEDDELETED) == 0);

    // If this is one of the DocSumInfo property sets,
    // we need to set some _State bits.  If this is an
    // Open, rather than a Create, pfmtid may be NULL.
    // In that case, we'll set these bits after the open
    // (since we can then get the fmtid from the header).

    if( pfmtid != NULL && *pfmtid == guidDocumentSummary )
    {
        _State |= CPSS_DOCUMENTSUMMARYINFO;
    }

    if (pfmtid != NULL && *pfmtid == guidDocumentSummarySection2)
    {
	_State |= CPSS_USERDEFINEDPROPERTIES;
    }
    else
    {
        // If this isn't the UD property set, the Mode
        // better not be "Delete" (all other property sets
        // are deleted simply be deleting the underlying
        // stream).

	if (Mode == CREATEPROP_DELETE)
	{
	    DebugTrace(0, Dbg, ("_LoadHeader: CREATEPROP_DELETE\n"));
	    StatusInvalidParameter(pstatus, "_LoadHeader: CREATEPROP_DELETE");
            goto Exit;
	}
	if (Mode == CREATEPROP_CREATE)
	{
	    goto Exit;  // We're going to overwrite it anyway
	}
    }

    // Get the size of the underlying stream.
    cbstm = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Map the serialized property set to a pointer.
    _MSTM(Map)(FALSE, (VOID **) &_pph);

    cbMin = _ComputeMinimumSize(cbstm, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // The following assert should technically ASSERT equality.  However,
    // to avoid unmapping and closing sections for every property operation,
    // we allow shrinks to fail when other instances of the same property
    // set are active.  So we on occasion will legitimately see streams larger
    // than necessary.  The wasted space will be cleaned up when the property
    // set is next modified.

    //PROPASSERT(cbMin == cbstm);
    PROPASSERT(cbMin <= cbstm);
    DebugTrace(0, KERNELSELECT(Dbg, Dbg | DEBTRACE_CREATESTREAM), (
        "ComputeMinimumSize: cbMin=%l" szX " cbstm=%l" szX " cbUnused=%l" szX "\n",
        cbMin,
        cbstm,
        cbstm - cbMin));

    _oSection = 0;
    _cSection = 1;
    _cbTail = 0;

    if (_HasPropHeader())
    {
	// The first expression must be TRUE before we can dereference _pph
	// for the second expression.

        if (cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET ||
	    cbstm < CB_PROPERTYSETHEADER + _pph->reserved * CB_FORMATIDOFFSET ||
            _pph->wByteOrder != 0xfffe ||
            _pph->wFormat != 0 ||
            _pph->reserved < 1)
        {
            _cSection = 0;		// Mark property set invalid
            DebugTrace(0, cbstm != 0? DEBTRACE_ERROR : Dbg, (
                "_LoadHeader: %s (ver=%lx)\n",
                cbstm == 0? "Empty Stream" :
		    cbstm < CB_PROPERTYSETHEADER + CB_FORMATIDOFFSET?
			"Stream too small for header" :
		    _pph->wByteOrder != 0xfffe? "Bad wByteOrder field" :
		    _pph->wFormat != 0? "Bad wFormat field" :
		    _pph->reserved < 1? "Bad reserved field" :
                    "Bad dwOSVer field",
                _pph != NULL? _pph->dwOSVer : 0));
            goto Exit;
        }

        // Now that we've loaded the property set, check again
        // to see if this is a SumInfo or DocSumInfo set.

        pfo = _GetFormatidOffset(0);
	if (pfo->fmtid == guidDocumentSummary)
	{
	    _State |= CPSS_DOCUMENTSUMMARYINFO;
	}
        else if (pfo->fmtid == guidSummary)
        {
            fSummaryInformation = TRUE;
        }

        // If what we're after is the property set in the
        // second section, verify that it's there.

        if (_State & CPSS_USERDEFINEDPROPERTIES)
	{
            // Ensure that this is the second section of
            // the DocSumInfo property set; that's the only
            // two-section property set we support.

	    if ((_State & CPSS_DOCUMENTSUMMARYINFO) == 0)
	    {
		DebugTrace(0, DEBTRACE_ERROR, ("Not DocumentSummaryInfo 1st FMTID\n"));
		goto Exit;
	    }

            // Verify that this proeprty set has two sections, and that
            // the second section is the UD propset.

	    if (_pph->reserved < 2 ||
		(pfo = _GetFormatidOffset(1))->fmtid != guidDocumentSummarySection2)
	    {
		DebugTrace(
			0,
			_pph->reserved < 2? Dbg : DEBTRACE_ERROR,
			("Bad/missing 2nd section FMTID\n"));
		loadstate = LOADSTATE_USERDEFINEDNOTFOUND;
                goto Exit;
	    }
	}
	else if (pfmtid != NULL)
        {
            // This isn't the UserDefined property set, so it
            // should be the first section, so it should match
            // the caller-requested format ID.

            if (*pfmtid != pfo->fmtid)
            {
                // The propset's FmtID doesn't match, but maybe that's
                // because it's a MacWord6 SumInfo property set, in which
                // the FmtID isn't byte-swapped.  Otherwise, it's a problem.

                if( OSKIND_MACINTOSH == PROPSETHDR_OSVER_KIND(_pph->dwOSVer)
                    &&
                    guidSummary == *pfmtid
                    &&
                    IsEqualFMTIDByteSwap( *pfmtid, pfo->fmtid )
                  )
                {
                    fSummaryInformation = TRUE;
                }
                else
	        {
                    _cSection = 0;
	            DebugTrace(0, DEBTRACE_ERROR, ("Bad FMTID\n"));
                    loadstate = LOADSTATE_BADFMTID;
                    goto Exit;
	        }
            }   // if (*pfmtid != pfo->fmtid)
        }   // else if (pfmtid != NULL)

        _oSection = pfo->dwOffset;
        _cSection = _pph->reserved;

    }   // if (_HasPropHeader())

    psh = _GetSectionHeader();

    if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
        psh->cbSection < CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
            psh->cProperties * CB_PROPERTYIDOFFSET ||
        cbstm < _oSection + psh->cbSection)
    {
        _cSection = 0;
        DebugTrace(0, Dbg, ("_LoadHeader: too small for section\n"));
        goto Exit;
    }

    if (_HasPropHeader())
    {
        // Scan the property set for a code page, and set _CodePage.
        
        _SearchForCodePage( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // If we have multiple sections, record the tail length
        // (the size of the property set beyond this section).

	if (_cSection > 1)
	{
	    _State |= CPSS_MULTIPLESECTIONS;
	    _cbTail = cbMin - (_oSection + psh->cbSection);
	    DebugTrace(0, Dbg, ("_LoadHeader: cbTail=%x\n", _cbTail));
	}

        // Fix all the problems we know how to fix in the in-memory
        // representation of the property set.

        if (fSummaryInformation || (_State & CPSS_DOCUMENTSUMMARYINFO))
        {
	    if (fSummaryInformation)
	    {
		_FixSummaryInformation(&cbstm, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    }

	    _FixPackedPropertySet( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

	if (Mode == CREATEPROP_DELETE)
	{
	    loadstate = LOADSTATE_USERDEFINEDDELETE;
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

    loadstate = LOADSTATE_DONE;

Exit:

    return( loadstate );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixSummaryInformation
//
// Synopsis:    Fix up the memory image of a SummaryInformation propset,
//              except for packing or padding problems (which are fixed
//              in _FixPackedPropertySet).
//
// Arguments:   [pcbstm]    - The size of the mapped stream.  This may
//                            be updated by this routine.
//              [pstatus]   - Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

#define PID_THUMBNAIL	0x00000011  // SummaryInformation thumbnail property

VOID
CPropertySetStream::_FixSummaryInformation(IN OUT ULONG *pcbstm,
                                           OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh;
    PROPERTYIDOFFSET *ppo, *ppoMax;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    //  Look for the MS Publisher problem.  Pub only writes
    //  a Thumbnail, but it sets the section size too short (by 4 bytes).
    //  Pub95 has the additional problem that it doesn't DWORD-align the
    //  section and stream size.  We fix both of these problems below.

    // Skip all of this processing unless it looks like the Publisher problem.

    if (psh != NULL && *pcbstm == _oSection + psh->cbSection + sizeof(ULONG))
    {
        // Look for the thumbnail property.

	for ( ; ppo < ppoMax; ppo++)
	{
	    if (ppo->propid == PID_THUMBNAIL)
	    {
		SERIALIZEDPROPERTYVALUE const *pprop;

                // If this property isn't properly aligned, then ignore it.

		if (ppo->dwOffset & (sizeof(DWORD) - 1))
		{
		    break;
		}

                // Get a pointer to the property.

		pprop = (SERIALIZEDPROPERTYVALUE *)
			    _MapOffsetToAddress(ppo->dwOffset);

                // Look specifically for the Publisher's Thumbnail property.
                // If this is a Publisher set, the lengths won't add
                // up correctly.  For the lengths to add up correctly,
                // the offset of the property, plus
                // the length of the thumbnail, plus the size of the VT
                // DWORD and the size of the length DWORD should be the
                // size of the Section.  But In the case of Publisher,
                // the section length is 4 bytes short.

		if (PropByteSwap(pprop->dwType) == VT_CF                // It's in a clipboard format
                    &&                                                  // For Windows
		    *(ULONG *) &pprop->rgb[sizeof(ULONG)] == PropByteSwap((ULONG)MAXULONG)
                    &&
		    ppo->dwOffset +                                     // And the lengths don't add up
			PropByteSwap( *(ULONG *) pprop->rgb ) +
			(3 - 2) * sizeof(ULONG) == psh->cbSection)
		{
                    // We've found the Publisher problem.

                    // For Pub95 files, we must dword-align the section
                    // and stream size.  We don't change the size of the underlying
                    // stream, however, just the mapping.  This is because if the caller
                    // doesn't make any explicit changes, we don't want the mapped Stream
                    // to be modified.  We do this step before fixing the section-size
                    // problem, so if it should fail we haven't touched anything.

                    if( !IsDwordAligned( *pcbstm ))
                    {
                        // Increase the size of the buffer, and reload the
                        // psh pointer.

                        *pcbstm += DwordRemain(*pcbstm);
    	                _MSTM(SetSize)(*pcbstm,             // The new size
                                       FALSE,               // Don't update the underlying stream
                                       (VOID **) &_pph,     // The new mapping
                                       pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // Align the section size.

                        psh->cbSection += DwordRemain(psh->cbSection);
                    }

                    // Now correct the section size.

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixSummaryInformation: Patch section size: %x->%x\n",
			psh->cbSection,
			psh->cbSection + sizeof(ULONG)));

                    psh->cbSection += sizeof(ULONG);

		}   // if (pprop->dwType == VT_CF ...

		break;

	    }   // if (ppo->propid == PID_THUMBNAIL)
	}   // for ( ; ppo < ppoMax; ppo++)
    }   // if (psh != NULL && cbstm == _oSection + psh->cbSection + sizeof(ULONG))

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixPackedPropertySet
//
// Synopsis:    Align the memory image of a propset.
//
// Algorithm:   We need to move the properties within the
//              property set so that they are properly aligned,
//              and we need to adjust the PID/Offset array accordingly.
//              This is complicated by the fact that we may have to 
//              grow some propertes (which are not properly padded
//              for alignement) and at the same time we may have to
//              shrink some properties (which are over-padded).
//
//              To handle these two constraints, and to 
//              avoid growing the underlying stream any more
//              than necessary, we process the property set in
//              two phases.  In the Compaction phase, we shrink
//              properties which are over-padded.  In the Expansion
//              phase, we grow properties which are under-padded.
//              For example, say we have a property set with 3
//              properties, all of which should be 4 bytes.  But
//              say they are currently 2, 4, and 6 bytes.  Thus
//              we must grow the first property, hold the second
//              constant, and shrink the third property.  In this
//              example, after the Compaction phase, the 3 properties
//              will be 2, 4, and 4 bytes.  After the Expansion phase,
//              the properties will be 4, 4, and 4 bytes.
//
//              To do all of this, we make a copy of the PID/Offset
//              array (apoT) and sort it.  We then proceed to make
//              two arrays of just offsets (no PIDs) - aopropShrink
//              and aopropFinal.  aopropShrink holds the offset for
//              each property after the Compaction phase.  aopropFinal
//              holds the offset for each property after the
//              Expansion phase.  (Note that each of these phases
//              could be skipped if they aren't necessary.)
//
//              Finally, we perform the Compaction and Expansion,
//              using aopropShrink and aopropFinal, respectively,
//              as our guide.
//
// Arguments:   [pstatus]       -- Pointer to NTSTATUS code.
//
// Returns:     None
//---------------------------------------------------------------------------

INT __cdecl fnOffsetCompare(VOID const *ppo1, VOID const *ppo2);

// DocumentSummaryInformation special case properties (w/packed vector elements)
#define PID_HEADINGPAIR 0x0000000c // heading pair (VT_VECTOR | VT_VARIANT):
					// {VT_LPSTR, VT_I4} pairs
#define PID_DOCPARTS	0x0000000d // docparts (VT_VECTOR | VT_LPSTR)
//#define PID_HLINKS	0x00000015 // hlinks vector

VOID
CPropertySetStream::_FixPackedPropertySet(OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    BOOLEAN fPacked = FALSE;
    BOOLEAN fDocSummaryInfo = FALSE;
#if DBGPROP
    BOOLEAN fExpandDocSummaryInfo = FALSE;
#endif
    PROPERTYSECTIONHEADER *psh = NULL;
    PROPERTYIDOFFSET *ppoT, *ppoTMax;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    PROPERTYIDOFFSET *apoT = NULL;

    ULONG *aopropShrink = NULL;
    ULONG *aopropFinal = NULL;
    ULONG cbprop;
    ULONG cCompact, cExpand;
    ULONG *poprop = NULL;

#if i386 == 0
    SERIALIZEDPROPERTYVALUE *ppropbuf = NULL;
#endif
    ULONG cbtotal = 0;
    ULONG cbpropbuf;
    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;

    // Determine if this is the first section of the DocSumInfo
    // property set.
    if ((_State & (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	 CPSS_DOCUMENTSUMMARYINFO)
    {
	fDocSummaryInfo = TRUE;
    }

    // Get pointers into this section's header.
    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // We know it's packed if the section-length isn't aligned.
    fPacked = !IsDwordAligned(psh->cbSection);

    // If we don't already know it's packed, check each of the properties in 
    // the PID/Offset array to see if one is not properly aligned, if so we'll
    // assume that it's packed.  Also, if this is an Ansi DocSumInfo property set,
    // (first section), we'll assume that the HeadingPair and DocParts properties
    // are packed (vectors).
   
    if (!fPacked && psh != NULL)
    {
	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
	    if ( !IsDwordAligned(ppo->dwOffset)
                 ||
		 ( fDocSummaryInfo
                   &&
                   _CodePage != CP_WINUNICODE
                   &&
		   ( ppo->propid == PID_HEADINGPAIR
                     ||
		     ppo->propid == PID_DOCPARTS
                   )
                 )
               )
	    {
		fPacked = TRUE;
		break;
	    }
	}
    }

    //  ----------------------------------------------------
    //  Fix the properties if they are packed or if there is
    //  unnecessary padding.
    //  ----------------------------------------------------

    // If we know there's a problem, set a _State flag
    // now.  If we can fix the problem below, we'll clear it.
    // Otherwise, the rest of the Class will know that there's
    // an unresolved problem.

    if (fPacked)
    {
	DebugTrace(0, DEBTRACE_PROPPATCH, (
	    "_FixPackedPropertySet: packed properties\n"));
        _State |= CPSS_PACKEDPROPERTIES;
    }


    //  ---------------------------------------------------------
    //  Create apoT (a sorted array of PID/Offsets), aopropShrink
    //  (the offsets for the Compaction phase) and aopropFinal
    //  (the offsets for the Expansion phase).
    //  ---------------------------------------------------------

    // Create a buffer for a temporary PID/Offset array.

    apoT = newk(mtPropSetStream, NULL) PROPERTYIDOFFSET[psh->cProperties + 1];
    if (apoT == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Copy the PID/offset pairs from the property set to the
    // temporary PID/Offset array.

    RtlCopyMemory(
	    apoT,
	    psh->rgprop,
	    psh->cProperties * CB_PROPERTYIDOFFSET);

    // Mark the end of the temporary array.

    ppoTMax = apoT + psh->cProperties;
    ppoTMax->propid = PID_ILLEGAL;
    ppoTMax->dwOffset = psh->cbSection;

    // Sort the PID/Offset array by offset and check for overlapping values:

    qsort(apoT, psh->cProperties, sizeof(apoT[0]), fnOffsetCompare);

    // Create two arrays which will hold property offsets.
    // aopropShrink holds the offsets for the Compaction phase where
    // we shrink the property set.  aopropFinal holds the offsets
    // of the final property set, which will be achieved in the
    // Expansion phase.

    aopropShrink = newk(mtPropSetStream, NULL) ULONG[psh->cProperties + 1];
    if (aopropShrink == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    aopropFinal = newk(mtPropSetStream, NULL) ULONG[psh->cProperties + 1];
    if (aopropFinal == NULL)
    {
	*pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

#if i386 == 0
    // On non-x86 machines, we can't directly access unaligned
    // properties.  So, allocate enough (aligned) memory to hold
    // the largest unaligned property.  We'll copy properties here
    // when we need to access them.

    cbpropbuf = 0;

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    cbprop = DwordAlign(ppoT[1].dwOffset - ppoT->dwOffset);
	    if (cbpropbuf < cbprop)
	    {
		cbpropbuf = cbprop;
	    }
	}
    }

    if (cbpropbuf != 0)
    {
	ppropbuf = (SERIALIZEDPROPERTYVALUE *)
			newk(mtPropSetStream, NULL) BYTE[cbpropbuf];
	if (ppropbuf == NULL)
	{
	    *pstatus = STATUS_NO_MEMORY;
            goto Exit;
	}
    }
#endif  // i386==0


    //  ----------------------------------------------
    //  Iterate through the properties, filling in the
    //  entries of aopropShrink and aopropFinal.
    //  ----------------------------------------------

    // We'll also count the number of compacts and expands
    // necessary.

    aopropShrink[0] = aopropFinal[0] = apoT[0].dwOffset;
    PROPASSERT(IsDwordAligned(aopropShrink[0]));
    cExpand = 0;
    cCompact = 0;

    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
    {
	SERIALIZEDPROPERTYVALUE *pprop;
	BOOLEAN fDocSumLengthComputed = FALSE;
        ULONG cbpropOriginal;

        // How much space does the property take up in the current
        // property set?

	cbpropOriginal = cbprop = ppoT[1].dwOffset - ppoT->dwOffset;
	pprop = (SERIALIZEDPROPERTYVALUE *)
		    _MapOffsetToAddress(ppoT->dwOffset);

#if i386 == 0
        // If necessary, put this property into an aligned buffer.

	if (!IsDwordAligned(ppoT->dwOffset))
	{
	    DebugTrace(0, Dbg, (
		"_FixPackedPropertySet: unaligned pid=%x off=%x\n",
		ppoT->propid,
		ppoT->dwOffset));
	    PROPASSERT(DwordAlign(cbprop) <= cbpropbuf);
	    RtlCopyMemory((VOID *) ppropbuf, pprop, cbprop);
	    pprop = ppropbuf;
	}
#endif
        // Calculate the actual length of this property, including
        // the necessary padding.  This might be bigger than the
        // property's current length (if the propset wasn't properly
        // padded), and it might be smaller than the property's current
        // length (if the propset was over-padded).

	if (ppoT->propid == PID_DICTIONARY)
	{
            // Get the size of the dictionary.

	    cbprop = DwordAlign(_DictionaryLength(
				    (DICTIONARY const *) pprop,
				    cbprop,
                                    pstatus));
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	}
	else
	{
	    ULONG cbpropT;

            // Ansi DocSumInfo property sets have two vector properties
            // which are packed.  If this is one of those properties,
            // we won't fix it yet, but we'll compute the size required
            // when the elements are un-packed.

	    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
	    {
		if (ppoT->propid == PID_HEADINGPAIR)
		{
		    fDocSumLengthComputed = _FixHeadingPairVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
		else
		if (ppoT->propid == PID_DOCPARTS)
		{
		    fDocSumLengthComputed = _FixDocPartsVector(
					    PATCHOP_COMPUTESIZE,
					    pprop,
					    &cbpropT);
		}
	    }

            // If we computed a length above, use it, otherwise calculate
            // the length using the standard rules (we've already checked
            // for the special cases).

	    if (fDocSumLengthComputed)
	    {
		cbprop = cbpropT;
#if DBGPROP
		fExpandDocSummaryInfo = TRUE;
#endif
	    }
	    else
	    {
		cbprop = PropertyLength(pprop, DwordAlign(cbprop), 0, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    }

	}   // if (ppoT->propid == PID_DICTIONARY) ... else

	PROPASSERT(IsDwordAligned(cbprop));

        // Now that we know the actual cbprop, use it to update the
        // *next* entry in the two arrays of correct offsets.
        //
        // We want aopropFinal to hold the final, correct offsets,
        // so we'll use cbprop to calculate this array.
        // But for aopropShrink, we only want it to differ from
        // the original array (apoT) when a property is shrinking,
        // so we'll use min(cbNew,cbOld) for this array.

        poprop = &aopropShrink[ ppoT - apoT ]; // 1st do aopropShrink
        poprop[1] = poprop[0] + min(cbprop, cbpropOriginal);

        poprop = &aopropFinal[ ppoT - apoT ];  // 2nd do aopropFinal
        poprop[1] = poprop[0] + cbprop;

	DebugTrace(0, Dbg, (
	    "_FixPackedPropertySet: pid=%x off=%x->%x\n",
	    ppoT->propid,
	    ppoT->dwOffset,
	    poprop[0],
	    poprop[0] < ppoT->dwOffset?
		" (compact)" :
		poprop[0] > ppoT->dwOffset? " (expand)" : ""));


        // Is this compaction or an expansion?
        // If we computed the doc-sum length, we count it as
        // an expansion, even if the total property size didn't change,
        // because we need the expand the elements within the vector.

	if (cbprop < cbpropOriginal)
	{
	    cCompact++;
	}
	else
	if (cbprop > cbpropOriginal || fDocSumLengthComputed)
	{
	    cExpand++;
	}
    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)


    //  -------------------------------
    //  Compact/Expand the Property Set
    //  -------------------------------

    // We've now generated the complete aopropShrink and aopropFinal
    // offset arrays.  Now, if necessary, let's expand and/or compact
    // the property set to match these offsets.

    if (cExpand || cCompact)
    {
	ULONG cbstm;
	LONG cbdelta;

	cbstm = _oSection + psh->cbSection + _cbTail;
	cbdelta = aopropFinal[psh->cProperties] - psh->cbSection;

	DebugTrace(0, Dbg, (
	    "_FixPackedPropertySet: cbstm=%x cbdelta=%x cexpand=%x ccompact=%x\n",
	    cbstm,
	    cbdelta,
	    cExpand,
	    cCompact));

        //  -----------------------------
        //  Grow the Stream if necessary.
        //  -----------------------------

        if (cbdelta > 0)
	{
	    DebugTrace(0, Dbg, (
		"SetSize(%x) _FixPackedPropertySet grow %x bytes\n",
		cbstm + cbdelta,
		cbdelta));
             
            // On the set-size, say that this is a non-persistent
            // change, so that the underlying Stream isn't modified.
            // At this point, we don't know if this change should remain
            // permanent (if the caller closes without making any changes
            // the file should remain un-changed). 

	    _MSTM(SetSize)(
		    cbstm + cbdelta,
                    FALSE,   // Not persistent
		    (VOID **) &_pph,
                    pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // reload all pointers into mapped image:

	    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

	    // If there's another section after this one, move it back
	    // to the end of the stream now, which will create room for
            // our expansion.

	    if (_cbTail != 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:grow)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }
	}   // if (cbdelta > 0)

        // This previous step (growing the Stream), was the last one which can
        // fail.  We're about to modify the actual property set (we've been
        // working only with temporary buffers so far).  So we're always guaranteed
        // a good property set, or the original set, we'll never end up with a
        // half-updated set.


        //  ----------------
        //  Compaction Phase
        //  ----------------

        // Compact the property set if necessary.  I.e., adjust
        // the property set buffer so that it matches aopropShrink.

        if (cCompact > 0)
	{
	    // Start at the beginning and move each property up.

	    poprop = aopropShrink;
	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	    {
		if (*poprop != ppoT->dwOffset)
		{
		    PROPASSERT(*poprop < ppoT->dwOffset);
		    PROPASSERT(poprop[1] > *poprop);

		    // We're compacting; the property should not grow!

		    PROPASSERT(
			poprop[1] - *poprop <=
			ppoT[1].dwOffset - ppoT->dwOffset);

		    PropMoveMemory(
			    "_FixPackedPropertySet(compact)",
			    psh,
			    Add2Ptr(psh, *poprop),
			    Add2Ptr(psh, ppoT->dwOffset),
			    poprop[1] - *poprop);
		}
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++, poprop++)
	}   // if (cCompact > 0)


        //  ---------------
        //  Expansion phase
        //  ---------------

        // Recall that, whether or not we just did a compaction, aopropShrink
        // holds the property set offsets as they currently exist in the
        // property set.

        if (cExpand > 0)
        {
	    // Start at the end and move each property back.
            // The 'poprop' gives us the final correct offset
            // of the current property.

            LONG lOffsetIndex;
	    poprop = &aopropFinal[psh->cProperties - 1];

            // Start at the second-to-last entry in the arrays of offsets
            // (the last entry is an artificially added one to mark the end of the
            // property set).

	    for (lOffsetIndex = ppoTMax - apoT - 1, ppoT = ppoTMax - 1;
                 lOffsetIndex >=0;
                 lOffsetIndex--, poprop--, ppoT--)
	    {
                // Get a pointer to the final location of this
                // property.

		SERIALIZEDPROPERTYVALUE *pprop;
		pprop = (SERIALIZEDPROPERTYVALUE *)
			    Add2Ptr(psh, *poprop);

		if (*poprop != aopropShrink[ lOffsetIndex ])
		{
		    ULONG cbCopy, cbOld;
			
		    PROPASSERT(*poprop > aopropShrink[ lOffsetIndex ]);
		    PROPASSERT(poprop[1] > *poprop);
                    PROPASSERT(aopropShrink[ lOffsetIndex+1 ] > aopropShrink[ lOffsetIndex ]);

                    // How many bytes should we copy?  The minimum size of the property
                    // calculated using the old and new offsets.

		    cbCopy = poprop[1] - poprop[0];
		    cbOld = aopropShrink[ lOffsetIndex+1 ]
                            - aopropShrink[ lOffsetIndex+0 ];

		    if (cbCopy > cbOld)
		    {
			cbCopy = cbOld;
		    }

                    // Copy the property from its old location
                    // (psh+aopropShrink[lOffsetIndex]) to its new location
                    // (pprop == psh+*poprop).

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixPackedPropertySet:move pid=%x off=%x->%x "
			    "cb=%x->%x cbCopy=%x z=%x @%x\n",
			ppoT->propid,
			ppoT->dwOffset,
			*poprop,
			cbOld,
			poprop[1] - *poprop,
			cbCopy,
			DwordRemain(cbCopy),
			_MapAddressToOffset(Add2Ptr(pprop, cbCopy))));

		    PropMoveMemory(
			    "_FixPackedPropertySet(expand)",
			    psh,
			    pprop,
			    Add2Ptr(psh, aopropShrink[ lOffsetIndex ]),
			    cbCopy);
		    RtlZeroMemory(
			    Add2Ptr(pprop, cbCopy),
			    DwordRemain(cbCopy));

		}   // if (*poprop != ppoT->dwOffset)

                // If this is an older DocSumInfo property set,
                // and this property is one of the vector values,
                // we must expand the vector elements now that we've
                // room for it.

		if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		{
		    ULONG cbpropT;

		    if (ppoT->propid == PID_HEADINGPAIR)
		    {
			_FixHeadingPairVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		    else
		    if (ppoT->propid == PID_DOCPARTS)
		    {
			_FixDocPartsVector(
					PATCHOP_EXPAND,
					pprop,
					&cbpropT);
		    }
		}   // if (fDocSummaryInfo)
	    }   // for (ppoT = ppoTMax; --ppoT >= apoT; popropNew--)
	}   // if (cExpand != 0)



        //  ---------------------------------------------------------
	//  Patch the section size and the moved properties' offsets.
        //  ---------------------------------------------------------

	DebugTrace(0, DEBTRACE_PROPPATCH, (
	    "_FixPackedPropertySet: Patch section size %x->%x\n",
	    psh->cbSection,
	    psh->cbSection + cbdelta));

	psh->cbSection += cbdelta;

        // Iterate through the original PID/Offset array to update the
        // offsets.

	for (ppo = ppoBase; ppo < ppoMax; ppo++)
	{
            // Search the temporary PID/Offset array (which has the updated
            // offsets) for ppo->propid.

	    for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	    {
		if (ppo->propid == ppoT->propid)
		{
                    // We've found ppo->propid in the temporary PID/Offset
                    // array.  Copy the offset value from the temporary array
                    // to the actual array in the property set.

		    PROPASSERT(ppo->dwOffset == ppoT->dwOffset);
		    ppo->dwOffset = aopropFinal[ppoT - apoT];
#if DBGPROP
		    if (ppo->dwOffset != ppoT->dwOffset)
		    {
			DebugTrace(0, DEBTRACE_PROPPATCH, (
			    "_FixPackedPropertySet: Patch propid %x"
				" offset=%x->%x\n",
			    ppo->propid,
			    ppoT->dwOffset,
			    ppo->dwOffset));
		    }   // if (ppo->dwOffset != ppoT->dwOffset)
#endif
		    break;

		}   // if (ppo->propid == ppoT->propid)
	    }   // for (ppoT = apoT; ppoT < ppoTMax; ppoT++)
	}   // for (ppo = ppoBase; ppo < ppoMax; ppo++)

        //  ------------
        //  Fix the tail
        //  ------------


        // If we have a tail, fix it's offset in the FmtID/Offset
        // array.  Also, if we've overall shrunk this section, bring
        // the tail in accordingly.

        if (_cbTail != 0)
	{
	    if (cbdelta < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"_FixPackedPropertySet(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbdelta),
			pvSrc,
			_cbTail);
	    }

	    _PatchSectionOffsets(cbdelta);

	}   // if (_cbTail != 0)


        // If we get to this point we've successfully un-packed (or
        // un-over-padded) the property set, so we can clear the
        // state flag.

	_State &= ~CPSS_PACKEDPROPERTIES;

    }   // if (cExpand || cCompact)


    //  ----
    //  Exit
    //  ----

Exit:

    delete [] apoT;
    delete [] aopropShrink;
    delete [] aopropFinal;

#if i386 == 0
    delete [] (BYTE *) ppropbuf;
#endif // i386

}   // CPropertySetStream::_FixPackedPropertySet()


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsVector
//
// Synopsis:    Align the memory image of a DocParts vector
//              The DocParts property is part of the DocSumInfo
//              property set (first section).  It is a vector
//              of strings, and in Ansi property sets it's packed
//              and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if property type and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_DOCPARTS.  This property is assumed to be an array of
//		VT_LPSTRs.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    OUT ULONG *pcbprop)
{
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    // If the property is a variant vector,
    // it's in an ANSI property set, and
    // there are an even number of elements, ...

    if ( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_LPSTR)
         &&
         _CodePage != CP_WINUNICODE)
    {
	ULONG cString;
	VOID *pv;

	cString = PropByteSwap( *(DWORD *) pprop->rgb );
	pv = Add2Ptr(pprop->rgb, sizeof(DWORD));

	if (_FixDocPartsElements(PatchOp, cString, pv, pv, pcbprop))
	{
	    *pcbprop += CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable DocParts vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixDocPartsElements
//
// Synopsis:    Recursively align the memory image of DocParts elements
//
// Arguments:	[PatchOp]	-- patch request
//		[cString]	-- count of strings remaining in the vector
//		[pvDst]		-- aligned overlapping destination buffer
//		[pvSrc]		-- unaligned overlapping source buffer
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//		FALSE on error
//
// Note:        The pvDst & pvSrc buffers must be in property-set
//              byte order (little endian).
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixDocPartsElements(
    IN PATCHOP PatchOp,
    IN ULONG cString,
    OUT VOID *pvDst,
    IN VOID UNALIGNED const *pvSrc,
    OUT ULONG *pcbprop)
{
    ULONG cb;
    
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pvDst >= pvSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || pvDst == pvSrc);

    if (cString == 0)
    {
	*pcbprop = 0;
	return(TRUE);
    }
    DWORD dwTemp;
    memcpy(&dwTemp, pvSrc, sizeof(DWORD));
    cb = sizeof(DWORD) + PropByteSwap( dwTemp );

    // If the caller serialized the vector properly, all we need to do is
    // to round up the string lengths to DWORD multiples, so readers that
    // treat these vectors as byte-aligned get faked out.  We expect
    // readers will not have problems with a DWORD aligned length, and a
    // '\0' character a few bytes earlier than the length indicates.

    if (PatchOp == PATCHOP_ALIGNLENGTHS)
    {
	cb = DwordAlign(cb);	// Caller says it's already aligned
    }
    if (_FixDocPartsElements(
		PatchOp,
		cString - 1,
		Add2Ptr(pvDst, DwordAlign(cb)),
		(VOID UNALIGNED const *) Add2ConstPtr(pvSrc, cb),
		pcbprop))
    {
	*pcbprop += DwordAlign(cb);

	if (PatchOp == PATCHOP_EXPAND)
	{
	    PropMoveMemory(
		    "_FixDocPartsElements",
		    _GetSectionHeader(),
		    pvDst,
		    pvSrc,
		    cb);
	    RtlZeroMemory(Add2Ptr(pvDst, cb), DwordRemain(cb));

	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"_FixDocPartsElements: Move(%x:%s) "
		    "cb=%x->%x off=%x->%x z=%x @%x\n",
		cString,
		Add2Ptr(pvDst, sizeof(ULONG)),
		cb - sizeof(ULONG),
		DwordAlign(cb) - sizeof(ULONG),
		_MapAddressToOffset(pvSrc),
		_MapAddressToOffset(pvDst),
		DwordRemain(cb),
		_MapAddressToOffset(Add2Ptr(pvDst, cb))));
	}
	if (PatchOp != PATCHOP_COMPUTESIZE)
	{
	    PROPASSERT(
		PatchOp == PATCHOP_ALIGNLENGTHS ||
		PatchOp == PATCHOP_EXPAND);

	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"_FixDocPartsElements: Patch(%x:%s) cb=%x->%x\n",
		cString,
		Add2Ptr(pvDst, sizeof(ULONG)),
		*(ULONG *) pvDst,
		DwordAlign(*(ULONG *) pvDst)));

            // put in the length
	    *(ULONG *) pvDst = 
                PropByteSwap( DwordAlign( PropByteSwap(*(ULONG *) pvDst) ) );
	}
	return(TRUE);
    }
    return(FALSE);	// Not a recognizable DocParts vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairVector
//
// Synopsis:    Align the memory image of a HeadingPair vector.
//              The HeadingPair property is part of the DocSumInfo
//              property set (first section).  It's a vector of
//              Variants, where the elements are alternating
//              strings and I4s (the string is a heading name,
//              and the I4 is the count of DocumentParts in that
//              heading).  In Ansi property sets, these elements
//              are packed, and must be un-packed.
//
// Arguments:	[PatchOp]	-- patch request
//		[pprop]         -- property value to be patched or sized
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if property and all elements meet expectations;
//		FALSE on error
//
// Note:	Operate on a DocumentSummaryInformation first section property,
//		PID_HEADINGPAIR.  This property is assumed to be an array of
//		VT_VARIANTs with an even number of elements.  Each pair must
//		consist of a VT_LPSTR followed by a VT_I4.
//
//		PATCHOP_COMPUTESIZE merely computes the size required to unpack
//		the property, and must assume it is currently unaligned.
//
//		PATCHOP_ALIGNLENGTHS patches all VT_LPSTR lengths to DWORD
//		multiples, and may rely on the property already being aligned.
//
//		PATCHOP_EXPAND expands the property from the Src to Dst buffer,
//		moving elements to DWORD boundaries, and patching VT_LPSTR
//		lengths to DWORD multiples.  The Src buffer is assumed to be
//		unaligned, and the Dst buffer is assumed to be properly sized.
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairVector(
    IN PATCHOP PatchOp,
    IN OUT SERIALIZEDPROPERTYVALUE *pprop,
    OUT ULONG *pcbprop)
{
    ULONG celem;
    ULONG cbprop = 0;

    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(pprop != NULL);
    PROPASSERT(pcbprop != NULL);

    // If the property is a variant vector, and
    // there are an even number of elements, ...

    if( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_VARIANT)
        &&
	( (celem = PropByteSwap(*(ULONG *) pprop->rgb) ) & 1) == 0
        &&
        _CodePage != CP_WINUNICODE)
    {
	pprop = (SERIALIZEDPROPERTYVALUE *) Add2Ptr(pprop->rgb, sizeof(ULONG));

	if (_FixHeadingPairElements(PatchOp, celem/2, pprop, pprop, pcbprop))
	{
	    *pcbprop += CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);
	    return(TRUE);
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_FixHeadingPairElements
//
// Synopsis:    Recursively align the memory image of HeadingPair elements
//
// Arguments:	[PatchOp]	-- patch request
//		[cPairs]	-- count of heading pairs remaining
//		[ppropDst]	-- aligned overlapping destination buffer
//		[ppropSrc]	-- unaligned overlapping source buffer
//		[pcbprop]	-- pointer to computed property length
//
// Returns:     TRUE if all remaining elements meet expectations;
//		FALSE on error
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_FixHeadingPairElements(
    IN PATCHOP PatchOp,
    IN ULONG cPairs,
    OUT SERIALIZEDPROPERTYVALUE *ppropDst,
    IN SERIALIZEDPROPERTYVALUE UNALIGNED const *ppropSrc,
    OUT ULONG *pcbprop)
{
    PROPASSERT(
	PatchOp == PATCHOP_COMPUTESIZE ||
	PatchOp == PATCHOP_ALIGNLENGTHS ||
	PatchOp == PATCHOP_EXPAND);
    PROPASSERT(ppropDst >= ppropSrc);
    PROPASSERT(PatchOp != PATCHOP_ALIGNLENGTHS || ppropDst == ppropSrc);

    if (cPairs == 0)
    {
	*pcbprop = 0;
	return(TRUE);
    }

    // If the first element of the pair is a VT_LPSTR, ...
    if( PropByteSwap(SPV_GetType(ppropSrc)) == VT_LPSTR )
    {
	ULONG cb;

	// Compute size of the string element.
        DWORD dwStrLen;
        memcpy(&dwStrLen, SPV_GetRgb(ppropSrc), sizeof(DWORD));
        dwStrLen = PropByteSwap(dwStrLen);
        
	cb = CB_SERIALIZEDPROPERTYVALUE  
            +
            sizeof(ULONG)
            +
            dwStrLen;

	// If the caller serialized the vector properly, all we need to do is
	// to round up the string lengths to DWORD multiples, so readers that
	// treat these vectors as byte-aligned get faked out.  We expect
	// readers will not have problems with a DWORD aligned length, and a
	// '\0' character a few bytes earlier than the length indicates.

	if (PatchOp == PATCHOP_ALIGNLENGTHS)
	{
	    cb = DwordAlign(cb);	// Caller says it's already aligned
	}

	// and if the second element of the pair is a VT_I4, ...

	if ( PropByteSwap( (DWORD) VT_I4 )
             ==
             SPV_GetType( 
                         (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
                         Add2ConstPtr(ppropSrc, cb)
             ))
	{
	    cb += CB_SERIALIZEDPROPERTYVALUE + sizeof(DWORD);

	    if (_FixHeadingPairElements(
			    PatchOp,
			    cPairs - 1,
			    (SERIALIZEDPROPERTYVALUE *)
				    Add2Ptr(ppropDst, DwordAlign(cb)),
			    (SERIALIZEDPROPERTYVALUE UNALIGNED const *)
				    Add2ConstPtr(ppropSrc, cb),
			    pcbprop))
	    {
		*pcbprop += DwordAlign(cb);

		if (PatchOp == PATCHOP_EXPAND)
		{
		    // Move the unaligned VT_I4 property back in memory to an
		    // aligned boundary, move the string back to a (possibly
		    // different) aligned boundary, zero the space in between
		    // the two and patch the string length to be a DWORD
		    // multiple to fake out code that expects vector elements
		    // to be byte aligned.

		    // Adjust byte count to include just the string element.

		    cb -= CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG);

		    // Move the VT_I4 element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:I4",
			    _GetSectionHeader(),
			    Add2Ptr(ppropDst, DwordAlign(cb)),
			    Add2ConstPtr(ppropSrc, cb),
			    CB_SERIALIZEDPROPERTYVALUE + sizeof(ULONG));

		    // Move the VT_LPSTR element.

		    PropMoveMemory(
			    "_FixHeadingPairElements:LPSTR",
			    _GetSectionHeader(),
			    ppropDst,
			    ppropSrc,
			    cb);

		    // Zero the space in between.

		    RtlZeroMemory(Add2Ptr(ppropDst, cb), DwordRemain(cb));

		    DebugTrace(0, DEBTRACE_PROPPATCH, (
		        "_FixHeadingPairElements: Move(%x:%s) "
			    "cb=%x->%x off=%x->%x z=%x @%x\n",
		        cPairs,
		        &ppropDst->rgb[sizeof(ULONG)],
		        PropByteSwap( *(ULONG *) ppropDst->rgb ),
		        DwordAlign(PropByteSwap( *(ULONG *) ppropDst->rgb )),
		        _MapAddressToOffset(ppropSrc),
		        _MapAddressToOffset(ppropDst),
		        DwordRemain(cb),
		        _MapAddressToOffset(Add2Ptr(ppropDst, cb))));
		}

		if (PatchOp != PATCHOP_COMPUTESIZE)
		{
		    PROPASSERT(
			PatchOp == PATCHOP_ALIGNLENGTHS ||
			PatchOp == PATCHOP_EXPAND);
#ifdef DBGPROP
		    SERIALIZEDPROPERTYVALUE const *ppropT =
			(SERIALIZEDPROPERTYVALUE const *)
			    Add2Ptr(ppropDst, DwordAlign(cb));
#endif
		    DebugTrace(0, DEBTRACE_PROPPATCH, (
			"_FixHeadingPairElements: Patch(%x:%s) "
			    "cb=%x->%x, vt=%x, %x\n",
			cPairs,
			&ppropDst->rgb[sizeof(ULONG)],
			PropByteSwap( *(ULONG *) ppropDst->rgb ),
			DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )),
			PropByteSwap( ppropT->dwType ),
			PropByteSwap( *(ULONG *) ppropT->rgb )));

		    // Patch the string length to be a DWORD multiple.
                    // and we have to put back the swapped length

		    *(ULONG *) ppropDst->rgb
                        = PropByteSwap( DwordAlign( PropByteSwap( *(ULONG *) ppropDst->rgb )));
		}
		return(TRUE);
	    }
	}
    }
    return(FALSE);	// Not a recognizable HeadingPair vector
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertySet
//
// Synopsis:    Return the classid for the property set code
//
// Arguments:   [pspss]         -- pointer to buffer for output
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::QueryPropertySet(OUT STATPROPSETSTG *pspss,
                                     OUT NTSTATUS       *pstatus) const
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if ((_State & CPSS_USERDEFINEDDELETED) || _cSection < 1)
    {
	StatusAccessDenied(pstatus, "QueryPropertySet: deleted or no section");
        goto Exit;
    }
    _MSTM(QueryTimeStamps)(
                pspss,
                (BOOLEAN) ((_Flags & CREATEPROP_NONSIMPLE) != 0));
    pspss->clsid = _pph->clsid;
    pspss->fmtid = _GetFormatidOffset(
			    (_State & CPSS_USERDEFINEDPROPERTIES)? 1 : 0)->fmtid;
    pspss->grfFlags = _CodePage == CP_WINUNICODE?
        PROPSETFLAG_DEFAULT : PROPSETFLAG_ANSI;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetClassId
//
// Synopsis:    Set the classid for the property set code
//
// Arguments:   [pclsid]        -- pointer to new ClassId
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CPropertySetStream::SetClassId(IN GUID const *pclsid,
                               OUT NTSTATUS  *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (IsReadOnlyPropertySet(_Flags, _State))
    {
	StatusAccessDenied(pstatus, "SetClassId: deleted or read-only");
        goto Exit;
    }

    _SetModified();
    _pph->clsid = *pclsid;

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::EnumeratePropids
//
// Synopsis:    enumerates the property ids in a prop set
//
// Arguments:   [pkey]     -- pointer to bookmark (0 implies beginning)
//              [pcprop]   -- on input: size; on output: # of props returned.
//              [apropids] -- output buffer
//              [pstatus]  -- pointer to NTSTATUS code
//
// Returns:     TRUE if more properties are available
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::EnumeratePropids(
    IN OUT ULONG *pkey,
    IN OUT ULONG  *pcprop,
    OPTIONAL OUT PROPID *apropids,
    OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoStart, *ppoMax;
    ULONG cprop = 0;
    BOOLEAN fMorePropids = FALSE;
    PROPID propidPrev = *pkey;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "EnumeratePropids: deleted");
        goto Exit;
    }

    if (_LoadPropertyOffsetPointers(&ppoStart, &ppoMax, pstatus) == NULL)
    {
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }
    else
    {
        if (propidPrev != 0)    // if not first call, start w/last propid
        {
            for (ppo = ppoStart; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == propidPrev)
                {
                    ppoStart = ++ppo;
                    break;
                }
            }
        }
        for (ppo = ppoStart; ppo < ppoMax; ppo++)
        {
            if (ppo->propid != PID_DICTIONARY &&
                ppo->propid != PID_CODEPAGE &&
                ppo->propid != PID_LOCALE)
            {
                if (cprop >= *pcprop)
                {
                    fMorePropids = TRUE;
                    break;
                }
                if (apropids != NULL)
                {
                    apropids[cprop] = ppo->propid;
                }
                cprop++;
                propidPrev = ppo->propid;
            }
        }
    }
    *pkey = propidPrev;
    *pcprop = cprop;

    //  ----
    //  Exit
    //  ----

Exit:

    return(fMorePropids);
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadPropertyOffsetPointers
//
// Synopsis:    Load start and (past) end pointers to PROPERTYIDOFFSET array
//
// Arguments:   [pppo]          -- pointer to base of PROPERTYIDOFFSET array
//              [pppoMax]       -- pointer past end of PROPERTYIDOFFSET array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Pointer to Section Header, NULL if section not present
//              or if there was an error.
//---------------------------------------------------------------------------

PROPERTYSECTIONHEADER *
CPropertySetStream::_LoadPropertyOffsetPointers(
    OUT PROPERTYIDOFFSET **pppo,
    OUT PROPERTYIDOFFSET **pppoMax,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER *psh;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());

    if (_cSection != 0)
    {
        psh = _GetSectionHeader();
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cbstm < _oSection + CB_PROPERTYSECTIONHEADER ||
            cbstm < _oSection + CB_PROPERTYSECTIONHEADER +
                psh->cProperties * CB_PROPERTYIDOFFSET ||
            cbstm < _oSection + psh->cbSection)
        {
            StatusCorruption(pstatus, "LoadPropertyOffsetPointers: stream size");
            goto Exit;
        }
        *pppo = psh->rgprop;
        *pppoMax = psh->rgprop + psh->cProperties;
    }

    //  ----
    //  Exit
    //  ----

Exit:
    if( !NT_SUCCESS(*pstatus) )
        psh = NULL;

    return(psh);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_LoadProperty
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id for property
//              [pcbprop]       -- pointer to return property size, 0 on error
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     SERIALIZEDPROPERTYVALUE * -- NULL if not present
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE *
CPropertySetStream::_LoadProperty(
    IN PROPID propid,
    OUT OPTIONAL ULONG *pcbprop,
    OUT NTSTATUS *pstatus )
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (psh != NULL)
    {
        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            if (IsDwordAligned(ppo->dwOffset)
                &&
                ppo->dwOffset >= CB_PROPERTYSECTIONHEADER
                                 +
                                 psh->cProperties * CB_PROPERTYIDOFFSET
                &&
                psh->cbSection >= ppo->dwOffset + CB_SERIALIZEDPROPERTYVALUE)
            {

                if (ppo->propid != propid)
                {
                    continue;
                }
                pprop = (SERIALIZEDPROPERTYVALUE *)
                    _MapOffsetToAddress(ppo->dwOffset);

                if (pcbprop != NULL)
                {
                    ULONG cb;

                    cb = psh->cbSection - ppo->dwOffset;
                    if (propid == PID_DICTIONARY)
                    {
                        *pcbprop = _DictionaryLength(
                                        (DICTIONARY const *) pprop,
                                        cb,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }
                    else
                    {
			*pcbprop = PropertyLength(pprop, cb, 0, pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    }
                }
                if (pcbprop == NULL ||
                    psh->cbSection >= ppo->dwOffset + *pcbprop)
                {
                    // Success
                    goto Exit;
                }
            }

            pprop = NULL;
            StatusCorruption(pstatus, "LoadProperty: property offset");
            goto Exit;
        }
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::GetValue
//
// Synopsis:    return a pointer to the specified property value
//
// Arguments:   [propid]        -- property id of property
//              [pcbprop]       -- pointer to returned property length
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     pointer to property value
//---------------------------------------------------------------------------

SERIALIZEDPROPERTYVALUE const *
CPropertySetStream::GetValue(
    IN PROPID propid,
    OUT ULONG *pcbprop,
    OUT NTSTATUS *pstatus)
{
    SERIALIZEDPROPERTYVALUE *pprop = NULL;

    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    if (_State & CPSS_USERDEFINEDDELETED)
    {
	StatusAccessDenied(pstatus, "GetValue: deleted");
        goto Exit;
    }
    if (propid == PID_DICTIONARY)
    {
	DebugTrace(0, DEBTRACE_ERROR, ("GetValue: PID_DICTIONARY\n"));
	StatusInvalidParameter(pstatus, "GetValue: PID_DICTIONARY");
        goto Exit;
    }

    pprop = NULL;
    if (propid == PID_SECURITY || propid == PID_MODIFY_TIME)
    {
        SERIALIZEDPROPERTYVALUE aprop[2];

        PROPASSERT(sizeof(aprop) >= sizeof(ULONG) + sizeof(LONGLONG));

        aprop[0].dwType = PropByteSwap( (DWORD) VT_EMPTY );
        if (propid == PID_SECURITY)
        {
            if (_MSTM(QuerySecurity)((ULONG *) aprop[0].rgb))
            {
                aprop[0].dwType = PropByteSwap( (DWORD) VT_UI4 );
                *pcbprop = 2 * sizeof(ULONG);
            }
        }
        else // (propid == PID_MODIFY_TIME)
        {
            LONGLONG ll;

            if (_MSTM(QueryModifyTime)(&ll))
            {
                PropByteSwap(&ll);
                memcpy(aprop[0].rgb, &ll, sizeof(LONGLONG)); 
                aprop[0].dwType = PropByteSwap( (DWORD) VT_FILETIME );
                *pcbprop = sizeof(ULONG) + sizeof(LONGLONG);
            }
        }

        if( VT_EMPTY != PropByteSwap(aprop[0].dwType)  )
        {
            pprop = (SERIALIZEDPROPERTYVALUE *)
                newk(mtPropSetStream, NULL) BYTE[*pcbprop];

            if (pprop == NULL)
            {
                StatusNoMemory(pstatus, "GetValue: no memory");
                goto Exit;
            }
            DebugTrace(0, Dbg, (
		"GetValue: pprop=%lx, vt=%lx, cb=%lx\n",
                pprop,
                PropByteSwap( aprop[0].dwType ),
                *pcbprop));
            RtlCopyMemory(pprop, aprop, *pcbprop);
        }
    }   // if (propid == PID_SECURITY || propid == PID_MODIFY_TIME)

    else
    {
	pprop = _LoadProperty(propid, pcbprop, pstatus);
        if( !NT_SUCCESS(*pstatus) )
        {
            pprop = NULL;
            goto Exit;
        }
    }   // if (propid == PID_SECURITY || propid == PID_MODIFY_TIME) ... else

#if DBGPROP
    if (pprop == NULL)
    {
        DebugTrace(0, Dbg, ("GetValue: propid=%lx pprop=NULL\n", propid));
    }
    else
    {
        char valbuf[CB_VALUESTRING];

        DebugTrace(0, Dbg, (
            "GetValue: propid=%lx pprop=%l" szX " vt=%hx val=%s cb=%l" szX "\n",
            propid,
	    _MapAddressToOffset(pprop),
            PropByteSwap( pprop->dwType ),
            ValueToString(pprop, *pcbprop, valbuf),
            *pcbprop));
    }
#endif

    //  ----
    //  Exit
    //  ----

Exit:

    return(pprop);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetValue
//
// Synopsis:    update/add/delete property values
//
// Arguments:   [cprop]         -- count of properties
//              [avar]          -- PROPVARIANT array
//              [apinfo]        -- PROPERTY_INFORMATION array
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        All the properties in the apinfo array can be classified into
//              one of the following categories:
//
//              PROPOP_IGNORE:
//                No change.  Deleting a non-existent property or the same
//                propid appears later in the apinfo array.
//
//              PROPOP_DELETE:
//                Deletion of an existing property.  Remove the
//                PROPERTYIDOFFSET structure from the property offset array and
//                and pack the remaining entries.  Delete the property value
//                and pack remaining property values
//
//              PROPOP_INSERT:
//                Addition of a new property.  Insert the new PROPERTYIDOFFSET
//                structure at the end of the property offset array.  Insert
//                the new property value at the end of the section/stream.
//
//              PROPOP_MOVE:
//                A property whose value needs to be updated out of place
//                because of a change in the property value's size.  A property
//                value is moved to the end of the section if it grows or
//                shrinks across a DWORD boundary.  The existing value is
//                removed from the section and the remaining values are packed.
//                Then, the new value is inserted at the end of the section.
//                The idea here is to move variable length properties that are
//                being changed frequently as near as possible to the end of
//                the stream to minimize the cost of maintaining a packed set
//                of property values.  Note that the property offset structure
//                is not moved around in the array.
//
//              PROPOP_UPDATE:
//                A property whose value can be updated in-place.  The property
//                value's new size is equal to the old size.  There are a
//                number of variant types that take up a fixed amount of space,
//                e.g., VT_I4, VT_R8 etc.  This would also apply to any
//                variable length property that is updated without changing
//                the property value's size across a DWORD boundary.
//
//              Note that while the property offset array is itself packed out
//              of necessity (to conform to the spec), there may be unused
//              entries at the end of the array that are not compressed out of
//              the stream when properties are deleted.  The unused space is
//              detected and reused when new properties are added later.
//---------------------------------------------------------------------------

#define CCHUNKSTACK     (sizeof(ascnkStack)/sizeof(ascnkStack[0]))

VOID
CPropertySetStream::SetValue(
    IN ULONG cprop,
    IN PROPVARIANT const avar[],
    IN PROPERTY_INFORMATION *apinfo,
    OUT NTSTATUS *pstatus)
{
    //  ------
    //  Locals
    //  ------

    CStreamChunk ascnkStack[6];

    ULONG cpoReserve;
    ULONG cDelete, cInsert, cMove, cUpdate;

#if DBGPROP
    ULONG cIgnore;
    char valbuf[CB_VALUESTRING];
    KERNELSELECT(
    char valbuf2[CB_VALUESTRING],
    char varbuf[CB_VARIANT_TO_STRING]);
#endif

    ULONG iprop;
    ULONG cbstm;
    LONG cbChange, cbInsertMove;
    PROPERTYSECTIONHEADER *psh;
    CStreamChunk *pscnk0 = NULL;
    ULONG cbNewSize;
    

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    // Worst case, we will need chunks for:
    //  - the possible growth of the PROPERTYIDOFFSET array,
    //  - one for EACH property that is being modified,
    //  - and one chunk to mark the end of the property data.

    CStreamChunkList scl(
                        1 + cprop + 1,
                        1 + cprop + 1 <= CCHUNKSTACK? 
			ascnkStack : ((CStreamChunk*)NULL) );

    PROPASSERT(_IsMapped());


    // Validate that this property set can be written to.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetValue: deleted or read-only");
        goto Exit;
    }

    // Mark the propset dirty.
    _SetModified();


    psh = _GetSectionHeader();

    cpoReserve = 0;
    cDelete = cInsert = cMove = cUpdate = 0;
#if DBGPROP
    cIgnore = 0;
#endif
    cbInsertMove = cbChange = 0;

    pscnk0 = scl.GetFreeChunk(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    pscnk0->oOld = 0;
    pscnk0->cbChange = 0;
    PROPASSERT(pscnk0 == scl.GetChunk(0));

    cbstm = _oSection + psh->cbSection + _cbTail;
    PROPASSERT( cbstm <= _MSTM(GetSize)(pstatus) && NT_SUCCESS(*pstatus) );
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    //  ------------------------
    //  Classify all the updates
    //  ------------------------

    // Each update gets classified as ignore, delete, insert, move,
    // or update.
    // Lookup the old value for each of the properties specified and
    // compute the current size.

    for (iprop = 0; iprop < cprop; iprop++)
    {
        ULONG i;
        ULONG cbPropOld;
        SERIALIZEDPROPERTYVALUE const *pprop = NULL;

        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        if (IsReadOnlyPropid(apinfo[iprop].pid))
        {
	    if (cprop != 1 ||
		apinfo[0].pid != PID_DICTIONARY ||
		apinfo[0].cbprop == 0 ||
                ( avar == NULL || avar[0].vt != VT_DICTIONARY )
               )
	    {
		DebugTrace(0, DEBTRACE_ERROR, (
		    "SetValue: read-only propid=%lx\n",
		    apinfo[iprop].pid));
		StatusInvalidParameter(pstatus, "SetValue: read-only PROPID");
                goto Exit;
	    }
        }

        if (apinfo[iprop].pid != PID_ILLEGAL)
        {
            pprop = _LoadProperty(apinfo[iprop].pid, &cbPropOld, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
        }

        // If this propid appears later in the array, ignore it.

        for (i = iprop + 1; i < cprop; i++)
        {
            if (apinfo[i].pid == apinfo[iprop].pid)
            {
#if DBGPROP
                cIgnore++;
#endif
                apinfo[iprop].operation = PROPOP_IGNORE;
                break;
            }
        }

        // If this propid appears only once or if it's the last instance,
        // load the property and compute its size.

        if (i == cprop)
        {
            VOID *pvStart = NULL;

            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
            if (pprop != NULL)
            {
                ULONG cbPropNew;

                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);
                if (apinfo[iprop].cbprop == 0)
                {
                    DebugTrace(0, Dbg, (
                        "SetValue: Deleting propid=%lx oOld=%l" szX
                            " vt=%hx val=%s cb=%l" szX "\n",
                        apinfo[iprop].pid,
                        _MapAddressToOffset(pprop),
                        PropByteSwap( pprop->dwType ),
                        ValueToString(pprop, cbPropOld, valbuf),
                        cbPropOld));

                    cbPropNew = 0;
                    cDelete++;
                    apinfo[iprop].operation = PROPOP_DELETE;
                }
                else
                {
                    DebugTrace(0, Dbg, (
                        "SetValue: Modifying propid=%lx oOld=%l" szX
                            " vt=%hx-->%hx cb=%l" szX "-->%l" szX " val=%s-->%s\n",
                        apinfo[iprop].pid,
                        _MapAddressToOffset(pprop),
                        PropByteSwap( pprop->dwType ),
			KERNELSELECT(
				PropByteSwap( apinfo[iprop].pprop->dwType ),
				avar[iprop].vt),
                        cbPropOld,
                        apinfo[iprop].cbprop,
                        ValueToString(pprop, cbPropOld, valbuf),
			KERNELSELECT(
			    ValueToString(
				    apinfo[iprop].pprop,
				    apinfo[iprop].cbprop,
				    valbuf2),
			    VariantToString(
				    avar[iprop],
				    varbuf,
				    sizeof( varbuf )))));

                    cbPropNew = apinfo[iprop].cbprop;
                    if (cbPropOld != cbPropNew)
                    {
                        cbInsertMove += apinfo[iprop].cbprop;
                        cMove++;
                        apinfo[iprop].operation = PROPOP_MOVE;
                    }
                    else
                    {
                        cUpdate++;
                        apinfo[iprop].operation = PROPOP_UPDATE;
                    }
                }

                if (apinfo[iprop].operation != PROPOP_UPDATE)
                {
                    // Update the list of chunks that need to be adjusted
                    CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    pscnk->oOld = _MapAddressToOffset(pprop);
                    pscnk->cbChange = - (LONG) cbPropOld;
                }

                // Stream size change
                cbChange += cbPropNew - cbPropOld;
            }

            // Delete non-existent property:

            else if (apinfo[iprop].cbprop == 0)
            {
#if DBGPROP
                cIgnore++;
#endif
                PROPASSERT(apinfo[iprop].pid != PID_DICTIONARY);
                apinfo[iprop].operation = PROPOP_IGNORE;
            }

            // Insert new property:

            else
            {
                DebugTrace(0, Dbg, (
                    "SetValue: Inserting new propid=%lx vt=%hx "
                        "cbNew=%l" szX " val=%s\n",
                    apinfo[iprop].pid,
                    KERNELSELECT(
			    PropByteSwap( apinfo[iprop].pprop->dwType ),
			    avar[iprop].vt),
                    apinfo[iprop].cbprop,
                    KERNELSELECT(
			ValueToString(
			    apinfo[iprop].pprop,
			    apinfo[iprop].cbprop,
			    valbuf),
			VariantToString(
			    avar[iprop],
			    varbuf,
			    sizeof( varbuf )))));

                PROPASSERT(apinfo[iprop].pid != PID_ILLEGAL);

                cbInsertMove += apinfo[iprop].cbprop;
                cbChange += apinfo[iprop].cbprop;

                cInsert++;
                apinfo[iprop].operation = PROPOP_INSERT;
            }
            PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);
        }

    }

    DebugTrace(0, Dbg, ("SetValue: Total Props %l" szX "\n", cprop));
    DebugTrace(0, Dbg, (
        "SetValue: Delete=%l" szX " Insert=%l" szX " Move=%l" szX
            " Update=%l" szX " Ignore=%l" szX "\n",
        cDelete,
        cInsert,
        cMove,
        cUpdate,
        cIgnore));

    PROPASSERT(cDelete + cInsert + cMove + cUpdate + cIgnore == cprop);
    PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    // If we need to grow the property offset array, detect any unused
    // entries at the end of the array that are available for reuse.
    // and adjust the size difference to reflect the reuse.

    if (cInsert > cDelete)
    {
        ULONG cpoReuse, cpoExpand;

        cpoExpand = cInsert - cDelete;
        cpoReuse = _CountFreePropertyOffsets(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (cpoReuse > cpoExpand)
        {
            cpoReuse = cpoExpand;
        }
        cpoExpand -= cpoReuse;

        // If adding a small number of new entries, but not reusing any old
        // ones, add 10% more reserved entries (but only up to 10 more) to
        // avoid having to continually grow the property offset array for
        // clients that insist on adding a few properties at a time.

        // We don't do this for the User-Defined property set, however,
        // because older apps assume that the dictionary immediately follows
        // the last entry in the PID/Offset array.

        if (cpoExpand >= 1 && cpoExpand <= 2 && cpoReuse == 0
            &&
            !(_State & CPSS_USERDEFINEDPROPERTIES)
           )
        {
           cpoReserve = 1 + min(psh->cProperties, 90)/10;
           cpoExpand += cpoReserve;
        }
        DebugTrace(0, Dbg, (
            "SetValue: Reusing %l" szX " offsets, Expanding %l" szX
                " offsets\n",
            cpoReuse,
            cpoExpand));

        pscnk0->oOld = CB_PROPERTYSECTIONHEADER +
               (psh->cProperties + cpoReuse) * CB_PROPERTYIDOFFSET;
        pscnk0->cbChange = cpoExpand * CB_PROPERTYIDOFFSET;
        cbChange += cpoExpand * CB_PROPERTYIDOFFSET;
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

    }   // if (cInsert > cDelete)

    // Do we instead need to *shrink* the PID/Offset array?
    // If so, don't shrink any more than necessary.  We'll
    // leave up to min(10%,10) blank entries.
    // Also, if this is the User-Defined property set,
    // there can never be any unused entries (for compatibility
    // with older apps), so we do a complete shrink.

    else if (cInsert < cDelete)
    {
        ULONG cpoRemove = 0;
        ULONG cpoDelta = cDelete - cInsert;

        // How many blank entries do we already have?
        ULONG cpoCurBlankEntries = _CountFreePropertyOffsets( pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( _State & CPSS_USERDEFINEDPROPERTIES )
        {
            cpoRemove = cpoDelta;
        }
        else
        {
            // How many blank entries can we have?
            ULONG cpoMaxBlankEntries;
            cpoMaxBlankEntries = 1 + min(psh->cProperties - cpoDelta, 90)/10;

            // If, after deleting the properties, we'd have too many,
            // remove only enough to get us down to the max allowable.

            if( cpoCurBlankEntries + cpoDelta
                >
                cpoMaxBlankEntries
              )
            {
                cpoRemove = cpoCurBlankEntries + cpoDelta - cpoMaxBlankEntries;
            }
        }   // if( _State & CPSS_USERDEFINEDPROPERTIES )

        // Should we remove any PID/Offset entries?

        if( cpoRemove > 0 )
        {
            // Start removing at cpoRemove entries from the end of the PID/Offset array
            pscnk0->oOld = CB_PROPERTYSECTIONHEADER
                           +
                           (psh->cProperties + cpoCurBlankEntries - cpoRemove)
                           *
                           CB_PROPERTYIDOFFSET;

            // Remove the bytes of the cpoRemove entries.
            pscnk0->cbChange = - (LONG) (cpoRemove * CB_PROPERTYIDOFFSET );

            // Adjust the size of the section equivalently.
            cbChange += pscnk0->cbChange;
        }

    }   // else if (cInsert < cDelete)

    PROPASSERT(
        cbstm + cbChange >=
        _oSection + CB_PROPERTYSECTIONHEADER +
        (psh->cProperties + cInsert - cDelete) * CB_PROPERTYIDOFFSET +
	_cbTail);

    // If we need to grow the stream, do it now.

    if (cbChange > 0)
    {
        if (cbstm + cbChange > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetValue: 256k limit");
            goto Exit;
        }

        DebugTrace(0, Dbg, (
            "SetSize(%x) SetValue grow\n",
            cbstm + cbChange));

        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // reload all pointers into mapped image:

        psh = _GetSectionHeader();
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

	// If there's another section after this one, move it back to the
	// end of the stream now.

	if (_cbTail != 0)
	{
	    VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

	    PropMoveMemory(
		    "SetValue(_cbTail:grow)",
		    psh,
		    Add2Ptr(pvSrc, cbChange),
		    pvSrc,
		    _cbTail);
	}
    }

    // From this point on, the operation should succeed.
    // If necessary, the stream has already been grown.

    if (cDelete + cInsert + cMove != 0)
    {
        // Delete and compact property offsets in the section header.

        if (cDelete + cMove != 0)
        {
            _DeleteMovePropertyOffsets(apinfo, cprop, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
            psh->cProperties -= cDelete;
        }
        PROPASSERT(cbstm == _oSection + psh->cbSection + _cbTail);

        // Use the last chunk to mark the section end, and sort the chunks
        // in ascending order by start offset.

        CStreamChunk *pscnk = scl.GetFreeChunk(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        pscnk->oOld = psh->cbSection;
        pscnk->cbChange = 0;

        scl.SortByStartAddress();

        // If we're reducing the number of properties, we may be shrinking
        // the PID/Offset array.  So, update that array now, since
        // we may remove some bytes at the end of it when we compact
        // the stream.

        if( cDelete > cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Compact the Stream following the directions in the
        // chunk list.

        _CompactStream(&scl);

        // If the number of properties is holding constant or increasing,
        // we can update the PID/Offset array now (because _CompactStream
        // allocated any necessary space for us).

        if( cDelete <= cInsert )
        {
            _UpdatePropertyOffsets( &scl, pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }

        // Set the new section size to include the deleted and inserted
        // property offsets, and the deleted property values.

        psh->cbSection += cbChange;

        // Insert new property offsets at the end of the array.

        if (cInsert + cMove != 0)
        {
            _InsertMovePropertyOffsets(
                                apinfo,
                                cprop,
                                psh->cbSection - cbInsertMove,
                                cpoReserve,
                                pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            psh->cProperties += cInsert;
        }

        PROPASSERT(cbstm + cbChange == _oSection + psh->cbSection + _cbTail);
	if (_cbTail != 0)
	{
	    // There's another section after this one; if we're shrinking
	    // the stream, move it up to the new end of the stream now.

	    if (cbChange < 0)
	    {
		VOID *pvSrc = _MapAbsOffsetToAddress(cbstm - _cbTail);

		PropMoveMemory(
			"SetValue(_cbTail:shrink)",
			psh,
			Add2Ptr(pvSrc, cbChange),
			pvSrc,
			_cbTail);
	    }
	    _PatchSectionOffsets(cbChange);
	}
    }   // if (cDelete + cInsert + cMove != 0)

    // Copy the new values.

    // NOTE: It might seem unnecessary to delay the in-place updates until
    // this for loop.  We do not perform the in-place updates while
    // classifying the changes because unmapping, remapping and changing
    // the size required for handling other updates can fail.  In the event
    // of such a failure, the update would not be atomic.  By delaying the
    // in-place updates, we provide some degree of atomicity.

    if (cInsert + cUpdate + cMove != 0)
    {
	BOOLEAN fDocSummaryInfo = FALSE;

	if ((_State &
             (CPSS_USERDEFINEDPROPERTIES | CPSS_DOCUMENTSUMMARYINFO)) ==
	     CPSS_DOCUMENTSUMMARYINFO)
	{
	    fDocSummaryInfo = TRUE;
	}
        
        for (iprop = 0; iprop < cprop; iprop++)
        {
            // Find property in the offset array and copy in the new value.
            if (apinfo[iprop].operation == PROPOP_INSERT ||
                apinfo[iprop].operation == PROPOP_UPDATE ||
                apinfo[iprop].operation == PROPOP_MOVE)
            {
                SERIALIZEDPROPERTYVALUE *pprop=NULL;
                ULONG cbprop;
                PROPID propid = apinfo[iprop].pid;

                pprop = _LoadProperty(propid, NULL, pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
                PROPASSERT(pprop != NULL);

                // Special case for SetPropertyNames dictionary creation:

                if (propid == PID_DICTIONARY)
                {
                    PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);
                    PROPASSERT(apinfo[iprop].cbprop == CB_SERIALIZEDPROPERTYVALUE);
                    PROPASSERT(avar[iprop].vt == VT_DICTIONARY);
                    ((DICTIONARY *) pprop)->cEntries = 0;
                }   // if (propid == PID_DICTIONARY)
                else
                {

                    // In User, serialize the PROPVARIANT in avar
                    // directly into the mapped stream.  

                    cbprop = apinfo[iprop].cbprop;
                    pprop = RtlConvertVariantToProperty(
                                    &avar[iprop],
                                    _CodePage,
                                    pprop,
                                    &cbprop,
                                    apinfo[iprop].pid,
                                    FALSE,
                                    pstatus
                                    );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    PROPASSERT(pprop != NULL);
                    PROPASSERT(cbprop == DwordAlign(cbprop));
                    PROPASSERT(cbprop == apinfo[iprop].cbprop);

		    // If writing a DocumentSummaryInformation property
		    // for which an alignment hack is provided, hack it now.

		    if (fDocSummaryInfo && _CodePage != CP_WINUNICODE)
		    {
                        // The two vectors in the DocSumInfo property set
                        // (if Ansi) are un-packed, but we'll adjust the lengths
                        // so that if a propset reader expects them to be packed,
                        // it will still work.  E.g., a one character string will
                        // have a length of 4, with padding of NULL characters.

			ULONG cbpropT;

			if (propid == PID_HEADINGPAIR)
			{
			    _FixHeadingPairVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
			else
			if (propid == PID_DOCPARTS)
			{
			    _FixDocPartsVector(
					    PATCHOP_ALIGNLENGTHS,
					    pprop,
					    &cbpropT);
			}
		    }
                    DebugTrace(0, Dbg, (
                        "SetValue:Insert: pph=%x pprop=%x cb=%3l" szX
                            " vt=%4x val=%s o=%x oEnd=%x\n",
                        _pph,
                        pprop,
                        apinfo[iprop].cbprop,
                        PropByteSwap(pprop->dwType),
                        ValueToString(pprop, apinfo[iprop].cbprop, valbuf),
                        _MapAddressToOffset(pprop),
                        _MapAddressToOffset(pprop) + apinfo[iprop].cbprop));

                }   // if (propid == PID_DICTIONARY) ... else
            }   // if (apinfo[iprop].operation == PROPOP_INSERT || ...
        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // if (cInsert + cUpdate + cMove != 0)

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    cbNewSize = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (cbNewSize != cbstm + cbChange)
    {
        DebugTrace(0, Dbg, (
            "SetSize(%x) SetValue shrink\n",
            cbstm + cbChange));
        _MSTM(SetSize)(cbstm + cbChange, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    scl.Delete();

}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CountFreePropertyOffsets, private
//
// Synopsis:    counts available (free) property offsets at and of array
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     count of available property offsets at and of array
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_CountFreePropertyOffsets(OUT NTSTATUS *pstatus)
{
    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER const *psh;
    ULONG oMin = MAXULONG;
    ULONG oEnd;
    ULONG cFree = 0;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (psh != NULL)
    {
        for ( ; ppo < ppoMax; ppo++)
        {
            if (oMin > ppo->dwOffset)
            {
                oMin = ppo->dwOffset;
            }
        }
    }
    if (oMin == MAXULONG)
    {
        goto Exit;
    }
    PROPASSERT(psh != NULL);
    oEnd = CB_PROPERTYSECTIONHEADER + psh->cProperties * CB_PROPERTYIDOFFSET;
    PROPASSERT(oEnd <= oMin);

    cFree = (oMin - oEnd)/CB_PROPERTYIDOFFSET;

Exit:

    return( cFree );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DeleteMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_DeleteMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    ULONG cDelete;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Remove the deleted properties

    DebugTrace(0, Dbg, ("Marking deleted/moved property offsets\n"));
    cDelete = 0;
    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_DELETE ||
            apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    DebugTrace(0, Dbg, (
                        "%sing propid=%lx oOld=%l" szX "\n",
                        apinfo[i].operation == PROPOP_DELETE? "Delet" : "Mov",
                        ppo->propid,
                        ppo->dwOffset));
                    if (apinfo[i].operation == PROPOP_DELETE)
                    {
                        cDelete++;
                        ppo->dwOffset = MAXULONG;
                    }
                    else
                    {
                        ppo->dwOffset = 0;
                    }
                    break;
                }
            }
        }
    }

    // scan once and compact the property offset array.

    if (cDelete > 0)
    {
        PROPERTYIDOFFSET *ppoDst = ppoBase;

        DebugTrace(0, Dbg, ("Compacting %l" szX " deleted props\n", cDelete));
        for (ppo = ppoBase; ppo < ppoMax; ppo++)
        {
            if (ppo->dwOffset != MAXULONG)
            {
                if (ppo > ppoDst)
                {
                    *ppoDst = *ppo;
                }
                DebugTrace(0, Dbg, (
                    "%sing propid=%lx oOld=%l" szX "\n",
                    ppo > ppoDst? "Compact" : "Preserv",
                    ppo->propid,
                    ppo->dwOffset));
                ppoDst++;
            }
        }
        PROPASSERT(cDelete == (ULONG) (ppoMax - ppoDst));
        DebugTrace(0, Dbg, ("Zeroing %l" szX " entries\n", cDelete));
        RtlZeroMemory(ppoDst, (BYTE *) ppoMax - (BYTE *) ppoDst);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_UpdatePropertyOffsets, private
//
// Synopsis:    update property offsets in section header
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_UpdatePropertyOffsets(
    IN CStreamChunkList const *pscl,
    OUT NTSTATUS *pstatus)
{
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoMax;

    // Update the offsets for the existing properties.
    DebugTrace(0, Dbg, ("Updating existing property offsets\n"));

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset != 0)
        {
#if DBGPROP
            ULONG oOld = ppo->dwOffset;
#endif
            ppo->dwOffset = _GetNewOffset(pscl, ppo->dwOffset);

            DebugTrace(0, Dbg, (
                "UpdatePropertyOffsets: propid=%lx offset=%l" szX "-->%l" szX"\n",
                ppo->propid,
                oOld,
                ppo->dwOffset));
        }
    }

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_InsertMovePropertyOffsets, private
//
// Synopsis:    updates the offsets following the changes to the stream
//
// Arguments:   [apinfo]        -- array of property information
//              [cprop]         -- number of properties
//              [oInsert]       -- offset in section for new properties
//              [cpoReserve]    -- newly reserved property offsets to zero
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_InsertMovePropertyOffsets(
    IN PROPERTY_INFORMATION const *apinfo,
    IN ULONG cprop,
    IN ULONG oInsert,
    IN ULONG cpoReserve,
    OUT NTSTATUS *pstatus)
{
    ULONG i;
    PROPERTYSECTIONHEADER const *psh;
    PROPERTYIDOFFSET *ppo, *ppoBase, *ppoMax;

    *pstatus = STATUS_SUCCESS;

    psh = _LoadPropertyOffsetPointers(&ppoBase, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Insert the new property offsets at the end.
    DebugTrace(0, Dbg, ("Inserting/Moving/Zeroing property offsets\n"));

    for (i = 0; i < cprop; i++)
    {
        if (apinfo[i].operation == PROPOP_INSERT)
        {
            ppo = ppoMax++;
            ppo->propid = apinfo[i].pid;
        }
        else if (apinfo[i].operation == PROPOP_MOVE)
        {
            for (ppo = ppoBase; ppo < ppoMax; ppo++)
            {
                if (ppo->propid == apinfo[i].pid)
                {
                    PROPASSERT(ppo->dwOffset == 0);
                    break;
                }
            }
        }
        else
        {
            continue;
        }

        PROPASSERT(ppo->propid == apinfo[i].pid);
        ppo->dwOffset = oInsert;
        oInsert += apinfo[i].cbprop;

        DebugTrace(0, Dbg, (
            "%sing propid=%lx offset=%l" szX " size=%l" szX "\n",
            apinfo[i].operation == PROPOP_INSERT? "Insert" : "Mov",
            ppo->propid,
            ppo->dwOffset,
            apinfo[i].cbprop));
    }
    DebugTrace(0, Dbg, (
        "Zeroing %x property offsets o=%l" szX " size=%l" szX "\n",
        cpoReserve,
        _MapAddressToOffset(ppoMax),
        cpoReserve * CB_PROPERTYIDOFFSET));
    RtlZeroMemory(ppoMax, cpoReserve * CB_PROPERTYIDOFFSET);

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactStream, private
//
// Synopsis:    compact all of the property stream chunks
//
// Arguments:   [pscl]          -- list of chunks in stream that were changed
//
// Returns:     None
//
// Note:
//      Each chunk structure represents a contiguous range of the stream to be
//      completely removed or added.  A terminating chunk is appended to
//      transparently mark the end of the data stream.  The unmodified data
//      after each chunk (except the last one) must be preserved and compacted
//      as necessary.  Chunk structures contain section-relative offsets.
//
//      Invariants:
//      - Only the first chunk can represent an insertion; subsequent chunks
//        always represent deletions.
//      - The first chunk can never cause a deletion, but it might not cause
//        any change at all.
//      - The last chunk is a dummy used to mark the end of the stream.
//
//      Algorithm:
//      In the optimal case without insertions, each chunk's trailing data can
//      be moved ahead (compacted) individually in ascending chunk index order.
//      If the first chunk represents an insertion, then some consecutive
//      number of data blocks must be moved back (in *descending* chunk index
//      order) to make room for the insertion.
//
//      Walk the chunk array to find the first point where the accumulated size
//      change is less than or equal to zero.
//
//      After (possibly) compacting a single range in descending chunk index
//      order, compact all remaining chunks in ascending chunk index order.
//
//      Example: the first chunk inserts 18 bytes for new property offsets
//      (apo'[]), and the second two delete 10 bytes each (chnk1 & chnk2).
//      There are four chunks in the array, and three blocks of data to move.
//
//                   oOld   cbChange | AccumulatedChange  oNew
//      chunk[0]:     38      +18    |      +18            38  (apo'[])
//      chunk[1]:     48      -10    |       +8            50  (chnk1)
//      chunk[2]:     6c      -10    |       -8            74  (chnk2)
//      chunk[3]:     8c        0    |       -8            84  (end)
//
//      Data blocks are moved in the following sequence to avoid overlap:
//      DstOff  SrcOff  cbMove | Chunk#
//        60      58      14   |    1  chnk1/data2: descending pass (Dst > Src)
//        50      38      10   |    0  apo'[]/data1: descending pass (Dst > Src)
//        74      7c      10   |    2  chnk2/data3: ascending pass  (Dst < Src)
//
//      SrcOff = oOld - min(cbChange, 0)
//      DstOff = SrcOff + AccumulatedChange
//      cbMove = chnk[i+1].oOld - SrcOff
//
//      Before compacting:
//                   0           38      48      58         6c      7c      8c
//                   |            |       |       |          |       |       |
//                   V            V   10  V  -10  V    14    V  -10  V   10  V
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//      | ph | afo[] | sh | apo[] | data1 | chnk1 |  data2   | chnk2 | data3 |
//      +----+-------+----+-------+-------+-------+----------+-------+-------+
//
//      After compacting:
//                   0           38          50      60         74      84
//                   |            |           |       |          |       |
//                   V            V    +18    V   10  V    14    V   10  V
//      +----+-------+----+-------+-----------+-------+----------+-------+
//      | ph | afo[] | sh | apo[] |   apo'[]  | data1 |  data2   | data3 |
//      +----+-------+----+-------+-----------+-------+----------+-------+
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactStream(
    IN CStreamChunkList const *pscl)
{
    ULONG i, iMax, iAscend;
    LONG cbChangeTotal, cbChangeTotalAscend;
    CStreamChunk const *pscnk;

    // Subtract one to avoid operating on the terminating chunk directly.

    iMax = pscl->Count() - 1;

    // If the first chunk does not indicate an insertion, the first for loop is
    // exited with i == 0.
    //
    // If the first chunk represents an insertion, either i == iMax or i itself
    // indexes the first chunk that can be compacted normally (in ascending
    // chunk index order).  In either case, we compact in descending chunk
    // index order starting just below i.

    DebugTrace(0, Dbg, (
        "CompactStream: %l" szX " chunks @%lx\n",
        pscl->Count(),
        pscl->GetChunk(0)));

    cbChangeTotal = 0;
    for (i = 0; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);
        if (cbChangeTotal + pscnk->cbChange <= 0)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
    }
    iAscend = i;                                // save ascending order start
    cbChangeTotalAscend = cbChangeTotal;

    DebugTrace(0, Dbg, ("CompactStream: iAscend=%l" szX "\n", iAscend));

    // First compact range in descending chunk index order if necessary:

    while (i-- > 0)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: descend: i=%l" szX "\n", i));
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
        cbChangeTotal -= pscnk->cbChange;
    }

    // Compact any remaining chunks in ascending chunk index order.

    cbChangeTotal = cbChangeTotalAscend;
    for (i = iAscend; i < iMax; i++)
    {
        pscnk = pscl->GetChunk(i);
        PROPASSERT(i == 0 || pscnk->cbChange < 0);

        DebugTrace(0, Dbg, ("CompactStream: ascend: i=%l" szX "\n", i));
        cbChangeTotal += pscnk->cbChange;
#if DBGPROP
        pscl->AssertCbChangeTotal(pscnk, cbChangeTotal);
#endif
        _CompactChunk(pscnk, cbChangeTotal, pscl->GetChunk(i + 1)->oOld);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_CompactChunk, private
//
// Synopsis:    Compact the data block following one chunk
//
// Arguments:   [pscnk]         -- pointer to stream chunk
//              [cbChangeTotal] -- Bias for this chunk
//              [oOldNext]      -- offset of next chunk
//
// Returns:     None
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_CompactChunk(
    IN CStreamChunk const *pscnk,
    IN LONG cbChangeTotal,
    IN ULONG oOldNext)
{
    LONG cbDelta = cbChangeTotal + min(pscnk->cbChange, 0);

    DebugTrace(0, Dbg, (
        "CompactChunk(pscnk->oOld=%l" szX ", pscnk->cbChange=%s%l" szX "\n"
            "       cbChangeTotal=%s%l" szX
            ", cbDelta=%s%l" szX                        
            ", oOldNext=%l" szX ")\n",
        pscnk->oOld,
        pscnk->cbChange < 0? "-" : "",
        pscnk->cbChange < 0? -pscnk->cbChange : pscnk->cbChange,
        cbChangeTotal < 0? "-" : "",
        cbChangeTotal < 0? -cbChangeTotal : cbChangeTotal,
        cbDelta < 0? "-" : "",                          
        cbDelta < 0? -cbDelta : cbDelta,                
        oOldNext));

    if (cbChangeTotal != 0)
    {
        ULONG oSrc;
        VOID const *pvSrc;

        oSrc = pscnk->oOld - min(pscnk->cbChange, 0);
        pvSrc = _MapOffsetToAddress(oSrc);
        PropMoveMemory(
                "CompactChunk",
                _GetSectionHeader(),
                (VOID *) Add2ConstPtr(pvSrc, cbChangeTotal),
                pvSrc,
                oOldNext - oSrc);
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PatchSectionOffsets, private
//
// Synopsis:    patch section offsets after moving data around
//
// Arguments:   [cbChange]      -- size delta
//
// Returns:     none
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::_PatchSectionOffsets(
    LONG cbChange)
{
    ULONG i;

    for (i = 0; i < _cSection; i++)
    {
	FORMATIDOFFSET *pfo;

	pfo = _GetFormatidOffset(i);
	if (pfo->dwOffset > _oSection)
	{
	    DebugTrace(0, DEBTRACE_PROPPATCH, (
		"PatchSectionOffsets(%x): %l" szX " + %l" szX " --> %l" szX "\n",
		i,
		pfo->dwOffset,
		cbChange,
		pfo->dwOffset + cbChange));
	    pfo->dwOffset += cbChange;
	}
    }
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_GetNewOffset, private
//
// Synopsis:    gets the new address
//
// Arguments:   [pscl]          -- list of stream chunks that were changed
//              [oOld]          -- old offset
//
// Returns:     new offset
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_GetNewOffset(
    IN CStreamChunkList const *pscl,
    IN ULONG oOld) const
{
    // The Chunk list is sorted by start offsets.  Locate the chunk to which
    // the old offset belongs, then use the total change undergone by the chunk
    // to compute the new offset.

    ULONG i;
    ULONG iMax = pscl->Count();
    LONG cbChangeTotal = 0;

    for (i = 0; i < iMax; i++)
    {
        CStreamChunk const *pscnk = pscl->GetChunk(i);
        if (pscnk->oOld > oOld)
        {
            break;
        }
        cbChangeTotal += pscnk->cbChange;
        if (pscnk->oOld == oOld)
        {
            PROPASSERT(pscnk->cbChange >= 0);
            break;
        }
    }
    PROPASSERT(i < iMax);
    DebugTrace(0, Dbg, (
        "GetNewOffset: %l" szX " + %l" szX " --> %l" szX "\n",
        oOld,
        cbChangeTotal,
        oOld + cbChangeTotal));
    return(oOld + cbChangeTotal);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComputeMinimumSize, private
//
// Synopsis:    computes the minimum possible size of a property set stream
//
// Arguments:   [cbstm]         -- actual stream size
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     computed highest offset in use
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_ComputeMinimumSize(
    IN ULONG cbstm,
    OUT NTSTATUS *pstatus)
{
    ULONG oMax = 0;
    *pstatus = STATUS_SUCCESS;

    // Don't assume *any* class variables except _pph are loaded yet!

    if (_pph != NULL && cbstm != 0)
    {
        ULONG cbMin;
        ULONG i;
        ULONG cSection;

        cSection = 1;
        cbMin = 0;

        if (_HasPropHeader())
        {
            cSection = _pph->reserved;
            cbMin = CB_PROPERTYSETHEADER + cSection * CB_FORMATIDOFFSET;
        }
        oMax = cbMin;

        // Add the size of each section

        for (i = 0; i < cSection; i++)
        {
            ULONG oSectionEnd;

            PROPERTYSECTIONHEADER const *psh = _GetSectionHeader(i, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            cbMin += psh->cbSection;
            oSectionEnd = _MapAddressToAbsOffset(psh) + psh->cbSection;
            if (oMax < oSectionEnd)
            {
                oMax = oSectionEnd;
            }
        }
        PROPASSERT(oMax <= cbstm);
        PROPASSERT(cbMin <= oMax);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // oMax may have been set before an error occurred.
    // In this case, set it to zero.

    if( !NT_SUCCESS(*pstatus) )
        oMax = 0;

    return(oMax);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_DictionaryLength
//
// Synopsis:    compute length of property set dictionary
//
// Arguments:   [pdy]           -- pointer to dictionary
//              [cbbuf]         -- maximum length of accessible memory at pdy
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     Byte-granular count of bytes in dictionary
//+--------------------------------------------------------------------------

ULONG
CPropertySetStream::_DictionaryLength(
    IN DICTIONARY const *pdy,
    IN ULONG cbbuf,
    OUT NTSTATUS *pstatus ) const
{
    ENTRY UNALIGNED const *pent;
    ULONG cbDict = CB_DICTIONARY;
    ULONG i;

    *pstatus = STATUS_SUCCESS;

    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        if (cbbuf < cbDict + CB_ENTRY ||
            cbbuf < _DictionaryEntryLength( pent ))
        {
            StatusCorruption(pstatus, "_DictionaryLength: section size");
            goto Exit;
        }

        cbDict += _DictionaryEntryLength( pent );
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(cbDict);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_PropertyNameLength
//
// Synopsis:    compute length (*byte* count) of a property name
//
// Arguments:   [pvName]        -- property name, in the codepage of
//                                 the property set
//              [pcbName]       -- pointer to returned byte length of name
//
// Returns:     TRUE if name length is valid; else FALSE
//
// Note:        The OLE 2.0 format mandates that the null be included as part
//              of the length of the name that is stored in the dictionary.
//              If the propset uses the Unicode code page, names contain
//              WCHARs, otherwise they contain CHARs.  In either case, the
//              length is a byte count that includes the L'\0' or '\0'.
//
//              Also note that this routine does not concern itself with
//              the byte-order of the name:  for Ansi names, it's irrelevant;
//              and for Unicode names, L'\0' == PropByteSwap(L'\0').
//
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_PropertyNameLength(
    IN VOID const *pvName,
    OUT ULONG *pcbName) const
{
    ULONG cch;

    if (_CodePage == CP_WINUNICODE)
    {
        cch = Prop_wcslen((WCHAR const *) pvName) + 1;
        *pcbName = cch * sizeof(WCHAR);
    }
    else
    {
        *pcbName = cch = strlen((char const *) pvName) + 1;
    }
    return(cch > 1 && cch <= CCH_MAXPROPNAMESZ );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ComparePropertyNames
//
// Synopsis:    Compare two property names.
//
// Pre-Conditions:
//              The property names are in the codepage of the
//              property set.
//
// Arguments:   [pvName1]       -- property name 1
//              [pvName2]       -- property name 2
//              [fSameByteOrder]-- TRUE: names are both big- or little-endian
//                                 FALSE: 2n\d name is wrong endian
//              [cbName]        -- byte count of name length
//                                 (includes terminator)
//
// Returns:     TRUE if names are equal
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::_ComparePropertyNames(
    IN VOID const *pvName1,
    IN VOID const *pvName2,
    IN BOOL fSameByteOrder,
    IN ULONG cbName) const
{
    if (_CodePage == CP_WINUNICODE)
    {
        // On big-endian systems, when the second name
        // is byte-swapped, we'll byte-swap it into a new
        // buffer to use for the comparisson.

#ifdef BIGENDIAN
        WCHAR awcByteSwap[ CCH_MAXPROPNAMESZ ];
        if( !fSameByteOrder )
        {
            ULONG ulIndex = 0;
            PROPASSERT( (WCHAR)'\0' == ByteSwap( (WCHAR) '\0'));

            do
            {
                awcByteSwap[ ulIndex ] = 
                    ByteSwap( ((WCHAR*)pvName2)[ ulIndex ] );
            } while (awcByteSwap[ulIndex++] != (WCHAR)'\0');
        }
#endif // BIGENDIAN 

        return(Prop_wcsnicmp(
                    (WCHAR const *) pvName1,
#ifdef BIGENDIAN
                    fSameByteOrder ? (WCHAR const *) pvName2
                                   : awcByteSwap,
#else
                    (WCHAR const * ) pvName2,
#endif
                    cbName / sizeof(WCHAR) ) == 0);

    }   // if (_CodePage == CP_WINUNICODE)

    else
    {
        return(_strnicmp(
                    (char const *) pvName1,
                    (char const *) pvName2,
                    cbName) == 0);
    }   // if (_CodePage == CP_WINUNICODE) ... else
}

    

//+---------------------------------------------------------------------------
// Function:    CPropertySetStream::DuplicatePropertyName
//
// Synopsis:    Duplicate an OLECHAR property name string
//
// Arguments:   [poszName]  -- input string
//              [cbName]    -- count of bytes in string (includes null)
//              [pstatus]   -- pointer to NTSTATUS code
//
// Returns:     pointer to new string
//---------------------------------------------------------------------------

OLECHAR *
CPropertySetStream::DuplicatePropertyName(
    IN OLECHAR const *poszName,
    IN ULONG cbName,
    OUT NTSTATUS *pstatus) const
{
    OLECHAR *poc = NULL;
    *pstatus = STATUS_SUCCESS;

    PROPASSERT(cbName != 0);
    PROPASSERT(IsOLECHARString(poszName, cbName));

    if (cbName != 0)
    {
        PROPASSERT((ocslen(poszName) + 1) * sizeof(OLECHAR) == cbName);

        poc = (OLECHAR *) _pma->Allocate(cbName);

        if (NULL == poc)
        {
            StatusNoMemory(pstatus, "DuplicatePropertyName: no memory");
            goto Exit;
        }
        RtlCopyMemory(poc, poszName, cbName);
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return(poc);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropid
//
// Synopsis:    translate a property name to a property id using the
//              dictionary on the property stream
//
// Arguments:   [poszName]      -- name of property
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     propid for property if found; PID_ILLEGAL if not found
//---------------------------------------------------------------------------

PROPID
CPropertySetStream::QueryPropid(
    IN OLECHAR const *poszName,
    OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    ULONG cbname;
    DICTIONARY const *pdy;
    ENTRY UNALIGNED const *pent;
    ULONG cdye;
    ULONG cbDict;               // BYTE granular size!
    VOID const *pvName=NULL;
    PROPID propid = PID_ILLEGAL;

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT( IsOLECHARString( poszName, MAXULONG ));
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);


    // Make sure this isn't a UD propset which has been deleted.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropid: deleted");
        goto Exit;
    }

    // Put the name into pvName, converting it if
    // necessary to the code-page of the property set.

    pvName = poszName;
    if (_CodePage == CP_WINUNICODE  // Property set is Unicode
        &&
        !OLECHAR_IS_UNICODE )       // Name is in Ansi
    {
        // Convert the caller-provided name from the system
        // Ansi codepage to Unicode.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToWideChar( poszName, (ULONG)-1, CP_ACP,
                            (WCHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // If necessary, swap the WCHARs of the Unicode string.
        //PropByteSwap( (WCHAR*) pvName, cb, sizeof(WCHAR) );
    }

    else
    if (_CodePage != CP_WINUNICODE  // Property set is Ansi
        &&
        OLECHAR_IS_UNICODE )        // Name is in Unicode
    {
        // Convert the caller-provided name from Unicode
        // to the propset's Ansi codepage.

        ULONG cb = 0;
        pvName = NULL;
        _OLECHARToMultiByte( poszName, (ULONG)-1, _CodePage,
                             (CHAR**)&pvName, &cb, pstatus );
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    // How long is this property name (in bytes)?

    if (!_PropertyNameLength(pvName, &cbname))
    {
        // The length is invalid.
        StatusInvalidParameter(pstatus, "QueryPropid: name length");
        goto Exit;
    }

    // Get a pointer to the raw dictionary.

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Is there a dictionary?

    if (pdy != NULL)
    {
        // Yes - there is a dictionary.

        PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();

        // Search the dictionary for an entry name matching
        // pvName.

        for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0];
             cdye > 0;
             cdye--, pent = _NextDictionaryEntry( pent ))
        {
            // Is the length of this dictionary entry valid?
            if ( _MapAddressToOffset(pent) + _DictionaryEntryLength( pent )
                 > psh->cbSection
               )
            {
                StatusCorruption(pstatus, "QueryPropid: section size");
                goto Exit;
            }

            // If the byte-length matches what we're looking for,
            // and the names compare successfully, then we're done.

            if ( CCh2CB(PropByteSwap( ENTRY_GetCch(pent) )) == cbname
                 &&
                 _ComparePropertyNames(pvName, ENTRY_GetSz(pent),
                                       FALSE, // pvName, pent->sz could be dif Endians
                                       cbname)
               )
            {
                propid = PropByteSwap( ENTRY_GetPropid(pent) );
                break;
            }
        }   // for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0]; ...

        PROPASSERT(cdye > 0 || pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:
    // If we did an alloc on the name to munge it,
    // delete that buffer now.  We must cast pvName
    // as a non-const in order for the compiler to accept
    // the free call.
    
    if( pvName != poszName )
        _pma->Free( (VOID*) pvName );
    
    return(propid);
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertyNameBuf
//
// Synopsis:    convert from a property id to a property name using the
//              dictionary in the property set, and putting the result 
//              in a caller-provided buffer.
//
// Arguments:   [propid]        -- property id to look up
//              [aocName]       -- output buffer
//              [pcbName]       -- IN:  length of aocName;
//                                 OUT: actual length of name
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     TRUE if name is found in dictionary
//---------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::QueryPropertyNameBuf(
    IN PROPID propid,
    OUT OLECHAR *aocName,
    IN OUT ULONG *pcbName,
    OUT NTSTATUS *pstatus)
{
    BOOL fFound = FALSE;
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_IsMapped());
    PROPASSERT(propid != PID_DICTIONARY);
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);
    PROPASSERT(NULL != aocName);

    // Ensure that this isn't an already-deleted UD propset.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropertyNameBuf: deleted");
        goto Exit;
    }

    // Get a pointer to the raw dictionary.

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Is there a dictionary?
    if (pdy != NULL)
    {
        // Yes - the dictionary was found.

        ULONG cdye;
        ENTRY UNALIGNED const *pent;
        VOID const *pvDictEnd;

        // Get pointers to the first and last+1 entries.

        pent = pdy->rgEntry;
        pvDictEnd = Add2ConstPtr(pdy, cbDict);

        // Scan through the dictionary, searching for 'propid'.

        for (cdye = PropByteSwap(pdy->cEntries), pent = &pdy->rgEntry[0];
             cdye > 0;
             cdye--, pent = _NextDictionaryEntry( pent ))
        {
            // Make sure this entry doesn't go off the end of the
            // dictionary.

            if (Add2ConstPtr(pent, _DictionaryEntryLength( pent )) > pvDictEnd)
            {
                StatusCorruption(pstatus, "QueryPropertyNameBuf: dictionary entry size");
                goto Exit;
            }

            // Is this the PID we're looking for?
            if (PropByteSwap(ENTRY_GetPropid(pent)) == propid)
            {
                // Yes.  Copy or convert the name into the caller's
                // buffer.

                // Is a Unicode to Ansi conversion required?
                if (_CodePage == CP_WINUNICODE      // Property set is Unicode
                    &&
                    !OLECHAR_IS_UNICODE )           // Caller's buffer is Ansi
                {
                    WCHAR *pwszName = (WCHAR*) ENTRY_GetSz(pent);

                    // If we're byte-swapping, alloc a new buffer, swap
                    // pwszName into it (getting the string into system-endian
                    // byte-order), and point pwszName to the result.

                    PBSInPlaceAlloc( &pwszName, NULL, pstatus );
                    if( !NT_SUCCESS( *pstatus )) goto Exit;

                    // Convert the Unicode string in the property set
                    // to the system default codepage.

                    _WideCharToOLECHAR( pwszName, (ULONG)-1, CP_ACP,
                                        &aocName, pcbName, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

                    // If we allocated a buffer for byte-swapping,
                    // we don't need it any longer.

                    if( pwszName != (WCHAR*) ENTRY_GetSz(pent) )
                        delete pwszName;
                }

                // Or is an Ansi to Unicode conversion required?
                else
                if (_CodePage != CP_WINUNICODE      // Property set is Ansi
                    &&
                    OLECHAR_IS_UNICODE )            // Caller's buffer is Unicode
                {
                    // Convert the Ansi property set name from the
                    // propset's codepage to Unicode.

                    _MultiByteToOLECHAR( (CHAR*) ENTRY_GetSz(pent), 
                                        (ULONG)-1, _CodePage,
                                         &aocName, pcbName, pstatus );
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
                }

                // Otherwise, no conversion of the name is required
                else
                {
                    ULONG ulEntryLen= CCh2CB(PropByteSwap(ENTRY_GetCch(pent)));
                    // Copy the name into the caller's buffer.
                    RtlCopyMemory(aocName, ENTRY_GetSz(pent),
                                  min(ulEntryLen, *pcbName));

                    // Swap the name to the correct endian
                    // (This will do nothing if OLECHARs are CHARs).
                    PBSBuffer( aocName,
                               min( CCh2CB(PropByteSwap( ENTRY_GetCch(pent) )),
                                    *pcbName),
                               sizeof(OLECHAR) );

                    // Tell the caller the actual size of the name.
                    *pcbName = ulEntryLen;
                }

                PROPASSERT( NULL == aocName || IsOLECHARString( aocName, MAXULONG ));
                fFound = TRUE;
                break;

            }   // if (ENTRY_GetPropid(pent) == propid)
        }   // for (cdye = pdy->cEntries, pent = &pdy->rgEntry[0]; ...

        PROPASSERT(fFound || pent == pvDictEnd);

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    return( fFound );
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::QueryPropertyNames
//
// Synopsis:    query dictionary names for the passed property ids.
//
// Arguments:   [cprop]          -- count of name to propid mappings to change
//              [apid]           -- array of property ids
//              [aposz]          -- array of pointers to the new names
//              [pstatus]        -- pointer to NTSTATUS code
//
// Returns:     TRUE if the property exists.
//+--------------------------------------------------------------------------

BOOLEAN
CPropertySetStream::QueryPropertyNames(
    IN ULONG cprop,
    IN PROPID const *apid,
    OUT OLECHAR *aposz[],
    OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!
    ULONG iprop;
    BOOLEAN fFound = FALSE;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    // If this is an attempt to access a deleted UD
    // propset, exit now.
    if (_State & CPSS_USERDEFINEDDELETED)
    {
        StatusAccessDenied(pstatus, "QueryPropertyNames: deleted");
        goto Exit;
    }

    // Validate the input array of strings.
    for (iprop = 0; iprop < cprop; iprop++)
    {
        PROPASSERT(aposz[iprop] == NULL);
    }

    // Get a pointer to the beginning of the dictionary
    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    // Did we get a dictionary?
    if (pdy != NULL)
    {
        // Yes, the dictionary exists.

        ULONG i;
        ENTRY UNALIGNED const *pent;

        // Iterate through each of the entries in the dictionary.

        for (i = 0, pent = &pdy->rgEntry[0];
             i < PropByteSwap( pdy->cEntries );
             i++, pent = _NextDictionaryEntry( pent ))
        {
            // Scan the input array of PIDs to see if one matches
            // this dictionary entry.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                if( PropByteSwap(ENTRY_GetPropid(pent)) == apid[iprop] )
                {
                    // We've found an entry in the dictionary
                    // that's in the input PID array.  Put the property's
                    // name in the caller-provided array (aposz).

                    PROPASSERT(aposz[iprop] == NULL);

                    // Do we need to convert to Unicode?

                    if (_CodePage != CP_WINUNICODE      // Ansi property set
                        &&
                        OLECHAR_IS_UNICODE)             // Unicode property names
                    {
                        ULONG cbName = 0;
                        _MultiByteToOLECHAR( ENTRY_GetSz(pent), 
                                            (ULONG)-1, _CodePage,
                                            &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                    }

                    // Or, do we need to convert to Ansi?
                    else
                    if (_CodePage == CP_WINUNICODE      // Unicode property set
                        &&
                        !OLECHAR_IS_UNICODE)            // Ansi property names
                    {
                        ULONG cbName = 0;
                        WCHAR *pwszName = (WCHAR*) ENTRY_GetSz(pent);

                        // If necessary, swap the Unicode name in the dictionary,
                        // pointing pwszName to the new, byte-swapped, buffer.

                        PBSInPlaceAlloc( &pwszName, NULL, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // And convert to Ansi.
                        _WideCharToOLECHAR( pwszName, (ULONG)-1, CP_ACP,
                                            &aposz[iprop], &cbName, pstatus );
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If we alloced a new buffer for byte-swapping,
                        // we can free it now.

                        if( pwszName != (WCHAR*) ENTRY_GetSz(pent) )
                            delete pwszName;

                    }   // else if (_CodePage == CP_WINUNICODE ...

                    // Otherwise, both the propset & in-memory property names
                    // are both Unicode or both Ansi, so we can just do 
                    // an alloc & copy.

                    else
                    {
                        aposz[iprop] = 
                            DuplicatePropertyName( (OLECHAR *) 
                                                  ENTRY_GetSz(pent),
                                                  CCh2CB(PropByteSwap(ENTRY_GetCch(pent))), 
                                                         pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                        // If necessary, swap the in-memory copy.
                        PBSBuffer( (OLECHAR*) aposz[iprop],
                                   CCh2CB( PropByteSwap( pent->cch )),
                                   sizeof(OLECHAR) );

                    }   // if (_CodePage != CP_WINUNICODE ... else if ... else

                    PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));

                    fFound = TRUE;

                }   // if (PropByteSwap(ENTRY_GetPropid(pent) == apid[iprop])
            }   // for (iprop = 0; iprop < cprop; iprop++)
        }   // for (i = 0, pent = &pdy->rgEntry[0];

        PROPASSERT(pent == Add2ConstPtr(pdy, cbDict));

    }   // if (pdy != NULL)

    //  ----
    //  Exit
    //  ----

Exit:

    // If the property name simply didn't exist, return
    // a special success code.

    if( !fFound && NT_SUCCESS(*pstatus) )
	    *pstatus = STATUS_BUFFER_ALL_ZEROS;

    return( fFound );

}   // CPropertySetStream::QueryPropertyNames



//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::SetPropertyNames
//
// Synopsis:    changes dictionary entry names associated with property ids.
//
// Arguments:   [cprop]         -- count of name to propid mappings to change
//              [apid]          -- array of property ids
//              [aposz]         -- array of pointers to the new names
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//
// Note:        Attempting to set a property name for a property that does not
//              exist in the property set is not an error.
//
//              Attempting to set a property name or property id that would
//		result in a duplicate name or property id causes the existing
//		entry(ies) to be replaced.
//+--------------------------------------------------------------------------

VOID
CPropertySetStream::SetPropertyNames(
    IN ULONG cprop,
    IN const PROPID *apid,
    IN OPTIONAL OLECHAR const * const aposz[],
    OUT NTSTATUS *pstatus )
{

    //  ------
    //  Locals
    //  ------

    DICTIONARY *pdy = NULL;
    ULONG cbDictOld = 0;            // Byte granular Old dictionary size
    ULONG cbDictOldD = 0;           // Dword granular Old dictionary size
    ULONG iprop = 0;
    ULONG i = 0;
    ULONG cDel, cAdd;
    LONG cbDel, cbAdd;          // Byte granular sizes
    LONG cbChangeD;             // Dword granular size
    ENTRY UNALIGNED *pent;
    BOOLEAN fDupPropid = FALSE;
    BOOLEAN fDupName = FALSE;
    BOOLEAN fDeleteByName = FALSE;
    BOOLEAN fDeleteAll = FALSE;
    VOID **appvNames = NULL;

    ULONG cbstm;
    ULONG oDictionary;
    ULONG cbTail;
    ULONG cbNewSize;

    //  ----------
    //  Initialize
    //  ----------

    *pstatus = STATUS_SUCCESS;

    DebugTrace(0, Dbg, (
        "SetPropertyNames(cprop=%x, apid=%x, apwsz=%x)\n",
        cprop,
        apid,
        aposz));

    PROPASSERT(_HasPropHeader());
    PROPASSERT(_IsMapped());
    PROPASSERT(PROPSET_BYTEORDER == _pph->wByteOrder);

    //  --------
    //  Validate
    //  --------

    // Verify that this propset is modifiable.
    if (IsReadOnlyPropertySet(_Flags, _State))
    {
        StatusAccessDenied(pstatus, "SetPropertyNames: deleted or read-only");
        goto Exit;
    }

    // Verify that none of the names are illegally long.

    if (aposz != NULL)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            PROPASSERT( IsOLECHARString( aposz[iprop], MAXULONG ));

            if (ocslen( aposz[iprop] ) > CCH_MAXPROPNAME)
            {
                StatusInvalidParameter(pstatus, "SetPropertyNames:  Name is too long" );
                goto Exit;
            }
        }
    }   // if (apwsz != NULL)

    //  ----------------------------------------------------------------
    //  If necessary, convert each of the caller-provided names:
    //  to Unicode (if the property set is Unicode) or Ansi (otherwise).
    //  ----------------------------------------------------------------

    // In the end, appvNames will have the names in the same codepage
    // as the property set.

    appvNames = (VOID **) aposz;
    if (appvNames != NULL)
    {
        // Do we need to convert the caller's names to Ansi?

        if( _CodePage != CP_WINUNICODE  // Property set is Ansi
            &&
            OLECHAR_IS_UNICODE )        // Caller's names are Unicode
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) newk(mtPropSetStream, NULL) char *[cprop];
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Ansi Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from Unicode to
            // the property set's codepage.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;
                appvNames[iprop] = NULL;
                _OLECHARToMultiByte( (OLECHAR*) aposz[iprop], (ULONG)-1, _CodePage,
                                     (CHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // if( _CodePage != CP_WINUNICODE ...

        // Or, do we need to convert the caller's names to Unicode?

        if( _CodePage == CP_WINUNICODE  // Property set is Unicode
            &&
            !OLECHAR_IS_UNICODE  )      // Caller's names are Ansi
        {
            // Allocate an array of cprop string pointers.

            appvNames = (VOID **) newk(mtPropSetStream, NULL) WCHAR *[cprop];
            if (appvNames == NULL)
            {
                StatusNoMemory(pstatus, "SetpropertyNames: Unicode Name Pointers");
                goto Exit;
            }
            RtlZeroMemory(appvNames, cprop * sizeof(appvNames[0]));

            // Convert the caller-provided property names from the system
            // default Ansi codepage to Unicode.

            for (iprop = 0; iprop < cprop; iprop++)
            {
                ULONG cb = 0;
                appvNames[iprop] = NULL;
                _OLECHARToWideChar( (OLECHAR*) aposz[iprop], (ULONG)-1, CP_ACP,
                                    (WCHAR**) &appvNames[iprop], &cb, pstatus );
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
            }
        }   // if( _CodePage == CP_WINUNICODE )
    }   // if (appvNames != NULL)
    

    //  -----------------------------------------------------
    //  Compute total size of entries to be modified or added
    //  -----------------------------------------------------

    cbAdd = 0;
    cAdd = 0;
    for (iprop = 0; iprop < cprop; iprop++)
    {
        // Did the caller give us no array of names?  If so, 
        // it means that the name for this PID is to be deleted.

        if (appvNames == NULL)
	{
            // If the PID is for the dictionary, then it must be the
            // only entry in apid, and it indicates that we're going to
            // delete all the names in the dictionary.

	    if (apid[iprop] == PID_DICTIONARY)
	    {
		if (cprop != 1)
		{
		    StatusInvalidParameter(pstatus, "SetPropertyNames: DeleteAll parms");
                    goto Exit;
		}
		fDeleteAll = TRUE;
	    }
        }

        // Otherwise, we're setting a new name for this PID.

	else
        {
            ULONG cbname;

            // Validate the caller-provided length.

            if (!_PropertyNameLength(appvNames[iprop], &cbname))
            {
                StatusInvalidParameter(pstatus, "SetPropertyNames: name length");
                goto Exit;
            }

            // See if this propid or name appears later in the array.

            for (i = iprop + 1; i < cprop; i++)
            {
                ULONG cbname2;

                if (apid[i] == apid[iprop])
                {
                    fDupPropid = TRUE;
                    break;
                }

                _PropertyNameLength(appvNames[i], &cbname2);

                if (cbname == cbname2 &&
                    _ComparePropertyNames(
                                appvNames[iprop],
                                appvNames[i],
                                TRUE, // Both names are in the same byte-order
                                cbname))
                {
                    fDupName = TRUE;
                    break;
                }
            }

            // If this propid appears only once or if it's the last instance,
            // count it.  If the property set is Unicode, include DWORD padding.

            if (i == cprop)
            {
                DebugTrace(0, Dbg, (
                    _CodePage == CP_WINUNICODE?
                        "Adding New Entry: propid=%lx  L'%ws'\n" :
                        "Adding New Entry: propid=%lx  '%s'\n",
                    apid[iprop],
                    appvNames[iprop]));

                cAdd++;

                cbAdd += CB_ENTRY + cbname;
                if( _CodePage == CP_WINUNICODE )
                {
                    cbAdd = DwordAlign( cbAdd );
                }
            }
        }
    }
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbAdd ) : TRUE );


    //  ---------------------------------------------
    //  Get the dictionary, creating it if necessary.
    //  ---------------------------------------------

    _SetModified();

    for (i = 0; ; i++)
    {
        PROPERTY_INFORMATION pinfo;
        PROPVARIANT var;

        pdy = (DICTIONARY *) _LoadProperty(PID_DICTIONARY, &cbDictOld, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (pdy != NULL)
        {
            break;
        }
        PROPASSERT(i == 0);
        if (cprop == 0 || appvNames == NULL)
        {
            // no dictionary and we are deleting or doing nothing -- return
            goto Exit;
        }
        // create dictionary if it doesn't exist
        DebugTrace(0, Dbg, ("Creating empty dictionary\n"));

        PROPASSERT(CB_SERIALIZEDPROPERTYVALUE == CB_DICTIONARY);
        pinfo.cbprop = CB_SERIALIZEDPROPERTYVALUE;
        pinfo.pid = PID_DICTIONARY;

        var.vt = VT_DICTIONARY;
        SetValue(1, &var, &pinfo, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        Validate(pstatus);     // Make sure dictionary was properly created
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
        DebugTrace(0, Dbg, ("Created empty dictionary\n"));

    }   // for (i = 0; ; i++)

    //  ----------------------------------------------------------------
    //  Compute total size of existing entries to be modified or deleted
    //  ----------------------------------------------------------------

    // Walk the dictionary looking for entries which are referenced
    // in the caller's 'apid' array or 'appvNames' array.

    cbDel = 0;
    cDel = 0;
    for (i = 0, pent = &pdy->rgEntry[0];
         i < PropByteSwap( pdy->cEntries );
         i++, pent = _NextDictionaryEntry( pent ))
    {
        DebugTrace(0, Dbg, (
            _CodePage == CP_WINUNICODE?
                "Dictionary Entry @%lx: propid=%lx L'%ws'\n" :
                "Dictionary Entry @%lx: propid=%lx '%s'\n",
            pent,
            PropByteSwap( ENTRY_GetPropid(pent) ),
            pent->sz ));

        // For this dictionary entry, walk the caller's
        // 'apid' and 'appvNames' arrays, looking for a match.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // If we get to the bottom of this 'for' loop,
            // then we know that we've found an entry to delete.
            // If fDeleteAll, or the PID in apid matches this
            // dictionary entry, then we can fall to the bottom.
            // Otherwise, the following 'if' block checks the
            // name in 'appvNames' against this dictionary entry.

            if (!fDeleteAll
                &&
                apid[iprop] != PropByteSwap( ENTRY_GetPropid(pent) ))
            {
                // The caller's PID didn't match this dictionary entry,
                // does the name?

                ULONG cbname;

                // If we have no names from the caller, then we obviously
                // don't have a match, and we can continue on to check this
                // dictionary entry against the next of the caller's PIDs.

                if (appvNames == NULL)
                {
                    continue;
                }

                // Or, if this name from the caller doesn't match this
                // dictionary entry, we again can continue on to check
                // the next of the caller's properties.

                _PropertyNameLength(appvNames[iprop], &cbname);
                if (cbname != CCh2CB( PropByteSwap( ENTRY_GetCch(pent) ))
                    ||
                    !_ComparePropertyNames(
                            appvNames[iprop],
                            ENTRY_GetSz(pent),
                            FALSE,  // appvNames & pent->sz may be dif endians.
                            cbname)
                   )
                {
                    continue;
                }
                fDeleteByName = TRUE;

            }   // if (!fDeleteAll ...

            // If we reach this point, we're going to delete this entry
            // in the dictionary.  So update cDel & cbDel.

            DebugTrace(0, Dbg, (
                "Deleting Entry (%s) @%lx: propid=%lx\n",
                fDeleteAll? "DeleteAll" :
                    apid[iprop] == PropByteSwap(ENTRY_GetPropid(pent))
                                ? "replace by propid"
                                : "replace by name",
                pent,
                PropByteSwap( ENTRY_GetPropid(pent) )));

            cDel++;
            cbDel += _DictionaryEntryLength( pent );

            // We don't need to continue through the caller's arrays,
            // we can move on to the next dictionary entry.

            break;

        }   // for (iprop = 0; iprop < cprop; iprop++)
    }   // for (i = 0, pent = &pdy->rgEntry[0]; ...

    PROPASSERT(pent == Add2Ptr(pdy, cbDictOld));
    PROPASSERT( _CodePage == CP_WINUNICODE ? IsDwordAligned( cbDel ) : TRUE );


    cbDictOldD = DwordAlign(cbDictOld);
    cbChangeD = DwordAlign(cbDictOld + cbAdd - cbDel) - cbDictOldD;

    cbstm = _oSection + _GetSectionHeader()->cbSection + _cbTail;
    oDictionary = _MapAddressToOffset(pdy);
    cbTail;

    cbTail = cbstm - (_oSection + oDictionary + cbDictOldD);

    //  --------------------------------------------------------
    //  Before we change anything, grow the stream if necessary.
    //  --------------------------------------------------------

    if (cbChangeD > 0)
    {
        DebugTrace(0, Dbg, (
            "SetSize(%x) dictionary grow\n", cbstm + cbChangeD));
        if (cbstm + cbChangeD > CBMAXPROPSETSTREAM)
        {
            StatusDiskFull(pstatus, "SetPropertyNames: 256k limit");
            goto Exit;
        }

        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // reload all pointers into mapped image:

        pdy = (DICTIONARY *) _MapOffsetToAddress(oDictionary);

        // move everything after the dictionary back by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailBack",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }

    //  -------------------------------------------------------------------
    //  Walk through the existing dictionary and compact unmodified entries
    //  toward the front.  New and modified entries will be appended later.
    //  -------------------------------------------------------------------

    VOID *pvSrc;
    VOID *pvDst;
    ULONG cbCopy;

    pvDst = pvSrc = pent = &pdy->rgEntry[0];
    cbCopy = 0;

    if (!fDeleteAll)
    {
        ULONG cb;

        for (i = 0; i < PropByteSwap(pdy->cEntries); i++)
        {
            for (iprop = 0; iprop < cprop; iprop++)
            {
                if( apid[iprop] == PropByteSwap(ENTRY_GetPropid(pent)) )
                {
                    break;
                }
                if (fDeleteByName)      // if deleting any properties by name
                {
                    ULONG cbname;

                    _PropertyNameLength(appvNames[iprop], &cbname);
                    if (cbname == CCh2CB( PropByteSwap( ENTRY_GetCch(pent) ))
                        &&
                        _ComparePropertyNames(
                                appvNames[iprop],
                                ENTRY_GetSz(pent),
                                FALSE,  // appvNames & pent->sz may be dif endians
                                cbname)
                       )
                    {
                        break;          // found an entry to be removed.
                    }
                }
            }   // for (iprop = 0; iprop < cprop; iprop++)

            cb = _DictionaryEntryLength( pent );
            pent = _NextDictionaryEntry( pent );

            if (iprop == cprop)     // keep the dictionary entry
            {
                cbCopy += cb;
            }
            else                    // remove the dictionary entry
            {
                if (cbCopy != 0)
                {
                    if (pvSrc != pvDst)
                    {
                        PropMoveMemory(
                            "SetPropertyNames:Compact",
                            _GetSectionHeader(),
                            pvDst,
                            pvSrc,
                            cbCopy);
                    }
                    pvDst = Add2Ptr(pvDst, cbCopy);
                    cbCopy = 0;
                }
                pvSrc = pent;
            }
        }   // for (i = 0; i < PropByteSwap(pdy->cEntries); i++)

        // Compact last chunk and point past compacted entries.

        if (cbCopy != 0 && pvSrc != pvDst)
        {
            PropMoveMemory(
                "SetPropertyNames:CompactLast",
                _GetSectionHeader(),
                pvDst,
                pvSrc,
                cbCopy);
        }
        pent = (ENTRY UNALIGNED *) Add2Ptr(pvDst, cbCopy);

    }   // if (!fDeleteAll)

    pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) - cDel );

    //  ------------------------------------
    //  Append new and modified entries now.
    //  ------------------------------------

    if (appvNames != NULL)
    {
        // Add each name to the property set.

        for (iprop = 0; iprop < cprop; iprop++)
        {
            // See if this propid appears later in the array.

            i = cprop;
            if (fDupPropid)
            {
                for (i = iprop + 1; i < cprop; i++)
                {
                    if (apid[i] == apid[iprop])
                    {
                        break;
                    }
                }
            }

            // See if this name appears later in the array.

            if (i == cprop && fDupName)
            {
                ULONG cbname;

                _PropertyNameLength(appvNames[iprop], &cbname);

                for (i = iprop + 1; i < cprop; i++)
                {
                    ULONG cbname2;

                    _PropertyNameLength(appvNames[i], &cbname2);

                    if (cbname == cbname2 &&
                        _ComparePropertyNames(
                            appvNames[iprop],
                            appvNames[i],
                            TRUE,   // Both names are the same endian
                            cbname))
                    {
                        break;
                    }
                }
            }

            // If this propid appears only once or if it's the last instance,
            // append the mapping entry.

            if (i == cprop)
            {
                ULONG cbname;

                // Set the PID & character-count fields for this entry.
                _PropertyNameLength(appvNames[iprop], &cbname);
                ENTRY_SetPropid(pent, PropByteSwap( apid[iprop] ) );
                ENTRY_SetCch(pent, PropByteSwap( CB2CCh( cbname ) ) );

                // Copy the name into the dictionary.
                RtlCopyMemory(ENTRY_GetSz(pent), appvNames[iprop], cbname);

                // If this is a Unicode property set, we need to correct
                // the byte-order.

                if( CP_WINUNICODE == _CodePage )
                {
                    PBSBuffer( ENTRY_GetSz(pent), cbname, sizeof(WCHAR) );
                }

                // Zero-out the pad bytes.

		RtlZeroMemory(
			Add2Ptr(pent->sz, cbname),
			DwordRemain((ULONG) pent->sz + cbname));
                
                pent = _NextDictionaryEntry( pent );
            }
        }   // for (iprop = 0; iprop < cprop; iprop++)

        // We've added all the names, now let's update the entry count.
        pdy->cEntries = PropByteSwap( PropByteSwap(pdy->cEntries) + cAdd );

    }   // if (appvNames != NULL)

    // Zero the possible partial DWORD at the end of the dictionary.

    {
        ULONG cb = (ULONG) ((BYTE *) pent - (BYTE *) pdy);
        PROPASSERT(DwordAlign(cb) == cbDictOldD + cbChangeD);
        RtlZeroMemory(pent, DwordRemain(cb));
    }


    //  -----------------------------------------------------
    //  Adjust the remaining property offsets in the section.
    //  -----------------------------------------------------

    PROPERTYIDOFFSET *ppo, *ppoMax;
    PROPERTYSECTIONHEADER *psh;

    psh = _LoadPropertyOffsetPointers(&ppo, &ppoMax, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;
    PROPASSERT(psh != NULL);

    // Don't rely on the dictionary being the first property.
    // Skip PID_DICTIONARY and adjust every other higher entry.

    for ( ; ppo < ppoMax; ppo++)
    {
        if (ppo->dwOffset > oDictionary)
        {
            ppo->dwOffset += cbChangeD;
            PROPASSERT(ppo->propid != PID_DICTIONARY);
        }
    }

    // Update the size of the section
    psh->cbSection += cbChangeD;

    if (cbChangeD < 0)
    {
        // move everything after the dictionary forward by cbChangeD bytes.

        PropMoveMemory(
            "SetPropertyNames:TailUp",
            _GetSectionHeader(),
            Add2Ptr(pdy, cbDictOldD + cbChangeD),
            Add2Ptr(pdy, cbDictOldD),
            cbTail);
    }
    if (_cbTail != 0)
    {
	_PatchSectionOffsets(cbChangeD);
    }

    // If we need to shrink the stream or if we are cleaning up after a
    // previous shrink that failed, do it last.

    cbNewSize = _MSTM(GetSize)(pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if ( cbNewSize != cbstm + cbChangeD)
    {
        DebugTrace(0, Dbg, (
            "SetSize(%x) dictionary shrink\n",
            cbstm + cbChangeD));
        _MSTM(SetSize)(cbstm + cbChangeD, TRUE, (VOID **) &_pph, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;
    }

    //  ----
    //  Exit
    //  ----

Exit:

    // If we had to convert the array of names into a different
    // codepage, delete those temporary buffers now.

    if (appvNames != NULL && appvNames != (VOID **) aposz)
    {
        for (iprop = 0; iprop < cprop; iprop++)
        {
            _pma->Free( appvNames[iprop] );
        }
        delete [] (char **) appvNames;
    }

    DebugTrace(0, Dbg, ("SetPropertyNames() ==> s=%x\n", STATUS_SUCCESS));
    return;
}


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateStructure
//
// Synopsis:    validate property set structure
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateStructure(OUT NTSTATUS *pstatus)
{
    PROPID propid;
    ULONG cb;

    OLECHAR aocName[ CCH_MAXPROPNAMESZ];
    ULONG cbName;

    *pstatus = STATUS_SUCCESS;

    // Walk through properties to make sure all properties are consistent
    // and are contained within the section size.  A NULL return value
    // means _LoadProperty walked the entire section, so we can quit then.

    for (propid = PID_CODEPAGE; propid != PID_ILLEGAL; propid++)
    {
        SERIALIZEDPROPERTYVALUE const *pprop;

        pprop = GetValue(propid, &cb, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if (NULL == pprop)
        {
            break;
        }
    }

    // Walk through dictionary entries to make sure all entries are consistent
    // and are contained within the dictionary size.  A FALSE return value
    // means QueryPropertyNameBuf walked the entire dictionary, so quit then.

    for (propid = PID_CODEPAGE + 1; propid != PID_ILLEGAL; propid++)
    {
        BOOL fExists;
        cb = 0;

        cbName = sizeof(aocName);
        fExists = QueryPropertyNameBuf(propid, aocName, &cbName, pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        if( !fExists )
        {
            break;
        }
    }

    if (_cSection > 1)
    {
	FORMATIDOFFSET const *pfo;

	if (_cSection != 2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: csection(%x) != 2",
		_cSection));
	    StatusCorruption(pstatus, "_ValidateStructure: csection != 2");
            goto Exit;
	}
	pfo = _GetFormatidOffset(0);
	if (pfo->fmtid != guidDocumentSummary)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[0] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[0] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[0] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[0]");
            goto Exit;
	}

	pfo = _GetFormatidOffset(1);
	if (pfo->fmtid != guidDocumentSummarySection2)
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: DocumentSummary[1] fmtid"));
	    StatusCorruption(pstatus, "_ValidateStructure: DocumentSummary[1] fmtid");
            goto Exit;
	}
	if (!IsDwordAligned(pfo->dwOffset))
	{
	    DebugTrace(0, DEBTRACE_ERROR, (
		"_ValidateStructure: dwOffset[1] = %x",
		pfo->dwOffset));
	    StatusCorruption(pstatus, "_ValidateStructure: dwOffset[1]");
            goto Exit;
	}
    }   // if (_cSection > 1)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnPropidCompare
//
// Synopsis:    qsort helper to compare propids in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
INT __cdecl
fnPropidCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->propid -
           ((PROPERTYIDOFFSET const *) ppo2)->propid);
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnOffsetCompare
//
// Synopsis:    qsort helper to compare offsets in a PROPERTYIDOFFSET array.
//
// Arguments:   [ppo1]          -- pointer to PROPERTYIDOFFSET 1
//              [ppo2]          -- pointer to PROPERTYIDOFFSET 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

INT __cdecl
fnOffsetCompare(VOID const *ppo1, VOID const *ppo2)
{
    return(((PROPERTYIDOFFSET const *) ppo1)->dwOffset -
           ((PROPERTYIDOFFSET const *) ppo2)->dwOffset);
}


//+--------------------------------------------------------------------------
// Member:      GetStringLength
//
// Synopsis:    return length of possibly unicode string.
//
// Arguments:   [CodePage]   -- TRUE if string is Unicode
//              [pwsz]       -- pointer to string
//              [cb]         -- MAXULONG or string length with L'\0' or '\0'
//
// Returns:     length of string in bytes including trailing L'\0' or '\0'
//+--------------------------------------------------------------------------

ULONG
GetStringLength(
    IN USHORT CodePage,
    IN WCHAR const *pwsz,
    IN ULONG cb)
{
    ULONG i;

    if (CodePage == CP_WINUNICODE)
    {
        for (i = 0; i < cb/sizeof(WCHAR); i++)
        {
            if (pwsz[i] == L'\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(WCHAR));
        return((i + 1) * sizeof(WCHAR));
    }
    else
    {
        char *psz = (char *) pwsz;

        for (i = 0; i < cb; i++)
        {
            if (psz[i] == '\0')
            {
                break;
            }
        }
        PROPASSERT(cb == MAXULONG || cb == (i + 1) * sizeof(char));
        return((i + 1) * sizeof(char));
    }
}

//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateProperties
//
// Synopsis:    validate properties
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateProperties(OUT NTSTATUS *pstatus) const
{
    PROPERTYIDOFFSET *apo = NULL;
    PROPERTYSECTIONHEADER const *psh = _GetSectionHeader();
    static ULONG cValidate = 0;
    ULONG cbwasted = 0;
    ULONG cbtotal = 0;

    *pstatus = STATUS_SUCCESS;

    cValidate++;
    DebugTrace(0, DEBTRACE_PROPVALIDATE, (
	"_ValidateProperties(%x ppsstm=%x state=%x pph=%x)\n",
	cValidate,
	this,
	_State,
	_pph));

    if (psh->cProperties != 0)
    {
        PROPERTYIDOFFSET *ppo, *ppoMax;

        apo = newk(mtPropSetStream, NULL) PROPERTYIDOFFSET[psh->cProperties + 1];
        if (apo == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        RtlCopyMemory(
                apo,
                psh->rgprop,
                psh->cProperties * CB_PROPERTYIDOFFSET);

        ppoMax = apo + psh->cProperties;
        ppoMax->propid = PID_ILLEGAL;
        ppoMax->dwOffset = psh->cbSection;

        // Sort by property id and check for duplicate propids:

        qsort(apo, psh->cProperties, sizeof(apo[0]), fnPropidCompare);

        for (ppo = apo; ppo < ppoMax; ppo++)
        {
            if (ppo->propid == PID_ILLEGAL ||
                ppo->propid == ppo[1].propid)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateProperties(bad propid=%x @%x)\n",
                    ppo->propid,
                    ppo->dwOffset));
                StatusCorruption(pstatus, "_ValidateProperties: bad or dup propid");
                goto Exit;
            }
        }

        // Sort by offset and check for overlapping values:

        qsort(apo, psh->cProperties, sizeof(apo[0]), fnOffsetCompare);

        cbtotal = _oSection;
        for (ppo = apo; ppo < ppoMax; ppo++)
        {
	    ULONG cbdiff, cbprop, cbpropraw;
	    SERIALIZEDPROPERTYVALUE const *pprop;

	    cbprop = MAXULONG;
	    cbpropraw = cbprop;
	    cbdiff = ppo[1].dwOffset - ppo->dwOffset;
            if (IsDwordAligned(ppo->dwOffset) &&
                IsDwordAligned(ppo[1].dwOffset))
            {
                pprop = (SERIALIZEDPROPERTYVALUE const *)
                            _MapOffsetToAddress(ppo->dwOffset);

                if (ppo->propid == PID_DICTIONARY)
                {
                    cbprop = _DictionaryLength(
                                    (DICTIONARY const *) pprop,
                                    cbdiff,
                                    pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    cbpropraw = cbprop;
		    cbprop = DwordAlign(cbprop);
                }
		else
		{
		    cbprop = PropertyLength(pprop, cbdiff, 0, pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    cbpropraw = cbprop;
		}
		DebugTrace(0, DEBTRACE_PROPVALIDATE, (
		    "_ValidateProperties(%x) i=%x cb=%x/%x/%x @%x/%x pid=%x\n",
		    cValidate,
		    ppo - apo,
		    cbprop,
		    cbdiff,
		    ppo->dwOffset,
		    pprop,
		    ppo->propid));
                cbtotal += cbdiff;

                // Technically, the OLE spec allows extra unused space
                // between properties, but this implementation never
                // writes out streams with space between properties.

                if (cbdiff == cbprop)
                {
                    continue;
                }
            }
            DebugTrace(0, DEBTRACE_ERROR, (
                "_ValidateProperties(bad value length: propid=%x @%x/%x cb=%x/%x/%x ppsstm=%x)\n",
                ppo->propid,
                ppo->dwOffset,
		pprop,
		cbpropraw,
		cbprop,
		cbdiff,
		this));
            StatusCorruption(pstatus, "_ValidateProperties: bad property length");
            goto Exit;

        }   // for (ppo = apo; ppo < ppoMax; ppo++)

    }   // if (psh->cProperties != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    delete [] apo;

    DebugTrace(0, cbwasted != 0? 0 : Dbg, (
        "_ValidateProperties(wasted %x bytes, total=%x)\n",
        cbwasted,
        cbtotal));

}
#endif


#if DBGPROP
typedef struct tagENTRYVALIDATE         // ev
{
    ENTRY UNALIGNED const *pent;
    CPropertySetStream const *ppsstm;
} ENTRYVALIDATE;
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryPropidCompare
//
// Synopsis:    qsort helper to compare propids in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
INT __cdecl
fnEntryPropidCompare(VOID const *pev1, VOID const *pev2)
{
    return( ENTRY_GetPropid( ((ENTRYVALIDATE const *) pev1)->pent) -
            ENTRY_GetPropid( ((ENTRYVALIDATE const *) pev2)->pent) );
}
#endif


//+--------------------------------------------------------------------------
// Member:      fnEntryNameCompare
//
// Synopsis:    qsort helper to compare names in a ENTRYVALIDATE array.
//
// Arguments:   [pev1]          -- pointer to ENTRYVALIDATE 1
//              [pev2]          -- pointer to ENTRYVALIDATE 2
//
// Returns:     difference
//+--------------------------------------------------------------------------

#if DBGPROP
INT __cdecl
fnEntryNameCompare(VOID const *pev1, VOID const *pev2)
{
    ENTRY UNALIGNED const *pent1;
    ENTRY UNALIGNED const *pent2;
    INT rc;

    pent1 = ((ENTRYVALIDATE const *) pev1)->pent;
    pent2 = ((ENTRYVALIDATE const *) pev2)->pent;

    rc = PropByteSwap(ENTRY_GetCch(pent1)) - PropByteSwap(ENTRY_GetCch(pent2));
    if (rc == 0)
    {
        rc = !((ENTRYVALIDATE const *) pev1)->ppsstm->_ComparePropertyNames(
                    ENTRY_GetSz(pent1),
                    ENTRY_GetSz(pent2),
                    TRUE,       // Both names have the same byte-order
                    ( (ENTRYVALIDATE const *)
                      pev1
                    )->ppsstm->CCh2CB(PropByteSwap( ENTRY_GetCch(pent1))));
    }
    return(rc);
}
#endif


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::_ValidateDictionary
//
// Synopsis:    validate property set dictionary
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP
VOID
CPropertySetStream::_ValidateDictionary(OUT NTSTATUS *pstatus)
{
    DICTIONARY const *pdy;
    ULONG cbDict;               // BYTE granular size!

    ENTRYVALIDATE *aev = NULL;
    ENTRYVALIDATE *pev, *pevMax;
    PROPERTYSECTIONHEADER const *psh;
    ENTRY UNALIGNED const *pent;
    ENTRY entMax;
    VOID const *pvDictEnd;

    *pstatus = STATUS_SUCCESS;

    pdy = (DICTIONARY const *) _LoadProperty(PID_DICTIONARY, &cbDict, pstatus);
    if( !NT_SUCCESS(*pstatus) ) goto Exit;

    if (pdy != NULL && PropByteSwap(pdy->cEntries) != 0)
    {
        aev = newk (mtPropSetStream, NULL)
                   ENTRYVALIDATE[ PropByteSwap(pdy->cEntries) + 1 ];
        if (aev == NULL)
        {
            *pstatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        psh = _GetSectionHeader();
        pent = pdy->rgEntry;
        pvDictEnd = Add2ConstPtr(pdy, cbDict);
        pevMax = aev + PropByteSwap( pdy->cEntries );

        for (pev = aev; pev < pevMax; pev++)
        {
            ULONG cb = _DictionaryEntryLength( pent );

            if (Add2ConstPtr(pent, cb) > pvDictEnd)
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad entry size for propid=%x)\n",
                    PropByteSwap( ENTRY_GetPropid(pev->pent) )));
                StatusCorruption(pstatus, "ValidateDictionary: entry size");
                goto Exit;
            }
            pev->pent = pent;
            pev->ppsstm = this;

#if DBGPROP
#if LITTLEENDIAN
            if (_CodePage == CP_WINUNICODE)
            {
                PROPASSERT(IsUnicodeString((WCHAR const *) ENTRY_GetSz(pent),
                                            CCh2CB(PropByteSwap(ENTRY_GetCch(pent) ))));
            }
            else
            {
                PROPASSERT(IsAnsiString((char const *) ENTRY_GetSz(pent),
                                        CCh2CB( PropByteSwap(ENTRY_GetCch(pent) ))));
            }
#endif //  LITTLEENDIAN
#endif //  DBGPROP

            pent = _NextDictionaryEntry( pent );
        }
        if ((VOID const *) pent != pvDictEnd)
        {
            StatusCorruption(pstatus, "ValidateDictionary: end offset");
            goto Exit;
        }
        entMax.cch = 0;
        entMax.propid = PID_ILLEGAL;
        pevMax->pent = &entMax;
        pevMax->ppsstm = this;

        // Sort by property id and check for duplicate propids:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), fnEntryPropidCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if (PID_ILLEGAL == PropByteSwap( ENTRY_GetPropid(pev->pent))
                ||
                PropByteSwap( ENTRY_GetPropid(pev[1].pent) ) 
                == PropByteSwap( ENTRY_GetPropid(pev->pent) ))
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad propid=%x)\n",
                    PropByteSwap( ENTRY_GetPropid(pev->pent) )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup propid");
                goto Exit;
            }
        }

        // Sort by property name and check for duplicate names:

        qsort(aev, PropByteSwap(pdy->cEntries), sizeof(aev[0]), fnEntryNameCompare);

        for (pev = aev; pev < pevMax; pev++)
        {
            if ( ENTRY_GetCch(pev->pent) == 0
                ||
                ( ENTRY_GetCch(pev->pent) == ENTRY_GetCch(pev[1].pent)
                  &&
                  _ComparePropertyNames(
                         ENTRY_GetSz(pev->pent),
                         ENTRY_GetSz(pev[1].pent),
                         TRUE,              // Names are the same byte-order
                         CCh2CB(PropByteSwap(ENTRY_GetCch(pev->pent))))
                )
               )
            {
                DebugTrace(0, DEBTRACE_ERROR, (
                    "_ValidateDictionary(bad name for propid=%x)\n",
                    PropByteSwap( ENTRY_GetPropid(pev->pent) )));
                StatusCorruption(pstatus, "_ValidateDictionary: bad or dup name");
                goto Exit;
            }
        }   // for (pev = aev; pev < pevMax; pev++)
    }   // if (pdy != NULL && pdy->cEntries != 0)

    //  ----
    //  Exit
    //  ----

Exit:

    delete [] aev;

}
#endif  // DBGPROP


//+--------------------------------------------------------------------------
// Member:      CPropertySetStream::Validate
//
// Synopsis:    validate entire property stream
//
// Arguments:   [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     None
//+--------------------------------------------------------------------------

#if DBGPROP

BOOLEAN fValidatePropSets = KERNELSELECT(DBG, TRUE);

VOID
CPropertySetStream::Validate(OUT NTSTATUS *pstatus)
{
    if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)
    {
        ULONG cbstm = _MSTM(GetSize)(pstatus);
        if( !NT_SUCCESS(*pstatus) ) goto Exit;

        // Walk through section headers to make sure all sections are contained
        // within the stream size.

        if (_ComputeMinimumSize(cbstm, pstatus) != 0)
        {
            // If an error had occurred in the above call,
            // it would have returned zero.

            _ValidateStructure( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateProperties( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ValidateDictionary( pstatus );
            if( !NT_SUCCESS(*pstatus) ) goto Exit;

            _ComputeMinimumSize(cbstm, pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
        }
    }   // if (fValidatePropSets && (_State & CPSS_USERDEFINEDDELETED) == 0)

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       pch.cxx
//
//  Contents:   Precompiled header includes.
//
//--------------------------------------------------------------------------
#include "olechar.h"

#include "h/windef.h"

#include "h/propset.hxx"    // for PROPID_CODEPAGE
#include "h/propapi.h"

#include "../h/propstm.hxx"  // Declaration for CMappedStream i/f that
                        // is used to let the ntdll implementation of
                        // OLE properties access the underlying stream data.


#include "../h/msf.hxx"
#include "../expdf.hxx"
#include "../expst.hxx"

#include "psetstg.hxx"  // CPropertySetStorage which implements
                        // IPropertySetStorage for docfile

#include "utils.hxx"



#include "propstg.hxx"

#include "propdbg.hxx"

#include "h/propmac.hxx"
#include "h/propvar.hxx"

extern WCHAR const wcsContents[];
extern const GUID GUID_NULL;

#define DFMAXPROPSETSIZE (256*1024)

#if DBG
#define DfpVerify(x) { BOOL f=x; GetLastError(); DfpAssert(f);}
#else
#define DfpVerify(x) x
#endif

#ifndef STG_E_PROPSETMISMATCHED
#define STG_E_PROPSETMISMATCHED 0x800300F0
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\qsort.h ===
/* qsort routine */
/* we have this routine because apparently some version of the 
   standard libraries don't work, possibly because REF passes
   in unaligned pointers */
#ifdef __cplusplus
extern "C" { 
#endif  
void ref_qsort (
   void *base,
   unsigned num,
   unsigned width,
   int (*comp)(const void *, const void *)
);
#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\propstg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       propstg.cxx
//
//  Contents:   Class that directly implements IPropertyStorage
//
//  Classes:    CCoTaskAllocator
//              CPropertyStorage
//
//  Notes:      For methods that state 'if successful returns S_OK,
//              otherwise error code', the possible error codes include:
//
//                  STG_E_INVALIDHANDLE
//                  STG_E_INSUFFICIENTMEMORY
//                  STG_E_MEDIUMFULL
//                  STG_E_REVERTED
//                  STG_E_INVALIDPARAMETER                  
//                  STG_E_INVALIDFLAG
//
//--------------------------------------------------------------------------

#include "pch.cxx"

DECLARE_INFOLEVEL(prop, DEB_ERROR)
 
//+-------------------------------------------------------------------
//
//  Member:     CCoTaskAllocator::Allocate, Free.
//
//  Synopsis:   Allocation routines called by RtlQueryProperties.
//
//  Notes:
//
//--------------------------------------------------------------------

CCoTaskAllocator g_CoTaskAllocator;

void *
CCoTaskAllocator::Allocate(ULONG cbSize)
{
    return(CoTaskMemAlloc(cbSize));
}

void
CCoTaskAllocator::Free(void *pv)
{
    CoTaskMemFree(pv);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CPropertyStorage
//
//  Synopsis:   Constructor used to create a property storage on disk.
//
//  Arguments:  [pstg] -- storage object to be parent
//              [rfmtid] -- format id for new property set.
//              [pclsid] -- pointer to class id
//              [grfFlags] -- flags
//              [grfMode] -- mode
//              [phr] -- HRESULT assumed to be STG_E_INSUFFICIENTMEMORY
//                       on entry. Will be HRESULT reflecting result on exit.
//              
//  Notes:      Get a CPropertySetStream initialized with the correct
//              type of map (i.e. docfile or native.)
//              If non-simple mode, create a storage with name derived
//              from rfmtid and then a contents sub-stream.
//              If simple mode, create a stream of a name derived from
//              rfmtid.
//
//              Does not clean up on failure: this is done by the
//              destructor.
//
//--------------------------------------------------------------------

CPropertyStorage::CPropertyStorage(
                IPrivateStorage *pprivstg,
                REFFMTID      rfmtid,
                const CLSID   *pclsid,
                DWORD         grfFlags,
                DWORD         grfMode,
                HRESULT       *phr)
{
    HRESULT & hr = *phr;
    CPropSetName psn(rfmtid);  // acts as Probe(&rfmtid, sizeof(rfmtid));
    BOOL fCreated = FALSE;
    IStorage *pstg = pprivstg->GetStorage();

    Initialize();

    if (grfFlags & PROPSETFLAG_NONSIMPLE)
    {
        hr = STG_E_UNIMPLEMENTEDFUNCTION;
        PROPASSERT(FALSE && "Unsupported function in reference called!\n" );
        return;                        
    }

    if (grfFlags & ~PROPSETFLAG_ANSI)
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    // check for any mode flags disallowed in Create.
    if (grfMode & (STGM_PRIORITY | STGM_CONVERT |
                   STGM_SIMPLE | STGM_DELETEONRELEASE))
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    _grfFlags = grfFlags;
    _grfAccess = 3 & grfMode;
    _grfShare = 0xF0 & grfMode;

    // Is this the special-case second-section property set?
    _fUserDefinedProperties = ( rfmtid == FMTID_UserDefinedProperties ) ? TRUE : FALSE;

    if (_grfAccess != STGM_READWRITE)
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    if (_grfFlags & PROPSETFLAG_ANSI)
    {
        _usCodePage = GetACP();
    }

    int i=0;
    while (i<=1)
    {
        // Create the property set stream in pstg.
        // The second section of the DocumentSummaryInformation Property Set
        // is a special-case.
        
        if( IsEqualGUID( rfmtid, FMTID_UserDefinedProperties ))
        {
            hr = _CreateDocumentSummary2Stream( pstg, psn, grfMode, &fCreated );
        }
        else
        {
            hr = pstg->CreateStream(psn.GetPropSetName(), grfMode, 0, 0, &_pstmPropSet);
            if( hr == S_OK )
                fCreated = TRUE;
        }
        
        if (hr == S_OK)
        {
            break;
        }
        else
        {
            PropDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::CPropertyStorage"
                     " - CreateStream(%ls) attempt %d, hr=%08X\n", this, psn.GetPropSetName(), i+1, hr));
            
            
            if (hr != STG_E_FILEALREADYEXISTS)
            {
                break;
            }
            else
                if (i == 0 && (grfMode & STGM_CREATE) == STGM_CREATE)
                {
                    pstg->DestroyElement(psn.GetPropSetName());
                }
        } // if (hr == S_OK) ... else
        
        i++;
    }

    if (hr == S_OK)
    {
        hr = InitializePropertyStream(CREATEPROP_CREATE,
                                      &rfmtid,
                                      pclsid);
    }

    if (hr != S_OK && fCreated)
    {
        //
        // if we fail after creating the property set in storage, cleanup.
        // 
        pstg->DestroyElement(psn.GetPropSetName());
    }

}



//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_CreateDocumentSummary2Stream
//
//  Synopsis:   Open the "DocumentSummaryInformation" stream, creating
//              it if necessary.
//
//  Arguments:  [pstg] -- container storage
//              [psn] -- the property set name
//              [grfMode] -- mode of the property set
//              [fCreated] -- TRUE if Stream is created, FALSE if opened.
//
//  Notes:      This special case is necessary because this property set
//              is the only one in which we support more than one section.
//              For this property set, if the caller Creates the second
//              Section, we must not *Create* the Stream, because that would
//              lost the first Section.  So, we must open it.
//
//              This routine is only called when creating the second
//              Section.  The first Section is created normally (note
//              that if the client creates the first section, the second
//              section is lost).
//
//              Also note that it may not be possible to open the Stream,
//              since it may already be opened.  This is significant
//              because it may not be obvious to the caller.  I.e.,
//              to a client of IPropertyStorage, the 2 sections are
//              distinct property sets, and you would think that you could
//              open them for simultaneous write.
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::_CreateDocumentSummary2Stream( IStorage *      pstg,
                                                 CPropSetName &  psn,
                                                 DWORD           grfMode,
                                                 BOOL *          pfCreated )
{

    HRESULT hr;
    DWORD   grfOpenMode = grfMode & ~(STGM_CREATE | STGM_CONVERT);

    *pfCreated = FALSE;

    hr = pstg->OpenStream( psn.GetPropSetName(), NULL, grfOpenMode, 0L, &_pstmPropSet );

    // If the file wasn't there, try a create.

    if( hr == STG_E_FILENOTFOUND )
    {
        hr = pstg->CreateStream(psn.GetPropSetName(), grfMode, 0, 0, &_pstmPropSet);

        if( SUCCEEDED( hr ))
        {
            *pfCreated = TRUE;
        }
    }

    return( hr );

} // CPropertyStorage::_CreateDocumentSummary2Stream()




//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::CPropertyStorage
//
//  Synopsis:   Constructor used to open a property storage on disk.
//
//  Arguments:  [pstg] -- container storage
//              [rfmtid] -- FMTID of property set to open
//              [grfMode] -- mode of the property set
//              [fDelete] -- Delete this property set from its stream
//              [phr] -- HRESULT returned here.
//
//  Notes:      Does not clean up on failure: this is done by the
//              destructor.
//
//--------------------------------------------------------------------

CPropertyStorage::CPropertyStorage(
                IPrivateStorage *pprivstg,
                REFFMTID  rfmtid,
                DWORD     grfMode,
                BOOL      fDelete,
                HRESULT  *phr)
{
    HRESULT &hr = *phr;
    CPropSetName psn(rfmtid);
    IStorage *pstgParent;
    IStorage *pstg = pprivstg->GetStorage();
    USHORT createprop = 0L;

    Initialize();

    _grfAccess = 3 & grfMode;
    _grfShare = 0xF0 & grfMode;

    // Is this the special-case second-section property set?
    _fUserDefinedProperties = ( rfmtid == FMTID_UserDefinedProperties ) ? TRUE : FALSE;

    // check for any mode flags disallowed in Open.
    if (grfMode & (STGM_CREATE | STGM_PRIORITY | STGM_CONVERT | STGM_TRANSACTED | 
                   STGM_SIMPLE | STGM_DELETEONRELEASE))
    {
        hr = STG_E_INVALIDFLAG;
        return;
    }

    hr = pstg->OpenStream(psn.GetPropSetName(), NULL, _grfAccess | _grfShare,
            0, &_pstmPropSet);

    if (hr == S_OK)
    {
        pstgParent = pstg;
    }


    // Determine the CREATEPROP flags.
    if( fDelete )
    {
        createprop = CREATEPROP_DELETE;
    }
    else
    {
        createprop = (S_OK == IsWriteable() ? 
                      CREATEPROP_WRITE : CREATEPROP_READ);
    }

    if (hr == S_OK)
    {
        // sets up _usCodePage
        hr = InitializePropertyStream(
                createprop,
                &rfmtid,
                NULL);

    }

}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Initialize
//
//  Synopsis:   Initialize members to known values.
//
//--------------------------------------------------------------------

VOID CPropertyStorage::Initialize(VOID)
{
    _ulSig = PROPERTYSTORAGE_SIG;
    _cRefs = 1;
    _pstgPropSet = NULL;
    _pstmPropSet = NULL;
    _dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;
    _np = NULL;
    _ms = NULL;
    _usCodePage = CP_WINUNICODE;
    _grfFlags = 0;
    _grfAccess = 0;
    _grfShare = 0;
    _fUserDefinedProperties = FALSE;

}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::InitializePropertyStream.
//
//  Synopsis:   Initialize the storage-type specific members.
//
//  Arguments:  [Flags] -- Flags for RtlCreatePropertySet: CREATEPROP_*
//              [pguid] -- FMTID, in for create only.
//              [pclsid] -- Class id, in for create only.
//                              
//  Returns:    HRESULT
//
//  Requires:
//              _pstmPropSet -- The IStream of the main property set stream.
//
//  Modifies:   _ms         (NTMAPPEDSTREAM) 
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//                          if _fNative, then _ms is CNtMappedStream*
//                          if !_fNative, then _ms is CMappedStream* of CExposedStream
//
//              _np         (NTPROP)         aka CPropertySetStream
//
//                          (assumed NULL on entry) will be NULL or valid on exit
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT
CPropertyStorage::InitializePropertyStream(
    USHORT Flags,
    const GUID *pguid,
    GUID const *pclsid)
{
    HRESULT hr;

    CExposedStream *pexpstm = (CExposedStream*)_pstmPropSet;
    PROPASSERT(pexpstm->Validate() != STG_E_INVALIDHANDLE );
    _ms =  (CMappedStream*)pexpstm;
    hr = S_OK;
    PropDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::InitializePropertyStream"
             " - using CExposedDocfile as CMappedStream\n", this));

    NTSTATUS Status;
    
    Status = RtlCreatePropertySet(
        _ms,
        Flags,
        pguid,
        pclsid,
        (NTMEMORYALLOCATOR) & g_CoTaskAllocator,
        GetUserDefaultLCID(),
        &_dwOSVersion,
        &_usCodePage,
        &_np);
    
    if (!NT_SUCCESS(Status))
    {
        PropDbg((DEB_PROP_TRACE_CREATE, "CPropertyStorage(%08X)::InitializePropertyStream"
                 " - RtlCreatePropertySet Status=%08X\n", this, Status));
    }
    
    if (NT_SUCCESS(Status))
    {
            if (_usCodePage != CP_WINUNICODE)
                _grfFlags |= PROPSETFLAG_ANSI; // for Stat
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }
    

    return(hr);
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::~CPropertyStorage
//
//  Synopsis:   Free up object resources.
//
//  Notes:      Cleans up even from partial construction.
//
//--------------------------------------------------------------------

CPropertyStorage::~CPropertyStorage()
{
    _ulSig = PROPERTYSTORAGE_SIGDEL; // prevent someone else deleting it

    if (_np != NULL)
    {
//        RtlFlushPropertySet(_np);
        RtlClosePropertySet(_np);
    }

    if (_pstmPropSet != NULL)
        _pstmPropSet->Release();

    if (_pstgPropSet != NULL)
        _pstgPropSet->Release();

}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//  Notes:      IPropertyStorage supports IPropertyStorage and IUnknown
//
//--------------------------------------------------------------------


HRESULT CPropertyStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = ValidateRef()))
        return(hr);

    // Validate the inputs

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----------------
    //  Perform the Query
    //  -----------------

    *ppvObject = NULL;

    if (IsEqualIID(riid,IID_IPropertyStorage) || IsEqualIID(riid,IID_IUnknown))
    {
        *ppvObject = (IPropertyStorage *)this;
        CPropertyStorage::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }

    return(hr);
}

ULONG   CPropertyStorage::AddRef(void)
{
    if (S_OK != ValidateRef())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

ULONG   CPropertyStorage::Release(void)
{
    LONG lRet;

    if (S_OK != ValidateRef())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;    // this will do a flush if dirty
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadMultiple
//
//  Synopsis:   Read properties from the property set.
//
//  Arguments:  [cpspec] -- Count of PROPSPECs in [rgpspec]
//              [rgpspec] -- Array of PROPSPECs
//              [rgpropvar] -- Array of PROPVARIANTs to be filled in
//                             with callee allocated data.
//              
//  Returns:    S_FALSE if none found
//              S_OK if >=1 found
//              FAILED(hr) otherwise.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadMultiple(
    ULONG                   cpspec,
    const PROPSPEC          rgpspec[],
    PROPVARIANT             rgpropvar[])
{
    NTSTATUS Status;
    HRESULT hr;
    ULONG   cpropFound;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsReadable()))
        goto errRet;

    // Validate inputs

    if (0 == cpspec)
    {
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    //  -------------------
    //  Read the Properties
    //  -------------------

    Status = RtlQueryProperties(
                    _np,
                    cpspec,
                    rgpspec,
                    NULL,   // don't want PROPID's
                    rgpropvar,
                    &cpropFound);

    if (NT_SUCCESS(Status))
    {
        if (cpropFound == 0)
        {
            hr = S_FALSE;
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    //  ----
    //  Exit
    //  ----

errRet:            
    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::ReadMultiple(cpspec=%d, rgpspec=%08X, "
             "rgpropvar=%08X) returns %08X\n",
             this, cpspec, rgpspec, rgpropvar, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WriteMultiple, private
//
//  Synopsis:   Write the properties to the property set.  Allows
//              a NULL rgpropvar pointer for deletion case.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//
//              [rgpspec] -- pointer to array of PROPSPECs
//
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//              
//  Returns:    S_OK,   -- all requested data was written.
//              Errors  -- 
//
//  Modifies:
//
//  Derivation:
//
//  Notes:
//              This routine assumes the object has been validated
//              and is writeable.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT             hr;
    NTSTATUS            Status;
    CStackPropIdArray   spia;

    if (S_OK != (hr = spia.Init(cpspec)))
        return(hr);

    Status = RtlSetProperties(_np,   // property set context
                cpspec,             // property count
                propidNameFirst,    // first propid for new named props
                rgpspec,            // array of property specifiers
                spia.GetBuf(),      // buffer for array of propids
                rgpropvar);

    if (!NT_SUCCESS(Status))
    {
        hr = DfpNtStatusToHResult(Status);
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WriteMultiple
//
//  Synopsis:   Write properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//              [rgpropvar] -- pointer to array of PROPVARIANTs with
//                           the values to write.
//              [propidNameFirst] -- id below which not to assign
//                           ids for named properties.
//
//  Returns:    S_OK,   -- all requested data was written.
//              Errors  -- accordingly
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WriteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[],
                const PROPVARIANT       rgpropvar[],
                PROPID                  propidNameFirst)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGPROPVARIANT( cpspec, rgpropvar )))
        goto errRet;

    //  --------------------
    //  Write the Properties
    //  --------------------

    hr = _WriteMultiple(cpspec, rgpspec, rgpropvar, propidNameFirst);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, rgpropvar+i, propidNameFirst);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::WriteMultiple(cpspec=%d, rgpspec=%08X, "
             "rgpropvar=%08X, propidNameFirst=%d) returns %08X\n",
             this, cpspec, rgpspec, rgpropvar, propidNameFirst, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeleteMultiple
//
//  Synopsis:   Delete properties.
//
//  Arguments:  [cpspec] -- count of PROPSPECs and PROPVARIANTs in
//                          [rgpspec] and [rgpropvar]
//              [rgpspec] -- pointer to array of PROPSPECs
//
//  Returns:    S_OK,   -- all requested data was deleted.
//              Errors  -- 
//
//  Notes:      Checks that rgpropvar is not NULL, then calls
//              _WriteMultiple.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeleteMultiple(
                ULONG                   cpspec,
                const PROPSPEC          rgpspec[])
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if (0 == cpspec)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPSPEC( cpspec, rgpspec )))
        goto errRet;

    //  ---------------------
    //  Delete the Properties
    //  ---------------------

    hr = _WriteMultiple(cpspec, rgpspec, NULL, 2);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpspec; i++)
        {
            hr = _WriteMultiple(1, rgpspec+i, NULL, 2);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::DeleteMultiple(cpspec=%d, rgpspec=%08X) "
             "returns %08X\n",
             this, cpspec, rgpspec, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::ReadPropertyNames
//
//  Synopsis:   Attempt to read names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, one or more names returned
//              S_FALSE -- success, no names returned
//              STG_E_INVALIDHEADER -- no propid->name mapping property
//              other errors -- STG_E_INSUFFICIENTMEMORY etc
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::ReadPropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                LPOLESTR                rglpwstrName[])
{
    HRESULT hr;
    NTSTATUS Status;

    //  --------
    //  Validate
    //  --------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsReadable()))
        goto errRet;

    // Validate the inputs

    if (0 == cpropid)
    {
        hr = S_FALSE;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateOutRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    //  --------------
    //  Read the Names
    //  --------------

    Status = RtlQueryPropertyNames(_np, cpropid, rgpropid, rglpwstrName);
    if (Status == STATUS_NOT_FOUND)
        hr = STG_E_INVALIDHEADER;
    else
    if (Status == STATUS_BUFFER_ALL_ZEROS)
        hr = S_FALSE;
    else
    if (!NT_SUCCESS(Status))
        hr = DfpNtStatusToHResult(Status);

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::ReadPropertyNames(cpropid=%d, rgpropid=%08X, "
                            "rglpwstrName=%08X) returns %08X\n",
                            this, cpropid, rgpropid, rglpwstrName, hr));

    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::_WritePropertyNames
//
//  Synopsis:   Internal function used by WritePropertyNames and
//              DeletePropertyNames.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK if successful, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::_WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    NTSTATUS Status;

    Status = RtlSetPropertyNames(_np, cpropid, rgpropid, 
                                  (OLECHAR const* const*) rglpwstrName);
    return NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::WritePropertyNames
//
//  Synopsis:   Attempt to write names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//              [rglpstrName] -- Pointer to array of [cpropid] LPOLESTRs
//
//  Returns:    S_OK -- success, otherwise error code.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::WritePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[],
                const LPOLESTR          rglpwstrName[])
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate inputs

    if (0 == cpropid)
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    if (S_OK != (hr = ValidateInRGLPOLESTR( cpropid, rglpwstrName )))
        goto errRet;

    //  ---------------
    //  Write the Names
    //  ---------------

    hr = _WritePropertyNames(cpropid, rgpropid, rglpwstrName);
    
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, rglpwstrName+i);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:

    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::WritePropertyNames(cpropid=%d, rgpropid=%08X, "
                            "rglpwstrName=%08X) returns %08X\n",
                            this, cpropid, rgpropid, rglpwstrName, hr));
    return hr;
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::DeletePropertyNames
//
//  Synopsis:   Attempt to delete names for all identified properties.
//
//  Arguments:  [cpropid] -- Count of PROPIDs in [rgpropid]
//              [rgpropid] -- Pointer to array of [cpropid] PROPIDs
//
//  Returns:    S_OK -- success, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::DeletePropertyNames(
                ULONG                   cpropid,
                const PROPID            rgpropid[])
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if( 0 == cpropid )
    {
        hr = S_OK;
        goto errRet;
    }

    if (S_OK != (hr = ValidateRGPROPID( cpropid, rgpropid )))
        goto errRet;

    //  ----------------
    //  Delete the Names
    //  ----------------

    hr = _WritePropertyNames(cpropid, rgpropid, NULL);
    if (hr == STG_E_INSUFFICIENTMEMORY)
    {
        hr = S_OK;
        
        for (ULONG i=0; hr == S_OK && i < cpropid; i++)
        {
            hr = _WritePropertyNames(1, rgpropid+i, NULL);
        }
    }

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::DeletePropertyNames(cpropid=%d, rgpropid=%08X) "
                            "returns %08X\n",
                            this, cpropid, rgpropid, hr));
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Commit
//
//  Synopsis:   Flush and/or commit the property set
//
//  Arguments:  [grfCommittFlags] -- Commit flags.
//
//  Returns:    S_OK -- success, otherwise error.
//
//  Notes:      For both simple and non-simple, this flushes the
//              memory image to disk subsystem.  In addition,
//              for non-simple transacted-mode property sets, this
//              performs a commit on the property set.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Commit(DWORD grfCommitFlags)
{
    HRESULT  hr;
    NTSTATUS Status;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    if (S_OK != (hr = VerifyCommitFlags(grfCommitFlags)))
        goto errRet;

    //  --------------------------
    //  Commit the PropertyStorage
    //  --------------------------

    Status = RtlFlushPropertySet(_np); 
    if (!NT_SUCCESS(Status))
    {
        hr = DfpNtStatusToHResult(Status);
    }

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::Commit(grfCommitFlags=%08X) "
                            "returns %08X\n",
                            this, grfCommitFlags, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Revert
//
//  Synopsis:   For non-simple property sets, revert it.
//
//  Returns:    S_OK if successful.  STG_E_UNIMPLEMENTEDFUNCTION for
//              simple property sets.
//
//  Notes:      For non-simple property sets, call the underlying
//              storage's Revert and re-open the 'contents' stream.
//              
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Revert()
{
    HRESULT hr;

    hr = Validate();

    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::Revert() "
                            "returns %08X\n",
                            this, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set.
//
//  Arguments:  [ppenum] -- where to return the IEnumSTATPROPSTG *
//              
//  Returns:    S_OK or error.
//
//  Notes:      The constructor of CEnumSTATPROPSTG creates a
//              CStatArray which reads the entire property set and
//              which can be shared when IEnumSTATPROPSTG::Clone is
//              used.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Enum(IEnumSTATPROPSTG **    ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    if (S_OK != (hr = IsReadable()))
        return(hr);

    if (S_OK != (hr = IsReverted()))
        return(hr);

    // Validate the inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );

    //  ----------------------
    //  Create the Enumeration
    //  ----------------------

    *ppenum = NULL;

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSTG(_np, &hr);
    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSTG*) *ppenum;
        *ppenum = NULL;
    }

    //  ----
    //  Exit
    //  ----

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetTimes
//
//  Synopsis:   Set the given times on the underlying storage
//
//  Arguments:  [pctime] -- creation time
//              [patime[ -- access time
//              [pmtime] -- modify time
//
//  Returns:    S_OK or error.
//
//  Notes:
//              (non-simple only)  Only the times supported by the
//              underlying docfile implementation are
//              supported.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetTimes(
                FILETIME const *        pctime,
                FILETIME const *        patime,
                FILETIME const *        pmtime)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    VDATEPTRIN_LABEL( pctime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( patime, FILETIME, errRet, hr );
    VDATEPTRIN_LABEL( pmtime, FILETIME, errRet, hr );

    // since we only support non-simple, this function does not
    // do anything

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, 
             "CPropertyStorage(%08X)::SetTimes("
             "pctime=%08X, patime=%08X, pmtime=%08X) returns %08X\n",
             this, pctime, patime, pmtime, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::SetClass
//
//  Synopsis:   Sets the class of the property set.
//
//  Arguments:  [clsid] -- class id to set.
//              
//  Returns:    S_OK or error.
//
//  Notes:      Have clsid set into the property set stream.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::SetClass(REFCLSID clsid)
{
    HRESULT hr;
    NTSTATUS Status;
    DBGBUF(buf);

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsWriteable()))
        goto errRet;

    // Validate the inputs

    GEN_VDATEREADPTRIN_LABEL(&clsid, CLSID, E_INVALIDARG, errRet, hr);

    //  -------------
    //  Set the CLSID
    //  -------------

    // Set it in the property set header

    Status = RtlSetPropertySetClassId(_np, &clsid);
    if (!NT_SUCCESS(Status))
        hr = DfpNtStatusToHResult(Status);

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::SetClass(clsid=%s) "
                                "returns %08X\n",
                                this, DbgFmtId(clsid, buf), hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::SetClass(clsid@%08X) "
                                "returns %08X\n",
                                this, &clsid, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertyStorage::Stat
//
//  Synopsis:   Get STATPROPSETSTG about the property set.
//
//  Arguments:  [p] -- STATPROPSETSTG *
//              
//  Returns:    S_OK if successful, error otherwise.  On failure,
//              *p is all zeros.
//
//  Notes:      See spec.  Gets times from underlying storage or stream
//              using IStorage or IStream ::Stat.
//
//--------------------------------------------------------------------

HRESULT CPropertyStorage::Stat(STATPROPSETSTG * p)
{
    HRESULT hr;
    NTSTATUS Status;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        goto errRet;

    if (S_OK != (hr = IsReverted()))
        goto errRet;

    if (S_OK != (hr = IsReadable()))
        goto errRet;

    // Validate inputs

    VDATEPTROUT_LABEL(p, STATPROPSETSTG, errRet, hr);

    //  ------------
    //  Get the Stat
    //  ------------

    ZeroMemory(p, sizeof(*p));

    // returns mtime, ansi flag, clsid, fmtid
    Status = RtlQueryPropertySet(_np, p);
    if (NT_SUCCESS(Status))
    {
        STATSTG statstg;

        hr = S_OK;
        hr = _pstmPropSet->Stat(&statstg, STATFLAG_NONAME);

        if (hr == S_OK)
        {
            p->mtime = statstg.mtime;
            p->ctime = statstg.ctime;
            p->atime = statstg.atime;
            p->grfFlags = _grfFlags;
            p->dwOSVersion = _dwOSVersion;
        }
    }
    else
    {
        hr = DfpNtStatusToHResult(Status);
    }

    if (FAILED(hr))
    {
        ZeroMemory(p, sizeof(*p));
    }

    //  ----
    //  Exit
    //  ----

errRet:
    PropDbg((DEB_PROP_EXIT, "CPropertyStorage(%08X)::Stat(STATPROPSETSTG *p = %08X) "
                            "returns %08X\n",
                            this, p, hr));
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::CStatArray
//
//  Synopsis:   Read in the enumeration using RtlEnumerateProperties
//
//  Arguments:  [np] -- the NTPROP to use
//              [phr] -- S_OK on success, error otherwise.
//              
//  Notes:      Retry getting number of properties and reading all of
//              them into a caller-allocated buffer until it fits.
//
//--------------------------------------------------------------------

CStatArray::CStatArray(NTPROP np, HRESULT *phr)
{
    NTSTATUS Status;
    ULONG ulKeyZero;
    ULONG cpropAllocated;

    _cRefs = 1;
    _psps = NULL;

    do
    {
        //  when *pkey == 0, *pcprop == MAXULONG, aprs == NULL and asps == NULL on input,
        // *pcprop will be the total count of properties in the enumeration set.  OLE needs to 
        // allocate memory and enumerate out of the cached PROPID+propname list.

        ulKeyZero = 0;
        _cpropActual = MAX_ULONG;

        delete [] _psps;
        _psps = NULL;

        Status = RtlEnumerateProperties(
                np,
                ENUMPROP_NONAMES,
                &ulKeyZero,
                &_cpropActual,
                NULL,   // aprs
                NULL);

        if (!NT_SUCCESS(Status))
            break;
        
        cpropAllocated = _cpropActual + 1;

        _psps = new STATPROPSTG [ cpropAllocated ];
        if (_psps == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ulKeyZero = 0;
        Status = RtlEnumerateProperties(
                np,
                0,
                &ulKeyZero,
                &cpropAllocated,
                NULL,   // aprs
                _psps);
    } while (NT_SUCCESS(Status) && cpropAllocated != _cpropActual);

    *phr = NT_SUCCESS(Status) ? S_OK : DfpNtStatusToHResult(Status);
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::~CStatArray
//
//  Synopsis:   Deallocated the object's data.
//
//--------------------------------------------------------------------

CStatArray::~CStatArray()
{
    if (_psps != NULL)
    {
        CleanupSTATPROPSTG(_cpropActual, _psps);
    }
    delete [] _psps;
}

//+-------------------------------------------------------------------
//
//  Member:     CStatArray::NextAt
//
//  Synopsis:   Read from the internal STATPROPSTG array.
//
//  Effects:    The cursor is passed in, and this function acts
//              as a IEnumXX::Next would behave if the current cursor
//              was [ipropNext].
//
//  Arguments:  [ipropNext] -- index of cursor to use
//              [pspsDest] -- if NULL, emulate read's effect on cursor.
//                            if non-NULL, return data with cursor effect.
//              [pceltFetched] -- buffer for count fetched
//              
//  Returns:    STATUS_SUCCESS if successful, otherwise
//              STATUS_INSUFFICIENT_RESOURCES.
//
//  Notes:      
//
//--------------------------------------------------------------------

NTSTATUS
CStatArray::NextAt(ULONG ipropNext, STATPROPSTG *pspsDest, ULONG *pceltFetched)
{
    ULONG   ipropLastPlus1;

    //
    // Copy the requested number of elements from the cache
    // (including strings, the allocation of which may fail.)
    //

    ipropLastPlus1 = ipropNext + *pceltFetched;
    if (ipropLastPlus1 > _cpropActual)
    {
        ipropLastPlus1 = _cpropActual;
    }

    *pceltFetched = ipropLastPlus1 - ipropNext;

    if (pspsDest != NULL)
        return CopySTATPROPSTG(*pceltFetched, pspsDest, _psps + ipropNext);
    else
        return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::CEnumSTATPROPSTG
//
//  Synopsis:   Constructor for object that has cursor over CStatArray
//              and implements IEnumSTATPROPSTG, used by
//              CPropertyStorage::Enum.
//
//  Arguments:  [np] -- the NTPROP to use
//              [phr] -- where to put the HRESULT
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::CEnumSTATPROPSTG(NTPROP np, HRESULT *phr)
{
    _ulSig = ENUMSTATPROPSTG_SIG;
    _cRefs = 1;

    _psa = new CStatArray(np, phr);

    _ipropNext = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::CEnumSTATPROPSTG
//
//  Synopsis:   Constructor which is used by IEnumSTATPROPSTG::Clone.
//
//  Arguments:  [other] -- the CEnumSTATPROPSTG to copy
//              [phr] -- the error code.
//              
//  Notes:      Since the CStatArray actually contains the object this
//              just adds to the ref count.
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::CEnumSTATPROPSTG(const CEnumSTATPROPSTG & other, HRESULT *phr)
{

    _ulSig = ENUMSTATPROPSTG_SIG;
    _cRefs = 1;

    _psa = other._psa;
    _psa->AddRef();

    _ipropNext = other._ipropNext;

    *phr = S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::~CEnumSTATPROPSTG
//
//  Synopsis:   Deallocated storage.
//
//  Arguments:
//              
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------

CEnumSTATPROPSTG::~CEnumSTATPROPSTG()
{
    _ulSig = ENUMSTATPROPSTG_SIGDEL;    // prevent another thread doing it - kinda

    if (_psa != NULL)
        _psa->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::QueryInterface
//
//  Synopsis:   Respond to IEnumSTATPROPSTG and IUnknown.
//
//  Returns:    S_OK  or E_NOINTERFACE
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    *ppvObject = NULL;

    if (S_OK != (hr = Validate()))
        return(hr);

    if (IsEqualIID(riid, IID_IEnumSTATPROPSTG))
    {
        *ppvObject = (IEnumSTATPROPSTG *)this;
        AddRef();
    }
    else
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::AddRef
//
//  Synopsis:   Add 1 to ref count.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::AddRef(void)
{
    if (S_OK != Validate())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Release
//
//  Synopsis:   Subtract 1 from ref count and delete if 0.
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Function:   CopySTATPROPSTG
//
//  Synopsis:   Copy out the range of elements from [pspsSrc] to
//              [pspsDest].
//
//  Arguments:  [celt] -- count of elements to copy
//              [pspsDest] -- where to copy to, always filled with
//                          zeros before anything else (helps cleanup
//                          case.)
//
//              [pspsSrc] -- where to copy from
//
//  Returns:    STATUS_SUCCESS if ok, otherwise
//              STATUS_INSUFFICIENT_RESOURCES in which case there
//              may be pointers that need deallocating.  Use
//              CleanupSTATPROPSTG to do that.
//
//--------------------------------------------------------------------

NTSTATUS
CopySTATPROPSTG(ULONG celt,
            STATPROPSTG * pspsDest,
            const STATPROPSTG * pspsSrc)
{
    memset(pspsDest, 0, sizeof(*pspsDest) * celt);

    while (celt)
    {
        *pspsDest = *pspsSrc;

        if (pspsSrc->lpwstrName != NULL)
        {
            pspsDest->lpwstrName = (LPOLESTR)CoTaskMemAlloc(
                sizeof(OLECHAR)*(1+ocslen(pspsSrc->lpwstrName)));
            if (pspsDest->lpwstrName != NULL)
            {
                ocscpy(pspsDest->lpwstrName,
                       pspsSrc->lpwstrName);
            }
            else
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
        }

        celt--;
        pspsDest++;
        pspsSrc++;
    }

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------
//
//  Member:     CleanupSTATPROPSTG
//
//  Synopsis:   Free any elements in the passed array.
//
//  Arguments:  [celt] -- number of elements to examine.
//              [psps] -- array of STATPROPSTG to examine.
//              
//  Notes:      Zeros them out too.
//
//--------------------------------------------------------------------

VOID
CleanupSTATPROPSTG(ULONG celt, STATPROPSTG * psps)
{
    while (celt)
    {
        CoTaskMemFree(psps->lpwstrName);
        memset(psps, 0, sizeof(*psps));
        celt--;
        psps++;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Next
//
//  Synopsis:   Get the next [celt] STATPROPSTGs from the enumerator.
//
//  Arguments:  [celt] -- count requested.
//              [rgelt] -- where to return them
//              [pceltFetched] -- buffer for returned-count.
//                  if pceltFetched==NULL && celt != 1 -> STG_E_INVALIDPARAMETER
//                  if pceltFetched!=NULL && celt == 0 -> S_OK
//
//  Returns:    S_OK if successful, otherwise error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Next(
             ULONG                   celt,
             STATPROPSTG *           rgelt,
             ULONG *                 pceltFetched)
{
    HRESULT hr;
    NTSTATUS Status;
    ULONG   celtFetched = celt;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the inputs

    if (NULL == pceltFetched)
    {
        if (celt != 1)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if( 0 == celt )
        return( S_OK );

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    if (celt == 0)
        return(hr);

    Status = _psa->NextAt(_ipropNext, rgelt, &celtFetched);

    if (NT_SUCCESS(Status))
    {
        _ipropNext += celtFetched;

        if (pceltFetched != NULL)
            *pceltFetched = celtFetched;

        hr = celtFetched == celt ? S_OK : S_FALSE;
    }
    else
    {
        CleanupSTATPROPSTG(celt, rgelt);
        hr = DfpNtStatusToHResult(Status);
    }

    return(hr);
    
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Skip
//
//  Synopsis:   Skip the next [celt] elements in the enumeration.
//
//  Arguments:  [celt] -- number of elts to skip
//              
//  Returns:    S_OK if skipped [celt] elements
//              S_FALSE if skipped < [celt] elements
//
//  Notes:
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Skip(ULONG celt)
{
    HRESULT hr;
    ULONG celtFetched = celt;

    if (S_OK != (hr = Validate()))
        return(hr);

    _psa->NextAt(_ipropNext, NULL, &celtFetched);

    _ipropNext += celtFetched;

    return celtFetched == celt ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Reset
//
//  Synopsis:   Set cursor to beginnging of enumeration.
//
//  Returns:    S_OK otherwise STG_E_INVALIDHANDLE.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    _ipropNext = 0;

    return(S_OK);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSTG::Clone
//
//  Synopsis:   Creates an IEnumSTATPROPSTG with same cursor
//              as this.
//
//  Arguments:  S_OK or error.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSTG::Clone(IEnumSTATPROPSTG ** ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate the input

    VDATEPTROUT( ppenum, IEnumSTATPROPSTG* );

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    *ppenum = NULL;

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSTG(*this, &hr);

    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSTG*)*ppenum;
        *ppenum = NULL;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\propvar.cxx ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1993
//
// File:        propvar.cxx
//
// Contents:    PROPVARIANT manipulation code
//
//
//---------------------------------------------------------------------------

#include "pch.cxx"

#ifndef newk
#define newk(Tag, pCounter)     new
#endif

extern "C" UNICODECALLOUTS UnicodeCallouts;

// The below variant types are supported in property set streams.  In addition,
// the variants found in an array of variants (VT_VECTOR | VT_VARIANT) can only
// contain the types listed below as legal for arrays.  Nested vectors of
// VT_VARIANT are specifically *allowed*.
//
// dd    xx  symbolic name	     field		  size
// --   ---  -------------	     -----		  ----
// -1 - ffff VT_ILLEGAL		     <none>		  can't legally be stored
//
//  0 - x00  VT_EMPTY		     <none>		  0
//  1 - x01  VT_NULL		     <none>		  0
//
// 16 - x10  VT_I1                   CHAR cVal            sizeof(char)
// 17 - x11  VT_UI1		     UCHAR bVal		  sizeof(char)
//
//  2 - x02  VT_I2		     short iVal		  sizeof(short)
// 18 - x12  VT_UI2		     USHORT uiVal	  sizeof(short)
// 11 - x0b  VT_BOOL		     VARIANT_BOOL boolVal sizeof(short)
//
//  3 - x03  VT_I4		     long lVal		  sizeof(long)
// 19 - x13  VT_UI4		     ULONG ulVal	  sizeof(long)
//  4 - x04  VT_R4		     float fltVal	  sizeof(long)
// 10 - x0a  VT_ERROR		     SCODE scode	  sizeof(long)
//
// 20 - x14  VT_I8		     LARGE_INTEGER hVal	  sizeof(ll)
// 21 - x15  VT_UI8		   ULARGE_INTEGER uhVal	  sizeof(ll)
//  5 - x05  VT_R8		     double dblVal	  sizeof(ll)
//  6 - x06  VT_CY		     CY cyVal		  sizeof(ll)
//  7 - x07  VT_DATE		     DATE date		  sizeof(ll)
// 64 - x40  VT_FILETIME	     FILETIME filetime	  sizeof(ll)
//
// 72 - x48  VT_CLSID		     CLSID *puuid	  sizeof(GUID)
//
// 65 - x41  VT_BLOB		     BLOB blob		  counted array of bytes
// 70 - x46  VT_BLOB_OBJECT	     BLOB blob		  counted array of bytes
// 71 - x47  VT_CF		     CLIPDATA *pclipdata    " + ulClipFmt
// 66 - x42  VT_STREAM		     LPSTR pszVal	  counted array of bytes
// 68 - x44  VT_STREAMED_OBJECT      LPSTR pszVal	  counted array of bytes
// 67 - x43  VT_STORAGE		     LPSTR pszVal	  counted array of bytes
// 69 - x45  VT_STORED_OBJECT	     LPSTR pszVal	  counted array of bytes
//  8 - x08  VT_BSTR		     BSTR bstrVal	  counted array of bytes
// 30 - x1e  VT_LPSTR		     LPSTR pszVal	  counted array of bytes
//
// 31 - x1f  VT_LPWSTR		     LPWSTR pwszVal	  counted array of WCHARs
//
//    x1010  VT_VECTOR | VT_I1	     CAC cac		  cElems * sizeof(char)
//    x1011  VT_VECTOR | VT_UI1	     CAUB caub		  cElems * sizeof(char)
//
//    x1002  VT_VECTOR | VT_I2	     CAI cai		  cElems * sizeof(short)
//    x1012  VT_VECTOR | VT_UI2	     CAUI caui		  cElems * sizeof(short)
//    x100b  VT_VECTOR | VT_BOOL     CABOOL cabool	  cElems * sizeof(short)
//
//    x1003  VT_VECTOR | VT_I4	     CAL cal		  cElems * sizeof(long)
//    x1013  VT_VECTOR | VT_UI4	     CAUL caul		  cElems * sizeof(long)
//    x1004  VT_VECTOR | VT_R4	     CAFLT caflt	  cElems * sizeof(long)
//    x100a  VT_VECTOR | VT_ERROR    CAERROR cascode	  cElems * sizeof(long)
//
//    x1014  VT_VECTOR | VT_I8	     CAH cah		  cElems * sizeof(ll)
//    x1015  VT_VECTOR | VT_UI8	     CAUH cauh		  cElems * sizeof(ll)
//    x1005  VT_VECTOR | VT_R8	     CADBL cadbl	  cElems * sizeof(ll)
//    x1006  VT_VECTOR | VT_CY	     CACY cacy		  cElems * sizeof(ll)
//    x1007  VT_VECTOR | VT_DATE     CADATE cadate	  cElems * sizeof(ll)
//    x1040  VT_VECTOR | VT_FILETIME CAFILETIME cafiletime cElems * sizeof(ll)
//
//    x1048  VT_VECTOR | VT_CLSID    CACLSID cauuid	  cElems * sizeof(GUID)
//
//    x1047  VT_VECTOR | VT_CF	  CACLIPDATA caclipdata   cElems cntarray of bytes
//    x1008  VT_VECTOR | VT_BSTR     CABSTR cabstr	  cElems cntarray of bytes
//    x101e  VT_VECTOR | VT_LPSTR    CALPSTR calpstr	  cElems cntarray of bytes
//
//    x101f  VT_VECTOR | VT_LPWSTR   CALPWSTR calpwstr	  cElems cntarray of WCHAR
//
//    x100c  VT_VECTOR | VT_VARIANT  CAPROPVARIANT capropvar cElems variants
//							   (recurse on each)


//+---------------------------------------------------------------------------
// Function:    RtlpConvertToUnicode, private
//
// Synopsis:    Convert a MultiByte string to a Unicode string
//
// Arguments:   [pch]        -- pointer to MultiByte string
//              [cb]         -- byte length of MultiByte string
//              [CodePage]   -- property set codepage
//              [ppwc]       -- pointer to returned pointer to Unicode string
//              [pcb]        -- returned byte length of Unicode string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
RtlpConvertToUnicode(
    IN CHAR const *pch,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT WCHAR **ppwc,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    WCHAR *pwszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pch != NULL);
    PROPASSERT(ppwc != NULL);
    PROPASSERT(pcb != NULL);

    *ppwc = NULL;
    *pcb = 0;

    ULONG cwcName;

    PROPASSERT(UnicodeCallouts.pfnMultiByteToWideChar != NULL);

    pwszName = NULL;
    cwcName = 0;
    while (TRUE)
    {
	cwcName = (*UnicodeCallouts.pfnMultiByteToWideChar)(
				    CodePage,
				    0,			// dwFlags
				    pch,
				    cb,
				    pwszName,
				    cwcName);
	if (cwcName == 0)
	{
	    delete [] pwszName;
            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "RtlpConvertToUnicode: MultiByteToWideChar error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}
	if (pwszName != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"RtlpConvertToUnicode: pch='%s'[%x] pwc='%ws'[%x->%x]\n",
		pch,
		cb,
		pwszName,
		*pcb,
		cwcName * sizeof(WCHAR)));
	    break;
	}
	*pcb = cwcName * sizeof(WCHAR);
	*ppwc = pwszName = (WCHAR *) newk(mtPropSetStream, NULL) CHAR[*pcb];
	if (pwszName == NULL)
	{
	    StatusNoMemory(pstatus, "RtlpConvertToUnicode: no memory");
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    RtlpConvertToMultiByte, private
//
// Synopsis:    Convert a Unicode string to a MultiByte string
//
// Arguments:   [pwc]        -- pointer to Unicode string
//              [cb]         -- byte length of Unicode string
//              [CodePage]   -- property set codepage
//              [ppch]       -- pointer to returned pointer to MultiByte string
//              [pcb]        -- returned byte length of MultiByte string
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     Nothing
//---------------------------------------------------------------------------

VOID
RtlpConvertToMultiByte(
    IN WCHAR const *pwc,
    IN ULONG cb,
    IN USHORT CodePage,
    OUT CHAR **ppch,
    OUT ULONG *pcb,
    OUT NTSTATUS *pstatus)
{
    ULONG cbName;
    CHAR *pszName;

    *pstatus = STATUS_SUCCESS;

    PROPASSERT(pwc != NULL);
    PROPASSERT(ppch != NULL);
    PROPASSERT(pcb != NULL);

    *ppch = NULL;
    *pcb = 0;


    PROPASSERT(UnicodeCallouts.pfnWideCharToMultiByte != NULL);

    pszName = NULL;
    cbName = 0;
    while (TRUE)
    {
	cbName = (*UnicodeCallouts.pfnWideCharToMultiByte)(
				    CodePage,
				    0,			// dwFlags
				    pwc,
				    cb/sizeof(WCHAR),
				    pszName,
				    cbName,
				    NULL,		// lpDefaultChar
				    NULL);		// lpUsedDefaultChar
	if (cbName == 0)
	{
	    delete [] pszName;
            // If there was an error, assume that it was a code-page
            // incompatibility problem.
            StatusError(pstatus, "RtlpConvertToMultiByte: WideCharToMultiByte error",
                        STATUS_UNMAPPABLE_CHARACTER);
            goto Exit;
	}
	if (pszName != NULL)
	{
	    DebugTrace(0, DEBTRACE_PROPERTY, (
		"RtlpConvertToMultiByte: pwc='%ws'[%x] pch='%s'[%x->%x]\n",
		pwc,
		cb,
		pszName,
		*pcb,
		cbName));
	    break;
	}
	*pcb = cbName;
	*ppch = pszName = newk(mtPropSetStream, NULL) CHAR[cbName];
	if (pszName == NULL)
	{
	    StatusNoMemory(pstatus, "RtlpConvertToMultiByte: no memory");
            goto Exit;
	}
    }

    //  ----
    //  Exit
    //  ----

Exit:

    return;
}


//+---------------------------------------------------------------------------
// Function:    RtlConvertVariantToProperty, private
//
// Synopsis:    Convert a PROPVARIANT to a SERIALIZEDPROPERTYVALUE
//
// Arguments:   [pvar]       -- pointer to PROPVARIANT
//              [CodePage]   -- property set codepage
//              [pprop]      -- pointer to SERIALIZEDPROPERTYVALUE
//              [pcb]        -- pointer to remaining stream length,
//			        updated to actual property size on return
//              [pid]	     -- propid
//              [fVariantVector] -- TRUE if recursing on VT_VECTOR | VT_VARIANT
//              [pstatus]    -- pointer to NTSTATUS code
//
// Returns:     NULL if buffer too small, else input [pprop] argument
//---------------------------------------------------------------------------


// Define a macro which sets a variable named 'cbByteSwap', but
// only on big-endian builds.  This value is not needed on little-
// endian builds (because byte-swapping is not necessary).

#ifdef BIGENDIAN
#define CBBYTESWAP(cb) cbByteSwap = cb
#elif LITTLEENDIAN
#define CBBYTESWAP(cb)
#else
#error Either BIGENDIAN or LITTLEENDIAN must be set.
#endif


SERIALIZEDPROPERTYVALUE *
RtlConvertVariantToProperty(
    IN PROPVARIANT const *pvar,
    IN USHORT CodePage,
    OPTIONAL OUT SERIALIZEDPROPERTYVALUE *pprop,
    IN OUT ULONG *pcb,
    IN PROPID pid,
    IN BOOLEAN fVariantVector,
    OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------
    CHAR *pchConvert = NULL;

    ULONG count;
    BYTE *pbdst;
    ULONG cbch = 0;
    ULONG cbchdiv = 0;
    ULONG cb = 0;

    // Size of byte-swapping units (e.g. 2 to swap a WORD).
    INT   cbByteSwap = 0;

    ULONG const *pcount = NULL;
    VOID const *pv = NULL;
    LONG *pclipfmt = NULL;
    BOOLEAN fCheckNullSource = (BOOLEAN) ((pvar->vt & VT_VECTOR) != 0);
    BOOLEAN fIllegalType = FALSE;
    VOID **ppv;

    //  -------------------------------------------------------
    //  Analyze the PropVariant, and store information about it
    //  in fIllegalType, cb, pv, pcount, count, pclipfmt,
    //  fCheckNullSource, cbch, chchdiv, and ppv.
    //  -------------------------------------------------------

    switch (pvar->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
	fIllegalType = fVariantVector;
	break;

#ifdef PROPVAR_VT_I1
    case VT_I1:
        AssertByteField(cVal);          // VT_I1
#endif
    case VT_UI1:
        AssertByteField(bVal);          // VT_UI1
	cb = sizeof(pvar->bVal);
	pv = &pvar->bVal;
	break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
	AssertShortField(iVal);	        // VT_I2
	AssertShortField(uiVal);        // VT_UI2
	AssertShortField(boolVal);      // VT_BOOL
	cb = sizeof(pvar->iVal);
	pv = &pvar->iVal;

        // If swapping, swap as a WORD
        CBBYTESWAP(cb);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
	AssertLongField(lVal);		// VT_I4
	AssertLongField(ulVal);		// VT_UI4
	AssertLongField(fltVal);		// VT_R4
	AssertLongField(scode);		// VT_ERROR
	cb = sizeof(pvar->lVal);
	pv = &pvar->lVal;

        // If swapping, swap as a DWORD
        CBBYTESWAP(cb);
	break;

    case VT_I8:
    case VT_UI8:
    case VT_FILETIME:
	AssertLongLongField(hVal);		// VT_I8
	AssertLongLongField(uhVal);		// VT_UI8
	AssertLongLongField(filetime);	// VT_FILETIME
	cb = sizeof(pvar->hVal);
	pv = &pvar->hVal;

        // If swapping, swap each DWORD independently.
        CBBYTESWAP(sizeof(DWORD));
	break;

    case VT_R8:
    case VT_CY:
    case VT_DATE:
	AssertLongLongField(dblVal);    // VT_R8
	AssertLongLongField(cyVal);     // VT_CY
	AssertLongLongField(date);      // VT_DATE
	cb = sizeof(pvar->dblVal);
	pv = &pvar->dblVal;

        // If swapping, swap as a LONGLONG (64 bits).
        CBBYTESWAP(cb);
	break;

    case VT_CLSID:
	AssertStringField(puuid);       // VT_CLSID
	cb = sizeof(GUID);
	pv = pvar->puuid;
	fCheckNullSource = TRUE;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
	break;

    case VT_CF:

        // Validate the PropVariant
	if (pvar->pclipdata == NULL
            ||
            pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
	{
	    StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: pclipdata NULL");
            goto Exit;
	}

        // How many bytes should we copy?
	cb = CBPCLIPDATA( *(pvar->pclipdata) );

        // Identify the value for this property's count field.
        // (which includes sizeof(ulClipFmt))
	count = pvar->pclipdata->cbSize;
	pcount = &count;

        // Identify the clipdata's format & data
	pclipfmt = &pvar->pclipdata->ulClipFmt;
	pv = pvar->pclipdata->pClipData;

	fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
	break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
	fIllegalType = fVariantVector;
	pcount = &pvar->blob.cbSize;
	cb = *pcount;
	pv = pvar->blob.pBlobData;
	fCheckNullSource = TRUE;

        // Note that no byte-swapping of 'pv' is necessary.
	break;

    case VT_LPSTR:
	PROPASSERT(
	    pvar->pszVal == NULL ||
	    IsAnsiString(pvar->pszVal, MAXULONG));
	// FALLTHROUGH

    case VT_BSTR:
	count = 0;	// allow NULL pointer
	pv = pvar->pszVal;

	AssertStringField(bstrVal);	// VT_BSTR
	AssertStringField(pszVal);	// VT_LPSTR

        // We have the string for an LPSTR, BSTR
        // property pointed to by 'pv'.  Now we'll perform any
        // Ansi/Unicode conversions and byte-swapping that's
        // necessary (putting the result in 'pv').

	if (pv == NULL)
	{
	    fCheckNullSource = TRUE;
	}

	else
	if (pvar->vt == VT_LPSTR)
	{
	    count = strlen((char *) pv) + 1;

            // If the propset is Unicode, convert the LPSTR to Unicode.

	    if (CodePage == CP_WINUNICODE)
	    {
                // Convert to Unicode.

		PROPASSERT(IsAnsiString((CHAR const *) pv, count));
		RtlpConvertToUnicode( (CHAR const *) pv,
                                      count, CP_ACP,
                                      // Variants are in the system codepage
                                      (WCHAR **) &pchConvert,
                                      &count,
                                      pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always has the ready-to-serialize string.
		pv = pchConvert;

                // This unicode string may require byte-swapping.
                CBBYTESWAP( sizeof(WCHAR) );
	    }
	}   // else if (pvar->vt == VT_LPSTR)

	else
	{
            // If this is a BSTR, increment the count to include
            // the string terminator.
	    if (pvar->vt == VT_BSTR)
	    {
		count = BSTRLEN(pv);

                // Verify that the input BSTR is terminated.
		if (pvar->bstrVal[count/sizeof(OLECHAR)] != ((OLECHAR)'\0'))
		{
		    PROPASSERT(pvar->bstrVal[count/sizeof(OLECHAR)] == OLESTR('\0'));
		    StatusInvalidParameter(pstatus,
			"RtlConvertVariantToProperty: bad BSTR null char");
                    goto Exit;
		}

                // Increment the count to include the terminator.
		count += sizeof(OLECHAR);
	    }
	    else
	    {
		count = (Prop_wcslen((WCHAR *) pv) + 1) * sizeof(WCHAR);
		PROPASSERT(IsUnicodeString((WCHAR const *) pv, count));
	    }

            // See if this BSTR requires conversion to the propset's code page      

            if (CodePage != CP_WINUNICODE   // Ansi property set
                &&
                OLECHAR_IS_UNICODE      // BSTRs are Unicode
                )
	    {
                // A Unicode to Ansi conversion is required.

                PROPASSERT( IsUnicodeString( (WCHAR*)pv, count ));

		RtlpConvertToMultiByte(
				(WCHAR const *) pv,
				count,
				CodePage,
				&pchConvert,
				&count,
                                pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;
		pv = pchConvert;
	    }
            else if (CodePage == CP_WINUNICODE   // Unicode property set,
                     &&
                     pvar->vt == VT_BSTR         // a BSTR property, and
                     &&
                     !OLECHAR_IS_UNICODE         // BSTRs are Ansi.
                )
            {
                // An Ansi to Unicode conversion is required.

                PROPASSERT(IsAnsiString((CHAR const *) pv, count));
                PROPASSERT(sizeof(OLECHAR) == sizeof(CHAR));

                RtlpConvertToUnicode(
                    (CHAR const *) pv,
                    count,
                    CP_ACP, // In-mem BSTR is in system CP
                    (WCHAR **) &pchConvert,
                    &count,
                    pstatus);
                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                // 'pv' always holds the ready-to-serialize value.
                pv = pchConvert;

                // This unicode string may require swapping.
                CBBYTESWAP( sizeof(WCHAR) );
            }

            else
            if (CodePage == CP_WINUNICODE)
            {
                // No conversion is required (i.e., both 'pv' and the 
                // property set are Unicode).  But we must remember
                // to perform a byte-swap (if byte-swapping is necessary).

                CBBYTESWAP( sizeof(WCHAR) );
            }
	}   // if (pv == NULL) ... else if ... else

        // Validate 'pv'.

#ifdef LITTLEENDIAN
        PROPASSERT( NULL == pv
                    ||
                    CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, count)
                    ||
                    CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, count) );
#endif

	cb = count;
	pcount = &count;
	break;

    case VT_LPWSTR:
	AssertStringField(pwszVal);		// VT_LPWSTR
	PROPASSERT(
	    pvar->pwszVal == NULL ||
	    IsUnicodeString(pvar->pwszVal, MAXULONG));

        pv = pvar->pwszVal;
	if (pv == NULL)
	{
	    count = 0;
	    fCheckNullSource = TRUE;
	}
	else
	{
            // Calculate the [length] field.
	    count = Prop_wcslen(pvar->pwszVal) + 1;

            // If byte-swapping will be necessary to get to the serialized
            // format, we'll do so in units of WCHARs.

            CBBYTESWAP( sizeof(WCHAR) );
	}

	cb = count * sizeof(WCHAR);
	pcount = &count;
	break;

    // Vector properties:

#ifdef PROPVAR_VT_I1
    case VT_VECTOR | VT_I1:
	AssertByteVector(cac);		// VT_I1
#endif
    case VT_VECTOR | VT_UI1:
	AssertByteVector(caub);		// VT_UI1
	pcount = &pvar->caub.cElems;
	cb = *pcount * sizeof(pvar->caub.pElems[0]);
	pv = pvar->caub.pElems;
	break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
	AssertShortVector(cai);		// VT_I2
	AssertShortVector(caui);        // VT_UI2
	AssertShortVector(cabool);      // VT_BOOL
	pcount = &pvar->cai.cElems;
	cb = *pcount * sizeof(pvar->cai.pElems[0]);
	pv = pvar->cai.pElems;

        // If swapping, swap as WORDs
        CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
	break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
	AssertLongVector(cal);		// VT_I4
	AssertLongVector(caul);		// VT_UI4
	AssertLongVector(caflt);        // VT_R4
	AssertLongVector(cascode);      // VT_ERROR
	pcount = &pvar->cal.cElems;
	cb = *pcount * sizeof(pvar->cal.pElems[0]);
	pv = pvar->cal.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
	break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_FILETIME:
	AssertLongLongVector(cah);      // VT_I8
	AssertLongLongVector(cauh);     // VT_UI8
	AssertLongLongVector(cafiletime);// VT_FILETIME
	pcount = &pvar->cah.cElems;
	cb = *pcount * sizeof(pvar->cah.pElems[0]);
	pv = pvar->cah.pElems;

        // If swapping, swap as DWORDs
        CBBYTESWAP(sizeof(DWORD));
	break;

    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
	AssertLongLongVector(cadbl);    // VT_R8
	AssertLongLongVector(cacy);     // VT_CY
	AssertLongLongVector(cadate);   // VT_DATE
	pcount = &pvar->cah.cElems;
	cb = *pcount * sizeof(pvar->cadbl.pElems[0]);
	pv = pvar->cadbl.pElems;

        // If swapping, swap as LONGLONGs (8 bytes)
        CBBYTESWAP(sizeof(pvar->cadbl.pElems[0]));
	break;


    case VT_VECTOR | VT_CLSID:
	AssertVarVector(cauuid, sizeof(GUID));
	pcount = &pvar->cauuid.cElems;
	cb = *pcount * sizeof(pvar->cauuid.pElems[0]);
	pv = pvar->cauuid.pElems;

        // If swapping, special handling is required.
        CBBYTESWAP( CBBYTESWAP_UID );
	break;

    case VT_VECTOR | VT_CF:
	cbch = sizeof(CLIPDATA);
	cbchdiv = sizeof(BYTE);
	goto stringvector;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
	cbchdiv = cbch = sizeof(BYTE);
	goto stringvector;

    case VT_VECTOR | VT_LPWSTR:
	cbchdiv = cbch = sizeof(WCHAR);
	goto stringvector;

    case VT_VECTOR | VT_VARIANT:
	cbch = MAXULONG;
stringvector:
	AssertVarVector(caclipdata, sizeof(CLIPDATA));	// VT_CF
	AssertStringVector(cabstr);                     // VT_BSTR
	AssertStringVector(calpstr);			// VT_LPSTR
	AssertStringVector(calpwstr);			// VT_LPWSTR
	AssertVarVector(capropvar, sizeof(PROPVARIANT));// VT_VARIANT

	pcount = &pvar->calpstr.cElems;
	ppv = (VOID **) pvar->calpstr.pElems;
	break;

    default:
	DebugTrace(0, DEBTRACE_ERROR, (
	    "RtlConvertVariantToProperty: unsupported vt=%x\n",
	    pvar->vt));
	StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: bad type");
        goto Exit;

    }   // switch (pvar->vt)

    // At this point we've analyzed the PropVariant, and stored
    // information about it in various local variables.  Now we
    // can use this information to serialize the propvar.

    // Early exit if this is an illegal type.

    if (fIllegalType)
    {
	StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: Illegal VarType");
        goto Exit;
    }

    // Set pbdst to point into the serialization buffer, or to 
    // NULL if there is no such buffer.

    if (pprop == NULL)
    {
	pbdst = NULL;
    }
    else
    {
	pbdst = pprop->rgb;
    }

    // Is this a Vector of Strings/Variants/CFs?
    if (cbch != 0)
    {
        // Yes.

	ULONG cElems;

	PROPASSERT(pcount != NULL);
	PROPASSERT(*pcount == 0 || ppv != NULL);
        PROPASSERT(0 == cbByteSwap);

	// Start calculating the serialized size.  Include the sizes
        // of the VT & element count.

	cb = sizeof(ULONG) + sizeof(ULONG);

        // Is this a Variant Vector?
	if (cbch != MAXULONG)
	{
	    // No.  Include each element's length field.
	    cb += *pcount * sizeof(ULONG);
	}

        // Is there room in the caller's buffer for everything
        // counted so far?
	if (*pcb < cb)
	{
            // No - we won't serialize the data, but we will continue
            // to calculate cb.
	    pprop = NULL;
	}

        // Write the count of vector elements.
	if (pprop != NULL)
	{
	    *(ULONG *) pbdst = PropByteSwap((ULONG) *pcount);
	    pbdst += sizeof(ULONG);
	}

        // Walk through the vector and write the elements.

	for (cElems = *pcount; cElems > 0; cElems--)
	{
	    ULONG cbcopy = 0;

            // Switch on the size of the element.
	    switch (cbch)
	    {
                //
                // VT_VARIANT
                //
		case MAXULONG:
		    cbcopy = MAXULONG;

                    // Perform a recursive serialization
		    RtlConvertVariantToProperty(
				(PROPVARIANT *) ppv,
				CodePage,
				NULL,
				&cbcopy,
				PID_ILLEGAL,
				TRUE,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    break;

                //
                //  VT_CF
                //
		case sizeof(CLIPDATA):

                    // We copy cbSize-sizeof(ulClipFmt) bytes.

                    if( ((CLIPDATA *) ppv)->cbSize < sizeof(ULONG) )
                    {
                        StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: short cbSize on VT_CF");
                        goto Exit;
                    }
                    else
                    {
                        cbcopy = CBPCLIPDATA( *(CLIPDATA*) ppv );
                    }

                    // But increment cb to to include sizeof(ulClipFmt)
                    cb += sizeof(ULONG);
		    break;

                //
                //  VT_LPWSTR
                //
		case sizeof(WCHAR):
		    if (*ppv != NULL)
		    {
			PROPASSERT(IsUnicodeString((WCHAR const *) *ppv, MAXULONG));
			cbcopy = (Prop_wcslen((WCHAR *) *ppv) + 1) * sizeof(WCHAR);
			pv = *ppv;

                        // If byte-swapping is necessary, swap in units of WCHARs
                        CBBYTESWAP( sizeof(WCHAR) );

		    }
		    break;

                //
                //  VT_LPSTR/VT_BSTR
                //
		default:
		    PROPASSERT(cbch == sizeof(BYTE));
		    PROPASSERT(pchConvert == NULL);
		    if (*ppv != NULL)
		    {
			pv = *ppv;

                        // Is this a BSTR?
			if (pvar->vt == (VT_VECTOR | VT_BSTR))
			{
                            // Initialize the # bytes to copy.
			    cbcopy = BSTRLEN(pv);

                            // Verify that the BSTR is terminated.
			    if (((OLECHAR const *) pv)
                                [cbcopy/sizeof(OLECHAR)] != ( (OLECHAR)'\0'))
			    {
				PROPASSERT(
                                    ((OLECHAR const *) pv)
                                    [cbcopy/sizeof(OLECHAR)] == ((OLECHAR)'\0'));
				StatusInvalidParameter(
                                    pstatus,
                                    "RtlConvertVariantToProperty: bad BSTR"
                                    "array null char"); 
                                goto Exit;
			    }

                            // Also copy the string terminator.
			    cbcopy += sizeof(OLECHAR);

                            // If the propset and the BSTR are in mismatched
                            // codepages (one's Unicode, the other's Ansi),
                            // correct the BSTR now.  In any case, the correct
                            // string is in 'pv'.

			    if (CodePage != CP_WINUNICODE   // Ansi property set
                                &&
                                OLECHAR_IS_UNICODE)         // Unicode BSTR
			    {
                                PROPASSERT(IsUnicodeString((WCHAR*)pv, cbcopy));

				RtlpConvertToMultiByte(
						(WCHAR const *) pv,
						cbcopy,
						CodePage,
						&pchConvert,
						&cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

				pv = pchConvert;
			    }

                            else
                            if (CodePage == CP_WINUNICODE   // Unicode property set
                                &&
                                !OLECHAR_IS_UNICODE)        // Ansi BSTRs
                            {
                                PROPASSERT(IsAnsiString((CHAR const *) pv, cbcopy));

                                RtlpConvertToUnicode(
		                                (CHAR const *) pv,
		                                cbcopy,
		                                CP_ACP, // In-mem BSTR is in system CP
		                                (WCHAR **) &pchConvert,
		                                &cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // The Unicode string must have the proper byte order
                                CBBYTESWAP( sizeof(WCHAR) );

                                pv = pchConvert;

                            }

                            else
                            if (CodePage == CP_WINUNICODE )
                            {
                                // Both the BSTR and the property set are Unicode.
                                // No conversion is required, but byte-swapping
                                // is (if byte-swapping is enabled).

                                CBBYTESWAP( sizeof(WCHAR) );
                            }

			}   // if (pvar->vt == (VT_VECTOR | VT_BSTR))

                        // Otherwise it's an LPSTR
			else
			{
			    PROPASSERT(IsAnsiString((char const *) pv, MAXULONG));
			    PROPASSERT(pvar->vt == (VT_VECTOR | VT_LPSTR));
			    cbcopy = strlen((char *) pv) + 1; // + trailing null

			    if (CodePage == CP_WINUNICODE)
			    {
				PROPASSERT(IsAnsiString(
						(CHAR const *) pv,
						cbcopy));
				RtlpConvertToUnicode(
						(CHAR const *) pv,
						cbcopy,
						CP_ACP,
						(WCHAR **) &pchConvert,
						&cbcopy,
                                                pstatus);
                                if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                // If byte-swapping, we'll do so with the WCHARs
                                CBBYTESWAP( sizeof(WCHAR) );

				pv = pchConvert;
			    }   
			}   // if (pvar->vt == (VT_VECTOR | VT_BSTR)) ... else
		    }   // if (*ppv != NULL)

                    // In the end, pv should be in the codepage of
                    // the property set.

#ifdef LITTLEENDIAN
                    PROPASSERT( NULL == pv
                                ||
                                CodePage == CP_WINUNICODE && IsUnicodeString((WCHAR*)pv, cbcopy)
                                ||
                                CodePage != CP_WINUNICODE && IsAnsiString((CHAR*)pv, cbcopy));
#endif

		    break;

	    }   // switch (cbch)
	    
            // Add the size of this vector element to the property total
	    cb += DwordAlign(cbcopy);

            // Will there be enough room for this vector element?

	    if (*pcb < cb)
	    {
                // No - we'll continue (thus calculating the total size
                // necessary), but we won't write to the caller's buffer.
		pprop = NULL;
	    }

            // Is this a vector of Variants?

	    if (cbch == MAXULONG)
	    {
                // Yes.  Convert this variant.
		if (pprop != NULL)
		{
		    RtlConvertVariantToProperty(
				(PROPVARIANT *) ppv,
				CodePage,
				(SERIALIZEDPROPERTYVALUE *) pbdst,
				&cbcopy,
				PID_ILLEGAL,
				TRUE,
                                pstatus);
                    if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    pbdst += cbcopy;
		}
		ppv = (VOID **) Add2Ptr(ppv, sizeof(PROPVARIANT));
	    }   // if (cbch == MAXULONG)

	    else
	    {
                // This is a vector of something other than Variants.

		PROPASSERT(
		    cbch == sizeof(BYTE) ||
		    cbch == sizeof(WCHAR) ||
		    cbch == sizeof(CLIPDATA));

		PROPASSERT(cbchdiv == sizeof(BYTE) || cbchdiv == sizeof(WCHAR));

                // Are we writing the serialized property?
		if (pprop != NULL)
		{
                    ULONG cbVectElement;

                    // Calculate the length of the vector element.
                    cbVectElement = (ULONG) cbcopy/cbchdiv;

                    // Is this a ClipData?
		    if (cbch == sizeof(CLIPDATA))
		    {
                        // Adjust the length to include sizeof(ulClipFmt)
                        cbVectElement += sizeof(ULONG);

                        // Write the vector element length.
                        *(ULONG *) pbdst = PropByteSwap( cbVectElement );

                        // Advance pbdst & write the clipboard format.
			pbdst += sizeof(ULONG);
			*(ULONG *) pbdst = PropByteSwap( ((CLIPDATA *) ppv)->ulClipFmt );
		    }
                    else    // This isn't a ClipFormat vector element.
                    {
                        // Write the vector element length.
		        *(ULONG *) pbdst = PropByteSwap( cbVectElement );
                    }

                    // Advance pbdst & write the property data.
		    pbdst += sizeof(ULONG);
		    RtlCopyMemory(
				pbdst,
				cbch == sizeof(CLIPDATA)?
				  ((CLIPDATA *) ppv)->pClipData :
				  pv,
				cbcopy);

                    // Zero out the pad bytes.
		    RtlZeroMemory(pbdst + cbcopy, DwordRemain(cbcopy));

                    // If byte-swapping is necessary, do so now.
                    PBSBuffer( pbdst, DwordAlign(cbcopy), cbByteSwap );

                    // Advance pbdst to the next property.
		    pbdst += DwordAlign(cbcopy);

		}   // if (pprop != NULL)

                // Advance ppv to point into the PropVariant at the
                // next element in the array.

		if (cbch == sizeof(CLIPDATA))
		{
		    ppv = (VOID **) Add2Ptr(ppv, sizeof(CLIPDATA));
		}
		else
		{
		    ppv++;
		    delete [] pchConvert;
		    pchConvert = NULL;
		}
	    }   // if (cbch == MAXULONG) ... else
	}   // for (cElems = *pcount; cElems > 0; cElems--)
    }   // if (cbch != 0)    // STRING/VARIANT/CF VECTOR property

    else
    {
        // This isn't a vector, or if it is, the elements
        // aren't Strings, Variants, or CFs.

	ULONG cbCopy = cb;

        // Adjust cb (the total serialized buffer size) for
        // pre-data.

	if (pvar->vt != VT_EMPTY)
	{   // Allow for the VT
	    cb += sizeof(ULONG);
	}
	if (pcount != NULL)
	{   // Allow for the count field
	    cb += sizeof(ULONG);
	}
	if (pclipfmt != NULL)
	{   // Allow for the ulClipFmt field.
	    cb += sizeof(ULONG);
	}

        // Is there room in the caller's buffer?
	if (*pcb < cb)
	{   // No - calculate cb but don't write anything.
	    pprop = NULL;
	}

        // 'pv' should point to the source data.  If it does, then
        // we'll copy it into the property set.  If it doesn't but
        // it should, then we'll report an error.

	if (pv != NULL || fCheckNullSource)
	{
	    ULONG cbZero = DwordRemain(cbCopy);

            // Do we have a destination (propset) buffer?

	    if (pprop != NULL)
	    {
                // Does this property have a count field?
		if (pcount != NULL)
		{
                    // Write the count & advance pbdst
		    *(ULONG *) pbdst = PropByteSwap( *pcount );
		    pbdst += sizeof(ULONG);
		}

                // Is this a VT_CF?
		if (pclipfmt != NULL)
		{
                    // Write the ClipFormat & advance pbdst
		    *(ULONG *) pbdst = PropByteSwap( (DWORD) *pclipfmt );
		    pbdst += sizeof(ULONG);
		}
	    }

            // Are we missing the source data?
	    if (pv == NULL)
	    {
		// The Source pointer is NULL.  If cbCopy != 0, the passed
		// VARIANT is not properly formed.

		if (cbCopy != 0)
		{
		    StatusInvalidParameter(pstatus, "RtlConvertVariantToProperty: bad NULL");
                    goto Exit;
		}
	    }
	    else if (pprop != NULL)
	    {
                // We have a non-NULL source & destination.
                // First, copy the bytes from the former to the latter.

		RtlCopyMemory(pbdst, pv, cbCopy);

                // Then, if necessary, swap the bytes in the property
                // set (leaving the PropVariant bytes untouched).

                PBSBuffer( (VOID*) pbdst, cbCopy, cbByteSwap );
	    }

            // Did we write the serialization?
	    if (pprop != NULL)
	    {
                // Zero the padding bytes.
		RtlZeroMemory(pbdst + cbCopy, cbZero);

		// Canonicalize VARIANT_BOOLs.  We do this here because
		// we don't want to muck with the caller's buffer directly.

		if ((pvar->vt & ~VT_VECTOR) == VT_BOOL)
		{
		    VARIANT_BOOL *pvb = (VARIANT_BOOL *) pbdst;
		    VARIANT_BOOL *pvbEnd = &pvb[cbCopy/sizeof(*pvb)];

		    while (pvb < pvbEnd)
		    {
			if (*pvb
                            &&
                            PropByteSwap(*pvb) != VARIANT_TRUE)
			{
			    DebugTrace(0, DEBTRACE_ERROR, (
				"Patching VARIANT_TRUE value: %hx --> %hx\n",
				*pvb,
				VARIANT_TRUE));

                            *pvb = PropByteSwap( (VARIANT_BOOL) VARIANT_TRUE );
			}
			pvb++;
		    }
		}
	    }   // if (pprop != NULL)
	}
    }   // if (cbch != 0) ... else    // non - STRING/VARIANT/CF VECTOR property

    // Set the VT in the serialized buffer now that all size
    // checks completed.

    if (pprop != NULL && pvar->vt != VT_EMPTY)
    {
        // When byte-swapping the VT, treat it as a DWORD
        // (it's a WORD in the PropVariant, but a DWORD when
        // serialized).

	pprop->dwType = PropByteSwap( (DWORD) pvar->vt );
    }

    // Update the caller's copy of the total size.
    *pcb = DwordAlign(cb);

Exit:

    delete [] pchConvert;
    return(pprop);

}


//+---------------------------------------------------------------------------
// Function:    RtlConvertPropertyToVariant, private
//
// Synopsis:    Convert a SERIALIZEDPROPERTYVALUE to a PROPVARIANT
//
// Arguments:   [pprop]         -- pointer to SERIALIZEDPROPERTYVALUE
//              [PointerDelta]	-- adjustment to pointers to get user addresses
//              [fConvertNullStrings] -- map NULL strings to empty strings
//              [CodePage]	-- property set codepage
//              [pvar]          -- pointer to PROPVARIANT
//              [pma]		-- caller's memory allocation routine
//              [pstatus]       -- pointer to NTSTATUS code
//
//---------------------------------------------------------------------------

#define ADJUSTPOINTER(ptr, delta, type)
VOID
RtlConvertPropertyToVariant( IN SERIALIZEDPROPERTYVALUE const *pprop,
                             IN USHORT CodePage,
                             OUT PROPVARIANT *pvar,
                             IN PMemoryAllocator *pma,
                             OUT NTSTATUS *pstatus)
{
    *pstatus = STATUS_SUCCESS;

    //  ------
    //  Locals
    //  ------

    // Buffers which must be freed before exiting.
    CHAR *pchConvert = NULL, *pchByteSwap = NULL;

    VOID **ppv = NULL;
    VOID *pv = NULL;
    ULONG cbskip = sizeof(ULONG);
    ULONG cb = 0;

    // Size of byte-swapping units (must be signed).
    INT cbByteSwap = 0;

    BOOLEAN fPostAllocInit = FALSE;
    BOOLEAN fNullLegal = (BOOLEAN) ( (PropByteSwap(pprop->dwType) & VT_VECTOR) != 0 );
    const BOOLEAN fConvertToEmpty = FALSE;

    //  ---------------------------------------------------------
    //  Based on the VT, calculate cch, ppv, pv, cbskip,
    //  cb, fPostAllocInit, fNullLegal, & fConvertToEmpty
    //  ---------------------------------------------------------

    // Set the VT in the PropVariant.  Note that in 'pprop' it's a
    // DWORD, but it's a WORD in 'pvar'.

    pvar->vt = (VARTYPE) PropByteSwap(pprop->dwType);

    switch (pvar->vt)
    {
	case VT_EMPTY:
	case VT_NULL:
	    break;

#ifdef PROPVAR_VT_I1
        case VT_I1:
            AssertByteField(cVal);          // VT_I1
#endif
	case VT_UI1:
	    AssertByteField(bVal);          // VT_UI1
	    cb = sizeof(pvar->bVal);
	    pv = &pvar->bVal;
	    break;

	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
	    AssertShortField(iVal);         // VT_I2
	    AssertShortField(uiVal);        // VT_UI2
	    AssertShortField(boolVal);      // VT_BOOL
	    cb = sizeof(pvar->iVal);
	    pv = &pvar->iVal;

            // If swapping, swap as a WORD
            CBBYTESWAP(cb);
	    break;

	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_ERROR:
	    AssertLongField(lVal);          // VT_I4
	    AssertLongField(ulVal);         // VT_UI4
	    AssertLongField(fltVal);        // VT_R4
	    AssertLongField(scode);         // VT_ERROR
	    cb = sizeof(pvar->lVal);
	    pv = &pvar->lVal;

            // If swapping, swap as a DWORD
            CBBYTESWAP(cb);
	    break;

	case VT_I8:
	case VT_UI8:
	case VT_FILETIME:
	    AssertLongLongField(hVal);		// VT_I8
	    AssertLongLongField(uhVal);		// VT_UI8
	    AssertLongLongField(filetime);	// VT_FILETIME
	    cb = sizeof(pvar->hVal);
	    pv = &pvar->hVal;

            // If swapping, swap as a pair of DWORDs
            CBBYTESWAP(sizeof(DWORD));
	    break;

	case VT_R8:
	case VT_CY:
	case VT_DATE:
	    AssertLongLongField(dblVal);	// VT_R8
	    AssertLongLongField(cyVal);		// VT_CY
	    AssertLongLongField(date);		// VT_DATE
	    cb = sizeof(pvar->dblVal);
	    pv = &pvar->dblVal;

            // If swapping, swap as a LONGLONG
            CBBYTESWAP(cb);
	    break;

	case VT_CLSID:
	    AssertStringField(puuid);		// VT_CLSID
	    cb = sizeof(GUID);
	    ppv = (VOID **) &pvar->puuid;
	    cbskip = 0;

            // If swapping, special handling is required
            CBBYTESWAP( CBBYTESWAP_UID );
	    break;

	case VT_CF:

            // Allocate a CLIPDATA buffer
	    pvar->pclipdata = (CLIPDATA *) pma->Allocate(sizeof(CLIPDATA));
	    if (pvar->pclipdata == NULL)
	    {
		StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for CF");
                goto Exit;
	    }
            RtlZeroMemory( pvar->pclipdata, sizeof(CLIPDATA) );

            // Set the size (includes sizeof(ulClipFmt))
	    pvar->pclipdata->cbSize = PropByteSwap( ((CLIPDATA *) pprop->rgb)->cbSize );
            if( pvar->pclipdata->cbSize < sizeof(pvar->pclipdata->ulClipFmt) )
            {
                StatusError(pstatus, "RtlConvertPropertyToVariant:  Invalid VT_CF cbSize",
                            STATUS_INTERNAL_DB_CORRUPTION);
                goto Exit;
            }

            // Set the # bytes-to-copy.  We can't use the CBPCLIPDATA macro
            // here because it assumes that the CLIPDATA parameter is correctly
            // byte-swapped.
	    cb = PropByteSwap( *(DWORD*) pprop->rgb ) - sizeof(pvar->pclipdata->ulClipFmt);

            // Set the ClipFormat itself.
	    pvar->pclipdata->ulClipFmt = PropByteSwap( ((CLIPDATA *) pprop->rgb)->ulClipFmt );

            // Prepare for the alloc & copy.  Put the buffer pointer
            // in pClipData, & skip the ulClipFmt in the copy.
	    ppv = (VOID **) &pvar->pclipdata->pClipData;
	    cbskip += sizeof(ULONG);

            // It's legal for cb to be 0.
            fNullLegal = TRUE;

            // Adjust to the user-mode pointer (Kernel only)
	    ADJUSTPOINTER(pvar->pclipdata, PointerDelta, CLIPDATA *);

	    break;

	case VT_BLOB:
	case VT_BLOB_OBJECT:
	    cb = pvar->blob.cbSize = PropByteSwap( *(ULONG *) pprop->rgb );
	    ppv = (VOID **) &pvar->blob.pBlobData;
	    fNullLegal = TRUE;
	    break;

	case VT_BSTR:
	case VT_LPSTR:
	    AssertStringField(bstrVal);		// VT_BSTR
	    AssertStringField(pszVal);		// VT_LPSTR

            // [length field] bytes should be allocated
	    cb = PropByteSwap( *(ULONG *) pprop->rgb );

            // When a buffer is allocated, it's pointer will go
            // in *ppv.
	    ppv = (VOID **) &pvar->pszVal;

            // Is this a non-empty string?
	    if (cb != 0)
	    {
                // Is the serialized value one that should be
                // an Ansi string in the PropVariant?

		if (pvar->vt == VT_LPSTR        // It's an LPSTR (always Ansi), or
                    ||
                    pvar->vt == VT_BSTR         // It's a BSTR and
                    &&
                    !OLECHAR_IS_UNICODE )       //    BSTRs are Ansi.
		{
                    // If the propset is Unicode, we must do a
                    // conversion to Ansi.

		    if (CodePage == CP_WINUNICODE)
		    {
                        WCHAR *pwsz = (WCHAR *) Add2ConstPtr(pprop->rgb, sizeof(ULONG));

                        // If necessary, swap the WCHARs.  'pwsz' will point to
                        // the correct (system-endian) string either way.  If an
                        // alloc is necessary, 'pchByteSwap' will point to the new
                        // buffer.

                        PBSInPlaceAlloc( &pwsz, (WCHAR**) &pchByteSwap, pstatus );
                        if( !NT_SUCCESS( *pstatus )) goto Exit;
			PROPASSERT(IsUnicodeString( pwsz, cb));

                        // Convert the properly-byte-ordered string in 'pwsz'
                        // into MBCS, putting the result in pchConvert.

			RtlpConvertToMultiByte(
				    pwsz,
				    cb,
				    CP_ACP,  // Use the system default codepage
				    &pchConvert,
				    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
		    }
		}   // if (pvar->vt == VT_LPSTR) ...

                // Otherwise, even though this string may be
                // Ansi in the Property Set, it must be Unicode
                // in the PropVariant.

		else
		{
                    // If necessary, convert to Unicode

		    if (CodePage != CP_WINUNICODE)
		    {
			PROPASSERT(
			    IsAnsiString(
				    (CHAR const *)
					Add2ConstPtr(pprop->rgb, sizeof(ULONG)),
				    cb));

			RtlpConvertToUnicode(
				    (CHAR const *)
					Add2ConstPtr(pprop->rgb, sizeof(ULONG)),
				    cb,
				    CodePage,
				    (WCHAR **) &pchConvert,
				    &cb,
                                    pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

		    }   // if (CodePage != CP_WINUNICODE)
                    else
                    {
                        // The value is Unicode both the property set
                        // and the PropVariant.  If byte-swapping is
                        // necessary, we'll do so in units of WCHARs.

                        CBBYTESWAP( sizeof(WCHAR) );
                    }

		}   // if (pvar->vt == VT_LPSTR) ... else

                // If this is a BSTR property, verify that it is terminated
                // appropriately.

		if (VT_BSTR == pvar->vt)
		{
                    BSTR bstr = ( NULL == pchConvert )
                                ? (BSTR) Add2ConstPtr(pprop->rgb, sizeof(ULONG))
                                : (BSTR) pchConvert;

                    // On little-endian machines, validate the string.
#ifdef LITTLEENDIAN
                    PROPASSERT( IsOLECHARString( bstr, MAXULONG ));
#endif

                    // Validate the bstr.  Note that even though this bstr may
                    // be byte-swapped, this 'if' block still works because
                    // ByteSwap('\0') == ('\0').


                    if( (cb & (sizeof(OLECHAR) - 1)) != 0
                        &&
                        OLECHAR_IS_UNICODE
                        ||
                        bstr[cb/sizeof(OLECHAR) - 1] != ((OLECHAR)'\0') )
                    {
                        StatusError(pstatus, "RtlConvertPropertyToVariant:  Invalid BSTR Property",
                                     STATUS_INTERNAL_DB_CORRUPTION);
                        goto Exit;
                    }
		}   // if (VT_BSTR == pvar->vt)
	    }   // if (cb != 0)

	    fNullLegal = TRUE;
	    break;

	case VT_LPWSTR:
	    fNullLegal = TRUE;
	    AssertStringField(pwszVal);		// VT_LPWSTR
	    cb = PropByteSwap( *(ULONG *) pprop->rgb ) * sizeof(WCHAR);
	    ppv = (VOID **) &pvar->pwszVal;

            // If byte-swapping will be necessary, do so for the WCHARs
            CBBYTESWAP( sizeof(WCHAR) );

	    break;

#ifdef PROPVAR_VT_I1
	case VT_VECTOR | VT_I1:
            AssertByteVector(cac);              // VT_I1
#endif
	case VT_VECTOR | VT_UI1:
	    AssertByteVector(caub);		// VT_UI1
	    pvar->caub.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->caub.cElems * sizeof(pvar->caub.pElems[0]);
	    ppv = (VOID **) &pvar->caub.pElems;
	    break;

	case VT_VECTOR | VT_I2:
	case VT_VECTOR | VT_UI2:
	case VT_VECTOR | VT_BOOL:
	    AssertShortVector(cai);		// VT_I2
	    AssertShortVector(caui);		// VT_UI2
	    AssertShortVector(cabool);		// VT_BOOL
	    pvar->cai.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cai.cElems * sizeof(pvar->cai.pElems[0]);
	    ppv = (VOID **) &pvar->cai.pElems;

            // If swapping, swap as a WORD
            CBBYTESWAP(sizeof(pvar->cai.pElems[0]));
	    break;

	case VT_VECTOR | VT_I4:
	case VT_VECTOR | VT_UI4:
	case VT_VECTOR | VT_R4:
	case VT_VECTOR | VT_ERROR:
	    AssertLongVector(cal);		// VT_I4
	    AssertLongVector(caul);		// VT_UI4
	    AssertLongVector(caflt);		// VT_R4
	    AssertLongVector(cascode);		// VT_ERROR
	    pvar->cal.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cal.cElems * sizeof(pvar->cal.pElems[0]);
	    ppv = (VOID **) &pvar->cal.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(pvar->cal.pElems[0]));
	    break;

	case VT_VECTOR | VT_I8:
	case VT_VECTOR | VT_UI8:
	case VT_VECTOR | VT_FILETIME:
	    AssertLongLongVector(cah);		// VT_I8
	    AssertLongLongVector(cauh);		// VT_UI8
	    AssertLongLongVector(cafiletime);	// VT_FILETIME
	    pvar->cah.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cah.cElems * sizeof(pvar->cah.pElems[0]);
	    ppv = (VOID **) &pvar->cah.pElems;

            // If byte swapping, swap as DWORDs
            CBBYTESWAP(sizeof(DWORD));
	    break;

	case VT_VECTOR | VT_R8:
	case VT_VECTOR | VT_CY:
	case VT_VECTOR | VT_DATE:
	    AssertLongLongVector(cadbl);	// VT_R8
	    AssertLongLongVector(cacy);		// VT_CY
	    AssertLongLongVector(cadate);	// VT_DATE
	    pvar->cadbl.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cadbl.cElems * sizeof(pvar->cadbl.pElems[0]);
	    ppv = (VOID **) &pvar->cadbl.pElems;

            // If byte swapping, swap as LONGLONGs
            CBBYTESWAP(sizeof(pvar->cah.pElems[0]));
	    break;


	case VT_VECTOR | VT_CLSID:
	    AssertVarVector(cauuid, sizeof(GUID));
	    pvar->cauuid.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->cauuid.cElems * sizeof(pvar->cauuid.pElems[0]);
	    ppv = (VOID **) &pvar->cauuid.pElems;

            // If byte swapping, special handling is required.
            CBBYTESWAP( CBBYTESWAP_UID );
	    break;

	case VT_VECTOR | VT_CF:

            // Set the count of clipdatas
	    pvar->caclipdata.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // How much should we allocate for caclipdata.pElems, & where
            // should that buffer pointer go?
	    cb = pvar->caclipdata.cElems * sizeof(pvar->caclipdata.pElems[0]);
	    ppv = (VOID **) &pvar->caclipdata.pElems;

            // We need to do work after pElems is allocated.
	    fPostAllocInit = TRUE;
	    break;

	case VT_VECTOR | VT_BSTR:
	case VT_VECTOR | VT_LPSTR:
	    AssertStringVector(cabstr);     // VT_BSTR
	    AssertStringVector(calpstr);    // VT_LPSTR

            // Put the element count in the PropVar
	    pvar->calpstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );

            // An array of cElems pointers should be alloced
	    cb = pvar->calpstr.cElems * sizeof(CHAR*);

            // Show where the array of pointers should go.
	    ppv = (VOID **) &pvar->calpstr.pElems;

            // Additional allocs will be necessary after the vector
            // is alloced.
	    fPostAllocInit = TRUE;

	    break;

	case VT_VECTOR | VT_LPWSTR:
	    AssertStringVector(calpwstr);	// VT_LPWSTR
	    pvar->calpwstr.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->calpwstr.cElems * sizeof(ULONG);
	    ppv = (VOID **) &pvar->calpwstr.pElems;
	    fPostAllocInit = TRUE;
	    break;

	case VT_VECTOR | VT_VARIANT:
	    AssertVariantVector(capropvar);	// VT_VARIANT
	    pvar->capropvar.cElems = PropByteSwap( *(ULONG *) pprop->rgb );
	    cb = pvar->capropvar.cElems * sizeof(PROPVARIANT);
	    ppv = (VOID **) &pvar->capropvar.pElems;
	    fPostAllocInit = TRUE;
     	    break;

	default:
	    DebugTrace(0, DEBTRACE_ERROR, (
		"RtlConvertPropertyToVariant: unsupported vt=%x\n",
		pvar->vt));
	    StatusInvalidParameter(pstatus, "RtlConvertPropertyToVariant: bad type");
            goto Exit;

    }   // switch (pvar->vt)

    //  ------------------------------------------------------
    //  We've now analyzed the serialized property and learned
    //  about it, now we can put it into the PropVariant.
    //  ------------------------------------------------------

    // Is this a simple, unaligned scalar?

    if (pv != NULL)
    {
        // Yes.  All we need to do is copy some bytes.
	PROPASSERT(pchConvert == NULL);
	RtlCopyMemory(pv, pprop->rgb, cb);

        // We also might need to byte-swap them (but only in the PropVar).
        PBSBuffer( pv, cb, cbByteSwap );
    }

    // Otherwise, we need to allocate memory, to which the
    // PropVariant will point.

    else if (ppv != NULL)
    {
	*ppv = NULL;

	if (!fConvertToEmpty && cb == 0)    // Kernel only
	{
	    if (!fNullLegal)
	    {
		StatusInvalidParameter(pstatus, "RtlConvertPropertyToVariant: bad NULL");
                goto Exit;
	    }
	}

        else
	{

	    PROPASSERT(cb != 0 || fConvertToEmpty);

            // Allocate the necessary buffer (which we figured out in the
            // switch above).  For vector properties, 
            // this will just be the pElems buffer at this point.
            // For singleton BSTR properties, we'll skip this allocate
            // altogether; they're allocated with SysStringAlloc.

            if( VT_BSTR != pvar->vt  )
            {
		*ppv = pma->Allocate(max(1, cb));
		if (*ppv == NULL)
		{
		    StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory");
                    goto Exit;
		}
            }

            // Can we load the PropVariant with a simple copy?
	    if (!fPostAllocInit)
	    {
                // Yes - all we need is a copy (and an implicit
                // alloc for BSTRs).

                if (VT_BSTR == pvar->vt)
		{
                    // We do the copy with the OleAutomation routine
                    // (which does an allocation too).
                    // If byte-swapping is necessary, the switch block
                    // already took care of it, leaving the buffer in
                    // 'pchConvert'.

                    PROPASSERT( NULL == *ppv );
                    *ppv = (*UnicodeCallouts.pfnSysAllocString)(
                                            ( pchConvert != NULL )
                                                ? (OLECHAR *) pchConvert
                                                : (OLECHAR *) (pprop->rgb + cbskip) );
		    if (*ppv == NULL)
		    {
		        StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory");
                        goto Exit;
		    }
		}
                else
                {
                    // Copy the property into the PropVariant.
		    RtlCopyMemory(
			    *ppv,
			    pchConvert != NULL?
				(BYTE const *) pchConvert : pprop->rgb + cbskip,
			    cb);

                }

                // If necessary, byte-swap the property (only in the PropVar).
                PBSBuffer( *ppv, cb, cbByteSwap );

	    }   // if (!fPostAllocInit)

	    else
	    {
                // We must do more than just a copy.
                // (Thus this is a vector of strings, variants, or CFs).

		ULONG cElems = pvar->calpstr.cElems;

                // Initialize the source pointer to point just beyond
                // the element count.

		BYTE const *pbsrc = pprop->rgb + sizeof(ULONG);

		// Zero all pointers in the pElems array for easy caller cleanup
		ppv = (VOID **) *ppv;
		RtlZeroMemory(ppv, cb);

                // Handle Variants, ClipFormats, & Strings separately.

		if (pvar->vt == (VT_VECTOR | VT_VARIANT))
		{
		    PROPVARIANT *pvarT = (PROPVARIANT *) ppv;

		    while (cElems-- > 0)
		    {
			ULONG cbelement;

			RtlConvertPropertyToVariant(
                            (SERIALIZEDPROPERTYVALUE const *) pbsrc,
                            CodePage,
                            pvarT,
                            pma,
                            pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                        
			cbelement = PropertyLength(
					(SERIALIZEDPROPERTYVALUE const *) pbsrc,
					MAXULONG,
					CPSS_VARIANTVECTOR,
                                        pstatus);
                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
                        
			pbsrc += cbelement;
			pvarT++;
		    }
		}   // if (pvar->vt == (VT_VECTOR | VT_VARIANT))

		else if (pvar->vt == (VT_VECTOR | VT_CF))
		{
                    // Set pcd to &pElems[0]
		    CLIPDATA *pcd = (CLIPDATA *) ppv;

                    // Loop through pElems
		    while (cElems-- > 0)
		    {
                        // What is the size of the clipdata (including sizeof(ulClipFmt))?
                        pcd->cbSize = PropByteSwap( ((CLIPDATA *) pbsrc)->cbSize );
                        if( pcd->cbSize < sizeof(pcd->ulClipFmt) )
                        {
                            StatusError(pstatus, "RtlConvertPropertyToVariant:  Invalid VT_CF cbSize",
                                        STATUS_INTERNAL_DB_CORRUPTION);
                            goto Exit;
                        }

                        // How many bytes should we copy to pClipData?
			cb = CBPCLIPDATA( *pcd );

                        // Set the ClipFormat & advance pbsrc to the clipdata.
			pcd->ulClipFmt = PropByteSwap( ((CLIPDATA *) pbsrc)->ulClipFmt );
			pbsrc += 2 * sizeof(ULONG);

                        // Copy the ClipData into the PropVariant

			pcd->pClipData = NULL;
			if (cb > 0)
			{
                            // Get a buffer for the clip data.
			    pcd->pClipData = (BYTE *) pma->Allocate(cb);
			    if (pcd->pClipData == NULL)
			    {
				StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for CF[]");
                                goto Exit;
			    }

                            // Copy the clipdata into pElems[i].pClipData
			    RtlCopyMemory(pcd->pClipData, pbsrc, cb);
			    ADJUSTPOINTER(pcd->pClipData, PointerDelta, BYTE *);

			}   // if (cb > 0)

                        // Move pcd to &pElems[i+1], and advance the buffer pointer.
			pcd++;
			pbsrc += DwordAlign(cb);

		    }   // while (cElems-- > 0)
		}   // else if (pvar->vt == (VT_VECTOR | VT_CF))

		else    // This is a vector of some kind of string.
		{
                    // Assume that characters are CHARs
		    ULONG cbch = sizeof(char);

		    if (pvar->vt == (VT_VECTOR | VT_LPWSTR))
		    {
                        // Characters are WCHARs
			cbch = sizeof(WCHAR);

                        // If byte-swapping is enabled, LPWSTRs must have
                        // their WCHARs swapped.
                        CBBYTESWAP( sizeof(WCHAR) );
		    }

		    while (cElems-- > 0)
		    {
			ULONG cbcopy;

			cbcopy = cb = PropByteSwap( *((ULONG *) pbsrc) ) * cbch;
			pbsrc += sizeof(ULONG);
			pv = (VOID *) pbsrc;
			PROPASSERT(*ppv == NULL);
			PROPASSERT(pchConvert == NULL);

			if (fConvertToEmpty || cb != 0)
			{
                            // Do we have actual data to work with?
			    if (cb != 0)
			    {
                                // Special BSTR pre-processing ...
				if (pvar->vt == (VT_VECTOR | VT_BSTR))
				{
                                    // If the propset & in-memory BSTRs are of
                                    // different Unicode-ness, convert now.

				    if (CodePage != CP_WINUNICODE   // Ansi PropSet
                                        &&
                                        OLECHAR_IS_UNICODE )        // Unicode BSTRs
				    {
                                        PROPASSERT(IsAnsiString((CHAR*) pv, cb));
					RtlpConvertToUnicode(
						    (CHAR const *) pv,
						    cb,
						    CodePage,
						    (WCHAR **) &pchConvert,
						    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
					pv = pchConvert;
				    }

                                    else
                                    if (CodePage == CP_WINUNICODE   // Unicode PropSet
                                        &&
                                        !OLECHAR_IS_UNICODE )       // Ansi BSTRs
                                    {
                                        // If byte-swapping is necessary, the string from
                                        // the propset must be swapped before it can be
                                        // converted to MBCS.  If such a conversion
                                        // is necessary, a new buffer is alloced and 
                                        // put in pchByteSwap.  Either way, 'pv' points
                                        // to the correct string.

                                        PBSInPlaceAlloc( (WCHAR**) &pv,
                                                         (WCHAR**) &pchByteSwap,
                                                         pstatus );
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
			                PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                        // Convert the Unicode string from the property
                                        // set to Ansi.

			                RtlpConvertToMultiByte(
				                    (WCHAR const *) pv,
				                    cb,
				                    CP_ACP,  // Use the system default codepage
				                    &pchConvert,
				                    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                        // 'pv' always has the correct string.
                                        pv = pchConvert;
                                    }
                                    else
                                    if (CodePage == CP_WINUNICODE)
                                    {
                                        // Both the BSTR is unicode in the property set,
                                        // and must remain unicode in the PropVariant.
                                        // But byte-swapping may still be necessary.

                                        CBBYTESWAP( sizeof(WCHAR) );
                                    }
                                                            

#ifdef LITTLEENDIAN
                                    PROPASSERT( IsOLECHARString((BSTR)pv, cbcopy ));
#endif
                                    // Verify that the BSTR is valid.
                                    if( (cbcopy & (sizeof(OLECHAR)-1)) != 0
                                        &&
                                        OLECHAR_IS_UNICODE
                                        ||
                                        ((OLECHAR const *)
                                         pv)[cbcopy/sizeof(OLECHAR) - 1] !=
                                        ((OLECHAR)'\0') )
                                    {
                                        StatusError(
                                            pstatus, 
                                            "RtlConvertPropertyToVariant:"
                                            "  Invalid BSTR element",
                                            STATUS_INTERNAL_DB_CORRUPTION);
                                        goto Exit;
                                    }

				}   // if (pvar->vt == (VT_VECTOR | VT_BSTR))

                                // Special LPSTR pre-processing
				else if (pvar->vt == (VT_VECTOR | VT_LPSTR))
				{
                                    // LPSTRs are always Ansi.  If the string
                                    // is Unicode in the propset, convert now.

				    if (CodePage == CP_WINUNICODE)
				    {
                                        // If byte-swapping is necessary, the string from
                                        // the propset must be swapped before it can be
                                        // converted to MBCS.  If such a conversion
                                        // is necessary, a new buffer is alloced and 
                                        // put in pchByteSwap.  Either way, 'pv' points
                                        // to the correct string.

                                        PBSInPlaceAlloc( (WCHAR**) &pv, (WCHAR**) &pchByteSwap,
                                                      pstatus );
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;
					PROPASSERT(IsUnicodeString((WCHAR*)pv, cb));

                                        // Convert to Ansi.
					RtlpConvertToMultiByte(
						    (WCHAR const *) pv,
						    cb,
						    CP_ACP,     // Use the system default codepage
						    &pchConvert,
						    &cbcopy,
                                                    pstatus);
                                        if( !NT_SUCCESS(*pstatus) ) goto Exit;

                                        pv = pchConvert;
				    }

                                    PROPASSERT( IsAnsiString( (CHAR const *)pv, cbcopy ));
				}   // else if (pvar->vt == (VT_VECTOR | VT_LPSTR))
			    }   // if (cb != 0)


                            // Allocate memory in the PropVariant and copy
                            // the string.

                            if( (VT_BSTR | VT_VECTOR) == pvar->vt )
                            {
                                // For BSTRs, the allocate/copy is performed
                                // by SysStringAlloc.

                                *ppv = (*UnicodeCallouts.pfnSysAllocString)( (BSTR) pv );
				if (*ppv == NULL)
				{
				    StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for BSTR element");
                                    goto Exit;
				}

                                // The BSTR length should be the property length
                                // minus the NULL.
                                PROPASSERT( BSTRLEN(*ppv) == cbcopy - sizeof(OLECHAR) );

                            }   // if( VT_BSTR == pvar->vt )

                            else
                            {
                                // Allocate a buffer in the PropVariant
				*ppv = pma->Allocate(max(1, cbcopy));
				if (*ppv == NULL)
				{
				    StatusKBufferOverflow(pstatus, "RtlConvertPropertyToVariant: no memory for string element");
                                    goto Exit;
				}

                                // Copy from the propset buffer to the PropVariant
				RtlCopyMemory(*ppv, pv, cbcopy);

                            }   // if( VT_BSTR == pvar->vt ) ... else

                            // If necessary, byte-swap in the PropVariant to get
                            // the proper byte-ordering.
                            PBSBuffer( *ppv, cbcopy, cbByteSwap );

                            // Adjust the PropVar element ptr to user-space (kernel only)
			    ADJUSTPOINTER(*ppv, PointerDelta, VOID *);

                            // Move, within the propset buffer, to the
                            // next element in the vector.
			    pbsrc += DwordAlign(cb);

                            // Delete the temporary buffers

                            delete[] pchByteSwap;
                            pchByteSwap = NULL;

			    delete [] pchConvert;
			    pchConvert = NULL;

			}   // if (fConvertToEmpty || cb != 0)

                        // Move, within the PropVariant, to the next
                        // element in the vector.
			ppv++;

		    }   // while (cElems-- > 0)
		}   // else if (pvar->vt == (VT_VECTOR | VT_CF)) ... else
	    }   // if (!fPostAllocInit) ... else

	    ADJUSTPOINTER(*ppvK, PointerDelta, VOID *);

	}   // if (!fConvertToEmpty && cb == 0) ... else
    }   // else if (ppv != NULL)

Exit:

    delete[] pchByteSwap;
    delete [] pchConvert;
}


//+---------------------------------------------------------------------------
// Function:    CleanupVariants, private
//
// Synopsis:    Free all memory used by an array of PROPVARIANT
//
// Arguments:   [pvar]          -- pointer to PROPVARIANT
//              [cprop]         -- property count
//              [pma]		-- caller's memory free routine
//
// Returns:     None
//---------------------------------------------------------------------------

VOID
CleanupVariants(
    IN PROPVARIANT *pvar,
    IN ULONG cprop,
    IN PMemoryAllocator *pma)
{
    while (cprop-- > 0)
    {
	VOID *pv = NULL;
	VOID **ppv = NULL;

	ULONG cElems;

	switch (pvar->vt)
	{
	case VT_CF:
	    pv = pvar->pclipdata;
	    if (pv != NULL && pvar->pclipdata->pClipData)
	    {
		pma->Free(pvar->pclipdata->pClipData);
	    }
	    break;

	case VT_BLOB:
	case VT_BLOB_OBJECT:
	    pv = pvar->blob.pBlobData;
	    break;

	case VT_BSTR:
	case VT_CLSID:
	case VT_LPSTR:
	case VT_LPWSTR:
	    AssertStringField(puuid);		// VT_CLSID
	    AssertStringField(bstrVal);		// VT_BSTR
	    AssertStringField(pszVal);		// VT_LPSTR
	    AssertStringField(pwszVal);		// VT_LPWSTR
	    pv = pvar->pszVal;
	    break;

	// Vector properties:

#ifdef PROPVAR_VT_I1
	case VT_VECTOR | VT_I1:
	    AssertByteVector(cac);			// VT_I1
#endif
	case VT_VECTOR | VT_UI1:
	case VT_VECTOR | VT_I2:
	case VT_VECTOR | VT_UI2:
	case VT_VECTOR | VT_BOOL:
	case VT_VECTOR | VT_I4:
	case VT_VECTOR | VT_UI4:
	case VT_VECTOR | VT_R4:
	case VT_VECTOR | VT_ERROR:
	case VT_VECTOR | VT_I8:
	case VT_VECTOR | VT_UI8:
	case VT_VECTOR | VT_R8:
	case VT_VECTOR | VT_CY:
	case VT_VECTOR | VT_DATE:
	case VT_VECTOR | VT_FILETIME:
	case VT_VECTOR | VT_CLSID:
	    AssertByteVector(caub);			// VT_UI1
	    AssertShortVector(cai);			// VT_I2
	    AssertShortVector(caui);			// VT_UI2
	    AssertShortVector(cabool);			// VT_BOOL
	    AssertLongVector(cal);			// VT_I4
	    AssertLongVector(caul);			// VT_UI4
	    AssertLongVector(caflt);			// VT_R4
	    AssertLongVector(cascode);			// VT_ERROR
	    AssertLongLongVector(cah);			// VT_I8
	    AssertLongLongVector(cauh);			// VT_UI8
	    AssertLongLongVector(cadbl);		// VT_R8
	    AssertLongLongVector(cacy);			// VT_CY
	    AssertLongLongVector(cadate);		// VT_DATE
	    AssertLongLongVector(cafiletime);		// VT_FILETIME
	    AssertVarVector(cauuid, sizeof(GUID));	// VT_CLSID
	    pv = pvar->cai.pElems;
	    break;

	case VT_VECTOR | VT_CF:
	    {
		CLIPDATA *pcd;

		cElems = pvar->caclipdata.cElems;
		pv = pcd = pvar->caclipdata.pElems;
		while (cElems-- > 0)
		{
		    if (pcd->pClipData != NULL)
		    {
			pma->Free(pcd->pClipData);
		    }
		    pcd++;
		}
	    }
	    break;

	case VT_VECTOR | VT_BSTR:
	case VT_VECTOR | VT_LPSTR:
	case VT_VECTOR | VT_LPWSTR:
	    AssertStringVector(cabstr);			// VT_BSTR
	    AssertStringVector(calpstr);		// VT_LPSTR
	    AssertStringVector(calpwstr);		// VT_LPWSTR
	    cElems = pvar->calpstr.cElems;
	    ppv = (VOID **) pvar->calpstr.pElems;
	    break;

	case VT_VECTOR | VT_VARIANT:
	    CleanupVariants(
		    pvar->capropvar.pElems,
		    pvar->capropvar.cElems,
		    pma);
	    pv = pvar->capropvar.pElems;
	    break;

	}   // switch (pvar->vt)

	if (ppv != NULL)			// STRING VECTOR property
	{
            // Save the vector of pointers
	    pv = (VOID *) ppv;

            // Free the vector elements
	    while (cElems-- > 0)
	    {
		if (*ppv != NULL)
		{
                    if( (VT_BSTR | VT_VECTOR) == pvar->vt )
                    {
                        (*UnicodeCallouts.pfnSysFreeString)( (BSTR) *ppv );
                    }
                    else
                    {
		        pma->Free((BYTE *) *ppv);
                    }
		}
		ppv++;
	    }

            // Free the vector of pointers.
            pma->Free(pv);
            pv = NULL;

	}   // if (ppv != NULL)

	if (pv != NULL)
	{
            if( VT_BSTR == pvar->vt )
            {
                (*UnicodeCallouts.pfnSysFreeString)( (BSTR) pv );
            }
            else
            {
                pma->Free((BYTE *) pv);
            }
        }

	pvar->vt = VT_EMPTY;

        // Move on to the next PropVar in the vector.
	pvar++;

    }   // while (cprop-- > 0)
}


//+--------------------------------------------------------------------------
// Function:    PropertyLength
//
// Synopsis:    compute the length of a property including the variant type
//
// Arguments:   [pprop]         -- property value
//              [cbbuf]         -- max length of accessible memory at pprop
//              [flags]		-- CPropertySetStream flags
//              [pstatus]       -- pointer to NTSTATUS code
//
// Returns:     length of property
//---------------------------------------------------------------------------

ULONG
PropertyLength(
    SERIALIZEDPROPERTYVALUE const *pprop,
    ULONG cbbuf,
    BYTE flags,
    OUT NTSTATUS *pstatus)
{
    ULONG const *pl = (ULONG const *) pprop->rgb;
    ULONG cElems = 1;
    ULONG cbremain = cbbuf;
    ULONG cb = 0, cbch;
    BOOLEAN fIllegalType = FALSE;

    *pstatus = STATUS_SUCCESS;

    if (cbremain < CB_SERIALIZEDPROPERTYVALUE)
    {
        StatusOverflow(pstatus, "PropertyLength: dwType");
        goto Exit;
    }
    cbremain -= CB_SERIALIZEDPROPERTYVALUE;
    if( PropByteSwap(pprop->dwType) & VT_VECTOR )
    {
        if (cbremain < sizeof(ULONG))
        {
            StatusOverflow(pstatus, "PropertyLength: cElems");
            goto Exit;
        }
        cbremain -= sizeof(ULONG);
        cElems = PropByteSwap( *pl++ );
    }
    if( PropByteSwap(pprop->dwType) == (VT_VECTOR | VT_VARIANT) )
    {
	while (cElems-- > 0)
	{
	    cb = PropertyLength(
			(SERIALIZEDPROPERTYVALUE const *) pl,
			cbremain,
			flags | CPSS_VARIANTVECTOR,
                        pstatus);
            if( !NT_SUCCESS(*pstatus) ) goto Exit;
	    pl = (ULONG const *) Add2ConstPtr(pl, cb);
	    cbremain -= cb;
        }
    }
    else
    {
        cbch = sizeof(WCHAR);

        switch( PropByteSwap(pprop->dwType) & VT_TYPEMASK)
        {
        case VT_EMPTY:
        case VT_NULL:
            fIllegalType = (flags & CPSS_VARIANTVECTOR) != 0;
            break;

#ifdef PROPVAR_VT_I1
        case VT_I1:
#endif
        case VT_UI1:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(BYTE)));
            break;

        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
            pl = (ULONG const *) Add2ConstPtr(pl, DwordAlign(cElems * sizeof(USHORT)));
            break;

        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_ERROR:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(ULONG));
            break;

        case VT_I8:
        case VT_UI8:
        case VT_R8:
        case VT_CY:
        case VT_DATE:
        case VT_FILETIME:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(LONGLONG));
            break;

        case VT_CLSID:
            pl = (ULONG const *) Add2ConstPtr(pl, cElems * sizeof(GUID));
            break;

        case VT_BLOB:
        case VT_BLOB_OBJECT:
            // FALLTHROUGH

        case VT_CF:
        case VT_BSTR:
        case VT_LPSTR:
            cbch = sizeof(BYTE);
            // FALLTHROUGH

        case VT_LPWSTR:
            while (cElems-- > 0)
            {
                if (cbremain < sizeof(ULONG) ||
                    cbremain < (cb = sizeof(ULONG) + DwordAlign(PropByteSwap(*pl) * cbch)))
                {
                    StatusOverflow(pstatus, "PropertyLength: String/BLOB/CF");
                    goto Exit;
                }

#ifdef LITTLEENDIAN
		PROPASSERT(
		    (PropByteSwap(pprop->dwType) & VT_TYPEMASK) != VT_LPWSTR
                     ||
		     IsUnicodeString( (WCHAR const *) &pl[1],
				       PropByteSwap(*pl) * sizeof(WCHAR)));
#endif

                pl = (ULONG const *) Add2ConstPtr(pl, cb);
                cbremain -= cb;
            }
            break;

        default:
	    fIllegalType = TRUE;
            break;
        }
    }
    if (fIllegalType)
    {
        StatusInvalidParameter(pstatus, "PropertyLength: Illegal VarType");
        goto Exit;
    }
    cb = (BYTE *) pl - (BYTE *) pprop;
    if (cbbuf < cb)
    {
        StatusOverflow(pstatus, "PropertyLength: cb");
        goto Exit;
    }

    // Make sure PropertyLength works when limited to an exact size buffer.
    PROPASSERT(cb == cbbuf || PropertyLength(pprop, cb, flags, pstatus) == cb);

    //  ----
    //  Exit
    //  ----

Exit:

    // Normalize the error return value.
    if( !NT_SUCCESS(*pstatus) )
        cb = 0;

    return(cb);
}


//+--------------------------------------------------------------------------
// Function:    PBSCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine copies the source to the destination, 
//              byte-swapping as it copies.
//
// Arguments:   [VOID*] pvDest
//                  Pointer to the target (swapped) buffer.
//                  This must be pre-allocated by the caller.
//              [VOID*] pvSource
//                  Pointer to the original buffer.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSCopy( OUT VOID *pvDest,
              IN VOID const *pvSource,
              IN ULONG cbCopy,
              IN LONG cbByteSwap )
{
    PROPASSERT( (cbCopy & 1) == 0 );
    PROPASSERT( pvDest != NULL && pvSource != NULL );

    memcpy( pvDest, pvSource, cbCopy );
    PBSBuffer( pvDest, cbCopy, cbByteSwap );
}

#endif  // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSAllocAndCopy
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine allocs a buffer, and swaps the bytes from
//              the source buffer into the destination.
//
// Arguments:   [VOID**] ppvDest (out)
//                  On success will point to the swapped buffer.
//              [VOID*] pvSource (in)
//                  Pointer to the original buffer.
//              [ULONG] cbSize (in)
//                  Size in bytes of the buffer.
//              [LONG] cbByteSwap (in)
//                  Size of byte-swapping units.
//              [NTSTATUS*] pstatus (out)
//                  NTSTATUS code.
//
// Returns:     None.
//
// Note:        The caller is responsible for freeing *ppvDest
//              (using ::delete).
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSAllocAndCopy( OUT VOID **ppvDest,
                      IN VOID const *pvSource,
                      ULONG cbSize,
                      LONG cbByteSwap,
                      OUT NTSTATUS *pstatus)
{
    ULONG cchString;

    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;
    PROPASSERT( ppvDest != NULL && pvSource != NULL );

    // Allocate a buffer.
    *ppvDest = new BYTE[ cbSize ];
    if( NULL == *ppvDest )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap/copy the bytes.
    PBSCopy( *ppvDest, pvSource, cbSize, cbByteSwap );

    //  ----
    //  Exit
    //  ----

Exit:

    return;

}   // PBSAllocAndCopy

#endif // BIGENDIAN

//+--------------------------------------------------------------------------
// Function:    PBSInPlaceAlloc
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a WCHAR array, allocates a new buffer,
//              and swaps the original array into the new buffer.
//              
//
// Arguments:   [WCHAR**] ppwszResult
//                  IN: *ppwszResult points to string to be swapped.
//                  OUT: *ppwszResult points to the swapped string.
//              [WCHAR**] ppwszBuffer
//                  *ppwszBuffer points to the buffer which was allocated
//                  for the swapped bytes (should be the same as *ppwszResult).
//                  *ppwszBuffer must be NULL in input, and must be freed
//                  by the caller (using ::delete).
//              [NTSTATUS*] pstatus
//                  NTSTATUS code.
//
// Returns:     None.
//
// On input, *ppwszResult contains the original string.
// An equivalently sized buffer is allocated in *ppwszBuffer,
// and *ppwszResult is byte-swapped into it.  *ppwszResult
// is then set to the new *ppwszBuffer.
//
// It doesn't appear to useful to have both buffer parameters,
// but it makes it easier on the caller in certain circumstances;
// *ppwszResult always points to the correct string, whether the
// build is BIGENDIAN (alloc & swap takes place) or the build
// is LITTLEENDIAN (nothing happes, so *ppwszResult continues
// to point to the proper string).  The LITTLEENDIAN version of
// this function is implemented as an inline routine.
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSInPlaceAlloc( IN OUT WCHAR** ppwszResult,
                      OUT WCHAR** ppwszBuffer,
                      OUT NTSTATUS *pstatus )
{
    //  ------
    //  Locals
    //  ------

    WCHAR *pwszNewBuffer;

    // Pointers which will walk through the input buffers.
    WCHAR *pwszOriginal, *pwszSwapped;

    //  -----
    //  Begin
    //  -----

    *pstatus = STATUS_SUCCESS;

    // Allocate a new buffer.
    pwszNewBuffer = new WCHAR[ Prop_wcslen(*ppwszResult) + 1 ];
    if( NULL == pwszNewBuffer )
    {
        *pstatus = STATUS_NO_MEMORY;
        goto Exit;
    }

    // Swap the WCHARs into the new buffer.

    pwszOriginal = *ppwszResult;
    pwszSwapped = pwszNewBuffer;

    do
    {
        *pwszSwapped = PropByteSwap(*pwszOriginal++);
    }   while( *pwszSwapped++ != L'\0' );

    // If the caller wants a special pointer to the new buffer,
    // set it now.

    if( NULL != ppwszBuffer )
    {
        PROPASSERT( NULL== *ppwszBuffer );
        *ppwszBuffer = pwszNewBuffer;
    }

    // Also point *ppwszResult to the new buffer.
    *ppwszResult = pwszNewBuffer;


    //  ----
    //  Exit
    //  ----

Exit:
    return;
}   // PropByteSwap( WCHAR**, WCHAR**, NTSTATUS*)

#endif // BIGENDIAN


//+--------------------------------------------------------------------------
// Function:    PBSBuffer
//
// Synopsis:    This is a Property Byte-Swap routine.  The PBS routines
//              only compile in the BIGENDIAN build.  In the
//              LITTLEENDIAN build, they are inlined with NOOP functions.
//
//              This routine takes a buffer and byte-swaps it.  The caller
//              specifies the size of the buffer, and the granularity of
//              the byte-swapping.
//
// Arguments:   [VOID*] pv
//                  Pointer to the buffer to be swapped.
//              [ULONG] cbSize
//                  Size in bytes of the buffer.
//              [ULONG] cbByteSwap
//                  Size of byte-swapping units.
//
// Returns:     None.
//
// For example, an array of 4 WORDs could be swapped with:
//
//      PBSBuffer( (VOID*) aw, 4, sizeof(WORD) );
//
//---------------------------------------------------------------------------

#ifdef BIGENDIAN

VOID PBSBuffer( IN OUT VOID *pv,
                IN ULONG cbSize,
                IN ULONG cbByteSwap )
{
    ULONG ulIndex;

    // What kind of swapping should be do?

    switch( cbByteSwap )
    {
        // No swapping required

        case 0:
        case( sizeof(BYTE) ):

            // Nothing to do.
            break;

        // Swap WORDs

        case( sizeof(WORD) ):
            
            for( ulIndex = 0; ulIndex < cbSize/sizeof(WORD); ulIndex++ )
                ByteSwap( &((WORD*)pv)[ulIndex] );
            break;

        // Swap DWORDs

        case( sizeof(DWORD) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(DWORD); ulIndex++ )
                ByteSwap( &((DWORD*)pv)[ulIndex] );
            break;

        // Swap LONGLONGs

        case( sizeof(LONGLONG) ):

            for( ulIndex = 0; ulIndex < cbSize/sizeof(LONGLONG); ulIndex++ )
                 ByteSwap( &((LONGLONG*)pv)[ulIndex] );
            break;

        // Swap GUIDs

        case CBBYTESWAP_UID:

            for( ulIndex = 0; ulIndex < cbSize/sizeof(GUID); ulIndex++ )
                ByteSwap( &((GUID*)pv)[ulIndex] );
            break;

        // Error

        default:
            PROPASSERT( !"Invalid generic byte-swap size" );
    }
}   // PropByteSwap( VOID*, ULONG, ULONG )

#endif // BIGENDIAN

DEFINE_CBufferAllocator__Allocate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\psetstg.cxx ===
//+-------------------------------------------------------------------------
// 
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       psetstg.cxx
//
//  Contents:   Implementation of common class DocFile
//              IPropertySetStorage
//
//  Classes:    CPropertySetStorage
//              CEnumSTATPROPSETSTG
//
//  Notes:      
//
//--------------------------------------------------------------------------

#include "pch.cxx"

#include "prophdr.hxx"

//
// debugging support
//
#if DBG
CHAR *
DbgFmtId(REFFMTID rfmtid, CHAR *pszBuf)
{
    PropSprintfA(pszBuf, "rfmtid=%08X.%04X.%04X.%02X.%02X.%02X.%02X.%02X.%02X.%02X.%02X",
        rfmtid.Data1,
        rfmtid.Data2,
        rfmtid.Data3,
        rfmtid.Data4[0],
        rfmtid.Data4[1],
        rfmtid.Data4[2],
        rfmtid.Data4[3],
        rfmtid.Data4[4],
        rfmtid.Data4[5],
        rfmtid.Data4[6],
        rfmtid.Data4[7]);

    return(pszBuf);
}

CHAR *  
DbgMode(DWORD grfMode, CHAR *psz)
{
    *psz = 0;

    if (grfMode & STGM_TRANSACTED)
        strcat(psz, "STGM_TRANSACTED | ");
    else
        strcat(psz, "STGM_DIRECT | ");

    if (grfMode & STGM_SIMPLE)
        strcat(psz, "STGM_SIMPLE | ");

    switch (grfMode & 3)
    {
    case STGM_READ:
        strcat(psz, "STGM_READ |");
        break;
    case STGM_WRITE:
        strcat(psz, "STGM_WRITE |");
        break;
    case STGM_READWRITE:
        strcat(psz, "STGM_READWRITE |");
        break;
    default:
        strcat(psz, "BAD grfMode |");
        break;
    }

    switch (grfMode & 0x70)
    {
    case STGM_SHARE_DENY_NONE:
        strcat(psz, "STGM_SHARE_DENY_NONE |");
        break;
    case STGM_SHARE_DENY_READ:
        strcat(psz, "STGM_SHARE_DENY_READ |");
        break;
    case STGM_SHARE_DENY_WRITE:
        strcat(psz, "STGM_SHARE_DENY_WRITE |");
        break;
    case STGM_SHARE_EXCLUSIVE:
        strcat(psz, "STGM_SHARE_EXCLUSIVE |");
        break;
    default:
        strcat(psz, "BAD grfMode | ");
        break;
    }

        
    if (grfMode & STGM_PRIORITY)
        strcat(psz, "STGM_PRIORITY | ");

    if (grfMode & STGM_DELETEONRELEASE)
        strcat(psz, "STGM_DELETEONRELEASE | ");

    if (grfMode & STGM_NOSCRATCH)
        strcat(psz, "STGM_NOSCRATCH | ");

    if (grfMode & STGM_CREATE)
        strcat(psz, "STGM_CREATE | ");

    if (grfMode & STGM_CONVERT)
        strcat(psz, "STGM_CONVERT | ");

    if (grfMode & STGM_FAILIFTHERE)
        strcat(psz, "STGM_FAILIFTHERE | ");

    return(psz);
}

CHAR *
DbgFlags(DWORD grfFlags, CHAR *psz)
{
    strcpy(psz, "grfFlags=");

    if (grfFlags & PROPSETFLAG_NONSIMPLE)
        strcat(psz, "PROPSETFLAG_NONSIMPLE |");
    else
        strcat(psz, "PROPSETFLAG_SIMPLE |");

    if (grfFlags & PROPSETFLAG_ANSI)
        strcat(psz, "PROPSETFLAG_ANSI |");
    else
        strcat(psz, "PROPSETFLAG_WIDECHAR |");

    return(psz);
}
#endif

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown members
//
//  Notes:      Send the calls to the root.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        return(hr);

    VDATEREADPTRIN( &riid, IID );
    VDATEPTROUT( ppvObject, void* );

    //  -----
    //  Query
    //  -----

    return(_pprivstg->GetStorage()->QueryInterface(riid, ppvObject));
}

ULONG   CPropertySetStorage::AddRef(void)
{
    if (S_OK !=  Validate())
        return(0);
    return(_pprivstg->GetStorage()->AddRef());
}

ULONG   CPropertySetStorage::Release(void)
{
    if (S_OK != Validate())
        return(0);
    return(_pprivstg->GetStorage()->Release());
}


//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Create
//
//  Synopsis:   Create a property set for outermost client of
//              IPropertSetStorage.
//
//  Arguments:  Passed through to CPropertyStorage ctor.
//              
//  Returns:    S_OK or failure code.
//
//  Notes:      Create a new CPropertyStorage object which will
//              implement IPropertyStorage.  The _pprivstg parameter
//              passed into CPropertyStorage::CPropertyStorage is
//              used to create (via QI) a matching type of mapped
//              stream for docfile properies
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Create( REFFMTID                rfmtid,
                                     const CLSID *           pclsid,
                                     DWORD                   grfFlags,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    HRESULT hr;
    DBGBUF(buf1);
    DBGBUF(buf2);
    DBGBUF(buf3);

    //  ----------
    //  Validation
    //  ----------

    if (S_OK != (hr = Validate()))
        goto errRet;

    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, errRet, hr);
    GEN_VDATEPTRIN_LABEL(pclsid, CLSID, E_INVALIDARG, errRet, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, errRet, hr);


    //  ---------------------------
    //  Create the Property Storage
    //  ---------------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppprstg = NULL;

    *ppprstg = new CPropertyStorage(_pprivstg,
                                    rfmtid,
                                    pclsid,
                                    grfFlags,
                                    grfMode,
                                    &hr);
    if (FAILED(hr))
    {
        delete (CPropertyStorage*) *ppprstg;
        *ppprstg = NULL;
    }

    //  ----
    //  Exit
    //  ----

errRet:
    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Create(%s, %s, %s, retif=%08X, hr = %08X\n",
            this, DbgFmtId(rfmtid, buf1), DbgFlags(grfFlags, buf2), DbgMode(grfMode, buf3), *ppprstg, hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Create(%08X, %s, %s, retif=%08X, hr = %08X\n",
            this, &rfmtid, DbgFlags(grfFlags, buf2), DbgMode(grfMode, buf3), ppprstg, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Open
//
//  Synopsis:   Open a property set for outermost client.
//
//  Arguments:  passed through to CPropertyStorage ctor.
//              
//  Returns:    S_OK or error.
//
//  Notes:      Creates a CPropertyStorage which will use the passed
//              pstg to create a mapped stream of the correct type
//              in its implementation.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Open(   REFFMTID                rfmtid,
                                     DWORD                   grfMode,
                                     IPropertyStorage **     ppprstg)
{
    HRESULT hr;
    DBGBUF(buf1);
    DBGBUF(buf2);

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate inputs
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, errRet, hr);
    GEN_VDATEPTROUT_LABEL( ppprstg, IPropertyStorage*, E_INVALIDARG, errRet, hr);

    //  -------------------------
    //  Open the Property Storage
    //  -------------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppprstg = NULL;

    *ppprstg = new CPropertyStorage(_pprivstg, rfmtid, grfMode,
                                    FALSE, // Don't delete this section
                                    &hr);

    if (FAILED(hr))
    {
        delete (CPropertyStorage*) *ppprstg;
        *ppprstg = NULL;
    }

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Open(%s, %s) retif=%08X, hr=%08X\n",
            this, DbgFmtId(rfmtid, buf1), DbgMode(grfMode, buf2), *ppprstg, hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Open(), hr=%08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Delete
//
//  Synopsis:   Delete the specified property set.
//
//  Arguments:  [rfmtid] -- format id of property set to delete.
//              
//  Returns:    S_OK if successful, error otherwise.
//
//  Notes:      Get the matching name and try the element deletion.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Delete( REFFMTID  rfmtid)
{
    HRESULT hr;
    DBGBUF(buf);

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the input
    GEN_VDATEREADPTRIN_LABEL(&rfmtid, FMTID, E_INVALIDARG, errRet, hr);

    //  --------------------------
    //  Delete the PropertyStorage
    //  --------------------------

    // Check for the special-case

    if( IsEqualIID( rfmtid, FMTID_UserDefinedProperties ))
    {

        // This property set is actually the second section of the Document
        // Summary Information property set.  We must delete this
        // section, but we can't delete the Stream because it 
        // still contain the first section.

        CPropertyStorage* pprstg;
        
        pprstg = new CPropertyStorage(_pprivstg,
                                      rfmtid,
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                      TRUE, // Delete this section.
                                      &hr);

        if (pprstg != NULL)
        {
            pprstg->Release();
        }
        pprstg = NULL;
    
    }   // if( IsEqualIID( rfmtid, FMTID_DocSummaryInformation2 ))

    else
    {
        // This is not a special case, so we can just delete
        // the Stream.  Note that if the rfmtid represents the first
        // section of the DocumentSummaryInformation set, we might be
        // deleting the second section here as well.

        CPropSetName psn(rfmtid);

        hr = _pprivstg->GetStorage()->DestroyElement(psn.GetPropSetName());

    }   // if( IsEqualIID( rfmtid, FMTID_DocSummaryInformation2 )) ... else

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Delete(%s) hr = %08X\n",
            this, DbgFmtId(rfmtid, buf), hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Delete(%08X) hr = %08X\n",
            this, &rfmtid, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CPropertySetStorage::Enum
//
//  Synopsis:   Create an enumerator over the property set
//
//  Arguments:  [ppenum] -- where to return the pointer to the
//                          enumerator.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      [ppenum] is NULL on error.
//
//--------------------------------------------------------------------

HRESULT CPropertySetStorage::Enum(   IEnumSTATPROPSETSTG **  ppenum)
{

    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'
    if (S_OK != (hr = Validate()))
        goto errRet;

    // Validate the input
    GEN_VDATEPTROUT_LABEL( ppenum, IEnumSTATPROPSETSTG*, E_INVALIDARG, errRet, hr);

    //  --------------------
    //  Create the enuerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = NULL; // for access violation

    *ppenum = new CEnumSTATPROPSETSTG(_pprivstg->GetStorage(), &hr);

    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }

    //  ----
    //  Exit
    //  ----

errRet:

    if( E_INVALIDARG != hr )
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Enum(retif=%08X), hr = %08X\n",
            this, *ppenum, hr));
    }
    else
    {
        PropDbg((DEB_PROP_EXIT, "CPropertySetStorage(%08X)::Enum(), hr = %08X\n",
            this, hr));
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Constructor which is used to implement
//              IPropertySetStorage::Enum
//
//  Arguments:  [pstg] -- the storage of the container to enumerate.
//              [phr] -- place to return HRESULT, S_OK or error.
//
//  Notes:      We use an STATSTG enumerator over the actual storage
//              to get the information about the property sets.
//
//--------------------------------------------------------------------


CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(IStorage *pstg, HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;
    hr = pstg->EnumElements(FALSE, NULL, 0, &_penumSTATSTG);
    if (FAILED(hr))
        _penumSTATSTG = NULL;
    _cstatTotalInArray = 0;
    _istatNextToRead = 0;

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG
//
//  Synopsis:   Copy constructor which is used to implement
//              IEnumSTATPROPSETSTG::Clone.
//
//  Arguments:  [Other] -- The CEnumSTATPROPSETSTG to clone.
//              [phr] -- place to return HRESULT, S_OK or error.
//  
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::CEnumSTATPROPSETSTG(   CEnumSTATPROPSETSTG &Other,
                                            HRESULT *phr)
{
    HRESULT & hr = *phr;

    _ulSig = ENUMSTATPROPSETSTG_SIG;
    _cRefs = 1;
    _cstatTotalInArray = 0;
    _istatNextToRead = Other._istatNextToRead;
    
    hr = Other._penumSTATSTG->Clone(&_penumSTATSTG);
    if (hr == S_OK)
    {
        // Copy the data in the buffer
        memcpy(_statarray, Other._statarray, sizeof(_statarray));
        _cstatTotalInArray = Other._cstatTotalInArray;

        // Copy the strings in the buffer
        for (ULONG i=0; i<_cstatTotalInArray; i++)
        {
            _statarray[i].pwcsName =
                (OLECHAR*)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(Other._statarray[i].pwcsName)+1));
            if (_statarray[i].pwcsName == NULL)
            {
                _cstatTotalInArray = i;
                hr = STG_E_INSUFFICIENTMEMORY;
                break;
            }
            else
            {
                ocscpy(_statarray[i].pwcsName, Other._statarray[i].pwcsName);
            }
        }
    }
    // note: destructor will cleanup the the strings or enumerator left behind
    //       in the error case
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG
//
//  Synopsis:   Delete the enumerator.
//
//  Notes:      Just releases the contained IEnumSTATSTG
//
//--------------------------------------------------------------------

CEnumSTATPROPSETSTG::~CEnumSTATPROPSETSTG()
{
    _ulSig = ENUMSTATPROPSETSTG_SIGDEL;

    if (_penumSTATSTG != NULL)
        _penumSTATSTG->Release();

    CleanupStatArray();

}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::QueryInterface, AddRef, Release
//
//  Synopsis:   IUnknown
//
//  Arguments:  The usual thing.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::QueryInterface( REFIID riid, void **ppvObject)
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IEnumSTATPROPSETSTG))
    {
        *ppvObject = (IEnumSTATPROPSETSTG *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = (IUnknown *)this;
        CEnumSTATPROPSETSTG::AddRef();
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return(hr);
    
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::AddRef
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::AddRef(void)
{
    if (S_OK != Validate())
        return(0);

    InterlockedIncrement(&_cRefs);
    return(_cRefs);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Release
//
//--------------------------------------------------------------------

ULONG   CEnumSTATPROPSETSTG::Release(void)
{
    LONG lRet;

    if (S_OK != Validate())
        return(0);

    lRet = InterlockedDecrement(&_cRefs);

    if (lRet == 0)
    {
        delete this;
    }
    else
    if (lRet <0)
    {
        lRet = 0;
    }
    return(lRet);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Next
//
//  Synopsis:   Implement IEnumSTATPROPSETSTG for docfile.
//
//  Arguments:  [celt] -- Count of elements to attempt to retrieve.
//              [rgelt] -- Where to put the results.  Must be valid for at least
//                         celt * sizeof(STATPROPSETSTG) bytes in length.
//              [pceltFetched] -- Count of elements returned is put here if
//                  the pointer is non-null.  If celt > 1, pceltFetched must
//                  be valid non-NULL.  If pcelt is non-NULL, it must be valid.
//                  if pcelt is NULL, celt must be 1.
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We use a stack buffer to get more stuff per call to
//              underlying storage IEnumSTATSTG::Next.  We then copy
//              data from the STATSTG's to STATPROPSETSTG's.
//
//              An outer loop enumerates into statarray and then an
//              inner loop copies each batch into the [rgelt] buffer.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Next(ULONG                   celt,
                                  STATPROPSETSTG *        rgelt,
                                  ULONG *                 pceltFetched)
{
    HRESULT hr;
    ULONG celtCallerTotal;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    if (NULL == pceltFetched)
    {
        if (1 != celt)
            return(STG_E_INVALIDPARAMETER);
    }
    else
    {
        VDATEPTROUT( pceltFetched, ULONG );
        *pceltFetched = 0;
    }

    if (0 == celt)
        return(hr);

    if( !IsValidPtrOut(rgelt, celt * sizeof(rgelt[0])) )
        return( E_INVALIDARG );


    //  -----------------------
    //  Perform the enumeration
    //  -----------------------

    celtCallerTotal = 0;

    //
    // we do this loop until we have what the caller wanted or error, or
    // no more.
    //
    do
    {
        //
        // If our internal buffer is empty, we (re)load it
        //
        if (_istatNextToRead == _cstatTotalInArray)
        {
            if (_cstatTotalInArray != 0)
                CleanupStatArray();

            hr = _penumSTATSTG->Next(sizeof(_statarray)/sizeof(_statarray[0]),
                    _statarray,
                    &_cstatTotalInArray);
        }

        // S_OK or S_FALSE indicate that we got something
        if (SUCCEEDED(hr))
        {
            //
            // we loop reading out of this buffer until either we have
            // all that the caller asked for, or we have exhausted the
            // buffer.
            //
            for (; celtCallerTotal < celt &&
                   _istatNextToRead < _cstatTotalInArray ;
                   _istatNextToRead++)
            {
                OLECHAR *pocsName = _statarray[_istatNextToRead].pwcsName;
                BOOL fDone = FALSE;

                PROPASSERT(pocsName != NULL);

                if (pocsName[0] == 5)
                {
                    // *** get fmtid *** //

                    if (!NT_SUCCESS(RtlPropertySetNameToGuid(
                                    ocslen(pocsName), pocsName, &rgelt->fmtid)))
                    {
                        ZeroMemory(&rgelt->fmtid, sizeof(rgelt->fmtid));
                    }
    
                    // *** get clsid *** //
                    // *** get grfFlags *** //
    
                    if (_statarray[_istatNextToRead].type == STGTY_STORAGE)
                    {
                        rgelt->clsid = _statarray[_istatNextToRead].clsid;
                        rgelt->grfFlags = PROPSETFLAG_NONSIMPLE;
                    }
                    else
                    {
                        ZeroMemory(&rgelt->clsid, sizeof(rgelt->clsid));
                        rgelt->grfFlags = 0;
                    }
    
                    // *** get mtime *** //
                    rgelt->mtime = _statarray[_istatNextToRead].mtime;
    
                    // *** get ctime *** //
                    rgelt->ctime = _statarray[_istatNextToRead].ctime;
    
                    // *** get atime *** //
                    rgelt->atime = _statarray[_istatNextToRead].atime;

                    // *** default the OS Version *** //
                    rgelt->dwOSVersion = PROPSETHDR_OSVERSION_UNKNOWN;
    
                    rgelt ++;
                    celtCallerTotal ++;
                }
            }
        }
    }
    while (celtCallerTotal < celt && hr == S_OK);

    if (SUCCEEDED(hr))
    {
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;
        PROPASSERT(hr == S_OK || celtCallerTotal < celt);

        if (pceltFetched != NULL)
            *pceltFetched = celtCallerTotal;
    }
    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Skip
//
//  Synopsis:   Skip the requested number of elements.
//
//  Arguments:  [celt] -- number to skip.
//
//  Returns:    S_OK if all skipped, S_FALSE if less than requested
//              number skipped, error otherwise.
//
//  Notes:      
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Skip(ULONG celt)
{
    HRESULT hr;
    STATPROPSETSTG stat;
    ULONG celtCallerTotal = 0;

    if (S_OK != (hr = Validate()))
        return(hr);

    do
    {
        hr = Next(1, &stat, NULL);
    } while ( hr == S_OK && ++celtCallerTotal < celt );

    if (SUCCEEDED(hr))
        hr = celt == celtCallerTotal ? S_OK : S_FALSE;

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::CleanupStatArray
//
//  Synopsis:   Free any strings in the array.
//
//--------------------------------------------------------------------

VOID CEnumSTATPROPSETSTG::CleanupStatArray()
{
    for (ULONG i=0; i<_cstatTotalInArray; i++)
    {
        CoTaskMemFree(_statarray[i].pwcsName);
        _statarray[i].pwcsName = NULL;
    }
    _istatNextToRead = 0;
    _cstatTotalInArray = 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Reset
//
//  Synopsis:   Reset the enumerator.
//
//  Notes:      Merely resetting the underlying enumerator should be
//              adequate,
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Reset()
{
    HRESULT hr;

    if (S_OK != (hr = Validate()))
        return(hr);

    hr = _penumSTATSTG->Reset();
    if (hr == S_OK)
    {
        CleanupStatArray();
    }

    return(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     CEnumSTATPROPSETSTG::Clone
//
//  Synopsis:   Copy the enumeration state of this enumerator.
//
//  Arguments:  [ppenum] -- where to put the pointer to the clone
//
//  Returns:    S_OK if ok, error otherwise.
//
//  Notes:      We end up just calling IEnumSTATSTG::Clone in the
//              CEnumSTATPROPSETSTG constructor.
//
//--------------------------------------------------------------------

HRESULT CEnumSTATPROPSETSTG::Clone(IEnumSTATPROPSETSTG **     ppenum)
{
    HRESULT hr;

    //  ----------
    //  Validation
    //  ----------

    // Validate 'this'

    if (S_OK != (hr = Validate()))
        return(hr);

    // Validate inputs

    VDATEPTROUT( ppenum, IEnumSTATPROPSETSTG* );

    //  --------------------
    //  Clone the enumerator
    //  --------------------

    hr = STG_E_INSUFFICIENTMEMORY;

    *ppenum = new CEnumSTATPROPSETSTG(*this, &hr);
    if (FAILED(hr))
    {
        delete (CEnumSTATPROPSETSTG*) *ppenum;
        *ppenum = NULL;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\stgvarb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       StgVarB.cxx
//
//  Contents:   C++ Base wrapper for PROPVARIANT.
//
//--------------------------------------------------------------------------

#include "pch.cxx"
#include <ctype.h>

/* right now only US ansi support */
EXTERN_C 
STDAPI_(UINT) GetACP(VOID)
{ return 1252; }  /* Latin 1 (US, Western Europe) */

#if DBGPROP

BOOLEAN
IsUnicodeString(WCHAR const *pwszname, ULONG cb)
{
    if (cb != 0)
    {
    	for (ULONG i = 0; pwszname[i] != (OLECHAR)'\0'; i++)
	    {
    	}

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.
        
        PROPASSERT(cb == MAXULONG || (i + 1) * sizeof(WCHAR) <= cb);
    }
    return(TRUE);
}


BOOLEAN
IsAnsiString(CHAR const *pszname, ULONG cb)
{
    if (cb != 0)
    {
    	for (ULONG i = 0; pszname[i] != '\0'; i++)
    	{
    	}

        // If cb isn't MAXULONG we verify that cb is at least as
        // big as the string.  We can't check for equality, because
        // there are some property sets in which the length field
        // for a string may include several zero padding bytes.
        
     	PROPASSERT(cb == MAXULONG || i + 1 <= cb);
    }
    return(TRUE);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\qsort.c ===
/***
*qsort.c - quicksort algorithm; qsort() library function for sorting arrays
*
*       Copyright (c) 1985-1993, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       To implement the qsort() routine for sorting arrays.
*      
*       This routine has been modified to suit the reference implementation
*
*******************************************************************************/
#include "qsort.h"

/* prototypes for local routines */
static void shortsort(char *lo, char *hi, unsigned width,
                 int (*comp)(const void *, const void *));
static void swap(char *p, char *q, unsigned int width);

/* this parameter defines the cutoff between using quick sort and
   insertion sort for arrays; arrays with lengths shorter or equal to the
   below value use insertion sort */

#define CUTOFF 8            /* testing shows that this is good value */


/***
*ref_qsort(base, num, wid, comp) - quicksort function for sorting arrays
*
*Purpose:
*       quicksort the array of elements
*       side effects:  sorts in place
*
*Entry:
*       char *base = pointer to base of array
*       unsigned num  = number of elements in the array
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

/* sort the array between lo and hi (inclusive) */

void ref_qsort (
    void *base,
    unsigned num,
    unsigned width,
    int (*comp)(const void *, const void *)
    )
{
    char *lo, *hi;              /* ends of sub-array currently sorting */
    char *mid;                  /* points to middle of subarray */
    char *loguy, *higuy;        /* traveling pointers for partition step */
    unsigned size;              /* size of the sub-array */
    char *lostk[30], *histk[30];
    int stkptr;                 /* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (num < 2 || width == 0)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = (char *) base;
    hi = (char *)base + width * (num-1);        /* initialize limits */

    /* this entry point is for pseudo-recursion calling: setting
       lo and hi and jumping to here is like recursion, but stkptr is
       prserved, locals aren't, so we preserve stuff on the stack */
recurse:

    size = (hi - lo) / width + 1;        /* number of el's to sort */

    /* below a certain size, it is faster to use a O(n^2) sorting method */
    if (size <= CUTOFF) {
         shortsort(lo, hi, width, comp);
    }
    else {
        /* First we pick a partititioning element.  The efficiency of the
           algorithm demands that we find one that is approximately the
           median of the values, but also that we select one fast.  Using
           the first one produces bad performace if the array is already
           sorted, so we use the middle one, which would require a very
           wierdly arranged array for worst case performance.  Testing shows
           that a median-of-three algorithm does not, in general, increase
           performance. */

        mid = lo + (size / 2) * width;      /* find middle element */
        swap(mid, lo, width);               /* swap it to beginning of array */

        /* We now wish to partition the array into three pieces, one
           consisiting of elements <= partition element, one of elements
           equal to the parition element, and one of element >= to it.  This
           is done below; comments indicate conditions established at every
           step. */

        loguy = lo;
        higuy = hi + width;

        /* Note that higuy decreases and loguy increases on every iteration,
           so loop must terminate. */
        for (;;) {
            /* lo <= loguy < hi, lo < higuy <= hi + 1,
               A[i] <= A[lo] for lo <= i <= loguy,
               A[i] >= A[lo] for higuy <= i <= hi */

            do  {
                loguy += width;
            } while (loguy <= hi && comp(loguy, lo) <= 0);

            /* lo < loguy <= hi+1, A[i] <= A[lo] for lo <= i < loguy,
               either loguy > hi or A[loguy] > A[lo] */

            do  {
                higuy -= width;
            } while (higuy > lo && comp(higuy, lo) >= 0);

            /* lo-1 <= higuy <= hi, A[i] >= A[lo] for higuy < i <= hi,
               either higuy <= lo or A[higuy] < A[lo] */

            if (higuy < loguy)
                break;

            /* if loguy > hi or higuy <= lo, then we would have exited, so
               A[loguy] > A[lo], A[higuy] < A[lo],
               loguy < hi, highy > lo */

            swap(loguy, higuy, width);

            /* A[loguy] < A[lo], A[higuy] > A[lo]; so condition at top
               of loop is re-established */
        }

        /*     A[i] >= A[lo] for higuy < i <= hi,
               A[i] <= A[lo] for lo <= i < loguy,
               higuy < loguy, lo <= higuy <= hi
           implying:
               A[i] >= A[lo] for loguy <= i <= hi,
               A[i] <= A[lo] for lo <= i <= higuy,
               A[i] = A[lo] for higuy < i < loguy */

        swap(lo, higuy, width);     /* put partition element in place */

        /* OK, now we have the following:
              A[i] >= A[higuy] for loguy <= i <= hi,
              A[i] <= A[higuy] for lo <= i < higuy
              A[i] = A[lo] for higuy <= i < loguy    */

        /* We've finished the partition, now we want to sort the subarrays
           [lo, higuy-1] and [loguy, hi].
           We do the smaller one first to minimize stack usage.
           We only sort arrays of length 2 or more.*/

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + width < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - width;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo + width < higuy) {
                hi = higuy - width;
                goto recurse;           /* do small recursion */
            }
        }
    }

    /* We have sorted the array, except for any pending sorts on the stack.
       Check if there are any, and do them. */

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
    else
        return;                 /* all subarrays done */
}


/***
*shortsort(hi, lo, width, comp) - insertion sort for sorting short arrays
*
*Purpose:
*       sorts the sub-array of elements between lo and hi (inclusive)
*       side effects:  sorts in place
*       assumes that lo < hi
*
*Entry:
*       char *lo = pointer to low element to sort
*       char *hi = pointer to high element to sort
*       unsigned width = width in bytes of each array element
*       int (*comp)() = pointer to function returning analog of strcmp for
*               strings, but supplied by user for comparing the array elements.
*               it accepts 2 pointers to elements and returns neg if 1<2, 0 if
*               1=2, pos if 1>2.
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void shortsort (
    char *lo,
    char *hi,
    unsigned width,
    int (*comp)(const void *, const void *)
    )
{
    char *p, *max;

    /* Note: in assertions below, i and j are alway inside original bound of
       array to sort. */

    while (hi > lo) {
        /* A[i] <= A[j] for i <= j, j > hi */
        max = lo;
        for (p = lo+width; p <= hi; p += width) {
            /* A[i] <= A[max] for lo <= i < p */
            if (comp(p, max) > 0) {
                max = p;
            }
            /* A[i] <= A[max] for lo <= i <= p */
        }

        /* A[i] <= A[max] for lo <= i <= hi */

        swap(max, hi, width);

        /* A[i] <= A[hi] for i <= hi, so A[i] <= A[j] for i <= j, j >= hi */

        hi -= width;

        /* A[i] <= A[j] for i <= j, j > hi, loop top condition established */
    }
    /* A[i] <= A[j] for i <= j, j > lo, which implies A[i] <= A[j] for i < j,
       so array is sorted */
}


/***
*swap(a, b, width) - swap two elements
*
*Purpose:
*       swaps the two array elements of size width
*
*Entry:
*       char *a, *b = pointer to two elements to swap
*       unsigned width = width in bytes of each array element
*
*Exit:
*       returns void
*
*Exceptions:
*
*******************************************************************************/

static void swap (
    char *a,
    char *b,
    unsigned width
    )
{
    char tmp;

    if ( a != b )
        /* Do the swap one character at a time to avoid potential alignment
           problems. */
        while ( width-- ) {
            tmp = *a;
            *a++ = *b;
            *b++ = tmp;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\utils.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       utils.cxx
//
//  Contents:   Utility classes/functions for property implementation.
//
//  Classes:    CPropSetName -- wraps buffer and conversion of fmtids
//              CStackBuffer -- utility class that allows a small number
//                              of items be on stack, but more be on heap.
//
//  Functions:  PropVariantClear
//              FreePropVariantArray
//              AllocAndCopy
//              PropVariantCopy
//              PropSysAllocString
//              PropSysFreeString
//
//
//--------------------------------------------------------------------------

#include "pch.cxx"

//+-------------------------------------------------------------------
//
//  Member:     CPropSetName::CPropSetName
//
//  Synopsis:   Initialize internal buffer with converted FMTID
//
//  Arguments:  [rfmtid] -- FMTID to convert
//
//--------------------------------------------------------------------

CPropSetName::CPropSetName(REFFMTID rfmtid)
{
    RtlGuidToPropertySetName(&rfmtid, _oszName);
}

//+-------------------------------------------------------------------
//
//  Member:     CStackBuffer::Init
//
//  Synopsis:   Determine whether the class derived from this one
//              needs to have additional buffer allocated on the
//              heap and allocate it if neccessary.  Otherwise, if
//              there is space, use the internal buffer in the
//              derived class.
//
//  Arguments:  [cElements] -- the number of elements required.
//
//  Returns:    S_OK if buffer available
//              STG_E_INSUFFICIENTMEMORY if stack buffer was not
//                  big enough AND heap allocation failed.
//
//  Notes:      To be called directly by client after the derived
//              classes constructor initialized CStackBuffer.
//
//--------------------------------------------------------------------

HRESULT CStackBuffer::Init(ULONG cElements)
{
    if (cElements > _cStackElements)
    {
        _pbHeapBuf = new BYTE[cElements * _cbElementSize];
        if (_pbHeapBuf == NULL)
        {
            return(STG_E_INSUFFICIENTMEMORY);
        }
    }
    return(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   PropVariantClear
//
//  Synopsis:   Deallocates the members of the PROPVARIANT that require
//              deallocation.
//
//  Arguments:  [pvarg] - variant to clear
//
//  Returns:    S_OK if successful,
//              STG_E_INVALIDPARAMETER if any part of the variant has
//                  an unknown vt type.  (In this case, ALL the elements
//                  that can be freed, will be freed.)
//
//  Modifies:   [pvarg] - the variant is left with vt = VT_EMPTY
//
//--------------------------------------------------------------------------

STDAPI PropVariantClear(PROPVARIANT *pvarg)
{

    ULONG l;
    HRESULT hr = S_OK;

    if (pvarg == NULL)
        return(hr);

    switch (pvarg->vt)
    {
    case VT_EMPTY:
    case VT_NULL:
    case VT_ILLEGAL:

#ifdef PROPVAR_VT_I1
    case VT_I1:
#endif
    case VT_UI1:
    case VT_I2:
    case VT_UI2:
    case VT_I4:
    case VT_UI4:
    case VT_I8:
    case VT_UI8:
    case VT_R4:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
        break;

    case VT_BSTR:
        if (pvarg->bstrVal != NULL)
            PropSysFreeString( pvarg->bstrVal );
        break;

    case VT_BOOL:
    case VT_ERROR:
    case VT_FILETIME:
        break;

    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_CLSID:
        PROPASSERT((void**)&pvarg->pszVal == (void**)&pvarg->pwszVal);
        PROPASSERT((void**)&pvarg->pszVal == (void**)&pvarg->puuid);
        CoTaskMemFree(pvarg->pszVal); // ptr at 0
        break;
        
    case VT_CF:
        if (pvarg->pclipdata != NULL)
        {
            CoTaskMemFree(pvarg->pclipdata->pClipData); // ptr at 8
            CoTaskMemFree(pvarg->pclipdata);
        }
        break;

    case VT_BLOB:
    case VT_BLOB_OBJECT:
        CoTaskMemFree(pvarg->blob.pBlobData); //ptr at 4
        break;

#ifdef PROPVAR_VT_I1
    case (VT_VECTOR | VT_I1):
#endif
    case (VT_VECTOR | VT_UI1):
    case (VT_VECTOR | VT_I2):
    case (VT_VECTOR | VT_UI2):
    case (VT_VECTOR | VT_I4):
    case (VT_VECTOR | VT_UI4):
    case (VT_VECTOR | VT_I8):
    case (VT_VECTOR | VT_UI8):
    case (VT_VECTOR | VT_R4):
    case (VT_VECTOR | VT_R8):
    case (VT_VECTOR | VT_CY):
    case (VT_VECTOR | VT_DATE):

FreeArray:
        PROPASSERT((void**)&pvarg->caub.pElems == (void**)&pvarg->cai.pElems);
        CoTaskMemFree(pvarg->caub.pElems);
        break;

    case (VT_VECTOR | VT_BSTR):
        if (pvarg->cabstr.pElems != NULL)
        {
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                if (pvarg->cabstr.pElems[l] != NULL)
                {
                    PropSysFreeString( pvarg->cabstr.pElems[l] );
                }
            }
        }
        goto FreeArray;

    case (VT_VECTOR | VT_BOOL):
    case (VT_VECTOR | VT_ERROR):
        goto FreeArray;

    case (VT_VECTOR | VT_LPSTR):
    case (VT_VECTOR | VT_LPWSTR):
        if (pvarg->calpstr.pElems != NULL)
        for (l=0; l< pvarg->calpstr.cElems; l++)
        {
            CoTaskMemFree(pvarg->calpstr.pElems[l]);
        }
        goto FreeArray;

    case (VT_VECTOR | VT_FILETIME):
    case (VT_VECTOR | VT_CLSID):
        goto FreeArray;

    case (VT_VECTOR | VT_CF):
        if (pvarg->caclipdata.pElems != NULL)
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                CoTaskMemFree(pvarg->caclipdata.pElems[l].pClipData);
            }
        goto FreeArray;

    case (VT_VECTOR | VT_VARIANT):
        if (pvarg->capropvar.pElems != NULL)
            hr = FreePropVariantArray(pvarg->capropvar.cElems, pvarg->capropvar.pElems);
        goto FreeArray;

    default:
        hr = STG_E_INVALIDPARAMETER;
        break;
    }

    //  We have all of the important information about the variant, so
    //  let's clear it out.
    //
    PropVariantInit(pvarg);

    return (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FreePropVariantArray, public
//
//  Synopsis:   Frees a value array returned from ReadMultiple
//
//  Arguments:  [cval] - Number of elements
//              [rgvar] - Array
//
//  Returns:    S_OK if all types recognised and all freeable items were freed.
//              STG_E_INVALID_PARAMETER if one or more types were not
//              recognised but all items are freed too.
//
//  Notes:      Even if a vt-type is not understood, all the ones that are
//              understood are freed.  The error code will indicate
//              if *any* of the members were illegal types.
//
//----------------------------------------------------------------------------

STDAPI FreePropVariantArray (
        ULONG cVariants,
        PROPVARIANT *rgvars)
{
    HRESULT hr = S_OK;

    if (rgvars != NULL)
        for ( ULONG I=0; I < cVariants; I++ )
            if (STG_E_INVALIDPARAMETER == PropVariantClear ( rgvars + I ))
                hr = STG_E_INVALIDPARAMETER;

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:   AllocAndCopy
//
//  Synopsis:   Allocates enough memory to copy the passed data into and
//              then copies the data into the new buffer.
//
//  Arguments:  [cb] -- number of bytes of data to allocate and copy
//              [pvData]  --  the source of the data to copy
//              [phr] -- optional pointer to an HRESULT set to
//                       STG_E_INSUFFICIENTMEMORY if memory could
//                       not be allocated.
//              
//
//  Returns:    NULL if no memory could be allocated,
//              Otherwise, pointer to allocated and copied data.
//
//--------------------------------------------------------------------

void * AllocAndCopy(ULONG cb, void * pvData, HRESULT *phr = NULL)
{
    PROPASSERT(cb!=0);
    void * pvNew  =  CoTaskMemAlloc(cb);
    if (pvNew != NULL)
    {
        memcpy(pvNew, pvData, cb);
    }
    else
    {
        if (phr != NULL)
        {
            *phr = STG_E_INSUFFICIENTMEMORY;
        }
    }
    return(pvNew);
}

//+-------------------------------------------------------------------
//
//  Function:   SysAllocString
//              SysFreeString
//
//  Synopsis:   Exported BSTR allocation and deallocation routines
//
//
//--------------------------------------------------------------------
STDAPI_(void) SysFreeString(BSTR bstr)
{
    if (bstr)
    {
	BYTE* pab = (BYTE*) bstr;
	delete[] (pab - sizeof(DWORD));
    }
}

STDAPI_(BSTR) SysAllocString(LPOLECHAR pwsz)
{
    if (!pwsz) return NULL;

    DWORD cch = _tcslen(pwsz);

    /* a BSTR points to a DWORD length, followed by the string */
    BYTE *pab = new BYTE[sizeof(DWORD) + ((cch+1)*sizeof(OLECHAR))];

    if (pab) 
    {
        *((DWORD*) pab) = cch*sizeof(OLECHAR);
        pab += sizeof(DWORD);
        _tcscpy( (LPOLECHAR)pab, pwsz );
    }
    return ((BSTR) pab);
}

//+---------------------------------------------------------------------------
//
//  Table:      g_TypeSizes, g_TypeSizesB
//
//  Synopsis:   Tables containing byte sizes and flags for various VT_ types.
//
//----------------------------------------------------------------------------

#define BIT_VECTNOALLOC 0x80    // the VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_SIMPNOALLOC 0x40    // the non VT_VECTOR with this type does not
                                // use heap allocation

#define BIT_INVALID     0x20    // marks an invalid type

#define BIT_SIZEMASK    0x1F    // mask for size of underlying type

const unsigned char g_TypeSizes[] =
{                     BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_EMPTY= 0,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_NULL      = 1,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_I2        = 2,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_I4        = 3,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_R4        = 4,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_R8        = 5,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(CY),           //VT_CY        = 6,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(DATE),         //VT_DATE      = 7,
                                                           sizeof(BSTR),         //VT_BSTR      = 8,
        BIT_INVALID |                                      0,                    //VT_DISPATCH  = 9,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(SCODE),        //VT_ERROR     = 10,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(VARIANT_BOOL), //VT_BOOL      = 11,
                                                           sizeof(PROPVARIANT),  //VT_VARIANT   = 12,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UNKNOWN   = 13,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 14
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    // 15
#ifdef PROPVAR_VT_I1
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_I1        = 16,
#else
        BIT_INVALID /*BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,*/ | 0,             //VT_I1        = 16,
#endif
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  1,                    //VT_UI1       = 17,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  2,                    //VT_UI2       = 18,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  4,                    //VT_UI4       = 19,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_I8        = 20,
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  8,                    //VT_UI8       = 21,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_INT  = 22,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_UINT = 23,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_VOID = 24,
        BIT_INVALID | BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  0,                    //VT_HRESULT      = 25,
        BIT_INVALID |                                      0,                    //VT_PTR  = 26,
        BIT_INVALID |                                      0,                    //VT_SAFEARRAY    = 27,
        BIT_INVALID |                                      0,                    //VT_CARRAY       = 28,
        BIT_INVALID |                                      0,                    //VT_USERDEFINED  = 29,
                                                           sizeof(LPSTR),        //VT_LPSTR        = 30,
                                                           sizeof(LPWSTR)        //VT_LPWSTR       = 31,
};

const unsigned char g_TypeSizesB[] =
{
    // NOTE: vectors of types marked ** are determined dynamically
                      BIT_SIMPNOALLOC | BIT_VECTNOALLOC |  sizeof(FILETIME),     //VT_FILETIME     = 64,
                                                           0,                    //**VT_BLOB = 65,
                                                           0,                    //**VT_STREAM       = 66,
                                                           0,                    //**VT_STORAGE      = 67,
                                                           0,                    //**VT_STREAMED_OBJECT      = 68,
                                                           0,                    //**VT_STORED_OBJECT        = 69,
                                                           0,                    //**VT_BLOB_OBJECT  = 70,
                                                           sizeof(CLIPDATA),     //VT_CF   = 71,
                                        BIT_VECTNOALLOC |  sizeof(CLSID)         //VT_CLSID        = 72
};

//+---------------------------------------------------------------------------
//
//  Function:   PropVariantCopy, public
//
//  Synopsis:   Copies a PROPVARIANT
//
//  Arguments:  [pDest] -- the destination PROPVARIANT
//              [pvarg] - the source PROPVARIANT
//
//  Returns:    Appropriate status code
//
//----------------------------------------------------------------------------

STDAPI PropVariantCopy ( PROPVARIANT * pDest, const PROPVARIANT * pvarg )
{
    HRESULT     hr = S_OK;
    register unsigned char TypeInfo;
    register int iBaseType;

    // handle the simple types quickly
    iBaseType = pvarg->vt & ~VT_VECTOR;

    if (iBaseType <= VT_LPWSTR)
    {
        TypeInfo = g_TypeSizes[iBaseType];
    }
    else
    if (VT_FILETIME <= iBaseType && iBaseType <= VT_CLSID)
    {
        TypeInfo = g_TypeSizesB[iBaseType-VT_FILETIME];
    }
    else
    {
        hr = STG_E_INVALIDPARAMETER;
        goto errRet;
    }

    if ((TypeInfo & BIT_INVALID) != 0)
    {
        hr = STG_E_INVALIDPARAMETER;
        goto errRet;
    }

    *pDest = *pvarg;

    if ((pvarg->vt & VT_VECTOR) == 0)
    {
        // handle non-vector types

        if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
        {
            void * pvAllocated = (void*)-1;

            switch (pvarg->vt)
            {
            case VT_BSTR:
                pvAllocated = pDest->bstrVal = PropSysAllocString( pvarg->bstrVal );
                break;

            case VT_LPSTR:
                if (pvarg->pszVal != NULL)
                    pvAllocated = pDest->pszVal = (CHAR *)
                        AllocAndCopy(strlen(pvarg->pszVal)+1, pvarg->pszVal);
                break;
            case VT_LPWSTR:
                if (pvarg->pwszVal != NULL)
                {
                    ULONG cbString = (Prop_wcslen(pvarg->pwszVal)+1) * sizeof(WCHAR);
                    pvAllocated = pDest->pwszVal = (WCHAR *)
                        AllocAndCopy(cbString, pvarg->pwszVal);
                }
                break;
            case VT_CLSID:
                if (pvarg->puuid != NULL)
                    pvAllocated = pDest->puuid = (GUID *)
                        AllocAndCopy(sizeof(*(pvarg->puuid)), pvarg->puuid);
                break;
                
            case VT_CF:
                // first check if CLIPDATA is present
                if (pvarg->pclipdata != NULL)
                {
                    // yes ... copy the clip data structure

                    pvAllocated = pDest->pclipdata = (CLIPDATA*)AllocAndCopy(
                        sizeof(*(pvarg->pclipdata)), pvarg->pclipdata);

                    // did we allocate the CLIPDATA ?
                    if (pvAllocated != NULL)
                    {
                        // yes ... initialize the destination.
                        pDest->pclipdata->pClipData = NULL;

                        // Is the input valid?
                        if (NULL == pvarg->pclipdata->pClipData
                            &&
                            0 != CBPCLIPDATA(*pvarg->pclipdata))
                        {
                            // no ... the input is not valid
                            hr = STG_E_INVALIDPARAMETER;
                        }

                        // Is there is any actual clip data ?
                        else if (0 != CBPCLIPDATA(*pvarg->pclipdata))
                        {
                            // yes ... copy the actual clip data
                            pvAllocated = pDest->pclipdata->pClipData =
                                (BYTE*)AllocAndCopy(CBPCLIPDATA(*pvarg->pclipdata),
                                         pvarg->pclipdata->pClipData);
                        }
                    }   // if (pvAllocated != NULL)
                }   // if (pvarg->pclipdata != NULL)
                break;

            case VT_BLOB:
            case VT_BLOB_OBJECT:
                if (pvarg->blob.pBlobData != NULL && pvarg->blob.cbSize != 0)
                {
                    pvAllocated = pDest->blob.pBlobData = (BYTE *)
                        AllocAndCopy(pvarg->blob.cbSize,
                                     pvarg->blob.pBlobData);
                }
                else 
                {
                    // if the cbsize is 0 or pBlobData is NULL, make
                    // sure both values are consistent in the destination
                    pDest->blob.pBlobData = NULL;
                    pDest->blob.cbSize = 0;
                }
                break;

            case VT_VARIANT:
                // drop through - this merely documents that VT_VARIANT has been thought of.

            default:
                //PROPASSERT(!"Unexpected non-vector type in PropVariantCopy");
                hr = STG_E_INVALIDPARAMETER;
                goto errRet;
            }

            if( FAILED(hr) )
                goto errRet;

            if (pvAllocated == NULL)
            {
                hr = STG_E_INSUFFICIENTMEMORY;
                goto errRet;
            }
        }   // if ((TypeInfo & BIT_SIMPNOALLOC) == 0)
    }   // if ((pvarg->vt & VT_VECTOR) == 0)

    else
    {
        ULONG cbType = TypeInfo & BIT_SIZEMASK;
        if (cbType == 0)
        {
            hr = STG_E_INVALIDPARAMETER;
            goto errRet;
        }

        // handle the vector types

        // this depends on the pointer and count being in the same place in
        // each of CAUI1 CAI2 etc

        // allocate the array for pElems
        if (pvarg->caub.pElems == NULL || pvarg->caub.cElems == 0)
        {
            PROPASSERT( hr == S_OK );
            goto errRet; // not really an error
        }

        void *pvAllocated = pDest->caub.pElems = (BYTE *)
            AllocAndCopy(cbType * pvarg->caub.cElems, pvarg->caub.pElems);

        if (pvAllocated == NULL)
        {
            hr = STG_E_INSUFFICIENTMEMORY;
            goto errRet;
        }

        if ((TypeInfo & BIT_VECTNOALLOC) != 0)
        {
            // the vector needs no further allocation
            PROPASSERT( hr == S_OK );
            goto errRet;
        }

        ULONG l;

        // vector types that require allocation ...
        // we first zero out the pointers so that we can use PropVariantClear
        // to clean up in the error case

        switch (pvarg->vt)
        {
        case (VT_VECTOR | VT_BSTR):
            // initialize for error case
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                pDest->cabstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_LPSTR):
        case (VT_VECTOR | VT_LPWSTR):
            // initialize for error case
            for (l=0; l< pvarg->calpstr.cElems; l++)
            {
                pDest->calpstr.pElems[l] = NULL;
            }
            break;

        case (VT_VECTOR | VT_CF):
            // initialize for error case
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                pDest->caclipdata.pElems[l].pClipData  = NULL;
            }
            break;

        case (VT_VECTOR | VT_VARIANT):
            // initialize for error case
            for (l=0; l< pvarg->capropvar.cElems; l++)
            {
                pDest->capropvar.pElems[l].vt = VT_ILLEGAL;
            }
            break;

        default:
            PROPASSERT(!"Internal error: Unexpected type in PropVariantCopy");
            CoTaskMemFree(pvAllocated);
            hr = STG_E_INVALIDPARAMETER;
            goto errRet;
        }

        // now do the vector copy...

        switch (pvarg->vt)
        {
        case (VT_VECTOR | VT_BSTR):
            for (l=0; l< pvarg->cabstr.cElems; l++)
            {
                if (pvarg->cabstr.pElems[l] != NULL)
                {
                    pDest->cabstr.pElems[l] = PropSysAllocString( pvarg->cabstr.pElems[l]);
                    if (pDest->cabstr.pElems[l]  == NULL)
                    {
                        hr = STG_E_INSUFFICIENTMEMORY;
                        break;
                    }
                }
            }
            break;

        case (VT_VECTOR | VT_LPWSTR):
            for (l=0; l< pvarg->calpwstr.cElems; l++)
            {
                if (pvarg->calpwstr.pElems[l] != NULL)
                {

                    pDest->calpwstr.pElems[l] = (LPWSTR)AllocAndCopy(
                        sizeof(WCHAR)*(Prop_wcslen(pvarg->calpwstr.pElems[l])+1),
                        pvarg->calpwstr.pElems[l],
                        &hr);

                    if (hr != S_OK)
                        break;
                }
            }
            break;

        case (VT_VECTOR | VT_LPSTR):
            for (l=0; l< pvarg->calpstr.cElems; l++)
            {
                if (pvarg->calpstr.pElems[l] != NULL)
                {
                    pDest->calpstr.pElems[l] = (LPSTR)AllocAndCopy(
                        strlen(pvarg->calpstr.pElems[l])+1,
                        pvarg->calpstr.pElems[l],
                        &hr);

                    if (hr != S_OK)
                        break;
                }
            }
            break;

        case (VT_VECTOR | VT_CF):
            for (l=0; l< pvarg->caclipdata.cElems; l++)
            {
                // Is the input valid?
                if (NULL == pvarg->caclipdata.pElems[l].pClipData
                    &&
                    0 != CBPCLIPDATA(pvarg->caclipdata.pElems[l] ))
                {
                    hr = STG_E_INVALIDPARAMETER;
                    break;
                }

                // Is there data to copy?
                if (0 != CBPCLIPDATA(pvarg->caclipdata.pElems[l]))
                {
                    pDest->caclipdata.pElems[l].pClipData  = (BYTE*)AllocAndCopy(
                        CBPCLIPDATA(pvarg->caclipdata.pElems[l]),
                        pvarg->caclipdata.pElems[l].pClipData,
                        &hr);

                    if (hr != S_OK)
                        break;
                }
            }
            break;

        case (VT_VECTOR | VT_VARIANT):
            for (l=0; l< pvarg->capropvar.cElems; l++)
            {
                hr = PropVariantCopy(pDest->capropvar.pElems + l,
                                     pvarg->capropvar.pElems + l);
                if (hr != S_OK)
                {
                    break;
                }
            }
            break;

        default:
            PROPASSERT(!"Internal error: Unexpected type in PropVariantCopy");
            CoTaskMemFree(pvAllocated);
            hr = STG_E_INVALIDPARAMETER;
            goto errRet;
        }

        if (hr != S_OK)
        {
            PropVariantClear(pDest);
            goto errRet;
        }
    }

errRet:

    if (hr != S_OK)
    {
        // VT_EMPTY
        PROPASSERT(VT_EMPTY == 0);
        memset(pDest, 0, sizeof(*pDest));
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NtStatusToScode, public
//
//  Synopsis:   Attempts to map an NTSTATUS code to an SCODE
//
//  Arguments:  [nts] - NTSTATUS
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-93       DrewB   Created
//
//  Notes:      Assumes [nts] is an error code
//              This function is by no means exhaustively complete
//
//----------------------------------------------------------------------------

SCODE NtStatusToScode(NTSTATUS nts)
{
    SCODE sc;

    PropDbg((DEB_ITRACE, "In  NtStatusToScode(%lX)\n", nts));

    switch(nts)
    {
    case STATUS_INVALID_PARAMETER:
    case STATUS_INVALID_PARAMETER_MIX:
    case STATUS_INVALID_PARAMETER_1:
    case STATUS_INVALID_PARAMETER_2:
    case STATUS_INVALID_PARAMETER_3:
    case STATUS_INVALID_PARAMETER_4:
    case STATUS_INVALID_PARAMETER_5:
    case STATUS_INVALID_PARAMETER_6:
    case STATUS_INVALID_PARAMETER_7:
    case STATUS_INVALID_PARAMETER_8:
    case STATUS_INVALID_PARAMETER_9:
    case STATUS_INVALID_PARAMETER_10:
    case STATUS_INVALID_PARAMETER_11:
    case STATUS_INVALID_PARAMETER_12:
        sc = STG_E_INVALIDPARAMETER;
        break;

    case STATUS_DUPLICATE_NAME:
    case STATUS_DUPLICATE_OBJECTID:
    case STATUS_OBJECTID_EXISTS:
    case STATUS_OBJECT_NAME_COLLISION:
        sc = STG_E_FILEALREADYEXISTS;
        break;

    case STATUS_NO_SUCH_DEVICE:
    case STATUS_NO_SUCH_FILE:
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_NOT_A_DIRECTORY:
    case STATUS_FILE_IS_A_DIRECTORY:
    case STATUS_PROPSET_NOT_FOUND:
    case STATUS_NOT_FOUND:
    case STATUS_OBJECT_TYPE_MISMATCH:
        sc = STG_E_FILENOTFOUND;
        break;

    case STATUS_OBJECT_NAME_INVALID:
    case STATUS_OBJECT_PATH_SYNTAX_BAD:
    case STATUS_OBJECT_PATH_INVALID:
    case STATUS_NAME_TOO_LONG:
        sc = STG_E_INVALIDNAME;
        break;

    case STATUS_ACCESS_DENIED:
        sc = STG_E_ACCESSDENIED;
        break;

    case STATUS_NO_MEMORY:
    case STATUS_INSUFFICIENT_RESOURCES:
        sc = STG_E_INSUFFICIENTMEMORY;
        break;

    case STATUS_INVALID_HANDLE:
    case STATUS_FILE_INVALID:
    case STATUS_FILE_FORCED_CLOSED:
        sc = STG_E_INVALIDHANDLE;
        break;

    case STATUS_INVALID_DEVICE_REQUEST:
    case STATUS_INVALID_SYSTEM_SERVICE:
    case STATUS_NOT_IMPLEMENTED:
        sc = STG_E_INVALIDFUNCTION;
        break;

    case STATUS_NO_MEDIA_IN_DEVICE:
    case STATUS_UNRECOGNIZED_MEDIA:
    case STATUS_DISK_CORRUPT_ERROR:
    case STATUS_DATA_ERROR:
        sc = STG_E_WRITEFAULT;
        break;

    case STATUS_OBJECT_PATH_NOT_FOUND:
        sc = STG_E_PATHNOTFOUND;
        break;

    case STATUS_SHARING_VIOLATION:
        sc = STG_E_SHAREVIOLATION;
        break;

    case STATUS_FILE_LOCK_CONFLICT:
    case STATUS_LOCK_NOT_GRANTED:
        sc = STG_E_LOCKVIOLATION;
        break;

    case STATUS_DISK_FULL:
        sc = STG_E_MEDIUMFULL;
        break;

    case STATUS_ACCESS_VIOLATION:
    case STATUS_INVALID_USER_BUFFER:
        sc = STG_E_INVALIDPOINTER;
        break;

    case STATUS_TOO_MANY_OPENED_FILES:
        sc = STG_E_TOOMANYOPENFILES;
        break;

    case STATUS_DIRECTORY_NOT_EMPTY:
        sc = WIN32_SCODE(ERROR_DIR_NOT_EMPTY);
        break;

    case STATUS_DELETE_PENDING:
        sc = STG_E_REVERTED;
        break;

    case STATUS_INTERNAL_DB_CORRUPTION:
        sc = STG_E_INVALIDHEADER;
        break;

    case STATUS_UNSUCCESSFUL:
        sc = E_FAIL;
        break;
        
    case STATUS_UNMAPPABLE_CHARACTER:
        sc = HRESULT_FROM_WIN32( ERROR_NO_UNICODE_TRANSLATION );
        break;

    default:
        PropDbg((DEB_ERROR, "NtStatusToScode: Unknown status %lX\n", nts));

        sc = HRESULT_FROM_NT(nts);
        break;
    }

    PropDbg((DEB_ITRACE, "Out NtStatusToScode => %lX\n", sc));
    return sc;
}

#if DBG!=0

ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    CHAR Buffer[512];
    int cb;

    //
    // Format the output into a buffer and then print it.
    //

    va_start(arglist, Format);
    cb = PropVsprintfA(Buffer, Format, arglist);
    if (cb == -1) {             // detect buffer overflow
        cb = sizeof(Buffer);
        Buffer[sizeof(Buffer) - 2] = '\n';
        Buffer[sizeof(Buffer) - 1] = '\0';
    }

    OutputDebugString(Buffer);

    return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\h\propapi.h ===
/*+-------------------------------------------------------------------------  
 * 
 *  Microsoft Windows   
 *  Copyright (C) Microsoft Corporation, 1992 - 1996.  
 *  
 *  File:       propapi.h   
 *   
 *  Contents:   Definitions of Nt property api.   
 *   
 *--------------------------------------------------------------------------*/

#ifndef _PROPAPI_H_
#define _PROPAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

/**/
/* typedef the function prototypes necessary*/
/* for the UNICODECALLOUTS structure.*/
/**/

typedef UINT (WINAPI FNGETACP)(VOID);

typedef int (WINAPI FNMULTIBYTETOWIDECHAR)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCSTR lpMultiByteStr,
    IN int cchMultiByte,
    OUT LPWSTR lpWideCharStr,
    IN int cchWideChar);

typedef int (WINAPI FNWIDECHARTOMULTIBYTE)(
    IN UINT CodePage,
    IN DWORD dwFlags,
    IN LPCWSTR lpWideCharStr,
    IN int cchWideChar,
    OUT LPSTR lpMultiByteStr,
    IN int cchMultiByte,
    IN LPCSTR lpDefaultChar,
    IN LPBOOL lpUsedDefaultChar);

typedef STDAPI_(BSTR) FNSYSALLOCSTRING(
    OLECHAR FAR* pwsz);

typedef STDAPI_(VOID) FNSYSFREESTRING(
    BSTR pwsz);

/**/
/* The UNICODECALLOUTS structure holds function*/
/* pointers for routines needed by the property*/
/* set routines in NTDLL.*/
/**/

typedef struct _UNICODECALLOUTS
{
    FNGETACP              *pfnGetACP;
    FNMULTIBYTETOWIDECHAR *pfnMultiByteToWideChar;
    FNWIDECHARTOMULTIBYTE *pfnWideCharToMultiByte;
    FNSYSALLOCSTRING      *pfnSysAllocString;
    FNSYSFREESTRING       *pfnSysFreeString;
} UNICODECALLOUTS;


/**/
/* Define the default UNICODECALLOUTS*/
/* values.*/
/**/

#define WIN32_UNICODECALLOUTS \
    GetACP,                   \
    MultiByteToWideChar,      \
    WideCharToMultiByte,      \
    SysAllocString,         \
    SysFreeString

# define PROPSYSAPI
# define PROPAPI

# define PropFreeHeap(h, z, p) CoTaskMemFree(p)

# define PROPASSERT assert

#define PROPASSERTMSG(szReason, f) assert( (szReason && FALSE) || (f))

# define PropSprintfA wsprintfA
# define PropVsprintfA wvsprintfA

#define WC_PROPSET0     ((WCHAR) 0x0005)
#define OC_PROPSET0     ((OLECHAR) 0x0005)

#define CBIT_BYTE       8
#define CBIT_GUID       (CBIT_BYTE * sizeof(GUID))
#define CBIT_CHARMASK   5

/* Allow for OC_PROPSET0 and a GUID mapped to a 32 character alphabet */
#define CCH_PROPSET        (1 + (CBIT_GUID + CBIT_CHARMASK-1)/CBIT_CHARMASK)
#define CCH_PROPSETSZ      (CHC_PROPSET + 1)            /* allow null*/
#define CCH_PROPSETCOLONSZ (1 + CHC_PROPSET + 1)        /* allow colon and null*/

/* Define the max property name in units of characters
   (and synonomously in wchars). */
#define CCH_MAXPROPNAME    255                          /* Matches Shell &
                                                           Office */
#define CCH_MAXPROPNAMESZ  (CWC_MAXPROPNAME + 1)        /* allow null */
#define CWC_MAXPROPNAME    CCH_MAXPROPNAME
#define CWC_MAXPROPNAMESZ  CCH_MAXPROPNAMESZ


/*+--------------------------------------------------------------------------*/
/* Property Access APIs:                                                     */
/*---------------------------------------------------------------------------*/

typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;
typedef VOID *NTMEMORYALLOCATOR;


VOID PROPSYSAPI PROPAPI
RtlSetUnicodeCallouts(
    IN UNICODECALLOUTS *pUnicodeCallouts);

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[]);

NTSTATUS PROPSYSAPI PROPAPI
RtlPropertySetNameToGuid(
    IN ULONG cwcname,
    IN OLECHAR const aocname[],
    OUT GUID *pguid);


/* RtlCreatePropertySet Flags:*/

#define CREATEPROP_READ         0x0000 /* request read access (must exist)*/
#define CREATEPROP_WRITE        0x0001 /* request write access (must exist)*/
#define CREATEPROP_CREATE       0x0002 /* create (overwrite if exists)*/
#define CREATEPROP_CREATEIF     0x0003 /* create (open existing if exists)*/
#define CREATEPROP_DELETE       0x0004 /* delete*/
#define CREATEPROP_MODEMASK     0x000f /* open mode mask*/

#define CREATEPROP_NONSIMPLE    0x0010 /* Is non-simple propset (in a storage)*/


/* RtlCreateMappedStream Flags:*/

#define CMS_READONLY      0x00000000    /* Opened for read-only*/
#define CMS_WRITE         0x00000001    /* Opened for write access*/
#define CMS_TRANSACTED    0x00000002    /* Is transacted*/


NTSTATUS PROPSYSAPI PROPAPI
RtlCreatePropertySet(
    IN NTMAPPEDSTREAM ms,       /* Nt mapped stream*/
    IN USHORT Flags,	/* NONSIMPLE|*1* of READ/WRITE/CREATE/CREATEIF/DELETE*/
    OPTIONAL IN GUID const *pguid, /* property set guid (create only)*/
    OPTIONAL IN GUID const *pclsid,/* CLASSID of propset code (create only)*/
    IN NTMEMORYALLOCATOR ma,	/* memory allocator of caller*/
    IN ULONG LocaleId,		/* Locale Id (create only)*/
    OPTIONAL OUT ULONG *pOSVersion,/* OS Version field in header.*/
    IN OUT USHORT *pCodePage,   /* IN: CodePage of property set (create only)*/
                                /* OUT: CodePage of property set (always)*/
    OUT NTPROP *pnp);           /* Nt property set context*/

NTSTATUS PROPSYSAPI PROPAPI
RtlClosePropertySet(
    IN NTPROP np);              /* property set context*/

#define CBSTM_UNKNOWN   ((ULONG) -1)
NTSTATUS PROPSYSAPI PROPAPI
RtlOnMappedStreamEvent(
    IN VOID *pv,               /* property set context */
    IN VOID *pbuf,             /* property set buffer */
    IN ULONG cbstm );          /* size of underlying stream or CBSTM_UNKNOWN */
                                                                           
NTSTATUS PROPSYSAPI PROPAPI
RtlFlushPropertySet(
    IN NTPROP np);              /* property set context*/

NTSTATUS PROPSYSAPI PROPAPI
RtlSetProperties(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPID pidNameFirst,     /* first PROPID for new named properties*/
    IN PROPSPEC const aprs[],   /* array of property specifiers*/
    OPTIONAL OUT PROPID apid[], /* buffer for array of propids*/
    OPTIONAL IN PROPVARIANT const avar[]);/* array of properties with values*/

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryProperties(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPSPEC const aprs[],   /* array of property specifiers*/
    OPTIONAL OUT PROPID apid[], /* buffer for array of propids*/
    IN OUT PROPVARIANT *avar,   /* IN: array of uninitialized PROPVARIANTs,*/
                                /* OUT: may contain pointers to alloc'd memory*/
    OUT ULONG *pcpropFound);    /* count of property values retrieved*/



#define ENUMPROP_NONAMES        0x00000001      /* return property IDs only*/

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumerateProperties(
    IN NTPROP np,               /* property set context*/
    IN ULONG Flags,             /* flags: No Names (propids only), etc.*/
    IN OUT ULONG *pkey,         /* bookmark; caller set to 0 before 1st call*/
    IN OUT ULONG *pcprop,       /* pointer to property count*/
    OPTIONAL OUT PROPSPEC aprs[],/* IN: array of uninitialized PROPSPECs*/
                                /* OUT: may contain pointers to alloc'd strings*/
    OPTIONAL OUT STATPROPSTG asps[]);
                                /* IN: array of uninitialized STATPROPSTGs*/
                                /* OUT: may contain pointers to alloc'd strings*/

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertyNames(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPID const *apid,      /* PROPID array*/
    OUT OLECHAR *apwsz[]          /* OUT pointers to allocated strings*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertyNames(
    IN NTPROP np,               /* property set context*/
    IN ULONG cprop,             /* property count*/
    IN PROPID const *apid,      /* PROPID array*/
    IN OLECHAR const * const apwsz[] /* pointers to property names*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlSetPropertySetClassId(
    IN NTPROP np,               /* property set context*/
    IN GUID const *pclsid       /* new CLASSID of propset code*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlQueryPropertySet(
    IN NTPROP np,               /* property set context*/
    OUT STATPROPSETSTG *pspss   /* buffer for property set stat information*/
    );

NTSTATUS PROPSYSAPI PROPAPI
RtlEnumeratePropertySets(
    IN HANDLE hstg,             /* structured storage handle*/
    IN BOOLEAN fRestart,        /* restart scan*/
    IN OUT ULONG *pcspss,       /* pointer to count of STATPROPSETSTGs*/
    IN OUT GUID *pkey,          /* bookmark*/
    OUT STATPROPSETSTG *pspss   /* array of STATPROPSETSTGs*/
    );

#ifdef __cplusplus
}
#endif

#endif /* ifndef _PROPAPI_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\h\windef.h ===
#ifndef _WINDEF_H__
#define _WINDEF_H__

#include "../../h/props.h"
#include "ntstatus.h"  /* status codes */

#ifdef _WIN32
#define WINAPI STDMETHODCALLTYPE
#else
#define WINAPI
#endif

/* these parameter modifiers are for informational purposes only */
#define IN 
#define OUT
#define OPTIONAL
#define UNALIGNED
#define CP_WINUNICODE 1200  /* 0x04b0 */

typedef void* PVOID;
typedef PVOID HANDLE;
typedef VOID *NTPROP;
typedef VOID *NTMAPPEDSTREAM;

#define INVALID_HANDLE_VALUE ((HANDLE) -1)

/* no multithread protect in reference implementation as yet */
inline long InterlockedIncrement(long *pulArg)
{ return ++(*pulArg); }
inline long InterlockedDecrement(long *pulArg)
{ return --(*pulArg); }

/* right now only US ansi support */
EXTERN_C STDAPI_(UINT) GetACP(VOID);
typedef ULONG LCID, *PLCID;
inline LCID GetUserDefaultLCID(void)
{
    /* Windows Code Page 1252 :(LANG_ENGLISH,SUBLANG_ENGLISH_US) */
    return 0x409; 
}

#define CP_ACP 0

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#define wsprintfA sprintf
#define wvsprintfA vsprintf

inline void OutputDebugString(LPSTR sz)
{
    printf("%s", sz);
}

#include <assert.h>
#define Win4Assert assert

#define TEXT(x) _T(x)

/* memory manupulation routines */
#define RtlCopyMemory(dest,src,count)    memcpy(dest, src, count)
#define RtlZeroMemory(dest, len)         memset(dest, 0, len)
#define RtlMoveMemory(dest, src, count)  memmove(dest, src, count)

#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))

#define WINVER 0x400

inline LONG CompareFileTime(
    const FILETIME *lpFileTime1,	/* pointer to first file time */
    const FILETIME *lpFileTime2 	/* pointer to second file time */
   )
{
    LONG ldiff = lpFileTime1->dwHighDateTime - lpFileTime2->dwHighDateTime;
    if (ldiff == 0)
        ldiff = lpFileTime1->dwLowDateTime - lpFileTime2->dwLowDateTime;
    if (ldiff > 0) 
        ldiff = 1;
    else if (ldiff < 0) 
        ldiff = -1;
    return ldiff;
}

#define MAKELONG(a, b)      ( (LONG)( ((WORD) (a)) | \
                                      ((DWORD) ((WORD) (b)))<< 16) )

#endif  /* _WINDEF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\props\h\ntstatus.h ===
/*

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ntstatus.h

Abstract:

    Constant definitions for the NTSTATUS values.

Notes:

    This file is from the NT SDK, a lot of these error codes are not
    being used in the reference implementation.

*/

#ifndef _NTSTATUS_
#define _NTSTATUS_

/////////////////////////////////////////////////////////////////////////
//
// Standard Success values
//
//
/////////////////////////////////////////////////////////////////////////


//
// The success status codes 0 - 63 are reserved for wait completion status.
//
#define STATUS_SUCCESS \
    ((NTSTATUS)0x00000000L)

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the status code of facility
//
//
// Define the facility codes
//
 
//
// MessageId: STATUS_IMAGE_MACHINE_TYPE_MISMATCH
//
// MessageText:
//
//  {Machine Type Mismatch}
//  The image file %s is valid, but is for a machine type other than the current machine. Select OK to continue, or CANCEL to fail the DLL load.
//
#define STATUS_IMAGE_MACHINE_TYPE_MISMATCH ((NTSTATUS)0x4000000EL)


//
// MessageId: STATUS_BUFFER_OVERFLOW
//
// MessageText:
//
//  {Buffer Overflow}
//  The data was too large to fit into the specified buffer.
//
#define STATUS_BUFFER_OVERFLOW           ((NTSTATUS)0x80000005L)

//
// MessageId: STATUS_UNSUCCESSFUL
//
// MessageText:
//
//  {Operation Failed}
//  The requested operation was unsuccessful.
//
#define STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)

//
// MessageId: STATUS_NOT_IMPLEMENTED
//
// MessageText:
//
//  {Not Implemented}
//  The requested operation is not implemented.
//
#define STATUS_NOT_IMPLEMENTED           ((NTSTATUS)0xC0000002L)

//
// MessageId: STATUS_ACCESS_VIOLATION
//
// MessageText:
//
//  The instruction at "0x%08lx" referenced memory at "0x%08lx". The memory
//  could not be "%s".
//
#define STATUS_ACCESS_VIOLATION          ((NTSTATUS)0xC0000005L)    // winnt ntsubauth

//
// MessageId: STATUS_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  {Unknown Disk Format}
//  The disk in drive %s is not formatted properly.
//  Please check the disk, and reformat if necessary.
//
#define STATUS_UNRECOGNIZED_MEDIA        ((NTSTATUS)0xC0000014L)

//
// MessageId: STATUS_INVALID_HANDLE
//
// MessageText:
//
//  An invalid HANDLE was specified.
//
#define STATUS_INVALID_HANDLE            ((NTSTATUS)0xC0000008L)    // winnt

//
// MessageId: STATUS_INVALID_PARAMETER
//
// MessageText:
//
//  An invalid parameter was passed to a service or function.
//
#define STATUS_INVALID_PARAMETER         ((NTSTATUS)0xC000000DL)

//
// MessageId: STATUS_NO_SUCH_DEVICE
//
// MessageText:
//
//  A device which does not exist was specified.
//
#define STATUS_NO_SUCH_DEVICE            ((NTSTATUS)0xC000000EL)


//
// MessageId: STATUS_NO_SUCH_FILE
//
// MessageText:
//
//  {File Not Found}
//  The file %s does not exist.
//
#define STATUS_NO_SUCH_FILE              ((NTSTATUS)0xC000000FL)

//
// MessageId: STATUS_INVALID_DEVICE_REQUEST
//
// MessageText:
//
//  The specified request is not a valid operation for the target device.
//
#define STATUS_INVALID_DEVICE_REQUEST    ((NTSTATUS)0xC0000010L)

//
// MessageId: STATUS_NO_MEDIA_IN_DEVICE
//
// MessageText:
//
//  {No Disk}
//  There is no disk in the drive.
//  Please insert a disk into drive %s.
//
#define STATUS_NO_MEDIA_IN_DEVICE        ((NTSTATUS)0xC0000013L)

//
// MessageId: STATUS_NO_MEDIA_IN_DEVICE
//
// MessageText:
//
//  {No Disk}
//  There is no disk in the drive.
//  Please insert a disk into drive %s.
//
#define STATUS_NO_MEDIA_IN_DEVICE        ((NTSTATUS)0xC0000013L)

//
// MessageId: STATUS_UNRECOGNIZED_MEDIA
//
// MessageText:
//
//  {Unknown Disk Format}
//  The disk in drive %s is not formatted properly.
//  Please check the disk, and reformat if necessary.
//
#define STATUS_UNRECOGNIZED_MEDIA        ((NTSTATUS)0xC0000014L)

//
// MessageId: STATUS_UNABLE_TO_DELETE_SECTION
//
// MessageText:
//
//  Specified section cannot be deleted.
//
#define STATUS_UNABLE_TO_DELETE_SECTION  ((NTSTATUS)0xC000001BL)

//
// MessageId: STATUS_INVALID_SYSTEM_SERVICE
//
// MessageText:
//
//  An invalid system service was specified in a system service call.
//
#define STATUS_INVALID_SYSTEM_SERVICE    ((NTSTATUS)0xC000001CL)

//
// MessageId: STATUS_NO_MEMORY
//
// MessageText:
//
//  {Not Enough Quota}
//  Not enough virtual memory or paging file quota is available to complete
//  the specified operation.
//
#define STATUS_NO_MEMORY                 ((NTSTATUS)0xC0000017L)    // winnt

//
// MessageId: STATUS_ACCESS_DENIED
//
// MessageText:
//
//  {Access Denied}
//  A process has requested access to an object, but has not been granted
//  those access rights.
//
#define STATUS_ACCESS_DENIED             ((NTSTATUS)0xC0000022L)

//
// MessageId: STATUS_OBJECT_TYPE_MISMATCH
//
// MessageText:
//
//  {Wrong Type}
//  There is a mismatch between the type of object required by the requested
//  operation and the type of object that is specified in the request.
//
#define STATUS_OBJECT_TYPE_MISMATCH      ((NTSTATUS)0xC0000024L)

//
// MessageId: STATUS_INVALID_PARAMETER_MIX
//
// MessageText:
//
//  An invalid combination of parameters was specified.
//
#define STATUS_INVALID_PARAMETER_MIX     ((NTSTATUS)0xC0000030L)

//
// MessageId: STATUS_DISK_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt Disk}
//  The file system structure on the disk is corrupt and unusable.
//  Please run the Chkdsk utility on the volume %s.
//
#define STATUS_DISK_CORRUPT_ERROR        ((NTSTATUS)0xC0000032L)

//
// MessageId: STATUS_OBJECT_NAME_INVALID
//
// MessageText:
//
//  Object Name invalid.
//
#define STATUS_OBJECT_NAME_INVALID       ((NTSTATUS)0xC0000033L)

//
// MessageId: STATUS_OBJECT_NAME_NOT_FOUND
//
// MessageText:
//
//  Object Name not found.
//
#define STATUS_OBJECT_NAME_NOT_FOUND     ((NTSTATUS)0xC0000034L)


//
// MessageId: STATUS_OBJECT_NAME_COLLISION
//
// MessageText:
//
//  Object Name already exists.
//
#define STATUS_OBJECT_NAME_COLLISION     ((NTSTATUS)0xC0000035L)

//
// MessageId: STATUS_OBJECT_PATH_INVALID
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_INVALID       ((NTSTATUS)0xC0000039L)

//
// MessageId: STATUS_OBJECT_PATH_NOT_FOUND
//
// MessageText:
//
//  {Path Not Found}
//  The path %s does not exist.
//
#define STATUS_OBJECT_PATH_NOT_FOUND     ((NTSTATUS)0xC000003AL)

//
// MessageId: STATUS_OBJECT_PATH_SYNTAX_BAD
//
// MessageText:
//
//  Object Path Component was not a directory object.
//
#define STATUS_OBJECT_PATH_SYNTAX_BAD    ((NTSTATUS)0xC000003BL)

//
// MessageId: STATUS_DATA_ERROR
//
// MessageText:
//
//  {Data Error}
//  An error in reading or writing data occurred.
//
#define STATUS_DATA_ERROR                ((NTSTATUS)0xC000003EL)

//
// MessageId: STATUS_NO_SUCH_FILE
//
// MessageText:
//
//  {File Not Found}
//  The file %s does not exist.
//
#define STATUS_NO_SUCH_FILE              ((NTSTATUS)0xC000000FL)

//
// MessageId: STATUS_SHARING_VIOLATION
//
// MessageText:
//
//  A file cannot be opened because the share access flags are
//  incompatible.
//
#define STATUS_SHARING_VIOLATION         ((NTSTATUS)0xC0000043L)

//
// MessageId: STATUS_FILE_LOCK_CONFLICT
//
// MessageText:
//
//  A requested read/write cannot be granted due to a conflicting file lock.
//
#define STATUS_FILE_LOCK_CONFLICT        ((NTSTATUS)0xC0000054L)

//
// MessageId: STATUS_LOCK_NOT_GRANTED
//
// MessageText:
//
//  A requested file lock cannot be granted due to other existing locks.
//
#define STATUS_LOCK_NOT_GRANTED          ((NTSTATUS)0xC0000055L)

//
// MessageId: STATUS_DELETE_PENDING
//
// MessageText:
//
//  A non close operation has been requested of a file object with a
//  delete pending.
//
#define STATUS_DELETE_PENDING            ((NTSTATUS)0xC0000056L)

//
// MessageId: STATUS_INTERNAL_DB_CORRUPTION
//
// MessageText:
//
//  This error indicates that the requested operation cannot be
//  completed due to a catastrophic media failure or on-disk data
//  structure corruption.
//
#define STATUS_INTERNAL_DB_CORRUPTION    ((NTSTATUS)0xC00000E4L)


//
// MessageId: STATUS_DISK_FULL
//
// MessageText:
//
//  An operation failed because the disk was full.
//
#define STATUS_DISK_FULL                 ((NTSTATUS)0xC000007FL)

//
// MessageId: STATUS_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define STATUS_FILE_INVALID              ((NTSTATUS)0xC0000098L)

//
// MessageId: STATUS_INSUFFICIENT_RESOURCES
//
// MessageText:
//
//  Insufficient system resources exist to complete the API.
//
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)     // ntsubauth


//
// MessageId: STATUS_FILE_INVALID
//
// MessageText:
//
//  The volume for a file has been externally altered such that the
//  opened file is no longer valid.
//
#define STATUS_FILE_INVALID              ((NTSTATUS)0xC0000098L)

//
// MessageId: STATUS_FILE_FORCED_CLOSED
//
// MessageText:
//
//  The specified file has been closed by another process.
//
#define STATUS_FILE_FORCED_CLOSED        ((NTSTATUS)0xC00000B6L)

//
// MessageId: STATUS_FILE_IS_A_DIRECTORY
//
// MessageText:
//
//  The file that was specified as a target is a directory and the caller
//  specified that it could be anything but a directory.
//
#define STATUS_FILE_IS_A_DIRECTORY       ((NTSTATUS)0xC00000BAL)

//
// MessageId: STATUS_DUPLICATE_NAME
//
// MessageText:
//
//  A duplicate name exists on the network.
//
#define STATUS_DUPLICATE_NAME            ((NTSTATUS)0xC00000BDL)

//
// Status codes raised by the Cache Manager which must be considered as
// "expected" by its callers.
//
//
// MessageId: STATUS_INVALID_USER_BUFFER
//
// MessageText:
//
//  An access to a user buffer failed at an "expected" point in time.
//  This code is defined since the caller does not want to accept
//  STATUS_ACCESS_VIOLATION in its filter.
//
#define STATUS_INVALID_USER_BUFFER       ((NTSTATUS)0xC00000E8L)

//
// MessageId: STATUS_INVALID_PARAMETER_1
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the first argument.
//
#define STATUS_INVALID_PARAMETER_1       ((NTSTATUS)0xC00000EFL)

//
// MessageId: STATUS_INVALID_PARAMETER_2
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the second argument.
//
#define STATUS_INVALID_PARAMETER_2       ((NTSTATUS)0xC00000F0L)

//
// MessageId: STATUS_INVALID_PARAMETER_3
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the third argument.
//
#define STATUS_INVALID_PARAMETER_3       ((NTSTATUS)0xC00000F1L)

//
// MessageId: STATUS_INVALID_PARAMETER_4
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the fourth argument.
//
#define STATUS_INVALID_PARAMETER_4       ((NTSTATUS)0xC00000F2L)

//
// MessageId: STATUS_INVALID_PARAMETER_5
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the fifth argument.
//
#define STATUS_INVALID_PARAMETER_5       ((NTSTATUS)0xC00000F3L)

//
// MessageId: STATUS_INVALID_PARAMETER_6
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the sixth argument.
//
#define STATUS_INVALID_PARAMETER_6       ((NTSTATUS)0xC00000F4L)

//
// MessageId: STATUS_INVALID_PARAMETER_7
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the seventh argument.
//
#define STATUS_INVALID_PARAMETER_7       ((NTSTATUS)0xC00000F5L)

//
// MessageId: STATUS_INVALID_PARAMETER_8
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the eighth argument.
//
#define STATUS_INVALID_PARAMETER_8       ((NTSTATUS)0xC00000F6L)

//
// MessageId: STATUS_INVALID_PARAMETER_9
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the ninth argument.
//
#define STATUS_INVALID_PARAMETER_9       ((NTSTATUS)0xC00000F7L)

//
// MessageId: STATUS_INVALID_PARAMETER_10
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the tenth argument.
//
#define STATUS_INVALID_PARAMETER_10      ((NTSTATUS)0xC00000F8L)

//
// MessageId: STATUS_INVALID_PARAMETER_11
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the eleventh argument.
//
#define STATUS_INVALID_PARAMETER_11      ((NTSTATUS)0xC00000F9L)

//
// MessageId: STATUS_INVALID_PARAMETER_12
//
// MessageText:
//
//  An invalid parameter was passed to a service or function as
//  the twelfth argument.
//
#define STATUS_INVALID_PARAMETER_12      ((NTSTATUS)0xC00000FAL)

//
// MessageId: STATUS_DIRECTORY_NOT_EMPTY
//
// MessageText:
//
//  Indicates that the directory trying to be deleted is not empty.
//
#define STATUS_DIRECTORY_NOT_EMPTY       ((NTSTATUS)0xC0000101L)

//
// MessageId: STATUS_FILE_CORRUPT_ERROR
//
// MessageText:
//
//  {Corrupt File}
//  The file or directory %s is corrupt and unreadable.
//  Please run the Chkdsk utility.
//
#define STATUS_FILE_CORRUPT_ERROR        ((NTSTATUS)0xC0000102L)

//
// MessageId: STATUS_NOT_A_DIRECTORY
//
// MessageText:
//
//  A requested opened file is not a directory.
//

//
// MessageId: STATUS_NOT_A_DIRECTORY
//
// MessageText:
//
//  A requested opened file is not a directory.
//
#define STATUS_NOT_A_DIRECTORY           ((NTSTATUS)0xC0000103L)

//
// MessageId: STATUS_NAME_TOO_LONG
//
// MessageText:
//
//  A specified name string is too long for its intended use.
//
#define STATUS_NAME_TOO_LONG             ((NTSTATUS)0xC0000106L)

//
// MessageId: STATUS_BUFFER_ALL_ZEROS
//
// MessageText:
//
//  Specified buffer contains all zeros.
//
#define STATUS_BUFFER_ALL_ZEROS          ((NTSTATUS)0x00000117L)

//
// MessageId: STATUS_TOO_MANY_OPENED_FILES
//
// MessageText:
//
//  Too many files are opened on a remote server.  This error should only
//  be returned by the NT redirector on a remote drive.
//
#define STATUS_TOO_MANY_OPENED_FILES     ((NTSTATUS)0xC000011FL)

//
// MessageId: STATUS_UNMAPPABLE_CHARACTER
//
// MessageText:
//
//  No mapping for the Unicode character exists in the target multi-byte code page.
//
#define STATUS_UNMAPPABLE_CHARACTER      ((NTSTATUS)0xC0000162L)

//
// MessageId: STATUS_NOT_FOUND
//
// MessageText:
//
//  The object was not found.
//
#define STATUS_NOT_FOUND                 ((NTSTATUS)0xC0000225L)

//
// MessageId: STATUS_DUPLICATE_OBJECTID
//
// MessageText:
//
//  The attempt to insert the ID in the index failed because the
//  ID is already in the index.
//
#define STATUS_DUPLICATE_OBJECTID        ((NTSTATUS)0xC000022AL)

//
// MessageId: STATUS_OBJECTID_EXISTS
//
// MessageText:
//
//  The attempt to set the object's ID failed because the object
//  already has an ID.
//
#define STATUS_OBJECTID_EXISTS           ((NTSTATUS)0xC000022BL)

//
// MessageId: STATUS_PROPSET_NOT_FOUND
//
// MessageText:
//
//  The property set specified does not exist on the object.
//
#define STATUS_PROPSET_NOT_FOUND         ((NTSTATUS)0xC0000230L)

#endif // _NTSTATUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\proptest\cpropvar.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       cpropvar.cxx
//
//---------------------------------------------------------------

#include "cpropvar.hxx"
#include "chresult.hxx"
#include <stdio.h>
#include "../../h/tchar.h"

 
// this function is from refstg
BOOLEAN STDCALL 
RtlCompareVariants(
    USHORT CodePage,
    PROPVARIANT const *pvar1,
    PROPVARIANT const *pvar2);


DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(LPSTR, LPSTR);
DEFINE_CPROPVARIANT_CONVERSION_OPERATOR(LPSTR, calpstr, pszVal );

DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(LPWSTR, LPWSTR);
DEFINE_CPROPVARIANT_CONVERSION_OPERATOR(LPWSTR, calpwstr, pwszVal );

DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(CF, CLIPDATA&);
DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(CF, CClipData&);
DEFINE_CPROPVARIANT_ASSIGNMENT_OPERATOR(CLSID, CLSID);


CPropVariant::CPropVariant( VARENUM v, ULONG cElements)
{
    Init(v, cElements);
}

void CPropVariant::Init(
    VARENUM v,
    ULONG cElements)
{
    ULONG cbElement;
    BOOLEAN fZero = FALSE;

    // Ignore vector flag.  This constructor is always for vectors only.

    vt = v | VT_VECTOR;

    switch (vt)
    {
    case VT_VECTOR | VT_UI1:
        cbElement = sizeof(caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbElement = sizeof(cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbElement = sizeof(cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbElement = sizeof(cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbElement = sizeof(GUID);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_CF:
        cbElement = sizeof(CLIPDATA);
        fZero = TRUE;
        break;

    case VT_VECTOR | VT_BSTR:
    case VT_VECTOR | VT_LPSTR:
    case VT_VECTOR | VT_LPWSTR:
        cbElement = sizeof(VOID *);
        fZero = TRUE;
        break; 

    case VT_VECTOR | VT_VARIANT:
        cbElement = sizeof(PROPVARIANT);
        ASSERT(VT_EMPTY == 0);
        fZero = TRUE;
        break;

    default:
        ASSERT(!"CAllocStorageVariant -- Invalid vector type");
        vt = VT_EMPTY;
        break;
    }
    if (vt != VT_EMPTY)
    {
        caub.cElems = 0;
        caub.pElems = (BYTE *) CoTaskMemAlloc(cElements * cbElement);
        if (caub.pElems != NULL)
        {
            if (fZero)
            {
                memset(caub.pElems, 0, cElements * cbElement);
            }
            caub.cElems = cElements;
        }
    }
}


VOID *
CPropVariant::_AddStringToVector(
    unsigned pos,
    VOID *pv,
    ULONG cb)
{
    ASSERT(vt == (VT_VECTOR | VT_BSTR)   ||
           vt == (VT_VECTOR | VT_LPSTR)  ||
           vt == (VT_VECTOR | VT_LPWSTR) ||
           vt == (VT_VECTOR | VT_CF) );
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * sizeof(calpstr.pElems[0]));
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }
        memcpy(calpstr.pElems, ppsz, calpstr.cElems * sizeof(calpstr.pElems[0]));
        memset(
            &calpstr.pElems[calpstr.cElems],
            0,
            ((pos + 1) - calpstr.cElems) * sizeof(calpstr.pElems[0]));
        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }

    LPSTR psz;

    if( (VT_VECTOR | VT_BSTR) == vt )
    {
        psz = (LPSTR) SysAllocString( (BSTR) pv );
        if (psz == NULL)
        {
            return(NULL);
        }

        if (calpstr.pElems[pos] != NULL)
        {
            SysFreeString((BSTR) calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }
    else
    {
        psz = (LPSTR) CoTaskMemAlloc((VT_BSTR == (vt & ~VT_VECTOR) )
                                       ? cb + sizeof(ULONG)
                                       : cb );
        if (psz == NULL)
        {
            return(NULL);
        }

        memcpy(psz, pv, cb);

        if (calpstr.pElems[pos] != NULL)
        {
            CoTaskMemFree(calpstr.pElems[pos]);
        }
        calpstr.pElems[pos] = psz;
    }


    return(calpstr.pElems[pos]);
}


VOID *
CPropVariant::_AddScalerToVector(
    unsigned pos,
    VOID *pv,
    ULONG cb)
{
    ASSERT(calpstr.pElems != NULL);

    if (pos >= calpstr.cElems)
    {
        char **ppsz = calpstr.pElems;

        calpstr.pElems =
            (char **) CoTaskMemAlloc((pos + 1) * cb);
        if (calpstr.pElems == NULL)
        {
            calpstr.pElems = ppsz;
            return(NULL);
        }
        memset(
            calpstr.pElems,
            0,
            ((pos + 1) - calpstr.cElems) * cb);
        memcpy(calpstr.pElems, ppsz, calpstr.cElems * cb);
        calpstr.cElems = pos + 1;
        CoTaskMemFree(ppsz);
    }


    memcpy( (BYTE*)calpstr.pElems + pos*cb, pv, cb );
    return( (BYTE*)calpstr.pElems + pos*cb );

}
void
CPropVariant::SetLPSTR(
    char const *psz,
    unsigned pos)
{
    if (vt != (VT_VECTOR | VT_LPSTR))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_LPSTR, pos);
    }
    _AddStringToVector(pos, (VOID *) psz, strlen(psz) + 1);
}


void
CPropVariant::SetLPWSTR(
    WCHAR const *pwsz,
    unsigned pos)
{
    if (vt != (VT_VECTOR | VT_LPWSTR))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_LPWSTR, pos);
    }
    _AddStringToVector(pos, (VOID *) pwsz,
                       sizeof(WCHAR) * (wcslen(pwsz) + 1) );
}


void
CPropVariant::SetCF(
    const CLIPDATA *pclipdata,
    unsigned pos)
{
    CLIPDATA *pclipdataNew;

    if (vt != (VT_VECTOR | VT_CF))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_CF, pos);
    }

    pclipdataNew = (CLIPDATA*) _AddScalerToVector(pos, (VOID *) pclipdata, sizeof(CLIPDATA) );

    if( NULL != pclipdataNew
        &&
        NULL != pclipdata )
    {
        pclipdataNew->pClipData = (BYTE*) CoTaskMemAlloc( CBPCLIPDATA(*pclipdata) );
        if( NULL == pclipdataNew->pClipData )
        {
            ASSERT( !"Couldn't allocate pclipdataNew" );
            return;
        }
        else
        {
            pclipdataNew->cbSize = pclipdata->cbSize;
            pclipdataNew->ulClipFmt = pclipdata->ulClipFmt;

            memcpy( pclipdataNew->pClipData,
                    pclipdata->pClipData,
                    CBPCLIPDATA(*pclipdata) );
            return;
        }
    }
}


void
CPropVariant::SetBSTR(
    const BSTR pbstr,
    unsigned int pos)
{
    if (vt != (VT_VECTOR | VT_BSTR))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_BSTR, pos+1);
    }
    _AddStringToVector(pos, (VOID *) pbstr,
                       sizeof(OLECHAR) * (ocslen(pbstr) + 1) );
}


BSTR
CPropVariant::GetBSTR( int nSubscript )
{
    ASSERT( vt & VT_VECTOR );
    ASSERT( vt == (VT_BSTR | VT_VECTOR) );
    ASSERT( wReserved1 > 0 );

    if( wReserved1 > 0
        &&
        cabstr.cElems > 0
        &&
        wReserved1 <= cabstr.cElems )
    {
        int nSubscript = wReserved1 - 1;
        wReserved1 = INVALID_SUBSCRIPT;
        return( cabstr.pElems[ nSubscript ] );
    }
    else
        return( NULL );
}

CPropVariant & CPropVariant::operator=(LPPROPVARIANT lppropvar) 
{
    if( INVALID_SUBSCRIPT == wReserved1 )
    {
        ASSERT( INVALID_SUBSCRIPT != wReserved1 );
        PropVariantClear(this);
	Init();
        return (*this);
    }
    else
    {
        if( !(vt & VT_VECTOR)
            ||
            (vt & ~VT_VECTOR) != VT_VARIANT )
        {
            USHORT wReserved1Save = wReserved1;
            PropVariantClear(this);
	    Init(VT_VARIANT, wReserved1Save );
            wReserved1 = wReserved1Save;
        }

        SetLPPROPVARIANT( lppropvar, wReserved1 - 1 );
        wReserved1 = INVALID_SUBSCRIPT;
        return (*this);
    }
}
        

CPropVariant::operator LPPROPVARIANT()
{
    if( vt & VT_VECTOR )
    {
        if( wReserved1 > 0
            &&
            capropvar.cElems > 0
            &&
            wReserved1 <= capropvar.cElems )
        {
            int nSubscript = wReserved1 - 1;
            wReserved1 = INVALID_SUBSCRIPT;
            return( &capropvar.pElems[ nSubscript ] );
        }
        else
        {
            ASSERT( INVALID_SUBSCRIPT == wReserved1 );
            return( (LPPROPVARIANT) this );
        }
    }
    else
        return( (LPPROPVARIANT) this );
}


void
CPropVariant::SetLPPROPVARIANT( LPPROPVARIANT lppropvar, unsigned pos )
{
    if (vt != (VT_VECTOR | VT_VARIANT))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_VARIANT, pos + 1);
    }
    
    if (pos >= capropvar.cElems)
    {
        LPPROPVARIANT rgpropvar = capropvar.pElems;

        capropvar.pElems =
            (PROPVARIANT *) CoTaskMemAlloc((pos + 1) * sizeof(capropvar.pElems[0]));
        if (capropvar.pElems == NULL)
        {
            capropvar.pElems = rgpropvar;
            return;
        }
        memcpy(capropvar.pElems, rgpropvar, capropvar.cElems * sizeof(capropvar.pElems[0]));
        memset(
            &capropvar.pElems[capropvar.cElems],
            0,
            ((pos + 1) - capropvar.cElems) * sizeof(capropvar.pElems[0]));
        capropvar.cElems = pos + 1;
        CoTaskMemFree(rgpropvar);
    }

    PropVariantClear( &capropvar.pElems[pos] );
    PropVariantCopy( &capropvar.pElems[pos], lppropvar );

    return;

}

void CPropVariant::Init(const CLIPDATA *p)
{
    Init();

    if( NULL == p )
        return;

    pclipdata = (CLIPDATA*) CoTaskMemAlloc( sizeof(CLIPDATA) );
    if( NULL == pclipdata )
    {
        return;
    }

    pclipdata->cbSize = p->cbSize;
    pclipdata->ulClipFmt = p->ulClipFmt;
    pclipdata->pClipData = NULL;

    if( sizeof(pclipdata->ulClipFmt) > p->cbSize )
    {
	Init();
        return;
    }


    if( NULL != p->pClipData )
    {
        pclipdata->pClipData = (BYTE*) CoTaskMemAlloc( pclipdata->cbSize
                                                      - sizeof(pclipdata->ulClipFmt) );
        if( NULL == pclipdata->pClipData )
            return;

        memcpy( pclipdata->pClipData, p->pClipData, pclipdata->cbSize - sizeof(pclipdata->ulClipFmt) );
    }

    vt = VT_CF;

}

void
CPropVariant::SetCLSID( const CLSID &clsid )
{
    PropVariantClear( this );

    puuid = (CLSID*) CoTaskMemAlloc( sizeof(CLSID) );
    if( NULL == puuid )
    {
        assert(FALSE && "out of memory!");
        exit(-1);
    }

    *puuid = clsid;
    vt = VT_CLSID;
}


void
CPropVariant::SetCLSID(
    const CLSID &clsid,
    unsigned pos)
{
    CLSID *pclsidNew;

    if (vt != (VT_VECTOR | VT_CLSID))
    {
        PropVariantClear( this );
        new (this) CPropVariant(VT_CLSID, pos);
    }

    pclsidNew = (CLSID*) _AddScalerToVector(pos, (VOID *) &clsid, sizeof(CLSID) );

    if( NULL != pclsidNew )
    {
        *pclsidNew = clsid;
    }
}


HRESULT
CPropVariant::Compare( PROPVARIANT *ppropvar1, PROPVARIANT *ppropvar2 )
{
    if( RtlCompareVariants( CP_ACP,     // Ignored,
                            ppropvar1,
                            ppropvar2 ))
    {
        return( S_OK );
    }
    else
    {
        return( S_FALSE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\proptest\testdoc.cxx ===
unsigned char g_achTestDoc[] = {
    0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,//........>.......
    0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x03,0x00,0x00,0x00,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x52,0x00,0x6f,0x00,0x6f,0x00,0x74,0x00,0x20,0x00,0x45,0x00,0x6e,0x00,0x74,0x00,//R.o.o.t. .E.n.t.
    0x72,0x00,0x79,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//r.y.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x05,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x03,0x00,0x00,0x00,//................
    0x00,0x09,0x02,0x00,0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,//...............F
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x7f,0xd9,0x7b,//............P..{
    0x1a,0x05,0xba,0x01,0x06,0x00,0x00,0x00,0x40,0x0f,0x00,0x00,0x00,0x00,0x00,0x00,//........@.......
    0x01,0x00,0x43,0x00,0x6f,0x00,0x6d,0x00,0x70,0x00,0x4f,0x00,0x62,0x00,0x6a,0x00,//..C.o.m.p.O.b.j.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x12,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6e,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//........n.......
    0x57,0x00,0x6f,0x00,0x72,0x00,0x64,0x00,0x44,0x00,0x6f,0x00,0x63,0x00,0x75,0x00,//W.o.r.d.D.o.c.u.
    0x6d,0x00,0x65,0x00,0x6e,0x00,0x74,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//m.e.n.t.........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x1a,0x00,0x02,0x01,0xff,0xff,0xff,0xff,0x04,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x4f,0x00,0x62,0x00,0x6a,0x00,0x65,0x00,0x63,0x00,0x74,0x00,0x50,0x00,0x6f,0x00,//O.b.j.e.c.t.P.o.
    0x6f,0x00,0x6c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//o.l.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x16,0x00,0x01,0x01,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x81,0x8f,0x87,0x7a,0x04,0xba,0x01,0x00,0x81,0x8f,0x87,//........z.......
    0x7a,0x04,0xba,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//z...............
    0x02,0x00,0x00,0x00,0xfd,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,0xfe,0xff,0xff,0xff,//................
    0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x05,0x00,0x53,0x00,0x75,0x00,0x6d,0x00,0x6d,0x00,0x61,0x00,0x72,0x00,0x79,0x00,//..S.u.m.m.a.r.y.
    0x49,0x00,0x6e,0x00,0x66,0x00,0x6f,0x00,0x72,0x00,0x6d,0x00,0x61,0x00,0x74,0x00,//I.n.f.o.r.m.a.t.
    0x69,0x00,0x6f,0x00,0x6e,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//i.o.n...........
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x28,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//(...............
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0xdd,0x01,0x00,0x00,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x01,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x08,0x00,0x00,0x00,//................
    0x09,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,//................
    0x0d,0x00,0x00,0x00,0x0e,0x00,0x00,0x00,0x17,0x00,0x00,0x00,0x10,0x00,0x00,0x00,//................
    0x11,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x13,0x00,0x00,0x00,0x14,0x00,0x00,0x00,//................
    0x15,0x00,0x00,0x00,0x16,0x00,0x00,0x00,0xfe,0xff,0xff,0xff,0x18,0x00,0x00,0x00,//................
    0x19,0x00,0x00,0x00,0x1a,0x00,0x00,0x00,0x1b,0x00,0x00,0x00,0x1c,0x00,0x00,0x00,//................
    0x1d,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x1f,0x00,0x00,0x00,0x20,0x00,0x00,0x00,//............ ...
    0x21,0x00,0x00,0x00,0x22,0x00,0x00,0x00,0x23,0x00,0x00,0x00,0x24,0x00,0x00,0x00,//!..."...#...$...
    0x25,0x00,0x00,0x00,0x26,0x00,0x00,0x00,0x27,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//%...&...'...(...
    0x29,0x00,0x00,0x00,0x2a,0x00,0x00,0x00,0x2b,0x00,0x00,0x00,0x2c,0x00,0x00,0x00,//)...*...+...,...
    0x2d,0x00,0x00,0x00,0x2e,0x00,0x00,0x00,0x2f,0x00,0x00,0x00,0x30,0x00,0x00,0x00,//-......./...0...
    0x31,0x00,0x00,0x00,0x32,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x34,0x00,0x00,0x00,//1...2...3...4...
    0x35,0x00,0x00,0x00,0x36,0x00,0x00,0x00,0x37,0x00,0x00,0x00,0x38,0x00,0x00,0x00,//5...6...7...8...
    0x39,0x00,0x00,0x00,0x3a,0x00,0x00,0x00,0x3b,0x00,0x00,0x00,0x3c,0x00,0x00,0x00,//9...:...;...<...
    0xfe,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0x02,0x00,0x00,0x00,0xab,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0xca,0x00,0x00,0x00,//................
    0x05,0x00,0x00,0x00,0xeb,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x0d,0x01,0x00,0x00,//................
    0x04,0x00,0x00,0x00,0x2f,0x01,0x00,0x00,0x08,0x00,0x00,0x00,0x4f,0x01,0x00,0x00,//..../.......O...
    0x01,0x00,0x00,0x00,0x62,0x01,0x00,0x00,0x0f,0x00,0x00,0x00,0x68,0x01,0x00,0x00,//....b.......h...
    0x10,0x00,0x00,0x00,0x70,0x01,0x00,0x00,0x12,0x00,0x00,0x00,0x78,0x01,0x00,0x00,//....p.......x...
    0x0e,0x00,0x00,0x00,0x93,0x01,0x00,0x00,0x09,0x00,0x00,0x00,0x9b,0x01,0x00,0x00,//................
    0x13,0x00,0x00,0x00,0xa5,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,//................
    0x4e,0x6f,0x72,0x6d,0x61,0x6c,0x2e,0x64,0x6f,0x74,0x00,0x1e,0x00,0x00,0x00,0x17,//Normal.dot......
    0x00,0x00,0x00,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,//...Title of the 
    0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x19,0x00,//document........
    0x00,0x00,0x53,0x75,0x62,0x6a,0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,//..Subject of the
    0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,0x00,0x1a,// document.......
    0x00,0x00,0x00,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,0x20,0x74,//...Keywords of t
    0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,0x00,0x00,//he document.....
    0x00,0x1a,0x00,0x00,0x00,0x43,0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,//.....Comments of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,0x6f,0x66,//.......Author of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x00,0x1e,// the document...
    0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,//.......Bill More
    0x6c,0x00,0x02,0x00,0x00,0x00,0xe4,0x04,0x03,0x00,0x00,0x00,0x07,0x00,0x00,0x00,//l...............
    0x03,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x13,0x00,0x00,0x00,//....A...........
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x1e,0x00,0x00,0x00,0x02,//.0..............
    0x00,0x00,0x00,0x33,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,//...3............
    0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x3e,0x00,0x03,0x00,0xfe,0xff,0x09,0x00,0x06,0x00,0x00,//.....>..........
    0x73,0x64,0x66,0x6f,0x69,0x68,0x73,0x64,0x66,0x0d,0xff,0xff,0xff,0xff,0xff,0xff,//sdfoihsdf.......
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x03,0x00,0x01,0x00,//................
    0x01,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x52,0x0b,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..R.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7e,0x08,0x00,0x00,0x08,0x00,//..........~.....
    0x00,0x00,0x86,0x08,0x00,0x00,0x0e,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..........j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,//..j.......j.....
    0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,//..j.............
    0x00,0x00,0x08,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x2a,0x00,//..............*.
    0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x46,0x6f,0x6f,0x20,0x42,0x61,0x72,0x0d,0x0d,0x73,0x64,0x66,0x6b,0x6a,0x68,0x73,//Foo Bar..sdfkjhs
    0x64,0x66,0x6b,0x6a,0x68,0x73,0x64,0x66,0x20,0x0d,0x73,0x20,0x64,0x6a,0x6b,0x73,//dfkjhsdf .s djks
    0x61,0x66,0x64,0x6c,0x6a,0x73,0x61,0x66,0x64,0x0d,0x73,0x64,0x66,0x6c,0x6b,0x68,//afdljsafd.sdflkh
    0x6a,0x73,0x66,0x61,0x64,0x6c,0x68,0x73,0x66,0x61,0x64,0x0d,0x73,0x64,0x66,0x68,//jsfadlhsfad.sdfh
    0xfe,0xff,0x00,0x00,0x03,0x33,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//.....3..........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xe0,0x85,0x9f,0xf2,//................
    0xf9,0x4f,0x68,0x10,0xab,0x91,0x08,0x00,0x2b,0x27,0xb3,0xd9,0x30,0x00,0x00,0x00,//.Oh.....+'..0...
    0xad,0x01,0x00,0x00,0x0e,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x98,0x00,0x00,0x00,//................
    0x01,0x00,0xfe,0xff,0x03,0x0a,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x09,0x02,0x00,//................
    0x00,0x00,0x00,0x00,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x1c,0x00,0x00,0x00,//...........F....
    0x4d,0x69,0x63,0x72,0x6f,0x73,0x6f,0x66,0x74,0x20,0x57,0x6f,0x72,0x64,0x20,0x36,//Microsoft Word 6
    0x2e,0x30,0x20,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x00,0x0a,0x00,0x00,0x00,//.0 Document.....
    0x4d,0x53,0x57,0x6f,0x72,0x64,0x44,0x6f,0x63,0x00,0x10,0x00,0x00,0x00,0x57,0x6f,//MSWordDoc.....Wo
    0x72,0x64,0x2e,0x44,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x36,0x00,0xf4,0x39,//rd.Document.6..9
    0xb2,0x71,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,//.q..............
    0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xdc,0xa5,0x68,0x00,0x45,0xc0,0x09,0x04,0x00,0x00,0x24,0x00,0x65,0x00,0x00,0x00,//..h.E.....$.e...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,//................
    0xb5,0x0c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....J...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,//............j...
    0x00,0x08,0x00,0x00,0x6a,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....j...j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//j.......j.......
    0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x14,0x00,0x00,0x00,//j.......j.......
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x94,0x08,0x00,0x00,0x36,0x00,0x00,0x00,//............6...
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,//................
    0xd4,0x08,0x00,0x00,0x0a,0x00,0x00,0x00,0xca,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x97,0x0b,0x00,0x00,0x31,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//....1...........
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0xde,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x08,0x09,0x00,0x00,0x02,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x0a,0x09,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x0a,0x09,0x00,0x00,0x52,0x00,0x00,0x00,0x5c,0x09,0x00,0x00,0xec,0x00,0x00,0x00,//....R...\.......
    0x48,0x0a,0x00,0x00,0xec,0x00,0x00,0x00,0x34,0x0b,0x00,0x00,0x1e,0x00,0x00,0x00,//H.......4.......
    0xc8,0x0b,0x00,0x00,0x58,0x00,0x00,0x00,0x20,0x0c,0x00,0x00,0x95,0x00,0x00,0x00,//....X... .......
    0x52,0x0b,0x00,0x00,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//R...E...........
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x6a,0x08,0x00,0x00,0x00,0x00,0x00,0x00,//........j.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x19,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,//............J...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,//................
    0x00,0x03,0x00,0x00,0x08,0x03,0x00,0x00,0x09,0x03,0x00,0x00,0x1a,0x03,0x00,0x00,//................
    0x2a,0x03,0x00,0x00,0x3c,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0xfe,0x00,0x01,0xc0,//*...<...J.......
    0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,//!......!......!.
    0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,0x00,0x01,0xc0,0x21,0xf0,0x00,0xfe,//.....!......!...
    0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//...!............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x06,//................
    0x0e,0x00,0x0f,0x00,0x08,0x00,0x01,0x00,0x4b,0x00,0x0f,0x00,0x00,0x00,0x00,0x00,//........K.......
    0x1a,0x00,0x00,0x40,0xf1,0xff,0x02,0x00,0x1a,0x00,0x06,0x4e,0x6f,0x72,0x6d,0x61,//...@.......Norma
    0x6c,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x61,0x09,0x04,0x00,0x00,0x00,0x00,0x00,//l.......a.......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x22,0x00,//..............".
    0x41,0x40,0xf2,0xff,0xa1,0x00,0x22,0x00,0x16,0x44,0x65,0x66,0x61,0x75,0x6c,0x74,//A@...."..Default
    0x20,0x50,0x61,0x72,0x61,0x67,0x72,0x61,0x70,0x68,0x20,0x46,0x6f,0x6e,0x74,0x00,// Paragraph Font.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,//..............J.
    0x00,0x00,0x02,0x00,0xff,0xff,0xff,0xff,0x02,0x00,0xff,0xff,0xff,0xff,0x01,0x00,//................
    0x04,0x20,0xff,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x00,//. ........J.....
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x28,0x00,0x00,0x00,//............(...
    0x3a,0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x00,0x01,0xc0,0x21,//:...H...J......!
    0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x01,//.....!.....!....
    0xc0,0x21,0xf0,0x00,0x00,0x01,0xc0,0x21,0xf0,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,//.!.....!......J.
    0x00,0x00,0x02,0x00,0x00,0x03,0x00,0x00,0x4a,0x03,0x00,0x00,0x03,0x00,0x2a,0x00,//........J.....*.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x1c,0x43,0x3a,0x5c,0x75,//.Bill Morel.C:\u
    0x73,0x65,0x72,0x73,0x5c,0x64,0x65,0x66,0x61,0x75,0x6c,0x74,0x5c,0x74,0x65,0x73,//sers\default\tes
    0x74,0x64,0x6f,0x63,0x2e,0x64,0x6f,0x63,0xff,0x40,0x5c,0x5c,0x4d,0x53,0x50,0x52,//tdoc.doc.@\\MSPR
    0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,//INT35\1/1049 COR
    0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x4e,0x65,0x30,0x30,0x3a,0x00,//PA 141B97.Ne00:.
    0x77,0x69,0x6e,0x73,0x70,0x6f,0x6f,0x6c,0x00,0x48,0x50,0x20,0x4c,0x61,0x73,0x65,//winspool.HP Lase
    0x72,0x4a,0x65,0x74,0x20,0x49,0x49,0x49,0x53,0x69,0x20,0x50,0x6f,0x73,0x74,0x53,//rJet IIISi PostS
    0x63,0x72,0x69,0x70,0x74,0x20,0x76,0x35,0x32,0x2e,0x33,0x00,0x5c,0x5c,0x4d,0x53,//cript v52.3.\\MS
    0x50,0x52,0x49,0x4e,0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,//PRINT35\1/1049 C
    0x4f,0x52,0x50,0x41,0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,//ORPA 141B97. .P.
    0x7c,0x00,0x70,0x00,0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//|.p...........o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x65,0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,//..Letter......o.
    0x64,0x00,0x01,0x00,0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,//d.....,.........
    0x00,0x00,0x4c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//..L.............
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,//........PRIV ...
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x18,0x00,0x00,0x00,0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,//...... N N N...'
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x5c,0x5c,0x4d,0x53,0x50,0x52,0x49,0x4e,//........\\MSPRIN
    0x54,0x33,0x35,0x5c,0x31,0x2f,0x31,0x30,0x34,0x39,0x20,0x43,0x4f,0x52,0x50,0x41,//T35\1/1049 CORPA
    0x20,0x31,0x34,0x31,0x42,0x39,0x37,0x00,0x20,0x03,0x50,0x03,0x7c,0x00,0x70,0x00,// 141B97. .P.|.p.
    0x13,0xdd,0x01,0x00,0x01,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//..........o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x65,//..,...........Le
    0x74,0x74,0x65,0x72,0x00,0x00,0x01,0x00,0xea,0x0a,0x6f,0x08,0x64,0x00,0x01,0x00,//tter......o.d...
    0x0f,0x00,0x2c,0x01,0x01,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x4c,0x00,//..,...........L.
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x50,0x52,0x49,0x56,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//....PRIV .......
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//................
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,//................
    0x00,0x00,0x20,0x4e,0x20,0x4e,0x20,0x4e,0x00,0x00,0x10,0x27,0x00,0x00,0x00,0x00,//.. N N N...'....
    0x00,0x00,0x00,0x00,0x01,0x80,0x01,0x00,0x48,0x00,0x00,0x00,0x48,0x00,0x00,0x00,//........H...H...
    0x08,0x00,0x01,0x00,0x01,0x00,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x17,0x00,//......H.........
    0x00,0x00,0x02,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x10,0x00,0x00,0x00,0x17,//...@............
    0x00,0x00,0x00,0x48,0x00,0x00,0x00,0x49,0x00,0x00,0x00,0x4a,0x00,0x00,0x00,0x21,//...H...I...J...!
    0x00,0x09,0x03,0x00,0x00,0x00,0x00,0x21,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x20,//.......!....... 
    0x00,0x19,0x03,0x00,0x00,0x00,0x00,0x20,0x00,0x07,0x03,0x00,0x00,0x00,0x00,0x20,//....... ....... 
    0x00,0x08,0x03,0x00,0x00,0x00,0x00,0x31,0x00,0x15,0x16,0x90,0x01,0x00,0x00,0x54,//.......1.......T
    0x69,0x6d,0x65,0x73,0x20,0x4e,0x65,0x77,0x20,0x52,0x6f,0x6d,0x61,0x6e,0x00,0x0c,//imes New Roman..
    0x16,0x90,0x01,0x02,0x00,0x53,0x79,0x6d,0x62,0x6f,0x6c,0x00,0x0b,0x26,0x90,0x01,//.....Symbol..&..
    0x00,0x00,0x41,0x72,0x69,0x61,0x6c,0x00,0x22,0x00,0x04,0x00,0x31,0x08,0x8a,0x18,//..Arial."...1...
    0x00,0x00,0xd0,0x02,0x00,0x00,0x68,0x01,0x00,0x00,0x00,0x00,0x40,0x34,0xf4,0x85,//......h.....@4..
    0x05,0x3b,0xf4,0xa5,0x04,0x3b,0xf4,0xa5,0x03,0x00,0x03,0x00,0x00,0x00,0x07,0x00,//.;...;..........
    0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x83,0x10,//..A.............
    0x05,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x41,0x00,0x00,0x00,0x01,0x00,0x04,0x00,//........A.......
    0x00,0x00,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x74,0x03,0x00,0x00,0x00,0x00,//..........t.....
    0x95,0x00,0x00,0x00,0x16,0x54,0x69,0x74,0x6c,0x65,0x20,0x6f,0x66,0x20,0x74,0x68,//.....Title of th
    0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x18,0x53,0x75,0x62,0x6a,//e document..Subj
    0x65,0x63,0x74,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,//ect of the docum
    0x65,0x6e,0x74,0x2e,0x19,0x4b,0x65,0x79,0x77,0x6f,0x72,0x64,0x73,0x20,0x6f,0x66,//ent..Keywords of
    0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x19,0x43,// the document..C
    0x6f,0x6d,0x6d,0x65,0x6e,0x74,0x73,0x20,0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,//omments of the d
    0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,0x17,0x41,0x75,0x74,0x68,0x6f,0x72,0x20,//ocument..Author 
    0x6f,0x66,0x20,0x74,0x68,0x65,0x20,0x64,0x6f,0x63,0x75,0x6d,0x65,0x6e,0x74,0x2e,//of the document.
    0x0a,0x42,0x69,0x6c,0x6c,0x20,0x4d,0x6f,0x72,0x65,0x6c,0x00,0x00,0x00,0x00,0x00,//.Bill Morel.....
    0x00,0x00,0x00,0x00,0x00,0xd0,0xcf,0x11,0xe0,0xa1,0xb1,0x1a,0xe1,0x00,0x00,0x00,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//................
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff //................
};

unsigned int g_cbTestDoc = sizeof(g_achTestDoc)/sizeof(g_achTestDoc[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\proptest\proptest.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:         proptest.cxx
//
//  Description:  This is the main file for all the tests
//                of Property set interfaces.
//
//---------------------------------------------------------------

//
//                             IPropertyStorage tests
//

// NOTE: we require more headers here just for convenience of 
// the test program, for other programs only "props.h" should be
// needed.

#ifndef _UNIX
#define INITGUID
#endif // _UNIX

#include "../../props/h/windef.h"
#include "../../h/props.h"

#include "../../props/h/propapi.h"
#include "../../props/h/propset.hxx"

#include "cpropvar.hxx"
#include "../../props/h/propmac.hxx"
#include "../../time.hxx"
#include "proptest.hxx"


#include <sys/types.h>
#include <sys/stat.h>
#ifdef _WIN32
#include <direct.h>  // _mkdir is stored here in win32
#endif

//  -------
//  Globals
//  -------
#ifndef _UNIX
// again for static linkage, these symbols will be duplicated.

OLECHAR aocMap[33], oszSummary[19], oszDocumentSummary[27];

GUID guidSummary =
    { 0xf29f85e0,
      0x4ff9, 0x1068,
      { 0xab, 0x91, 0x08, 0x00, 0x2b, 0x27, 0xb3, 0xd9 } };

GUID guidDocumentSummary =
    { 0xd5cdd502,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };

GUID guidDocumentSummary2 =
    { 0xd5cdd505,
      0x2e9c, 0x101b,
      { 0x93, 0x97, 0x08, 0x00, 0x2b, 0x2c, 0xf9, 0xae } };
#else
extern LPOLESTR aocMap, oszSummary, oszDocumentSummary;
extern GUID guidSummary, guidDocumentSummary, guidDocumentSummary2;
#endif // _UNIX

LARGE_INTEGER g_li0;

CPropVariant  g_rgcpropvarAll[ CPROPERTIES_ALL ];
CPropSpec     g_rgcpropspecAll[ CPROPERTIES_ALL ];
char g_szPropHeader[] = "  propid/name          propid    cb   type value\n";
char g_szEmpty[] = "";
BOOL g_fVerbose = FALSE;

/* just a uuid that we use to create new uuids */
GUID g_curUuid = 
{ /* e4ecf7f0-e587-11cf-b10d-00aa005749e9 */
    0xe4ecf7f0,
    0xe587,
    0x11cf,
    {0xb1, 0x0d, 0x00, 0xaa, 0x00, 0x57, 0x49, 0xe9}
};

#define TEST_STANDARD           0x1
#define TEST_WORD6              0x2
#define TEST_INTEROP_W          0x4
#define TEST_INTEROP_R          0x8

__inline OLECHAR
MapChar(IN ULONG i)
{
    return((OLECHAR) aocMap[i & CHARMASK]);
}

//
// We simulate uuidcreate by incrementing a global uuid
// each time the function is called.
//
void UuidCreate (
    OUT GUID * pUuid
    )
{
    g_curUuid.Data1++;          
    *pUuid = g_curUuid;         // member to member copy
}

#ifndef _UNIX

//+--------------------------------------------------------------------------
// Function:    RtlGuidToPropertySetName
//
// Synopsis:    Map property set GUID to null-terminated OLECODE name string.
//
//              The aocname parameter is assumed to be a buffer with room for
//              CCH_PROPSETSZ (28) OLECHARs.  The first character
//              is always OC_PROPSET0 (0x05), as specified by the OLE Appendix
//              B documentation.  The colon character normally used as an NT
//              stream name separator is not written to the caller's buffer.
//
//              No error is possible.
// Arguments:   IN GUID *pguid        -- pointer to GUID to convert
//              OUT OLECHAR aocname[] -- output string buffer
//
// Returns:     count of non-NULL characters in the output string buffer
//---------------------------------------------------------------------------

ULONG PROPSYSAPI PROPAPI
RtlGuidToPropertySetName(
    IN GUID const *pguid,
    OUT OLECHAR aocname[])
{
    BYTE *pb = (BYTE *) pguid;
    BYTE *pbEnd = pb + sizeof(*pguid);
    ULONG cbitRemain = CBIT_BYTE;
    OLECHAR *poc = aocname;

    *poc++ = OC_PROPSET0;

    // Note: CCH_PROPSET includes the OC_PROPSET0, and sizeof(osz...)
    // includes the trailing L'\0', so sizeof(osz...) is ok because the
    // OC_PROPSET0 character compensates for the trailing NULL character.

    ASSERT(CCH_PROPSET >= sizeof(oszSummary)/sizeof(OLECHAR));
    if (*pguid == guidSummary)
    {
        RtlCopyMemory(poc, oszSummary, sizeof(oszSummary));
        return(sizeof(oszSummary)/sizeof(OLECHAR));
    }

    ASSERT(CCH_PROPSET >= sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    if (*pguid == guidDocumentSummary || *pguid == guidDocumentSummary2)
    {
        RtlCopyMemory(poc, oszDocumentSummary, sizeof(oszDocumentSummary));
        return(sizeof(oszDocumentSummary)/sizeof(OLECHAR));
    }

    while (pb < pbEnd)
    {
        ULONG i = *pb >> (CBIT_BYTE - cbitRemain);

        if (cbitRemain >= CBIT_CHARMASK)
        {
            *poc = MapChar(i);
            if (cbitRemain == CBIT_BYTE && 
                *poc >= ((OLECHAR)'a') && 
                *poc <= ((OLECHAR)'z') )
            {
                *poc += (OLECHAR) ((OLECHAR)('A') - (OLECHAR)('a'));
            }
            poc++;

            cbitRemain -= CBIT_CHARMASK;
            if (cbitRemain == 0)
            {
                pb++;
                cbitRemain = CBIT_BYTE;
            }
        }
        else
        {
            if (++pb < pbEnd)
            {
                i |= *pb << cbitRemain;
            }
            *poc++ = MapChar(i);
            cbitRemain += CBIT_BYTE - CBIT_CHARMASK;
        }
    }
    *poc = (OLECHAR)'\0';
    return(CCH_PROPSET);
}
#endif // #ifndef _UNIX

#define Check(x,y) _Check(x,y, __LINE__)


void Cleanup(); // forward declaration

//+=================================================================
//
//  Function:   _Check
//  
//  Synopsis:   Verify that the actual HR is the expected
//              value.  If not, report an error and exit.
//
//  Inputs:     [HRESULT] hrExpected
//                  What we expected
//              [HRESULT] hrActual
//                  The actual HR of the previous operation.
//              [int] line
//                  The line number of the operation.
//  
//  Outputs:    None.
//  
//+=================================================================


void _Check(HRESULT hrExpected, HRESULT hrActual, int line)
{
    if (hrExpected != hrActual)
    {
        printf("\nFailed with hr=%08x at line %d (expected hr=%08x in proptest.cxx)\n",
               hrActual, line, hrExpected );
        Cleanup();
    }
}

OLECHAR * GetNextTest()
{
    static int nTest;
    static CHAR pchBuf[10];
    static OLECHAR pocs[10];

    sprintf(pchBuf, "%d", nTest++);
    STOT(pchBuf, pocs, strlen(pchBuf)+1);

    return(pocs);
}

void Now(FILETIME *pftNow)
{
    DfGetTOD(pftNow);
}


enum CreateOpen
{
    Create, Open
};

IStorage *_pstgTemp=NULL;
IStorage *_pstgTempCopyTo=NULL;  // _pstgTemp is copied to _pstgTempCopyTo

class CTempStorage
{
public:
    CTempStorage(DWORD grfMode = STGM_DIRECT | STGM_CREATE)
    {
        Check(S_OK, (_pstgTemp->CreateStorage(GetNextTest(), grfMode | 
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0,
            &_pstg)));
    }


    CTempStorage(CreateOpen co, IStorage *pstgParent, 
                 OLECHAR *pocsChild, DWORD grfMode = STGM_DIRECT)
    {
        if (co == Create)
            Check(S_OK, pstgParent->CreateStorage(pocsChild,
                grfMode | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, 0,
                &_pstg));
        else
            Check(S_OK, pstgParent->OpenStorage(pocsChild, NULL,
                grfMode | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0,
                &_pstg));
    }

    ~CTempStorage()
    {
        if (_pstg != NULL)
            _pstg->Release();
    }


    IStorage * operator -> ()
    {
        return(_pstg);
    }

    operator IStorage * ()
    {
        return(_pstg);
    }

    void Release()
    {
        if (_pstg != NULL)
        {
            _pstg->Release();
            _pstg = NULL;
        }
    }

private:
    static unsigned int _iName;

    IStorage *  _pstg;
};

unsigned int CTempStorage::_iName;

class CGenProps
{
public:
    CGenProps() : _vt((VARENUM)2) {}
    PROPVARIANT * GetNext(int HowMany, int *pActual, BOOL fWrapOk = FALSE, BOOL fNoNonSimple = TRUE);
    
private:
    BOOL        _GetNext(PROPVARIANT *pVar, BOOL fWrapOk, BOOL fNoNonSimple);
    VARENUM     _vt;

};


PROPVARIANT * CGenProps::GetNext(int HowMany, int *pActual, BOOL fWrapOk, BOOL fNoNonSimple)
{
    PROPVARIANT *pVar = new PROPVARIANT[HowMany];

    if (pVar == NULL)
        return(NULL);
    int l;	
    for (l=0; l<HowMany && _GetNext(pVar + l, fWrapOk, fNoNonSimple); l++) { };

    if (pActual)
        *pActual = l;

    if (l == 0)
    {
        delete pVar;
        return(NULL);
    }

    return(pVar);
}

BOOL CGenProps::_GetNext(PROPVARIANT *pVar, BOOL fWrapOk, BOOL fNoNonSimple)
{
    if (_vt == (VT_VECTOR | VT_CLSID)+1)
    {
        if (!fWrapOk)
            return(FALSE);
        else
            _vt = (VARENUM)2;
    }

    PROPVARIANT Var;
    BOOL fFirst = TRUE;

    do
    {
        GUID *pg;

        if (!fFirst)
        {
            PropVariantClear(&Var);
        }

        fFirst = FALSE;

        memset(&Var, 0, sizeof(Var));
        Var.vt = _vt;

        (*((int*)&_vt))++;

        switch (Var.vt)
        {
        case VT_LPSTR:
                Var.pszVal = (LPSTR)CoTaskMemAlloc(6);
                strcpy(Var.pszVal, "lpstr");
                break;
        case VT_LPWSTR:
                DECLARE_WIDESTR(wcsTemp, "lpwstr");            
                Var.pwszVal = (LPWSTR)CoTaskMemAlloc(14);
                wcscpy(Var.pwszVal, wcsTemp);
                break;
        case VT_CLSID:
                pg = (GUID*)CoTaskMemAlloc(sizeof(GUID));
                UuidCreate(pg);
                Var.puuid = pg;
                break;
        case VT_CF:
                Var.pclipdata = (CLIPDATA*)CoTaskMemAlloc(sizeof(CLIPDATA));
                Var.pclipdata->cbSize = 10;
                Var.pclipdata->pClipData = (BYTE*)CoTaskMemAlloc(10);
                Var.pclipdata->ulClipFmt = 0;
                break;
        }
    } while ( (fNoNonSimple && 
               (Var.vt == VT_STREAM || Var.vt == VT_STREAMED_OBJECT ||
                Var.vt == VT_STORAGE || Var.vt == VT_STORED_OBJECT)) || 
             Var.vt == (VT_VECTOR | VT_VARIANT) || 
             Var.vt == (VT_VECTOR | VT_CF) || 
             Var.vt == (VT_VECTOR | VT_BSTR) || 
             S_OK != PropVariantCopy(pVar, &Var) );  // Is valid propvariant ?

    PropVariantClear(&Var);

    return(TRUE);
}

VOID
CleanStat(ULONG celt, STATPROPSTG *psps)
{
    while (celt--)
    {
        CoTaskMemFree(psps->lpwstrName);
        psps++;
    }
}



HRESULT
PopulateRGPropVar( CPropVariant rgcpropvar[],
                   CPropSpec    rgcpropspec[] )
{
    HRESULT hr = E_FAIL;
    int  i;
    ULONG ulPropIndex = 0;
    CLIPDATA clipdataNull, clipdataNonNull;

    // Initialize the PropVariants

    for( i = 0; i < CPROPERTIES_ALL; i++ )
    {
        rgcpropvar[i].Clear();
    }

    // Create a UI1 property

    DECLARE_OLESTR(ocsUI1, "UI1 Property" );   
    rgcpropspec[ulPropIndex] = ocsUI1;
    rgcpropvar[ulPropIndex] = (UCHAR) 39; // 0x27
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI1 );
    ulPropIndex++;

    // Create an I2 property

    DECLARE_OLESTR(ocsI2, "I2 Property" );   
    rgcpropspec[ulPropIndex] = ocsI2;
    rgcpropvar[ulPropIndex] = (SHORT) -502; // 0xfe0a
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_I2 );
    ulPropIndex++;

    // Create a UI2 property
    DECLARE_OLESTR(ocsUI2,  "UI2 Property" );
    rgcpropspec[ulPropIndex] =  ocsUI2;
    rgcpropvar[ulPropIndex] = (USHORT) 502; // 01f6
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI2 );
    ulPropIndex++;

    // Create a BOOL property
    DECLARE_OLESTR(ocsBool, "Bool Property" );
    rgcpropspec[ulPropIndex] = ocsBool;
    rgcpropvar[ulPropIndex].SetBOOL( VARIANT_TRUE ); // 0xFFFF
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BOOL );
    ulPropIndex++;

    // Create a I4 property

    DECLARE_OLESTR(ocsI4, "I4 Property" );
    rgcpropspec[ulPropIndex] = ocsI4;
    rgcpropvar[ulPropIndex] = (long) -523; // 0xFFFFFDF5
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_I4 );
    ulPropIndex++;

    // Create a UI4 property
    DECLARE_OLESTR(ocsUI4, "UI4 Property" );
    rgcpropspec[ulPropIndex] = ocsUI4;
    rgcpropvar[ulPropIndex] = (ULONG) 530; // 0x212
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI4 );
    ulPropIndex++;

    // Create a R4 property
    DECLARE_OLESTR(ocsR4,  "R4 Property" );
    rgcpropspec[ulPropIndex] = ocsR4;
    rgcpropvar[ulPropIndex] = (float) 5.37; // 0x40abd70a ?
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_R4 );
    ulPropIndex++;

    // Create an ERROR property
    DECLARE_OLESTR(ocsErr, "ERROR Property" );
    rgcpropspec[ulPropIndex] = ocsErr;
                                // 0x800030002
    rgcpropvar[ulPropIndex].SetERROR( STG_E_FILENOTFOUND );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_ERROR );
    ulPropIndex++;

    // Create an I8 property

    LARGE_INTEGER large_integer;
    large_integer.LowPart = 551; // 0x227
    large_integer.HighPart = 30; // 0x1E
    DECLARE_OLESTR(ocsI8, "I8 Property" );
    rgcpropspec[ulPropIndex] = ocsI8;
    rgcpropvar[ulPropIndex] = large_integer;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_I8 );
    ulPropIndex++;

    // Create a UI8 property

    ULARGE_INTEGER ularge_integer;
    ularge_integer.LowPart = 561; // 0x231
    ularge_integer.HighPart = 30; // 0x1E
    DECLARE_OLESTR(ocsUI8, "UI8 Property" );
    rgcpropspec[ulPropIndex] = ocsUI8;
    rgcpropvar[ulPropIndex] = ularge_integer;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_UI8 );
    ulPropIndex++;

    // Create an R8 property
    DECLARE_OLESTR( ocsR8, "R8 Property" );
    rgcpropspec[ulPropIndex] = ocsR8;
    rgcpropvar[ulPropIndex] = (double) 571.36; // 4081dae1:47ae147b
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_R8 );
    ulPropIndex++;

    // Create a CY property

    CY cy;
    cy.int64 = 578;             // 0x242
    DECLARE_OLESTR(ocsCY, "Cy Property" );
    rgcpropspec[ulPropIndex] = ocsCY;
    rgcpropvar[ulPropIndex] = cy;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_CY );
    ulPropIndex++;

    // Create a DATE property
    DECLARE_OLESTR(ocsDate, "DATE Property" );
    rgcpropspec[ulPropIndex] = ocsDate;
    rgcpropvar[ulPropIndex].SetDATE( 587 );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_DATE );
    ulPropIndex++;

    // Create a FILETIME property

    FILETIME filetime;
    filetime.dwLowDateTime = 0x767c0570;
    filetime.dwHighDateTime = 0x1bb7ecf;
    DECLARE_OLESTR(ocsFT, "FILETIME Property" );
    rgcpropspec[ulPropIndex] = ocsFT;
    rgcpropvar[ulPropIndex] = filetime;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_FILETIME );
    ulPropIndex++;

    // Create a CLSID property

    DECLARE_OLESTR(ocsCLSID, "CLSID Property" );
    rgcpropspec[ulPropIndex] = ocsCLSID;
    //  f29f85e0-4ff9-1068-ab91-08002b27b3d9
    rgcpropvar[ulPropIndex] = FMTID_SummaryInformation;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_CLSID );
    ulPropIndex++;


    // Create a vector of CLSIDs
    DECLARE_OLESTR(ocsVectCLSID, "CLSID Vector Property" );
    rgcpropspec[ulPropIndex] = ocsVectCLSID;
    //  f29f85e0-4ff9-1068-ab91-08002b27b3d9
    rgcpropvar[ulPropIndex][0] = FMTID_SummaryInformation;    
    rgcpropvar[ulPropIndex][1] = FMTID_DocSummaryInformation;
    rgcpropvar[ulPropIndex][2] = FMTID_UserDefinedProperties;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_CLSID | VT_VECTOR );
    ulPropIndex++;

    // Create a BSTR property
    DECLARE_OLESTR(ocsBSTR, "BSTR");
    DECLARE_OLESTR(ocsBSTRVal, "BSTR Value");
    rgcpropspec[ulPropIndex] = ocsBSTR;
    rgcpropvar[ulPropIndex].SetBSTR( ocsBSTRVal );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    // Create a BSTR Vector property
    DECLARE_OLESTR(ocsBSTRVect, "BSTR Vector");
    rgcpropspec[ulPropIndex] = ocsBSTRVect;
    DECLARE_OLESTR(ocsBSTRVectElt, "# - BSTR Vector Element");
    for( i = 0; i < 3; i++ )
    {
        OLECHAR *olestrElement = ocsBSTRVectElt;
        olestrElement[0] = (OLECHAR) i%10 + (OLECHAR)'0';
        rgcpropvar[ulPropIndex].SetBSTR( olestrElement, i );
    }

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_BSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a variant vector BSTR property.
    DECLARE_OLESTR(ocsBSTRVariantVect, "BSTR Variant Vector");
    DECLARE_OLESTR(ocsBSTRVariantVectElt, "# - Vector Variant Vector");
    rgcpropspec[ulPropIndex ] = ocsBSTRVariantVect;
    
    for( i = 0; i < 3; i++ )
    {
        if( i == 0 )
        {
            rgcpropvar[ulPropIndex][0] = 
                (PROPVARIANT*) CPropVariant((long) 0x1234);
        }
        else
        {
            CPropVariant cpropvarBSTR;
            cpropvarBSTR.SetBSTR( ocsBSTRVariantVectElt );
            (cpropvarBSTR.GetBSTR())[0] = (OLECHAR) i%10 + (OLECHAR)'0';
            rgcpropvar[ulPropIndex][i] = (PROPVARIANT*) cpropvarBSTR;
        }
    }

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPSTR property
    DECLARE_OLESTR(ocsLPSTRP, "LPSTR Property");
    rgcpropspec[ulPropIndex] = ocsLPSTRP;
    rgcpropvar[ulPropIndex]  = "LPSTR Value";
    
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    // Create some ClipFormat properties
    DECLARE_OLESTR(ocsClipName, "ClipFormat property");
    rgcpropspec[ ulPropIndex ] = ocsClipName;
    DECLARE_WIDESTR(wcsClipData, "Clipboard Data");
    rgcpropvar[ ulPropIndex ]  = CClipData( wcsClipData );
    ASSERT( rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyClipName,
                   "Empty ClipFormat property (NULL pointer)"); 
    rgcpropspec[ ulPropIndex ] = ocsEmptyClipName;
    clipdataNull.cbSize = 4;
    clipdataNull.ulClipFmt = (ULONG) -1; // 0xffff
    clipdataNull.pClipData = NULL;
    rgcpropvar[ ulPropIndex ] = clipdataNull;
    ASSERT( rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyClipNameNotNull,
                   "Empty ClipFormat property (non-NULL pointer)"); 
    rgcpropspec[ ulPropIndex ] = ocsEmptyClipNameNotNull;
    clipdataNonNull.cbSize = 4;
    clipdataNonNull.ulClipFmt = (ULONG) -1; // 0xffff
    clipdataNonNull.pClipData = (BYTE*) CoTaskMemAlloc(0);
    rgcpropvar[ ulPropIndex ] = clipdataNonNull;
    ASSERT( rgcpropvar[ ulPropIndex ].VarType() == VT_CF );
    ulPropIndex++;


    // Create a vector of ClipFormat properties

    CClipData cclipdataEmpty;
    cclipdataEmpty.Set( (ULONG) -1, "", 0 );
    DECLARE_OLESTR(ocsClipArr, "ClipFormat Array Property");
    rgcpropspec[ ulPropIndex ] = ocsClipArr;
    DECLARE_OLESTR(ocsElt1, "Clipboard Date element 1");
    DECLARE_OLESTR(ocsElt2, "Clipboard Date element 2");     
    rgcpropvar[ ulPropIndex ][0] = CClipData( ocsElt1 );
    rgcpropvar[ ulPropIndex ][1] = cclipdataEmpty;
    rgcpropvar[ ulPropIndex ][2] = clipdataNull;
    rgcpropvar[ ulPropIndex ][3] = clipdataNonNull;
    rgcpropvar[ ulPropIndex ][4] = CClipData( ocsElt2 );

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_CF | VT_VECTOR) );
    ASSERT( rgcpropvar[ulPropIndex].Count() == 5 );
    ulPropIndex++;

    // Create an LPSTR|Vector property (e.g., the DocSumInfo
    // Document Parts array).
    DECLARE_OLESTR(ocsLPSTRorVect, "LPSTR|Vector property");
    rgcpropspec[ ulPropIndex ] = ocsLPSTRorVect;
    rgcpropvar[ ulPropIndex ][0] = "LPSTR Element 0";
    rgcpropvar[ ulPropIndex ][1] = "LPSTR Element 1";

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_LPSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create an LPWSTR|Vector property
    
    DECLARE_OLESTR(ocsLPWSTRVect, "LPWSTR|Vector property");
    DECLARE_WIDESTR(ocslpwvElt1, "LPWSTR Element 0");
    DECLARE_WIDESTR(ocslpwvElt2, "LPWSTR Element 1");    
    rgcpropspec[ ulPropIndex ] = ocsLPWSTRVect;
    rgcpropvar[ ulPropIndex ][0] = ocslpwvElt1;
    rgcpropvar[ ulPropIndex ][1] = ocslpwvElt2;

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_LPWSTR | VT_VECTOR) );
    ulPropIndex++;

    // Create a DocSumInfo HeadingPairs array.
    DECLARE_OLESTR(ocsPairArr, "HeadingPair array");
    rgcpropspec[ ulPropIndex ] = ocsPairArr; 

    rgcpropvar[ ulPropIndex ][0] = (PROPVARIANT*) CPropVariant( "Heading 0" );
    rgcpropvar[ ulPropIndex ][1] = (PROPVARIANT*) CPropVariant( (long) 1 );
    rgcpropvar[ ulPropIndex ][2] = (PROPVARIANT*) CPropVariant( "Heading 1" );
    rgcpropvar[ ulPropIndex ][3] = (PROPVARIANT*) CPropVariant( (long) 1 );

    ASSERT( rgcpropvar[ulPropIndex].VarType() == (VT_VARIANT | VT_VECTOR) );
    ulPropIndex++;

    // Create some NULL (but extant) properties
    DECLARE_OLESTR(ocsEmptyLPSTR, "Empty LPSTR");
    rgcpropspec[ulPropIndex] = ocsEmptyLPSTR;
    rgcpropvar[ulPropIndex]  = "";
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_LPSTR );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyLPWSTR, "Empty LPWSTR");    
    DECLARE_WIDESTR(wcsEmpty, "");
    rgcpropspec[ulPropIndex] = ocsEmptyLPWSTR;
    rgcpropvar[ulPropIndex]  = wcsEmpty;
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_LPWSTR );
    ulPropIndex++;


    DECLARE_OLESTR(ocsEmptyBLOB, "Empty BLOB");
    rgcpropspec[ulPropIndex] = ocsEmptyBLOB;
    rgcpropvar[ulPropIndex] = CBlob(0);
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BLOB );
    ulPropIndex++;

    DECLARE_OLESTR(ocsEmptyBSTR, "Empty BSTR");
    DECLARE_OLESTR(ocsEmpty, "");
    rgcpropspec[ulPropIndex] = ocsEmptyBSTR;
    rgcpropvar[ulPropIndex].SetBSTR( ocsEmpty );
    ASSERT( rgcpropvar[ulPropIndex].VarType() == VT_BSTR );
    ulPropIndex++;

    //  ----
    //  Exit
    //  ----

    CoTaskMemFree( clipdataNonNull.pClipData );
    memset( &clipdataNonNull, 0, sizeof(clipdataNonNull) );
   
    ASSERT( CPROPERTIES_ALL == ulPropIndex );
    hr = S_OK;
    return(hr);
}


//+---------------------------------------------------------------
//
//  Function:   test_WriteReadAllProperties
//
//  Synopsis:   This test simply creates two new property
//              sets in a new file (one Ansi and one Unicode),
//              writes all the properties in g_rgcpropvarAll,
//              reads them back, and verifies that it reads what
//              it wrote.
//
//  Outputs:    None.
//
//+---------------------------------------------------------------

void
test_WriteReadAllProperties(ULONG ulTestOptions )
{
    FMTID fmtidAnsi, fmtidUnicode;
    TSafeStorage< IStorage > pstg;
    TSafeStorage< IPropertySetStorage > ppropsetstg;
    TSafeStorage< IPropertyStorage > ppropstgAnsi;
    TSafeStorage< IPropertyStorage > ppropstgUnicode;

    CPropVariant rgcpropvarAnsi[ CPROPERTIES_ALL ];
    CPropVariant rgcpropvarUnicode[ CPROPERTIES_ALL ];

    printf( "   Simple Write/Read Test\n" );

    //  -----------------------
    //  Create the Property Set
    //  -----------------------

    // Generate FMTIDs.

    fmtidAnsi = IID_IPropertyStorage;
    fmtidUnicode = IID_IPropertySetStorage;

    // Generate a filename from the directory name.

    DECLARE_OLESTR(ocsFile, "AllProps.stg" );

    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        // Create the Docfile.
        printf("        Writing into file ... \n");

        Check( S_OK, StgCreateDocfile( ocsFile,
                                       STGM_CREATE | 
                                       STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                       0L,
                                       &pstg ));
    
        // Get the IPropertySetStorage
        
        Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, 
                                           (void**)&ppropsetstg ));
    
        // Create a Property Storage
        
        Check( S_OK, ppropsetstg->Create( fmtidAnsi,
                                          &CLSID_NULL,
                                          PROPSETFLAG_DEFAULT,
                                          STGM_READWRITE | 
                                          STGM_SHARE_EXCLUSIVE,
                                          &ppropstgAnsi ));
        
        Check( S_OK, ppropsetstg->Create( fmtidUnicode,
                                          &CLSID_NULL,
                                          PROPSETFLAG_ANSI,
                                          STGM_READWRITE | 
                                          STGM_SHARE_EXCLUSIVE,
                                          &ppropstgUnicode ));
        
        Check( S_OK, ppropstgAnsi->WriteMultiple( CPROPERTIES_ALL,
                                                  (PROPSPEC*)g_rgcpropspecAll,
                                                  (PROPVARIANT*)g_rgcpropvarAll,
                                                  PID_FIRST_USABLE ));

        Check( S_OK, ppropstgUnicode->WriteMultiple( CPROPERTIES_ALL,
                                                     (PROPSPEC*)g_rgcpropspecAll,
                                                     (PROPVARIANT*)g_rgcpropvarAll,
                                                     PID_FIRST_USABLE ));      
    }
    else
    {
        // open it
        printf("        opening file ... \n");

        Check(S_OK, StgOpenStorage( ocsFile,
                                    (IStorage*) NULL,
                                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE,  
                                    (SNB) 0,
                                    (DWORD) 0,
                                    &pstg ));

        // Get the IPropertySetStorage
        
        Check( S_OK, pstg->QueryInterface( IID_IPropertySetStorage, 
                                           (void**)&ppropsetstg ));
    
        // Open the Property Storage

        Check(S_OK, ppropsetstg->Open(fmtidUnicode,
                                      STGM_SHARE_EXCLUSIVE | 
                                      STGM_DIRECT | STGM_READWRITE,
                                      &ppropstgUnicode));
        Check(S_OK, ppropsetstg->Open(fmtidAnsi,
                                      STGM_SHARE_EXCLUSIVE | 
                                      STGM_DIRECT | STGM_READWRITE,
                                      &ppropstgAnsi));
    }    

    printf("        Verifying file ... \n");
    // either way, read it and make sure it is right
    Check( S_OK, ppropstgAnsi->ReadMultiple( CPROPERTIES_ALL,
                                             (PROPSPEC*)g_rgcpropspecAll,
                                             (PROPVARIANT*)rgcpropvarAnsi ));

    Check( S_OK, ppropstgUnicode->ReadMultiple( CPROPERTIES_ALL,
                                                (PROPSPEC*)g_rgcpropspecAll,
                                                (PROPVARIANT*)rgcpropvarUnicode ));
        
    //  ----------------------
    //  Compare the properties
    //  ----------------------
    
    for( int i = 0; i < (int)CPROPERTIES_ALL; i++ )
    {
        Check( TRUE, rgcpropvarAnsi[i] == g_rgcpropvarAll[i]
                     &&
                     rgcpropvarUnicode[i] == g_rgcpropvarAll[i] );
    }
    
}   // test_WriteReadProperties




//
// DOCFILE -- run all tests on DocFile
//
// IPropertySetStorage tests
//      

void
test_IPropertySetStorage_IUnknown(IStorage *pStorage)
{
    printf( "   IPropertySetStorage::IUnknown\n" );

    //       Check ref counting through different interfaces on object
    //      
    //          QI to IPropertySetStorage
    //          QI to IUnknown on IStorage
    //          QI to IUnknown on IPropertySetStorage
    //          QI back to IPropertySetStorage from IUnknown
    //          QI back to IStorage from IPropertySetStorage
    //      
    //          Release all.
    //

    IStorage *pStorage2;
    IPropertySetStorage *ppss1, *ppss2, *ppss3;
    IUnknown *punk1,*punk2;

    Check(S_OK, pStorage->QueryInterface(IID_IPropertySetStorage, (void**)&ppss1));
    Check(S_OK, pStorage->QueryInterface(IID_IUnknown, (void **)&punk1));
    Check(S_OK, ppss1->QueryInterface(IID_IUnknown, (void **)&punk2));
    Check(S_OK, ppss1->QueryInterface(IID_IStorage, (void **)&pStorage2));
    Check(S_OK, ppss1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss2));
    Check(S_OK, punk1->QueryInterface(IID_IPropertySetStorage, (void **)&ppss3));

    ppss1->AddRef();
    ppss1->Release();

    //pStorage.Release();
    ppss1->Release();
    punk1->Release();
    punk2->Release();
    pStorage2->Release();
    ppss2->Release();
    ppss3->Release();

}


#define INVALID_POINTER     ( (void *) 0xFFFFFFFF )
#define VTABLE_MEMBER_FN(pObj,entry)  ( (*(ULONG ***)(pObj))[ (entry) ] )


//+---------------------------------------------------------
//
//  Template:   Alloc2PageVector
//
//  Purpose:    This function template allocates two pages
//              of memory, and then sets a vector pointer
//              so that its first element is wholy within
//              the first page, and the second element is 
//              wholy within the second.  Then, the protection
//              of the second page is set according to the
//              caller-provided parameter.
//
//
//  Inputs:     [TYPE**] ppBase
//                  Points to the beginning of the two pages.
//              [TYPE**] ppVector
//                  Points to the beginning of the vector of TYPEs.
//              [DWORD] dwProtect
//                  The desired protection on the second page
//                  (from the PAGE_* enumeration).
//              [LPWSTR] lpwstr (optional)
//                  If not NULL, used to initialize the vector
//                  elements.
//
//  Output:     TRUE iff successful.
//
//+---------------------------------------------------------


template< class TYPE > BOOL Alloc2PageVector( TYPE** ppBase,
                                              TYPE** ppVector,
                                              DWORD  dwProtect,
                                              TYPE*  pInit )
{
    DWORD dwOldProtect;
    SYSTEM_INFO si;

    GetSystemInfo( &si );

    *ppBase = (TYPE*) VirtualAlloc( NULL, 2 * si.dwPageSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE );
    if( NULL == *ppBase )
        return( FALSE );

    *ppVector = (TYPE*) ( (BYTE*) *ppBase + si.dwPageSize - sizeof(TYPE) );

    if( NULL != pInit )
    {
        memcpy( &((LPWSTR*)*ppVector)[0], pInit, sizeof(TYPE) );
        memcpy( &((LPWSTR*)*ppVector)[1], pInit, sizeof(TYPE) );
    }

    if( !VirtualProtect( (BYTE*) *ppBase + si.dwPageSize, si.dwPageSize, dwProtect, &dwOldProtect ) )
        return( FALSE );

    return( TRUE );
}



void
test_PropVariantValidation( IStorage *pStg )
{

    printf( "   PropVariant Validation\n" );

    TSafeStorage< IPropertySetStorage > pPSStg( pStg );
    TSafeStorage< IPropertyStorage > pPStg;

    CPropVariant cpropvar;
    CLIPDATA     clipdata;
    PROPSPEC     propspec;

    DECLARE_WIDESTR(wszText, "Unicode Text String");

    FMTID fmtid;
    UuidCreate( &fmtid );

    Check(S_OK, pPSStg->Create( fmtid,
                                NULL,
                                PROPSETFLAG_DEFAULT,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));


    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 2;

    //  -------------------------------
    //  Test invalid VT_CF Propvariants
    //  -------------------------------

    // NULL clip format.

    clipdata.cbSize = 4;
    clipdata.ulClipFmt = (ULONG) -1;
    clipdata.pClipData = NULL;

    cpropvar = clipdata;

    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Too short cbSize.

    ((PROPVARIANT*)cpropvar)->pclipdata->cbSize = 3;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Too short pClipData (it should be 1 byte, but the pClipData is NULL).

    ((PROPVARIANT*)cpropvar)->pclipdata->cbSize = 5;
    Check(STG_E_INVALIDPARAMETER, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));


}

//       Check creation/open/deletion of property sets (check fmtid and predefined names)
//          Create a property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Try recreate of same 
//          Reopen the property set
//          Try recreate of same
//          Try delete
//          Close the property set
//          Delete the property set
//          Repeat the test once more

void
test_IPropertySetStorage_CreateOpenDelete(IStorage *pStorage)
{
    printf( "   IPropertySetStorage::Create/Open/Delete\n" );

    FMTID fmtid;
    PROPSPEC propspec;

    UuidCreate(&fmtid);
    int i;
    for (i=0; i<4; i++)
    {
        {
            TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;
            
            Check(S_OK, pPropSetStg->Create(fmtid,
                                            NULL,
                                            PROPSETFLAG_DEFAULT,
                                            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                            &PropStg));
            Check(S_OK, pPropSetStg->Create(
                fmtid,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg2));
            
            Check(STG_E_REVERTED, PropStg->Commit(0));
            
            PropStg->Release();
            PropStg2->Release();
        }        
        {
            TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
            IPropertyStorage *PropStg, *PropStg2;
            
            // use STGM_FAILIFTHERE
            Check(STG_E_FILEALREADYEXISTS, 
                  pPropSetStg->Create(fmtid,
                                      NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_SHARE_EXCLUSIVE | STGM_DIRECT | 
                                      STGM_READWRITE,
                                      &PropStg));
            
            Check(S_OK, 
                  pPropSetStg->Open(fmtid,
                                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | 
                                    STGM_READWRITE,
                                    &PropStg));
            
            Check(STG_E_ACCESSDENIED, 
                  pPropSetStg->Create(fmtid,
                                      NULL,
                                      PROPSETFLAG_DEFAULT,
                                      STGM_SHARE_EXCLUSIVE | STGM_DIRECT | 
                                      STGM_READWRITE,
                                      &PropStg2));
        
            Check(S_OK, 
                  pPropSetStg->Delete(fmtid));
        
            propspec.ulKind = PRSPEC_PROPID;
            propspec.propid = 1000;
            PROPVARIANT propvar;
            propvar.vt = VT_I4;
            propvar.lVal = 12345;
            Check(STG_E_REVERTED, 
                  PropStg->WriteMultiple(1, &propspec, &propvar, 
                                     2)); // force dirty
        
            PropStg->Release();
        }
    }

    //  --------------------------------------------------------
    //  Test the Create/Delete of the DocumentSummaryInformation
    //  property set (this requires special code because it
    //  has two sections).
    //  --------------------------------------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    TSafeStorage< IPropertyStorage> pPropStg1, pPropStg2;

    // Create & Delete a DSI propset with just the first section.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg1));

    pPropStg1->Release(); pPropStg1 = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));

    // Create & Delete a DSI propset with just the second section

    Check(S_OK, pPropSetStg->Create(FMTID_UserDefinedProperties,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg1 ));

    pPropStg1->Release(); pPropStg1 = NULL;
    Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));

    // Create & Delete a DocumentSummaryInformation propset with both sections.  
    // If you delete the DSI propset first, it should delete both sections.
    // If you delete the UD propset first, the DSI propset should still
    // remain.  We'll loop twice, trying both combinations.

    for( i = 0; i < 2; i++ )
    {

        // Create the first section, which implicitely creates
        // the second section.

        Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
                NULL,
                PROPSETFLAG_DEFAULT,
                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &pPropStg1));

        pPropStg1->Release(); pPropStg1 = NULL;

        if( i == 0 )
        {
            Check(S_OK, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
        }
        else
        {
            Check(S_OK, pPropSetStg->Delete( FMTID_DocSummaryInformation ));
            Check(STG_E_FILENOTFOUND, pPropSetStg->Delete( FMTID_UserDefinedProperties ));
        }
    }   // for( i = 0; i < 2; i++ )

    //  -------------------------------------
    //  Test special properties in DocSumInfo
    //  -------------------------------------

    // This verifies that when we Create a DocSumInfo
    // property set, and write a Vector or LPSTRs,
    // we can read it again.  We test this because 
    // Vectors of LPSTRs are a special case in the DocSumInfo,
    // and the Create & Open path are slightly different
    // in CPropertySetStream::_LoadHeader.

    // Create a new property set.

    Check(S_OK, pPropSetStg->Create(FMTID_DocSummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg1));

    // Create a vector of LPSTRs.  Make the strings
    // varying lengths to ensure we get plenty of
    // opportunity for alignment problems.

    CPropVariant cpropvarWrite, cpropvarRead;

    cpropvarWrite[3] = "12345678";
    cpropvarWrite[2] = "1234567";
    cpropvarWrite[1] = "123456";
    cpropvarWrite[0] = "12345";
    ASSERT( cpropvarWrite.Count() == 4 );

    // Write the property
    DECLARE_OLESTR(ocsVect, "A Vector of LPSTRs");
    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = ocsVect;

    Check(S_OK, pPropStg1->WriteMultiple( 1, &propspec, cpropvarWrite, 2 ));

    // Read the property back.

    Check(S_OK, pPropStg1->ReadMultiple( 1, &propspec, cpropvarRead ));

    // Verify that we read what we wrote.

    for( i = 0; i < (int) cpropvarWrite.Count(); i++ )
    {
        Check(0, strcmp( (LPSTR) cpropvarWrite[i], (LPSTR) cpropvarRead[i] ));
    }

}


void
test_IPropertySetStorage_SummaryInformation(IStorage *pStorage)
{
    printf( "   SummaryInformation\n" );
    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    IPropertyStorage *PropStg;
    IStream *pstm;

    Check(S_OK, pPropSetStg->Create(FMTID_SummaryInformation,
            NULL,
            PROPSETFLAG_DEFAULT, // simple, wide
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &PropStg));

    PropStg->Release();
    DECLARE_OLESTR(ocsSummary, "\005SummaryInformation");
    Check(S_OK, pStorage->OpenStream(ocsSummary,
            NULL,
            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
            0,
            &pstm));

    pstm->Release();
}

//
//       Check STGM_FAILIFTHERE and ~STGM_FAILIFTHERE in following cases
//          Check overwriting simple with simple

void
test_IPropertySetStorage_FailIfThere(IStorage *pStorage)
{
    // (Use "fale" instead of "fail" in this printf so the output won't
    // alarm anyone with the word "fail" uncessarily).
    printf( "   IPropertySetStorage, FaleIfThere\n" );

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

    // Iter       0        1          2         3          4        5          6         7
    // Create     simple   nonsimple  simple    nonsimple  simple   nonsimple  simple    nonsimple
    // ReCreate   simple   simple     nonsimple nonsimple  simple   simple     nonsimple nonsimple
    //            failif   failif     failif    failif     overw    overw      overw     overw
    //
    // expected   exists   exists     exists    exists     ok       ok         ok        ok

    for (int i=0; i<8; i++)
    {
        FMTID fmtid;
        IPropertyStorage *PropStg;


        UuidCreate(&fmtid);

        Check(S_OK, pPropSetStg->Create(fmtid,
                NULL,
                0,
                STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        PropStg->Release();

        Check((i&4) == 4 ? S_OK : STG_E_FILEALREADYEXISTS,
            pPropSetStg->Create(fmtid,
                NULL,
                0,
                ( (i & 4) == 4 ? STGM_CREATE : STGM_FAILIFTHERE) |
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                &PropStg));

        if (PropStg)
        {
            PropStg->Release();
        }
    }
}

void
test_IPropertySetStorage(IStorage *pStorage)
{
    //       Check ref counting through different interfaces on object
    test_IPropertySetStorage_IUnknown(pStorage);
    test_IPropertySetStorage_CreateOpenDelete(pStorage);
    test_IPropertySetStorage_SummaryInformation(pStorage);
    test_IPropertySetStorage_FailIfThere(pStorage);
}

//  IEnumSTATPROPSETSTG
//
//       Check enumeration of property sets
//      
//          Check refcounting and IUnknown
//      
//          Create some property sets, predefined and not, simple and not, one through IStorage
//          Enumerate them and check
//              (check fmtid, grfFlags)
//              (check when asking for more than there is: S_FALSE, S_OK)
//          Delete one
//          Reset the enumerator
//          Enumerate them and check
//          Delete one
//      
//          Reset the enumeratorA
//          Read one from enumeratorA
//          Clone enumerator -> enumeratorB
//          Loop comparing rest of enumerator contents
//      
//          Reset the enumerator
//          Skip all
//          Check none left
//      
//          Reset the enumerator
//          Skip all but one
//          Check one left
//

void CheckTime(const FILETIME &ftStart, const FILETIME &ftPropSet)
{
    FILETIME ftNow;
    Now(&ftNow);

    if (ftPropSet.dwLowDateTime == 0 && ftPropSet.dwHighDateTime == 0)
    {
        return;
    }

    // if ftPropSet < ftStart || ftNow < ftPropSet, error
    ASSERT (!(CompareFileTime(&ftPropSet, &ftStart) == -1 ||
              CompareFileTime(&ftNow, &ftPropSet) == -1));
}

void test_IEnumSTATPROPSETSTG(IStorage *pStorage)
{
    printf( "   IEnumSTATPROPSETSTG\n" );

    FMTID afmtid[8];
    CLSID aclsid[8];
    IPropertyStorage *pPropSet;

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FILETIME ftStart;

    Now(&ftStart);

    pPropSetStg->Delete(FMTID_SummaryInformation);

    for (int i=0; i<5; i++)
    {
        if (i & 4)
            afmtid[i] = FMTID_SummaryInformation;
        else
            UuidCreate(&afmtid[i]);

        UuidCreate(&aclsid[i]);

        Check(S_OK, pPropSetStg->Create(afmtid[i], aclsid+i,
             ((i & 2) ? PROPSETFLAG_ANSI : 0),
            STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropSet));
        pPropSet->Release();
    }


    STATPROPSETSTG StatBuffer[6];
    ULONG celt;
    IEnumSTATPROPSETSTG *penum, *penum2;

    Check(S_OK, pPropSetStg->Enum(&penum));

    IUnknown *punk, *punk2;
    IEnumSTATPROPSETSTG *penum3;
    Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
    Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&penum3));
    Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSETSTG, (void**)&punk2));
    ASSERT(punk == punk2);
    punk->Release();
    penum3->Release();
    punk2->Release();

    // test S_FALSE
    Check(S_FALSE, penum->Next(6, StatBuffer, &celt));
    ASSERT(celt == 5);
    penum->Reset();


    // test reading half out, then cloning, then comparing
    // rest of enumeration with other clone.

    Check(S_OK, penum->Next(3, StatBuffer, &celt));
    ASSERT(celt == 3);
    celt = 0;
    Check(S_OK, penum->Clone(&penum2));
    Check(S_OK, penum->Next(2, StatBuffer, &celt));
    ASSERT(celt == 2);
    // check the clone
    for (int c=0; c<2; c++)
    {
        STATPROPSETSTG CloneStat;
        Check(S_OK, penum2->Next(1, &CloneStat, NULL));
        Check(TRUE, 0 == memcmp(&CloneStat, StatBuffer+c, sizeof(CloneStat)));
        Check(TRUE, CloneStat.dwOSVersion == PROPSETHDR_OSVERSION_UNKNOWN);
    }

    // check both empty
    celt = 0;
    Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
    ASSERT(celt == 0);

    Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
    ASSERT(celt == 0);

    penum->Reset();

    //
    // loop deleting one propset at a time
    // enumerate the propsets checking that correct ones appear.
    //
    for (ULONG d = 0; d<5; d++)
    {
        // d is for delete

        BOOL afFound[5];

        Check(S_OK, penum->Next(5-d, StatBuffer, &celt));
        ASSERT(celt == 5-d);
        penum->Reset();
    
        memset(afFound, 0, sizeof(afFound));
        for (ULONG iPropSet=0; iPropSet<5; iPropSet++)
        {
            ULONG iSearch;	
            for (iSearch=0; iSearch<5-d; iSearch++)
            {
                if (0 == memcmp(&StatBuffer[iSearch].fmtid, 
                                &afmtid[iPropSet], 
                                sizeof(StatBuffer[0].fmtid)))
                {
                    ASSERT (!afFound[iPropSet]);
                    afFound[iPropSet] = TRUE;
                    break;
                }
            }
            if (iPropSet < d)
            {
                ASSERT(!afFound[iPropSet]);
            }
            if (iSearch == 5-d)
            {
                ASSERT(iPropSet < d);
                continue;
            }
            ASSERT( ( (StatBuffer[iSearch].grfFlags 
                           & PROPSETFLAG_NONSIMPLE)  == 0 ) ); 
            ASSERT((StatBuffer[iSearch].grfFlags & PROPSETFLAG_ANSI) == 0);
            if (StatBuffer[iSearch].grfFlags & PROPSETFLAG_NONSIMPLE)
            {
                ASSERT(StatBuffer[iSearch].clsid == aclsid[iPropSet]);
            }
            else
            {
                ASSERT(StatBuffer[iSearch].clsid == CLSID_NULL);
            }
            CheckTime(ftStart, StatBuffer[iSearch].mtime);
            CheckTime(ftStart, StatBuffer[iSearch].atime);
            CheckTime(ftStart, StatBuffer[iSearch].ctime);
        }

        Check(S_OK, pPropSetStg->Delete(afmtid[d]));
        Check(S_OK, penum->Reset());
    }

    penum->Release();
    penum2->Release();

}


//   Creation tests
//
//       Access flags/Valid parameters/Permissions
//          Check readonly cannot be written -
//              WriteProperties, WritePropertyNames
void
test_IPropertyStorage_Access(IStorage *pStorage)
{
    printf( "   IPropertyStorage creation (access) tests\n" );

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, 0, 
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));

//   QueryInterface tests
//          QI to IPropertyStorage
//          QI to IUnknown on IPropertyStorage
//          QI back to IPropertyStorage from IUnknown
//      
//          Release all.
    IPropertyStorage *pPropStg2,*pPropStg3;
    IUnknown *punk;

    Check(S_OK, pPropStg->QueryInterface(IID_IPropertyStorage, 
        (void**)&pPropStg2));
    Check(S_OK, pPropStg->QueryInterface(IID_IUnknown, 
        (void**)&punk));
    Check(S_OK, punk->QueryInterface(IID_IPropertyStorage, 
        (void**)&pPropStg3));
    pPropStg3->Release();
    pPropStg2->Release();
    punk->Release();

    PROPSPEC ps;
    ps.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsTestProp, "testprop");
    ps.lpwstr = ocsTestProp;
    PROPVARIANT pv;
    pv.vt = VT_LPWSTR;
    DECLARE_CONST_OLESTR(ocsTestVal, "testval");
    LPOLESTR ocsTest = ocsTestVal;
    DECLARE_WIDESTR(wcsTestVal, "testval");
    pv.pwszVal = wcsTestVal;
    Check(S_OK, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    pPropStg->Release();
    Check(S_OK, pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READ,
                                  &pPropStg)); 
    Check(STG_E_ACCESSDENIED, pPropStg->WriteMultiple(1, &ps, &pv, 2));
    Check(STG_E_ACCESSDENIED, pPropStg->DeleteMultiple(1, &ps));
    PROPID propid=3;
    Check(STG_E_ACCESSDENIED, pPropStg->WritePropertyNames(1, &propid, 
                                                           &ocsTestVal));
    Check(STG_E_ACCESSDENIED, pPropStg->DeletePropertyNames(1, &propid));
    FILETIME ft;
    Check(STG_E_ACCESSDENIED, pPropStg->SetTimes(&ft, &ft, &ft));
    CLSID clsid;
    Check(STG_E_ACCESSDENIED, pPropStg->SetClass(clsid));

    pPropStg->Release();
}

//   Creation tests
//       Check VT_STREAM etc not usable with simple.

void 
test_IPropertyStorage_Create(IStorage *pStorage)
{
    printf( "   IPropertyStorage creation tests\n" );
    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;

    UuidCreate(&fmtid);

    // check by name
    IPropertyStorage *pPropStg;
    Check(S_OK, pPropSetStg->Create(fmtid, NULL, 0 /* simple */, 
        STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, &pPropStg));
    PROPSPEC ps;
    ps.ulKind = PRSPEC_PROPID;
    ps.propid = 2;
    PROPVARIANT pv;
    pv.vt = VT_STREAM;
    pv.pStream = NULL;
    // the ref impl. does not recognize VT_STREAM, and will thus
    // treat it as a invalid type.
    Check(STG_E_INVALIDPARAMETER, 
          pPropStg->WriteMultiple(1, &ps, &pv, 2000));  
    // 
    pPropStg->Release();
}


void
CheckStat(  IPropertyStorage *pPropSet, REFFMTID fmtid, 
            REFCLSID clsid, ULONG PropSetFlag,
            const FILETIME & ftStart, DWORD dwOSVersion )
{
    STATPROPSETSTG StatPropSetStg;
    Check(S_OK, pPropSet->Stat(&StatPropSetStg));

    Check(TRUE, StatPropSetStg.fmtid == fmtid);
    Check(TRUE, StatPropSetStg.clsid == clsid);
    Check(TRUE, StatPropSetStg.grfFlags == PropSetFlag);
    Check(TRUE, StatPropSetStg.dwOSVersion == dwOSVersion);
    CheckTime(ftStart, StatPropSetStg.mtime);
    CheckTime(ftStart, StatPropSetStg.ctime);
    CheckTime(ftStart, StatPropSetStg.atime);
}

//
//   
//   Stat (Create four combinations)
//       Check ansi/wide fflag
//     Also test clsid on propset

void test_IPropertyStorage_Stat(IStorage *pStorage)
{
    printf( "   IPropertyStorage::Stat\n" );

    DWORD dwOSVersion = 0;

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);
    FMTID fmtid;
    UuidCreate(&fmtid);
    IPropertyStorage *pPropSet;
    STATPROPSETSTG StatPropSetStg;

    // Calculate the OS Version

#ifdef _MAC_
#error Do not know how to calculate the OS Version for the macintosh.
#endif

    dwOSVersion = MAKELONG( 0x0100, OSKIND_REF );

    for (ULONG i=0; i<4; i++)
    {
        FILETIME ftStart;
        DfGetTOD(&ftStart);

        memset(&StatPropSetStg, 0, sizeof(StatPropSetStg));
        CLSID clsid;
        UuidCreate(&clsid);
        Check(S_OK, pPropSetStg->Create(fmtid, &clsid,
            ((i & 2) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));

        CheckStat(pPropSet, fmtid, clsid, 
                  ((i & 2) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );
        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid, 
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
        CheckStat(pPropSet, fmtid, clsid, 
                  ((i & 2) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );

        pPropSet->Release();

        Check(S_OK, pPropSetStg->Open(fmtid, 
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropSet));
        CheckStat(pPropSet, fmtid, clsid, 
            ((i & 2) ? PROPSETFLAG_ANSI : 0), ftStart, dwOSVersion );
        pPropSet->Release();
    }
}

//
// test using IStorage::Commit to commit the changes in a nested
// property set
//

void
test_IPropertyStorage_Commit(IStorage *pStorage)
{
    printf( "   IPropertyStorage::Commit\n" );

    // create another level of storage

    SCODE sc;

    // 8 scenarios: simple  * direct * (release only + commit storage + commit
    // propset)
    // note: some scenarios might repeat since there is no
    // non-simple/transacted cases
    for (int i=0; i<32; i++)
    {
        CTempStorage pDeeper(Create, pStorage, GetNextTest(), 
            STGM_DIRECT);
        TSafeStorage< IPropertySetStorage > pPropSetStg(pDeeper);
    
        FMTID fmtid;
        UuidCreate(&fmtid);
    
        IPropertyStorage *pPropSet;
        if (S_OK != (sc = pPropSetStg->Create(
            fmtid, NULL, 
            PROPSETFLAG_DEFAULT,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE | 
            STGM_DIRECT,
             &pPropSet)))
        {
            Check(S_OK, sc);
        }
              
        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = 100;
        PROPVARIANT pv;
        pv.vt = VT_I4;
        pv.lVal = 1234;
    
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));
    
        PropVariantClear(&pv);
        Check(S_OK, pPropSet->ReadMultiple(1, &ps, &pv));
        ASSERT(pv.vt==VT_I4);
        ASSERT(pv.lVal == 1234);

        pv.lVal = 2345; // no size changes
        Check(S_OK, pPropSet->WriteMultiple(1, &ps, &pv, 1000));

        if (i & 4)
            Check(S_OK, pPropSet->Commit(0));
        if (i & 2)
            Check(S_OK, pStorage->Commit(0));

        Check(0, pPropSet->Release()); // implicit commit if i&2 is false

        if (S_OK == pPropSetStg->Open(fmtid, STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                    &pPropSet))
        {
            PropVariantClear(&pv);
            Check( S_OK, pPropSet->ReadMultiple(1, &ps, &pv));
            ASSERT(pv.vt == VT_I4);
            ASSERT(pv.lVal == 2345);
            pPropSet->Release();
        }
    }
}

void
test_IPropertyStorage_WriteMultiple(IStorage *pStorage)
{
    test_IPropertyStorage_Commit(pStorage);
}

// this serves as a test for WritePropertyNames, ReadPropertyNames, DeletePropertyNames
// DeleteMultiple, PropVariantCopy, FreePropVariantArray.

void
test_IPropertyStorage_DeleteMultiple(IStorage *pStorage)
{
    printf( "   IPropertyStorage::DeleteMultiple\n" );

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStorage);

    FMTID fmtid;
    UuidCreate(&fmtid);

    IPropertyStorage *pPropSet;

    int PropId = 3;

    UuidCreate(&fmtid);
    Check(S_OK, pPropSetStg->Create(
        fmtid,
        NULL, PROPSETFLAG_DEFAULT,
        STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
        &pPropSet));
    
    // create and delete each type.
    
    PROPVARIANT *pVar;
        
    for (int AtOnce=1; AtOnce <3; AtOnce++)
    {
        CGenProps gp;
        int Actual;
        while (pVar = gp.GetNext(AtOnce, &Actual, FALSE, TRUE))
        {
            PROPSPEC ps[3];
            PROPID   rgpropid[3];
            LPOLESTR rglpostrName[3];
            OLECHAR    aosz[3][16];
            char pchTemp [16];

            for (int s=0; s<3; s++)
            {                
                sprintf(pchTemp, "prop%d", PropId );
                STOT(pchTemp, aosz[s], strlen(pchTemp)+1);
                rgpropid[s] = PropId++;
                rglpostrName[s] = &aosz[s][0];
                ps[s].ulKind = PRSPEC_LPWSTR;
                ps[s].lpwstr = &aosz[s][0];
            }

            for (int l=1; l<Actual; l++)
            {                
                PROPVARIANT VarRead[3];
                Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                Check(S_OK, pPropSet->
                      WritePropertyNames(l, rgpropid, rglpostrName));
                Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                
                Check(S_OK, pPropSet->WriteMultiple(l, ps, pVar, 1000));
                Check(S_OK, pPropSet->ReadMultiple(l, ps, VarRead));
                Check(S_OK, FreePropVariantArray(l, VarRead));
                Check(S_OK, pPropSet->DeleteMultiple(l, ps));
                Check(S_FALSE, pPropSet->ReadMultiple(l, ps, VarRead));
                Check(S_OK, FreePropVariantArray(l, VarRead));

                LPOLESTR rglpostrNameCheck[3];
                Check(S_OK, pPropSet->
                      ReadPropertyNames(l, rgpropid, rglpostrNameCheck));

                for (int c=0; c<l; c++)
                {
                    ASSERT(ocscmp(rglpostrNameCheck[c], rglpostrName[c])==0);
                    CoTaskMemFree(rglpostrNameCheck[c]);
                }
                Check(S_OK, pPropSet->DeletePropertyNames(l, rgpropid));
                Check(S_FALSE, pPropSet->ReadPropertyNames(l, rgpropid, 
                                                           rglpostrNameCheck));
            }
            
            FreePropVariantArray(Actual, pVar);
            delete pVar;
        }
    }
    pPropSet->Release();
}

void
test_IPropertyStorage(IStorage *pStorage)
{
    test_IPropertyStorage_Access(pStorage);
    test_IPropertyStorage_Create(pStorage);
    test_IPropertyStorage_Stat(pStorage);
    test_IPropertyStorage_WriteMultiple(pStorage);
    test_IPropertyStorage_DeleteMultiple(pStorage);
}



//
//   Word6.0 summary information
//      Open
//      Read fields
//      Stat
//

#define W6TEST "w6test.doc"

void test_Word6(IStorage *pStorage)
{
    printf( "   Word 6.0 compatibility test\n" );

    extern unsigned char g_achTestDoc[];
    extern unsigned g_cbTestDoc;
    OLECHAR ocsTempFile[MAX_PATH+1];

    FILE *f = fopen(W6TEST, "w+b");
    int nWritten = fwrite(g_achTestDoc, 1, g_cbTestDoc, f);
    ASSERT(nWritten == (int)g_cbTestDoc);
    fclose(f);

    STOT(W6TEST, ocsTempFile, strlen(W6TEST)+1);
    IStorage *pStg;
    Check(S_OK, StgOpenStorage(ocsTempFile, 
                               (IStorage*)NULL,
                               (DWORD) STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                               0, 
                               0, 
                               &pStg));

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    Check(S_OK, pPropSetStg->Open(FMTID_SummaryInformation,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ,
                    &pPropStg));

#define WORDPROPS 18

    static struct tagWordTest {
        VARENUM vt;
        void *pv;
    } avt[WORDPROPS] = {
        VT_LPSTR, "Title of the document.",    // PID_TITLE                                 
        VT_LPSTR, "Subject of the document.",  // PID_SUBJECT                               
        VT_LPSTR, "Author of the document.",   // PID_AUTHOR                                
        VT_LPSTR, "Keywords of the document.", // PID_KEYWORDS                              
        VT_LPSTR, "Comments of the document.", // PID_COMMENTS                              
        VT_LPSTR, "Normal.dot",                // PID_TEMPLATE -- Normal.dot                
        VT_LPSTR, "Bill Morel",                // PID_LASTAUTHOR --                         
        VT_LPSTR, "3",                         // PID_REVNUMBER -- '3'                      
        VT_EMPTY, 0,                           // PID_EDITTIME -- 3 Minutes FILETIME        
        VT_EMPTY, 0,                           // PID_LASTPRINTED -- 04/07/95 12:04 FILETIME
        VT_EMPTY, 0,                           // PID_CREATE_DTM                            
        VT_EMPTY, 0,                           // PID_LASTSAVE_DTM                          
        VT_I4, (void*) 1,                      // PID_PAGECOUNT                             
        VT_I4, (void*) 7,                      // PID_WORDCOUNT                             
        VT_I4, (void*) 65,                     // PID_CHARCOUNT                             
        VT_EMPTY, 0,                           // PID_THUMBNAIL
        VT_LPSTR, "Microsoft Word 6.0",        // PID_APPNAME
        VT_I4, 0  };                           // PID_SECURITY

    PROPSPEC propspec[WORDPROPS+2];
    int i;
    for (i=2; i<WORDPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[WORDPROPS+2];

    Check(S_OK, pPropStg->ReadMultiple(WORDPROPS, propspec+2, propvar+2));

    for (i=2; i<WORDPROPS+2; i++)
    {
        if ( propvar[i].vt != avt[i-2].vt )
        {
            printf( " PROPTEST: 0x%x retrieved type 0x%x, expected type 0x%x\n",
                    i, propvar[i].vt, avt[i-2].vt );
            ASSERT(propvar[i].vt == avt[i-2].vt);
        }

        switch (propvar[i].vt)
        {
        case VT_LPSTR:
            ASSERT(strcmp(propvar[i].pszVal, (char*)avt[i-2].pv)==0);
            break;
        case VT_I4:
            ASSERT(propvar[i].lVal == (int)avt[i-2].pv);
            break;
        }
    }
    FreePropVariantArray( WORDPROPS, propvar+2 );    
    pPropStg->Release();
    pStg->Release();

    //_unlink("w6test");
}

BOOL
IsEqualSTATPROPSTG(const STATPROPSTG *p1, const STATPROPSTG *p2)
{
    BOOL f1 = p1->propid == p2->propid;
    BOOL f2 = p1->vt == p2->vt;
    BOOL f3 = (p1->lpwstrName == NULL && p2->lpwstrName == NULL) ||
              ((p1->lpwstrName != NULL && p2->lpwstrName != NULL) &&
               ocscmp(p1->lpwstrName, p2->lpwstrName) == 0);
    return(f1 && f2 && f3);
}

void
test_IEnumSTATPROPSTG(IStorage *pstgTemp)
{
    printf( "   IEnumSTATPROPSTG\n" );

    PROPID apropid[8];
    LPOLESTR alpostrName[8];
    OLECHAR aosz[8][32];
    PROPID PropId=2;
    PROPSPEC ps[8];
    char pchTemp[32];

    FMTID fmtid;
    IPropertyStorage *pPropStg;

    TSafeStorage< IPropertySetStorage > pPropSetStg(pstgTemp);

    UuidCreate(&fmtid);

    for (int setup=0; setup<8; setup++)
    {
        alpostrName[setup] = &aosz[setup][0];
    }


    CGenProps gp;

    // simple/simple, ansi/wide, named/not named
    for (int outer=0; outer<8; outer++)
    {
        Check(S_OK, pPropSetStg->Create(fmtid, NULL,
            ((outer&2) ? PROPSETFLAG_ANSI : 0),
            STGM_CREATE | STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
            &pPropStg));


        for (int i=0; i<CPROPERTIES; i++)
        {
            apropid[i] = PropId++;
            if (outer & 1)
            {
                ps[i].ulKind = PRSPEC_LPWSTR;
                sprintf(pchTemp, "prop%d\0", apropid[i]);
                STOT(pchTemp, aosz[i], strlen(pchTemp)+1);
                ps[i].lpwstr = aosz[i];
            }
            else
            {
                ps[i].ulKind = PRSPEC_PROPID;
                ps[i].propid = apropid[i];
            }
        }

        if (outer & 1)
        {
            Check(S_OK, pPropStg->WritePropertyNames(CPROPERTIES, apropid, alpostrName));
        }
        
        PROPVARIANT *pVar = gp.GetNext(CPROPERTIES, NULL, TRUE, TRUE); 
        ASSERT(pVar != NULL);

        Check(S_OK, pPropStg->WriteMultiple(CPROPERTIES, ps, pVar, 1000));
        FreePropVariantArray(CPROPERTIES, pVar);
        delete pVar;

        // Allocate enough STATPROPSTGs for one more than the actual properties
        // in the set.

        STATPROPSTG StatBuffer[CPROPERTIES+1];
        ULONG celt;
        IEnumSTATPROPSTG *penum, *penum2;
    
        Check(S_OK, pPropStg->Enum(&penum));
    
        IUnknown *punk, *punk2;
        IEnumSTATPROPSTG *penum3;
        Check(S_OK, penum->QueryInterface(IID_IUnknown, (void**)&punk));
        Check(S_OK, punk->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&penum3));
        Check(S_OK, penum->QueryInterface(IID_IEnumSTATPROPSTG, (void**)&punk2));
        ASSERT(punk == punk2);
        punk->Release();
        penum3->Release();
        punk2->Release();
    
        // test S_FALSE
        Check(S_FALSE, penum->Next( CPROPERTIES+1, StatBuffer, &celt));
        ASSERT(celt == CPROPERTIES);

        CleanStat(celt, StatBuffer);

        penum->Reset();
    
    
        // test reading half out, then cloning, then comparing
        // rest of enumeration with other clone.

        Check(S_OK, penum->Next(CPROPERTIES/2, StatBuffer, &celt));
        ASSERT(celt == CPROPERTIES/2);
        CleanStat(celt, StatBuffer);
        celt = 0;
        Check(S_OK, penum->Clone(&penum2));
        Check(S_OK, penum->Next(CPROPERTIES - CPROPERTIES/2, StatBuffer, &celt));
        ASSERT(celt == CPROPERTIES - CPROPERTIES/2);
        // check the clone
        for (int c=0; c<CPROPERTIES - CPROPERTIES/2; c++)
        {
            STATPROPSTG CloneStat;
            Check(S_OK, penum2->Next(1, &CloneStat, NULL));
            ASSERT(IsEqualSTATPROPSTG(&CloneStat, StatBuffer+c));
            CleanStat(1, &CloneStat);
        }
    
        CleanStat(celt, StatBuffer);

        // check both empty
        celt = 0;
        Check(S_FALSE, penum->Next(1, StatBuffer, &celt));
        ASSERT(celt == 0);
    
        Check(S_FALSE, penum2->Next(1, StatBuffer, &celt));
        ASSERT(celt == 0);
    
        penum->Reset();
    
        //
        // loop deleting one property at a time
        // enumerate the propertys checking that correct ones appear.
        //
        for (ULONG d = 0; d<CPROPERTIES; d++)
        {
            // d is for delete
    
            BOOL afFound[CPROPERTIES];
            ULONG cTotal = 0;

            Check(S_OK, penum->Next(CPROPERTIES-d, StatBuffer, &celt));
            ASSERT(celt == CPROPERTIES-d);
            penum->Reset();
        
            memset(afFound, 0, sizeof(afFound));

            for (ULONG iProperty=0; iProperty<CPROPERTIES; iProperty++)
            {

                // Search the StatBuffer for this property.

                for (ULONG iSearch=0; iSearch<CPROPERTIES-d; iSearch++)
                {

                    // Compare this entry in the StatBuffer to the property for which we're searching.
                    // Use the lpstrName or propid, whichever is appropriate for this pass (indicated
                    // by 'outer').

                    if ( ( (outer & 1) == 1 && 0 == ocscmp(StatBuffer[iSearch].lpwstrName, ps[iProperty].lpwstr) )
                         ||
                         ( (outer & 1) == 0 && StatBuffer[iSearch].propid == apropid[iProperty] )
                       )
                    {
                        ASSERT (!afFound[iSearch]);
                        afFound[iSearch] = TRUE;
                        cTotal++;
                        break;
                    }
                }
            }

            CleanStat(celt, StatBuffer);

            ASSERT(cTotal == CPROPERTIES-d);

            Check(S_OK, pPropStg->DeleteMultiple(1, ps+d));
            Check(S_OK, penum->Reset());
        }
    
        penum->Release();
        penum2->Release();

        pPropStg->Release();

    }
}

void
test_MaxPropertyName(IStorage *pstgTemp)
{

    printf( "   Max Property Name length\n" );

    //  ----------
    //  Initialize
    //  ----------

    CPropVariant cpropvar;

    // Create a new storage, because we're going to create
    // well-known property sets, and this way we can be sure
    // that they don't already exist.

    TSafeStorage< IStorage > pstg;
    DECLARE_OLESTR(ocsMaxProp, "MaxPropNameTest");
    Check(S_OK, pstgTemp->CreateStorage( ocsMaxProp,
                                         STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                         0L, 0L,
                                         &pstg ));

    // Generate a new Format ID.

    FMTID fmtid;
    UuidCreate(&fmtid);

    // Get a IPropertySetStorage from the IStorage.

    TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    TSafeStorage< IPropertyStorage > pPropStg;

    //  ----------------------------------
    //  Test the non-SumInfo property set.
    //  ----------------------------------

    // Create a new PropertyStorage.

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));

    // Generate a property name which is max+1 characters.
    OLECHAR *poszPropertyName;
    poszPropertyName = (OLECHAR*) 
        CoTaskMemAlloc( (CCH_MAXPROPNAMESZ+1) * sizeof(OLECHAR) );
    Check(TRUE, poszPropertyName != NULL );

    for( ULONG ulIndex = 0; ulIndex < CCH_MAXPROPNAMESZ; ulIndex++ )
        poszPropertyName[ ulIndex ] = (OLECHAR)'a' + (OLECHAR) ( ulIndex % 26 );
    poszPropertyName[ CCH_MAXPROPNAMESZ ] = (OLECHAR)0;  // terminating null


    // Write out a property with this max+1 name.

    PROPSPEC propspec;

    propspec.ulKind = PRSPEC_LPWSTR;
    propspec.lpwstr = poszPropertyName;

    cpropvar = (long) 0x1234;

    Check(STG_E_INVALIDPARAMETER, pPropStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a max-character name (we create a max-
    // char name by terminating the previously-used string one character
    // earlier).

    poszPropertyName[ CWC_MAXPROPNAME ] = 0;
    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a minimum-character name.
    DECLARE_OLESTR(ocsX, "X");
    propspec.lpwstr = ocsX;
    Check(S_OK, pPropStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write out a property with a below-minimum-character name.
    DECLARE_OLESTR(ocsEmpty, ""); 
    propspec.lpwstr = ocsEmpty;
    Check(STG_E_INVALIDPARAMETER, 
          pPropStg->WriteMultiple( 1, &propspec,
                                   cpropvar,
                                   PID_FIRST_USABLE));
    CoTaskMemFree( poszPropertyName );
}

#define CODEPAGE_TEST_NAMED_PROPERTY     "Named Property"
#define CODEPAGE_TEST_UNNAMED_BSTR_PROPID   3
#define CODEPAGE_TEST_UNNAMED_I4_PROPID     4
#define CODEPAGE_TEST_VBSTR_PROPID          7
#define CODEPAGE_TEST_VPROPVAR_BSTR_PROPID  9

void
CreateCodePageTestFile( LPOLESTR poszFileName, 
                        IStorage **ppStg,
                        BOOL fUseUnicode)
{
    ASSERT( poszFileName != NULL );

    //  --------------
    //  Initialization
    //  --------------

    TSafeStorage< IPropertySetStorage > pPSStg;
    TSafeStorage< IPropertyStorage > pPStg;

    PROPSPEC propspec;
    CPropVariant cpropvar;

    *ppStg = NULL;

    OLECHAR poszActualFile[MAX_PATH];
    ocscpy(poszActualFile, poszFileName);

    // assume the path name has enough space, change the last character
    // of the filename
    int len = ocslen(poszActualFile);
    if (!fUseUnicode) 
    {
        
        poszActualFile[len]='a';
        poszActualFile[len+1]=0;
    }
    else
    {
        poszActualFile[len]='w';
        poszActualFile[len+1]=0;
    }

    Check(S_OK, StgCreateDocfile( poszActualFile,
                                  STGM_CREATE | STGM_READWRITE |
                                  STGM_SHARE_EXCLUSIVE,  
                                  0,
                                  ppStg ));

    // Get an IPropertySetStorage

    Check(S_OK, (*ppStg)->QueryInterface( IID_IPropertySetStorage, (void**)&pPSStg ));

    // Create an IPropertyStorage (ANSI or UNICODE)  
    DWORD psFlag= (fUseUnicode) ? 0 : PROPSETFLAG_ANSI ;

    Check(S_OK, pPSStg->Create( FMTID_NULL,
                                NULL,
                                psFlag,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                &pPStg ));

    //  ----------------------
    //  Write a named property
     //  ----------------------

    // Write a named I4 property

    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsNamed,  CODEPAGE_TEST_NAMED_PROPERTY);
    propspec.lpwstr = ocsNamed;

    cpropvar = (LONG) 0x12345678;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    //  --------------------------
    //  Write singleton properties
    //  --------------------------

    // Write an un-named BSTR.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;
    DECLARE_OLESTR(ocsBSTR, "BSTR Property");
    cpropvar.SetBSTR( ocsBSTR );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    // Write an un-named I4

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_I4_PROPID;

    cpropvar = (LONG) 0x76543210;
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    //  -----------------------
    //  Write vector properties
    //  -----------------------

    // Write a vector of BSTRs.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;
    DECLARE_OLESTR(ocsElt0, "BSTR Element 0");
    DECLARE_OLESTR(ocsElt1, "BSTR Element 1");
    
    cpropvar.SetBSTR( ocsElt1, 1 );
    cpropvar.SetBSTR( ocsElt0, 0 );
    ASSERT( (VT_VECTOR | VT_BSTR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

    //  -------------------------------
    //  Write Variant Vector Properties
    //  -------------------------------

    // Write a variant vector that has a BSTR

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    CPropVariant cpropvarT;
    DECLARE_OLESTR(ocsPropVect, "PropVar Vector BSTR");
    cpropvarT.SetBSTR( ocsPropVect );
    cpropvar[1] = (LPPROPVARIANT) cpropvarT;
    cpropvar[0] = (LPPROPVARIANT) CPropVariant((long) 44);
    ASSERT( (VT_VARIANT | VT_VECTOR) == cpropvar.VarType() );
    Check(S_OK, pPStg->WriteMultiple( 1, &propspec, cpropvar, PID_FIRST_USABLE ));

}   // CreateCodePageTestFile()


void
OpenCodePageTestFile( LPOLESTR poszFileName, 
                      IStorage **ppStg,
                      BOOL fUseUnicode)
{
    OLECHAR poszActualFile[MAX_PATH];
    ocscpy(poszActualFile, poszFileName);

    // assume the path name has enough space, change the last character
    // of the filename
    int len = ocslen(poszActualFile);
    if (!fUseUnicode) 
    {
        poszActualFile[len]='a';
        poszActualFile[len+1]=0;
    }
    else
    {
        poszActualFile[len]='w';
        poszActualFile[len+1]=0;
    }    

    Check(S_OK, StgOpenStorage( poszActualFile,
                                (IStorage*) NULL,
                                STGM_READWRITE | STGM_SHARE_EXCLUSIVE,  
                                (SNB) 0,
                                (DWORD) 0,
                                ppStg ));
}

void
ModifyPropSetCodePage( IStorage *pStg, ULONG ulCodePage )
{

    ASSERT( pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    DWORD dwOffset = 0;
    DWORD dwcbSection = 0;
    DWORD dwcProperties = 0;
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liSectionOffset, liCodePageOffset;

    TSafeStorage< IStream > pStm;

    CPropVariant cpropvar;

    // Open the Stream

    RtlGuidToPropertySetName( &FMTID_NULL, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  (VOID*)NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                                  (DWORD)NULL,
                                  &pStm ));

    // Seek past the propset header and the format ID.

    liSectionOffset.HighPart = 0;
    liSectionOffset.LowPart = sizeof(PROPERTYSETHEADER) + sizeof(FMTID);
    Check(S_OK, pStm->Seek(liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Move to the beginning of the property set.

    liSectionOffset.HighPart = 0;
    Check(S_OK, pStm->Read( &liSectionOffset.LowPart, sizeof(DWORD), NULL ));
    PropByteSwap(&liSectionOffset.LowPart);

    Check(S_OK, pStm->Seek( liSectionOffset, STREAM_SEEK_SET, NULL ));

    // Get the section size & property count.

    Check(S_OK, pStm->Read( &dwcbSection, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcbSection );

    Check(S_OK, pStm->Read( &dwcProperties, sizeof(DWORD), NULL ));
    PropByteSwap( &dwcProperties );

    // Scan for the PID_CODEPAGE property.
    ULONG ulIndex; 
    for(ulIndex = 0; ulIndex < dwcProperties; ulIndex++ )
    {
        PROPID propid;
        DWORD dwOffset;

        // Read in the PROPID
        Check(S_OK, pStm->Read( &propid, sizeof(PROPID), NULL ));

        // Is it the codepage?
        if( PropByteSwap(propid) == PID_CODEPAGE )
            break;

        // Read in this PROPIDs offset (we don't need it, but we want
        // to seek past it.
        Check(S_OK, pStm->Read( &dwOffset, sizeof(dwOffset), NULL ));
    }

    // Verify that the above for loop terminated because we found
    // the codepage.
    Check( TRUE, ulIndex < dwcProperties );

    // Move to the code page.

    liCodePageOffset.HighPart = 0;
    Check(S_OK, pStm->Read( &liCodePageOffset.LowPart, sizeof(DWORD), NULL ));
    PropByteSwap( &liCodePageOffset.LowPart );

    liCodePageOffset.LowPart += liSectionOffset.LowPart + sizeof(ULONG); // Move past VT too.
    ASSERT( liSectionOffset.HighPart == 0 );

    Check(S_OK, pStm->Seek( liCodePageOffset, STREAM_SEEK_SET, NULL ));

    // this is so that you can manually verify what was read
    // i.e. that it is the code page
    WORD wCodePage;                                          
    Check(S_OK, pStm->Read( &wCodePage, sizeof(WORD), NULL));
    Check(S_OK, pStm->Seek( liCodePageOffset, STREAM_SEEK_SET, NULL )); 
    
    // Write the new code page.
    wCodePage = PropByteSwap( (WORD) ((ulCodePage << 16) >> 16) );
    Check(S_OK, pStm->Write( &wCodePage, sizeof(wCodePage), &ulcbWritten ));
    Check(TRUE, ulcbWritten == sizeof(wCodePage) );

    //pStm->Commit(0);   
}   // ModifyPropSetCodePage()

void
ModifyOSVersion( IStorage* pStg, DWORD dwOSVersion )
{

    ASSERT( pStg != NULL );

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR aocPropSetName[ 32 ];
    ULONG ulcbWritten = 0;

    LARGE_INTEGER   liOffset;
    PROPERTYSETHEADER propsetheader;
    TSafeStorage< IStream > pStm;

    // Open the Stream

    RtlGuidToPropertySetName( &FMTID_NULL, aocPropSetName );
    Check(S_OK, pStg->OpenStream( aocPropSetName,
                                  (VOID*)NULL,
                                  STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                                  (DWORD)NULL,
                                  &pStm ));


    // Seek to the OS Version field in the header.

    liOffset.HighPart = 0;
    propsetheader;  // avoid compiler warning of unref'd var.
    liOffset.LowPart = sizeof(propsetheader.wByteOrder) + sizeof(propsetheader.wFormat);
    Check(S_OK, pStm->Seek( liOffset, STREAM_SEEK_SET, NULL ));

    // Set the new OS Version
    PropByteSwap( &dwOSVersion );
    Check(S_OK, pStm->Write( &dwOSVersion, sizeof(dwOSVersion), &ulcbWritten ));
    Check(TRUE, ulcbWritten == sizeof(dwOSVersion) );

}   // ModifyOSVersion()


#define CODEPAGE_DEFAULT    0x04e4  // US English
#define CODEPAGE_GOOD       0x0000  // Present on a US English machine
#define CODEPAGE_BAD        0x9999  // Non-existent code page

void
test_CodePages( LPOLESTR poszDirectory, 
                ULONG ulTestOptions, 
                BOOL fTestUnicode)
{

    printf( "   Code Page compatibility -- " );

    if (ulTestOptions & TEST_INTEROP_R)
        printf("Verify Read, ");
    else 
        printf("Write & Read, ");
    if (fTestUnicode)
        printf("UNICODE files\n");
    else
        printf("ASCII files\n");

    //  --------------
    //  Initialization
    //  --------------

    OLECHAR oszBadFile[ MAX_PATH ];
    OLECHAR oszGoodFile[ MAX_PATH ];
    OLECHAR oszUnicodeFile[ MAX_PATH ];
    OLECHAR oszMacFile[ MAX_PATH ];
    HRESULT hr = S_OK;

    TSafeStorage< IStorage > pStgBad, pStgGood, pStgUnicode, pStgMac;
    CPropVariant cpropvarWrite, cpropvarRead;

    Check( TRUE, GetACP() == CODEPAGE_DEFAULT );
    
    //  ------------------------------
    //  Create test property sets
    //  ------------------------------

    // Create a property set with a bad codepage.
#ifdef _WIN32
    DECLARE_OLESTR(ocsBad, "\\badcp.sg");
    ocscpy( oszBadFile, poszDirectory );    
    ocscat( oszBadFile, ocsBad );
#else
    DECLARE_OLESTR(ocsBad, "badcp.sg");
    ocscpy( oszBadFile, ocsBad );
#endif
    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        CreateCodePageTestFile( oszBadFile, &pStgBad, fTestUnicode );
        if (!fTestUnicode)
        {                       
            // modification of code page is only
            // interesting for ansi property sets,
            // otherwise it will result in in error
            ModifyPropSetCodePage( pStgBad, CODEPAGE_BAD );
        }
    }
    else 
        OpenCodePageTestFile( oszBadFile, &pStgBad, fTestUnicode );

    // Create a property set with a good codepage.

#ifdef _WIN32
    ocscpy( oszGoodFile, poszDirectory );
    DECLARE_OLESTR(ocsGood, "\\goodcp.sg");
    ocscat( oszGoodFile, ocsGood );
#else
    DECLARE_OLESTR(ocsGood, "goodcp.sg");
    ocscpy( oszGoodFile, ocsGood );
#endif

    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        CreateCodePageTestFile( oszGoodFile, &pStgGood, fTestUnicode );
        // We can only modify code page of ansi property sets; Modfiying 
        // code page of UNICODE pages will result in a INVALID_HEADER
        // 'cos it will treat strings as wide chars instead of single-byte
        if (!fTestUnicode)
        {
            ModifyPropSetCodePage( pStgGood, CODEPAGE_GOOD );
        }
    }
    else 
        OpenCodePageTestFile( oszGoodFile, &pStgGood, fTestUnicode );

    // Create a property set that has the OS Kind (in the
    // header) set to "Mac".

#ifdef _WIN32
    DECLARE_OLESTR(ocsMac, "\\mackind.sg");
    ocscpy( oszMacFile, poszDirectory );
    ocscat( oszMacFile, ocsMac );
#else
    DECLARE_OLESTR(ocsMac, "mackind.sg");
    ocscpy( oszMacFile, ocsMac );
#endif
    
    if (! (ulTestOptions & TEST_INTEROP_R))
    {
        CreateCodePageTestFile( oszMacFile, &pStgMac, fTestUnicode );        
        ModifyOSVersion( pStgMac, 0x00010904 );
    }
    else
        OpenCodePageTestFile( oszMacFile, &pStgMac, fTestUnicode );

    //  ---------------------------
    //  Open the Ansi property sets
    //  ---------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStgBad(pStgBad);
    TSafeStorage< IPropertySetStorage > pPropSetStgGood(pStgGood);
    TSafeStorage< IPropertySetStorage > pPropSetStgMac(pStgMac);

    TSafeStorage< IPropertyStorage > pPropStgBad, pPropStgGood, pPropStgMac;

    Check(S_OK, pPropSetStgBad->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgBad));

    Check(S_OK, pPropSetStgGood->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgGood));

    Check(S_OK, pPropSetStgMac->Open(FMTID_NULL,
            STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStgMac));
    
    PROPSPEC propspec;
    PROPVARIANT propvar;
    PropVariantInit( &propvar );

    // ASSUMPTION: all three files are created all together by
    //    proptest, they will all be ansi or they will all be
    //    unicode.
    //
    // For UNICODE APIs, when the code page is not Unicode, it will
    // try and translate it to unicode and thus result in an error

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 1;        // propid for code page indicator
    Check(S_OK, pPropStgGood->ReadMultiple( 1, &propspec, &propvar));

    HRESULT pStgBadHr = S_OK;   // default
    if (propvar.iVal == (SHORT) CODEPAGE_GOOD) 
    {                           // files created in Ansi
#ifdef _UNICODE
        pStgBadHr = HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
#endif
    }

    // Since we are doing interoperability testing and pStgBad with
    // a wrong codepage number will result in a invalid_header error,
    // we change it back to normal to get rid of the error.
    //
    // Also, we only change it when the current code page is bad,
    // otherwise, we leave it as it is.
    //
    // We know that the correct number to put in is 1252 'cos we only
    // change the code page for ansi property sets.
    if (propvar.iVal == (SHORT) CODEPAGE_BAD)
        ModifyPropSetCodePage( pStgBad, 1252 );  

    //  ------------------------------------------
    //  Test BSTRs in the three property sets
    //  ------------------------------------------
    // Attempt to read by name.

    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsCP_test, CODEPAGE_TEST_NAMED_PROPERTY);
    propspec.lpwstr = ocsCP_test;

    CPropVariant cpropvar=(LONG) 0x12345678;

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    PropVariantClear( &propvar );

    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));    
    PropVariantClear( &propvar );

    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));    
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    

    // Attempt to write by name.

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    // Attempt to read the BSTR property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_BSTR_PROPID;

    DECLARE_OLESTR(ocsBSTR, "BSTR Property");
    cpropvar.SetBSTR( ocsBSTR );
    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    PropVariantClear( &propvar );
    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
    PropVariantClear( &propvar );
    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the BSTR property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    // Attempt to read the BSTR Vector property

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VBSTR_PROPID;
    DECLARE_OLESTR(ocsElt0, "BSTR Element 0");
    DECLARE_OLESTR(ocsElt1, "BSTR Element 1");    
    cpropvar.SetBSTR( ocsElt1, 1 );
    cpropvar.SetBSTR( ocsElt0, 0 );
    ASSERT( (VT_VECTOR | VT_BSTR) == cpropvar.VarType() );

    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    PropVariantClear( &propvar );
    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
    
    PropVariantClear(&propvar);
    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the BSTR Vector property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );
    
    // Attempt to read the Variant Vector which has a BSTR
    CPropVariant cpropvarT;
    DECLARE_OLESTR(ocsPropVect, "PropVar Vector BSTR");
    cpropvarT.SetBSTR( ocsPropVect );
    cpropvar[1] = (LPPROPVARIANT) cpropvarT;
    cpropvar[0] = (LPPROPVARIANT) CPropVariant((long) 44);
    ASSERT( (VT_VARIANT | VT_VECTOR) == cpropvar.VarType() );

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_VPROPVAR_BSTR_PROPID;

    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    PropVariantClear( &propvar );
    Check(pStgBadHr, 
          pPropStgBad->ReadMultiple( 1, &propspec, &propvar ));
    
    PropVariantClear(&propvar);
    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the Variant Vector which has a BSTR

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(pStgBadHr,
          pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    // Attempt to read the I4 property.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = CODEPAGE_TEST_UNNAMED_I4_PROPID;
    Check(S_OK, 
          pPropStgMac->ReadMultiple( 1, &propspec, &propvar ));
    cpropvar = (LONG) 0x76543210;
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));
    PropVariantClear( &propvar );

    hr = pPropStgBad->ReadMultiple( 1, &propspec, &propvar );
    Check(TRUE, S_OK == hr || pStgBadHr == hr );
    PropVariantClear( &propvar );

    Check(S_OK,
          pPropStgGood->ReadMultiple( 1, &propspec, &propvar ));
    Check(S_OK, CPropVariant::Compare( &propvar, &cpropvar ));

    // Attempt to write the I4 property

    Check(S_OK,
          pPropStgMac->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));

    hr = pPropStgBad->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE );
    Check(TRUE, S_OK == hr || pStgBadHr == hr );

    Check(S_OK,
          pPropStgGood->WriteMultiple( 1, &propspec, &propvar, PID_FIRST_USABLE ));
    PropVariantClear( &propvar );

    //  ---------------------------------------
    //  Test LPSTRs in the Unicode property set
    //  ---------------------------------------

    // This test doesn't verify that the LPSTRs are actually
    // written in Unicode.  A manual test is required for that.

    // Create a Unicode property set.  We'll make it
    // non-simple so that we can test a VT_STREAM (which
    // is stored like an LPSTR).
#ifdef _WIN32
    DECLARE_OLESTR(ocsUni, "\\UnicodCP.stg");
    ocscpy( oszUnicodeFile, poszDirectory );
    ocscat( oszUnicodeFile, ocsUni);
#else
    DECLARE_OLESTR(ocsUni, "UnicodCP.stg");
    ocscpy( oszUnicodeFile, ocsUni );
#endif

    Check(S_OK, StgCreateDocfile(oszUnicodeFile,
                                 STGM_CREATE | STGM_READWRITE |
                                 STGM_SHARE_EXCLUSIVE, 
                                 (DWORD)NULL,
                                 &pStgUnicode));

    TSafeStorage< IPropertySetStorage > pPropSetStgUnicode(pStgUnicode);
    TSafeStorage< IPropertyStorage > pPropStgUnicode;
    Check(S_OK, pPropSetStgUnicode->Create(FMTID_NULL,
                                           &CLSID_NULL,
                                           PROPSETFLAG_DEFAULT,
                                           STGM_CREATE | STGM_SHARE_EXCLUSIVE
                                           | STGM_READWRITE, 
                                           &pPropStgUnicode));


    // Write/verify an LPSTR property.

    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsLPSTR, "LPSTR Property");
    propspec.lpwstr = ocsLPSTR;

    cpropvarWrite = "An LPSTR Property";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite, (LPSTR) cpropvarRead ));
    cpropvarRead.Clear();

    // Write/verify a vector of LPSTR properties
    DECLARE_OLESTR(ocsVectLPSTR, "Vector of LPSTR properties"); 
    propspec.lpwstr = ocsVectLPSTR;

    cpropvarWrite[1] = "LPSTR Property #1";
    cpropvarWrite[0] = "LPSTR Property #0";

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    Check(0, strcmp( (LPSTR) cpropvarWrite[0], (LPSTR) cpropvarRead[0] ));
    cpropvarRead.Clear();

    // Write/verify a vector of variants which has an LPSTR
    DECLARE_OLESTR(ocsVariantWithLPSTR, "Variant Vector with an LPSTR");
    propspec.lpwstr = ocsVariantWithLPSTR;

    cpropvarWrite[1] = (LPPROPVARIANT) CPropVariant("LPSTR in a Variant Vector");
    cpropvarWrite[0] = (LPPROPVARIANT) CPropVariant((long) 22); // an I4
    ASSERT( (VT_VECTOR | VT_VARIANT) == cpropvarWrite.VarType() );

    Check(S_OK, pPropStgUnicode->WriteMultiple( 1, &propspec, cpropvarWrite, PID_FIRST_USABLE ));
    Check(S_OK, pPropStgUnicode->ReadMultiple( 1, &propspec, cpropvarRead ));

    Check(0, strcmp( (LPSTR) cpropvarWrite[1], (LPSTR) cpropvarRead[1] ));
    cpropvarRead.Clear();

}

void
test_PropertyInterfaces(IStorage *pstgTemp)
{
    // this test depends on being first for enumerator
    test_IEnumSTATPROPSETSTG(pstgTemp);

    test_MaxPropertyName(pstgTemp);
    test_IPropertyStorage(pstgTemp);
    test_IPropertySetStorage(pstgTemp);
    test_IEnumSTATPROPSTG(pstgTemp);
}


//===================================================================
//
//  Function:   test_CopyTo
//
//  Synopsis:   Verify that IStorage::CopyTo copies an
//              un-flushed property set.
//
//              This test creates and writes to a simple property set,
//              a non-simple property set, and a new Storage & Stream,
//              all within the source (caller-provided) Storage.
//
//              It then copies the entire source Storage to the
//              destination Storage, and verifies that all commited
//              data in the Source is also in the destination.
//  
//              All new Storages and property sets are created
//              under a new base storage.  The caller can specify
//              if this base Storage is direct or transacted, and
//              can specify if the property sets are direct or
//              transacted.
//
//===================================================================

void test_CopyTo(IStorage *pstgSource,          // Source of the CopyTo
                 IStorage *pstgDestination,     // Destination of the CopyTo
                 ULONG ulBaseStgTransaction,    // Transaction bit for the base storage.
                 ULONG ulPropSetTransaction,    // Transaction bit for the property sets.
                 LPOLESTR oszBaseStorageName )
{
    printf( "   IStorage::CopyTo (Base Storage is %s, PropSets are %s)\n",
            ulBaseStgTransaction & STGM_TRANSACTED ? "transacted" : "directed",
            ulPropSetTransaction & STGM_TRANSACTED ? "transacted" : "directed" );


    //  ---------------
    //  Local Variables
    //  ---------------
    
    DECLARE_OLESTR(poszTestSubStorage     ,"TestStorage" );
    DECLARE_OLESTR(poszTestSubStream      ,"TestStream" );
    DECLARE_OLESTR(poszTestDataPreCommit  ,"Test Data (pre-commit)" );
    DECLARE_OLESTR(poszTestDataPostCommit ,"Test Data (post-commit)");
    
    long lSimplePreCommit = 0x0123;
    long lSimplePostCommit = 0x4567;

    long lNonSimplePreCommit  = 0x89AB;
    long lNonSimplePostCommit = 0xCDEF;

    BYTE acReadBuffer[ 80 ];
    ULONG cbRead;

    FMTID fmtidSimple, fmtidNonSimple;

    // Base Storages for the Source & Destination.  All
    // new Streams/Storages/PropSets will be created below here.

    TSafeStorage< IStorage > pstgBaseSource;
    TSafeStorage< IStorage > pstgBaseDestination;

    TSafeStorage< IStorage > pstgSub;   // A sub-storage of the base.
    TSafeStorage< IStream >  pstmSub;   // A Stream in the sub-storage (pstgSub)

    PROPSPEC propspec;
    PROPVARIANT propvarSourceSimple,
                propvarDestination;


    //  -----
    //  Begin
    //  -----

    // Create new format IDs

    UuidCreate(&fmtidSimple);
    UuidCreate(&fmtidNonSimple);

    //  -----------------------
    //  Create the base Storage
    //  -----------------------

    // Create a base Storage for the Source.  All of this test will be under
    // that Storage.

    // In the source Storage.

    Check( S_OK, pstgSource->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | ulBaseStgTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseSource ));


    // And in the destination Storage.

    Check( S_OK, pstgDestination->CreateStorage(
                                oszBaseStorageName,
                                STGM_CREATE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgBaseDestination ));



    //  -------------------------------------------
    //  Write data to a new Stream in a new Storage
    //  -------------------------------------------

    // We'll partially verify the CopyTo by checking that this data
    // makes it into the destination Storage.


    // Create a Storage, and then a Stream within it.

    Check( S_OK, pstgBaseSource->CreateStorage(
                                poszTestSubStorage,
                                STGM_CREATE | ulPropSetTransaction | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                0L, 0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->CreateStream(
                            poszTestSubStream,
                            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L, 0L,
                            &pstmSub ));

    // Write data to the Stream.

    Check( S_OK, pstmSub->Write(
                    poszTestDataPreCommit,
                    ( sizeof(OLECHAR)
                      *
                      ( ocslen(poszTestDataPreCommit) + sizeof( OLECHAR ))
                    ),
                    NULL ));


    //  ---------------------------------------------------------
    //  Write to a new simple property set in the Source storage.
    //  ---------------------------------------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStgSource(pstgBaseSource);
    TSafeStorage< IPropertyStorage >    pPropStgSource1,
                                        pPropStgSource2,
                                        pPropStgDestination;

    // Create a property set mode.

    Check(S_OK, pPropSetStgSource->Create(fmtidSimple,
            NULL,
            PROPSETFLAG_DEFAULT,
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgSource1));

    // Write the property set name (just to test this functionality).

    PROPID pidDictionary = 0;
    DECLARE_CONST_OLESTR(cposzPropSetName, "Property Set for CopyTo Test");
    ASSERT( CWC_MAXPROPNAMESZ >= ocslen(cposzPropSetName) + sizeof(OLECHAR) );
    
    Check(S_OK, pPropStgSource1->WritePropertyNames( 1, &pidDictionary,
                                                     &cposzPropSetName )); 

    // Create a PROPSPEC.  We'll use this throughout the rest of the routine.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = 1000;

    // Create a PROPVARIANT for this test of the Simple case.

    propvarSourceSimple.vt = VT_I4;
    propvarSourceSimple.lVal = lSimplePreCommit;

    // Write the PROPVARIANT to the property set.

    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));



    //  -------------------------
    //  Commit everything so far.
    //  -------------------------

    // Commit the sub-Storage.
    Check(S_OK, pstgSub->Commit( STGC_DEFAULT ));

    // Commit the simple property set.
    Check(S_OK, pPropStgSource1->Commit( STGC_DEFAULT ));

    // Commit the base Storage which holds all of the above.
    Check(S_OK, pstgBaseSource->Commit( STGC_DEFAULT ));


    //  -------------------------------------------------
    //  Write new data to everything but don't commit it.
    //  -------------------------------------------------

    // Write to the sub-storage.
    Check(S_OK, pstmSub->Seek(g_li0, STREAM_SEEK_SET, NULL));
    Check( S_OK, pstmSub->Write(
                    poszTestDataPostCommit,
                    ( sizeof(OLECHAR)
                      *
                      (ocslen( poszTestDataPostCommit ) + sizeof(OLECHAR))
                    ),
                    NULL ));

    // Write to the simple property set.
    propvarSourceSimple.lVal = lSimplePostCommit;
    Check(S_OK, pPropStgSource1->WriteMultiple(1, &propspec, &propvarSourceSimple, 2));

    //  -------------------------------------------
    //  Copy the source Storage to the destination.
    //  -------------------------------------------

    // Release the sub-Storage (which is below the base Storage, and has
    // a Stream with data in it), just to test that the CopyTo can
    // handle it.

    pstgSub->Release();
    pstgSub = NULL;

    Check(S_OK, pstgBaseSource->CopyTo( 0, NULL, NULL, pstgBaseDestination ));


    //  ----------------------------------------------------------
    //  Verify the simple property set in the destination Storage.
    //  ----------------------------------------------------------


    TSafeStorage< IPropertySetStorage > pPropSetStgDestination(pstgBaseDestination);

    // Open the simple property set.

    Check(S_OK, pPropSetStgDestination->Open(fmtidSimple,
            STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
            &pPropStgDestination));

    // Verify the property set name.

    OLECHAR *poszPropSetNameDestination;
    BOOL   bReadPropertyNamePassed = FALSE;

    Check(S_OK, pPropStgDestination->
          ReadPropertyNames( 1, &pidDictionary, &poszPropSetNameDestination ));
    if( poszPropSetNameDestination  // Did we get a name back?
        &&                          // If so, was it the correct name?
        !ocscmp( cposzPropSetName, poszPropSetNameDestination )
      )
    {
        bReadPropertyNamePassed = TRUE;
    }
    CoTaskMemFree( poszPropSetNameDestination );
    poszPropSetNameDestination = NULL;

    Check( TRUE, bReadPropertyNamePassed );

    // Read the PROPVARIANT that we wrote earlier.

    Check(S_OK, pPropStgDestination->ReadMultiple(1, &propspec, &propvarDestination));

    // Verify that it's correct.

    Check(TRUE, propvarDestination.vt   == propvarSourceSimple.vt );
    Check(TRUE, propvarDestination.lVal == lSimplePostCommit);

    Check(S_OK, pPropStgDestination->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStgDestination->Release());
    pPropStgDestination = NULL;


    //  ------------------------------------------------
    //  Verify the test data in the destination Storage.
    //  ------------------------------------------------

    // Now we can release and re-use the Stream pointer that
    // currently points to the sub-Stream in the source docfile.

    Check(STG_E_REVERTED, pstmSub->Commit( STGC_DEFAULT ));
    Check(S_OK, pstmSub->Release());
    pstmSub = NULL;

    // Get the Storage then the Stream.

    Check( S_OK, pstgBaseDestination->OpenStorage(
                                poszTestSubStorage,
                                NULL,
                                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
                                NULL,
                                0L,
                                &pstgSub ));

    Check( S_OK, pstgSub->OpenStream(
                            poszTestSubStream,
                            NULL,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            0L,
                            &pstmSub ));

    // Read the data and compare it against what we wrote.

    Check( S_OK, pstmSub->Read(
                    acReadBuffer,
                    sizeof( acReadBuffer ),
                    &cbRead ));

    OLECHAR const *poszTestData =   ( STGM_TRANSACTED & ulPropSetTransaction )
                                  ?
                                  poszTestDataPreCommit
                                  :
                                  poszTestDataPostCommit;

    Check( TRUE, cbRead == sizeof(OLECHAR)
                           *
                           (ocslen( poszTestData ) + sizeof(OLECHAR))
         );

    Check( FALSE, ocscmp( poszTestData, (OLECHAR *) acReadBuffer ));


    //  ----
    //  Exit
    //  ----

    // We're done.  Don't bother to release anything;
    // they'll release themselves in their destructors.

    return;

}   // test_CopyTo()



//--------------------------------------------------------
//
//  Function:   test_OLESpecTickerExample
//
//  Synopsis:   This function generates the ticker property set
//              example that's used in the OLE Programmer's Reference
//              (when describing property ID 0 - the dictionary).
//
//--------------------------------------------------------


#define PID_SYMBOL  0x7
#define PID_OPEN    0x3
#define PID_CLOSE   0x4
#define PID_HIGH    0x5
#define PID_LOW     0x6
#define PID_LAST    0x8
#define PID_VOLUME  0x9

void test_OLESpecTickerExample( IStorage* pstg )
{
    printf( "   Generate the Stock Ticker property set example from the OLE Programmer's Ref\n" );

    //  ------
    //  Locals
    //  ------

    FMTID fmtid;

    PROPSPEC propspec;

    DECLARE_CONST_OLESTR(coszPropSetName, "Stock Quote" );
    DECLARE_CONST_OLESTR(coszTickerSymbolName, "Ticker Symbol" );
    DECLARE_CONST_OLESTR(coszOpenName, "Opening Price" );
    DECLARE_CONST_OLESTR(coszCloseName, "Last Closing Price" );
    DECLARE_CONST_OLESTR(coszHighName, "High Price" );
    DECLARE_CONST_OLESTR(coszLowName, "Low Price" );
    DECLARE_CONST_OLESTR(coszLastName, "Last Price" );
    DECLARE_CONST_OLESTR(coszVolumeName, "Volume" );

    //  ---------------------------------
    //  Create a new simple property set.
    //  ---------------------------------

    TSafeStorage< IPropertySetStorage > pPropSetStg(pstg);
    IPropertyStorage *pPropStg;

    UuidCreate( &fmtid );

    Check(S_OK, pPropSetStg->Create(fmtid,
            NULL,
            PROPSETFLAG_DEFAULT,    // Unicode
            STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
            &pPropStg));


    //  ---------------------------------------------
    //  Fill in the simply property set's dictionary.
    //  ---------------------------------------------

    // Write the property set's name.

    PROPID pidDictionary = 0;
    Check(S_OK, pPropStg->WritePropertyNames(1, &pidDictionary, &coszPropSetName ));

    // Write the High price, forcing the dictionary to pad.

    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_HIGH;

    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszHighName ));


    // Write the ticker symbol.

    propspec.propid = PID_SYMBOL;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszTickerSymbolName));

    // Write the rest of the dictionary.

    propspec.propid = PID_LOW;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszLowName));

    propspec.propid = PID_OPEN;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszOpenName));
    
    propspec.propid = PID_CLOSE;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszCloseName));
    
    propspec.propid = PID_LAST;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszLastName));
    
    propspec.propid = PID_VOLUME;
    Check(S_OK, pPropStg->WritePropertyNames(1, &propspec.propid, &coszVolumeName));


    // Write out the ticker symbol.

    propspec.propid = PID_SYMBOL;

    PROPVARIANT propvar;
    propvar.vt = VT_LPWSTR;
    DECLARE_WIDESTR(wszMSFT, "MSFT");
    propvar.pwszVal = wszMSFT;

    Check(S_OK, pPropStg->WriteMultiple(1, &propspec, &propvar, 2));


    //  ----
    //  Exit
    //  ----

    Check(S_OK, pPropStg->Commit( STGC_DEFAULT ));
    Check(S_OK, pPropStg->Release());
    Check(S_OK, pstg->Commit( STGC_DEFAULT ));

    return;


}  // test_OLESpecTickerExample()


void
test_Office( LPOLESTR wszTestFile )
{

    printf( "   Generate Office Property Sets\n" );

    TSafeStorage<IStorage> pStg;
    TSafeStorage<IPropertyStorage> pPStgSumInfo, pPStgDocSumInfo, pPStgUserDefined;

    PROPVARIANT propvarWrite, propvarRead;
    PROPSPEC    propspec;

    PropVariantInit( &propvarWrite );
    PropVariantInit( &propvarRead );

    // Create the DocFile

    Check(S_OK, StgCreateDocfile(  wszTestFile,
                                   STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                   0,
                                   &pStg));

    // Create the SummaryInformation property set.

    TSafeStorage<IPropertySetStorage> pPSStg( pStg );
    Check(S_OK, pPSStg->Create( FMTID_SummaryInformation,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgSumInfo ));

    // Write a Title to the SumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "Title from PropTest";
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_TITLE;

    Check( S_OK, pPStgSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    PropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgSumInfo->Release();
    pPStgSumInfo = NULL;


    // Create the DocumentSummaryInformation property set.

    Check(S_OK, pPSStg->Create( FMTID_DocSummaryInformation,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgDocSumInfo ));

    // Write a word-count to the DocSumInfo property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_I4;
    propvarWrite.lVal = 100;
    propspec.ulKind = PRSPEC_PROPID;
    propspec.propid = PID_WORDCOUNT;

    Check( S_OK, pPStgDocSumInfo->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgDocSumInfo->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( TRUE, propvarWrite.lVal == propvarRead.lVal );

    PropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgDocSumInfo->Release();
    pPStgDocSumInfo = NULL;


    // Create the UserDefined property set.

    Check(S_OK, pPSStg->Create( FMTID_UserDefinedProperties,
                                NULL,
                                PROPSETFLAG_ANSI,
                                STGM_CREATE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                                &pPStgUserDefined ));

    // Write named string to the UserDefined property set.

    PropVariantInit( &propvarWrite );
    propvarWrite.vt = VT_LPSTR;
    propvarWrite.pszVal = "User-Defined string from PropTest";
    propspec.ulKind = PRSPEC_LPWSTR;
    DECLARE_OLESTR(ocsTest, "PropTest String");
    propspec.lpwstr = ocsTest;

    Check( S_OK, pPStgUserDefined->WriteMultiple( 1, &propspec, &propvarWrite, PID_FIRST_USABLE ));
    Check( S_OK, pPStgUserDefined->ReadMultiple( 1, &propspec, &propvarRead ));

    Check( TRUE, propvarWrite.vt == propvarRead.vt );
    Check( FALSE, strcmp( propvarWrite.pszVal, propvarRead.pszVal ));

    PropVariantClear( &propvarRead );
    PropVariantInit( &propvarRead );
    pPStgUserDefined->Release();
    pPStgUserDefined = NULL;


    // And we're done!  (Everything releases automatically)

    return;

}


inline BOOL operator == ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime == ft2.dwHighDateTime
            &&
            ft1.dwLowDateTime  == ft2.dwLowDateTime );
}

inline BOOL operator != ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime != ft2.dwHighDateTime
            ||
            ft1.dwLowDateTime  != ft2.dwLowDateTime );
}


inline BOOL operator > ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime >  ft2.dwHighDateTime
            ||
            ft1.dwHighDateTime == ft2.dwHighDateTime
            &&
            ft1.dwLowDateTime  > ft2.dwLowDateTime );
}

inline BOOL operator < ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1.dwHighDateTime <  ft2.dwHighDateTime
            ||
            ft1.dwHighDateTime == ft2.dwHighDateTime
            &&
            ft1.dwLowDateTime  <  ft2.dwLowDateTime );
}

inline BOOL operator >= ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1 > ft2
            ||
            ft1 == ft2 );
}

inline BOOL operator <= ( FILETIME &ft1, FILETIME &ft2 )
{
    return( ft1 < ft2
            ||
            ft1 == ft2 );
}



FILETIME operator - ( FILETIME &ft1, FILETIME &ft2 )
{
    FILETIME ftDiff;

    if( ft1 < ft2 )
    {
        ftDiff.dwLowDateTime  = 0;
        ftDiff.dwHighDateTime = 0;
    }

    else if( ft1.dwLowDateTime >= ft2.dwLowDateTime )
    {
        ftDiff.dwLowDateTime  = ft1.dwLowDateTime  - ft2.dwLowDateTime;
        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime;
    }
    else
    {
        ftDiff.dwLowDateTime = ft1.dwLowDateTime - ft2.dwLowDateTime;
        ftDiff.dwLowDateTime = (DWORD) -1 - ftDiff.dwLowDateTime;

        ftDiff.dwHighDateTime = ft1.dwHighDateTime - ft2.dwHighDateTime - 1;
    }

    return( ftDiff );
}




void test_PropVariantCopy( )
{
    printf( "   PropVariantCopy\n" );

    PROPVARIANT propvarCopy;
    PropVariantInit( &propvarCopy );

    for( int i = 0; i < CPROPERTIES_ALL; i++ )
    {
        Check(S_OK, PropVariantCopy( &propvarCopy, &g_rgcpropvarAll[i] ));
        Check(S_OK, CPropVariant::Compare( &propvarCopy, &g_rgcpropvarAll[i]
            ));
        PropVariantClear( &propvarCopy );
    }

}

char* oszft(FILETIME *pft)
{
    static char szBuf[32];
    szBuf[0] = '\0';
    sprintf(szBuf, "(H)%x (L)%x", pft->dwLowDateTime, 
            pft->dwHighDateTime);
    return szBuf;
}

void PrintOC(char *ocsStr)
{
    // simple subsitute to print both WIDE and BYTE chars
    for (  ;*ocsStr; ocsStr++)
        printf("%c", (char) *(ocsStr));
}

void PrintOC(WCHAR *ocsStr)
{
    // simple subsitute to print both WIDE and BYTE chars
    for (  ;*ocsStr; ocsStr++)
        if ( (int) *ocsStr < (int) 0xff)        // in range
            printf("%c", (char) *(ocsStr));
        else
            printf("[%d]", *ocsStr);
}

void DumpTime(WCHAR *pszName, FILETIME *pft)
{
    PrintOC(pszName);
    printf("(H)%x (L)%x\n", 
           pft->dwHighDateTime,
           pft->dwLowDateTime);
}

void DumpTime(char *pszName, FILETIME *pft)
{
    printf("%s (H)%x (L)%x\n", 
           pszName,
           pft->dwHighDateTime,
           pft->dwLowDateTime);
}

VOID
PrintGuid(GUID *pguid)
{
    printf(
        "%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        pguid->Data1,
        pguid->Data2,
        pguid->Data3,
        pguid->Data4[0],
        pguid->Data4[1],
        pguid->Data4[2],
        pguid->Data4[3],
        pguid->Data4[4],
        pguid->Data4[5],
        pguid->Data4[6],
        pguid->Data4[7]);
}


VOID
ListPropSetHeader(
    STATPROPSETSTG *pspss,
    OLECHAR *poszName)
{
    BOOLEAN fDocumentSummarySection2;
    OLECHAR oszStream[80];      // should be enough

    fDocumentSummarySection2 = (BOOLEAN)
	memcmp(&pspss->fmtid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0;

    printf(" Property set ");
    PrintGuid(&pspss->fmtid);

    RtlGuidToPropertySetName(&pspss->fmtid, oszStream);

    printf("\n  %s Name ",
           (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)?
	    "Embedding" : "Stream");
    PrintOC(oszStream);
    if (poszName != NULL || fDocumentSummarySection2)
    {
        printf(" (");
        if (poszName != NULL)
            PrintOC(poszName);
        else
            printf("User defined properties");
        printf(")");
    }
    printf("\n");

    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime("  Create Time ", &pspss->ctime);
    }
    DumpTime("  Modify Time ", &pspss->mtime);
    if (pspss->grfFlags & PROPSETFLAG_NONSIMPLE)
    {
	DumpTime("  Access Time ", &pspss->atime);
    }
}




typedef enum _PUBLICPROPSET
{
    PUBPS_UNKNOWN = 0,
    PUBPS_SUMMARYINFO = 3,
    PUBPS_DOCSUMMARYINFO = 4,
    PUBPS_USERDEFINED = 5,
} PUBLICPROPSET;


#define BSTRLEN(bstrVal)      *((ULONG *) bstrVal - 1)
ULONG
SizeProp(PROPVARIANT *pv)
{
    ULONG j;
    ULONG cbprop = 0;

    switch (pv->vt)
    {
    default:
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_UI1:
        cbprop = sizeof(pv->bVal);
        break;

    case VT_I2:
    case VT_UI2:
    case VT_BOOL:
        cbprop = sizeof(pv->iVal);
        break;

    case VT_I4:
    case VT_UI4:
    case VT_R4:
    case VT_ERROR:
        cbprop = sizeof(pv->lVal);
        break;

    case VT_I8:
    case VT_UI8:
    case VT_R8:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
        cbprop = sizeof(pv->hVal);
        break;

    case VT_CLSID:
        cbprop = sizeof(*pv->puuid);
        break;

    case VT_BLOB_OBJECT:
    case VT_BLOB:
        cbprop = pv->blob.cbSize + sizeof(pv->blob.cbSize);
        break;

    case VT_CF:
        cbprop = sizeof(pv->pclipdata->cbSize) +
                 pv->pclipdata->cbSize;
        break;

    case VT_BSTR:
	// count + string
	cbprop = sizeof(ULONG);
	if (pv->bstrVal != NULL)
	{
	    cbprop += BSTRLEN(pv->bstrVal);
	}
	break;

    case VT_LPSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pszVal != NULL)
	{
	    cbprop += strlen(pv->pszVal) + 1;
	}
	break;

    case VT_STREAM:
    case VT_STREAMED_OBJECT:
    case VT_STORAGE:
    case VT_STORED_OBJECT:
    case VT_LPWSTR:
	// count + string + null char
	cbprop = sizeof(ULONG);
	if (pv->pwszVal != NULL)
	{
	    cbprop += sizeof(pv->pwszVal[0]) * (wcslen(pv->pwszVal) + 1);
	}
	break;

    //  vectors
    case VT_VECTOR | VT_UI1:
        cbprop = sizeof(pv->caub.cElems) +
             pv->caub.cElems * sizeof(pv->caub.pElems[0]);
        break;

    case VT_VECTOR | VT_I2:
    case VT_VECTOR | VT_UI2:
    case VT_VECTOR | VT_BOOL:
        cbprop = sizeof(pv->cai.cElems) +
             pv->cai.cElems * sizeof(pv->cai.pElems[0]);
        break;

    case VT_VECTOR | VT_I4:
    case VT_VECTOR | VT_UI4:
    case VT_VECTOR | VT_R4:
    case VT_VECTOR | VT_ERROR:
        cbprop = sizeof(pv->cal.cElems) +
             pv->cal.cElems * sizeof(pv->cal.pElems[0]);
        break;

    case VT_VECTOR | VT_I8:
    case VT_VECTOR | VT_UI8:
    case VT_VECTOR | VT_R8:
    case VT_VECTOR | VT_CY:
    case VT_VECTOR | VT_DATE:
    case VT_VECTOR | VT_FILETIME:
        cbprop = sizeof(pv->cah.cElems) +
             pv->cah.cElems * sizeof(pv->cah.pElems[0]);
        break;

    case VT_VECTOR | VT_CLSID:
        cbprop = sizeof(pv->cauuid.cElems) +
             pv->cauuid.cElems * sizeof(pv->cauuid.pElems[0]);
        break;

    case VT_VECTOR | VT_CF:
        cbprop = sizeof(pv->caclipdata.cElems);
        for (j = 0; j < pv->caclipdata.cElems; j++)
        {
            cbprop += sizeof(pv->caclipdata.pElems[j].cbSize) +
                      DwordAlign(pv->caclipdata.pElems[j].cbSize);
        }
        break;

    case VT_VECTOR | VT_BSTR:
	cbprop = sizeof(pv->cabstr.cElems);
	for (j = 0; j < pv->cabstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->cabstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(BSTRLEN(pv->cabstr.pElems[j]));
	    }
	}
	break;

    case VT_VECTOR | VT_LPSTR:
	cbprop = sizeof(pv->calpstr.cElems);
	for (j = 0; j < pv->calpstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(strlen(pv->calpstr.pElems[j]) + 1);
	    }
	}
	break;

    case VT_VECTOR | VT_LPWSTR:
	cbprop = sizeof(pv->calpwstr.cElems);
	for (j = 0; j < pv->calpwstr.cElems; j++)
	{
	    // count + string + null char
	    cbprop += sizeof(ULONG);
	    if (pv->calpwstr.pElems[j] != NULL)
	    {
		cbprop += DwordAlign(
			sizeof(pv->calpwstr.pElems[j][0]) *
			(wcslen(pv->calpwstr.pElems[j]) + 1));
	    }
	}
	break;

    case VT_VECTOR | VT_VARIANT:
        cbprop = sizeof(pv->calpwstr.cElems);
        for (j = 0; j < pv->calpwstr.cElems; j++)
        {
            cbprop += SizeProp(&pv->capropvar.pElems[j]);
        }
        break;
    }
    return(DwordAlign(cbprop) + DwordAlign(sizeof(pv->vt)));
}


PUBLICPROPSET
GuidToPropSet(GUID *pguid)
{
    PUBLICPROPSET pubps = PUBPS_UNKNOWN;
	
    if (pguid != NULL)
    {
	if (memcmp(pguid, &FMTID_SummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_SUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_DocSummaryInformation, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_DOCSUMMARYINFO;
	}
	else if (memcmp(pguid, &FMTID_UserDefinedProperties, sizeof(GUID)) == 0)
	{
	    pubps = PUBPS_USERDEFINED;
	}
    }
    return(pubps);
}


char
PrintableChar(char ch)
{
    if (ch < ' ' || ch > '~')
    {
        ch = '.';
    }
    return(ch);
}


VOID
DumpHex(BYTE *pb, ULONG cb, ULONG base)
{
    char *pszsep;
    ULONG r, i, cbremain;
    int fZero = FALSE;
    int fSame = FALSE;

    for (r = 0; r < cb; r += 16)
    {
        cbremain = cb - r;
        if (r != 0 && cbremain >= 16)
        {
            if (pb[r] == 0)
            {
                ULONG j;

                for (j = r + 1; j < cb; j++)
                {
                    if (pb[j] != 0)
                    {
                        break;
                    }
                }
                if (j == cb)
                {
                    fZero = TRUE;
                    break;
                }
            }
            if (memcmp(&pb[r], &pb[r - 16], 16) == 0)
            {
                fSame = TRUE;
                continue;
            }
        }
        if (fSame)
        {
            printf("\n\t  *");
            fSame = FALSE;
        }
        unsigned int iLimit =  (cbremain > 16) ? 16 : cbremain;
        for (i = 0; i < iLimit; i++)
        {
            pszsep = " ";
            if ((i % 8) == 0)           // 0 or 8
            {
                pszsep = "  ";
                if (i == 0)             // 0
                {
		    // start a new line
		    printf("%s    %04x:", r == 0? "" : "\n", r + base);
		    pszsep = " ";
                }
            }
            printf("%s%02x", pszsep, pb[r + i]);
        }
        if (i != 0)
        {
            printf("%*s", 3 + (16 - i)*3 + ((i <= 8)? 1 : 0), "");
            for (i = 0; i < iLimit; i++)
            {
                printf("%c", PrintableChar(pb[r + i]));
            }
        }
    }
    if (r != 0)
    {
        printf("\n");
    }
    if (fZero)
    {
        printf("    Remaining %lx bytes are zero\n", cbremain);
    }
}


// Property Id's for Summary Info
#define PID_TITLE		0x00000002L	// VT_LPSTR
#define PID_SUBJECT		0x00000003L	// VT_LPSTR
#define PID_AUTHOR		0x00000004L	// VT_LPSTR
#define PID_KEYWORDS		0x00000005L	// VT_LPSTR
#define PID_COMMENTS		0x00000006L	// VT_LPSTR
#define PID_TEMPLATE		0x00000007L	// VT_LPSTR
#define PID_LASTAUTHOR		0x00000008L	// VT_LPSTR
#define PID_REVNUMBER		0x00000009L	// VT_LPSTR
#define PID_EDITTIME		0x0000000aL	// VT_FILETIME
#define PID_LASTPRINTED		0x0000000bL	// VT_FILETIME
#define PID_CREATE_DTM		0x0000000cL	// VT_FILETIME
#define PID_LASTSAVE_DTM	0x0000000dL	// VT_FILETIME
#define PID_PAGECOUNT		0x0000000eL	// VT_I4
#define PID_WORDCOUNT		0x0000000fL	// VT_I4
#define PID_CHARCOUNT		0x00000010L	// VT_I4
#define PID_THUMBNAIL		0x00000011L	// VT_CF
#define PID_APPNAME		0x00000012L	// VT_LPSTR
#define PID_SECURITY_DSI	0x00000013L	// VT_I4

// Property Id's for Document Summary Info
#define PID_CATEGORY		0x00000002L	// VT_LPSTR
#define PID_PRESFORMAT		0x00000003L	// VT_LPSTR
#define PID_BYTECOUNT		0x00000004L	// VT_I4
#define PID_LINECOUNT		0x00000005L	// VT_I4
#define PID_PARACOUNT		0x00000006L	// VT_I4
#define PID_SLIDECOUNT		0x00000007L	// VT_I4
#define PID_NOTECOUNT		0x00000008L	// VT_I4
#define PID_HIDDENCOUNT		0x00000009L	// VT_I4
#define PID_MMCLIPCOUNT		0x0000000aL	// VT_I4
#define PID_SCALE		0x0000000bL	// VT_BOOL
#define PID_HEADINGPAIR		0x0000000cL	// VT_VECTOR | VT_VARIANT
#define PID_DOCPARTS		0x0000000dL	// VT_VECTOR | VT_LPSTR
#define PID_MANAGER		0x0000000eL	// VT_LPSTR
#define PID_COMPANY		0x0000000fL	// VT_LPSTR
#define PID_LINKSDIRTY		0x00000010L	// VT_BOOL
#define PID_CCHWITHSPACES	0x00000011L	// VT_I4
#define PID_GUID		0x00000012L	// VT_LPSTR
#define PID_SHAREDDOC		0x00000013L	// VT_BOOL
#define PID_LINKBASE		0x00000014L	// VT_LPSTR
#define PID_HLINKS		0x00000015L	// VT_VECTOR | VT_VARIANT
#define PID_HYPERLINKSCHANGED	0x00000016L	// VT_BOOL

VOID
DisplayProps(
    GUID *pguid,
    ULONG cprop,
    PROPID apid[],
    STATPROPSTG asps[],
    FULLPROPSPEC afps[],
    PROPVARIANT *av,
    BOOLEAN fsumcat,
    ULONG *pcbprop)
{
    PROPVARIANT *pv;
    PROPVARIANT *pvend;
    STATPROPSTG *psps;
    FULLPROPSPEC *pfps, *pfpsLast = NULL;
    BOOLEAN fVariantVector;
    PUBLICPROPSET pubps;
    DECLARE_OLESTR(ocsNull,"");

    ASSERT(asps == NULL || afps == NULL);
    fVariantVector = (asps == NULL && afps == NULL);

    pubps = GuidToPropSet(pguid);
    pvend = &av[cprop];
    for (pv = av, psps = asps, pfps = afps; pv < pvend; pv++, psps++, pfps++)
    {
        ULONG j;
        ULONG cbprop;
        PROPID propid;
        OLECHAR *postrName;
        char *psz;
        BOOLEAN fNewLine = TRUE;
        int ccol;
        static char szNoFormat[] = " (no display format)";
        char achvt[19 + 8 + 1];

        cbprop = SizeProp(pv);
        *pcbprop += cbprop;

        postrName = NULL;
        if (asps != NULL)
        {
            propid = psps->propid;
            postrName = psps->lpwstrName;
        }
        else if (afps != NULL)          // If multiple propsets are possible
        {
            if (pfpsLast == NULL ||     // print unique GUIDs only
                memcmp(
                    &pfps->guidPropSet,
                    &pfpsLast->guidPropSet,
                    sizeof(pfps->guidPropSet)) != 0)
            {
                OLECHAR oszStream[80];

		printf("%s Guid: ", pfpsLast == NULL? "" : "\n");
		PrintGuid(&pfps->guidPropSet);

		pubps = GuidToPropSet(&pfps->guidPropSet);
                RtlGuidToPropertySetName(&pfps->guidPropSet, oszStream);

                printf( " Name: " ); 
		PrintOC(oszStream);
                printf( "%s", pubps == PUBPS_USERDEFINED?
			g_szEmpty : " (User defined properties)");
                pfpsLast = pfps;
            }
            if (pfps->psProperty.ulKind == PRSPEC_PROPID)
            {
                propid = pfps->psProperty.propid;
            }
            else
            {
                propid = PID_ILLEGAL;
                postrName = pfps->psProperty.lpwstr;
            }
        }
        else
        {
            ASSERT(apid != NULL);
            propid = apid[0];
        }

        printf(" ");
        ccol = 0;

        if (propid != PID_ILLEGAL)
        {
            printf(" %04x", propid);
            ccol += 5;
            if (propid & (0xf << 28))
            {
                ccol += 4;
            }
            else if (propid & (0xf << 24))
            {
                ccol += 3;
            }
            else if (propid & (0xf << 20))
            {
                ccol += 2;
            }
            else if (propid & (0xf << 16))
            {
                ccol++;
            }
        }
        if (postrName != NULL)
        {
            printf(" '");
	    PrintOC(postrName);
            printf("' ");
	    ccol += ocslen(postrName) + 3;
        }
        else if (fVariantVector)
        {
            ULONG i = pv - av;
                
            printf("[%x]", i);
            do
            {
                ccol++;
                i >>= 4;
            } while (i != 0);
            ccol += 2;
        }
        else
        {
            psz = NULL;

            switch (propid)
            {
                case PID_LOCALE:               psz = "Locale";           break;
                case PID_SECURITY:             psz = "SecurityId";       break;
                case PID_MODIFY_TIME:          psz = "ModifyTime";       break;
                case PID_CODEPAGE:             psz = "CodePage";         break;
                case PID_DICTIONARY:           psz = "Dictionary";       break;
            }
            if (psz == NULL)
		switch (pubps)
		{
		case PUBPS_SUMMARYINFO:
		    switch (propid)
		    {
		    case PID_TITLE:              psz = "Title";          break;
		    case PID_SUBJECT:            psz = "Subject";        break;
		    case PID_AUTHOR:             psz = "Author";         break;
		    case PID_KEYWORDS:           psz = "Keywords";       break;
		    case PID_COMMENTS:           psz = "Comments";       break;
		    case PID_TEMPLATE:           psz = "Template";       break;
		    case PID_LASTAUTHOR:         psz = "LastAuthor";     break;
		    case PID_REVNUMBER:          psz = "RevNumber";      break;
		    case PID_EDITTIME:           psz = "EditTime";       break;
		    case PID_LASTPRINTED:        psz = "LastPrinted";    break;
		    case PID_CREATE_DTM:         psz = "CreateDateTime"; break;
		    case PID_LASTSAVE_DTM:       psz = "LastSaveDateTime";break;
		    case PID_PAGECOUNT:          psz = "PageCount";      break;
		    case PID_WORDCOUNT:          psz = "WordCount";      break;
		    case PID_CHARCOUNT:          psz = "CharCount";      break;
		    case PID_THUMBNAIL:          psz = "ThumbNail";      break;
		    case PID_APPNAME:            psz = "AppName";        break;
		    case PID_DOC_SECURITY:       psz = "Security";       break;

		    }
		    break;

		case PUBPS_DOCSUMMARYINFO:
		    switch (propid)
		    {
		    case PID_CATEGORY:          psz = "Category";        break;
		    case PID_PRESFORMAT:        psz = "PresFormat";      break;
		    case PID_BYTECOUNT:         psz = "ByteCount";       break;
		    case PID_LINECOUNT:         psz = "LineCount";       break;
		    case PID_PARACOUNT:         psz = "ParaCount";       break;
		    case PID_SLIDECOUNT:        psz = "SlideCount";      break;
		    case PID_NOTECOUNT:         psz = "NoteCount";       break;
		    case PID_HIDDENCOUNT:       psz = "HiddenCount";     break;
		    case PID_MMCLIPCOUNT:       psz = "MmClipCount";     break;
		    case PID_SCALE:             psz = "Scale";           break;
		    case PID_HEADINGPAIR:       psz = "HeadingPair";     break;
		    case PID_DOCPARTS:          psz = "DocParts";        break;
		    case PID_MANAGER:           psz = "Manager";         break;
		    case PID_COMPANY:           psz = "Company";         break;
		    case PID_LINKSDIRTY:        psz = "LinksDirty";      break;
		    case PID_CCHWITHSPACES:     psz = "CchWithSpaces";   break;
		    case PID_GUID:              psz = "Guid";            break;
		    case PID_SHAREDDOC:         psz = "SharedDoc";       break;
		    case PID_LINKBASE:          psz = "LinkBase";        break;
		    case PID_HLINKS:            psz = "HLinks";          break;
		    case PID_HYPERLINKSCHANGED:	psz = "HyperLinksChanged";break;
		    }
		    break;
            }
            if (psz != NULL)
            {
                printf(" %s", psz);
                ccol += strlen(psz) + 1;
            }
        }
#define CCOLPROPID 20
        if (ccol != CCOLPROPID)
	{
	    if (ccol > CCOLPROPID)
	    {
		ccol = -1;
	    }
            printf("%s%*s", ccol == -1? "\n" : "", CCOLPROPID - ccol, "");
	}
        printf(" %08x  %04x  %04x ", propid, cbprop, pv->vt);

        psz = "";
        switch (pv->vt)
        {
        default:
            psz = achvt;
            sprintf(psz, "Unknown (vt = %hx)", pv->vt);
            break;

        case VT_EMPTY:
            printf("EMPTY");
            break;

        case VT_NULL:
            printf("NULL");
            break;

        case VT_UI1:
            printf("UI1 = %02lx", pv->bVal);
            psz = "";
            break;

        case VT_I2:
            psz = "I2";
            goto doshort;

        case VT_UI2:
            psz = "UI2";
            goto doshort;

        case VT_BOOL:
            psz = "BOOL";
doshort:
            printf("%s = %04hx", psz, pv->iVal);
            psz = g_szEmpty;
            break;

        case VT_I4:
            psz = "I4";
            goto dolong;

        case VT_UI4:
            psz = "UI4";
            goto dolong;

        case VT_R4:
            psz = "R4";
            goto dolong;

        case VT_ERROR:
            psz = "ERROR";
dolong:
            printf("%s = %08lx", psz, pv->lVal);
            psz = g_szEmpty;
            break;

        case VT_I8:
            psz = "I8";
            goto dotwodword;

        case VT_UI8:
            psz = "UI8";
dotwodword:
            printf( "%s = %08lx:%08lx",
                   psz,
                   pv->hVal.HighPart,
                   pv->hVal.LowPart );
            psz = g_szEmpty;
            break;

        case VT_R8:
            psz = "R8";
            goto dolonglong;

        case VT_CY:
            psz = "R8";
            goto dolonglong;

        case VT_DATE:
            psz = "R8";
dolonglong:
            printf(
                "%s = %08lx:%08lx",
                psz,
                (pv->cyVal).split.Hi,
                (pv->cyVal).split.Lo);
            psz = g_szEmpty;
            break;

        case VT_FILETIME:
            DumpTime("FILETIME =\n\t  ", &pv->filetime);
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_CLSID:
            printf("CLSID =\n\t  ");
            PrintGuid(pv->puuid);
            break;

        case VT_BLOB:
            psz = "BLOB";
            goto doblob;

        case VT_BLOB_OBJECT:
            psz = "BLOB_OBJECT";
doblob:
            printf("%s (cbSize %x)", psz, pv->blob.cbSize);
            if (pv->blob.cbSize != 0)
            {
                printf(" =\n");
                DumpHex(pv->blob.pBlobData, pv->blob.cbSize, 0);
            }
            psz = g_szEmpty;
            break;

        case VT_CF:
            printf(
                "CF (cbSize %x, ulClipFmt %x)\n",
                pv->pclipdata->cbSize,
                pv->pclipdata->ulClipFmt);
            DumpHex(pv->pclipdata->pClipData,
                    pv->pclipdata->cbSize - sizeof(pv->pclipdata->ulClipFmt),
                    0);
            break;

        case VT_STREAM:
            psz = "STREAM";
            goto dostring;

        case VT_STREAMED_OBJECT:
            psz = "STREAMED_OBJECT";
            goto dostring;

        case VT_STORAGE:
            psz = "STORAGE";
            goto dostring;

        case VT_STORED_OBJECT:
            psz = "STORED_OBJECT";
            goto dostring;

        case VT_BSTR:
            printf(
		"BSTR (cb = %04lx)%s\n",
		pv->bstrVal == NULL? 0 : BSTRLEN(pv->bstrVal),
		pv->bstrVal == NULL? " NULL" : g_szEmpty);
            if (pv->bstrVal != NULL)
	    {
		DumpHex(
		    (BYTE *) pv->bstrVal,
		    BSTRLEN(pv->bstrVal) + sizeof(WCHAR),
		    0);
	    }
            break;

        case VT_LPSTR:
            psz = "LPSTR";
            printf(
		"%s = %s%s%s",
		psz,
		pv->pszVal == NULL? g_szEmpty : "'",
		pv->pszVal == NULL? "NULL" : pv->pszVal,
		pv->pszVal == NULL? g_szEmpty : "'");
	    psz = g_szEmpty;
            break;

        case VT_LPWSTR:
            psz = "LPWSTR";
dostring:
            printf(
		"%s = %s",
		psz,
		pv->pwszVal == NULL? g_szEmpty : "'");
            if ( pv->pwszVal == NULL)
                printf("NULL");
            else
                PrintOC(pv->pwszVal);
            printf("%s", pv->pwszVal == NULL? g_szEmpty : "'");
            psz = g_szEmpty;
            break;

        //  vectors

        case VT_VECTOR | VT_UI1:
            printf("UI1[%x] =", pv->caub.cElems);
            for (j = 0; j < pv->caub.cElems; j++)
            {
                if ((j % 16) == 0)
                {
                    printf("\n    %02hx:", j);
                }
                printf(" %02hx", pv->caub.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_I2:
            psz = "I2";
            goto doshortvector;

        case VT_VECTOR | VT_UI2:
            psz = "UI2";
            goto doshortvector;

        case VT_VECTOR | VT_BOOL:
            psz = "BOOL";
doshortvector:
            printf("%s[%x] =", psz, pv->cai.cElems);
            for (j = 0; j < pv->cai.cElems; j++)
            {
                if ((j % 8) == 0)
                {
                    printf("\n    %04hx:", j);
                }
                printf(" %04hx", pv->cai.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I4:
            psz = "I4";
            goto dolongvector;

        case VT_VECTOR | VT_UI4:
            psz = "UI4";
            goto dolongvector;

        case VT_VECTOR | VT_R4:
            psz = "R4";
            goto dolongvector;

        case VT_VECTOR | VT_ERROR:
            psz = "ERROR";
dolongvector:
            printf("%s[%x] =", psz, pv->cal.cElems);
            for (j = 0; j < pv->cal.cElems; j++)
            {
                if ((j % 4) == 0)
                {
                    printf("\n    %04x:", j);
                }
                printf(" %08lx", pv->cal.pElems[j]);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_I8:
            psz = "I8";
            goto dolonglongvector;

        case VT_VECTOR | VT_UI8:
            psz = "UI8";
            goto dolonglongvector;

        case VT_VECTOR | VT_R8:
            psz = "R8";
            goto dolonglongvector;

        case VT_VECTOR | VT_CY:
            psz = "CY";
            goto dolonglongvector;

        case VT_VECTOR | VT_DATE:
            psz = "DATE";
dolonglongvector:
            printf("%s[%x] =", psz, pv->cah.cElems);
            for (j = 0; j < pv->cah.cElems; j++)
            {
                if ((j % 2) == 0)
                {
                    printf("\n    %04x:", j);
                }
                printf(
                    " %08lx:%08lx",
                    pv->cah.pElems[j].HighPart,
                    pv->cah.pElems[j].LowPart);
            }
            psz = g_szEmpty;
            break;

        case VT_VECTOR | VT_FILETIME:
            printf("FILETIME[%x] =\n", pv->cafiletime.cElems);
            for (j = 0; j < pv->cafiletime.cElems; j++)
            {
		printf("    %04x: ", j);
		DumpTime(ocsNull, &pv->cafiletime.pElems[j]);
            }
            fNewLine = FALSE;           // skip newline printf
            break;

        case VT_VECTOR | VT_CLSID:
            printf("CLSID[%x] =", pv->cauuid.cElems);
            for (j = 0; j < pv->cauuid.cElems; j++)
            {
                printf("\n    %04x: ", j);
                PrintGuid(&pv->cauuid.pElems[j]);
            }
            break;

        case VT_VECTOR | VT_CF:
            printf("CF[%x] =", pv->caclipdata.cElems);
            for (j = 0; j < pv->caclipdata.cElems; j++)
            {
                printf("\n    %04x: (cbSize %x, ulClipFmt %x) =\n",
                    j,
                    pv->caclipdata.pElems[j].cbSize,
                    pv->caclipdata.pElems[j].ulClipFmt);
                DumpHex(
                    pv->caclipdata.pElems[j].pClipData,
                    pv->caclipdata.pElems[j].cbSize - sizeof(pv->caclipdata.pElems[j].ulClipFmt),
		    0);
            }
            break;

        case VT_VECTOR | VT_BSTR:
            printf("BSTR[%x] =", pv->cabstr.cElems);
            for (j = 0; j < pv->cabstr.cElems; j++)
            {
		BSTR bstr = pv->cabstr.pElems[j];

                printf(
		    "\n    %04x: cb = %04lx%s\n",
		    j,
		    bstr == NULL? 0 : BSTRLEN(pv->cabstr.pElems[j]),
		    bstr == NULL? " NULL" : g_szEmpty);
		if (bstr != NULL)
		{
		    DumpHex((BYTE *) bstr, BSTRLEN(bstr) + sizeof(WCHAR), 0);
		}
            }
            break;

        case VT_VECTOR | VT_LPSTR:
            printf("LPSTR[%x] =", pv->calpstr.cElems);
            for (j = 0; j < pv->calpstr.cElems; j++)
            {
		CHAR *psz = pv->calpstr.pElems[j];

                printf(
		    "\n    %04x: %s%s%s",
		    j,
		    psz == NULL? g_szEmpty : "'",
		    psz == NULL? "NULL" : psz,
		    psz == NULL? g_szEmpty : "'");
            }
            break;

        case VT_VECTOR | VT_LPWSTR:
            printf("LPWSTR[%x] =", pv->calpwstr.cElems);
            for (j = 0; j < pv->calpwstr.cElems; j++)
            {
		WCHAR *pwsz = pv->calpwstr.pElems[j];
                printf( "\n     %04x: %s",
                        j, pv->pwszVal == NULL? g_szEmpty : "'");
                if ( pwsz == NULL)
                    printf("NULL");
                else
                    PrintOC(pwsz);
                printf("%s", pwsz == NULL? g_szEmpty : "'");       
            }
            break;

        case VT_VECTOR | VT_VARIANT:
            printf("VARIANT[%x] =\n", pv->capropvar.cElems);
            DisplayProps(
		    pguid,
                    pv->capropvar.cElems,
                    &propid,
                    NULL,
                    NULL,
                    pv->capropvar.pElems,
		    fsumcat,
                    pcbprop);
            fNewLine = FALSE;           // skip newline printf
            break;
        }
        if (*psz != '\0')
        {
            printf("%s", psz);
            if (pv->vt & VT_VECTOR)
            {
                printf("[%x]", pv->cal.cElems);
            }
            printf("%s", szNoFormat);
        }
        if (!fVariantVector && apid != NULL && apid[pv - av] != propid)
        {
            printf(" (bad PROPID: %04x)", apid[pv - av]);
            fNewLine = TRUE;
        }
        if (asps != NULL && pv->vt != psps->vt)
        {
            printf(" (bad STATPROPSTG VARTYPE: %04x)", psps->vt);
            fNewLine = TRUE;
        }
        if (fNewLine)
        {
            printf("\n");
        }
    }
}

STATPROPSTG aspsStatic[] = {
    { NULL, PID_CODEPAGE,    VT_I2 },
    { NULL, PID_MODIFY_TIME, VT_FILETIME },
    { NULL, PID_SECURITY,    VT_UI4 },
};
#define CPROPSTATIC      (sizeof(aspsStatic)/sizeof(aspsStatic[0]))


#define CB_STREAM_OVERHEAD      28
#define CB_PROPSET_OVERHEAD     (CB_STREAM_OVERHEAD + 8)
#define CB_PROP_OVERHEAD        8

HRESULT
DumpOlePropertySet(
    IPropertySetStorage *ppsstg,
    STATPROPSETSTG *pspss,
    ULONG *pcprop,
    ULONG *pcbprop)
{
    HRESULT hr;
    IEnumSTATPROPSTG *penumsps = NULL;
    IPropertyStorage *pps;
    ULONG cprop, cbpropset;
    PROPID propid;
    OLECHAR *poszName;
    ULONG ispsStatic;

    *pcprop = *pcbprop = 0;
    hr = ppsstg->Open(
        pspss->fmtid,
        STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE,
        &pps);

    if (FAILED(hr))
        return (hr);

    propid = PID_DICTIONARY;
    
    hr = pps->ReadPropertyNames(1, &propid, &poszName);
    if( S_FALSE == hr )
        hr = S_OK;
    Check( S_OK, hr );

    ListPropSetHeader(pspss, poszName);
    if (poszName != NULL)
    {
	CoTaskMemFree(poszName);
    }

    cprop = cbpropset = 0;

    Check(S_OK, pps->Enum(&penumsps) );

    ispsStatic = 0;
    hr = S_OK;
    while (hr == S_OK)
    {
	STATPROPSTG sps;
	PROPSPEC propspec;
	PROPVARIANT propvar;
	ULONG count;

	hr = S_FALSE;
	if (ispsStatic == 0)
	{
	    hr = penumsps->Next(1, &sps, &count);
	}

	if (hr != S_OK)
	{
	    if (hr == S_FALSE)
	    {
		hr = S_OK;
		if (ispsStatic >= CPROPSTATIC)
		{
		    break;
		}
		sps = aspsStatic[ispsStatic];
		ispsStatic++;
		count = 1;
	    }
            Check( S_OK, hr );
	}
	PropVariantInit(&propvar);
	if (sps.lpwstrName != NULL)
	{
	    propspec.ulKind = PRSPEC_LPWSTR;
	    propspec.lpwstr = sps.lpwstrName;
	}
	else
	{
	    propspec.ulKind = PRSPEC_PROPID;
	    propspec.propid = sps.propid;
	}

        hr = pps->ReadMultiple(1, &propspec, &propvar);
	if (hr == S_FALSE)
	{
	    if (g_fVerbose)
	    {
		printf(
		    "%s(%u, %x) vt=%x returned hr=%x\n",
		    "IPropertyStorage::ReadMultiple",
		    ispsStatic,
		    propspec.propid,
		    propvar.vt,
		    hr);
	    }
	    ASSERT(propvar.vt == VT_EMPTY);
	    hr = S_OK;
	}
        Check( S_OK, hr );

	if (ispsStatic == 0 || propvar.vt != VT_EMPTY)
	{
	    ASSERT(count == 1);
	    cprop += count;
	    if (cprop == 1)
	    {
		printf(g_szPropHeader);
	    }

	    DisplayProps(
		    &pspss->fmtid,
		    1,
		    NULL,
		    &sps,
		    NULL,
		    &propvar,
		    FALSE,
		    &cbpropset);
	    PropVariantClear(&propvar);
	}
	if (sps.lpwstrName != NULL)
	{
	    CoTaskMemFree(sps.lpwstrName);
	}
    }
    if (penumsps != NULL)
    {
	penumsps->Release();
    }
    pps->Release();
    if (cprop != 0)
    {
	cbpropset += CB_PROPSET_OVERHEAD + cprop * CB_PROP_OVERHEAD;
	printf("  %04x bytes in %u properties\n\n", cbpropset, cprop);
    }
    *pcprop = cprop;
    *pcbprop = cbpropset;
    return(hr);
}


HRESULT
DumpOlePropertySets(
    IStorage *pstg,
    OLECHAR *aocpath)
{

    HRESULT hr = S_OK;
    IPropertySetStorage *ppsstg;
    ULONG cbproptotal = 0;
    ULONG cproptotal = 0;
    ULONG cpropset = 0;
    IID IIDpsstg = IID_IPropertySetStorage;

    Check(S_OK, pstg->QueryInterface(IID_IPropertySetStorage, (void **) &ppsstg) );

    {
	IEnumSTATPROPSETSTG *penumspss = NULL;

	Check(S_OK, ppsstg->Enum(&penumspss) );

	while (hr == S_OK)
	{
	    STATPROPSETSTG spss;
	    ULONG count;
	    BOOLEAN fDocumentSummarySection2;

	    hr = penumspss->Next(1, &spss, &count);

	    if (hr != S_OK)
	    {
		if (hr == S_FALSE)
		{
		    hr = S_OK;
		}

                Check( S_OK, hr );
		break;
	    }
	    ASSERT(count == 1);

	    fDocumentSummarySection2 = FALSE;
	    while (TRUE)
	    {
		ULONG cprop, cbprop;
                HRESULT hr;

		DumpOlePropertySet(
				ppsstg,
				&spss,
				&cprop,
				&cbprop);
                if ( STG_E_FILENOTFOUND == hr 
                     && fDocumentSummarySection2 )
                {
                    hr = S_OK;
                }

		cpropset++;
		cproptotal += cprop;
		cbproptotal += cbprop;

		if (memcmp(&spss.fmtid, &guidDocumentSummary, sizeof(GUID)))
		{
		    break;
		}
		spss.fmtid = FMTID_UserDefinedProperties;
		fDocumentSummarySection2 = TRUE;
	    }
	}

	if (penumspss != NULL)
	{
	    penumspss->Release();
	}
	ppsstg->Release();
    }
    if ((cbproptotal | cproptotal | cpropset) != 0)
    {
	printf(
	    " %04x bytes in %u properties in %u property sets\n",
	    cbproptotal,
	    cproptotal,
	    cpropset);
    }
    return(hr);
}

inline ULONG min(ULONG ul1, ULONG ul2)
{
    if (ul1 > ul2) return ul2;
    else return ul1;
}

NTSTATUS
DumpOleStream(
    LPSTREAM pstm,
    ULONG cb)
{
    ULONG cbTotal = 0;

    while (TRUE)
    {
	ULONG cbOut;
	BYTE ab[4096];

	Check(S_OK, pstm->Read(ab, min(cb, sizeof(ab)), &cbOut) );
	if (cbOut == 0)
	{
	    break;
	}
	if (g_fVerbose)
	{
	    DumpHex(ab, cbOut, cbTotal);
	}
	cb -= cbOut;
	cbTotal += cbOut;
    }
    return(STATUS_SUCCESS);
}

VOID
DumpOleStorage(
    IStorage *pstg,
    LPOLESTR aocpath )
{
    LPENUMSTATSTG penum;
    STATSTG ss;
    char *szType;
    OLECHAR *pocChild;
    HRESULT hr;
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    Check( S_OK, DumpOlePropertySets(pstg, aocpath) );
    Check( S_OK, pstg->EnumElements(0, NULL, 0, &penum) );

    pocChild = &aocpath[ocslen(aocpath)];

    // Continue enumeration until IEnumStatStg::Next returns non-S_OK

    while (TRUE)
    {
	ULONG ulCount;

        // Enumerate one element at a time
        hr = penum->Next(1, &ss, &ulCount);
        if( S_FALSE == hr )
            break;
        else
            Check( S_OK, hr );

        // Select the human-readable type of object to display
        switch (ss.type)
        {
	    case STGTY_STREAM:    szType = "Stream";    break;
	    case STGTY_STORAGE:   szType = "Storage";   break;
	    case STGTY_LOCKBYTES: szType = "LockBytes"; break;
	    case STGTY_PROPERTY:  szType = "Property";  break;
	    default:              szType = "<Unknown>"; break;
        }
	if (g_fVerbose)
	{
	    printf(
		"Type=%hs Size=%lx Mode=%lx LocksSupported=%lx StateBits=%lx",
		szType,
		ss.cbSize.LowPart,
		ss.grfMode,
		ss.grfLocksSupported,
		ss.grfStateBits);
            PrintOC(aocpath);
            PrintOC(ss.pwcsName);
            printf("\n");
	    printf("ss.clsid = ");
	    PrintGuid(&ss.clsid);
	    printf("\n");
	}

        // If a stream, output the data in hex format.

        CoTaskMemFree(ss.pwcsName);
    }
    penum->Release();
    return;
}


//+---------------------------------------------------------
//
//  Function:   MungePropertyStorage
//  
//  Synopsis:   This routine munges the properties in a
//              Property Storage.  The values of the properties
//              remain the same, but the underlying serialization
//              is new (the properties are read, the property
//              storage is deleted, and the properties are
//              re-written).
//
//  Inputs:     [IPropertySetStorage*] ppropsetgstg (in)
//                  The Property Storage container.
//              [FMTID] fmtid
//                  The Property Storage to munge.
//
//  Returns:    None.
//
//  Note:       Property names in the dictionary for which
//              there is no property are not munged.
//
//+---------------------------------------------------------

#define MUNGE_PROPVARIANT_STEP  10  

void
MungePropertyStorage( IPropertySetStorage *ppropsetstg,
                      FMTID fmtid )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt, ulIndex;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSTG *penumstatpropstg=NULL;

    PROPVARIANT *rgpropvar = NULL;
    STATPROPSTG *rgstatpropstg = NULL;
    ULONG        cProperties = 0;

    // Allocate an array of PropVariants.  We may grow this later.
    rgpropvar = (PROPVARIANT*) CoTaskMemAlloc( MUNGE_PROPVARIANT_STEP * sizeof(*rgpropvar) );
    Check( FALSE, NULL == rgpropvar );

    // Allocate an array of STATPROPSTGs.  We may grow this also.
    rgstatpropstg = (STATPROPSTG*) CoTaskMemAlloc( MUNGE_PROPVARIANT_STEP * sizeof(*rgstatpropstg) );
    Check( FALSE, NULL == rgstatpropstg );

    //  -----------------
    //  Get an Enumerator
    //  -----------------

    // Open the Property Storage.  We may get an error if we're attempting
    // the UserDefined propset.  If it's file-not-found, then simply return,
    // it's not an error, and there's nothing to do.

    hr = ppropsetstg->Open( fmtid,
                            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                            &ppropstg );
    if( FMTID_UserDefinedProperties == fmtid
        &&
        STG_E_FILENOTFOUND == hr )
    {
        goto Exit;
    }
    Check( S_OK, hr );

    // Get an Enumerator
    Check(S_OK, ppropstg->Enum( &penumstatpropstg ));


    //  --------------------------------------------
    //  Read & delete in all of the properties/names
    //  --------------------------------------------

    // Get the first property from the enumerator
    hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
    Check( TRUE, S_OK == hr || S_FALSE == hr );

    // Iterate through the properties.
    while( celt > 0 )
    {
        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[cProperties].propid;

        // Read and delete the property

        Check(S_OK, ppropstg->ReadMultiple( 1, &propspec, &rgpropvar[cProperties] ));
        Check(S_OK, ppropstg->DeleteMultiple( 1, &propspec ));

        // If there is a property name, delete it also.

        if( NULL != rgstatpropstg[cProperties].lpwstrName )
        {
            // We have a name.
            Check(S_OK, ppropstg->DeletePropertyNames( 1, &rgstatpropstg[cProperties].propid ));
        }

        // Increment the property count.
        cProperties++;

        // Do we need to grow the arrays?

        if( 0 != cProperties
            &&
            (cProperties % MUNGE_PROPVARIANT_STEP) == 0 )
        {
            // Yes - they must be reallocated.

            rgpropvar = (PROPVARIANT*)
                        CoTaskMemRealloc( rgpropvar,
                                          ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                            *
                                            sizeof(*rgpropvar) 
                                          ));
            Check( FALSE, NULL == rgpropvar );

            rgstatpropstg = (STATPROPSTG*)
                            CoTaskMemRealloc( rgstatpropstg,
                                              ( (cProperties + MUNGE_PROPVARIANT_STEP)
                                                 *
                                                 sizeof(*rgstatpropstg)
                                              ));
            Check( FALSE, NULL == rgstatpropstg );
        }

        // Move on to the next property.
        hr = penumstatpropstg->Next( 1, &rgstatpropstg[cProperties], &celt );
        Check( TRUE, S_OK == hr || S_FALSE == hr );

    }   // while( celt > 0 )


    //  -------------------------------------
    //  Write the properties & names back out
    //  -------------------------------------

    for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
    {

        // Write the property.

        PROPSPEC propspec;
        propspec.ulKind = PRSPEC_PROPID;
        propspec.propid = rgstatpropstg[ ulIndex ].propid;

        Check(S_OK, ppropstg->WriteMultiple(1, &propspec, &rgpropvar[ulIndex], PID_FIRST_USABLE ));

        // If this property has a name, write it too.
        if( rgstatpropstg[ ulIndex ].lpwstrName != NULL )
        {
            Check(S_OK, ppropstg->WritePropertyNames(
                                            1,
                                            &rgstatpropstg[ulIndex].propid, 
                                            &rgstatpropstg[ulIndex].lpwstrName ));
        }

    }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )


    //  ----
    //  Exit
    //  ----

Exit:

    if( penumstatpropstg )
    {
        penumstatpropstg->Release();
        penumstatpropstg = NULL;
    }

    // Free the PropVariants
    if( rgpropvar )
    {
        FreePropVariantArray( cProperties, rgpropvar );
        CoTaskMemFree( rgpropvar );
    }

    // Free the property names
    if( rgstatpropstg )
    {
        for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )
        {
            if( NULL != rgstatpropstg[ ulIndex ].lpwstrName )
            {
                CoTaskMemFree( rgstatpropstg[ ulIndex ].lpwstrName );
            }
        }   // for( ulIndex = 0; ulIndex < cProperties; ulIndex++ )

        CoTaskMemFree( rgstatpropstg );
    }


}   // MungePropertyStorage

//+---------------------------------------------------------
//
//  Function:   MungeStorage
//
//  Synopsis:   This routine munges the property sets in a
//              Storage.  The properties themselves are not
//              modified, but the serialized bytes are.
//              For each property set, all the properties are
//              read, the property set is deleted, and
//              the properties are re-written.
//
//  Inputs:     [IStorage*] pstg (in)
//                  The Storage to munge.
//
//  Returns:    None.
//
//  Note:       This routine only munges simple property
//              sets.
//
//+---------------------------------------------------------

void
MungeStorage( IStorage *pstg )
{
    //  ------
    //  Locals
    //  ------

    HRESULT hr;
    ULONG celt;

    STATPROPSETSTG statpropsetstg;
    STATSTG statstg;

    TSafeStorage< IPropertySetStorage > ppropsetstg;
    TSafeStorage< IPropertyStorage > ppropstg;

    IEnumSTATPROPSETSTG *penumstatpropsetstg;
    IEnumSTATSTG *penumstatstg;
    
    //  -----------------------------------------------
    //  Munge each of the property sets in this Storage
    //  -----------------------------------------------

    // Get the IPropertySetStorage interface
    Check(S_OK, pstg->QueryInterface( IID_IPropertySetStorage, (VOID**) &ppropsetstg ));

    // Get a property storage enumerator
    Check(S_OK, ppropsetstg->Enum( &penumstatpropsetstg ));

    // Get the first STATPROPSETSTG
    hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
    Check( TRUE, S_OK == hr || S_FALSE == hr );

    // Loop through the STATPROPSETSTGs.
    while( celt > 0 )
    {
        // Is this a simple property storage (we don't
        // handle non-simple sets)?

        if( !(statpropsetstg.grfFlags & PROPSETFLAG_NONSIMPLE) )
        {
            // Munge the Property Storage.
            MungePropertyStorage( ppropsetstg, statpropsetstg.fmtid );
        }

        // Get the next STATPROPSETSTG
        // If we just did the first section of the DocSumInfo
        // property set, then attempt the second section

        if( FMTID_DocSummaryInformation == statpropsetstg.fmtid )
        {                                                         
            statpropsetstg.fmtid = FMTID_UserDefinedProperties;
        }
        else
        {
            hr = penumstatpropsetstg->Next( 1, &statpropsetstg, &celt );
            Check( TRUE, S_OK == hr || S_FALSE == hr );
        }
    }

    // We're done with the Property Storage enumerator.
    penumstatpropsetstg->Release();
    penumstatpropsetstg = NULL;

    //  ------------------------------------------
    //  Recursively munge each of the sub-storages
    //  ------------------------------------------

    // Get the IEnumSTATSTG enumerator
    Check(S_OK, pstg->EnumElements( 0L, NULL, 0L, &penumstatstg ));

    // Get the first STATSTG structure.
    hr = penumstatstg->Next( 1, &statstg, &celt );
    Check( TRUE, S_OK == hr || S_FALSE == hr );

    // Loop through the elements of this Storage.
    while( celt > 0 )
    {
        // Is this a sub-Storage which must be
        // munged?

        if( STGTY_STORAGE & statstg.type  // This is a Storage
            &&
            0x20 <= *statstg.pwcsName )   // But not a system Storage.
        {
            // We'll munge it.
            IStorage *psubstg;
            
            // Open the sub-storage.
            Check(S_OK, pstg->OpenStorage( statstg.pwcsName,
                                           NULL,
                                           STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                                           NULL,
                                           0L,
                                           &psubstg ));

            // Munge the sub-storage.
            MungeStorage( psubstg );
            psubstg->Release();
            psubstg = NULL;
        }

        CoTaskMemFree(statstg.pwcsName);
        // Move on to the next Storage element.
        hr = penumstatstg->Next( 1, &statstg, &celt );
        Check( TRUE, S_OK == hr || S_FALSE == hr );
    }

    penumstatstg->Release();
    penumstatstg = NULL;


}   // MungeStorage

void
DisplayUsage( LPSTR pszCommand )
{
    printf("\n");
    printf("   Usage:  %s [[options] <test directory>] [file-commands]\n", pszCommand );
    printf("\n");
    printf("   The <test directory> is required in order to run tests, but is\n" );
    printf("   not required for the file-commands.\n" );
    printf("\n");
    printf("   Options:\n" );
    printf("      /w enables the Word 6 compatibility test\n");
    printf("      /iw creates a file for interop test\n");
    printf("      /ir verfies the file created for interop test\n" );    
    printf("\n");
    printf("   File-commands:\n" );
    printf("      /g<file> specifies a file to be munGed\n" );
    printf("          (propsets are read, deleted, & re-written)\n" );
    printf("      /d<file> specifies a file to be Dumped\n" );
    printf("          (propsets are dumped to stdout)\n" );
    printf("\n");
    printf("   Examples:\n" );
    printf("      %s c:\\test\n", pszCommand );
    printf("      %s -iw c:\\test\n", pszCommand );
    printf("      %s -dMyFile.doc\n", pszCommand );
    printf("      %s -gMyFile.doc\n", pszCommand );
    printf("\n");
    return;
}

//
//   Interoperability test
//
//   test_interop_write writes in a doc file
//   test_interop_read reads it in and verifies that it is right.
typedef struct tagInteropTest {
    VARENUM vt;
    void *pv;
} interopStruct;

const int cInteropPROPS=18;

static interopStruct  
avtInterop[cInteropPROPS] = {
    VT_LPSTR, "Title of the document.",                                  
    VT_LPSTR, "Subject of the document.",                                
    VT_LPSTR, "Author of the document.",                                 
    VT_LPSTR, "Keywords of the document.",                               
    VT_LPSTR, "Comments of the document.",                               
    VT_LPSTR, "Normal.dot",                
    VT_LPSTR, "Mr. Unknown",               
    VT_LPSTR, "3",                         
    VT_EMPTY, 0,                           
    VT_EMPTY, 0,                           
    VT_EMPTY, 0,                           
    VT_EMPTY, 0,                           
    VT_I4, (void*) 1,                                                   
    VT_I4, (void*) 7,                                                   
    VT_I4, (void*) 65,                                                  
    VT_EMPTY, 0,                           
    VT_LPSTR, "Reference",                 
    VT_I4, (void*) 1121                            
};


void test_interop_write()
{
    printf( "   Interoperability - write \n" );

    DECLARE_OLESTR(szFile, "t_interop");

    IStorage *pStg;
    Check(S_OK, 
          StgCreateDocfile(szFile, 
                           STGM_CREATE| STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
                           (DWORD)NULL, &pStg));

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    Check(S_OK, pPropSetStg->Create(FMTID_SummaryInformation, NULL, 0,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READWRITE,
                    &pPropStg));

    PROPSPEC propspec[cInteropPROPS+2];
    int i;
    for (i=2; i<cInteropPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[cInteropPROPS+2];

    for (i=2; i<cInteropPROPS+2; i++)
    {
        propvar[i].vt = avtInterop[i-2].vt;
        switch (avtInterop[i-2].vt)
        {
        case VT_LPSTR:
            propvar[i].pszVal = (char*)avtInterop[i-2].pv;
            break;
        case VT_I4:
            propvar[i].lVal = (int)avtInterop[i-2].pv;
            break;
        default: 
            break;
        }
    }
    Check(S_OK, 
          pPropStg->WriteMultiple(cInteropPROPS, propspec+2, 
                                        propvar+2, 2) );
    pPropStg->Release();
    pStg->Release();
}

void test_interop_read()
{
    printf( "   Interoperability - read \n" );

    DECLARE_OLESTR(szFile, "t_interop");

    IStorage *pStg;
    Check(S_OK, StgOpenStorage(szFile, NULL,
                    STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, 0, &pStg));

    TSafeStorage< IPropertySetStorage > pPropSetStg(pStg);
    IPropertyStorage *pPropStg;

    Check(S_OK, pPropSetStg->Open(FMTID_SummaryInformation,
                    STGM_SHARE_EXCLUSIVE | STGM_DIRECT | STGM_READ,
                    &pPropStg));

    PROPSPEC propspec[cInteropPROPS+2];
    int i;
    for (i=2; i<cInteropPROPS+2; i++)
    {
        propspec[i].ulKind = PRSPEC_PROPID;
        propspec[i].propid = (PROPID)i;
    }

    PROPVARIANT propvar[cInteropPROPS+2];

    Check(S_OK, pPropStg->ReadMultiple(cInteropPROPS, propspec+2, propvar+2));

    for (i=2; i<cInteropPROPS+2; i++)
    {
        if ( propvar[i].vt != avtInterop[i-2].vt )
        {
            printf( " PROPTEST: 0x%x retrieved type 0x%x, expected type 0x%x\n",
                    i, propvar[i].vt, avtInterop[i-2].vt );
            ASSERT(propvar[i].vt == avtInterop[i-2].vt);
        }
        
        switch (propvar[i].vt) 
        {
        case VT_LPSTR:
            ASSERT(strcmp(propvar[i].pszVal, (char*)avtInterop[i-2].pv)==0);
            break;
        case VT_I4:
            ASSERT(propvar[i].lVal == (int)avtInterop[i-2].pv);
            break; 
        }
        PropVariantClear(propvar+i);
    }

    pPropStg->Release();
    pStg->Release();
}

void Cleanup()
{
    ULONG ul;
    // Clean up and exit.
    if (_pstgTemp)
    {
        ul = _pstgTemp->Release();
        assert(ul==0 && "_pstgTemp ref counting is wrong!");
    }
    if (_pstgTempCopyTo)
    {
        ul = _pstgTempCopyTo->Release();
        assert( 0 == ul 
           && "_pstgTempCopyTo ref counting is wrong!");
    }
}

int main(int argc, char *argv[])
{
    int nArgIndex;
#ifndef _UNIX
    INIT_OLESTR(oszSummary, "SummaryInformation");
    INIT_OLESTR(aocMap, "abcdefghijklmnopqrstuvwxyz012345");
    INIT_OLESTR( oszDocumentSummary, "DocumentSummaryInformation");
#endif

    ULONG ulTestOptions = 0L;
    BOOL  fOffice97TestDoc = FALSE;
    CHAR* pszFileToMunge = NULL;
    CHAR* pszFileToDump = NULL;

    printf("Property Set Tests\n");

    // Check for command-line switches
    if( 2 > argc )
    {
        printf("Too few arguments\n");
        DisplayUsage( argv[0] );
        exit(0);
    }

    for( nArgIndex = 1; nArgIndex < argc; nArgIndex++ )
    {
        if( argv[nArgIndex][0] == '/'
            ||
            argv[nArgIndex][0] == '-'
          )
        {
            BOOL fNextArgument = FALSE;

            for( int nOptionSubIndex = 1;
                 argv[nArgIndex][nOptionSubIndex] != '\0' && !fNextArgument;
                 nOptionSubIndex++
                )
            {
                switch( argv[nArgIndex][nOptionSubIndex] )
                {                                    
                case 'w':
                case 'W':
                    ulTestOptions |= TEST_WORD6;
                    break;
                    
                case '?':
                    DisplayUsage(argv[0]);
                    exit(1);
                    
                case 'i':    
                    if (argv[nArgIndex][nOptionSubIndex+1]=='w')
                        ulTestOptions |= TEST_INTEROP_W;
                    else if (argv[nArgIndex][nOptionSubIndex+1]=='r')
                        ulTestOptions |= TEST_INTEROP_R;
                    else
                    {
                        DisplayUsage(argv[0]);
                        printf("You must specify 'r' or 'w' for interop!\n");
                        exit(-1);
                    }

                    nOptionSubIndex++;
                    break;                            

                case 'd':
                case 'D':
                    if( NULL != pszFileToDump )
                    {
                        printf( "Error:  Only one file may be dumped\n" );
                        DisplayUsage( argv[0] );
                    }
                    else
                    {
                        pszFileToDump = &argv[nArgIndex][nOptionSubIndex+1];
                        fNextArgument = TRUE;
                    }
                    
                    if( '\0' == *pszFileToDump )
                    {
                        printf( "Error:  Missing filename for dump option\n" );
                        DisplayUsage( argv[0] );
                        exit(1);
                    }
                    break;

                case 'g':
                case 'G':

                    if( NULL != pszFileToMunge )
                    {
                        printf( "Error:  Only one file may be munged\n" );
                        DisplayUsage( argv[0] );
                        exit(1);
                    }
                    else
                    {
                        pszFileToMunge = &argv[nArgIndex][nOptionSubIndex+1];
                        fNextArgument = TRUE;
                    }
                    
                    if( '\0' == *pszFileToMunge )
                    {
                        printf( "Error:  Missing filename for munge option\n" );
                        DisplayUsage( argv[0] );
                        exit(1);
                    }
                    break;
                    
                default:
                    printf( "Option '%c' ignored\n", 
                            argv[nArgIndex][nOptionSubIndex] );
                    break;

                }   // switch( argv[nArgIndex][1] )

            }   // for( int nOptionSubIndex = 1; ...
        }   // if( argv[nArgIndex][0] == '/'
        else
        {
            break;
        }
    }   // for( ULONG nArgIndex = 2; nArgIndex < argc; nArgIndex++ )


    // If any other command-line parameters were given, ignore them.

    for( int nExtraArg = nArgIndex+1; nExtraArg < argc; nExtraArg++ )
    {
        printf( "Illegal argument ignored:  %s\n", argv[nExtraArg] );
    }

    OLECHAR ocsFile[256], ocsTest[256], ocsTest2[256], ocsTestOffice[256];
    CHAR szDir[256];
    HRESULT hr;
    IStorage *pstg;

    int i=0;

    if ( NULL != pszFileToDump )
    {
        printf("DUMPING: %s\n", pszFileToDump);
        printf("========================\n");        
        STOT( pszFileToDump, ocsFile, strlen(pszFileToDump)+1 );
        Check(S_OK, StgOpenStorage( ocsFile,
                                    (IStorage*)NULL,
                                    (DWORD)STGM_DIRECT | STGM_READWRITE | 
                                    STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0L,
                                    &pstg ));
        DumpOleStorage( pstg, ocsFile );
        Check(0, pstg->Release()); // ensure we released the last reference
        exit(0);
    }

    // Is there a file to munge?
    if ( NULL != pszFileToMunge )
    {
        STOT(pszFileToMunge, ocsFile, strlen(pszFileToMunge)+1 );
        Check(S_OK, StgOpenStorage( ocsFile,
                                    NULL,
                                    (DWORD) STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                                    NULL,
                                    0L,
                                    &pstg ));
        MungeStorage( pstg );
        PrintOC(ocsFile);
        printf( " successfully munged\n");
        Check(0, pstg->Release());
        exit(0);
    }

    // Verify that the user provided a directory path.

    if (nArgIndex >= argc)
    {
        printf( "Test directory not provided on command-line\n" );
        DisplayUsage( argv[0] );
        exit(1);
    }

    // Verify that the user-provided directory path
    // exists

    struct _stat filestat;
    if (_stat(argv[nArgIndex], &filestat)!=0 || 
        !(filestat.st_mode && S_IFDIR))
    {
        printf("Error in opening %s as a directory", argv[nArgIndex] );
        exit(1);
    }

#ifdef _WIN32  // don't bother to create a directory for test files on UNIX
               // since there are some problems with creating files with 
               // path names

    if (!(ulTestOptions & TEST_INTEROP_R) && !(ulTestOptions & TEST_INTEROP_W))
    {
        // Find an new directory name to use for temporary
        // files ("testdirX", where "X" is a number).
        do
        {
            strcpy(szDir, argv[nArgIndex]);
            sprintf(strchr(szDir,0), "\\testdir%d", i++);
        } while ( (_mkdir(szDir, 0x744) == -1) && (i<20) );      
    
        if (i>=20) 
        {
            printf("Too many testdirX subdirectories, delete some and re-run\n");
            exit(-1);
        }
    }
    else 
    {
        // use current directory for interop testing
        szDir[0] = '.';
        szDir[1] = 0;
    }
#endif


#ifdef _WIN32
    printf( "Generated files will be put in \"%s\"\n", szDir );
    // Create "tesdoc"
    STOT(szDir, ocsFile, strlen(szDir)+1);

    ocscpy(ocsTest, ocsFile);
    DECLARE_OLESTR(ocsTestDoc, "\\testdoc");
    ocscat(ocsTest, ocsTestDoc);
#else
    DECLARE_OLESTR(ocsTestDoc, "testdoc");
    ocscpy(ocsTest, ocsTestDoc);
#endif

    hr = StgCreateDocfile(ocsTest, STGM_DIRECT | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                          0, &_pstgTemp);
    if (hr != S_OK)
    {
        printf("Can't create %s\n", ocsTest);
        exit(1);
    }

    // Create "testdoc2"
#ifdef _WIN32
    DECLARE_OLESTR(ocsTestDoc2,"\\testdoc2");
    ocscpy(ocsTest2, ocsFile);
    ocscat(ocsTest2, ocsTestDoc2); 
#else
    DECLARE_OLESTR(ocsTestDoc2,"testdoc2");
    ocscpy(ocsTest2, ocsTestDoc2);
#endif

    hr = StgCreateDocfile(ocsTest2, STGM_CREATE | STGM_READWRITE |
                          STGM_SHARE_EXCLUSIVE,
                          0, &_pstgTempCopyTo);
    if (hr != S_OK)
    {
        printf("Can't create %ls\n", ocsTest);
        exit(1);
    }

    Check(S_OK, PopulateRGPropVar( g_rgcpropvarAll, g_rgcpropspecAll ));

    printf( "\nStandard Tests\n" );
    printf(   "--------------\n" );

    test_WriteReadAllProperties(ulTestOptions);

    test_PropertyInterfaces(_pstgTemp);

    // test with Unicode, then ansi files

    test_CodePages(ocsFile, ulTestOptions, TRUE);
    test_CodePages(ocsFile, ulTestOptions, FALSE);     

    // Test the IStorage::CopyTo operation, using all combinations of 
    // direct and transacted mode for the base and PropSet storages.

    for( int iteration = 0; iteration < 4; iteration++ )
    {
        DECLARE_OLESTR(aocStorageName, "#0 Test CopyTo");
        aocStorageName[1] = (OLECHAR) iteration + (OLECHAR)'0';

        test_CopyTo( _pstgTemp, _pstgTempCopyTo,
                     STGM_DIRECT,
                     STGM_DIRECT,
                     aocStorageName );
    }


    // Generate the stock ticker property set example
    // from the OLE programmer's reference spec.
    test_OLESpecTickerExample( _pstgTemp );

#ifdef _WIN32
    ocscpy(ocsTestOffice, ocsFile);
    DECLARE_OLESTR(ocsOffice, "\\Office");
    ocscat(ocsTestOffice, ocsOffice);
#else
    DECLARE_OLESTR(ocsOffice, "Office");
    ocscpy(ocsTestOffice, ocsOffice);
#endif

    test_Office( ocsTestOffice );
    test_PropVariantValidation( _pstgTemp );
    test_PropVariantCopy();

    if( ulTestOptions )
    {
        printf( "\nOptional Tests\n" );
        printf(   "--------------\n" );

        // If requested, test for compatibility with Word 6.0 files.

        if ( ulTestOptions & TEST_WORD6 )
            test_Word6(_pstgTemp);

        if ( ulTestOptions & TEST_INTEROP_W)
        {
            test_interop_write();
        }
        if ( ulTestOptions & TEST_INTEROP_R)
        {
            test_interop_read();
        }

    }   // if( ulTestOptions )

    Cleanup();

    printf("\nPASSED\n");

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\reftest\time.cxx ===
#include "../../h/storage.h"
#include "time.hxx"
#include <limits.h>
#include <assert.h>

// Number of seconds difference betwen FILETIME (since 1601 00:00:00) 
// and time_t (since 1970 00:00:00)
//
// This should be a constant difference between the 2 time formats
//
const LONGLONG ci64DiffFTtoTT=11644473600; 

STDAPI_(void) FileTimeToTimeT(const FILETIME *pft, time_t *ptt)
{
    ULONGLONG llFT = pft->dwHighDateTime;
    llFT = (llFT << 32) | (pft->dwLowDateTime);
    // convert to seconds 
    // (note that all fractions of seconds will be lost)
    llFT = llFT/10000000;       
    llFT -= ci64DiffFTtoTT;         // convert to time_t 
    assert(llFT <= ULONG_MAX);
    *ptt = (time_t) llFT;
}

STDAPI_(void) TimeTToFileTime(const time_t *ptt, FILETIME *pft)
{
    ULONGLONG llFT = *ptt;
    llFT += ci64DiffFTtoTT;         // convert to file time
    // convert to nano-seconds
    for (int i=0; i<7; i++)         // mulitply by 10 7 times
    {        
        llFT = llFT << 1;           // llFT = 2x
        llFT += (llFT << 2);        // llFT = 4*2x + 2x = 10x
    }
    pft->dwLowDateTime  = (DWORD) (llFT & 0xffffffff);
    pft->dwHighDateTime = (DWORD) (llFT >> 32);
}

#pragma warning(disable:4514)
// disable warning about unreferenced inline functions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\reftest\reftest.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	reftest.cxx
//
//  Contents:	Reference tests
//
//  Classes:	
//
//  Functions:	
//
//----------------------------------------------------------------------------
#ifdef _MSC_VER
#define INITGUID
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "../../h/storage.h"

// enable debugging features of memory allocation
#include "../../h/dbg.hxx"

#ifdef _MSC_VER
#undef INITGUID
#endif

#include "refilb.hxx"

#ifndef _WIN32 
#include <unistd.h>
#else
#include <io.h>
#endif

#define STGP(x) STGM_SHARE_EXCLUSIVE | x
#define STMP(x) STGM_SHARE_EXCLUSIVE | x
#define ROOTP(x) STGP(x)

#define EXIT_BADSC 1

int g_fTestInterop = 0;

#define olHChk(e) \
     if FAILED(sc = e) \
         goto EH_Err

#define olChk(e) olHChk(e)

#include <assert.h>
#define olAssert assert

#ifdef NDEBUG
#define verify(exp) exp
#else
#define verify(exp) assert(exp)
#endif

#define ULIGetLow(ui) (ui.LowPart)

//
// some global variables used by all the tests
//
OLECHAR ocsDRT   [ sizeof("drt.dfl")+1 ];
OLECHAR ocsChild [ sizeof("Child")  +1 ];
OLECHAR ocsChild1[ sizeof("Child1") +1 ];
OLECHAR ocsChild2[ sizeof("Child2") +1 ];
OLECHAR ocsStream[ sizeof("Stream") +1 ];
OLECHAR ocsRenamedStream[ sizeof("RenamedStream") +1 ];
OLECHAR ocsRenamedChild[ sizeof("RenamedChild") +1 ];

void error(int code, char *fmt, ...)
{
    va_list args;
    
    args = va_start(args, fmt);
    fprintf(stderr, "** Fatal error **: ");
    vfprintf(stderr, fmt, args);    
    va_end(args);
    exit(code);
}


BOOL IsEqualTime(FILETIME ttTime, FILETIME ttCheck)
{
    return ttTime.dwLowDateTime == ttCheck.dwLowDateTime &&
        ttTime.dwHighDateTime == ttCheck.dwHighDateTime;
}


SCODE t_create(BOOL fTestStorage)
{
    IStorage *pstgRoot, *pstgChild, *pstgChild2;
    IStream *pstm;
    SCODE sc;
    ILockBytes *pilb=NULL;
    
    if (!fTestStorage)
    {
       printf("Testing Create ILB\n");

       pilb = new CFileILB(ocsDRT, (DWORD)NULL);
       if (pilb == NULL)
           error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
       
       //  create a storage on the ILockBytes
       olHChk( StgCreateDocfileOnILockBytes( pilb, 
                                            STGM_READWRITE | 
                                            STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                            0, &pstgRoot));
    }
    else 
    {
       printf("Testing Create storage\n");
       olHChk(StgCreateDocfile( ocsDRT, 
			       STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
			       0, &pstgRoot));
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    
    olHChk(pstgChild->CreateStorage(ocsChild2, STGP(STGM_READWRITE), 0, 0,
                                    &pstgChild2));
    
    olHChk(pstgChild2->CreateStream(ocsStream, STMP(STGM_READWRITE), 0, 0,
                                    &pstm));
    
    pstm->Release();
    olHChk(pstgChild2->Commit(0));
    pstgChild2->Release();
    
    olHChk(pstgChild->Commit(0));
    pstgChild->Release();
    
    pstgRoot->Release();
    if (pilb) pilb->Release();
    
EH_Err:
    return sc;
}

SCODE t_open(BOOL fTestStorage)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgChild, *pstgChild2;
    IStream *pstm;
    ILockBytes *pilb=NULL;
    if (!fTestStorage)
    {
       printf("Testing Open ILB\n");
       pilb = new CFileILB(ocsDRT, (DWORD)NULL);
       if (pilb == NULL)
	  error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
       
       //  create a storage on the ILockBytes
       olHChk(StgCreateDocfileOnILockBytes(pilb,
					   STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
					   0, &pstgRoot));
    }
    else 
    {
        //  create a storage
        printf("Testing Open storage\n");
        olHChk(StgCreateDocfile(ocsDRT, 
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                0, &pstgRoot));				
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    olHChk(pstgChild->CreateStorage(ocsChild2, STGP(STGM_READWRITE), 0, 0,
                                    &pstgChild2));
    olHChk(pstgChild2->CreateStream(ocsStream, STMP(STGM_READWRITE), 0, 0,
                                    &pstm));
    pstm->Release();
    pstgChild2->Release();
    pstgChild->Release();
    
    olHChk(pstgRoot->Commit(0));
    pstgRoot->Release();

    if (!fTestStorage)
    {
        olHChk(StgOpenStorageOnILockBytes(pilb, NULL,
                                          ROOTP(STGM_READWRITE), NULL, 0, &pstgRoot));
    }
    else 
    {
        olHChk(StgOpenStorage(ocsDRT,			
                              NULL, ROOTP(STGM_READWRITE), NULL, 0,
                              &pstgRoot));
    }
    
    olHChk(pstgRoot->OpenStorage(
        ocsChild,
        NULL,
        STGP(STGM_READWRITE),
        NULL,
        0,
        &pstgChild));
    
    olHChk(pstgChild->OpenStorage(
        ocsChild2,
        NULL,
        STGP(STGM_READWRITE),
        NULL,
        0,
        &pstgChild2));
    
    olHChk(pstgChild2->OpenStream(
        ocsStream,
        NULL,
        STMP(STGM_READWRITE),
        0,
        &pstm));
    
    pstm->Release();
    pstgChild2->Release();
    pstgChild->Release();
    pstgRoot->Release();
    if (pilb) pilb->Release();
    
EH_Err:
    return sc;
}  // t_open



SCODE t_addref(BOOL fTestStorage)
{
    SCODE sc;
    IStorage *pstg;
    IStream *pstm;
    ULONG ul;
    ILockBytes *pilb=NULL;
    
    if (!fTestStorage)
    {
		printf("Testing Addref ILB\n");
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
        
        //  create a storage on the ILockBytes    
        olHChk(StgCreateDocfileOnILockBytes(pilb,
                                            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                            0, &pstg));
    }
    else 
    {
		printf("Testing Addref Storage\n");
        olHChk(StgCreateDocfile(ocsDRT,
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                0, &pstg));
    }
    
    olHChk(pstg->CreateStream( ocsStream, STMP(STGM_READWRITE),
                               0, 0, &pstm));
    
    if ((ul = pstm->AddRef()) != 2)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) != 1)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Release();
    if ((ul = pstg->AddRef()) != 2)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) != 1)
        error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    
    pstg->Release();
    if (pilb) pilb->Release();
EH_Err:
    return sc;
} // t_addref

SCODE t_dmodify(BOOL fTestStorage)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgChild, *pstgChild2;
    IStream *pstm;
    ILockBytes *pilb=NULL;

    DECLARE_OLESTR(ocs88, "88");
    DECLARE_OLESTR(ocs84, "84");
    DECLARE_OLESTR(ocs92, "92");
    DECLARE_OLESTR(ocs64, "64");
    DECLARE_OLESTR(ocs32, "32");
    DECLARE_OLESTR(ocs96, "96");
    DECLARE_OLESTR(ocs80, "80");
    
    if (!fTestStorage)
    {
		printf("Testing Modify ILB\n");
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	
        //  create a storage on the ILockBytes  
        olHChk(StgCreateDocfileOnILockBytes(pilb, 
                                            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 
                                            0, &pstgRoot));
    }
    else {
		printf("Testing Modify Storage\n");
        olHChk(StgCreateDocfile(ocsDRT, 
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 
                                0, &pstgRoot));
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0,
                                   0, &pstgChild));
    olHChk(pstgChild->CreateStorage(ocsChild2, STGP(STGM_READWRITE), 0,
                                    0, &pstgChild2));
    olHChk(pstgChild2->CreateStream(
        ocsStream, STMP(STGM_READWRITE), 0, 0, &pstm));
    pstm->Release();
    
    // Test renaming a closed stream
    olHChk(pstgChild2->RenameElement(ocsStream, ocsRenamedStream));
    
    // Test destroying a stream
    olHChk(pstgChild2->DestroyElement(ocsRenamedStream));
    
    // Test renaming an open stream
    olHChk(pstgChild2->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    olHChk(pstgChild2->RenameElement(ocsStream, ocsRenamedStream));
    
    olHChk(pstgChild2->DestroyElement(ocsRenamedStream));
    pstm->Release();
    
    pstgChild2->Release();
    
    // Test renaming a storage
    olHChk(pstgChild->RenameElement(ocsChild2, ocsRenamedChild));
    
    olHChk(pstgChild->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    pstm->Release();
    olHChk(pstgChild->DestroyElement(ocsStream));
    
    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;
    
    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x9abcdef0;
    
    // Set when element not open
    olHChk(pstgChild->SetElementTimes(ocsRenamedChild, &tm, NULL, NULL));
    olHChk(pstgChild->SetElementTimes(ocsRenamedChild, NULL, &tm, NULL));
    olHChk(pstgChild->SetElementTimes(ocsRenamedChild, NULL, NULL, &tm));
    
    olHChk(pstgChild->OpenStorage(
        ocsRenamedChild,
        NULL,
        STMP(STGM_READWRITE),
        NULL,
        0,
        &pstgChild2));
    olHChk(pstgChild2->Stat(&stat, STATFLAG_NONAME));
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");
    
    // Test SetClass and SetStateBits
    olHChk(pstgChild2->SetClass(IID_IStorage));
    olHChk(pstgChild2->SetStateBits(0xff00ff00, 0xffffffff));
    olHChk(pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee));
    olHChk(pstgChild2->Stat(&stat, STATFLAG_NONAME));
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set improperly\n");
    if (stat.grfStateBits != 0x11881188)
        error(EXIT_BADSC, "State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Release();
    
    pstgChild->Release();
    
    olHChk(pstgRoot->Revert());
    
    olHChk(pstgRoot->Commit(0));
    
    olHChk(pstgRoot->DestroyElement(ocsChild));
    
    olHChk(pstgRoot->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    ULARGE_INTEGER ulSize;
    ULISet32(ulSize, 65536);
    
    olHChk(pstm->SetSize(ulSize));
    pstm->Release();
    olHChk(pstgRoot->DestroyElement(ocsStream));
    olHChk(pstgRoot->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    olHChk(pstm->SetSize(ulSize));
    pstm->Release();
    
    pstgRoot->Release();
    
    if (pilb) pilb->Release();
    
    if (!fTestStorage)
    {
        pilb = new CFileILB((TCHAR*)NULL, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	
        //  create a storage on the ILockBytes		
        olHChk(StgCreateDocfileOnILockBytes(pilb,
                                            STGM_READWRITE |
                                            STGM_CREATE    |
                                            STGM_SHARE_EXCLUSIVE,
                                            0, &pstgRoot));
    }
    else 
    {
        olHChk(StgCreateDocfile(ocsDRT,
                                STGM_READWRITE |
                                STGM_CREATE    |
                                STGM_SHARE_EXCLUSIVE,
                                0, &pstgRoot));		
    }
    
    //  removal cases
    //    1) no right child

    olHChk(pstgRoot->CreateStorage(ocs64, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs32, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    
    olHChk(pstgRoot->DestroyElement(ocs64));
    
    //    2) right child has no left child
    
    olHChk(pstgRoot->CreateStorage(ocs64, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->DestroyElement(ocs32));
    
    //    3) right child has left child
    
    olHChk(pstgRoot->CreateStorage(ocs96, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs80, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    
    olHChk(pstgRoot->DestroyElement(ocs64));
    
    //    4) right child's left child has children
    
    olHChk(pstgRoot->CreateStorage(ocs88, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs84, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->CreateStorage(ocs92, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    pstgChild->Release();
    olHChk(pstgRoot->DestroyElement(ocs80));
    
    pstgRoot->Release();
    
    if (pilb) pilb->Release();
EH_Err:
    return sc;
}


SCODE t_stat(BOOL fTestStorage)
{
    SCODE sc;
    IStorage *pstgRoot, *pstgChild;
    IStream *pstm;
    STATSTG stat;
    ILockBytes *pilb=NULL;
    
    if (!fTestStorage)
    { 
		printf("Testing Stat ILB\n");
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	
        //  create a storage on the ILockBytes
	
        olHChk(StgCreateDocfileOnILockBytes(pilb,
                                            STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                            0, &pstgRoot));
    }
    else 
    {		
		printf("Testing Stat Storage\n");
        //  create a storage 		
        olHChk(StgCreateDocfile(ocsDRT,
                                STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
                                0, &pstgRoot));
    }
    
    olHChk(pstgRoot->CreateStorage(ocsChild, STGP(STGM_READWRITE), 0, 0,
                                   &pstgChild));
    olHChk(pstgChild->CreateStream(
        ocsStream,
        STMP(STGM_READWRITE),
        0,
        0,
        &pstm));
    
    olHChk(pstm->Stat(&stat, 0));
    delete [] stat.pwcsName;
    
    olHChk(pstm->Stat(&stat, STATFLAG_NONAME));
    
    pstm->Release();
    
    olHChk(pstgChild->Stat(&stat, 0));
    delete [] stat.pwcsName;
    
    olHChk(pstgChild->Stat(&stat, STATFLAG_NONAME));
    
    pstgChild->Release();
    
    olHChk(pstgRoot->Stat(&stat, 0));
    
    delete[] stat.pwcsName;
    
    olHChk(pstgRoot->Stat(&stat, STATFLAG_NONAME));
    
    pstgRoot->Release();
    if (pilb) pilb->Release();
EH_Err:
    return sc;
}

static char NUMBERS[] = "12345678901234567890123456789012345678901234567890";

SCODE t_stream(BOOL fTestStorage, BOOL fCreate=1)
{
    SCODE sc;
    IStorage *pstg=NULL, *pstg1=NULL, *pstg2=NULL, *pstg3=NULL;
    IStream *pstm=NULL, *pstmC=NULL, *pstm1=NULL, *pstm2=NULL;
    char buf[sizeof(NUMBERS)*2];
    ULONG cb;
    ULARGE_INTEGER ulPos, ulSize;
    LARGE_INTEGER lPos;
    ILockBytes *pilb=NULL;
    int i=0;

    DECLARE_OLESTR(ocsStorage1,        "Storage1");
    DECLARE_OLESTR(ocsStorage1Stream1, "Storage1Stream1");
    DECLARE_OLESTR(ocsStorage2,        "Storage2");
    DECLARE_OLESTR(ocsStorage2Storage1, "Storage2Storage1");
    DECLARE_OLESTR(ocsStorage3Stream1, "Storage3Stream1");

    if (fCreate)
    {
        if (!fTestStorage)
        {
            printf("Testing streams for ILB\n");
            pilb = new CFileILB(ocsDRT, (DWORD)NULL);
            if (pilb == NULL)
                error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
	      
            //  create a storage on the ILockBytes
            olHChk(StgCreateDocfileOnILockBytes(pilb,
                                                STGM_READWRITE |
                                                STGM_CREATE    |
                                                STGM_SHARE_EXCLUSIVE,
                                                0, &pstg));
        }
        else
        {
            printf("Testing streams for Storage\n");
            //  create a storage on the ILockBytes
            olHChk(StgCreateDocfile(ocsDRT,
                                    STGM_READWRITE | STGM_CREATE 
                                    | STGM_SHARE_EXCLUSIVE,
                                    0, &pstg));
        }
	 
        olHChk(pstg->CreateStream( ocsStream,
				   STMP(STGM_READWRITE), 0, 0, &pstm));
        olHChk(pstg->CreateStorage( ocsStorage1,
				    STMP(STGM_READWRITE), 0, 0, &pstg1));
        olHChk(pstg1->CreateStream( ocsStorage1Stream1,
				    STMP(STGM_READWRITE), 0, 0, &pstm1));
        olHChk(pstg->CreateStorage( ocsStorage2,
				    STMP(STGM_READWRITE), 0, 0, &pstg2));
        olHChk(pstg2->CreateStorage( ocsStorage2Storage1,
				     STMP(STGM_READWRITE), 0, 0, &pstg3));
        olHChk(pstg3->CreateStream( ocsStorage3Stream1,
				    STMP(STGM_READWRITE), 0, 0, &pstm2));
        for (i=0; i<20; i++)
            olHChk(pstm->Write(NUMBERS, sizeof(NUMBERS), &cb));
        for (i=0; i<20; i++)
            olHChk(pstm2->Write(NUMBERS, sizeof(NUMBERS), &cb));
	 
        olHChk(pstm->Commit(0));
        unsigned long ul;
        if ((ul = pstm->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstm1->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstm2->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg1->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg2->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if ((ul = pstg3->Release())!=0)
            error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
        if (pilb && (0 != pilb->Release()) );
        return sc;
    }
    
    if (!fTestStorage)
    {
        pilb = new CFileILB(ocsDRT, (DWORD)NULL);
        if (pilb == NULL)
            error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");
        
        //  create a storage on the ILockBytes
        olHChk(StgOpenStorageOnILockBytes(pilb, NULL,
                                          ROOTP(STGM_READWRITE), NULL, 0, 
                                          &pstg));
    }
    else
    {
        olHChk(StgOpenStorage(ocsDRT,			
                              NULL, ROOTP(STGM_READWRITE), NULL, 0,
                              &pstg));
    }
    
    olHChk(pstg->OpenStream( ocsStream, NULL,
                             STMP(STGM_READWRITE), 0, &pstm));
    olHChk(pstg->OpenStorage( ocsStorage1, NULL,
                              STMP(STGM_READWRITE), 0, 0, &pstg1));
    olHChk(pstg1->OpenStream( ocsStorage1Stream1, NULL,
                              STMP(STGM_READWRITE), 0, &pstm1));
    olHChk(pstg->OpenStorage( ocsStorage2, NULL,
                              STMP(STGM_READWRITE), 0, 0, &pstg2));
    olHChk(pstg2->OpenStorage( ocsStorage2Storage1, 0, 
                               STMP(STGM_READWRITE), 0, 0, &pstg3));
    olHChk(pstg3->OpenStream( ocsStorage3Stream1, 0,
                              STMP(STGM_READWRITE), 0, &pstm2));

    ULISet32(lPos, 0);    
    olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, &ulPos));
    if (ULIGetLow(ulPos) != 0)
        error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ULIGetLow(ulPos));
    for (i=0; i<20; i++)
    {
        olHChk(pstm->Read(buf, sizeof(NUMBERS), &cb));
        if (strcmp(buf, NUMBERS))
            error(EXIT_BADSC, "Incorrect stream contents\n");
    }

    ULISet32(lPos, 0);    
    olHChk(pstm2->Seek(lPos, STREAM_SEEK_SET, &ulPos));
    if (ULIGetLow(ulPos) != 0)
        error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ULIGetLow(ulPos));
    for (i=0; i<20; i++)
    {
        olHChk(pstm2->Read(buf, sizeof(NUMBERS), &cb));
        if (strcmp(buf, NUMBERS))
            error(EXIT_BADSC, "Incorrect stream contents\n");
    }
    
    if (!g_fTestInterop)
    {   // some tests that changes the contents
        ULISet32(ulSize, sizeof(NUMBERS)/2);
        olHChk(pstm->SetSize(ulSize));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        
        olHChk(pstm->Read(buf, sizeof(NUMBERS), &cb));
    
        if (cb != sizeof(NUMBERS)/2)
            error(EXIT_BADSC, "SetSize failed to size stream properly\n");
        if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2))
            error(EXIT_BADSC, "SetSize corrupted contents\n");
        olHChk(pstm->Clone(&pstmC));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        olHChk(pstm->CopyTo(pstmC, ulSize, NULL, NULL));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        
        ULISet32(ulSize, sizeof(NUMBERS)&~1);
        olHChk(pstm->CopyTo(pstmC, ulSize, NULL, NULL));
        olHChk(pstm->Seek(lPos, STREAM_SEEK_SET, NULL));
        olHChk(pstm->Read(buf, (sizeof(NUMBERS)&~1)*2, &cb));
        if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2) ||
            memcmp(buf+sizeof(NUMBERS)/2, NUMBERS, sizeof(NUMBERS)/2) ||
            memcmp(buf+(sizeof(NUMBERS)&~1), NUMBERS, sizeof(NUMBERS)/2) ||
            memcmp(buf+3*(sizeof(NUMBERS)/2), NUMBERS, sizeof(NUMBERS)/2))
            error(EXIT_BADSC, "Stream contents incorrect\n");
        verify( 0 == pstmC->Release());
    }

EH_Err:

    if (pstm) verify( 0 == pstm->Release() );
    if (pstm1) verify( 0 == pstm1->Release() );
    if (pstm2) verify( 0 == pstm2->Release() );
    if (pstg) verify( 0 == pstg->Release() );
    if (pstg1) verify( 0 == pstg1->Release() );
    if (pstg2) verify( 0 == pstg2->Release() );
    if (pstg3) verify( 0 == pstg3->Release() );
    
    if (pilb) verify( 0 == pilb->Release() );

    return sc;
}

SCODE t_stgmisc(void)
{
    SCODE sc;
    IStorage *pstg;
    FILE *f;

    _unlink("drt.dfl");
    // create zero byte file
    f= fopen("drt.dfl", "w+b");
    fclose(f);


    olAssert(StgIsStorageFile(ocsDRT)==S_FALSE);

    _unlink("drt.dfl");
    olHChk(StgCreateDocfile(ocsDRT, 
                            STGM_READWRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE,
                            0, 
                            &pstg));

    olAssert(StgIsStorageFile(ocsDRT)==S_OK);
    pstg->Release();

EH_Err:
    return sc;
}

void terminate(void)
{
	printf("Terminate() called!\n");
	exit(-1);
}

int main(int argc, char** argv)
{
    SCODE sc;
    int fCreate=0;

    // change the following line to whatever number to detect mem leaks
    //_CrtSetBreakAlloc(146);

    // initialize the strings
    INIT_OLESTR(ocsDRT,    "drt.dfl");
    INIT_OLESTR(ocsChild,  "Child");
    INIT_OLESTR(ocsChild1, "Child1");
    INIT_OLESTR(ocsChild2, "Child2");
    INIT_OLESTR(ocsStream, "Stream");
    INIT_OLESTR(ocsRenamedStream, "RenamedStream");
    INIT_OLESTR(ocsRenamedChild,  "RenamedChild");

    printf("Reference storage tests:\n");
    printf("Optional features:\n");
    printf("Use '%s c' to create a test file\n", argv[0]);
    printf("Use '%s r' to verify read of the test file\n", argv[0]);
    printf("-----\n");

    if (argc==2) {
        printf(" * Interops testing --- ");
        
        if (*(argv[1])=='c')	 {
            printf("Create\n");
            fCreate=1;
        }
        else if (*(argv[1])=='r')
            printf("Read\n");
        else {
            printf("Wrong args: usage\nreftest [c|r]\nc - Create\nr - read\n");
            return 0;
        }
        
	g_fTestInterop = 1;
    }

    if (g_fTestInterop)
    {
        olChk(t_stream(FALSE, fCreate));
        printf("\nTests passed successfully.\n");
        exit(0);
    }

    printf("\nTesting ILockBytes\n\n");

    olChk(t_create(FALSE));
    olChk(t_open(FALSE));
    olChk(t_addref(FALSE));
    olChk(t_stream(FALSE));
    olChk(t_stat(FALSE));
    olChk(t_dmodify(FALSE));
    
    printf("\nTesting Storage\n\n");
    olChk(t_create(TRUE));
    olChk(t_open(TRUE));
    olChk(t_addref(TRUE));
    olChk(t_dmodify(TRUE));
    olChk(t_stream(TRUE));
    olChk(t_stat(TRUE));
    olChk(t_stgmisc());
    
    printf("\nTests passed successfully.\n");
    exit(0);
    
EH_Err:
    printf("Tests failed with error %lX\n",sc);
    exit(EXIT_BADSC);
    return 0;
}

#ifdef _MSC_VER
// some of these functions are a nuisance 
#pragma warning (disable:4127)  // conditional expression is constant
#pragma warning (disable:4514)  // unreferenced inline function
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\reftest\refilb.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	refilb.cxx
//
//  Contents:	Reference ILockBytes class
//
//  Classes:	CFileILB
//
//  Notes:      This Class always call single byte I/O routines
//              because most systems only have support for single byte
//              I/O. This makes the code more portable.
//
//----------------------------------------------------------------------------

#include <errno.h>
#include "refilb.hxx"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <sys/stat.h>
#include "time.hxx"

#ifdef _WIN32
#include <io.h> // to get definition of wunlink
#else
#include <unistd.h>
#define _stat stat
#define _tstat stat
#endif

#include <stdlib.h>
#include <assert.h>

#ifdef PRINT_TRACE
#define TRACE(x) printf(x)
#else
#define TRACE(x)
#endif

static int filenum = 0;

char * GetTempFileName(void)
{
    char *psz = new char[_MAX_PATH +1];
    strcpy(psz, "dft");

    _itoa(filenum, psz + 3, 10);
    filenum++;
    return psz;
}

CFileILB::CFileILB(const TCHAR *pszName,
                   DWORD grfMode,
                   BOOL fOpenFile/* =TRUE */)
{
    _pszName = NULL;

    _fDelete = FALSE;
    if (pszName == NULL)
    {
         _pszName = GetTempFileName();
         _unlink(_pszName);            // make sure file is over written
         _fDelete |= ILB_DELETEONERR;  // don't want to keep scratch files
    }
    else
    {
        _pszName = new char[_MAX_PATH + 1];
        TTOS(pszName, _pszName, _tcslen(pszName)+1);
    }

    if (grfMode & STGM_DELETEONRELEASE)
        _fDelete |= ILB_DELETEONRELEASE;
    _f = NULL;
    if (fOpenFile)
    {
        // disregard if file is already there
	Create(STGM_CREATE|STGM_READWRITE);
        // got to open the file with this option
        assert(_f && "CFileILB could not open the file!");
    }
    _ulRef = 1;
}

static const char pcszReadOnly[] ="rb";
static const char pcszReadWrite[] = "r+b";
static const char pcszWrite[] = "w+b";

SCODE CFileILB::Create(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        TRACE("CFileILB::Create called with Read Only!!\n");

    _f = fopen(_pszName, pszMode);
    if (_f)                     // open succeeded
    {
        if ((grfMode & (STGM_CREATE|STGM_CONVERT) ) == STGM_FAILIFTHERE)
            return STG_E_FILEALREADYEXISTS;
    }
    else if (errno==EACCES && (grfMode & STGM_CONVERT))
    {
        TRACE("Access Denied in CFileILB::Create\n");
        return STG_E_ACCESSDENIED;
    }
    else
    {
        // the file does not exists, create the file
        _f = fopen(_pszName, pcszWrite);
        if (_f==NULL)
        {
            // we could not create the file for some reason
            // return the appropriate error code
            if (errno== EACCES)
                return STG_E_ACCESSDENIED;
            else
            {
                return STG_E_INVALIDNAME; // assume it is an invalid name
            }
        }
        else
        {
            // the newly create file should be deleted on error
            _fDelete |= ILB_DELETEONERR;
        }
    }
    return S_OK;
}

SCODE CFileILB::Open(DWORD grfMode)
{
    char const *pszMode = pcszReadOnly; // default

    assert( (_fDelete & ILB_DELETEONERR)==0 ); // this means an null named file
                                                  // has been opened
    if (grfMode & STGM_READWRITE)
        pszMode = pcszReadWrite;
    else
        TRACE( "CFileILB::Open called with Read Only!!\n");

    _f = fopen(_pszName, pszMode);
    if (_f == NULL)
    {
        if (errno==EACCES) return STG_E_ACCESSDENIED;
        else if (errno==ENOENT) return STG_E_FILENOTFOUND;
        else return STG_E_INVALIDNAME; // we assume that the name is invalid
    }

    return S_OK;
}

CFileILB::~CFileILB()
{
    if (_f)
        fclose(_f);
    if (_fDelete & ILB_DELETEONRELEASE)
    {
         // nothing we can do if the file cannot be deleted somehow
         // since the ref impl. is not multi-thread safe
        _unlink(_pszName);
    }
    delete _pszName;
}

STDMETHODIMP CFileILB::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    UNREFERENCED_PARM(riid);
    //olAssert(FALSE && "function not implemented!");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

STDMETHODIMP_(ULONG) CFileILB::AddRef(void)
{
    _ulRef++;
    return(_ulRef);
}

STDMETHODIMP_(ULONG) CFileILB::Release(void)
{
    _ulRef--;
    TRACE("CFileILB::Release%lx\n");
    if (_ulRef > 0)
        return(_ulRef);
    delete this;

    return(0);
}

ULONG CFileILB::ReleaseOnError(void)
{
    // this function should be not used otherwise
    assert(_ulRef == 1);

    // Delete the file if it is a file we just created
    if (_fDelete & ILB_DELETEONERR)
        _fDelete |= ILB_DELETEONRELEASE;
    return( Release() );
}

STDMETHODIMP CFileILB::ReadAt(ULARGE_INTEGER ulPosition,

        VOID HUGEP *pb,
        ULONG cb,
        ULONG *pcbRead)
{
    fseek(_f, ulPosition.LowPart, SEEK_SET);

    *pcbRead = fread(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::WriteAt(ULARGE_INTEGER ulPosition,
        VOID const HUGEP *pb,
        ULONG cb,
        ULONG FAR *pcbWritten)
{
    fseek(_f, ulPosition.LowPart, SEEK_SET);

    *pcbWritten = fwrite(pb, 1, cb, _f);
    return NOERROR;
}

STDMETHODIMP CFileILB::Flush(void)
{
    fflush(_f);
    return NOERROR;
}

STDMETHODIMP CFileILB::SetSize(ULARGE_INTEGER ulNewSize)
{
    LONG cbNewSize = ulNewSize.LowPart;
    LONG cbCurrentSize = ftell(_f);
    if(-1 == cbCurrentSize)
        return STG_E_SEEKERROR;

    if(cbCurrentSize < cbNewSize)
    {                                       // Increase the Size
        fseek(_f, cbNewSize-1, SEEK_SET);
        if(1 != fwrite("", 1, 1, _f))
            return STG_E_WRITEFAULT;
    }
    else if(cbCurrentSize > cbNewSize)
    {                                       // Decrease the Size
        //  OS specific: file truncation.
    }
    return NOERROR;
}

STDMETHODIMP CFileILB::LockRegion(ULARGE_INTEGER libOffset,
                                  ULARGE_INTEGER cb,
                                  DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    assert(FALSE && "function not implemented!");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    UNREFERENCED_PARM(dwLockType);
    UNREFERENCED_PARM(cb);
    UNREFERENCED_PARM(libOffset);
    assert(FALSE && "function not implemented!");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}


STDMETHODIMP CFileILB::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
         char pchTemp[_MAX_PATH+1];
        _fullpath(pchTemp, _pszName, _MAX_PATH+1);
        pstatstg->pwcsName = new TCHAR[strlen(pchTemp)+1];
        STOT(pchTemp, pstatstg->pwcsName, strlen(pchTemp)+1);
    }

    pstatstg->type = STGTY_LOCKBYTES;

    (pstatstg->cbSize).HighPart = 0;

    fseek(_f, 0, SEEK_END);
    (pstatstg->cbSize).LowPart = ftell(_f);

    // just return a default, the function that calls this should fill in
    // the structure.
    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    struct _stat buf;
    int result = _stat(_pszName, &buf);
    if (!result)  // fill in zeros
    {
        pstatstg->atime.dwLowDateTime = pstatstg->atime.dwLowDateTime = 0;
        pstatstg->mtime.dwLowDateTime = pstatstg->mtime.dwLowDateTime = 0;
        pstatstg->ctime.dwLowDateTime = pstatstg->ctime.dwLowDateTime = 0;
    }
    else
    {
        TimeTToFileTime(&buf.st_atime, &pstatstg->atime);
        TimeTToFileTime(&buf.st_mtime, &pstatstg->mtime);
        TimeTToFileTime(&buf.st_ctime, &pstatstg->ctime);
    }
    return NOERROR;
}

EXTERN_C STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return (memcmp(&rguid1, &rguid2, sizeof(GUID)) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\drt.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       drt.cxx
//
//  Contents:   DRT main routine
//
//---------------------------------------------------------------

#include "headers.cxx"
#include "../../h/dbg.hxx"

#include "tests.hxx"
#include "illeg.hxx"

// Test flags and type
typedef ULONG FLAGS;

#define TF_NONE                 0x00000000

// Suppression flags
#define TF_SUPPRESS             0x0000FFFF
#define TFS_ILLEGITIMATE        0x00000001
#define TFS_16BIT               0x00000002

// Enabling flags
#define TF_ENABLE               0xFFFF0000
#define TFE_DIRECT              0x00010000
#define TFE_ANY                 (TFE_DIRECT)

// Pointer to a test function
typedef void (*TestFn)(void);

static struct
{
    char *pszName;
    char *pszDesc;
    TestFn tfn;
    FLAGS flags;
} tests[] =
{
    "Create",   "Creation",
        t_create, TFE_ANY,
    "Open",     "Opening",
        t_open, TFE_ANY,
    "AddRef",   "AddRef/Release",
        t_addref, TFE_ANY,
    "DModify",  "Direct modifications",
        t_dmodify, TFE_DIRECT,
    "Stat",     "Stat",
        t_stat, TFE_ANY,
    "Stream",   "Stream operations",
        t_stream, TFE_ANY,
    "Enum",     "Enumerator operations",
        t_enum, TFE_ANY,
    "StgCopyTo", "IStorage::CopyTo",
        t_stgcopyto, TFE_ANY,
    "MoveCopy", "IStorage::MoveElementTo",
        t_movecopy, TFE_ANY,
    "ILockBytes", "ILockBytes usage",
        t_ilb, TFE_ANY,
    "StgMisc",  "Miscellaneous Stg functions",
        t_stgmisc, TFE_ANY,
    "IllStg", "Illegitimate IStorage calls", 
        i_storage, TFE_ANY | TFS_ILLEGITIMATE,
    "IllStm", "Illegitimate IStream calls",
        i_stream, TFE_ANY | TFS_ILLEGITIMATE,
    "IllEnum", "Illegitimate enumerator calls",
        i_enum, TFE_ANY | TFS_ILLEGITIMATE
};
#define NTESTS (sizeof(tests)/sizeof(tests[0]))

DWORD dwRootDenyWrite = STGM_SHARE_DENY_WRITE;
BOOL fVerbose = FALSE;
OLECHAR atcDrtDocfile[_MAX_PATH];

static BOOL fRun[NTESTS];
#ifdef FLAT
static FLAGS flTests = TF_NONE;
#else
static FLAGS flTests = TF_NONE | TFS_16BIT;
#endif

static void Initialize(void)
{
    SetData();
}

static void Uninitialize(void)
{
    UnsetData();
}

static int FindTest(char *pszName)
{
    int i, cchName;

    cchName = strlen(pszName);
    for (i = 0; i<NTESTS; i++)
        if (!_strnicmp(pszName, tests[i].pszName, cchName))
            return i;
    return -1;
}

static void RunTests(void)
{
    int i;

    for (i = 0; i<NTESTS; i++)
        // For a test to run:
        // 1)  fRun[test] must be TRUE
        // 2)  No suppression flags can be set that are not set in flTests
        // 3)  At least one enabling flag must be set that is set in flTests
        if (fRun[i] &&
            (tests[i].flags & ~flTests & TF_SUPPRESS) == 0 &&
            (tests[i].flags & flTests & TF_ENABLE) != 0)
        {
            out("\n----- Test #%2d - %s -----\n", i+1, tests[i].pszDesc);
            tests[i].tfn();
            CleanData();
        }
}

static void Usage(void)
{
    int i;

    printf("Usage: drt [options]\n");
    printf("Options are:\n");
    printf("  -h        - This message\n");
    printf("  -d        - Suppress direct tests\n");
    printf("  -i        - Enable illegitimate tests\n");
    printf("  -v        - Display test output\n");
    printf("  -#[+|-]<number>   - Turn test <number> on (+) or off (-)\n");
    printf("                      No number means all\n");
    printf("  -n[+|-]<prefix>   - Turn test <prefix> on or off\n");
    printf("  -N<file>  - Set file to use for tests\n");
    printf("Prefix can be any prefix of:\n");
    printf("HR=%lx\n", E_INVALIDARG);
    for (i = 0; i<NTESTS; i++)
        printf("  %s\n", tests[i].pszName);
    exit(1);
}

int __cdecl main(int argc, char **argv)
{
    int i, iTest;
    BOOL fDirect = TRUE;

    // change the following line to set mem check breakpoints
    // on win32, using debug CRT.
    //_CrtSetBreakAlloc();

    for (i = 0; i<NTESTS; i++)
        fRun[i] = TRUE;
    ATOOLE(pszDRTDF, atcDrtDocfile, _MAX_PATH);
    while (--argc>0)
    {
        if (**++argv == '-')
        {
            switch(argv[0][1])
            {
            case '#':
                if (sscanf(argv[0]+3, "%d", &iTest) != 1)
                    iTest = -1;
                else
                    iTest--;
                for (i = 0; i<NTESTS; i++)
                    if (iTest == -1 || iTest == i)
                        fRun[i] = argv[0][2] == '+';
                break;
            case 'd':
                fDirect = FALSE;
                break;
            case 'i':
                flTests |= TFS_ILLEGITIMATE;
                break;
            case 'n':
                iTest = FindTest(argv[0]+3);
                if (iTest >= 0)
                    fRun[iTest] = argv[0][2] == '+';
                break;
            case 'N':
                ATOOLE(argv[0]+2, atcDrtDocfile, _MAX_PATH);
                break;
            case 'v':
                fVerbose = TRUE;
                break;

            case 'h':
            default:
                Usage();
            }
        }
        else
            Usage();
    }

    Initialize();

    if (fDirect)
    {
        out("\n---------- Direct ----------\n");
        dwRootDenyWrite = STGM_SHARE_EXCLUSIVE;
        flTests |= TFE_DIRECT;
        RunTests();
        flTests &= ~TFE_DIRECT;
    }

    printf("Storage DRT - PASSED\n");

    Uninitialize();

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       headers.cxx
//
//  Contents:   Frequently used headers
//
//--------------------------------------------------------------------------

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../../h/storage.h"
#include "drt.hxx"
#include "wrap.hxx"
#include "util.hxx"
#include "strlist.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\strlist.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	strlist.cxx
//
//  Contents:	CStrList implementation
//
//---------------------------------------------------------------

#include "headers.cxx"

#include <string.h>

//+--------------------------------------------------------------
//
//  Member:	CStrList::CStrList, public
//
//  Synopsis:	Ctor
//
//---------------------------------------------------------------

CStrList::CStrList(void)
{
    _pseHead = NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::~CStrList, public
//
//  Synopsis:	Dtor
//
//---------------------------------------------------------------

CStrList::~CStrList(void)
{
    Empty();
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Add, public
//
//  Synopsis:	Adds a string to the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Pointer to entry or NULL
//
//---------------------------------------------------------------

SStrEntry *CStrList::Add(OLECHAR *ptcs)
{
    SStrEntry *pse;

    // One char of string already counted in sizeof
    pse = (SStrEntry *)new
        char[sizeof(SStrEntry)+olecslen(ptcs)*sizeof(OLECHAR)];
    if (pse == NULL)
	return NULL;
    pse->pseNext = _pseHead;
    pse->psePrev = NULL;
    if (_pseHead)
	_pseHead->psePrev = pse;
    _pseHead = pse;
    olecscpy(pse->atc, ptcs);
    return pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Remove, public
//
//  Synopsis:	Removes an entry from the list
//
//  Arguments:	[pse] - Entry
//
//---------------------------------------------------------------

void CStrList::Remove(SStrEntry *pse)
{
    if (pse->psePrev)
	pse->psePrev->pseNext = pse->pseNext;
    else
	_pseHead = pse->pseNext;
    if (pse->pseNext)
	pse->pseNext->psePrev = pse->psePrev;
    delete pse;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Find, public
//
//  Synopsis:	Attempts to find a string in the list
//
//  Arguments:	[ptcs] - String
//
//  Returns:	Entry or NULL
//
//---------------------------------------------------------------

SStrEntry *CStrList::Find(OLECHAR *ptcs)
{
    SStrEntry *pse;

    for (pse = _pseHead; pse; pse = pse->pseNext)
	if (!olecscmp(ptcs, pse->atc))
	    return pse;
    return NULL;
}

//+--------------------------------------------------------------
//
//  Member:	CStrList::Empty, public
//
//  Synopsis:	Frees all elements in list
//
//---------------------------------------------------------------

void CStrList::Empty(void)
{
    SStrEntry *pse;

    while (_pseHead)
    {
	pse = _pseHead->pseNext;
	delete _pseHead;
	_pseHead = pse;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\tests.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	tests.cxx
//
//  Contents:	DRT tests
//
//---------------------------------------------------------------
#ifdef _WIN32
// for win32 env, we use dll's and therefore have to define the GUIDs
#define INITGUID
#endif

#include "headers.cxx"

#include "tests.hxx"
#include "ilb.hxx"

void t_create(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;
    
    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(ocsChild, STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStorage(ocsChild2, STGP(WSTG_READWRITE), 0, 0,
			     &pstgChild2);
    pstgChild2->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild2->Commit(0);
    pstgChild2->Unwrap();
    pstgChild->Commit(0);
    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Unwrap();
}

void t_open(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		     0, &pstgRoot);
    CreateStructure(pstgRoot->GetI(), "dChild(dChild2(sStream))");
    pstgRoot->Commit(0);
    pstgRoot->Unwrap();

    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgOpenStorage(DRTDF, NULL, ROOTP(WSTG_READWRITE), NULL,
		    0, &pstgRoot);
    pstgRoot->OpenStorage(ocsChild, NULL, STGP(WSTG_READWRITE), NULL, 0,
			  &pstgChild);
    pstgChild->OpenStorage(ocsChild2, NULL, STGP(WSTG_READWRITE), NULL, 0,
			   &pstgChild2);
    pstgChild2->OpenStream(ocsStream, NULL, STMP(WSTG_READWRITE), 0,
			   &pstm);
    pstm->Unwrap();
    pstgChild2->Unwrap();
    pstgChild->Unwrap();
    pstgRoot->Unwrap();
}

void t_addref(void)
{
    WStorage *pstg;
    WStream *pstm;
    ULONG ul;

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstg);

    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    pstg->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
#ifndef FLAT
    if ((ul = pstm->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) != 2)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) != 1)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#else
    if ((ul = pstm->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstm->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    pstm->Unwrap();
    if ((ul = pstg->AddRef()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
    if ((ul = pstg->Release()) <= 0)
	error(EXIT_BADSC, "Wrong reference count - %lu\n", ul);
#endif
    pstg->Unwrap();
}

void t_dmodify(void)
{
    WStorage *pstgRoot, *pstgChild, *pstgChild2;
    WStream *pstm;
    ULONG cbSize1, cbSize2;

    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsChild2, "Child2");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(ocsChild, STGP(WSTG_READWRITE), 0,
                            0, &pstgChild);
    pstgChild->CreateStorage(ocsChild2, STGP(WSTG_READWRITE), 0,
			     0, &pstgChild2);
    pstgChild2->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Unwrap();
    VerifyStructure(pstgChild2->GetI(), "sStream");

    // Test renaming a closed stream
    DECLARE_OLESTR(ocsRenamedStream, "RenamedStream");
    pstgChild2->RenameElement(ocsStream, ocsRenamedStream);
    VerifyStructure(pstgChild2->GetI(), "sRenamedStream");

    // Test destroying a stream
    pstgChild2->DestroyElement(ocsRenamedStream);

    pstgChild2->Unwrap();
    VerifyStructure(pstgChild->GetI(), "dChild2()");

    // Test renaming a storage
    DECLARE_OLESTR(ocsRenamedChild, "RenamedChild");
    pstgChild->RenameElement(ocsChild2, ocsRenamedChild);
    pstgChild->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0,
			     &pstm);
    pstm->Unwrap();
    pstgChild->DestroyElement(ocsStream);

    // Test SetElementTimes
    FILETIME tm;
    STATSTG stat;

    tm.dwLowDateTime = 0x12345678;
    tm.dwHighDateTime = 0x01bcdef0;

    // Set when element not open
    pstgChild->SetElementTimes(ocsRenamedChild, &tm, NULL, NULL);
    pstgChild->SetElementTimes(ocsRenamedChild, NULL, &tm, NULL);
    pstgChild->SetElementTimes(ocsRenamedChild, NULL, NULL, &tm);

    pstgChild->OpenStorage(ocsRenamedChild, NULL, STMP(WSTG_READWRITE),
                           NULL, 0, &pstgChild2);
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualTime(stat.ctime, tm) ||
        !IsEqualTime(stat.mtime, tm))
        error(EXIT_BADSC, "Times don't match those set by SetElementTimes\n");

    // Test SetClass and SetStateBits
    pstgChild2->SetClass(IID_IStorage);
    fExitOnFail = FALSE;
    pstgChild2->SetStateBits(0xff00ff00, 0xffffffff);
    pstgChild2->SetStateBits(0x00880088, 0xeeeeeeee);
    fExitOnFail = TRUE;
    pstgChild2->Stat(&stat, STATFLAG_NONAME);
    if (!IsEqualCLSID(stat.clsid, IID_IStorage))
        error(EXIT_BADSC, "Class ID set improperly\n");
    if (stat.grfStateBits != 0x11881188)
        errorprint("State bits set improperly: has %lX vs. %lX\n",
              stat.grfStateBits, 0x11881188);
    pstgChild2->Unwrap();

    pstgChild->Unwrap();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Revert();
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->Commit(0);
    VerifyStructure(pstgRoot->GetI(), "dChild(dRenamedChild())");
    pstgRoot->DestroyElement(ocsChild);
    VerifyStructure(pstgRoot->GetI(), "");

    // Verify that space is reclaimed after modifications
    pstgRoot->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize1 = Length(DRTDF);
    pstgRoot->DestroyElement(ocsStream);
    pstgRoot->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->SetSize(65536);
    pstm->Unwrap();
    cbSize2 = Length(DRTDF);
    if (cbSize1 != cbSize2)
        error(EXIT_BADSC, "Space is not being reclaimed, original %lu, "
              "now %lu\n", cbSize1, cbSize2);

    pstgRoot->Unwrap();

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgRoot);

    //  removal cases
    //    1) no right child

    CreateStructure(pstgRoot->GetI(), "d64,d32");
    VerifyStructure(pstgRoot->GetI(), "d64,d32");
    DECLARE_OLESTR(ocs64, "64");
    pstgRoot->DestroyElement(ocs64);
    VerifyStructure(pstgRoot->GetI(), "d32");

    //    2) right child has no left child

    CreateStructure(pstgRoot->GetI(), "d64");
    VerifyStructure(pstgRoot->GetI(), "d32,d64");
    DECLARE_OLESTR(ocs32, "32");
    pstgRoot->DestroyElement(ocs32);
    VerifyStructure(pstgRoot->GetI(), "d64");

    //    3) right child has left child

    CreateStructure(pstgRoot->GetI(), "d96,d80");
    VerifyStructure(pstgRoot->GetI(), "d64,d80,d96");
    pstgRoot->DestroyElement(ocs64);
    VerifyStructure(pstgRoot->GetI(), "d80,d96");

    //    4) right child's left child has children

    CreateStructure(pstgRoot->GetI(), "d88,d84,d92");
    VerifyStructure(pstgRoot->GetI(), "d80,d84,d88,d92,d96");
    DECLARE_OLESTR(ocs80, "80");
    pstgRoot->DestroyElement(ocs80);
    VerifyStructure(pstgRoot->GetI(), "d84,d88,d92,d96");

    pstgRoot->Unwrap();

}

void t_stat(void)
{
    WStorage *pstgRoot, *pstgChild;
    WStream *pstm;
    STATSTG stat;
    DECLARE_OLESTR(ocsChild, "Child");
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE,
		      0, &pstgRoot);
    pstgRoot->CreateStorage(ocsChild, STGP(WSTG_READWRITE), 0, 0,
			    &pstgChild);
    pstgChild->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);

    pstm->Stat(&stat, 0);
    VerifyStat(&stat, ocsStream, STGTY_STREAM, STMP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstm->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STREAM, STMP(WSTG_READWRITE));

    pstm->Unwrap();

    pstgChild->Stat(&stat, 0);
    VerifyStat(&stat, ocsChild, STGTY_STORAGE, STGP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgChild->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, STGP(WSTG_READWRITE));

    pstgChild->Unwrap();

    pstgRoot->Stat(&stat, 0);
    OLECHAR atcFullPath[_MAX_PATH+1];
    GetFullPath(DRTDF, atcFullPath, _MAX_PATH+1);
    VerifyStat(&stat, atcFullPath, STGTY_STORAGE, ROOTP(WSTG_READWRITE));
    drtMemFree(stat.pwcsName);

    pstgRoot->Stat(&stat, STATFLAG_NONAME);
    VerifyStat(&stat, NULL, STGTY_STORAGE, ROOTP(WSTG_READWRITE));

    pstgRoot->Unwrap();
}

static char NUMBERS[] = "12345678901234567890123456789012345678901234567890";

void t_stream(void)
{
    WStorage *pstg;
    WStream *pstm, *pstmC;
    char buf[sizeof(NUMBERS)*2];
    ULONG cb, ulPos;
    DECLARE_OLESTR(ocsStream, "Stream");

    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    pstg->CreateStream(ocsStream, STMP(WSTG_READWRITE), 0, 0, &pstm);
    pstm->Write(NUMBERS, sizeof(NUMBERS), &cb);
    pstm->Commit(0);
    pstm->Seek(0, WSTM_SEEK_SET, &ulPos);
    if (ulPos != 0)
	error(EXIT_BADSC, "Incorrect seek, ptr is %lu\n", ulPos);
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    if (strcmp(buf, NUMBERS))
	error(EXIT_BADSC, "Incorrect stream contents\n");
    pstm->SetSize(sizeof(NUMBERS)/2);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    fExitOnFail = FALSE;
    pstm->Read(buf, sizeof(NUMBERS), &cb);
    fExitOnFail = TRUE;
    if (cb != sizeof(NUMBERS)/2)
	error(EXIT_BADSC, "SetSize failed to size stream properly\n");
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "SetSize corrupted contents\n");
    pstm->Clone(&pstmC);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)/2, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->CopyTo(pstmC, sizeof(NUMBERS)&~1, NULL, NULL);
    pstm->Seek(0, WSTM_SEEK_SET, NULL);
    pstm->Read(buf, (sizeof(NUMBERS)&~1)*2, &cb);
    if (memcmp(buf, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+sizeof(NUMBERS)/2, NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+(sizeof(NUMBERS)&~1), NUMBERS, sizeof(NUMBERS)/2) ||
	memcmp(buf+3*(sizeof(NUMBERS)/2), NUMBERS, sizeof(NUMBERS)/2))
	error(EXIT_BADSC, "Stream contents incorrect\n");
    pstmC->Unwrap();
    pstm->Unwrap();
    pstg->Unwrap();
}

// Number of entries for enumeration test
#define ENUMENTRIES 10

// Flag indicating a name has already shown up in enumeration,
// must not conflict with STGTY_*
#define ENTRY_SEEN 0x100

// Check the validity of an enumeration element
static void elt_check(STATSTG *pstat, CStrList *psl)
{
    SStrEntry *pse;

    pse = psl->Find(pstat->pwcsName);
    if (pse == NULL)
        error(EXIT_BADSC, "Spurious element '%s'\n", pstat->pwcsName);
    else if ((pse->user.dw & ~ENTRY_SEEN) != pstat->type)
        error(EXIT_BADSC, "Element '%s' has wrong type - "
              "has %lX vs. %lX\n", pstat->pwcsName, pstat->type,
              pse->user.dw & ~ENTRY_SEEN);
    else if (pse->user.dw & ENTRY_SEEN)
        error(EXIT_BADSC, "Element '%s' has already been seen\n",
              pstat->pwcsName);
    pse->user.dw |= ENTRY_SEEN;
}

// Do final validity checks for enumeration
static void enum_list_check(CStrList *psl)
{
    SStrEntry *pse;

    for (pse = psl->GetHead(); pse; pse = pse->pseNext)
    {
        if ((pse->user.dw & ENTRY_SEEN) == 0)
            error(EXIT_BADSC, "Element '%s' not found\n", pse->atc);
        pse->user.dw &= ~ENTRY_SEEN;
    }
}

void t_enum(void)
{
    int i;    
    char pchName[CWCSTORAGENAME];
    OLECHAR atcName[CWCSTORAGENAME];
    WStorage *pstg, *pstg2;
    WStream *pstm;
    SStrEntry *pse;
    CStrList sl;

    // Create some entries to enumerate
    WStgCreateDocfile(DRTDF, ROOTP(WSTG_READWRITE) | WSTG_CREATE, 0, &pstg);
    for (i = 0; i<ENUMENTRIES; i++)
    {
	sprintf(pchName, "Name%d", rand());
        STOT(pchName, atcName, strlen(pchName)+1);
	pse = sl.Add(atcName);
	if (rand()%100 < 50)
	{
	    pse->user.dw = STGTY_STORAGE;
	    pstg->CreateStorage(atcName, STGP(WSTG_READWRITE), 0, 0, &pstg2);
	    pstg2->Unwrap();
	}
	else
	{
	    pse->user.dw = STGTY_STREAM;
	    pstg->CreateStream(atcName, STMP(WSTG_READWRITE), 0, 0, &pstm);
	    pstm->Unwrap();
	}
    }

    WEnumSTATSTG *penm;
    STATSTG stat[2*ENUMENTRIES];
    SCODE sc;

    // Test plain, single element enumeration
    pstg->EnumElements(0, NULL, 0, &penm);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, stat, NULL));
	if (sc == S_FALSE)
	    break;
        elt_check(stat, &sl);
        drtMemFree(stat->pwcsName);

    }
    enum_list_check(&sl);

    ULONG cFound;

    // Test rewind and multiple element enumeration with too many elements
    penm->Reset();
    sc = DfGetScode(penm->Next(ENUMENTRIES*2, stat, &cFound));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    enum_list_check(&sl);

    // Test skip and multiple enumeration with exact number of elements
    penm->Reset();
    penm->Skip(ENUMENTRIES/2);
    sc = DfGetScode(penm->Next(ENUMENTRIES-ENUMENTRIES/2, stat, &cFound));
    if (sc != S_OK)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_OK\n", ScText(sc), sc);
    if (cFound != ENUMENTRIES-ENUMENTRIES/2)
        error(EXIT_BADSC, "Enumerator found %lu entries instead of "
              "%d entries\n", cFound, ENUMENTRIES-ENUMENTRIES/2);
    for (; cFound > 0; cFound--)
    {
        elt_check(&stat[cFound-1], &sl);
        drtMemFree(stat[cFound-1].pwcsName);
    }
    sc = DfGetScode(penm->Next(1, stat, NULL));
    if (sc != S_FALSE)
        error(EXIT_BADSC, "Enumerator returned %s (%lX) instead of "
              "S_FALSE\n", ScText(sc), sc);

    penm->Unwrap();
    pstg->Unwrap();
}

#define SCT_CLASSID IID_ILockBytes
#define SCT_STATEBITS 0xfef1f0f0

void t_stgcopyto(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    // Set some interesting values to make sure they're copied
    pstgFrom->SetClass(SCT_CLASSID);
    fExitOnFail = FALSE;
    pstgFrom->SetStateBits(SCT_STATEBITS, 0xffffffff);
    fExitOnFail = TRUE;

    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");
    CreateStructure(pstgTo->GetI(), "dA(dY(sZ),sBs)");

    pstgFrom->CopyTo(0, NULL, NULL, pstgTo);

    VerifyStructure(pstgTo->GetI(),
		    "dA(dB(dC(sA,sB,sC),sCs),dY(sZ),sBs),sAs");
    pstgTo->Stat(&statTo, 0);
    if (!IsEqualCLSID(statTo.clsid, SCT_CLASSID))
        error(EXIT_BADSC, "Class ID mismatch after copy\n");
    if (statTo.grfStateBits != SCT_STATEBITS)
        errorprint("State bits mismatch: has %lX vs. %lX\n",
              statTo.grfStateBits, SCT_STATEBITS);

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}

void t_stgmisc(void)
{
    WStorage *pstg;
    SCODE sc;
    STATSTG stat;

    // Can't make this call in transacted mode because we want
    // the storage signature to make it into the file right away
    WStgCreateDocfile(DRTDF, WSTG_READWRITE | WSTG_CREATE |
	WSTG_SHARE_EXCLUSIVE, 0, &pstg);

    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open file - Should be a storage object\n");
    pstg->Unwrap();
    sc = DfGetScode(WStgIsStorageFile(DRTDF));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Closed file - Should be a storage object\n");
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
	    WSTG_DELETEONRELEASE, 0, &pstg);
    pstg->Stat(&stat, 0);
    if (!Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not created\n", stat.pwcsName);
    pstg->Unwrap();
    if (Exists(stat.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted on release\n",
	    stat.pwcsName);
    drtMemFree(stat.pwcsName);
}

void t_ilb(void)
{
    WStorage *pstg;
    SCODE sc;
    //  create an ILockBytes

    ILockBytes *pilb = new CMapBytes();
    if (pilb == NULL)
	error(EXIT_BADSC, "Unable to allocate an ILockBytes\n");

    //  create a storage on the ILockBytes

    WStgCreateDocfileOnILockBytes(pilb,
				  WSTG_READWRITE |
                                  WSTG_CREATE    |
                                  WSTG_SHARE_EXCLUSIVE,
                                  0, &pstg);

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));
    if (sc == S_FALSE)
	error(EXIT_BADSC, "Open ILockBytes - Should be a storage object\n");

    //  release the storage

    pstg->Unwrap();

    //  verify the ILockBytes

    sc = DfGetScode(WStgIsStorageILockBytes(pilb));

    if (sc == S_FALSE)
	error(EXIT_BADSC, "Released ILockBytes - Should be a storage object\n");

    //  open the ILockBytes

    WStgOpenStorageOnILockBytes(pilb, NULL, ROOTP(WSTG_READWRITE),
				NULL, 0, &pstg);


    //  release the storage

    pstg->Unwrap();

    //  release the ILockBytes

    pilb->Release();
}

void t_movecopy(void)
{
    WStorage *pstgFrom, *pstgTo;
    STATSTG statFrom, statTo;

    //  create a source
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgFrom);
    pstgFrom->Stat(&statFrom, 0);

    //  create a destination
    WStgCreateDocfile(NULL, ROOTP(WSTG_READWRITE) | WSTG_CREATE |
		      WSTG_DELETEONRELEASE, 0, &pstgTo);
    pstgTo->Stat(&statTo, 0);

    //  populate source
    CreateStructure(pstgFrom->GetI(), "dA(dB(dC(sA,sB,sC),sCs),sBs),sAs");

    DECLARE_OLESTR(ocsM, "M");
    DECLARE_OLESTR(ocsA, "A");
    //  move a storage
    pstgFrom->MoveElementTo(ocsA, pstgTo, ocsM, STGMOVE_MOVE);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs)");

    //  copy a stream
    DECLARE_OLESTR(ocsBs, "Bs");
    DECLARE_OLESTR(ocsAs, "As");
    pstgFrom->MoveElementTo(ocsAs, pstgTo, ocsBs, STGMOVE_COPY);
    VerifyStructure(pstgFrom->GetI(),
                    "sAs");
    VerifyStructure(pstgTo->GetI(),
                    "dM(dB(dC(sA,sB,sC),sCs),sBs),sBs");

    pstgFrom->Unwrap();
    pstgTo->Unwrap();
    if (Exists(statFrom.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statFrom.pwcsName);
    drtMemFree(statFrom.pwcsName);
    if (Exists(statTo.pwcsName))
	error(EXIT_BADSC, "Storage '%s' not deleted\n", statTo.pwcsName);
    drtMemFree(statTo.pwcsName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\illeg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	illeg.cxx
//
//  Contents:	Illegitimate tests
//
//----------------------------------------------------------------------------

#include "headers.cxx"

#ifdef _WIN32
#include <io.h>
#else 
#include <unistd.h>
#include "winio.hxx"
#endif

#include <fcntl.h>
#ifdef _WIN32
#include <sys\types.h>
#include <sys\stat.h>
#else // war of the slashes
#include <sys/types.h> 
#include <sys/stat.h>
#endif

#include "illeg.hxx"

void i_storage(void)
{
    WStorage *pwstg;
    IStorage *pstg, *pstg2;
    WStorage *pw1;
    IStream *pstm;

    IllResult("StgCreateDocfile with NULL ppstg",
             StgCreateDocfile(NULL, ROOTP(STGM_READWRITE), 0, NULL));
    IllResult("StgCreateDocfile with non-zero reserved",
             StgCreateDocfile(NULL, ROOTP(STGM_READWRITE), 1, &pstg));
    IllResult("StgCreateDocfile with illegal permissions",
             StgCreateDocfile(NULL, 0, 0, &pstg));

    int fd;
    fd = _creat(OlecsOut(DRTDF), _S_IREAD);
    if (fd<0)
        error(EXIT_BADSC, "Unable to create file '%s'\n", OlecsOut(DRTDF));
    _close(fd);
    IllResult("StgCreateDocfile with STGM_WRITE over read-only file",
             StgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pstg));
    _chmod(OlecsOut(DRTDF), _S_IREAD | _S_IWRITE);

    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE)|STGM_CREATE, 0, &pw1);
    pw1->Commit(0);
    pw1->Unwrap();

    IllResult("StgOpenStorage with NULL ppstg",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL, 0, NULL));
    IllResult("StgOpenStorage with NULL name",
             StgOpenStorage(NULL, NULL, STGP(WSTG_READWRITE), NULL, 0, &pstg));
    IllResult("StgOpenStorage with illegal permissions",
             StgOpenStorage(DRTDF, NULL, 0xffffffff, NULL, 0, &pstg));
    IllResult("StgOpenStorage with non-zero reserved",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            1, &pstg));

    fd = _creat(OlecsOut(DRTDF), _S_IREAD | _S_IWRITE);
    if (fd<0) error(EXIT_BADSC, "Unable to create file '%s'\n", OlecsOut(DRTDF));
    _close(fd);

#if WIN32 != 300
    IllResult("StgOpenStorage on non-docfile",
             StgOpenStorage(DRTDF, NULL, ROOTP(STGM_READWRITE), NULL,
                            0, &pstg));
#endif

    DECLARE_OLESTR(ocsNoName, "NoName");
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE) | STGM_CREATE, 0, &pwstg);
    pstg = pwstg->GetI();
    IllResult("OpenStream that doesn't exist",
             pstg->OpenStream(ocsNoName, 0, STMP(STGM_READWRITE),
                              0, &pstm));
    IllResult("OpenStorage that doesn't exist",
             pstg->OpenStorage(ocsNoName, NULL, STGP(STGM_READWRITE),
                               NULL, 0, &pstg2));
    pwstg->Unwrap();
}

#define STREAMSIZE 128

void i_stream(void)
{
    WStorage *pwstg;
    WStream *pwstm;
    IStream *pstm;
    BYTE bBuffer[STREAMSIZE];
    ULONG cbRead;
    LARGE_INTEGER liSeek;    
    ULARGE_INTEGER uliSize;    

    DECLARE_OLESTR(ocsStream, "Stream");
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pwstg->CreateStream(ocsStream, STMP(STGM_READ), 0, 0, &pwstm);
    pstm = pwstm->GetI();
    
    IllResult("Read with NULL buffer",
             pstm->Read(NULL, STREAMSIZE, NULL));
    fExitOnFail = FALSE;
    pwstm->Read(bBuffer, STREAMSIZE, &cbRead);
    fExitOnFail = TRUE;
    if (cbRead != 0)
        error(EXIT_BADSC, "Read %lu bytes on zero-length stream\n", cbRead);

    IllResult("Write with NULL buffer",
             pstm->Write(NULL, STREAMSIZE, NULL));
    IllResult("Write on read-only stream",
             pstm->Write(bBuffer, STREAMSIZE, NULL));

    LISet32(liSeek, 0);
    IllResult("Seek with invalid origin",
             pstm->Seek(liSeek, (DWORD)(~STREAM_SEEK_SET), NULL));
#ifdef _MSC_VER
#pragma warning(disable:4245)
    // LISet32 in objbase.h has a bug that issues warning for negative values
#endif
    LISet32(liSeek, (ULONG) -1);
#ifdef _MSC_VER
#pragma warning(default:4245)
#endif
    IllResult("Seek before beginning",
             pstm->Seek(liSeek, STREAM_SEEK_CUR, NULL));

    ULISet32(uliSize, STREAMSIZE);
    IllResult("SetSize on read-only stream",
             pstm->SetSize(uliSize));
    
    pwstm->Unwrap();
    pwstg->Unwrap();
}

void i_enum(void)
{
    WStorage *pwstg;
    IStorage *pstg;
    IEnumSTATSTG *penm;
    
    WStgCreateDocfile(DRTDF, ROOTP(STGM_READWRITE), 0, &pwstg);
    pstg = pwstg->GetI();
    
    IllResult("EnumElements with NULL ppenm",
             pstg->EnumElements(0, NULL, 0, NULL));
    IllResult("EnumElements with non-zero reserved1",
             pstg->EnumElements(1, NULL, 0, &penm));
    IllResult("EnumElements with non-zero reserved2",
             pstg->EnumElements(0, (void *)1, 0, &penm));
    IllResult("EnumElements with non-zero reserved3",
             pstg->EnumElements(0, NULL, 1, &penm));
    
    pwstg->Unwrap();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\ilb.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	ilbmem.cx
//
//  Contents:	ILockBytes memory implementation
//
//  Classes:	CMapBytes
//
//--------------------------------------------------------------------------

#include "headers.cxx"

#include <memory.h>
#include "ilb.hxx"

#if DBG == 1
#ifndef _UNIX // on unix we use static lib, so the symbol is defined
DECLARE_INFOLEVEL(ol, DEB_ERROR);
#endif
#endif

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::CMapBytes, public
//
//  Synopsis:   constructor
//
//  Effects:    initialize member variables
//
//  Derivation: ILockBytes
//
//  Notes:      Returns a fully initialized CMapBytes (ref count == 1)
//
//--------------------------------------------------------------------------

CMapBytes::CMapBytes(void)
{
    _ulSize = 0;
    _pv = 0;

    _ulRef = 1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::QueryInterface, public
//
//  Arguments:	[riid] - interface id
//		[ppvObj] - place holder for interface
//
//  Returns:    Always fails
//
//  Derivation: ILockBytes
//
//  Notes:      Not used in tests
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = NULL;
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::AddRef, public
//
//  Synopsis:	add reference
//
//  Returns:    post reference count
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::AddRef(void)
{
    _ulRef++;
    return(_ulRef);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Release, public
//
//  Synopsis:	release reference
//
//  Effects:	deletes object when reference count reaches zero
//
//  Returns:	post reference count
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMapBytes::Release(void)
{
    _ulRef--;

    if (_ulRef > 0)
        return(_ulRef);

    free(_pv);

    delete this;

    return(0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::ReadAt
//
//  Synopsis:   Reads bytes from memory
//
//  Arguments:  [ulOffset] - byte offset
//		[pv]       - input buffer
//		[cb]       - count of bytes to read
//		[pcbRead]  - count of bytes read
//
//  Returns:    SCODE
//
//  Modifies:   pv, pcbRead
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::ReadAt(ULARGE_INTEGER uliOffset,
			       VOID HUGEP *pv,
			       ULONG cb,
			       ULONG *pcbRead)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    if (ulOffset >= _ulSize)
    {
        //  truncate read
        cb = 0;
    }
    else if (cb > (_ulSize - ulOffset))
    {
        //  truncate range that exceeds size
        cb = _ulSize - ulOffset;
    }

    memcpy(pv, (void*)(((BYTE*)_pv) + ulOffset), (size_t) cb);
    *pcbRead = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::WriteAt, public
//
//  Synopsis:	Writes bytes to memory
//
//  Effects:	May change memory size
//
//  Arguments:	[uliOffset]  - byte offset
//		[pv]         - output buffer
//		[cb]         - count of bytes to write
//		[pcbWritten] - count of bytes written
//
//  Returns:	SCODE
//
//  Modifies:	pcbWritten
//
//  Derivation: ILockBytes
//
//  Notes:	This implementation doesn't write partial buffers.
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::WriteAt(ULARGE_INTEGER uliOffset,
				VOID const HUGEP *pv,
				ULONG cb,
				ULONG FAR *pcbWritten)
{
    olAssert(ULIGetHigh(uliOffset) == 0);

    ULONG ulOffset = ULIGetLow(uliOffset);
    HRESULT hr;

    if (ulOffset + cb > _ulSize)
    {
        //  increase memory buffer to accomodate write

        ULARGE_INTEGER uliSize;

        ULISetHigh(uliSize, 0);
        ULISetLow(uliSize, ulOffset + cb);
        hr = SetSize(uliSize);

        if (FAILED(DfGetScode(hr)))
        {
            //  don't bother writing partial buffers

            *pcbWritten = 0;
            return hr;
        }
    }

    memcpy((void *)(((BYTE*)_pv) + ulOffset), pv, (size_t) cb);
    *pcbWritten = cb;
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Flush, public
//
//  Synopsis:	flushes memory - not appropriate for this implementation
//
//  Effects:	none
//
//  Returns:    SUCCESS_SUCCESS
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Flush(void)
{
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::GetSize, public
//
//  Synopsis:	gets memory buffer size
//
//  Arguments:	[pcb] - size place holder
//
//  Returns:	SUCCESS_SUCCESS
//
//  Modifies:	pcb
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::GetSize(ULARGE_INTEGER FAR *pcb)
{
    ULISetHigh(*pcb, 0);
    ULISetLow(*pcb, _ulSize);
    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::SetSize, public
//
//  Synopsis:	sets memory buffer size
//
//  Effects:	may change buffer size
//
//  Arguments:	[ulicb] - new memory size
//
//  Returns:	SCODE
//
//  Derivation: ILockBytes
//
//  Algorithm:  realloc the buffer
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::SetSize(ULARGE_INTEGER ulicb)
{
    olAssert(ULIGetHigh(ulicb) == 0);

    ULONG cb = ULIGetLow(ulicb);

    if (cb == _ulSize)
        return NOERROR;

    void *pv = realloc(_pv, (size_t) cb);

    if ((cb > 0) && (pv == NULL))
    {
        //  Unable to allocate memory
        //  Leave current memory and size alone

        return ResultFromScode(E_OUTOFMEMORY);
    }

    _pv = pv;
    _ulSize = cb;

    return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::LockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::LockRegion(ULARGE_INTEGER libOffset,
				   ULARGE_INTEGER cb,
				   DWORD dwLockType)
{
    olAssert(0 && "Can't lock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::UnLockRegion, public
//
//  Synopsis:	not supported (intentionally)
//
//  Effects:	asserts if called
//
//  Arguments:	[libOffset]  - lock range offset
//		[cb]         - lock range size
//		[dwLockType] - lock type
//
//  Returns:	STG_E_INVALIDFUNCTION
//
//  Derivation: ILockBytes
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::UnlockRegion(ULARGE_INTEGER libOffset,
				     ULARGE_INTEGER cb,
				     DWORD dwLockType)
{
    olAssert(0 && "Can't unlock CMapBytes");
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMapBytes::Stat, public
//
//  Synopsis:	Provide instance information
//
//  Arguments:	[pstatstg]    - status buffer
//		[grfStatFlag] - status flags
//
//  Returns:	SCODE
//
//  Modifies:	pstatstg
//
//  Derivation: ILockBytes
//
//  Notes:	No time stamps
//
//--------------------------------------------------------------------------

STDMETHODIMP CMapBytes::Stat(STATSTG FAR *pstatstg, DWORD grfStatFlag)
{
    memset(pstatstg, 0, sizeof(STATSTG));

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        static char const abName[] = "Memory";

        HRESULT hr;

        if (FAILED(DfGetScode(hr = drtMemAlloc(sizeof(abName),
                                             (void **) &pstatstg->pwcsName))))
            return hr;

        memcpy(pstatstg->pwcsName, abName, sizeof(abName));
    }

    pstatstg->type = STGTY_LOCKBYTES;

    ULISetHigh(pstatstg->cbSize, 0);
    ULISetLow(pstatstg->cbSize, _ulSize);

    pstatstg->grfMode = STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\util.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	util.cxx
//
//  Contents:	DRT support routines
//
//---------------------------------------------------------------

#include "headers.cxx"

#include <stdarg.h>
#ifdef _WIN32
#include <direct.h>
#include <io.h>
#else
#include "winio.hxx"
#endif

#define DEFAULT_DATA_DIR "."

BOOL fExitOnFail = TRUE;

char szOrigDir[_MAX_PATH] = ".";

// Preserve the current directory and change
// directory into the data directory
void SetData(void)
{
    char *pszDataDir;

    _getcwd(szOrigDir, _MAX_PATH);
    pszDataDir = getenv("DRTDATA");
    if (pszDataDir == NULL)
	pszDataDir = DEFAULT_DATA_DIR;
    _chdir(pszDataDir);
}

// Clean up the data directory
void CleanData(void)
{
    _unlink(pszDRTDF);
}

// Restore the original directory
void UnsetData(void)
{
    _chdir(szOrigDir);
}

// Output a message if fVerbose is true
void out(char *fmt, ...)
{
    va_list args;

    if (fVerbose)
    {
	va_start(args, fmt);
	vprintf(fmt, args);
	va_end(args);
    }
}

//  internal error print
void _errorprint (char *fmt, va_list args)
{
    printf("** Fatal error **: ");
    vprintf(fmt, args);
}

//  error print
void errorprint (char *fmt, ...)
{
    va_list args;

    va_start (args, fmt);

    _errorprint (fmt, args);

    va_end (args);
}

// Print out an error message and terminate the DRT
void error(int code, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);

    _errorprint (fmt, args);

    va_end(args);
    CleanData();
    UnsetData();
    exit(code);
}


// Converts a TCHAR string to a char pointer in a temporary buffer
// This implementation treats the conversion buffer as a circular
// buffer so more than one string can be held (depending on the size
// of the strings)

#define BUFSIZE 1024

char *OlecsOut(OLECHAR const *ptcs)
{
#ifdef OLEWIDECHAR
    static char szBuffer[BUFSIZE];
    static char *pszBuf = szBuffer;
    char *pszTmp;

    if (ptcs == NULL)
        return NULL;
    if (wcslen(ptcs) >= (size_t)(BUFSIZE-(pszBuf-szBuffer)))
        pszBuf = szBuffer;
    OLETOA(ptcs, pszBuf, BUFSIZE);
    szBuffer[BUFSIZE-1] = 0;
    pszTmp = pszBuf;
    pszBuf += strlen(pszBuf)+1;
    return pszTmp;
#else
    return (char *)ptcs;
#endif
}

typedef struct
{
    SCODE sc;
    char *text;
} StatusCodeText;

static StatusCodeText scodes[] =
{
    S_OK, "S_OK",
    S_FALSE, "S_FALSE",
    STG_E_INVALIDFUNCTION, "STG_E_INVALIDFUNCTION",
    STG_E_FILENOTFOUND, "STG_E_FILENOTFOUND",
    STG_E_PATHNOTFOUND, "STG_E_PATHNOTFOUND",
    STG_E_TOOMANYOPENFILES, "STG_E_TOOMANYOPENFILES",
    STG_E_ACCESSDENIED, "STG_E_ACCESSDENIED",
    STG_E_INVALIDHANDLE, "STG_E_INVALIDHANDLE",
    STG_E_INSUFFICIENTMEMORY, "STG_E_INSUFFICIENTMEMORY",
    STG_E_INVALIDPOINTER, "STG_E_INVALIDPOINTER",
    STG_E_NOMOREFILES, "STG_E_NOMOREFILES",
    STG_E_DISKISWRITEPROTECTED, "STG_E_DISKISWRITEPROTECTED",
    STG_E_SEEKERROR, "STG_E_SEEKERROR",
    STG_E_WRITEFAULT, "STG_E_WRITEFAULT",
    STG_E_READFAULT, "STG_E_READFAULT",
    STG_E_SHAREVIOLATION, "STG_E_SHAREVIOLATION",
    STG_E_LOCKVIOLATION, "STG_E_LOCKVIOLATION",
    STG_E_FILEALREADYEXISTS, "STG_E_FILEALREADYEXISTS",
    STG_E_INVALIDPARAMETER, "STG_E_INVALIDPARAMETER",
    STG_E_MEDIUMFULL, "STG_E_MEDIUMFULL",
    STG_E_ABNORMALAPIEXIT, "STG_E_ABNORMALAPIEXIT",
    STG_E_INVALIDHEADER, "STG_E_INVALIDHEADER",
    STG_E_INVALIDNAME, "STG_E_INVALIDNAME",
    STG_E_UNKNOWN, "STG_E_UNKNOWN",
    STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
    STG_E_INVALIDFLAG, "STG_E_INVALIDFLAG",
    STG_E_INUSE, "STG_E_INUSE",
    STG_E_NOTCURRENT, "STG_E_NOTCURRENT",
    STG_E_REVERTED, "STG_E_REVERTED",
    STG_E_CANTSAVE, "STG_E_CANTSAVE",
    STG_E_OLDFORMAT, "STG_E_OLDFORMAT",
    STG_E_OLDDLL, "STG_E_OLDDLL",
    STG_E_SHAREREQUIRED, "STG_E_SHAREREQUIRED",
    STG_E_NOTFILEBASEDSTORAGE, "STG_E_NOTFILEBASEDSTORAGE",
    STG_S_CONVERTED, "STG_S_CONVERTED"
};
#define NSCODETEXT (sizeof(scodes)/sizeof(scodes[0]))

// Convert a status code to text
char *ScText(SCODE sc)
{
    int i;

    for (i = 0; i<NSCODETEXT; i++)
	if (scodes[i].sc == sc)
	    return scodes[i].text;
    return "?";
}

// Output a call result and check for failure
HRESULT Result(HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out(" - %s (0x%lX)\n", ScText(sc), sc);
    if (FAILED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call failure\n");
    return hr;
}

// Perform Result() when the expectation is failure
HRESULT IllResult(char *pszText, HRESULT hr)
{
    SCODE sc;

    sc = DfGetScode(hr);
    out("%s - %s (0x%lX)\n", pszText, ScText(sc), sc);
    if (SUCCEEDED(sc) && fExitOnFail)
        error(EXIT_BADSC, "Unexpected call success\n");
    return hr;
}

// Check whether a given storage has a certain
// structure or not
// Structure is given as a string with elements:
//   <Type><Name><Options>[,...]
//   Type - d for docfile and s for stream
//   Name - Characters up to a '(' or ','
//   Options - For a docfile, you can specify a recursive check
//     in parentheses
//
// Example:  dDocfile(sStream,dDocfile)
char *VerifyStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    char chType;
    SCODE sc;
    CStrList sl;
    SStrEntry *pse;
    IEnumSTATSTG *penm;
    STATSTG stat;
    OLECHAR atcName[CWCSTORAGENAME];

    if (FAILED(sc = DfGetScode(pstg->EnumElements(0, NULL, 0, &penm))))
	error(EXIT_BADSC, "VerifyStructure: Unable to create enumerator - "
	      "%s (0x%lX)\n", ScText(sc), sc);
    for (;;)
    {
	sc = DfGetScode(penm->Next(1, &stat, NULL));
	if (sc == S_FALSE)
	    break;
	else if (FAILED(sc))
	    error(EXIT_BADSC, "VerifyStructure: Unable to enumerate - "
	      "%s (0x%lX)\n", ScText(sc), sc);
	pse = sl.Add(stat.pwcsName);
	if (pse == NULL)
	    error(EXIT_OOM, "VerifyStructure: Unable to allocate string\n");
	pse->user.dw = stat.type;
	drtMemFree(stat.pwcsName);
    }
    penm->Release();
    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	pse = sl.Find(atcName);
	if (pse == NULL)
	    error(EXIT_BADSC, "VerifyStructure: '%s' not found\n", szName);
	switch(chType)
	{
	case 'd':
	    if (pse->user.dw != STGTY_STORAGE)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a storage\n",
		      szName);
	    sc = DfGetScode(pstg->OpenStorage(atcName, NULL,
                                              STGP(STGM_READWRITE), NULL,
                                              0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "VerifyStructure: can't open storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = VerifyStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    if (pse->user.dw != STGTY_STREAM)
		error(EXIT_BADSC, "VerifyStructure: '%s' is not a stream\n",
		      szName);
	    break;
	}
	sl.Remove(pse);
	if (*pszStructure == ',')
	    pszStructure++;
    }
    for (pse = sl.GetHead(); pse; pse = pse->pseNext)
	error(EXIT_BADSC, "VerifyStructure: additional member '%s'\n",
	      OlecsOut(pse->atc));
    return pszStructure;
}

// Creates a structure using the same syntax
// as VerifyStructure
char *CreateStructure(IStorage *pstg, char *pszStructure)
{
    char szName[CWCSTORAGENAME], *psz;
    IStorage *pstgChild;
    IStream *pstmChild;
    char chType;
    SCODE sc;
    OLECHAR atcName[CWCSTORAGENAME];

    while (*pszStructure && *pszStructure != ')')
    {
	chType = *pszStructure++;
	psz = szName;
	while (*pszStructure && *pszStructure != '(' &&
	       *pszStructure != ')' && *pszStructure != ',')
	    *psz++ = *pszStructure++;
	*psz = 0;
        ATOOLE(szName, atcName, CWCSTORAGENAME);
	switch(chType)
	{
	case 'd':
	    sc = DfGetScode(pstg->CreateStorage(atcName, STGP(STGM_READWRITE),
                                                0, 0, &pstgChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create storage "
		      "'%s' - %s\n", szName, ScText(sc));
	    if (*pszStructure == '(')
		pszStructure = CreateStructure(pstgChild, pszStructure+1)+1;
	    pstgChild->Release();
	    break;
	case 's':
	    sc = DfGetScode(pstg->CreateStream(atcName, STMP(STGM_READWRITE),
                                               0, 0, &pstmChild));
	    if (FAILED(sc))
		error(EXIT_BADSC, "CreateStructure: can't create stream "
		      "'%s' - %s\n", szName, ScText(sc));
	    pstmChild->Release();
	    break;
	}
	if (*pszStructure == ',')
	    pszStructure++;
    }
    pstg->Commit(0);
    return pszStructure;
}

// Verifies the fields of a STATSTG
void VerifyStat(STATSTG *pstat, OLECHAR *ptcsName, DWORD type, DWORD grfMode)
{
    if (ptcsName == NULL)
    {
        if (pstat->pwcsName != NULL)
	    error(EXIT_BADSC, "Stat name should be NULL - is %p\n",
                  pstat->pwcsName);
    }
    else if (olecscmp(pstat->pwcsName, ptcsName))
	error(EXIT_BADSC, "Stat name mismatch - has '%s' vs. '%s'\n",
	      OlecsOut(pstat->pwcsName), OlecsOut(ptcsName));
    if (pstat->type != type)
	error(EXIT_BADSC, "Stat type mismatch - has %lu vs. %lu\n",
	      pstat->type, type);
    if (pstat->grfMode != grfMode)
	error(EXIT_BADSC, "Stat mode mismatch - has 0x%lX vs. 0x%lX\n",
	      pstat->grfMode, grfMode);
}

// Checks on a file's existence
BOOL Exists(OLECHAR* ocsFile)
{   
    char pszFile[_MAX_PATH];
    TTOS(ocsFile, pszFile, _tcslen(ocsFile)+1);
    FILE *f=fopen(pszFile, "r");
    BOOL fExists= (f!=NULL);
    if (f!=NULL) fclose(f);
    return (fExists);
}

// Gets a file's length
ULONG Length(OLECHAR *ocsFile)
{
    ULONG cb;
    char pszFile[_MAX_PATH];
    TTOS(ocsFile, pszFile, _tcslen(ocsFile)+1);

    FILE *f=fopen(pszFile, "r");
    if (!f) 
	error(EXIT_BADSC, "Length: Unable to open '%s'\n", pszFile);
    int rcode=fseek(f, 0, SEEK_END);
    if (rcode!=0)
	error(EXIT_BADSC, "Length: Unable to get length for '%s'\n",
	      pszFile);
    cb= (ULONG) ftell(f);
    fclose(f);

    return cb;
}

// Equality for FILETIME
BOOL IsEqualTime(FILETIME ttTime, FILETIME ttCheck)
{
#ifdef _UNIX
    #ifdef LONGLONG
    #error "LONGLONG should not be defined"
    #else
    #define LONGLONG time_t
    #endif
#endif
    //  File times can be off by as much as 2 seconds due to FAT rounding
    LONGLONG tmTime = *(LONGLONG *)&ttTime;
    LONGLONG tmCheck = *(LONGLONG *)&ttCheck;
    LONGLONG tmDelta = tmTime - tmCheck;
#ifdef _UNIX
    #undef LONGLONG
#endif
#ifndef _UNIX
    return tmDelta < 20000000i64 && tmDelta > -2i64 ;
#else
    return tmDelta < 2; // time_t is in seconds
#endif
}

// Get a fully qualified path for a file name
void GetFullPath(TCHAR *ocsFile, TCHAR *ocsPath, int len)
{
    char pszPath[_MAX_PATH+1], pszFile[_MAX_PATH+1];
    TTOS(ocsFile, pszFile, _tcslen(ocsFile)+1);
    _fullpath(pszPath, pszFile, len);
    STOT(pszPath, ocsPath, strlen(pszPath)+1);
}

//  Memory helper functions

HRESULT drtMemAlloc(ULONG ulcb, void **ppv)
{
    HRESULT hr;
    IMalloc *pMalloc = NULL;

    if (SUCCEEDED(DfGetScode(hr = CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        *ppv = pMalloc->Alloc(ulcb);
        pMalloc->Release();

        if (*ppv == NULL)
            return ResultFromScode(E_OUTOFMEMORY);
    }

    return hr;
}

void drtMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

#ifdef _MSC_VER
#pragma pack(1)
#endif

struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};

#ifdef _MSC_VER
#pragma pack()
#endif

char *GuidText(GUID const *pguid)
{
    static char buf[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    sprintf(buf, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\wchar.c ===
/*
*
*       Copyright (c) 1985-1996, Microsoft Corporation. All Rights Reserved.
*
*       Character functions (to and from wide characters)
i*
******************************************************************************
*/

#include "h/wchar.h"
#include <errno.h>

/*
** Converts a single byte i.e. ascii string to the wide char format 
**
** NOTE: This function does NOT handle multibyte characters!
**       It should be used only when wchar_t is not 2 bytes and
**       we cannot use the standard functions
**
*/

#ifndef _MSC_VER
size_t sbstowcs(WCHAR *pwcs, const char *s, size_t n )
{
	size_t count=0;

	/* if destintation string exists, fill it in */
	if (pwcs)
	{
		while (count < n)
		{
			*pwcs = (WCHAR) ( (unsigned char)s[count]);
			if (!s[count])
				return count;
			count++;
			pwcs++;
		}
		return count;
	}
	else { /* pwcs == NULL, get size only, s must be NUL-terminated */
		return strlen(s);
	}
}
#endif

/***
*size_t wcstrsbs() - Convert wide char string to single byte char string.
*
*Purpose:
*       Convert a wide char string into the equivalent multibyte char string 
*       [ANSI].
*
*Entry:
*       char *s            = pointer to destination char string
*       const WCHAR *pwc = pointer to source wide character string
*       size_t           n = maximum number of bytes to store in s
*
*Exit:
*       If s != NULL, returns    (size_t)-1 (if a wchar cannot be converted)
*       Otherwise:       Number of bytes modified (<=n), not including
*                    the terminating NUL, if any.
* 
*Exceptions
*       Returns (size_t)-1 if s is NULL or invalid mb character encountered.
*
*******************************************************************************/

size_t __cdecl wcstosbs( char * s, const WCHAR * pwcs, size_t n)
{
	size_t count=0;
        /* if destination string exists, fill it in */
 	if (s)
	{
		while(count < n)
		{
		    if (*pwcs > 255)  /* validate high byte */
		    {
			errno = EILSEQ;
			return (size_t)-1;  /* error */
		    }
		    s[count] = (char) *pwcs;

 		    if (!(*pwcs++))
			return count;
    		    count++;
	        }
		return count;
											} else { /* s == NULL, get size only, pwcs must be NUL-terminated */
	        const WCHAR *eos = pwcs;
		while (*eos++);
		return ( (size_t) (eos - pwcs -1));
	}
}


/******
*	WCHAR *wcscat(dst, src) - concatenate (append) one wide character string
*       to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       WCHAR *dst - wide character string to which "src" is to be appended
*       const WCHAR *src - wide character string to append to end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

WCHAR * __cdecl wcscat(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;

    while( *cp )
            ++cp;       /* Find end of dst */

    wcscpy(cp,src);     /* Copy src to end of dst */

    return dst;         /* return dst */

}


/***
*WCHAR *wcscpy(dst, src) - copy one wide character string over another
*
*Purpose:
*       Copies the wide character string src into the spot specified by
*       dest; assumes enough room.
*
*Entry:
*       WCHAR * dst - wide character string over which "src" is to be copied
*       const WCHAR * src - string to be copied over "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*******************************************************************************/

WCHAR * __cdecl wcscpy(WCHAR * dst, const WCHAR * src)
{
    WCHAR * cp = dst;

    while( *cp++ = *src++ )
            ;               /* Copy src over dst */

    return dst;
}


/***
*wcslen - return the length of a null-terminated string
*
*Purpose:
*       Finds the number of wide characters in the given wide character
*       string, not including the final null character.
*
*Entry:
*       const wchat_t * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null wide character
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen(const WCHAR * str)
{
    WCHAR *string = (WCHAR *) str;

    while( *string )
            string++;

    return string - str;
}

/****************************************************************************
*wcsnicmp.c - compare first n characters of two wide character strings with
*             case insensitivity
*
*       Copyright (c) 1985-1996, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcsnicmp() - compare first n characters of two wide character
*       strings for lexical order with case insensitivity.
*
*****************************************************************************/

/***
*WCHAR wcUp(wc) - upper case wide character
****/

static WCHAR wcUp(WCHAR wc)
{
    if ('a' <= wc && wc <= 'z')
        wc += (WCHAR)('A' - 'a');

    return(wc);
}

/***
*int wcsnicmp(first, last, count) - compare first count wide characters of wide
*       character strings with case insensitivity.
*
*Purpose:
*       Compares two wide character strings for lexical order.  The comparison
*       stops after: (1) a difference between the strings is found, (2) the end
*       of the strings is reached, or (3) count characters have been
*       compared.
*
*Entry:
*       char *first, *last - wide character strings to compare
*       unsigned count - maximum number of wide characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns  0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsnicmp(const WCHAR * first, const WCHAR * last, size_t count)
{
      if (!count)
              return 0;

      while (--count && *first && wcUp(*first) == wcUp(*last))
              {
              first++;
              last++;
              }

      return wcUp(*first) - wcUp(*last);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\simp\simphead.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:   simphead.cxx
//
//  Contents:   Precompiled headers
//
//  History:    04-Aug-94       PhilipLa        Created.
//
//--------------------------------------------------------------------------

#include <memory.h>

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
}
#include <ole2.h>

#if defined(_CHICAGO_)
#include <widewrap.h>
#endif

#include <msf.hxx>
#include <header.hxx>
#include <fat.hxx>
#include <dir.hxx>
#include <dirfunc.hxx>
#include <psetstg.hxx>
#include <simpdf.hxx>
#include <simpstm.hxx>
#include <dfnlist.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\simp\simpdf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	simpdf.cxx
//
//  Contents:	StdDocfile implementation
//
//  Classes:	
//
//  Functions:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop


#if DBG == 1
DECLARE_INFOLEVEL(simp)
#endif

//+---------------------------------------------------------------------------
//
//  Function:	DfCreateSimpDocfile, private
//
//  Synopsis:	
//
//  Arguments:	
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE DfCreateSimpDocfile(WCHAR const *pwcsName,
                          DWORD grfMode,
                          DWORD reserved,
                          IStorage **ppstgOpen)
{
    SCODE sc;
    CSimpStorage *pstg;

    if (grfMode !=
        (STGM_SIMPLE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE))
        return STG_E_INVALIDFLAG;

    
    pstg = new CSimpStorage;
    if (pstg == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }
    
    sc = pstg->Init(pwcsName, NULL);
    
    if (FAILED(sc))
    {
        pstg->Release();
        pstg = NULL;
    }

    *ppstgOpen = pstg;
    return sc;
}

#if WIN32 != 200
//+---------------------------------------------------------------------------
//
//  Function:   DfOpenSimpDocfile, private
//
//  Synopsis:   opens an existing docfile for reading
//
//  Arguments:  [pwcsName] name of docfile
//              [grfMode]  permission bits
//              [reserved] must be zero
//              [pstgOpen] opened storage pointer
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-96   HenryLee    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE DfOpenSimpDocfile(WCHAR const *pwcsName,
                          DWORD grfMode,
                          DWORD reserved,
                          IStorage **ppstgOpen)

{
    SCODE sc = S_OK;
    CSimpStorageOpen *pstg;

    if (ppstgOpen == NULL)
        return STG_E_INVALIDPARAMETER;
    else
        *ppstgOpen = NULL;

    if (grfMode != (STGM_SIMPLE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE) &&
        grfMode != (STGM_SIMPLE | STGM_READ      | STGM_SHARE_EXCLUSIVE))
        return STG_E_INVALIDFLAG;

    if ((pstg = new CSimpStorageOpen) == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }

    if (FAILED(sc = pstg->Init(pwcsName, grfMode, NULL)))
    {
        pstg->Release();
        pstg = NULL;
    }

    *ppstgOpen = pstg;
    return sc;
}
#endif // WIN32 != 200
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\stgdbg\sources.inc ===
!IF 0

Copyright (c) 1998-1999  Microsoft Corporation

!ENDIF
SYNCHRONIZE_DRAIN=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\ref\test\stgdrt\wrap.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:	wrap.cxx
//
//  Contents:	Wrapper implementations
//
//---------------------------------------------------------------

#include "headers.cxx"

// Retrieve interface pointer for possibly NULL objects
#define SAFEI(obj) ((obj) ? (obj)->GetI() : NULL)

//+--------------------------------------------------------------
//
//  IStorage wrappers
//
//---------------------------------------------------------------

WStorage *WStorage::Wrap(IStorage *pistg)
{
    WStorage *wstg;

    wstg = new WStorage(pistg);
    if (wstg == NULL)
	error(EXIT_OOM, "Unable to wrap IStorage\n");
    return wstg;
}

WStorage::WStorage(IStorage *pstg)
{
    // Note:  takes ownership of pstg
    _pstg = pstg;
}

WStorage::~WStorage(void)
{
    if (_pstg)
	Release();
}

void WStorage::Unwrap(void)
{
    delete this;
}

HRESULT WStorage::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStorage %p::QueryInterface(riid, %p)", _pstg, ppvObj);
    return Result(_pstg->QueryInterface(riid, ppvObj));
}

ULONG WStorage::AddRef(void)
{
    ULONG ul;

    ul = _pstg->AddRef();
    out("IStorage %p::AddRef() - %lu\n", _pstg, ul);
    return ul;
}

ULONG WStorage::Release(void)
{
    ULONG ul;

    ul = _pstg->Release();
    out("IStorage %p::Release() - %lu\n", _pstg, ul);
    if (ul == 0)
	_pstg = NULL;
    return ul;
}

HRESULT WStorage::CreateStream(const OLECHAR * pwcsName,
			     const DWORD grfMode,
			     DWORD reserved1,
			     DWORD reserved2,
			     WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::CreateStream(%s, 0x%lX, %lu, %lu, %p)", _pstg,
	OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstm);
    hr = Result(_pstg->CreateStream(pwcsName, grfMode, reserved1,
                                    reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::OpenStream(const OLECHAR * pwcsName,
			   void *reserved1,
			   const DWORD grfMode,
			   DWORD reserved2,
			   WStream **ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStorage %p::OpenStream(%s, %p, 0x%lX, %lu, %p)", _pstg,
	OlecsOut(pwcsName), reserved1, grfMode, reserved2, ppstm);
    hr = Result(_pstg->OpenStream(pwcsName, reserved1, grfMode,
				 reserved2, &pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

HRESULT WStorage::CreateStorage(const OLECHAR * pwcsName,
			      const DWORD grfMode,
			      DWORD reserved1,
                              DWORD reserved2,
			      WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::CreateStorage(%s, 0x%lX, %lu, %lu, %p)", _pstg,
        OlecsOut(pwcsName), grfMode, reserved1, reserved2, ppstg);
    hr = Result(_pstg->CreateStorage(pwcsName, grfMode, reserved1,
                                     reserved2, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::OpenStorage(const OLECHAR * pwcsName,
			    WStorage *pstgPriority,
			    const DWORD grfMode,
			    SNB snbExclude,
			    DWORD reserved,
			    WStorage **ppstg)
{
    HRESULT hr;
    IStorage *pistg;

    out("IStorage %p::OpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", _pstg,
	OlecsOut(pwcsName), SAFEI(pstgPriority), grfMode,
	snbExclude, reserved, ppstg);
    hr = Result(_pstg->OpenStorage(pwcsName, (IStorage*) SAFEI(pstgPriority),
                                   grfMode, snbExclude,
                                   reserved, &pistg));
    *ppstg = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStorage::CopyTo(DWORD ciidExclude,
		       IID *rgiidExclude,
		       SNB snbExclude,
		       WStorage *pstgDest)
{
    out("IStorage %p::CopyTo(%lu, %p, %p, %p)", _pstg, ciidExclude,
	rgiidExclude, snbExclude, pstgDest->GetI());
    return Result(_pstg->CopyTo(ciidExclude, rgiidExclude, snbExclude,
                                pstgDest->GetI()));
}

HRESULT WStorage::MoveElementTo(OLECHAR const FAR* lpszName,
    			WStorage FAR *pstgDest,
                        OLECHAR const FAR* lpszNewName,
                        DWORD grfFlags)
{
    out("IStorage %p::MoveElementTo(%p, %p, %p, %lu)", _pstg, lpszName,
	pstgDest->GetI(), lpszNewName, grfFlags);
    return Result(_pstg->MoveElementTo(lpszName, pstgDest->GetI(),
                                       lpszNewName, grfFlags));
}

HRESULT WStorage::Commit(const DWORD grfCommitFlags)
{
    out("IStorage %p::Commit(0x%lX)", _pstg, grfCommitFlags);
    return Result(_pstg->Commit(grfCommitFlags));
}

HRESULT WStorage::Revert(void)
{
    out("IStorage %p::Revert()", _pstg);
    return Result(_pstg->Revert());
}

HRESULT WStorage::EnumElements(DWORD reserved1,
			     void *reserved2,
			     DWORD reserved3,
			     WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IStorage %p::EnumElements(%lu, %p, %lu, %p)", _pstg,
	reserved1, reserved2, reserved3, ppenm);
    hr = Result(_pstg->EnumElements(reserved1, reserved2, reserved3, &pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

HRESULT WStorage::DestroyElement(const OLECHAR * pwcsName)
{
    out("IStorage %p::DestroyElement(%s)", _pstg, OlecsOut(pwcsName));
    return Result(_pstg->DestroyElement(pwcsName));
}

HRESULT WStorage::RenameElement(const OLECHAR * pwcsOldName,
			      const OLECHAR * pwcsNewName)
{
    out("IStorage %p::RenameElement(%s, %s)", _pstg, OlecsOut(pwcsOldName),
	OlecsOut(pwcsNewName));
    return Result(_pstg->RenameElement(pwcsOldName, pwcsNewName));
}

HRESULT WStorage::SetElementTimes(const OLECHAR *lpszName,
                                FILETIME const *pctime,
                                FILETIME const *patime,
                                FILETIME const *pmtime)
{
    out("IStorage %p::SetElementTimes(%s, %p, %p, %p)", _pstg,
        OlecsOut(lpszName), pctime, patime, pmtime);
    return Result(_pstg->SetElementTimes(lpszName, pctime, patime, pmtime));
}

HRESULT WStorage::SetClass(REFCLSID clsid)
{
    out("IStorage %p::SetClass(%s)", _pstg, GuidText(&clsid));
    return Result(_pstg->SetClass(clsid));
}

HRESULT WStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    out("IStorage %p::SetStateBits(0x%lX, 0x%lX)", _pstg, grfStateBits,
        grfMask);
    return Result(_pstg->SetStateBits(grfStateBits, grfMask));
}

HRESULT WStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStorage %p::Stat(%p, %lu)", _pstg, pstatstg, grfStatFlag);
    return Result(_pstg->Stat(pstatstg, grfStatFlag));
}

//+--------------------------------------------------------------
//
//  IStream wrappers
//
//---------------------------------------------------------------

WStream *WStream::Wrap(IStream *pistm)
{
    WStream *wstm;

    wstm = new WStream(pistm);
    if (wstm == NULL)
	error(EXIT_OOM, "Unable to wrap IStream\n");
    return wstm;
}

WStream::WStream(IStream *pstm)
{
    // Note:  takes ownership of pstm
    _pstm = pstm;
}

WStream::~WStream(void)
{
    if (_pstm)
	Release();
}

void WStream::Unwrap(void)
{
    delete this;
}

HRESULT WStream::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IStream %p::QueryInterface(riid, %p)", _pstm, ppvObj);
    return Result(_pstm->QueryInterface(riid, ppvObj));
}

ULONG WStream::AddRef(void)
{
    ULONG ul;

    ul = _pstm->AddRef();
    out("IStream %p::AddRef() - %lu\n", _pstm, ul);
    return ul;
}

ULONG WStream::Release(void)
{
    ULONG ul;

    ul = _pstm->Release();
    out("IStream %p::Release() - %lu\n", _pstm, ul);
    if (ul == 0)
	_pstm = NULL;
    return ul;
}

HRESULT WStream::Read(VOID *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr;

    out("IStream %p::Read(%p, %lu, %p)", _pstm, pv, cb, pcbRead);
    hr = _pstm->Read(pv, cb, pcbRead);
    if (pcbRead)
	out(" - %lu bytes", *pcbRead);
    Result(hr);
    if (pcbRead && *pcbRead != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't read data\n");
    return hr;
}

HRESULT WStream::Write(VOID *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr;

    out("IStream %p::Write(%p, %lu, %p)", _pstm, pv, cb, pcbWritten);
    hr = _pstm->Write(pv, cb, pcbWritten);
    if (pcbWritten)
	out(" - %lu bytes", *pcbWritten);
    Result(hr);
    if (pcbWritten && *pcbWritten != cb && fExitOnFail)
	error(EXIT_BADSC, "Couldn't write data\n");
    return hr;
}

HRESULT WStream::Seek(LONG dlibMove,
		    DWORD dwOrigin,
		    ULONG *plibNewPosition)
{
    HRESULT hr;
    LARGE_INTEGER dlib;
    ULARGE_INTEGER plib;

    out("IStream %p::Seek(%ld, %lu, %p)", _pstm, dlibMove, dwOrigin,
	plibNewPosition);
    LISet32(dlib, dlibMove);
    hr = _pstm->Seek(dlib, dwOrigin, &plib);
    if (plibNewPosition)
    {
        *plibNewPosition = ULIGetLow(plib);
	out(" - ptr %lu", *plibNewPosition);
    }
    return Result(hr);
}

HRESULT WStream::SetSize(ULONG libNewSize)
{
    ULARGE_INTEGER lib;
    
    out("IStream %p::SetSize(%lu)", _pstm, libNewSize);
    ULISet32(lib, libNewSize);
    return Result(_pstm->SetSize(lib));
}

HRESULT WStream::Commit(const DWORD dwFlags)
{
    out("IStream %p:Commit(%lu)", _pstm, dwFlags);
    return Result(_pstm->Commit(dwFlags));
}

HRESULT WStream::CopyTo(WStream *pstm,
		      ULONG cb,
		      ULONG *pcbRead,
		      ULONG *pcbWritten)
{
    ULARGE_INTEGER lcb, pcbr, pcbw;
    HRESULT hr;
    
    out("IStream %p::CopyTo(%p, %lu, %p, %p)", _pstm, pstm->GetI(), cb,
	pcbRead, pcbWritten);
    ULISet32(lcb, cb);
    hr = Result(_pstm->CopyTo(pstm->GetI(), lcb, &pcbr, &pcbw));
    if (pcbRead)
        *pcbRead = ULIGetLow(pcbr);
    if (pcbWritten)
        *pcbWritten = ULIGetLow(pcbw);
    return hr;
}

HRESULT WStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    out("IStream %p::Stat(%p, %lu)", _pstm, pstatstg, grfStatFlag);
    return Result(_pstm->Stat(pstatstg, grfStatFlag));
}

HRESULT WStream::Clone(WStream * *ppstm)
{
    HRESULT hr;
    IStream *pistm;

    out("IStream %p::Clone(%p)", _pstm, ppstm);
    hr = Result(_pstm->Clone(&pistm));
    *ppstm = WStream::Wrap(pistm);
    return hr;
}

//+--------------------------------------------------------------
//
//  IEnumSTATSTG wrappers
//
//---------------------------------------------------------------

WEnumSTATSTG *WEnumSTATSTG::Wrap(IEnumSTATSTG *pienm)
{
    WEnumSTATSTG *wenm;

    wenm = new WEnumSTATSTG(pienm);
    if (wenm == NULL)
	error(EXIT_OOM, "Unable to wrap IEnumSTATSTG\n");
    return wenm;
}

WEnumSTATSTG::WEnumSTATSTG(IEnumSTATSTG *penm)
{
    // Note:  takes ownership of penm
    _penm = penm;
}

WEnumSTATSTG::~WEnumSTATSTG(void)
{
    if (_penm)
	Release();
}

void WEnumSTATSTG::Unwrap(void)
{
    delete this;
}

HRESULT WEnumSTATSTG::QueryInterface(REFIID riid, void **ppvObj)
{
    out("IEnumSTATSTG %p::QueryInterface(riid, %p)", _penm, ppvObj);
    return Result(_penm->QueryInterface(riid, ppvObj));
}

ULONG WEnumSTATSTG::AddRef(void)
{
    ULONG ul;

    ul = _penm->AddRef();
    out("IEnumSTATSTG %p::AddRef() - %lu\n", _penm, ul);
    return ul;
}

ULONG WEnumSTATSTG::Release(void)
{
    ULONG ul;

    ul = _penm->Release();
    out("IEnumSTATSTG %p::Release() - %lu\n", _penm, ul);
    if (ul == 0)
	_penm = NULL;
    return ul;
}

HRESULT WEnumSTATSTG::Next(ULONG celt, STATSTG rgelt[], ULONG *pceltFetched)
{
    out("IEnumSTATSTG %p::Next(%lu, rgelt, %p)", _penm, celt, pceltFetched);
    return Result(_penm->Next(celt, rgelt, pceltFetched));
}

HRESULT WEnumSTATSTG::Skip(ULONG celt)
{
    out("IEnumSTATSTG %p::Skip(%lu)", _penm, celt);
    return Result(_penm->Skip(celt));
}

HRESULT WEnumSTATSTG::Reset(void)
{
    out("IEnumSTATSTG %p::Reset()", _penm);
    return Result(_penm->Reset());
}

HRESULT WEnumSTATSTG::Clone(WEnumSTATSTG **ppenm)
{
    HRESULT hr;
    IEnumSTATSTG *pienm;

    out("IEnumSTATSTG %p::Clone(%p)", _penm, ppenm);
    hr = Result(_penm->Clone(&pienm));
    *ppenm = WEnumSTATSTG::Wrap(pienm);
    return hr;
}

//+--------------------------------------------------------------
//
//  Root level wrappers
//
//---------------------------------------------------------------

HRESULT WStgCreateDocfile(const OLECHAR * pwcsName,
			const DWORD grfMode,
			DWORD reserved,
			WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

#ifndef _CAIRO_
    if (pwcsName)
     {
	 out("StgCreateDocfile(%s, 0x%lX, %lu, %p)", 
	     OlecsOut(pwcsName), grfMode, reserved, ppstgOpen);
     }
    hr = Result(StgCreateDocfile(pwcsName, grfMode,
                                 reserved, &pistg));
#else ELSE == 300
    out("StgCreateStorage(%s, 0x%lX, %lu, %p)", OlecsOut(pwcsName), grfMode,
	reserved, ppstgOpen);

    hr = Result(StgCreateStorage(pwcsName, grfMode,
                                 STGFMT_DOCUMENT,
                                 (LPSECURITY_ATTRIBUTES)reserved, &pistg));
#endif

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgCreateDocfileOnILockBytes(ILockBytes *plkbyt,
				    const DWORD grfMode,
				    DWORD reserved,
				    WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgCreateDocfileOnILockBytes(%p, 0x%lX, %lu, %p)",
	plkbyt, grfMode, reserved, ppstgOpen);
    hr = Result(StgCreateDocfileOnILockBytes(plkbyt, grfMode,
                                             reserved, &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorage(const OLECHAR * pwcsName,
		      WStorage *pstgPriority,
		      const DWORD grfMode,
		      SNB snbExclude,
		      DWORD reserved,
		      WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorage(%s, %p, 0x%lX, %p, %lu, %p)", OlecsOut(pwcsName),
	SAFEI(pstgPriority), grfMode, snbExclude, reserved, ppstgOpen);
    hr = Result(StgOpenStorage(pwcsName, (IStorage*)SAFEI(pstgPriority), grfMode,
			      snbExclude,
                               reserved, &pistg));

    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgOpenStorageOnILockBytes(ILockBytes *plkbyt,
				  WStorage *pstgPriority,
				  const DWORD grfMode,
				  SNB snbExclude,
				  DWORD reserved,
				  WStorage * *ppstgOpen)
{
    HRESULT hr;
    IStorage *pistg;

    out("StgOpenStorageOnILockBytes(%p, %p, 0x%lX, %p, %lu, %p)",
	plkbyt, SAFEI(pstgPriority), grfMode, snbExclude, reserved,
	ppstgOpen);
    hr = Result(StgOpenStorageOnILockBytes(plkbyt, (IStorage*)SAFEI(pstgPriority),
					  grfMode, snbExclude, reserved,
					  &pistg));
    *ppstgOpen = WStorage::Wrap(pistg);
    return hr;
}

HRESULT WStgIsStorageFile(const OLECHAR * pwcsName)
{
    out("StgIsStorageFile(%s)", OlecsOut(pwcsName));
    return Result(StgIsStorageFile(pwcsName));
}

HRESULT WStgIsStorageILockBytes(ILockBytes * plkbyt)
{
    out("StgIsStorageILockBytes(%p)", plkbyt);
    return Result(StgIsStorageILockBytes(plkbyt));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\simp\simpenm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       simpenm.cxx
//
//  Contents:   SimpEnumSTATSTG class implementation
//
//  Classes:    CSimpEnumSTATSTG
//
//  Functions:  
//
//  History:     04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::QueryInterface, public
//
//  Synopsis:   Init function
//
//  Arguments:  [riid] -- reference to desired interface ID
//              [ppvObj] -- output pointer to interface
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::QueryInterface (REFIID riid, void **ppvObj)
{
    simpDebugOut((DEB_ITRACE,"In  CSimpEnumSTATSTG::QueryInterface %p\n",this));

    SCODE sc = S_OK;

    if (ppvObj == NULL)
        return STG_E_INVALIDPOINTER;

    *ppvObj = NULL;

    if (riid == IID_IEnumSTATSTG || riid == IID_IUnknown)
    { 
        *ppvObj = this;
        AddRef ();
    }
    else
        sc = E_NOINTERFACE;

    simpDebugOut((DEB_ITRACE, "Out CSimpEnumSTATSTG::QueryInterface\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::AddRef, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpEnumSTATSTG::AddRef ()
{
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::AddRef()\n"));
    simpAssert(_cReferences > 0);

    LONG lRet = AtomicInc(&_cReferences);

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::AddRef()\n"));
    return (ULONG) lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Release, public
//
//  Synopsis:   
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpEnumSTATSTG::Release ()
{
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Release()\n"));
    simpAssert(_cReferences > 0);

    LONG lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        delete this;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Release()\n"));
    return (ULONG) lRet;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Next, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Next (ULONG celt,  STATSTG *rgelt,
                                     ULONG *pceltFetched) 
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Next()\n"));

    if (celt != 1 || rgelt == NULL)
        return STG_E_INVALIDPARAMETER;

    if (pceltFetched)
        *pceltFetched = 0;

    if (_pdflCurrent == _pdfl && _pdfl != NULL)
        _pdflCurrent = _pdflCurrent->GetNext();   // skip the root directory

    if (_pdflCurrent != NULL)
    {
        memset (rgelt, 0, sizeof(STATSTG));
        rgelt->pwcsName = (WCHAR *) CoTaskMemAlloc (
            _pdflCurrent->GetName()->GetLength()+sizeof(WCHAR));

        if (rgelt->pwcsName)
        {
            memcpy (rgelt->pwcsName, _pdflCurrent->GetName()->GetBuffer(),
                _pdflCurrent->GetName()->GetLength());
            rgelt->pwcsName[_pdflCurrent->GetName()->GetLength()/
                            sizeof(WCHAR)] = L'\0';
            rgelt->cbSize.LowPart = _pdflCurrent->GetSize();
            rgelt->cbSize.HighPart = 0;
            rgelt->type = STGTY_STREAM;

            _pdflCurrent = _pdflCurrent->GetNext();
            if (pceltFetched)
                *pceltFetched = 1;
        }
        else
            sc = STG_E_INSUFFICIENTMEMORY;

    }
    else  // end of list
    {
        sc = S_FALSE;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Next()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Skip, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Skip (ULONG celt)
{
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Skip()\n"));
    SCODE sc = STG_E_INVALIDFUNCTION;

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Skip()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Reset, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Reset (void)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Reset()\n"));

    _pdflCurrent = _pdfl; 

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Reset()\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpEnumSTATSTG::Clone, public
//
//  Synopsis:
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpEnumSTATSTG::Clone (IEnumSTATSTG **ppenum)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpEnumSTATSTG::Clone()\n"));

    if (ppenum == NULL)
        return STG_E_INVALIDPARAMETER;

    if ((*ppenum = new CSimpEnumSTATSTG (_pdfl, _pdflCurrent)) == NULL)
        sc = STG_E_INSUFFICIENTMEMORY;

    simpDebugOut((DEB_TRACE, "Out CSimpEnumSTATSTG::Clone()\n"));
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\simp\simpstg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simpstg.cxx
//
//  Contents:   SimpStorage class implementation
//
//  Classes:
//
//  Functions:
//
//  History:    04-Aug-94   PhilipLa    Created
//              26-Feb-97   Danl        QI support for IID_IPropertySetStorage
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop

#include <ole.hxx>
#include <logfile.hxx>
#include <expparam.hxx>


#ifdef SECURE_BUFFER
BYTE s_bufSecure[MINISTREAMSIZE];
#endif


ULONG ConvertSect(SECT sect)
{
    return (ULONG)(sect << SECTORSHIFT512) + SECTORSIZE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorage::Init, public
//
//  Synopsis:   Init function
//
//  Arguments:  [psdh] -- Pointer to hints structure
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

SCODE CSimpStorage::Init(WCHAR const * pwcsName, SSimpDocfileHints *psdh)
{
    simpDebugOut((DEB_ITRACE,
                 "In  CSimpStorage::Init:%p(%ws)\n", this, pwcsName));

#ifdef UNICODE
    TCHAR const *atcPath = pwcsName;
#else
    TCHAR atcPath[_MAX_PATH+1];

    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    if (!WideCharToMultiByte(
            uCodePage,
            0,
            pwcsName,
            -1,
            atcPath,
            _MAX_PATH + 1,
            NULL,
            NULL))
    {
        return STG_E_INVALIDNAME;
    }
#endif

    _hFile = CreateFileT(atcPath,
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (_hFile == INVALID_HANDLE_VALUE)
    {
        return STG_SCODE(GetLastError());
    }

    if (FALSE == SetEndOfFile (_hFile))
    {
        return STG_SCODE(GetLastError());
    }

    _sectMax = 0;
    //From this point on, we need to try to produce a docfile.
    _fDirty = TRUE;
    _clsid = IID_NULL;

#ifdef SECURE_SIMPLE_MODE
    memset(s_bufSecure, SECURECHAR, MINISTREAMSIZE);
#endif

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::Init\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Release, public
//
//  Synopsis:   Releases resources for a CSimpStorage
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStorage::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CSimpStorage::Release()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStorage::Release()\n"));

    simpAssert(_cReferences > 0);
    lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        //Clean up
        if (_hFile != INVALID_HANDLE_VALUE)
        {
            if (_fDirty)
                Commit(STGC_DEFAULT);
            CloseHandle(_hFile);
        }
        delete this;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpStorage::Release()\n"));
    olLog(("%p::Out CSimpStorage::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return (ULONG)lRet;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::CreateStream, public
//
//  Synopsis:   Creates a stream
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::CreateStream(WCHAR const *pwcsName,
                                            DWORD grfMode,
                                            DWORD reserved1,
                                            DWORD reserved2,
                                            IStream **ppstm)
{
    SCODE sc;
    CSimpStream *pstm;
    CDfNameList *pdfl, *pdflPrev = NULL;
    CDfNameList *pdflLoop = _pdfl;
    int iCmp;

    olLog(("%p::In  CSimpStorage::CreateStream(%ws, %lX, %lu, %lu, %p)\n",
           this, pwcsName, grfMode, reserved1, reserved2, ppstm));

    SIMP_VALIDATE(CreateStream(pwcsName,
                               grfMode,
                               reserved1,
                               reserved2,
                               ppstm));

    if (grfMode != (STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
        return STG_E_INVALIDFLAG;

    if (_pdflCurrent != NULL)
    {
        return STG_E_INVALIDFUNCTION;
    }

    //Check the name.  If it isn't already in the list, create a new
    //  CDfNameList object (in pdfl), and create a new stream object for it.

    pdfl = new CDfNameList;
    if (pdfl == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }

    pstm = new CSimpStream;
    if (pstm == NULL)
    {
        delete pdfl;
        return STG_E_INSUFFICIENTMEMORY;
    }

    pdfl->SetName(pwcsName);
    pdfl->SetStart(_sectMax);
    pdfl->SetSize(0);

    while (pdflLoop != NULL)
    {
        iCmp = CDirectory::NameCompare(pdfl->GetName(), pdflLoop->GetName());
        if (iCmp == 0)
        {
            //Already have a stream of this name.
            delete pdfl;
            delete pstm;
            return STG_E_FILEALREADYEXISTS;
        }

        if (iCmp < 0)
        {
            //We found the right spot.
            break;
        }

        pdflPrev = pdflLoop;
        pdflLoop = pdflLoop->GetNext();
    }

    if (FAILED(sc = pstm->Init(this, _hFile, ConvertSect(_sectMax))))
    {
        delete pdfl;
        delete pstm;
        return sc;
    }

    //Insert pdfl into list.
    pdfl->Insert(&_pdfl, pdflPrev, pdflLoop);

    _pdflCurrent = pdfl;
    _fDirty = TRUE;
    _cStreams++;
    *ppstm = pstm;

    olLog(("%p::Out CSimpStorage::CreateStream().  "
           "*ppstm == %p, ret == %lx\n", this, *ppstm, S_OK));

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorage::ReleaseCurrentStream, public
//
//  Synopsis:   Signal release of the current open stream
//
//  Arguments:  None.
//
//  Returns:    void.
//
//  History:    05-Aug-94       PhilipLa        Created
//
//----------------------------------------------------------------------------

#ifdef SECURE_SIMPLE_MODE
void CSimpStorage::ReleaseCurrentStream(ULONG ulHighWater)
#else
void CSimpStorage::ReleaseCurrentStream(void)
#endif
{
    simpDebugOut((DEB_ITRACE,
                 "In  CSimpStorage::ReleaseCurrentStream:%p()\n", this));

    ULONG cbSize;
    ULONG ulEndOfFile;

    ulEndOfFile = GetFileSize(_hFile, NULL);

    cbSize = ulEndOfFile - ConvertSect(_sectMax);
    cbSize = max(cbSize, MINISTREAMSIZE);

    _pdflCurrent->SetSize(cbSize);

    ULONG sectUsed;
    sectUsed = (cbSize + SECTORSIZE - 1) / SECTORSIZE;

#ifdef SECURE_SIMPLE_MODE
    ULONG cbBytesToWrite = ConvertSect(sectUsed + _sectMax) - ulHighWater;
    simpAssert(ConvertSect(sectUsed + _sectMax) >= ulHighWater);

    ULONG cbWritten;

    if ((cbBytesToWrite > 0) &&
        (SetFilePointer(_hFile, ulHighWater, NULL, FILE_BEGIN) != 0xFFFFFFFF))
    {
        while (cbBytesToWrite > 0)
        {
            if (!WriteFile(_hFile,
                           s_bufSecure,
                           min(MINISTREAMSIZE, cbBytesToWrite),
                           &cbWritten,
                           NULL))
            {
                break;
            }
            cbBytesToWrite -= cbWritten;
        }
    }
#endif
    _sectMax += sectUsed;
    _pdflCurrent = NULL;

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::ReleaseCurrentStream\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::CreateStorage, public
//
//  Synopsis:   Creates an embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [grfMode] - Permissions
//              [reserved1]
//              [reserved2]
//              [ppstg] - New DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::CreateStorage(WCHAR const *pwcsName,
                                             DWORD grfMode,
                                             DWORD reserved1,
                                             LPSTGSECURITY reserved2,
                                             IStorage **ppstg)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::OpenStorage, public
//
//  Synopsis:   Gets an existing embedded DocFile
//
//  Arguments:  [pwcsName] - Name
//              [pstgPriority] - Priority reopens
//              [grfMode] - Permissions
//              [snbExclude] - Priority reopens
//              [reserved]
//              [ppstg] - DocFile return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::OpenStorage(WCHAR const *pwcsName,
                                           IStorage *pstgPriority,
                                           DWORD grfMode,
                                           SNBW snbExclude,
                                           DWORD reserved,
                                           IStorage **ppstg)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::CopyTo, public
//
//  Synopsis:   Makes a copy of a DocFile
//
//  Arguments:  [ciidExclude] - Length of rgiid array
//              [rgiidExclude] - Array of IIDs to exclude
//              [snbExclude] - Names to exclude
//              [pstgDest] - Parent of copy
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::CopyTo(DWORD ciidExclude,
                                      IID const *rgiidExclude,
                                      SNBW snbExclude,
                                      IStorage *pstgDest)
{
    return STG_E_INVALIDFUNCTION;
}



//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorage::BuildTree, private
//
//  Synopsis:   Construct the btree given the sorted array of entries.
//
//  Arguments:  [ade] -- Array of CDirEntry to operate on.  These are
//                      already sorted.
//              [sidStart] -- SID of first entry on this segment
//              [cStreams] -- Length of segment to process
//
//  Returns:    SID of root of tree
//
//  History:    09-Aug-94       PhilipLa        Created
//
//  Notes:      This is a recursive function.  Yes, I know...
//
//----------------------------------------------------------------------------

SID CSimpStorage::BuildTree(CDirEntry *ade, SID sidStart, ULONG cStreams)
{
    simpDebugOut((DEB_ITRACE, "In  CSimpStorage::BuildTree:%p()\n", this));

    if (cStreams > 3)
    {
        SID sidSplit;

        sidSplit = sidStart + (cStreams / 2);

        simpAssert(cStreams == 1 + (sidSplit - sidStart) +
                   (cStreams + sidStart - 1) - sidSplit);

        ade[sidSplit].SetLeftSib(BuildTree(ade,
                                           sidStart,
                                           sidSplit - sidStart));
        ade[sidSplit].SetRightSib(BuildTree(ade,
                                            sidSplit + 1,
                                            (cStreams + sidStart - 1) -
                                            sidSplit));

        return sidSplit;
    }
    //Base cases:
    //  cStreams == 1 -- return sidStart
    //  cStreams == 2 -- Left child of sidStart + 1 == sidStart, return
    //                  sidStart + 1
    //  cStreams == 3 -- Root is sidStart + 1, with children sidStart and
    //                    sidStart + 2

    if (cStreams == 1)
    {
        return sidStart;
    }

    if (cStreams == 3)
        ade[sidStart + 1].SetRightSib(sidStart + 2);

    ade[sidStart + 1].SetLeftSib(sidStart);
    return sidStart + 1;

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::BuildTree\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Commit, public
//
//  Synopsis:   Commits transacted changes
//
//  Arguments:  [dwFlags] - DFC_*
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::Commit(DWORD dwFlags)
{
    CDfName const dfnRoot(L"Root Entry");
    SCODE sc;
    
    olLog(("%p::In  CSimpStorage::Commit(%lX)\n",this, dwFlags));

    SIMP_VALIDATE(Commit(dwFlags));
    
    // Simple mode commit does not allow open stream elements
    // While we could possibly revert the stream instead of returning an error,
    // it would not have the same semantics as normal mode transactions
    if (_pdflCurrent != NULL)
        return STG_E_INVALIDFUNCTION;

    if (!_fDirty)
        return S_OK;

    //Allocate a buffer big enough for all the control structures.
    const USHORT cdePerSect = SECTORSIZE / sizeof(CDirEntry);
    const USHORT cSectPerFat = SECTORSIZE / sizeof(SECT);

    ULONG cDifSect = 0;
    ULONG cFatSect = 0;
    ULONG cFatSectOld = (ULONG)-1;
    ULONG cDifSectOld = (ULONG)-1;
    ULONG cDirSect;
    ULONG cSect;
    ULONG cbSize;

    cDirSect = (_cStreams + 1 + cdePerSect - 1) / cdePerSect;
    cSect = _sectMax + cDirSect;

    //At this point, csect is the number of sectors needed to hold
    //  everything but the fat itself (and the DIFat, if necessary).


    while ((cFatSect != cFatSectOld) || (cDifSect != cDifSectOld))
    {
        //Now, compute the number of fat sectors needed to hold everything.

        cFatSectOld = cFatSect;
        cFatSect = (cSect + cFatSect + cDifSect + cSectPerFat - 1) /
            cSectPerFat;

        cDifSectOld = cDifSect;
        if (cFatSect >= CSECTFAT)
        {
            cDifSect = (cFatSect - CSECTFAT + cSectPerFat - 2)
                        / (cSectPerFat - 1);
        }
    }

    //At this point, we know how big the buffer needs to be.  Allocate
    // it.

    _pbBuf = new BYTE[(cFatSect + cDirSect + cDifSect) * SECTORSIZE];

    if (_pbBuf == NULL)
    {
        return STG_E_INSUFFICIENTMEMORY;
    }

    //The fat is placed in the buffer first, followed by the directory.
    SECT sect;
    SECT *asectFat;
    SECT *asectDif;
    CDirEntry *adeDir;

    SECT sectDifStart = _sectMax;
    SECT sectFatStart = _sectMax + cDifSect;
    SECT sectDirStart = _sectMax + cDifSect + cFatSect;

    asectDif = (SECT *)_pbBuf;
    asectFat = (SECT *)(_pbBuf + (cDifSect * SECTORSIZE));
    adeDir = (CDirEntry *)(_pbBuf + ((cFatSect + cDifSect) * SECTORSIZE));
    //asectFat and adeDir can be used as arrays.

    //Need to get the buffer to a correct 'empty' state.
    //  1)  Initialize fat and difat to all 0xff.
    memset(asectDif, 0xff, cDifSect * SECTORSIZE);
    memset(asectFat, 0xff, cFatSect * SECTORSIZE);

    //  2)  Initialize dir to all empty state
    for (USHORT i = 0; i < cDirSect * cdePerSect; i++)
    {
        adeDir[i].Init(STGTY_INVALID);
        simpAssert((BYTE *)&adeDir[i] <
                   _pbBuf + ((cFatSect + cDifSect + cDirSect) * SECTORSIZE));
    }


    if (cDifSect > 0)
    {
        //Put dif into fat.
        for (sect = sectDifStart; sect < sectFatStart; sect++)
        {
            asectFat[sect] = DIFSECT;
            simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);

            ULONG ulOffset = sect - sectDifStart;

            asectDif[ulOffset * cSectPerFat + (cSectPerFat - 1)] = sect + 1;
        }
        asectDif[((cDifSect - 1) * cSectPerFat) + (cSectPerFat - 1)] =
            ENDOFCHAIN;
        _hdr.SetDifStart(sectDifStart);
        _hdr.SetDifLength(cDifSect);
    }

    for (sect = sectFatStart;
         sect < sectDirStart;
         sect++)
    {
        asectFat[sect] = FATSECT;
        simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);

        ULONG ulOffset = sect - sectFatStart;

        if (ulOffset < CSECTFAT)
        {
            _hdr.SetFatSect(ulOffset, sect);
        }
        else
        {
            ulOffset -= CSECTFAT;
            asectDif[(ulOffset / (cSectPerFat - 1)) * cSectPerFat +
                     (ulOffset % (cSectPerFat - 1))] = sect;
        }
    }

    for (sect = sectDirStart;
         sect < sectDirStart + cDirSect;
         sect++)
    {
        asectFat[sect] = sect + 1;
        simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);
    }
    asectFat[sectDirStart + cDirSect - 1] = ENDOFCHAIN;
    simpAssert((BYTE *)&asectFat[sectDirStart + cDirSect - 1] <
               (BYTE *)adeDir);

    _hdr.SetDirStart(sectDirStart);
    _hdr.SetFatLength(cFatSect);

    //Fat, directory, and header are set up.  Woowoo.

    //Walk name list and construct directory and fat structures for
    //    user streams.
    //Write them out, then write out header.

    CDfNameList *pdfl;
    SID sid;
    pdfl = _pdfl;
    sid = 1;

    while (pdfl != NULL)
    {
        //Set up fat chain.
        SECT sectStart = pdfl->GetStart();
        ULONG cSect = (pdfl->GetSize() + SECTORSIZE - 1) / SECTORSIZE;

        for (sect = sectStart; sect < sectStart + cSect; sect++)
        {
            asectFat[sect] = sect + 1;
            simpAssert((BYTE *)&asectFat[sect] < (BYTE *)adeDir);
        }
        asectFat[sectStart + cSect - 1] = ENDOFCHAIN;
        simpAssert((BYTE *)&asectFat[sectStart + cSect - 1] < (BYTE *)adeDir);

        adeDir[sid].SetFlags(STGTY_STREAM);
        adeDir[sid].SetName(pdfl->GetName());
        adeDir[sid].SetStart(pdfl->GetStart());
        adeDir[sid].SetSize(pdfl->GetSize());
        adeDir[sid].SetColor(DE_BLACK);
        simpAssert((BYTE *)&adeDir[sid] <
                   _pbBuf + ((cFatSect + cDifSect + cDirSect) * SECTORSIZE));
        pdfl = pdfl->GetNext();
        sid++;
    }

    //Set up root entry.
    adeDir[0].Init(STGTY_ROOT);
    adeDir[0].SetName(&dfnRoot);
    adeDir[0].SetClassId(_clsid);
    adeDir[0].SetColor(DE_BLACK);

    //This recursively builds the btree and sets the root in the child
    //    of the root entry.
    adeDir[0].SetChild(BuildTree(adeDir, 1, _cStreams));


    //Write out buffer
    ULONG cbWritten;

    SetFilePointer(_hFile, ConvertSect(_sectMax), NULL, FILE_BEGIN);
    BOOL f= WriteFile(_hFile,
                      _pbBuf,
                      (cFatSect + cDifSect + cDirSect) * SECTORSIZE,
                      &cbWritten,
                      NULL);
    if (!f)
    {
        sc = STG_SCODE(GetLastError());
        delete _pbBuf;
        _pbBuf = NULL;
        return sc;
    }

    //Write out header
    DWORD dwErr;
    dwErr= SetFilePointer(_hFile, 0, NULL, FILE_BEGIN);
    if (dwErr == 0xFFFFFFFF)
    {
        sc = STG_SCODE(GetLastError());
        delete _pbBuf;
        _pbBuf = NULL;
        return sc;
    }

    f= WriteFile(_hFile,
                 _hdr.GetData(),
                 sizeof(CMSFHeaderData),
                 &cbWritten,
                 NULL);
    if (!f)
    {
        sc = STG_SCODE(GetLastError());
        delete _pbBuf;
        _pbBuf = NULL;
        return sc;
    }

    if (!(dwFlags & STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE))
    {
        f = FlushFileBuffers(_hFile);
        if (!f)
        {
            sc = STG_SCODE(GetLastError());
            delete _pbBuf;
            _pbBuf = NULL;
            return sc;
        }
    }

    delete _pbBuf;
    _pbBuf = NULL;

    _fDirty = FALSE;

    olLog(("%p::Out CSimpStorage::Commit().  ret == %lx\n",this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Revert, public
//
//  Synopsis:   Reverts transacted changes
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::Revert(void)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::DestroyElement, public
//
//  Synopsis:   Permanently deletes an element of a DocFile
//
//  Arguments:  [pwcsName] - Name of element
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::DestroyElement(WCHAR const *pwcsName)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::MoveElementTo, public
//
//  Synopsis:   Move an element of a DocFile to an IStorage
//
//  Arguments:  [pwcsName] - Current name
//              [ptcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  Algorithm:  Open source as storage or stream (whatever works)
//              Create appropriate destination
//              Copy source to destination
//              Set create time of destination equal to create time of source
//              If appropriate, delete source
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::MoveElementTo(WCHAR const *pwcsName,
                                             IStorage *pstgParent,
                                             OLECHAR const *ptcsNewName,
                                             DWORD grfFlags)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::RenameElement, public
//
//  Synopsis:   Renames an element of a DocFile
//
//  Arguments:  [pwcsName] - Current name
//              [pwcsNewName] - New name
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::RenameElement(WCHAR const *pwcsName,
                                             WCHAR const *pwcsNewName)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::SetElementTimes, public
//
//  Synopsis:   Sets element time stamps
//
//  Arguments:  [pwcsName] - Name
//              [pctime] - create time
//              [patime] - access time
//              [pmtime] - modify time
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::SetElementTimes(WCHAR const *pwcsName,
                                               FILETIME const *pctime,
                                               FILETIME const *patime,
                                               FILETIME const *pmtime)
{
    SCODE sc;
    
    olLog(("%p::In  CSimpStorage::SetElementTimes(%ws, %p, %p, %p)\n",
           this, pwcsName, pctime, patime, pmtime));

    SIMP_VALIDATE(SetElementTimes(pwcsName,
                                  pctime,
                                  patime,
                                  pmtime));
    
    if (pwcsName != NULL)
        return STG_E_INVALIDFUNCTION;

    if (!SetFileTime(_hFile,
                     pctime,
                     patime,
                     pmtime))
    {
        return STG_SCODE(GetLastError());
    }
    olLog(("%p::Out CSimpStorage::SetElementTimes().  ret == %lx\n",
           this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::SetClass(REFCLSID rclsid)
{
    olLog(("%p::In  CSimpStorage::SetClass(?)\n", this));
    SCODE sc;
    
    SIMP_VALIDATE(SetClass(rclsid));
    
    _clsid = rclsid;
    olLog(("%p::Out CSimpStorage::SetClass().  ret == %lx\n",
           this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::SetStateBits, public
//
//  Synopsis:   Sets state bits
//
//  Arguments:  [grfStateBits] - state bits
//              [grfMask] - state bits mask
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

_OLESTDMETHODIMP CSimpStorage::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStorage::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CSimpStorage::AddRef()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStorage::AddRef()\n"));

    AtomicInc(&_cReferences);
    ulRet = _cReferences;

    simpDebugOut((DEB_TRACE, "Out CSimpStorage::AddRef\n"));
    olLog(("%p::Out CSimpStorage::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CSimpStorage::QueryInterface(?, %p)\n",
           this, ppvObj));
    simpDebugOut((DEB_TRACE, "In  CSimpStorage::QueryInterface(?, %p)\n",
                ppvObj));

    SIMP_VALIDATE(QueryInterface(iid, ppvObj));

    sc = S_OK;
    if (IsEqualIID(iid, IID_IStorage) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStorage *)this;
        CSimpStorage::AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        *ppvObj = (IMarshal *)this;
        CSimpStorage::AddRef();
    }
    else if (IsEqualIID(iid, IID_IPropertySetStorage))
    {
        *ppvObj = (IPropertySetStorage *)this;
        CSimpStorage::AddRef();
    }
    else
        sc = E_NOINTERFACE;

    olLog(("%p::Out CSimpStorage::QueryInterface().  "
           "*ppvObj == %p  ret == %lx\n", this, *ppvObj, sc));
    simpDebugOut((DEB_TRACE, "Out CSimpStorage::QueryInterface => %p\n",
                ppvObj));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Invalid function.
//
//  Modifies:   [pcid]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::GetUnmarshalClass(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPCLSID pcid)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::GetMarshalSizeMax(REFIID riid,
                                                void *pv,
                                                DWORD dwDestContext,
                                                LPVOID pvDestContext,
                                                DWORD mshlflags,
                                                LPDWORD pcbSize)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::MarshalInterface(IStream *pstStm,
                                               REFIID riid,
                                               void *pv,
                                               DWORD dwDestContext,
                                               LPVOID pvDestContext,
                                               DWORD mshlflags)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::UnmarshalInterface(IStream *pstStm,
                                                 REFIID riid,
                                                 void **ppvObj)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::ReleaseMarshalData(IStream *pstStm)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorage::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorage::DisconnectObject(DWORD dwReserved)
{
    return STG_E_INVALIDFUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\simp\simpstg2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       simpstg2.cxx
//
//  Contents:   SimpStorageOpen class implementation
//
//  Classes:    CSimpStorageOpen, CSafeBYTEArray 
//
//  Functions:  
//
//  Notes:      No error labels, tried to use destructors for cleanup
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop

#include <expparam.hxx>

//+---------------------------------------------------------------------------
//
//  Class:      CSafeBYTEArray
//
//  Purpose:    automatically allocate & destroy an array of BYTEs
//
//  Interface:
//
//  History:    04-Jun-96   HenryLee    Created
//
//  Notes:      destructor automatically cleans up
//
//----------------------------------------------------------------------------

class CSafeBYTEArray
{
public:
    inline CSafeBYTEArray (ULONG cBYTE) {_p = new BYTE[cBYTE]; };
    inline ~CSafeBYTEArray () { delete [] _p; };
    inline operator BYTE* ()  { return _p; };
private:
    BYTE *_p;   // allowed to be NULL
};

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::Init, public
//
//  Synopsis:   Init function
//
//  Arguments:  [psdh] -- Pointer to hints structure
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//              14-Oct-97       HenryLee       recoginize CNSS file format
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::Init(WCHAR const * pwcsName, DWORD grfMode,
                             SSimpDocfileHints *psdh)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_ITRACE,
                 "In  CSimpStorageOpen::Init:%p(%ws)\n", this, pwcsName));

#ifdef UNICODE
    TCHAR const *atcPath = pwcsName;
#else
    TCHAR atcPath[_MAX_PATH+1];

    UINT uCodePage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;

    if (!WideCharToMultiByte( uCodePage, 0, pwcsName, -1,
            atcPath, _MAX_PATH + 1, NULL, NULL))
    {
        return STG_E_INVALIDNAME;
    }
#endif

    DWORD dwMode;
    switch (grfMode & (STGM_READ | STGM_WRITE | STGM_READWRITE)) 
    {
        case STGM_READWRITE : dwMode = GENERIC_READ | GENERIC_WRITE; break;
        case STGM_READ : dwMode = GENERIC_READ;  break;
        case STGM_WRITE : dwMode = GENERIC_WRITE; break;
    }

    _hFile = CreateFileT(atcPath, dwMode, 0,
                        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
        return Win32ErrorToScode(GetLastError());
    }

    _grfMode = grfMode;
    _sectMax = 0;
    _fDirty = FALSE;
    _clsid = IID_NULL;
    _grfStateBits = 0;
    lstrcpyW (_awcsName, pwcsName);

    ULONG cbRead;
    BOOL f= ReadFile(_hFile, _hdr.GetData(), HEADERSIZE, &cbRead, NULL);
    if (!f)
    {
        return Win32ErrorToScode(GetLastError());
    }

    if (cbRead != HEADERSIZE)
    {
        return STG_E_READFAULT;
    }

    if (!SUCCEEDED(sc = ValidateHeader(_hdr)))
    {
        return sc;
    }

    ULONG ulEndOfFile = GetFileSize(_hFile, NULL);
    if (ulEndOfFile == 0xFFFFFFFF && GetLastError() != NO_ERROR)
        return Win32ErrorToScode(GetLastError());

    const BOOL  fCNSS = _hdr.GetDirStart() == 0;
    const ULONG ulFatStart=_hdr.GetFatStart()*SECTORSIZE + HEADERSIZE;
    const ULONG ulDifStart=_hdr.GetDifStart()*SECTORSIZE + HEADERSIZE;
    const ULONG ulFatLength = _hdr.GetFatLength()*SECTORSIZE;
    const ULONG ulDifLength = _hdr.GetDifLength()*SECTORSIZE;
    const ULONG ulDirLength = fCNSS ?
                              (ulDifLength != 0 ? ulDifStart-HEADERSIZE :
                                                  ulFatStart-HEADERSIZE)
                            : ulEndOfFile - ulFatStart - ulFatLength;
    const ULONG cBytes = ulDirLength + ulFatLength + ulDifLength;

    if (ulFatLength == 0 || ulDirLength == 0)
        return STG_E_DOCFILECORRUPT;

    DWORD dwErr;
    CSafeBYTEArray pByte (cBytes);
    
    if (pByte == NULL)
        return STG_E_INSUFFICIENTMEMORY;

    if ((dwErr = SetFilePointer (_hFile, fCNSS ? HEADERSIZE :
                 (ulDifLength == 0 ?  ulFatStart : ulDifStart),
                 NULL, FILE_BEGIN)) == 0xFFFFFFFF)
    {
        return Win32ErrorToScode(GetLastError());
    }

    // Read the FAT, DIFAT, and Directory into one big buffer
    //
    if (!(f=ReadFile(_hFile, pByte, cBytes, &cbRead, NULL)))
    {
        return Win32ErrorToScode(GetLastError());
    }
    if (cbRead != cBytes)
    {
        return STG_E_READFAULT;
    }

    if (!SUCCEEDED(sc = ValidateDirectory(
        fCNSS ? pByte+0 : pByte+ulDifLength+ulFatLength, ulDirLength)))
    {
        return sc;
    }

    if (!SUCCEEDED(sc = ValidateFat ((SECT*)
        (fCNSS ? pByte+ulDirLength+ulDifLength : pByte+ulDifLength),
        ulFatLength)))
    {
        return sc;
    }

    if (ulDifLength != 0 && !SUCCEEDED(sc = ValidateDIFat ((SECT *)
        (fCNSS ? pByte+ulDirLength : pByte+0),
        ulDifLength, _hdr.GetFatSect(CSECTFAT-1))))
    {
        return sc;
    }

    simpDebugOut((DEB_ITRACE, "Out CSimpStorage::Init\n"));
    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateHeader, public
//
//  Synopsis:   verifies header is in simple mode format
//
//  Arguments:  [hdr] -- reference to a docfile header
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//              14-Oct-97       HenryLee       recoginize CNSS file format
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateHeader (CMSFHeader &hdr)
{
    SCODE sc = S_OK;

    if (!SUCCEEDED(sc = hdr.Validate()))
    {
        return sc;
    }

    const SECT sectDifStart = hdr.GetDifStart();
    const SECT sectFatStart = hdr.GetFatStart();
    const SECT sectDirStart = hdr.GetDirStart();

    // in simple mode, DifStart < FatStart < DirStart
    //
    if(hdr.GetMiniFatStart() != ENDOFCHAIN || hdr.GetMiniFatLength() != 0 ||
       (sectDifStart != ENDOFCHAIN && sectDifStart >= sectFatStart))
    {
        return STG_E_OLDFORMAT;
    }

    // in simple mode, DifStart+DifLength = FatStart
    //                 FatStart+FatLength = DirStart
    //
    // in CNSS mode, DirStart+DirLength = DifStart
    //               DifStart+DifLength = FatStart
    //               DirStart = 0
    //
    if (sectDifStart != ENDOFCHAIN &&
        (sectDifStart + hdr.GetDifLength() != sectFatStart))
    {
        return STG_E_OLDFORMAT;
    }

    if (sectDirStart != 0 &&
        (sectFatStart + hdr.GetFatLength() != sectDirStart))
    {
            return STG_E_OLDFORMAT;
    }

    // make sure the FAT is contiguous within the header
    //
    for (INT i=1; i < CSECTFAT; i++)
    {
        if (hdr.GetFatSect(i) == FREESECT)
            break;

        if (hdr.GetFatSect(i-1)+1 != hdr.GetFatSect(i))
            return STG_E_OLDFORMAT;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateDirectory, public
//
//  Synopsis:   verifies stream entries are correct
//
//  Arguments:  
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//              14-Oct-97       HenryLee       recoginize CNSS file format
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateDirectory (BYTE *pByte, ULONG ulDirLength)
{
    SCODE sc = S_OK;
    CDfNameList *pdflRoot = _pdfl;
    SECT sectStartLowest = ENDOFCHAIN;
    ULONG ulSize = 0;
    ULONG cbStorages = 0;
    CDirEntry *pde = (CDirEntry *) pByte;

    // Read the directory entries until the end of buffer
    CDfNameList *pdflPrev = NULL;
    for (ULONG i=0; i < ulDirLength/sizeof(CDirEntry); i++)
    {
         if (!pde[i].IsFree())
         {
              if (pde[i].GetFlags() != STGTY_ROOT &&
                  pde[i].GetFlags() != STGTY_STREAM &&
                  pde[i].GetFlags() != STGTY_STORAGE)
                  return STG_E_OLDFORMAT;

              if (STORAGELIKE(pde[i].GetFlags()))
              {
                  cbStorages++;       // first entry must be a storage
                  if (pdflPrev != NULL || cbStorages > 1) 
                      return STG_E_OLDFORMAT;
              }

              if (pde[i].GetRightSib() == (SID) i ||
                  pde[i].GetLeftSib()  == (SID) i)
                return STG_E_DOCFILECORRUPT;

              CDfNameList *pdfl = new CDfNameList;
              if (pdfl != NULL)
              {  
                  pdfl->SetDfName(pde[i].GetName());
                  pdfl->SetStart(pde[i].GetStart());

                  if (sectStartLowest > pdfl->GetStart())
                      sectStartLowest = pdfl->GetStart();

#ifdef LARGE_STREAMS
                  pdfl->SetSize((ULONG)pde[i].GetSize(FALSE));
#else
                  pdfl->SetSize((ULONG)pde[i].GetSize());
#endif
                  pdfl->Insert (&_pdfl, pdflPrev, NULL);  //insert at end
                  pdflPrev = pdfl;
              }
              else return STG_E_INSUFFICIENTMEMORY;
         }
    }

    pdflRoot = _pdfl;
    if (pdflRoot == 0 || pdflRoot->GetStart() != ENDOFCHAIN ||
                         pdflRoot->GetSize() != 0)
    {
        return STG_E_OLDFORMAT;
    }
    else pdflRoot = pdflRoot->GetNext();

    // make sure streams are one after another
    //
    for (CDfNameList *pdfl = pdflRoot; pdfl != NULL; pdfl = pdfl->GetNext())
    {
        // start should be after another stream's end
        // In the CNSS case, the pdflRoot points to 1st stream in file
        // In the docfile case, entry with 0 start sector is 1st stream in file
        if (pdfl->GetStart() != sectStartLowest) // skip 1st stream
        {
            CDfNameList *pdfl2 = NULL;
            for (pdfl2 = pdflRoot; pdfl2 != NULL; pdfl2=pdfl2->GetNext())
            {
                if (pdfl->GetStart() == (pdfl2->GetStart() + (
                    pdfl2->GetSize()+SECTORSIZE-1)/SECTORSIZE))
                    break;
            }
            if (pdfl2 == NULL)            // did not find a match
                return STG_E_OLDFORMAT;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateFat, public
//
//  Synopsis:   verifies that stream sectors are contiguous
//
//  Arguments:  [pSect] array of Fat sectors
//              [ulFatLength] length of the Fat
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateFat (SECT *pSect, ULONG ulFatLength)
{
    SCODE sc = S_OK;

    simpAssert  (_pdfl != NULL && pSect != NULL);

    for (CDfNameList *pdfl = _pdfl->GetNext(); pdfl; pdfl = pdfl->GetNext())
    {
        SECT sectStart = pdfl->GetStart();
        ULONG ulSize = pdfl->GetSize();

        SECT *psect = &pSect[sectStart];
        SECT sectCount = sectStart+1;

        for (ULONG i = sectStart; 
                   i < sectStart + (ulSize+SECTORSIZE-1)/SECTORSIZE; i++)
        {
            if (*psect != sectCount && *psect != ENDOFCHAIN)
                return STG_E_OLDFORMAT;
            psect++;         // check for sector numbers
            sectCount++;     // increasing in order by 1
        }

        if ((ULONG)(psect - pSect) > ulFatLength / sizeof(SECT))
        {
            return STG_E_OLDFORMAT;
        }
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::ValidateDIFat, public
//
//  Synopsis:   verifies that FAT sectors are contiguous
//
//  Arguments:  [pSect] array of DIFat sectors
//              [ulDIFatLength] length of the DIFat
//              [sectStart] last Fat sector in header
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//----------------------------------------------------------------------------

SCODE CSimpStorageOpen::ValidateDIFat (SECT *pSect, ULONG ulDIFatLength,
                                       SECT sectStart)
{
    SCODE sc = S_OK;
    simpAssert (pSect != NULL);
    simpAssert (sectStart != ENDOFCHAIN);

    SECT *psect = pSect;
    SECT sectCount = sectStart + 1;
    SECT iLastSect = SECTORSIZE / sizeof(SECT);

    for (ULONG i = 0; i < ulDIFatLength/sizeof(SECT); i++)
    {
        // skip last sector entry
        if (*psect != FREESECT && ((i+1) % iLastSect) != 0)
        { 
            if (*psect != sectCount)
                return STG_E_OLDFORMAT;

            sectCount++;     // check for sector numbers increasing by 1
        }
        psect++; 
    }

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::Release, public
//
//  Synopsis:   Releases resources for a CSimpStorageOpen
//              override CSimpStorage::Release because of delete this
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStorageOpen::Release(void)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen::Release()\n"));
    simpAssert(_cReferences > 0);

    LONG lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        if (_fDirty)
            Commit(STGC_DEFAULT);
        CloseHandle(_hFile);         // streams are not reverted
        delete this;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::Release()\n"));
    return (ULONG) lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen::Stat(%p)\n", pstatstg));

    SIMP_VALIDATE(Stat(pstatstg, grfStatFlag));
    
    if (GetFileTime(_hFile, &pstatstg->ctime, &pstatstg->atime,
                            &pstatstg->mtime) == FALSE)
    {
        return Win32ErrorToScode(GetLastError());
    }

    if ((grfStatFlag & STATFLAG_NONAME) == 0)
    {
        if ((pstatstg->pwcsName = (WCHAR*) CoTaskMemAlloc(
            (lstrlenW(_awcsName)+1)*sizeof(WCHAR))) == 0)
        {
            return STG_E_INSUFFICIENTMEMORY;
        }
        lstrcpyW (pstatstg->pwcsName, _awcsName);
    }

    pstatstg->grfMode = _grfMode;
    pstatstg->clsid = _clsid;
    pstatstg->grfStateBits = _grfStateBits;

    pstatstg->type = STGTY_STORAGE;
    ULISet32(pstatstg->cbSize, 0);
    pstatstg->grfLocksSupported = 0;
    pstatstg->STATSTG_dwStgFmt = 0;

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::Stat\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::OpenStream, public
//
//  Synopsis:   Opens an existing stream
//
//  Arguments:  [pwcsName] - Name
//              [reserved1]
//              [grfMode] - Permissions
//              [reserved2]
//              [ppstm] - Stream return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppstm]
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::OpenStream(WCHAR const *pwcsName,
                                          void *reserved1,
                                          DWORD grfMode,
                                          DWORD reserved2,
                                          IStream **ppstm)
{
    SCODE sc = S_OK;
    simpAssert  (_pdfl != NULL);
    CDfNameList *pdflLoop = _pdfl->GetNext();
    CDfName dfn;

    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen:OpenStream("
                "%ws, %p, %lX, %lu, %p)\n", pwcsName, reserved1,
                grfMode, reserved2, ppstm));

    SIMP_VALIDATE(OpenStream(pwcsName,
                             reserved1,
                             grfMode,
                             reserved2,
                             ppstm));
    
    if (_pdflCurrent != NULL)
        return STG_E_INVALIDFUNCTION;

    if (grfMode != (STGM_READWRITE | STGM_SHARE_EXCLUSIVE) &&
        grfMode != (STGM_READ      | STGM_SHARE_EXCLUSIVE))
        return STG_E_INVALIDFLAG;

    if (_grfMode == (STGM_READ      | STGM_SHARE_EXCLUSIVE)  &&
         grfMode == (STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
        return STG_E_ACCESSDENIED;

    dfn.Set(pwcsName);
    while (pdflLoop != NULL)
    {
        INT iCmp = CDirectory::NameCompare(&dfn, pdflLoop->GetName());
        if (iCmp == 0)
        {
            //Found a stream with this name
            CSimpStreamOpen *pstm = new CSimpStreamOpen ();
            if (pstm != NULL)
            {
                _pdflCurrent = pdflLoop;
                if (!SUCCEEDED(sc = pstm->Init (this, _hFile, 
                              (_pdflCurrent->GetStart()+1)*SECTORSIZE,
                               grfMode, _pdflCurrent)))
                {
                    delete pstm;
                    pstm = NULL;
                    _pdflCurrent = NULL;
                }
                *ppstm = pstm;
                break;
            }
            else return STG_E_INSUFFICIENTMEMORY;
        }
        pdflLoop = pdflLoop->GetNext();
    }

    if (pdflLoop == NULL)
    {
        sc = STG_E_FILENOTFOUND;
    }

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::OpenStream => %p\n",
                *ppstm));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::CreateStream, public
//
//  Synopsis:   stub
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::CreateStream(WCHAR const *pwcsName,
                            DWORD grfMode,
                            DWORD reserved1,
                            DWORD reserved2,
                            IStream **ppstm)
{
    simpDebugOut((DEB_TRACE, "Stb CSimpStorageOpen::CreateStream\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::EnumElements, public
//
//  Synopsis:   Starts an iterator
//
//  Arguments:  [reserved1]
//              [reserved2]
//              [reserved3]
//              [ppenm] - Enumerator return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppenm]
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::EnumElements(DWORD reserved1,
                                           void *reserved2,
                                           DWORD reserved3,
                                           IEnumSTATSTG **ppenm)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStorageOpen::EnumElements\n"));
    SCODE sc = S_OK;

    SIMP_VALIDATE(EnumElements(reserved1,
                               reserved2,
                               reserved3,
                               ppenm));
    
    if ((*ppenm = new CSimpEnumSTATSTG (_pdfl, _pdfl)) == NULL)
        sc = STG_E_INSUFFICIENTMEMORY;

    simpDebugOut((DEB_TRACE, "Out CSimpStorageOpen::EnumElements => %x\n", sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStorageOpen::SetClass, public
//
//  Synopsis:   Sets storage class
//
//  Arguments:  [clsid] - class id
//
//  Returns:    Appropriate status code
//
//  History:    04-May-96       HenryLee       Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStorageOpen::SetClass(REFCLSID rclsid)
{
    simpDebugOut((DEB_TRACE, "Stb CSimpStorageOpen::SetClass\n"));
    return STG_E_INVALIDFUNCTION;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\stgdbg\bighdr.h ===
extern "C" {
#undef DBG
#define DBG 1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <rpc.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define private   public
#define protected public

#include <ole2.h>

// ole\stg\h

#include <docfilep.hxx>
#include <msf.hxx>
#include <publicdf.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\stgdbg\stgdbg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       stgdbg.cxx
//
//  Contents:   OLE Storage debugger extention DLL
//
//  Classes:
//
//  Functions:
//
//  History:    8-05-94   kevinro   Created
//              5/02/97 bchapman  Debugged and added storage features
//
//----------------------------------------------------------------------------

#include "bighdr.h"

#include "stgdbg.h"

PNTSD_EXTENSION_APIS    pExtApis;
HANDLE                  hDbgThread;
HANDLE                  hDbgProcess;

//
char achTokenBuf[1024];
char *pszTokenNext = NULL;
char *pszToken = NULL;

void InitTokenStr(LPSTR lpszString)
{
    if (lpszString)
    {
	strcpy(achTokenBuf,lpszString);
    }
    else
    {
	achTokenBuf[0]=0;
    }

    pszTokenNext = achTokenBuf;
    pszToken = NULL;
}

char *NextToken()
{
    return(NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadMemory
//
//  Synopsis:   Reads memory from the debuggee
//
//  Effects:
//
//  Arguments:  [pvAddress] --
//		[cbMemory] --
//		[pvLocalMemory] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
ReadMemory( PVOID               pvAddress,
            ULONG               cbMemory,
            PVOID               pvLocalMemory)
{
    ULONG       cbActual = cbMemory;

    if (ReadProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return((DWORD)-1);
        }
        return(0);
    }
    return(GetLastError());

}

//+---------------------------------------------------------------------------
//
//  Function:   WriteMemory
//
//  Synopsis:   Writes memory to the debuggee
//
//  Effects:
//
//  Arguments:  [pvLocalMemory] --
//		[cbMemory] --
//		[pvAddress] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    8-05-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD
WriteMemory(PVOID           pvLocalMemory,
            ULONG           cbMemory,
            PVOID           pvAddress)
{
    ULONG       cbActual = cbMemory;

    if (WriteProcessMemory(hDbgProcess, pvAddress, pvLocalMemory, cbMemory, &cbActual))
    {
        if (cbActual != cbMemory)
        {
            return((DWORD)-1);
        }
        return(0);
    }
    return(GetLastError());
}
#define AllocHeap(x)    RtlAllocateHeap(RtlProcessHeap(), 0, x)
#define FreeHeap(x) 	RtlFreeHeap(RtlProcessHeap(), 0, x)


DWORD
GetOleTlsEntry(PVOID *     ppvValue)
{
    NTSTATUS                    Status;
    THREAD_BASIC_INFORMATION    ThreadInfo;
    ULONG                       cbReturned;
    TEB                         Teb;

    Status = NtQueryInformationThread(  hDbgThread,
                                        ThreadBasicInformation,
                                        &ThreadInfo,
                                        sizeof(ThreadInfo),
                                        &cbReturned);

    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    ReadMemory(ThreadInfo.TebBaseAddress, sizeof(TEB), &Teb);

    *ppvValue = Teb.ReservedForOle;

    return(0);

}

DWORD
GetOleThreadBase(DWORD *psmBase)
{
    SOleTlsData oleBuf;
    PVOID OleTlsAddr;
    DWORD err;

    if(err = GetOleTlsEntry(&OleTlsAddr))
        return err;

    if(err = ReadMemory(OleTlsAddr, sizeof(SOleTlsData), &oleBuf))
        return err;

    *psmBase = (DWORD)oleBuf.pvThreadBase;

    return 0;
}

void ShowBinaryData(PBYTE   pData,
                    DWORD   cbData)
{
    DWORD                   i;
    char                    line[20];
    PNTSD_EXTENSION_APIS    lpExt = pExtApis;

    line[16] = '\0';
    if (cbData > 65536)
    {
        ntsdPrintf("ShowBinaryData:  Data @%x is said to be %d bytes in length\n");
        ntsdPrintf("                 Rejecting request.  Corrupt data\n");
        return;
    }
    for (; cbData > 0 ; )
    {
        for (i = 0; i < 16 && cbData > 0 ; i++, cbData-- )
        {
            ntsdPrintf(" %02x", (unsigned) *pData);
            if (isprint(*pData))
                line[i] = *pData;
             else
                line[i] = '.';
            pData++;
        }
        if (i < 16)
        {
            for (;i < 16 ; i++ )
            {
                ntsdPrintf("   ");
                line[i] = ' ';
            }
        }
        ntsdPrintf("\t%s\n",line);
        if (lpExt->lpCheckControlCRoutine())
        {
            break;
        }

    }
}



BOOL
IsDebug_olethk32()
{
    ULONG addr;
    DWORD dwValue;
    addr = ntsdGetExpr("olethk32!oledbgCheck_olethk32");

    if (addr == 0)
    {
	ntsdPrintf("warning: olethk32 not debug version\n");
	return(0);
    }

    if (ReadMemory((LPVOID)addr,sizeof(dwValue),(PVOID)&dwValue))
    {
	ntsdPrintf("warning: could not read check value at %x\n",addr);
	return(0);
    }

     if (dwValue != 0x12345678)
    {
	ntsdPrintf("warning: olethk32!oledbgCheck_olethk32 value wrong\n");
	ntsdPrintf("warning: suspect wrong symbols for olethk32\n");
	return(0);
    }
    return(1);
}


BOOL
IsDebug_ole32()
{
    ULONG addr;
    DWORD dwValue;
    addr = ntsdGetExpr("ole32!oledbgCheck_ole32");
    if (addr == 0)
    {
	ntsdPrintf("warning: ole32 not debug version\n");
	return(0);
    }

    if (ReadMemory((LPVOID)addr,sizeof(dwValue),(PVOID)&dwValue))
    {
	ntsdPrintf("warning: could not read check value at %x\n",addr);
	return(0);
    }

    if (dwValue != 0x12345678)
    {
	ntsdPrintf("warning: olethk32!oledbgCheck_ole32 value wrong\n");
	ntsdPrintf("warning: suspect wrong symbols for ole32\n");
	return(0);
    }
    return(1);
}

//+---------------------------------------------------------------------------
//
//  Function:   DumpVtbl
//
//  Synopsis:   Dumps a vtbl to the debugger
//
//  Effects:	Given a pointer to a vtbl, output the name of the vtbl, and
//		its contents to the debugger.
//
//  Arguments:  [pvtbl] -- Address of vtbl
//		[pszCommand] -- Symbolic expression for pvtbl
//
//  History:    8-07-94   kevinro   Created
//
//----------------------------------------------------------------------------
//extern "C"
void
DumpVtbl(PVOID pvtbl, LPSTR pszCommand)
{
   DWORD dwVtblOffset;
   char achNextSymbol[256];

   if (pvtbl == 0)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s has a vtbl pointer of NULL\n",pszCommand);
       return;
   }

   if ((DWORD)pvtbl == 0xdededede)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s may be deleted memory. pvtbl==0xdededede\n",pszCommand);
       return;
   }

   // This value points at the VTBL. Find a symbol for the VTBL
   ntsdGetSymbol((LPVOID)pvtbl,(UCHAR *)achNextSymbol,(LPDWORD)&dwVtblOffset);

   // If the dwVtblOffset is not zero, then we are pointing into the table.
   // This could mean multiple inheritance. We could be tricky, and try to
   // determine the vtbl by backing up here. Maybe later
   if (dwVtblOffset != 0)
   {
       ntsdPrintf("Closest Previous symbol is %s at 0x%x (offset -0x%x)\n",
		  achNextSymbol,
		  (DWORD)pvtbl - dwVtblOffset,
		  dwVtblOffset);
       return;
   }
   ntsdPrintf("0x%08x -->\t %s\n",pvtbl,achNextSymbol);
   // vtbl entries should always point at functions. Therefore, we should
   // always have a displacement of zero. To check for the end of the table
   // we will reevaluate the vtbl pointer. If the offset isn't what we
   // expected, then we are done.

   DWORD dwIndex;
   for (dwIndex = 0 ; dwIndex < 4096 ; dwIndex += 4)
   {
       DWORD dwVtblEntry;

       ntsdGetSymbol((LPVOID)((DWORD)pvtbl+dwIndex),
		     (UCHAR *)achNextSymbol,
		     (LPDWORD)&dwVtblOffset);

       if (dwVtblOffset != dwIndex)
       {
	   //
	   // May have moved on to another vtable
	   //
#ifdef DBG_OLEDBG
	   ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
	   ntsdPrintf("Moved to another table?\n");
#endif
	   return;
       }

       if (ReadMemory((LPVOID)((DWORD)pvtbl+dwIndex),
		      sizeof(dwVtblEntry),
		      (PVOID)&dwVtblEntry))
       {
	   //
	   // Must be off the end of a page or something.
	   //
#ifdef DBG_OLEDBG
	   ntsdPrintf("End of page?\n");
#endif
	   return;
       }

       // If the function is at zero, then must be at end of table
       if (dwVtblEntry == 0)
       {
#ifdef DBG_OLEDBG
	   ntsdPrintf("dwVtblEntry is zero. Must be end of table\n");
	   return;
#endif

       }

       // Now, determine the symbol for the entry in the vtbl
       ntsdGetSymbol((LPVOID)dwVtblEntry,
		     (UCHAR *)achNextSymbol,
		     (LPDWORD)&dwVtblOffset);

       // If it doesn't point to the start of a routine, then it
       // probably isn't part of the vtbl
       if (dwVtblOffset != 0)
       {
#ifdef DBG_OLEDBG
	   ntsdPrintf("?? %s + %x\n",achNextSymbol,dwVtblOffset);
	   ntsdPrintf("Doesn't point to function?\n");
#endif
	   return;
       }

       ntsdPrintf("   0x%08x\t %s\n",dwVtblEntry,achNextSymbol);
   }
   ntsdPrintf("Wow, there were at least 1024 entries in the table!\n");

}

void
Dump_CFileStream(
        PVOID pv_arg,
        LPSTR pszCommand)
{
    CFileStream *pflst = (CFileStream *)pv_arg;

    ntsdPrintf("_sig = %8x", pflst->_sig);
    switch(pflst->_sig)
    {
    case CFILESTREAM_SIG:
        ntsdPrintf("\t(Valid)\n");
        break;
    case CFILESTREAM_SIGDEL:
        ntsdPrintf("\t(Deleted)\n");
        break;
    default:
        ntsdPrintf("\t(Invalid Signature)\n");
        break;
    }

    ntsdPrintf("_pgfst = %x\n", pflst->_pgfst);
    ntsdPrintf("_ppc   = %x\n", pflst->_ppc);
    ntsdPrintf("_hfile = %2x; _hMapObject = %2x\n",
                        pflst->_hFile, pflst->_hMapObject);
    ntsdPrintf("_hReserved  = %2x; _hPreDuped = %2x\n",
                        pflst->_hReserved, pflst->_hPreDuped);
    ntsdPrintf("_pbBaseAddr = %8x\n", pflst->_pbBaseAddr);
    ntsdPrintf("_cbViewSize = %6x\n", pflst->_cbViewSize);
}


void
Dump_CGlobalFileStream(
        PVOID pv_arg,
        LPSTR pszCommand)
{
    CGlobalFileStream *pgfst = (CGlobalFileStream *)pv_arg;

    ntsdPrintf("_df = %8x\n", pgfst->_df);
    ntsdPrintf("_dwStartFlags = %x\n", pgfst->_dwStartFlags);
    ntsdPrintf("_pMalloc      = %x\n", pgfst->_pMalloc);
    ntsdPrintf("_ulLowPos     = %x\n", pgfst->_ulLowPos);
#ifdef USE_FILEMAPPING
    ntsdPrintf("_cbMappedFileSize   = %6x\n", pgfst->_cbMappedFileSize);
    ntsdPrintf("_cbMappedCommitSize = %6x\n", pgfst->_cbMappedCommitSize);
    ntsdPrintf("_dwMapFlags = %x\n", pgfst->_dwMapFlags);
    ntsdPrintf("_awcMapName = %ws\n", pgfst->_awcMapName);
#endif
    ntsdPrintf("_awcPath = %ws\n", pgfst->_awcPath);
#ifdef ASYNC
    ntsdPrintf("_dwTerminate = %x\n", pgfst->_dwTerminate);
    ntsdPrintf("_ulHighWater = %x\n", pgfst->_ulHighWater);
    ntsdPrintf("_ulFailurePoint = %x\n", pgfst->_ulFailurePoint);
#endif
    ntsdPrintf("_ulLastFilePos = %x\n", pgfst->_ulLastFilePos);
}


extern "C" {  // Everything from here down is Extern "C"

void
punk(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
   PVOID punk;
   PVOID pvtbl;

   InitDebugHelp(hProcess, hThread, lpExt);

   // Evalute the first pointer. This is a pointer to the object
   punk = (PVOID) ntsdGetExpr(pszCommand);

   if (punk == NULL)
   {
       // Can't handle objects at zero
       ntsdPrintf("%s is not a valid pointer\n",pszCommand);
       return;
   }
   // Now, read the first DWORD of this memory location
   // This is a pointer to the table
   if (ReadMemory(punk,sizeof(pvtbl),(PVOID)&pvtbl))
   {
       ntsdPrintf("Couldn't read memory at %x\n",punk);
       return;
   }

   DumpVtbl(pvtbl,pszCommand);

}

void
vtbl(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
   PVOID pvtbl;

   InitDebugHelp(hProcess, hThread, lpExt);

   // Evalute the first pointer. This is a pointer to the table
   pvtbl = (PVOID) ntsdGetExpr(pszCommand);
   DumpVtbl(pvtbl,pszCommand);
}

void
expr(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    InitDebugHelp(hProcess, hThread, lpExt);

    UCHAR symbol[256];
    DWORD expr;
    DWORD disp;

    expr = ntsdGetExpr(pszCommand);

    ntsdGetSymbol((LPVOID)expr,(UCHAR *)symbol,(LPDWORD)&disp);

    ntsdPrintf("expr: %x (%d) %s+0x%x\n", expr, expr, symbol, disp);
}

void
isdbg(  HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    InitDebugHelp(hProcess, hThread, lpExt);

    if (IsDebug_ole32())
    {
	ntsdPrintf("ole32.dll is debug\n");
    }
    if (IsDebug_olethk32())
    {
	ntsdPrintf("olethk32.dll is debug\n");
    }
}

void
smbase(
        HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    DWORD smBase;

    InitDebugHelp(hProcess, hThread, lpExt);

    GetOleThreadBase(&smBase);

    ntsdPrintf("Shared memory base address = %x\n", smBase);
}


void
pflst(  HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    PVOID pflst;
    char buf[sizeof(CFileStream)];

    InitDebugHelp(hProcess, hThread, lpExt);

    pflst = (PVOID) ntsdGetExpr(pszCommand);

    if (ReadMemory(pflst,sizeof(CFileStream),(PVOID)buf))
    {
        ntsdPrintf("Couldn't read all %d bytes at 0x%x\n",
                             sizeof(CFileStream), pflst);
        return;
    }
    Dump_CFileStream(buf,pszCommand);
}


void
pgfst(  HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{
    PVOID pgfst;
    char buf[sizeof(CGlobalFileStream)];

    InitDebugHelp(hProcess, hThread, lpExt);

    pgfst = (PVOID) ntsdGetExpr(pszCommand);

    if (ReadMemory(pgfst,sizeof(CGlobalFileStream),(PVOID)buf))
    {
        ntsdPrintf("Couldn't read all %d bytes at 0x%x\n",
                             sizeof(CGlobalFileStream), pgfst);
        return;
    }
    Dump_CGlobalFileStream(buf,pszCommand);
}


void
help(   HANDLE                  hProcess,
        HANDLE                  hThread,
        DWORD                   dwCurrentPc,
        PNTSD_EXTENSION_APIS    lpExt,
        LPSTR                   pszCommand)
{

    InitDebugHelp(hProcess, hThread, lpExt);

    ntsdPrintf("   help		This Message\n");
    ntsdPrintf("COM commands:\n");
    ntsdPrintf("   isdbg          Determine if DLL's are debug\n");
    ntsdPrintf("   punk  <expr>   Dump IUnknown vtbl\n");
    ntsdPrintf("   vtbl  <expr>   Dump vtbl\n");
    ntsdPrintf("Storage commands:\n");
    ntsdPrintf("   smbase         Print shared memory base address\n");
    ntsdPrintf("   pflst <expr>   Dump CFileStream\n");
    ntsdPrintf("   pgfst <expr>   Dump CGlobalFileStream\n");

}

}; // end Extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\stgdbg\stgdbg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:
//
// Contents:
//
//
// History:
//
//------------------------------------------------------------------------

#include <ntsdexts.h>


extern "C" PNTSD_EXTENSION_APIS pExtApis;
extern "C" HANDLE               hDbgThread;
extern "C" HANDLE               hDbgProcess;
extern "C" char                 *pszToken;
extern "C" char                 *pszTokenNext;


#define ntsdPrintf    (pExtApis->lpOutputRoutine)
#define ntsdGetSymbol (pExtApis->lpGetSymbolRoutine)
#define ntsdGetExpr   (pExtApis->lpGetExpressionRoutine)
#define ntsdCheckC    (pExtApis->lpCheckControlCRoutine)


inline void InitDebugHelp(
        HANDLE hProc,
        HANDLE hThd,
        PNTSD_EXTENSION_APIS pApis)
{
    hDbgProcess = hProc;
    hDbgThread = hThd;
    pExtApis = pApis;
}

// #define InitDebugHelp(hProc,hThd,pApis) {hDbgProcess = hProc; hDbgThread = hThd; pExtApis = pApis;}

extern void InitTokenStr(LPSTR lpzString);
extern DWORD ReadMemory( PVOID pvAddress, ULONG cbMemory, PVOID pvLocalMemory);
extern DWORD WriteMemory(PVOID pvLocalMemory, ULONG cbMemory, PVOID pvAddress);
extern void ShowBinaryData(PBYTE   pData,DWORD   cbData);
extern BOOL IsDebug_olethk32();
extern BOOL IsDebug_ole32();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\simp\simpstm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	simpstm.cxx
//
//  Contents:	CStdStream implementation
//
//  Classes:	
//
//  Functions:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//----------------------------------------------------------------------------

#include "simphead.cxx"
#pragma hdrstop

#include <ole.hxx>
#include <logfile.hxx>
#include <expparam.hxx>


#if DBG == 1 && defined(SECURE_SIMPLE_MODE)
void CSimpStream::CheckSeekPointer(void)
{
    LONG lHighChk;
    ULONG ulLowChk;
    lHighChk = 0;
    ulLowChk = SetFilePointer(_hFile, 0, &lHighChk, FILE_CURRENT);
    if (ulLowChk == 0xFFFFFFFF)
    {
        //An error occurred while checking.
        simpDebugOut((DEB_ERROR, "SetFilePointer call failed with %lu\n",
                      GetLastError()));
    }
    else if ((ulLowChk != _ulSeekPos) || (lHighChk != 0))
    {
        simpDebugOut((DEB_ERROR, "Seek pointer mismatch."
                      "  Cached = %lu, Real = %lu, High = %lu\n",
                      _ulSeekPos, ulLowChk, lHighChk));
        simpAssert((ulLowChk == _ulSeekPos) && (lHighChk == 0));
    }
}
#define CheckSeek() CheckSeekPointer()
#else
#define CheckSeek()
#endif // DBG == 1 && defined(SECURE_SIMPLE_MODE)

//+---------------------------------------------------------------------------
//
//  Member:	CSimpStream::Init, public
//
//  Synopsis:	Initialize stream object
//
//  Arguments:	[pstgParent] -- Pointer to parent
//              [hFile] -- File handle for writes
//              [ulSeekStart] -- Beginning seek pointer
//
//  Returns:	Appropriate status code
//
//  Modifies:	
//
//  History:	04-Aug-94	PhilipLa	Created
//
//  Notes:	
//
//----------------------------------------------------------------------------

SCODE CSimpStream::Init(
    CSimpStorage *pstgParent,
    HANDLE hFile,
    ULONG ulSeekStart)
{
    simpDebugOut((DEB_ITRACE, "In  CSimpStream::Init:%p()\n", this));
    _ulSeekStart = ulSeekStart;
    _hFile = hFile;
    _pstgParent = pstgParent;
    _cReferences = 1;

#ifdef SECURE_SIMPLE_MODE    
    _ulHighWater = ulSeekStart;
#endif    
    _ulSeekPos = ulSeekStart;
    
    if (SetFilePointer(_hFile, ulSeekStart, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return STG_SCODE(GetLastError());
    }

    CheckSeek();
    
    if (!SetEndOfFile(_hFile))
    {
        return STG_SCODE(GetLastError());
    }
    
    simpDebugOut((DEB_ITRACE, "Out CSimpStream::Init\n"));
    return S_OK;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Read, public
//
//  Synopsis:   Read from a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return number of bytes read
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Read(VOID HUGEP *pb, ULONG cb, ULONG *pcbRead)
{
    ULONG cbRead;
    ULONG *pcb;
    SCODE sc;

    olLog(("%p::In  CSimpStream::Read(%p, %lu, %p)\n",
           this, pb, cb, pcbRead));

    SIMP_VALIDATE(Read(pb, cb, pcbRead));
    
    pcb = (pcbRead != NULL) ? pcbRead : &cbRead;

#ifdef SECURE_SIMPLE_MODE
    if (_ulSeekPos + cb > _ulHighWater)
    {
        ULONG cbTotalSize;
        cbTotalSize = GetFileSize(_hFile, NULL);

        if (_ulSeekPos + cb > cbTotalSize)
        {
            //Truncate.
            cb = (_ulSeekPos > cbTotalSize) ? 0 : cbTotalSize - _ulSeekPos;
        }
        
        //Part of this read would come from uninitialized space, so
        //  we need to return zeroes instead.
        if (_ulSeekPos > _ulHighWater)
        {
            if (SetFilePointer(_hFile,
                               _ulSeekPos + cb,
                               NULL,
                               FILE_BEGIN) == 0xFFFFFFFF)
            {
                //We can't get the seek pointer where it will need to
                //  end up, so return zero bytes and be done with it.
                *pcb = 0;
                return S_OK;
            }
            
            //Actually, the whole thing is coming from uninitialized
            //  space.  Why someone would do this is a mystery, but
            //  let's return zeroes anyway.
            memset(pb, SECURECHAR, cb);
            *pcb = cb;
            
            _ulSeekPos += cb;
        }
        else
        {
            ULONG cbBytesToRead = _ulHighWater - _ulSeekPos;
            
            if (FAILED(sc = Read(pb, cbBytesToRead, pcb)))
            {
                CheckSeek();
                return sc;
            }

            cb -= *pcb;
            
            if ((*pcb != cbBytesToRead) ||
                (SetFilePointer(_hFile,
                                _ulSeekPos + cb,
                                NULL,
                                FILE_BEGIN) == 0xFFFFFFFF))
            {
                //Either the Read call returned a weird number of bytes,
                //                     Or
                //We can't actually get the seek pointer where we need
                //  it, so return fewer bytes than we normally would,
                //  with a success code.
                CheckSeek();
                return S_OK;
            }
            
            //Zero the rest of the buffer.
            memset((BYTE *)pb + *pcb, SECURECHAR, cb);
            *pcb += cb;
            _ulSeekPos += cb;
        }
        CheckSeek();
        return S_OK;
    }
#endif
        
    //Maps directly to ReadFile call
    BOOL f = ReadFile(_hFile,
                      pb,
                      cb,
                      pcb,
                      NULL);

    _ulSeekPos += *pcb;
    
    CheckSeek();

    if (!f)
        return STG_SCODE(GetLastError());

    olLog(("%p::Out CSimpStream::Read().  *pcbRead == %lu, ret = %lx\n",
           this, *pcb, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Write, public
//
//  Synopsis:   Write to a stream
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Write(
    VOID const HUGEP *pb,
    ULONG cb,
    ULONG *pcbWritten)
{
    ULONG cbWritten;
    ULONG *pcb;
    BOOL f = TRUE;
    SCODE sc = S_OK;
    
    olLog(("%p::In  CSimpStream::Write(%p, %lu, %p)\n",
           this, pb, cb, pcbWritten));

    SIMP_VALIDATE(Write(pb, cb, pcbWritten));
    
    pcb = (pcbWritten != NULL) ? pcbWritten : &cbWritten;

    if (_ulSeekPos + cb >= OLOCKREGIONBEGIN)
        return STG_E_DOCFILETOOLARGE;

#ifdef SECURE_SIMPLE_MODE
    if (_ulSeekPos > _ulHighWater)
    {
        //We're leaving a gap in the file, so we need to fill in that
        //   gap.  Sad but true.
        ULONG cbBytesToWrite = _ulSeekPos - _ulHighWater;

        ULONG cbWrittenSecure;
    
        if (SetFilePointer(_hFile,
                           _ulHighWater,
                           NULL,
                           FILE_BEGIN) != 0xFFFFFFFF)
        {
            while (cbBytesToWrite > 0)
            {
                if (!(f = WriteFile(_hFile,
                                    s_bufSecure,
                                    min(MINISTREAMSIZE, cbBytesToWrite),
                                    &cbWrittenSecure,
                                    NULL)))
                {
                    break;
                }
                cbBytesToWrite -= cbWrittenSecure;
            }
            if ((!f) && (SetFilePointer(_hFile,
                               _ulSeekPos,
                               NULL,
                               FILE_BEGIN) == 0xFFFFFFFF))
            {
                return STG_SCODE(GetLastError());
            }
        }
        CheckSeek();
    }
#endif    
    //Maps directly to WriteFile call
    f = WriteFile(_hFile,
                       pb,
                       cb,
                       pcb,
                       NULL);

    _ulSeekPos += *pcb;
#ifdef SECURE_SIMPLE_MODE
    if (_ulSeekPos > _ulHighWater)
        _ulHighWater = _ulSeekPos;
#endif

    if (!f)
    {
        sc = STG_SCODE(GetLastError());
    }

    CheckSeek();
    olLog(("%p::Out CSimpStream::Write().  "
           "*pcbWritten == %lu, ret = %lx\n",
           this, *pcb, sc));

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Seek(LARGE_INTEGER dlibMove,
                               DWORD dwOrigin,
                               ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc = S_OK;
    LONG lMove;
    ULONG ulPos;

    simpAssert((dwOrigin == STREAM_SEEK_SET) || (dwOrigin == STREAM_SEEK_CUR) ||
               (dwOrigin == STREAM_SEEK_END));

    olLog(("%p::In  CSimpStream::Seek(%ld, %lu, %p)\n",
           this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));

    SIMP_VALIDATE(Seek(dlibMove, dwOrigin, plibNewPosition));
    
    // Truncate dlibMove to 32 bits
    if (dwOrigin == STREAM_SEEK_SET)
    {
        // Make sure we don't seek too far
        if (LIGetHigh(dlibMove) != 0)
            LISet32(dlibMove, 0xffffffff);
    }
    else
    {
        // High dword must be zero for positive values or -1 for
        // negative values
        // Additionally, for negative values, the low dword can't
        // exceed -0x80000000 because the 32nd bit is the sign
        // bit
        if (LIGetHigh(dlibMove) > 0 ||
            (LIGetHigh(dlibMove) == 0 &&
             LIGetLow(dlibMove) >= 0x80000000))
            LISet32(dlibMove, 0x7fffffff);
        else if (LIGetHigh(dlibMove) < -1 ||
                 (LIGetHigh(dlibMove) == -1 &&
                  LIGetLow(dlibMove) <= 0x7fffffff))
            LISet32(dlibMove, 0x80000000);
    }

    lMove = (LONG)LIGetLow(dlibMove);
    
    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
        ulPos = _ulSeekStart + lMove;
        break;
        
    case STREAM_SEEK_END:
        ULONG cbSize;
        cbSize = GetFileSize(_hFile, NULL);
        
        if (lMove < 0)
        {
            if ((ULONG)(-lMove) > (cbSize - _ulSeekStart))
                return STG_E_INVALIDFUNCTION;
        }
        ulPos = cbSize+lMove;
        break;
        
    case STREAM_SEEK_CUR:
        ulPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);
        
        if (lMove < 0)
        {
            if ((ULONG)(-lMove) > (ulPos - _ulSeekStart))
                return STG_E_INVALIDFUNCTION;
        }
        ulPos += lMove;
        break;
    }

    ulPos = SetFilePointer(_hFile,
                           ulPos,
                           NULL,
                           FILE_BEGIN);

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, ulPos - _ulSeekStart);
    }

    _ulSeekPos = ulPos;

    CheckSeek();

    olLog(("%p::Out CSimpStream::Seek().  ulPos == %lu,  ret == %lx\n",
           this, ulPos, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::SetSize, public
//
//  Synopsis:   Sets the size of a stream
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::SetSize(ULARGE_INTEGER ulNewSize)
{
    ULONG ulCurrentPos;
    SCODE sc;
    
    olLog(("%p::In  CSimpStream::SetSize(%lu)\n",
           this, ULIGetLow(ulNewSize)));

    SIMP_VALIDATE(SetSize(ulNewSize));
    
    ulCurrentPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);

    if (ulCurrentPos == 0xFFFFFFFF)
    {
        return STG_SCODE(GetLastError());
    }
    
    if (ULIGetHigh(ulNewSize) != 0 ||
        ulCurrentPos + ULIGetLow(ulNewSize) >= OLOCKREGIONBEGIN)
        return STG_E_DOCFILETOOLARGE;

    if (SetFilePointer(_hFile,
                       ULIGetLow(ulNewSize) + _ulSeekStart,
                       NULL,
                       FILE_BEGIN) == 0xFFFFFFFF)
    {
        CheckSeek();
        return STG_SCODE(GetLastError());
    }
    
    if (!SetEndOfFile(_hFile))
    {
        SetFilePointer(_hFile, ulCurrentPos, NULL, FILE_BEGIN);

        CheckSeek();
        return STG_SCODE(GetLastError());
    }

#ifdef SECURE_SIMPLE_MODE
    // if we are shrinking the stream below the highwater mark, reset it
    if (ULIGetLow(ulNewSize) + _ulSeekStart < _ulHighWater)
    {
        _ulHighWater = ULIGetLow(ulNewSize) + _ulSeekStart;
    }
#endif    
        
    if (SetFilePointer(_hFile, ulCurrentPos, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        _ulSeekPos = ULIGetLow(ulNewSize) + _ulSeekStart;
        CheckSeek();
        return STG_SCODE(GetLastError());
    }
    
    CheckSeek();
    olLog(("%p::Out CSimpStream::SetSize().  ret == %lx\n", this, S_OK));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::CopyTo, public
//
//  Synopsis:   Copies information from one stream to another
//
//  Arguments:  [pstm] - Destination
//              [cb] - Number of bytes to copy
//              [pcbRead] - Return number of bytes read
//              [pcbWritten] - Return number of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//              [pcbWritten]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::CopyTo(IStream *pstm,
                                 ULARGE_INTEGER cb,
                                 ULARGE_INTEGER *pcbRead,
                                 ULARGE_INTEGER *pcbWritten)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::CopyTo("
                  "%p, %lu, %p, %p)\n", pstm, ULIGetLow(cb),
                  pcbRead, pcbWritten));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::CopyTo\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStream::Release(void)
{
    LONG lRet;

    olLog(("%p::In  CSimpStream::Release()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Release()\n"));

    simpAssert(_cReferences > 0);
    lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
#ifdef SECURE_SIMPLE_MODE
        _pstgParent->ReleaseCurrentStream(_ulHighWater);
#else        
        _pstgParent->ReleaseCurrentStream();
#endif        
        
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::Release\n"));
    olLog(("%p::Out CSimpStream::Release().  ret == %lu\n", this, lRet));
    FreeLogFile();
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;

    simpDebugOut((DEB_TRACE, "In  CSimpStream::Stat(%p, %lu)\n",
                  pstatstg, grfStatFlag));

    SIMP_VALIDATE(Stat(pstatstg, grfStatFlag));
    
    memset (pstatstg, 0, sizeof(STATSTG));

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        return STG_E_INVALIDFLAG;
        //pstatstg->pwcsName = (WCHAR *) CoTaskMemAlloc (
        //     _pdfl->GetName()->GetLength()+sizeof(WCHAR));
        //if (pstatstg->pwcsName)
        //{
        //    memcpy (pstatstg->pwcsName, _pdfl->GetName()->GetBuffer(),
        //            _pdfl->GetName()->GetLength());
        //    pstatstg->pwcsName[_pdfl->GetName()->GetLength()/sizeof(WCHAR)]
        //            = L'\0';
        //}
        //else sc = STG_E_INSUFFICIENTMEMORY;
    }

    pstatstg->cbSize.LowPart = _ulSeekPos - _ulSeekStart;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->type = STGTY_STREAM;
    pstatstg->grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::Stat\n"));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Clone, public
//
//  Synopsis:   Clones a stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Clone(IStream **ppstm)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Clone(%p)\n",
                  ppstm));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::Clone\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::AddRef, public
//
//  Synopsis:   Increments the ref count
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStream::AddRef(void)
{
    ULONG ulRet;

    olLog(("%p::In  CSimpStream::AddRef()\n", this));
    simpDebugOut((DEB_TRACE, "In  CSimpStream::AddRef()\n"));

    AtomicInc(&_cReferences);
    ulRet = _cReferences;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::AddRef\n"));
    olLog(("%p::Out CSimpStream::AddRef().  ret == %lu\n", this, ulRet));
    return ulRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::LockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::LockRegion(ULARGE_INTEGER libOffset,
                                     ULARGE_INTEGER cb,
                                     DWORD dwLockType)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::LockRegion("
                  "%lu, %lu\n", ULIGetLow(cb), dwLockType));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::LockRegion\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::UnlockRegion, public
//
//  Synopsis:   Nonfunctional
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::UnlockRegion(ULARGE_INTEGER libOffset,
                                       ULARGE_INTEGER cb,
                                       DWORD dwLockType)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::UnlockRegion(%lu, %lu)\n",
                  ULIGetLow(cb), dwLockType));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::UnlockRegion\n"));
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Commit, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Commit(DWORD grfCommitFlags)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Commit(%lu)\n",
                  grfCommitFlags));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::Commit\n"));
    return STG_E_UNIMPLEMENTEDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::Revert, public
//
//  Synopsis:   No-op in current implementation
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::Revert(void)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream::Revert()\n"));
    simpDebugOut((DEB_TRACE, "Out CSimpStream::Revert\n"));
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::QueryInterface, public
//
//  Synopsis:   Returns an object for the requested interface
//
//  Arguments:  [iid] - Interface ID
//              [ppvObj] - Object return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::QueryInterface(REFIID iid, void **ppvObj)
{
    SCODE sc;

    olLog(("%p::In  CSimpStream::QueryInterface(?, %p)\n",
           this, ppvObj));
    simpDebugOut((DEB_TRACE, "In  CSimpStream::QueryInterface(?, %p)\n",
                  ppvObj));

    SIMP_VALIDATE(QueryInterface(iid, ppvObj));
    
    sc = S_OK;
    if (IsEqualIID(iid, IID_IStream) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppvObj = (IStream *)this;
        CSimpStream::AddRef();
    }
    else if (IsEqualIID(iid, IID_IMarshal))
    {
        *ppvObj = (IMarshal *)this;
        CSimpStream::AddRef();
    }
    else
        sc = E_NOINTERFACE;

    simpDebugOut((DEB_TRACE, "Out CSimpStream::QueryInterface => %p\n",
                  ppvObj));
    olLog(("%p::Out CSimpStream::QueryInterface().  "
           "*ppvObj == %p, ret == %lx\n", this, *ppvObj, sc));
    return ResultFromScode(sc);
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStream::GetUnmarshalClass, public
//
//  Synopsis:   Returns the class ID
//
//  Arguments:  [riid] - IID of object
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcid] - CLSID return
//
//  Returns:    Invalid function.
//
//  Modifies:   [pcid]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::GetUnmarshalClass(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPCLSID pcid)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::GetMarshalSizeMax, public
//
//  Synopsis:   Returns the size needed for the marshal buffer
//
//  Arguments:  [riid] - IID of object being marshaled
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbSize]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::GetMarshalSizeMax(REFIID riid,
                                            void *pv,
                                            DWORD dwDestContext,
                                            LPVOID pvDestContext,
                                            DWORD mshlflags,
                                            LPDWORD pcbSize)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::MarshalInterface, public
//
//  Synopsis:   Marshals a given object
//
//  Arguments:  [pstStm] - Stream to write marshal data into
//              [riid] - Interface to marshal
//              [pv] - Unreferenced
//              [dwDestContext] - Unreferenced
//              [pvDestContext] - Unreferenced
//              [mshlflags] - Unreferenced
//
//  Returns:    Appropriate status code
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::MarshalInterface(IStream *pstStm,
                                           REFIID riid,
                                           void *pv,
                                           DWORD dwDestContext,
                                           LPVOID pvDestContext,
                                           DWORD mshlflags)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::UnmarshalInterface, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//              [riid] -
//              [ppvObj] -
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvObj]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::UnmarshalInterface(IStream *pstStm,
                                             REFIID riid,
                                             void **ppvObj)
{
    return STG_E_INVALIDFUNCTION;
}


//+--------------------------------------------------------------
//
//  Member:     CSimpStream::ReleaseMarshalData, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [pstStm] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::ReleaseMarshalData(IStream *pstStm)
{
    return STG_E_INVALIDFUNCTION;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStream::DisconnectObject, public
//
//  Synopsis:   Non-functional
//
//  Arguments:  [dwRevserved] -
//
//  Returns:    Appropriate status code
//
//  History:    18-Sep-92       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStream::DisconnectObject(DWORD dwReserved)
{
    return STG_E_INVALIDFUNCTION;
}

//+---------------------------------------------------------------------------
//
//  Member: CSimpStreamOpen::Init, public
//
//  Synopsis:   Initialize stream object for simple mode read
//
//  Arguments:  [pstgParent] -- Pointer to parent
//              [hFile] -- File handle for writes
//              [ulSeekStart] -- Beginning seek pointer
//              [grfMode] -- open mode of the stream
//              [pdfl] -- CDfNameList entry for this stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Jun-96   HenryLee    Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE CSimpStreamOpen::Init(CSimpStorageOpen *pstgParent, HANDLE hFile,
                         ULONG ulSeekStart, DWORD grfMode, CDfNameList *pdfl)
{
    simpDebugOut((DEB_ITRACE, "In  CSimpStreamOpen::Init:%p()\n", this));
    simpAssert (pdfl != NULL);

    _ulSeekStart = ulSeekStart;
    _pdfl = pdfl;
    _hFile = hFile;
    _pstgParent = pstgParent;
    _cReferences = 1;
    _grfMode = grfMode;

    if (SetFilePointer(_hFile, ulSeekStart, NULL, FILE_BEGIN) == 0xFFFFFFFF)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

#ifdef SECURE_SIMPLE_MODE
    _ulHighWater = ulSeekStart + pdfl->GetSize();
#endif
    _ulSeekPos = ulSeekStart;

    simpDebugOut((DEB_ITRACE, "Out CSimpStreamOpen::Init\n"));
    return S_OK;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Read, public
//
//  Synopsis:   Read from a stream for simple mode open
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to read
//              [pcbRead] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbRead]
//
//  History:    04-Aug-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Read ( VOID *pb, ULONG cb, ULONG *pcbRead)
{
    SCODE sc = S_OK;
    simpAssert (_pdfl != NULL);

    // cannot read past end of stream
    if (_ulSeekPos + cb > _ulSeekStart + _pdfl->GetSize())
        cb = _ulSeekStart + _pdfl->GetSize() - _ulSeekPos;

    sc = CSimpStream::Read (pb, cb, pcbRead);

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Write, public
//
//  Synopsis:   Write to a stream for simple mode open
//
//  Arguments:  [pb] - Buffer
//              [cb] - Count of bytes to write
//              [pcbWritten] - Return of bytes written
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pcbWritten]
//
//  History:    04-Jun-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Write(VOID const *pb, ULONG cb, ULONG *pcbWritten)
{
    SCODE sc = S_OK;
    simpAssert (_pdfl != NULL);

    if ((_grfMode & (STGM_READ|STGM_WRITE|STGM_READWRITE)) == STGM_READ)
        return STG_E_ACCESSDENIED;

    // cannot write past end of stream
    if (_ulSeekPos + cb > _ulSeekStart + _pdfl->GetSize()) 
        return STG_E_WRITEFAULT;

    sc = CSimpStream::Write (pb, cb, pcbWritten);

    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::SetSize, public
//
//  Synopsis:   Sets the size of a stream for simple mode read
//
//  Arguments:  [ulNewSize] - New size
//
//  Returns:    Appropriate status code
//
//  History:    04-Jun-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::SetSize(ULARGE_INTEGER ulNewSize)
{
    simpDebugOut((DEB_TRACE, "In  CSimpStream2::SetSize()\n"));

    simpAssert (_pdfl != NULL);

    return STG_E_INVALIDFUNCTION;

    simpDebugOut((DEB_TRACE, "Out CSimpStreamOpen::SetSize\n"));
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Release, public
//
//  Synopsis:   Releases a stream
//
//  Returns:    Appropriate status code
//
//  History:    04-Jun-96   HenryLee    Created
//
//---------------------------------------------------------------

STDMETHODIMP_(ULONG) CSimpStreamOpen::Release()
{
    simpDebugOut((DEB_TRACE, "In  CSimpStreamOpen::Release()\n"));

    simpAssert(_cReferences > 0);
    LONG lRet = AtomicDec(&_cReferences);
    if (lRet == 0)
    {
        ((CSimpStorageOpen *)_pstgParent)->ReleaseCurrentStream();
        delete this;
    }
    else if (lRet < 0)
        lRet = 0;

    simpDebugOut((DEB_TRACE, "Out CSimpStreamOpen::Release\n"));
    return lRet;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Seek, public
//
//  Synopsis:   Seek to a point in a stream
//
//  Arguments:  [dlibMove] - Offset to move by
//              [dwOrigin] - SEEK_SET, SEEK_CUR, SEEK_END
//              [plibNewPosition] - Return of new offset
//
//  Returns:    Appropriate status code
//
//  Modifies:   [plibNewPosition]
//
//  History:    04-Sep-96      HenryLee   Created
//
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Seek(LARGE_INTEGER dlibMove,
                                   DWORD dwOrigin,
                                   ULARGE_INTEGER *plibNewPosition)
{
    SCODE sc = S_OK;
    LONG lMove;
    ULONG ulPos;

    simpDebugOut((DEB_TRACE, "%p::In  CSimpStreamOpen::Seek(%ld, %lu, %p)\n",
           this, LIGetLow(dlibMove), dwOrigin, plibNewPosition));

    SIMP_VALIDATE(Seek(dlibMove, dwOrigin, plibNewPosition));
    
    // Truncate dlibMove to 32 bits
    if (dwOrigin == STREAM_SEEK_SET)
    {
        if (LIGetHigh(dlibMove) != 0)   // Make sure we don't seek too far
            LISet32(dlibMove, 0xffffffff);
    }
    else
    {
        // High dword must be zero for positive values or -1 for
        // negative values
        // Additionally, for negative values, the low dword can't
        // exceed -0x80000000 because the 32nd bit is the sign
        // bit
        if (LIGetHigh(dlibMove) > 0 ||
           (LIGetHigh(dlibMove) == 0 && LIGetLow(dlibMove) >= 0x80000000))
            LISet32(dlibMove, 0x7fffffff);
        else if (LIGetHigh(dlibMove) < -1 ||
                (LIGetHigh(dlibMove) == -1 && LIGetLow(dlibMove) <= 0x7fffffff))
            LISet32(dlibMove, 0x80000000);
    }

    lMove = (LONG)LIGetLow(dlibMove);

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
        if (lMove < 0 || (ULONG) lMove > _pdfl->GetSize())
            return STG_E_INVALIDFUNCTION;

        ulPos = _ulSeekStart + lMove;
        break;

    case STREAM_SEEK_END:
        if (lMove > 0 || (lMove < 0 && (ULONG)(-lMove) > _pdfl->GetSize())) 
            return STG_E_INVALIDFUNCTION;

        ulPos = _ulSeekStart + _pdfl->GetSize() + lMove;
        break;

    case STREAM_SEEK_CUR:
        ulPos = SetFilePointer(_hFile, 0, NULL, FILE_CURRENT);

        if ((ULONG) (ulPos + lMove) > _ulSeekStart + _pdfl->GetSize() ||
            (LONG) (ulPos + lMove) < _ulSeekStart)
            return STG_E_INVALIDFUNCTION;

        ulPos += lMove;
        break;
    }

    ulPos = SetFilePointer(_hFile,
                           ulPos,
                           NULL,
                           FILE_BEGIN);

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, ulPos - _ulSeekStart);
    }

    _ulSeekPos = ulPos;

    simpDebugOut((DEB_TRACE, "%p::Out CSimpStreamOpen::Seek(). ulPos==%lu,"
           " ret==%lx\n", this, ulPos, sc));
    return sc;
}

//+--------------------------------------------------------------
//
//  Member:     CSimpStreamOpen::Stat, public
//
//  Synopsis:   Fills in a buffer of information about this object
//
//  Arguments:  [pstatstg] - Buffer
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pstatstg]
//
//  History:    04-Aug-94       PhilipLa   Created
//
//---------------------------------------------------------------

STDMETHODIMP CSimpStreamOpen::Stat(STATSTGW *pstatstg, DWORD grfStatFlag)
{
    SCODE sc = S_OK;
    simpDebugOut((DEB_TRACE, "In  CSimpStreamOpen::Stat(%p, %lu)\n",
                  pstatstg, grfStatFlag));

    SIMP_VALIDATE(Stat(pstatstg, grfStatFlag));
    
    simpAssert (_pdfl != NULL);

    memset (pstatstg, 0, sizeof(STATSTG));

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        pstatstg->pwcsName = (WCHAR *) CoTaskMemAlloc (
                _pdfl->GetName()->GetLength()+sizeof(WCHAR));

        if (pstatstg->pwcsName)
        {
           memcpy (pstatstg->pwcsName, _pdfl->GetName()->GetBuffer(),
                _pdfl->GetName()->GetLength());
           pstatstg->pwcsName[_pdfl->GetName()->GetLength()/sizeof(WCHAR)] =
                L'\0';
        }
        else sc = STG_E_INSUFFICIENTMEMORY;
    }

    pstatstg->cbSize.LowPart = _pdfl->GetSize();
    pstatstg->cbSize.HighPart = 0;
    pstatstg->type = STGTY_STREAM;
    pstatstg->grfMode = _grfMode;

    simpDebugOut((DEB_TRACE, "Out CSimpStreamOpen::Stat\n"));
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\compob32\dllentry.c ===
#include <stdio.h>
#include <windows.h>

BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

#ifdef HAS_LIBMAIN
BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);
#else
#define LibMain(h, d, l) TRUE
#endif

BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRc;
//    char msg[80];

    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
//        DebugBreak();
        break;
    }
    if (fRc = _CRT_INIT(hDll, dwReason, lpReserved))
        fRc = LibMain(hDll, dwReason, lpReserved);
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
//        sprintf(msg, "Compob32 returning %d on attach\r\n", fRc);
//        OutputDebugStringA(msg);
        break;
    }
    return fRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\compob32\compob32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	compob32.cxx
//
//  Contents:	Stub compobj for Chicago
//
//  History:	09-Sep-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include <malloc.h>

// Bind GUID definitions in
#include <initguid.h>
#include <coguid.h>

typedef void *LPCOCS;

class CMalloc : public IMalloc
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS) ;
    STDMETHOD_(ULONG,Release) (THIS);

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ ULONG cb);
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, ULONG cb);
    STDMETHOD_(void, Free) (THIS_ void FAR* pv);
    STDMETHOD_(ULONG, GetSize) (THIS_ void FAR* pv);
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv);
    STDMETHOD_(void, HeapMinimize) (THIS);
};

STDMETHODIMP CMalloc::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IMalloc))
    {
        *ppv = (IMalloc *)this;
        CMalloc::AddRef();
        return NOERROR;
    }
    *ppv = NULL;
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CMalloc::AddRef(void)
{
    return 1;
}

STDMETHODIMP_(ULONG) CMalloc::Release(void)
{
    return 0;
}

STDMETHODIMP_(void FAR*) CMalloc::Alloc(THIS_ ULONG cb)
{
    return malloc(cb);
}

STDMETHODIMP_(void FAR*) CMalloc::Realloc(THIS_ void FAR* pv, ULONG cb)
{
    return realloc(pv, cb);
}

STDMETHODIMP_(void) CMalloc::Free(THIS_ void FAR* pv)
{
    free(pv);
}

STDMETHODIMP_(ULONG) CMalloc::GetSize(THIS_ void FAR* pv)
{
    return _msize(pv);
}

STDMETHODIMP_(int) CMalloc::DidAlloc(THIS_ void FAR* pv)
{
    return TRUE;
}

STDMETHODIMP_(void) CMalloc::HeapMinimize(THIS)
{
}

static CMalloc _cm;

STDAPI CoInitialize(IMalloc *pm)
{
    return NOERROR;
}

STDAPI_(void) CoUninitialize(void)
{
}

STDAPI CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc)
{
    *ppMalloc = (IMalloc *)&_cm;
    return NOERROR;
}

STDAPI_(BOOL) IsValidPtrIn( const void FAR* pv, UINT cb )
{
    return pv == NULL || !IsBadReadPtr(pv, cb);
}

STDAPI_(BOOL) IsValidPtrOut( void FAR* pv, UINT cb )
{
    return !IsBadWritePtr(pv, cb);
}

STDAPI_(BOOL) IsValidInterface( void FAR* pv )
{
    return !IsBadReadPtr(pv, sizeof(void *)) &&
        !IsBadReadPtr(*(void **)pv, sizeof(void *)) &&
        !IsBadCodePtr(**(FARPROC **)pv);
}

STDAPI_(BOOL) IsValidIid( REFIID riid )
{
    return !IsBadReadPtr(&riid, sizeof(IID));
}

STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
    return memcmp(&rguid1, &rguid2, sizeof(GUID)) == 0;
}

STDAPI_(void *) SharedMemAlloc(ULONG cNeeded, DWORD dwReserved)
{
    return malloc(cNeeded);
}

STDAPI_(void) SharedMemFree(void *pmem, DWORD dwReserved)
{
    free(pmem);
}

STDAPI_(DWORD) CoGetCurrentProcess(void)
{
    return 1;
}
        
STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                          DWORD dwDestContext, LPVOID pvDestContext,
                          DWORD mshlflags)
{
    return ResultFromScode(E_UNEXPECTED);
}

STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv)
{
    return ResultFromScode(E_UNEXPECTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\chkdsk\chkdsk.cxx ===
//-----------------------------------------------------------------------
//
// File:	chkdsk.cxx
//
// Contents: 	Sanity checking and recovery mechanism for multistream files
//
// Argument: 
//
// History:	9-July-92	t-chrisy	Created.
//------------------------------------------------------------------------

#include "chkdsk.hxx"

// Global variables, declared as so for convenience.
CMSFHeader *pheader;
CFat *pFat;
CFat *pMiniFat;
CDirectory *pDir;
CDIFat *pDIFat;
BOOL fixdf;
CFatVector *pfvFat, *pfvMiniFat;
wchar_t pwcsDocfile[_MAX_PATH];
DFLAGS	df = DF_READWRITE | DF_DENYWRITE;

extern SCODE DllMultiStreamFromCorruptedStream(CMStream MSTREAM_NEAR **ppms,
			       ILockBytes **pplstStream,
			       DWORD dwFlags);

// Function Prototypes
void BuildFatTables();
void MarkFatTables();
void TreeWalk(CDirEntry *pde, SID sid);
BOOL GetOption(int argc, char *argv[]);
void Usage(char *pszProgName);
void DIFTable();

void main(int argc, char *argv[])
{
	CFileStream *pfilestr;
	CMStream MSTREAM_NEAR *pms;
	SCODE scRc;
	ILockBytes *pilb;

	// if fixdf returns yes, open docfile without a copy;
	// otherwise, open docfile with a copy and operate on the copy.
	fixdf = GetOption(argc,argv);
	pfilestr = new CFileStream;
	
	// creating ILockBytes implementation for the given file 
	// Note:  When a docfile is corrupted, the chkdsk utility
	//      calls the original CFileStream::Init.  If any objects
	//		fail to instantiate, the approach is to call an
	// 		alternative Init routine, which can force the instantiation
	// 		of Directory and MiniFat objects.

	if (fixdf==TRUE)		// -f specified, write allowed.
	{
		df &= ~0x03;
		df |= DF_WRITE;
		printf("Trying to open file...\n");
		scRc = pfilestr->Init(pwcsDocfile,RSF_OPEN,df);
		if (FAILED(scRc)) 
		{
			printf("Error creating ILockBytes.\n");
			exit(FAIL_CREATE_ILB);
		}
	}
	else					// open a read-only copy of filestream
	{
		df &= ~0x300;		// clear access bits
		df |= DF_DENYWRITE;
		printf("Trying to open file...\n");
		scRc = pfilestr->Init(pwcsDocfile,RSF_OPEN,df);
		if (FAILED(scRc)) 
		{
			printf("Error creating ILockBytes.\n");
			exit(FAIL_CREATE_ILB);
		}
		else printf("Successfully created ILockBytes.\n");
	}

  	scRc = pfilestr->Validate();
	if (scRc == STG_E_INVALIDHANDLE)
	{
		printf("Filestream signature is not valid.\n");
		exit(INVALID_DOCFILE);
	}

	// CFileStream is essentially equivalent to ILockBytes.
	pilb = (ILockBytes *) pfilestr;
	scRc = DllMultiStreamFromStream(&pms,&pilb,0);

	if (FAILED(scRc)) 
		if (FAILED(scRc = DllMultiStreamFromCorruptedStream
					(&pms,&pilb,0)))
		{
			exit(FAIL_CREATE_MULTISTREAM);
			printf("Error creating a multistream.\n");
		}

	
	// When an multi-stream is instantiated, the following control structures
	// are automatically instantiated.
	pheader = pms->GetHeader();
	pDir = pms->GetDir();
	pFat = pms->GetFat();
	pMiniFat = pms->GetMiniFat();
	pDIFat = pms->GetDIFat();

		printf("\tBuilding fat tables...\n");
	BuildFatTables();
		printf("\tExamining the DIFat...\n");
	DIFTable();
		printf("\tExamining Fat and MiniFat chains...\n");
	MarkFatTables();
		printf("\tChecking completed.\n");
	delete(pfvFat);
	delete(pfvMiniFat);
	pfilestr->Release();
		printf("Memory blocks freed.\n");
}

void BuildFatTables()
{
	// Build two tables: one for Fat sectors, the other for Minifat sectors.

	FSINDEX FatLen,MiniFatLen;
	FatLen = pheader->GetFatLength();
	MiniFatLen = pheader->GetMiniFatLength();
	pfvFat = new CFatVector(TABLE_SIZE);
	pfvFat->Init(FatLen);
	if (MiniFatLen == 0) 
		printf("No MiniFat to be checked.\n");
	else 
	{	
		pfvMiniFat = new CFatVector(TABLE_SIZE);
		pfvMiniFat->Init(MiniFatLen);
	}
}

void MarkFatTables()
{
	CDirEntry *pde;

	// Walk through all the fat chains and mark the new table with the
	// first SID number encountered.

	pDir->SidToEntry(SIDROOT,&pde);
	TreeWalk(pde,SIDROOT);			// pde points to the root entry now
}

void TreeWalk(CDirEntry *pde, SID sid)
{
	CDirEntry *pchild, *pnext;
	SID childsid, nextsid;
	SCODE scRc,scRcM;
	FSINDEX fitable,fioffset;
	SECT sectentry, sect;
	CFatSect *pfsec;
	CFatVector *pfv;
	CFat *pf;
	ULONG uldesize;
	
	pDir->GetStart(sid,&sect);
	uldesize = pde->GetSize();

	if (uldesize >= MINISTREAMSIZE)		// storage is in FAT
	{
		pfv = pfvFat;
		pf = pFat;
	}
	else
	{
		pfv = pfvMiniFat;
		pf = pMiniFat;
	}
	
	// Check if LUID exceeds MaxLUID.  If so, report the error.
	if (pde->GetLuid() > pheader->GetLuid())
		printf("LUID for dir entry #%lu exceeds MAXLuid.\n",sid);
	
	while (sect < MAXREGSECT)
	{
		if (sid == SIDROOT)
			break;		// nothing should be in root stream
		// Use fitable and fioffset to index into the fat (or minifat)
		// table and mark the field with visited.
		// at the same time, check for loops or crosslinks.

		//Note:  3 cases
		fitable = sect / (TABLE_SIZE);
		fioffset = sect % (TABLE_SIZE);
		pfv->GetTable(fitable,&pfsec);      // pfsec = ptr to CFatSect 
		sectentry = pfsec->GetSect(fioffset);		

//		printf("\tsect = %lu \t \t sectentry = %lu \t stream_size = %lu\n",
//				sect,sectentry, uldesize);
		// Mark the FatTables as well as fixing the multistream.
		// Right now, the routine only marks the FatTables.
		//Note:  3 cases...but the last two cases may not
		// be handled the same.
		if (sectentry > MAXREGSECT)
			pfsec->SetSect(fioffset,sid);
		else if (sectentry == sid)
		{
			// discontinue the current stream chain by marking
			// current SECT as ENDOFCHAIN.
			pf->SetNext(sect,ENDOFCHAIN);
			pfsec->SetSect(fioffset,ENDOFCHAIN);
			printf("Loop detected at fat SECT %ul\n",sectentry);
		}
		else 
		{
			pf->SetNext(sect,ENDOFCHAIN);
			pfsec->SetSect(fioffset,ENDOFCHAIN);
			printf("Crosslink detected at Fat SECT %lu with stream #%lu\n",
				sect,sid);
		}
		// get the next sector to be examined
		// !!!!! Need to use the Fat object to track down next sector
		pf->GetNext(sect,&sect);
	}
		
	// Recursively go down the tree
	// pchild and pnext must point to the original tree for
	// efficiency purposes.
	
	childsid = pde->GetChild();
	if (childsid != NOSTREAM) 
	{
		pDir->SidToEntry(childsid,&pchild);
		TreeWalk(pchild,childsid);
	}
	nextsid = pde->GetNext();
	if (nextsid != NOSTREAM)
	{
		pDir->SidToEntry(nextsid,&pnext);
		TreeWalk(pnext,nextsid);
	}

	if (fixdf==TRUE) 
	{
		scRc = pFat->Flush();
		scRcM = pMiniFat->Flush();
		if (FAILED(scRc) || FAILED(scRcM))
			printf("Failed to write all modified FatSects out to stream.\n");
	}
}
	
BOOL GetOption(int argc, char *argv[]) 
{
	char *pszArg, *pszProgName;
	BOOL ArgsOK = FALSE, Fix = FALSE;
	pszProgName = *argv++;

	while ((pszArg = *argv++) != NULL)
	{
		if (*pszArg == '-' || *pszArg == '/')
		{
			switch (tolower(*(++pszArg)))
			{
			case 'f':		// fix the errors.
				Fix = TRUE;   // open file with read-only without a copy.
				break;
			case 'n':		// name of the docfile to be opened.
							// path of the filename.
				mbstowcs(pwcsDocfile,++pszArg,_MAX_PATH);
				Fix = FALSE;
				ArgsOK = TRUE;
				break;
			default:
				break;
			}
		}
		else ArgsOK = FALSE;
	}
	if (ArgsOK == FALSE) 
	{
		printf("0 argument or invalid command line argument.\n");
		Usage(pszProgName);
		exit(INVALID_ARG);
	}
	return Fix;
}

void Usage(char *pszProgName)
{
	printf("Usage:  %s\n", pszProgName);
	printf("		-f	fix requested by user.\n");
	printf("		-n  <name of docfile>\n");
	printf("The -n option must be specified.\n");
}
	
	
void DIFTable()				// August 11, 1992
{
	// Walk through each DIF sector array to detect loops and 
	// crosslinks.  
	SCODE scRc;
	BOOL FatOK = TRUE;
	SECT sect, sectentry; 
	FSINDEX diflen, fatlen, fitable, fioffset, index, minifatlen,uldif,ulr;
	CFatSect *pfsec;

	diflen = pheader->GetDifLength();
	fatlen = pheader->GetFatLength();
	minifatlen = pheader->GetMiniFatLength();
	
	// testing the validity of pheader->GetDifLength
	if (fatlen > CSECTFAT)		// diflen > 0
	{
		ulr = ( ((fatlen - CSECTFAT)%TABLE_SIZE) > 0 )? 1: 0;
		uldif = CSECTFAT + (fatlen-CSECTFAT)/TABLE_SIZE + ulr;
	}
	else uldif = 0;
	if (diflen!=uldif) 
		printf("DIFLEN in header is inconsistent with FatLEN.\n");

	for (index=0; index<fatlen; index++)
	{
		pDIFat->GetFatSect(index,&sect);
		if (sect < MAXREGSECT)
		{
			fitable =  sect / TABLE_SIZE;
			fioffset = sect % TABLE_SIZE;
			pfvFat->GetTable(fitable,&pfsec);	 // pfsec = ptr to CFatSect 
			sectentry = pfsec->GetSect(fioffset);			
		
			if (sectentry > MAXREGSECT)
				pfsec->SetSect(fioffset,SIDFAT);
			else 
			{
				printf("Crosslink! DIF index #%u points\n",index);
				printf(" to the same location %u.\n", sect);
				FatOK = FALSE;
			}
		}
		pDIFat->GetFatSect(index+1,&sect);
	}

	if (FatOK == TRUE)
		printf("No errors found in DIFat.\n");

	// Walk through the terminating cells in each sector array to check
	// the correctness of chaining.
	printf("\tWalking through DIFTable chain.\n");
	for (index = 0; index<diflen; index++)
	{
		pDIFat->GetSect(index,&sect);
		fitable =  sect/TABLE_SIZE;
		fioffset = sect%TABLE_SIZE;
		pfvFat->GetTable(fitable,&pfsec); // pfsec = ptr to CFatSect 
		sectentry = pfsec->GetSect(fioffset);			
		if ((sectentry!=ENDOFCHAIN) && (index == diflen-1))
			printf("ERROR!  ENDOFCHAIN expected at the end of DIFat.\n.");
		pDIFat->SetFatSect(fioffset,SIDDIF);
		pfsec->SetSect(fioffset,SIDDIF);
	}
	if (fixdf==TRUE) 
	{
		scRc = pDIFat->FlushAll();
		if (FAILED(scRc)) 
			printf("Failed to write all modified FatSects out to stream.\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\compob32\pch.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	pch.cxx
//
//  History:	09-Sep-93	DrewB	Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <compobj.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\df2t\df2t.cxx ===
//+----------------------------------------------------------------------------// File:    DF2T.CXX
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1991 - 1992.
//
// Contents:  utility program for converting a Docfile to a directory tree.
//  	      Given a Docfile,it is walked with an enumerator and each
//			  embedded IStorage creates a directory in the specified
//	      destination tree while each IStream creates a file within
//	      the appropriate directory.  Finally, a tree compare is
//	      performed on the source and destination trees.
//
// Classes:   IStorage    - Container class
//            IStream     - Contained stream class
//            IEnumSTATSTG - Enumerator class for IStorages
//
// Command line:  df2c -f/-b -(n)ameofDocfile -(s)rcTree -(d)estTree -T -W
//		    -f forward conversion (docfile --> tree)
//		    -b backward conversion (tree --> docfile)
//          -n name for root docfile
//          -s name of the source directory tree
//		    -d name of the destination directory tree
//          -t specifies STGM_TRANSACTED mode
//          -w specifies STGM_SHARE_DENY_WRITE mode for root docfile
//
//		  -f and -b cannot be both specified in one command.
//
//		  The default conversion is from Docfile to tree.
//		  Therefore, -n and -d(est) must be specified when forward
//		  conversion -f is used.  Otherwise, -b should be accompanied
//		  by -s(rc) and -n(doc).
//
//                This utility defaults to running in DIRECT mode so that all
//                operations at all levels are performed immediately on the
//                base copy of the root docfile.
//
//                With the -T switch, this runs in STGM_TRANSACTED mode for
//                all IStorage creation and instantiation so that scratch
//		  streams are created and committed, but only made permanent
//		  in the persistent version by Commit of the root docfile.
//
//                With the -W switch, this runs in STGM_TRANSACTED mode
//                with STGM_SHARE_DENY_WRITE for root docfile creation and
//                instantiation so that operations are performed on the base
//                copy of the docfile.
//
// Requires:  Windows 3.x.  MSF.DLL and DOCFILE.DLL should be in same dir
//            as executable or in \windows\system
//
// Returns:   0 if successful, exits with error code otherwise
//
// Notes:     uses whcar and 'mbtowcs' conversions for wide char support
//	      returns STG_E_NOTCURRENT if docfile-to-be-created
//	      already exists.
//
// Created: RichE, January 13, 1992  Original program
// Revised: t-chrisy, June 25, 1992  convert the test program to a utility
// 					dftc.cxx --> df2t.cxx
//-----------------------------------------------------------------------------


#include <stdlib.h>
#include <string.h>
#include <dos.h>
#include <direct.h>

#include "w4ctsupp.hxx"

#define WILD_CARD "\\*.*"
#define BACK_SLASH "\\"
#define NS_INCL (STGTY_STORAGE | STGTY_STREAM)
#define FIND_ATTRS _A_SUBDIR | _A_NORMAL | _A_RDONLY | _A_HIDDEN
#define FILE_BUF_SIZE 32768 // msf is optimized for file size of 4K or 512bytes
#define DOCTOTREE 0
#define TREETODOC 1

//function prototypes
void CopyTreeToDocfile(IStorage *pstgParent);
void CopyDocfileToTree(IStorage *pstgParent, TCHAR *ptcsDFName);
void CopyFileToStream(IStorage *pstgParent, char *FileName);
void CopyStreamToFile(IStorage *pstgParent, TCHAR *ptcsStreamName);
int GetOptions(int argc, char *argv[]);
void Usage(char *pszProgName);

//buffers for file/dir path calls and docfile name (default assignments)
char szDestDocfile[_MAX_PATH + 1] = "";
char szSrcPath[_MAX_PATH + 1] = "";
char szDestPath[_MAX_PATH + 1] = "";
int  iSrcPathEnd = sizeof(_MAX_PATH);   //length minus terminating '\0'
int  iDestPathEnd = sizeof(_MAX_PATH);

//buffers for converting to/from wide characters
TCHAR wcsWideName[_MAX_PATH + 1];
char  szName[_MAX_PATH + 1];

//modifiers to flags for root and child docfiles (GetOptions may modify)
DWORD dwRootFlags = STGM_READWRITE | STGM_SHARE_DENY_WRITE;
DWORD dwChildFlags = STGM_READWRITE | STGM_SHARE_EXCLUSIVE;

void utMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

//+----------------------------------------------------------------------------
// Function: main, public
//
// Synopsis: main body of program, controls overall flow
//
// Effects:  initialize.  Depending on the direction of converionsn,
//			  call functions to create a tree, given a DocFile;
//			  call functions to create a DocFile, given a tree.
//
// Created: RichE January 13, 1992  original program
// Revised: t-chrisy June 25, 1992  modified to convert docfile to tree;
//					and vice versa.
//
//-----------------------------------------------------------------------------

void main(int argc, char *argv[])
{
    IStorage *pstgDest = NULL;
    SCODE    scRc;
    short ret;

#if WIN32 == 300
    if (FAILED(scRc = GetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
#else
    if (FAILED(scRc = GetScode(CoInitialize(NULL))))
#endif
    {
        fprintf(stderr, "CoInitialize failed with sc = %lx\n", scRc);
        exit(1);
    }

    ret=GetOptions(argc, argv);
    if (ret==DOCTOTREE)
    {
        tprintf(bDestOut, "Converting Docfile to tree....\n");
        if ((!strcmp(szDestDocfile,"\0"))||(!strcmp(szDestPath,"\0")))
        {
            tprintf(bDestOut, "Invalid switches used.\n");
            tprintf(bDestOut,
                    "If -f is indicated, -n and -d must also be specified.\n");
            exit(1);
        }	
    }	
    else
    {
        tprintf(bDestOut, "Converting a directory tree to Docfile....\n");
        if ((!strcmp(szDestDocfile,"\0")||(!strcmp(szSrcPath,"\0"))))
        {
            tprintf(bDestOut, "Invalid switches used.\n");
            tprintf(bDestOut,
                    "If -b is chosen, -s and -n must also be specified.\n");
            exit(1);
        }
    }

    if (dwRootFlags & STGM_TRANSACTED)
    {
        tprintf(bDestOut, "STGM_TRANSACTED mode ");
        if ((dwRootFlags & 0x70) == STGM_SHARE_EXCLUSIVE)
        {
            tprintf(bDestOut, "with STGM_SHARE_EXCLUSIVE");
        }
        else
        {
            tprintf(bDestOut, "without STGM_SHARE_EXCLUSIVE");
        }
    }
    else
    {
        tprintf(bDestOut, "STGM_DIRECT mode (with STGM_SHARE_EXCLUSIVE)");
    }
    tprintf(bDestOut, " operation\n");

    MakeWide(wcsWideName, szDestDocfile);

    if (ret==DOCTOTREE) // Docfile to tree...
    {
        MakePath(szDestPath);
        CopyDocfileToTree((IStorage *) NULL, wcsWideName);
    }
    else
    {	
	// Create root docfile with specified mode, nuke if already exists
        tprintf(bDestOut, "Create root docfile %s\n", szDestDocfile);
        scRc = GetScode(StgCreateDocfile(wcsWideName,
                                         dwRootFlags | STGM_CREATE, 0,
                                         &pstgDest));
        tprintf(bDestOut, "Returned %lu\n", scRc);
        tprintf(bDestOut, "Root docfile %s %s, pointer %p\n", szDestDocfile,
                pstgDest == NULL ? "FALSE" : "TRUE", pstgDest);
        if (pstgDest == NULL || FAILED(scRc))
        {
            ErrExit(DEST_LOG, scRc, "Error creating root docfile %s\n",
                    szDestDocfile);
        }
        CopyTreeToDocfile(pstgDest);
    }
}

//+----------------------------------------------------------------------------
// Function: CopyTreeToDocfile, private
//
// Synopsis: traverses and reads source tree and creates docfile image
//
// Effects: for each directory in source tree, an IStorage is created, for each
//          file, a contained stream is created.  this function is recursive.
//
// Arguments: [pstgParent] - current parent IStorage for new containees
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 17, 1992    convert to OLE interfaces
//-----------------------------------------------------------------------------

void CopyTreeToDocfile(IStorage *pstgParent)
{
    struct find_t FileInfo;
    SCODE         scRc;
    USHORT        usEndOfBasePath;
    IStorage      *pstgChild;

    // Save pointer to base of pure path at this level
    usEndOfBasePath = strlen(szSrcPath) + 1;

    scRc = _dos_findfirst(strcat(szSrcPath, WILD_CARD), FIND_ATTRS, &FileInfo);
	
    while (scRc==0)
    {
	// If not '.' or '..' directories
	if (FileInfo.name[0] != '.')
	{
            // Restore pure path and add current file/dir name to it
            szSrcPath[usEndOfBasePath] = NIL;
            strcat(szSrcPath, FileInfo.name);
            if (FileInfo.attrib == _A_SUBDIR)
            {
                MakeWide(wcsWideName, FileInfo.name);
                // Create new IStorage inside current one,
                // use dir name for name
                tprintf(bDestOut,
                        "Create embedded DF %s inside pstgParent %p\n",
                        szSrcPath, pstgParent);
                scRc = GetScode(pstgParent->CreateStorage(wcsWideName,
                                                          dwChildFlags |
                                                          STGM_FAILIFTHERE,
                                                          0, 0,
                                                          &pstgChild));
                tprintf(bDestOut, "Returned: %lu, pointer = %p\n",
                        scRc, pstgChild);

                if (pstgChild == NULL || FAILED(scRc))
                {
                    ErrExit(DEST_LOG, scRc,
                            "Error creating child IStorage %s\n",
                            FileInfo.name);
                }
                CopyTreeToDocfile(pstgChild);
            }
            else
            {
                CopyFileToStream(pstgParent, FileInfo.name);
            }
        }
        scRc = _dos_findnext(&FileInfo);
    }
    if (dwRootFlags & STGM_TRANSACTED)
    {
        tprintf(bDestOut, "Committing pstgParent %p\n", pstgParent);
        if (scRc = GetScode(pstgParent->Commit(STGC_ONLYIFCURRENT)))
        {
            ErrExit(DEST_LOG, scRc, "Error committing IStorage %p\n",
                    pstgParent);
        }
    }
    tprintf(bDestOut, "Releasing pstgParent %p\n", pstgParent);
    pstgParent->Release();
}

//+----------------------------------------------------------------------------
// Function: CopyFileToStream, private
//
// Synopsis: copies supplied file to stream inside of parent IStorage
//
// Arguments: [pstgParent] - parent IStorage for stream created
//            [FileName] - name of source file to copy to stream
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 15, 1992    streams no longer TRANSACTED
// Revised: RichE March 17, 1992    convert to OLE interfaces
//-----------------------------------------------------------------------------

void CopyFileToStream(IStorage *pstgParent, char *FileName)
{
    IStream *pstmStream = NULL;
    FILE    *FileToCopy;
    SCODE   scRc;
    ULONG   cNumRead;
    ULONG   cNumWritten;
    BYTE    *FileBuf;

    tprintf(bDestOut, "  File %s\n", szSrcPath);
    FileToCopy = fopen(szSrcPath, "rb");
    if (FileToCopy == NULL)
    {
        ErrExit(DEST_LOG, ERR, "Cannot open file %s\n", szSrcPath);
    }

    MakeWide(wcsWideName, FileName);

    // Create a stream inside parent IStorage
    tprintf(bDestOut,
            "Create embedded stream inside parent pstgParent = %p\n",
            pstgParent);
    scRc = GetScode(pstgParent->CreateStream(wcsWideName, STGM_STREAM |
                                             STGM_FAILIFTHERE, 0, 0,
                                             &pstmStream));
    tprintf(bDestOut, "Returned: %lu, pointer = %p\n", scRc, pstmStream);
    if (pstmStream == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc, "Error creating stream %s\n", szSrcPath);
    }

    FileBuf = (BYTE * ) Allocate(FILE_BUF_SIZE * sizeof(BYTE));

    //while still reading from source file, write what was just read to Stream
    while (cNumRead = fread(FileBuf, 1, FILE_BUF_SIZE, FileToCopy))
    {
        if (ferror(FileToCopy))
        {
            ErrExit(DEST_LOG, ERR, "Error during stream read of %s\n",
                    szSrcPath);
        }

        tprintf(bDestOut, "Try Stream write of %lu bytes on stream %p\n",
                cNumRead, pstmStream);
        scRc = GetScode(pstmStream->Write(FileBuf, cNumRead, &cNumWritten));
        tprintf(bDestOut, "Returned: %lu, bytes written %lu\n",
                scRc, cNumWritten);
        if (cNumWritten != cNumRead)
        {
            tprintf(bDestOut, "Write:  scRc = %lu, cNumWritten = %lu, ",
                    scRc, cNumWritten);
            tprintf(bDestOut, "cNumRead = %lu\n", cNumRead);
        }

        if (FAILED(scRc))
        {
            ErrExit(DEST_LOG, ERR, "Error writing stream %p\n", pstmStream);
        }
    }

    tprintf(bDestOut, "Releasing stream %p\n", pstmStream);
    pstmStream->Release();

    fclose(FileToCopy);
    free(FileBuf);
}

//+----------------------------------------------------------------------------// Function: CopyDocfileToTree, private
//
// Synopsis: enumerates and reads docfile and creates directory tree
//
// Effects: for each child IStorage in the root docfile, a subdir is created,
//          for each child stream, a file is created.  this function is
//          recursive.
//
// Arguments: [pstgParent] - current parent IStorage for reading containees
//            [ptcsDFName] - name of IStorage to instantiate
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 17, 1992    convert to OLE interfaces
// Revised: t-chrisy June 30, 1992  removed the section on unlinking docfile
//-----------------------------------------------------------------------------

void CopyDocfileToTree(IStorage *pstgParent, TCHAR *ptcsDFName)
{
    IStorage    *pstgSrc = NULL;
    IEnumSTATSTG *penmWalk;
    USHORT      usEndOfBasePath;
    SCODE       scRc;
    STATSTG     sstg;
    int         iRc;

    // Add back slash & save pointer to base of pure path at this level
    strcat(szDestPath, BACK_SLASH);
    usEndOfBasePath = strlen(szDestPath);

    MakeSingle(szName, ptcsDFName);

    // If not first call (parent != NULL) then instantiate child IStorage with
    // method call, else instantiate root docfile via Df API call
    if (pstgParent != NULL)
    {
        tprintf(bDestOut, "Get embedded IStorage %s in parent %p\n",
                szName, pstgParent);
        scRc = GetScode(pstgParent->OpenStorage(ptcsDFName, NULL, dwChildFlags,
                                                NULL, 0, &pstgSrc));
    }
    else
    {
        tprintf(bDestOut, "Instantiate root docfile %s\n", szName);
	dwRootFlags |= STGM_READ;
        scRc = GetScode(StgOpenStorage(ptcsDFName, NULL, dwRootFlags, NULL,
                                       0, &pstgSrc));
    }

    tprintf(bDestOut, "Return code: %lu, IStorage pointer %p\n",
            scRc, pstgSrc);
    if (pstgSrc == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc, "Error instantiating IStorage %s\n", szName);
    }

    // Get an enumerator on the IStorage we just instantiated
    scRc = GetScode(pstgSrc->EnumElements(0, NULL, 0, &penmWalk));
    tprintf(bDestOut, "Got enumerator %p on IStorage %p, returned %lu\n",
            penmWalk, pstgSrc, scRc);
    if (penmWalk == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc,
                "Error obtaining enumerator for IStorage %p\n", pstgSrc);
    }

    // Loop until GetNext returns other than S_OK, then break out of loop
    while (TRUE)
    {
        if (GetScode(penmWalk->Next(1, &sstg, NULL)) != S_OK)
        {
            tprintf(bDestOut, "No more to enumerate with enumerator %p\n",
                    penmWalk);
            break;
        }
        else
        {
            MakeSingle(szName, sstg.pwcsName);
            tprintf(bDestOut, "Got item type %lu, Name %s, w/enumerator %p\n",
                    sstg.type, szName, penmWalk);

            // Restore to path + BACK_SLASH and add file/dir name to DestPath
            szDestPath[usEndOfBasePath] = NIL;
            strcat(szDestPath, szName);
            tprintf(bDestOut, "Path Name: %s is ", szDestPath);
            if (sstg.type == STGTY_STORAGE)
            {
                tprintf(bDestOut, "STGTY_STORAGE\n");
                iRc = _mkdir(szDestPath);
                tprintf(bDestOut,
                        "Trying to make directory %s, returned %d\n",
                        szDestPath, iRc);
                CopyDocfileToTree(pstgSrc, sstg.pwcsName);
            }
            else
            {
                tprintf(bDestOut, "STGTY_STREAM\n");
                CopyStreamToFile(pstgSrc, sstg.pwcsName);
            }
        }

        utMemFree(sstg.pwcsName);
    }

    tprintf(bDestOut, "Releasing enumerator %p\n", penmWalk);
    penmWalk->Release();
}


//+----------------------------------------------------------------------------
// Function: CopyStreamToFile, private
//
// Synopsis: copies supplied embedded stream to file in current dubdir
//
// Arguments: [pstgParent] - parent IStorage for stream to copy
//            [ptcsStreamName] - name of stream to copy to file
//
// Created: RichE, January 13, 1992
// Revised: RichE March 5, 1992     Df APIs to method calls
// Revised: RichE March 6, 1992     TRANSACTED mode operation
// Revised: RichE March 15, 1992    streams no longer TRANSACTED
// Revised: RichE March 17, 1992    convert to OLE interfaces
//-----------------------------------------------------------------------------

void CopyStreamToFile(IStorage *pstgParent, TCHAR *ptcsStreamName)
{
    IStream *pstmStream = NULL;
    FILE    *FileToWrite;
    ULONG   cNumRead = 1;
    ULONG   cNumWritten;
    BYTE    *FileBuf;
    SCODE   scRc;

    tprintf(bDestOut, "Copying embedded stream to file %s\n", szDestPath);

    // Instantiate named stream within parent IStorage
    tprintf(bDestOut, "Get stream in parent %p\n", pstgParent);
    scRc = GetScode(pstgParent->OpenStream(ptcsStreamName, NULL, STGM_STREAM,
                                           0, &pstmStream));
    tprintf(bDestOut, "Returned: %lu, stream pointer %p\n", scRc, pstmStream);
    if (pstmStream == NULL || FAILED(scRc))
    {
        ErrExit(DEST_LOG, scRc, "Error opening stream %s\n", szDestPath);
    }

    FileToWrite = fopen(szDestPath, "wb");
    if (FileToWrite == NULL)
    {
        ErrExit(DEST_LOG, ERR, "Cannot open file %s\n", szDestPath);
    }

    FileBuf = (BYTE * ) Allocate(FILE_BUF_SIZE * sizeof(BYTE));

    // While still reading Stream, write what was just read to file.
    tprintf(bDestOut, "Starting to read stream %p\n", pstmStream);
    while (cNumRead > 0)
    {
        scRc = GetScode(pstmStream->Read(FileBuf, FILE_BUF_SIZE, &cNumRead));
        tprintf(bDestOut, "Read %lu bytes from stream %p, returned %lu\n",
                cNumRead, pstmStream, scRc);
        if (FAILED(scRc))
        {
            ErrExit(DEST_LOG, scRc, "Error reading stream %p\n", pstmStream);
        }
        cNumWritten = (ULONG)fwrite(FileBuf, 1, (size_t)cNumRead, FileToWrite);
        if (ferror(FileToWrite))
        {
            ErrExit(DEST_LOG, ERR, "Error writing to file %s\n", szDestPath);
        }

        if (cNumWritten != cNumRead)
        {
            tprintf(bDestOut, "Fwrite: cNumRead = %lu, cNumWritten = %lu\n",
                    cNumRead, cNumWritten);
        }
    }

    tprintf(bDestOut, "Attempting to release stream %p in IStorage %p\n",
            pstmStream, pstgParent);
    pstmStream->Release();

    fclose(FileToWrite);
    free(FileBuf);
}


//+----------------------------------------------------------------------------
// Function: GetOptions, private
// Returns: DOCTOTREE or TREETODOC to indicate the direction of conversion.
//
// Synopsis: parses command line and sets global program options/variables
//
// Arguments: [argc] and [**argv] passed from main() function
//
// Modifies: [szSrcPath, szDestPath, szDestDocfile]
//
// Created: RichE, January 13, 1992
// Revised: RichE, March 15, 1992    added -T and -W switches
// Revised: RichE, March 19, 1992    fixed bug displaying error usage
// Revised: t-chrisy, June 25, 1992  added -f and -b switches
//-----------------------------------------------------------------------------

int GetOptions(int argc, char *argv[])
{
    char *pszArg;
    char *pszProgName;
    BOOL ArgsOK = TRUE;
    short ret=DOCTOTREE;

    // Bump past command name (argv[0])
    pszProgName = *argv++;

    // For each command line arg, if it begins with a '-' or '/' check the
    // next letter for a valid argument.  return error for invalid args

    while ((pszArg = *argv++) != NULL)
    {
        if (*pszArg == '-' || *pszArg == '/')
        {
            switch (tolower(*(++pszArg)))
            {
            case 'w':
                dwRootFlags |= STGM_TRANSACTED;
                dwChildFlags |= STGM_TRANSACTED;
                break;
            case 't':
                dwRootFlags |= STGM_TRANSACTED;
                dwChildFlags |= STGM_TRANSACTED;
                break;

            case 's':
                strcpy(szSrcPath, ++pszArg);
                iSrcPathEnd = strlen(pszArg);
                break;

            case 'd':
                strcpy(szDestPath, ++pszArg);
                iDestPathEnd = strlen(pszArg);
                break;

            case 'z':
                 LogFile(++pszArg,LOG_INIT);
                 break;

            case 'y':
                SetDebugMode(tolower(*(++pszArg)));
                break;

            case 'n':
                if (strlen(++pszArg) <= _MAX_PATH)
                {
                    strcpy(szDestDocfile, pszArg);
                }
                else
                {
                    tprintf(DEST_LOG, "Dest DocFile Name too long: %s\n",
                            pszArg);
                    tprintf(DEST_LOG, "Max len = %d\n", _MAX_PATH);
                    tprintf(DEST_LOG, "Specified len = %d\n", strlen(pszArg));
                    ArgsOK = FALSE;
                }
                break;
	
            case 'f':
                // Docfile to tree
                dwRootFlags &= ~0x03;		// clear access bits
                dwRootFlags |= STGM_READ;
                ret=DOCTOTREE;
                break;

            case 'b':
                // Tree to docfile
                dwRootFlags &= ~0x70;
                dwRootFlags |= STGM_SHARE_EXCLUSIVE;
                ret=TREETODOC;	
                break;

            default:
                ArgsOK = FALSE;
                break;
            }
        }
        else
            ArgsOK = FALSE;
	
        if (ArgsOK == FALSE)
        {
            tprintf(DEST_LOG,
                    "Invalid command line argument: %s\n", --pszArg);
            Usage(pszProgName);
        }
    }
    return ret;
}


//+----------------------------------------------------------------------------
// Function: Usage, private
//
// Synopsis: displays program syntax and example and exits with error
//
// Arguments: [pszProgramName] - name of this executable file for error usage
//
// Created: RichE, January 15, 1992
// Revised: t-chrisy, June 30, 1992  Added -f and -b options.
//+----------------------------------------------------------------------------

void Usage(char *pszProgName)
{
	
    tprintf(DEST_ERR, "Usage: %s\n", pszProgName);
    tprintf(DEST_ERR, "       [-f]		- forward conversion"
            "(docfile-->tree)  DEFAULT\n");
    tprintf(DEST_ERR, "       		-n and -d must be specified.");
    tprintf(DEST_ERR, "       [-b]		- backward conversion"
            "(tree-->docfile)\n");
    tprintf(DEST_ERR, "       		-s and -n must be specified.");
    tprintf(DEST_ERR, "       [-sSRCDIR]	 \n");
    tprintf(DEST_ERR, "       [-nDOCFILENAME]    \n");
    tprintf(DEST_ERR, "       [-dDESTDIR]        \n");
    tprintf(DEST_ERR, "       [-t]               - for transacted mode\n");
    tprintf(DEST_ERR, "       [-w]               - for deny write mode\n");
    ErrExit(DEST_ERR, ERR, "   ex:  %df2t -b -sc:\\dos -nd:\\docfile.dfl\n",
            pszProgName);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\df2t\w4ctsupp.cxx ===
//############################################################################
//#
//#   Microsoft Windows
//#   Copyright (C) Microsoft Corporation, 1992 - 1992.
//#   All rights reserved.
//#
//############################################################################
//
//+----------------------------------------------------------------------------
// File: W4CTSUPP.CXX
//
// Contents: Contains support functions for docfile testing
//
// Command line: N/A
//
// Requires: must be linked with program containing function main()
//
// Notes: Compiled to create W4CTSUPP.LIB
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <direct.h>
#include <ctype.h>
#include <time.h>

#define __CRC32__
#include "w4ctsupp.hxx"

#include <dfdeb.hxx>

//char for separating FAT file name from extension
#define FILE_NAME_SEPARATOR '.'

//global array of interesting file sizes for IStream read/writes
USHORT ausSIZE_ARRAY[] = {0,1,2,255,256,257,511,512,513,2047,2048,2049,4095,4096,4097};

//test logging file pointer
static FILE *fileLogFile = NULL;

//should log be closed after every log write, modified by SetDebugMode()
static BOOL fCloseLogAfterWrite = FALSE;

//test name string for ErrExit and application use
char szTestName[MAX_TEST_NAME_LEN + 1] = "No Test Name Specified";

//random number seed used by test apps
USHORT usRandomSeed = 0;

//routing variable for standard out in tprintf and ErrExit calls
//can be changed from default of DEST_OUT
BYTE bDestOut = DEST_OUT;

//+----------------------------------------------------------------------------
// Function: Allocate, public
//
// Synopsis: allocate memory, exit with error if malloc failes
//
// Arguments: [cbBytesToAllocate] - size of memory block to allocate
//
// Returns: void pointer to block of memory allocated
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void *Allocate(size_t cbBytesToAllocate)
{
    void *pvMemPtr;

    pvMemPtr = (void *) malloc(cbBytesToAllocate);
    if(pvMemPtr == NULL)
    {
        ErrExit(DEST_ERR, ERR, "Unable to allocate %u bytes of memory\n",
                cbBytesToAllocate);
    }

    return pvMemPtr;
}

//+----------------------------------------------------------------------------
// Function: MakePath, public
//
// Synopsis: makes a sub-directory at end of specified path
//
// Effects: For each char in pszDirToMake, if it's a '\', make the destination
//          directory at the level accumulated in pszPathBuf, else append
//          the next letter of the dest path to pszPathBuf.  After the loop,
//          attempt to _mkdir a final time (since the path probably won't
//          end with a '\').
//
// Arguments: [pszDirToMake] - full directory path name to make
//
// Returns: TRUE if all directories in path were made OK, otherwise FALSE
//
// Created: RichE January 1992
//-----------------------------------------------------------------------------

BOOL MakePath(char *pszDirToMake)
{
#ifdef DBCS
	char *pszDirToMakeSav = pszDirToMake;
#endif
    char *pcDestPathSoFar;
    char *pszPathBuf;
    int  iRc;

    pszPathBuf = (char *) Allocate(_MAX_PATH + 1);
    pcDestPathSoFar = pszPathBuf;

    //
    //while not at end of path string, if this char is a back slash, make
    //the directory up to the slash.  in either case, copy the next char
    //into the accumulated path buffer.
    //

    while (*pszDirToMake)
    {
        if (*pszDirToMake == '\\')
        {
            *pcDestPathSoFar = NIL;
            iRc = _mkdir(pszPathBuf);
            tprintf(bDestOut, "Trying to make directory %s, returned %d\n",
                    pszPathBuf, iRc);
        }
#ifdef DBCS
 #ifdef _MAC
		if (iskanji (*pszDirToMake)) // iskanji is in dbcsutil.cpp
 #else
		if (IsDBCSLeadbyte (*pszDirToMake))
 #endif
        	*pcDestPathSoFar++ = *pszDirToMake++;
#endif
        *pcDestPathSoFar++ = *pszDirToMake++;
    }

    //
    //if the last char wasn't a back slash, the last part of the path hasn't
    //been made so make it.
    //
#ifdef DBCS
 #ifdef _MAC
	DecLpch (pszDirToMakeSav, pszDirToMake);
 #else
	pszDirToMake = AnsiPrev (pszDirToMakeSav, pszDirToMake);
 #endif // MAC
	if (*pszDirToMake != '\\')
#else
    if (*(--pszDirToMake) != '\\')
#endif
    {
        *pcDestPathSoFar = NIL;
        iRc = _mkdir(pszPathBuf);
        tprintf(bDestOut, "Trying to make directory %s, returned %d\n",
                pszPathBuf, iRc);
    }

    free(pszPathBuf);

    return (iRc == 0) ? TRUE : FALSE;
}



//+----------------------------------------------------------------------------
// Function: SetDebugMode, public
//
// Synopsis: sets debugging mode and program exit control and tprintf routing
//
// Effects: Sets exit control to 'no exit when complete.'  depending upon
//          the char passed, in calls debug macro to set appropriate
//          debug mode.  If no debug is specified, sets program exit
//          control to 'exit when complete' and sets flag to close log
//          file after every log write.  If a debug mode other than
//          none is specified, redirects default output destination to
//          DEST_LOG instead of DEST_OUT.  Also sets capture buffer to
//          unlimited size
//
// Arguments: [DebugMode] - single character representing desired mode
//
// Modifiles: [fCloseLogAfterWrite] - if running in non-debug mode, close
//                                    log file after every write
//
// Created: RichE April 1992
//-----------------------------------------------------------------------------

void SetDebugMode(char DebugMode)
{
    SET_DISPLAY_BUF_SIZE;

    NO_EXIT_WHEN_DONE;

    switch(DebugMode)
    {
    case 'a':
        DEBUG_ALL;
        bDestOut = DEST_LOG;
        break;

    case 'n':
        DEBUG_NONE;
        EXIT_WHEN_DONE;
        //fCloseLogAfterWrite = TRUE;
        break;

    case 'd':
        DEBUG_DOCFILE;
        bDestOut = DEST_LOG;
        break;

    case 'm':
        DEBUG_MSF;
        bDestOut = DEST_LOG;
        break;

    case 'i':
    default:
        DEBUG_INTERNAL_ERRORS;
        bDestOut = DEST_LOG;
        break;

    }
}



//+----------------------------------------------------------------------------
// Function: ErrExit, public
//
// Synopsis: allows error output to any combo of stdout, stderr, and logfile
//
// Effects: depending upon flags passed in, will display (via vfprintf)
//          error output to any combination of stdout, stderr, and a user-
//          supplied log file.  if output destination is a log file,
//          will open the log file if not already open and set
//          all output to the error output destination as well.
//          prints docfile error message based on error code, or
//          generic error message is error is undefined.  prints error
//          return code, prints FAIL message using extern global [szTestName]
//          (defined in calling test) and exits with error code.
//
// Arguments: [bOutputDest] - bit flags specifying where output goes
//                            valid flags defined in W4CTSUPP.HXX
//            [ErrCode] - error code to use in exit() function
//            [fmt] - vfprintf formatting string
//            [...] - parameters to vfprintf function
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void ErrExit(BYTE bOutputDest, SCODE ErrCode, char *fmt, ...)
{
    USHORT iErrIndex = 0;

    struct
    {
        SCODE scErrCode;
        char *pszErrMessage;
    } aszErrMessages[] = {S_FALSE,                     "S_FALSE",
                          STG_E_INVALIDFUNCTION,       "STG_E_INVALIDFUNCTION",
                          STG_E_FILENOTFOUND,          "STG_E_FILENOTFOUND",
                          STG_E_TOOMANYOPENFILES,      "STG_E_TOOMANYOPENFILES",
                          STG_E_ACCESSDENIED,          "STG_E_ACCESSDENIED",
                          STG_E_INVALIDHANDLE,         "STG_E_INVALIDHANDLE",
                          STG_E_INSUFFICIENTMEMORY,    "STG_E_INSUFFICIENTMEMORY",
                          STG_E_INVALIDPOINTER,        "STG_E_INVALIDPOINTER",
                          STG_E_NOMOREFILES,           "STG_E_NOMOREFILES",
                          STG_E_WRITEFAULT,            "STG_E_WRITEFAULT",
                          STG_E_READFAULT,             "STG_E_READFAULT",
                          STG_E_LOCKVIOLATION,         "STG_E_LOCKVIOLATION",
                          STG_E_FILEALREADYEXISTS,     "STG_E_FILEALREADYEXISTS",
                          STG_E_INVALIDPARAMETER,      "STG_E_INVALIDPARAMETER",
                          STG_E_MEDIUMFULL,             "STG_E_MEDIUMFULL",
                          STG_E_ABNORMALAPIEXIT,       "STG_E_ABNORMALAPIEXIT",
                          STG_E_INVALIDHEADER,         "STG_E_INVALIDHEADER",
                          STG_E_INVALIDNAME,           "STG_E_INVALIDNAME",
                          STG_E_UNKNOWN,               "STG_E_UNKNOWN",
                          STG_E_UNIMPLEMENTEDFUNCTION, "STG_E_UNIMPLEMENTEDFUNCTION",
                          STG_E_INVALIDFLAG,           "STG_E_INVALIDFLAG",
                          STG_E_INUSE,                 "STG_E_INUSE",
                          STG_E_NOTCURRENT,            "STG_E_NOTCURRENT",
                          STG_E_REVERTED,              "STG_E_REVERTED",
                          STG_S_CONVERTED,             "STG_S_CONVERTED",
                          ERR,                         "GENERIC_ERROR"
                         };

    va_list args;

    va_start(args, fmt);

    //if dest is log file, open log file if not already open
    //and set all output to DEST_ERR as well.
    if (bOutputDest & DEST_LOG)
    {
        bOutputDest |= DEST_ERR;

        if (fileLogFile == NULL)
        {
            LogFile(NULL, LOG_OPEN);
        }

        vfprintf(fileLogFile, fmt, args);

        if (fCloseLogAfterWrite == TRUE)
        {
            LogFile(NULL, LOG_CLOSE);
        }
    }

    if (bOutputDest & DEST_OUT)
    {
        vfprintf(stdout, fmt, args);
    }

    if (bOutputDest & DEST_ERR)
    {
        vfprintf(stderr, fmt, args);
    }

    va_end(args);

    tprintf(bOutputDest, "Return code %lu (0x%08lX), ", ErrCode, ErrCode);

    //lookup error in struct table and print error message
    while (aszErrMessages[iErrIndex].scErrCode != ErrCode)
    {
        if (aszErrMessages[iErrIndex].scErrCode == ERR)
        {
            break;
        }
        else
        {
            iErrIndex++;
        }
    }

    tprintf(bOutputDest, "%s\n", aszErrMessages[iErrIndex].pszErrMessage);

    tprintf(bOutputDest, "FAIL: %s\n", szTestName);

    exit((int) ErrCode);
}



//+----------------------------------------------------------------------------
// Function: tprintf, public
//
// Synopsis: allows output to any combo of stdout, stderr, and logfile
//
// Effects: depending upon flags passed in, will display (via vfprintf)
//          output to any combination of stdout, stderr, and a user-
//          supplied log file.  if output destination is a log file,
//          will open the log file if not already open and set
//          all output to the error output destination as well.
//
// Arguments: [bOutputDest] - bit flags specifying where output goes
//                            valid flags defined in W4CTSUPP.HXX
//            [fmt] - vfprintf formatting string
//            [...] - parameters to vfprintf function
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void tprintf(BYTE bOutputDest, char *fmt, ...)
{
    va_list args;

    va_start(args, fmt);

    //if dest is log file, open log file if not already open
    //and set all output to DEST_ERR as well.
    if (bOutputDest & DEST_LOG)
    {
        bOutputDest |= DEST_ERR;

        if (fileLogFile == NULL)
        {
            LogFile(NULL, LOG_OPEN);
        }

        vfprintf(fileLogFile, fmt, args);

        if (fCloseLogAfterWrite == TRUE)
        {
            LogFile(NULL, LOG_CLOSE);
        }
    }

    if (bOutputDest & DEST_OUT)
    {
        vfprintf(stdout, fmt, args);
    }

    if (bOutputDest & DEST_ERR)
    {
        vfprintf(stderr, fmt, args);
    }

    va_end(args);
}



//+----------------------------------------------------------------------------
// Function: LogFile, public
//
// Synopsis: opens or closed specified file for logging via tprintf and errexit
//
// Effects: the specfied file is opened via fopen for logging purposes when
//          [bLogFileAction] = LOG_OPEN and closed for LOG_CLOSE.  The
//          calling application should open the LogFile via a LOG_INIT
//          call which will define the routine to call to ensure that the
//          log file is closed upon completion and set the log file name.
//
// Modifies: [fileLogFile] - the global variable defined at top of this file
//           will contain a pointer to the log file stream on exit.
//
// Arguments: [pszLogFileName] - pathname of file for logging purposes
//            [bLogFileAction] - whether to open or close the log file
//
// Notes: [pszLogReOpenName] is the filename to use for opening the log
//        file.  In non-debug runs, the log file is closed after every
//        log write and re-opened before the next write.
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void LogFile(char *pszLogFileName, BYTE bLogFileAction)
{
    static char  *pszLogReOpenName = NULL;
    static BOOL  fFirstInitCall = FALSE;
    char         *pszTestDataDir;

    switch (bLogFileAction)
    {
    case LOG_INIT:
        if (pszLogFileName == NULL)
        {
            ErrExit(DEST_ERR, ERR, "No filename specified for LOG_INIT\n");
        }

        if (fileLogFile != NULL)
        {
            fclose(fileLogFile);
            free(pszLogReOpenName);
        }

        pszLogReOpenName = (char *) Allocate(strlen(pszLogFileName)+1);
        strcpy(pszLogReOpenName, pszLogFileName);

        if (fFirstInitCall == FALSE)
        {
            //register function to call on program exit
            //

            atexit(MakeSureThatLogIsClosed);
            fFirstInitCall = TRUE;

            //
            //change to dir specified by DFDATA env variable, if it's set
            //

            if (pszTestDataDir = getenv("DFDATA"))
            {
                _chdir(pszTestDataDir);
            }
        }

        break;

    case LOG_OPEN:
        if (fileLogFile != NULL)
        {
            ErrExit(DEST_ERR,ERR,"Can't open log file %s, log is already open!",
                    pszLogReOpenName);
        }

        if (pszLogReOpenName == NULL)
        {
            pszLogReOpenName = (char *) Allocate(strlen(LOG_DEFAULT_NAME)+1);
            strcpy(pszLogReOpenName, LOG_DEFAULT_NAME);
        }

        if ((fileLogFile = fopen(pszLogReOpenName, "w")) == NULL)
        {
            ErrExit(DEST_ERR, ERR, "Error opening log file %s\n",
                    pszLogReOpenName);
        }

        break;

    case LOG_CLOSE:
        if (fileLogFile != NULL)
        {
            fflush(fileLogFile);
            fclose(fileLogFile);
        }
        else
        {
            tprintf(DEST_ERR,"Warning: can't close log file %s, log isn't open!",
                   pszLogReOpenName);
        }

        break;

    default:
        ErrExit(DEST_ERR,ERR,"Invalid parameter to LogFile() function!");
    }
}



//+----------------------------------------------------------------------------
// Function: MakeSureThatLogFileIsClosed
//
// Synopsis: closes log file on exit
//
// Effects: immediately flushes all file buffers, and then calls Logfile to
// close the test log file.  upon abnormal exit (GP fault), this saves most
// of the log information.
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void MakeSureThatLogIsClosed(void)
{
    //fflush(fileLogFile);
    LogFile(NULL, LOG_CLOSE);

}

//+----------------------------------------------------------------------------
// Function: MakeSingle, public
//
// Synopsis: converts TCHAR string to single character string
//
// Arguments: [pszSingleName] - pointer to TCHAR string
//            [ptcsWideName] - buffer to hold returned single-wide string
//
// Modifies: [pszSingleName] - on exit holds single-wide character string
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void MakeSingle(char *pszSingleName, TCHAR *ptcsWideName)
{
#ifdef UNICODE
    USHORT cusBufLen = (tcslen(ptcsWideName)+1) * sizeof(TCHAR);

    if (_fwcstombs(pszSingleName, ptcsWideName, cusBufLen) == -1)
    {
        ErrExit(DEST_LOG, ERR, "Error converting TCHAR string to single wide\n");
    }
#else
    strcpy(pszSingleName, ptcsWideName);
#endif
}



//+----------------------------------------------------------------------------
// Function: MakeWide, public
//
// Synopsis: converts single character string to multi-byte (TCHAR) string
//
// Arguments: [ptcsWideName] - buffer to hold returned TCHAR string
//            [pszSingleName] - pointer to single wide string
//
// Modifies: [ptcsWideName] - on exit holds wide character string
//
// Created: RichE March 1992
//-----------------------------------------------------------------------------

void MakeWide(TCHAR *ptcsWideName, char *pszSingleName)
{
#ifdef UNICODE
    USHORT cusBufLen = (strlen(pszSingleName)+1) * sizeof(TCHAR);

    if (_fmbstowcs(ptcsWideName, pszSingleName, cusBufLen) == -1)
    {
        ErrExit(DEST_LOG, ERR, "Error converting name %s to TCHAR string\n", pszSingleName);
    }
#else
    strcpy(ptcsWideName, pszSingleName);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\fail\sift.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       SIFT.cxx
//
//  Contents:   Simulated Iterated Failure Testing Harness
//
//  Functions:  Sift
//
//  History:    25-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>

#pragma hdrstop

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

#include <sift.hxx>

#define SET_DISPLAY_BUF_SIZE _wsetscreenbuf(_fileno(stdout), _WINBUFINF)

void main (int argc, char *argv[])
{
    int i;
    int cTests = TestCount();

    SiftInit();

    SET_DISPLAY_BUF_SIZE;   //set QuickWin buffer size to infinite

    printf("SIFT %d tests.\n", cTests);

    for (i = 0; i < cTests; i++)
    {
        SiftDriver(TestItem(i));
    }

    //  Be a good citizen and leave the Docfile clean
    SetFailLimit(0L);

    CoUninitialize();

    printf("SIFT complete.\n");
}

//+-------------------------------------------------------------------------
//
//  Function:   Initialize
//
//  Synopsis:   Standard initialization
//
//  History:    21-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void SiftInit(void)
{
    SCODE sc;

#if WIN32 == 300
    if (FAILED(sc = DfGetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
#else
    if (FAILED(sc = DfGetScode(CoInitialize(NULL))))
#endif
        printf("SIFT: Unable to CoInitialize, sc = 0x%lX\n", sc);

    DfDebug(0x00100101, 0x101);
}

void SiftDriver(CTestCase *ptc)
{
    SCODE sc;

    if (!ptc->Init())
    {
        //  Test's obligation to display failure message
        return;
    }

    do
    {
        LONG iteration, lcf = 0;
        for (iteration = 0; iteration <= lcf; iteration++)
        {
            SetFailLimit(0L);

            sc = ptc->Prep(iteration);
            if (FAILED(sc))
                continue;

            SetFailLimit(iteration);
            sc = ptc->Call(iteration);

            if (SUCCEEDED(sc))
            {
                if (iteration == 0)
                {
                    lcf = DfGetResLimit(DBR_FAILCOUNT);
                    printf("%ld failure points\n", lcf);
                }
                else
                {
                    //  Shouldn't have succeeded
                    printf("..Iteration %ld succeeded!\n", iteration);
                }
                SetFailLimit(0L);
                ptc->EndCall(iteration);
            }
            else
            {
                SetFailLimit(0L);
                ptc->CallVerify(iteration);
            }

            ptc->EndPrep(iteration);
            ptc->EndVerify(iteration);
        }
    } while (ptc->Next());
}

//+-------------------------------------------------------------------------
//
//  Function:   SetFailLimit
//
//  Synopsis:   clear count, set limit
//
//  Arguments:  [limit] -- failure limit
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void SetFailLimit(LONG limit)
{
    DfSetResLimit(DBR_FAILCOUNT, 0);
    DfSetResLimit(DBR_FAILLIMIT, limit);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\fail\supp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Supp.cxx
//
//  Contents:   Supplementary classes
//
//  Classes:    CModeDf - Docfile creation modes
//
//  History:    25-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>

#pragma hdrstop

#include <sift.hxx>

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

// #define DEPTHTEST    //  Uncomment out for depth testing (long time)

//+-------------------------------------------------------------------------
//
//  Notes:  Mode combinations for StgCreateDocfile
//
//--------------------------------------------------------------------------

DWORD adwTransactionModes[] = {
    STGM_DIRECT,
    STGM_TRANSACTED
};

#define TMODES (sizeof(adwTransactionModes) / sizeof(DWORD))

DWORD adwAccessModes[] = {
    STGM_READWRITE,
    STGM_WRITE,
    STGM_READ
};

#if defined(DEPTHTEST)
# define AMODES (sizeof(adwAccessModes) / sizeof(DWORD))
#else
# define AMODES 1
#endif

DWORD adwShareModes[] = {
    STGM_SHARE_DENY_NONE,
    STGM_SHARE_EXCLUSIVE,
    STGM_SHARE_DENY_READ,
    STGM_SHARE_DENY_WRITE
};

#if defined(DEPTHTEST)
# define SMODES (sizeof(adwShareModes) / sizeof(DWORD))
#else
# define SMODES 2
#endif

DWORD adwDeleteModes[] = {
    0,
    STGM_DELETEONRELEASE
};

#if defined(DEPTHTEST)
# define DMODES (sizeof(adwDeleteModes) / sizeof(DWORD))
#else
# define DMODES 1
#endif

DWORD adwCreateModes[] = {
    STGM_FAILIFTHERE,
    STGM_CREATE,
    STGM_CONVERT
};

#if defined(DEPTHTEST)
# define CMODES (sizeof(adwCreateModes) / sizeof(DWORD))
#else
# define CMODES 1
#endif

void CModeDf::Init(void)
{
    _it = _ia = _is = _id = _ic = 0;
    CalcMode();
}

void CModeDf::CalcMode(void)
{
    _dwMode = adwTransactionModes[_it] |
              adwAccessModes[_ia]      |
              adwShareModes[_is]       |
              adwDeleteModes[_id]      |
              adwCreateModes[_ic];
}

BOOL CModeDf::Next(void)
{
    BOOL f = TRUE;

    if (++_ic >= CMODES)
    {
        _ic = 0;
        if (++_id >= DMODES)
        {
            _id = 0;
            if (++_is >= SMODES)
            {
                _is = 0;
                if (++_ia >= AMODES)
                {
                    _ia = 0;
                    if (++_it >= TMODES)
                    {
                        f = FALSE;
                    }
                }
            }
        }
    }

    if (f)
        CalcMode();

    return(f);
}

void CModeStg::Init(void)
{
    _it = _ia = 0;
    CalcMode();
}

void CModeStg::CalcMode(void)
{
    _dwMode = adwTransactionModes[_it] |
              adwAccessModes[_ia]      |
              STGM_SHARE_EXCLUSIVE;
}

BOOL CModeStg::Next(void)
{
    BOOL f = TRUE;

    if (++_ia >= AMODES)
    {
        _ia = 0;
        if (++_it >= TMODES)
        {
            f = FALSE;
        }
    }

    if (f)
        CalcMode();

    return(f);
}

void CModeStm::Init(void)
{
    _ia = 0;
    CalcMode();
}

void CModeStm::CalcMode(void)
{
    _dwMode = STGM_DIRECT         |
              adwAccessModes[_ia] |
              STGM_SHARE_EXCLUSIVE;
}

BOOL CModeStm::Next(void)
{
    BOOL f = TRUE;

    if (++_ia >= AMODES)
    {
        f = FALSE;
    }

    if (f)
        CalcMode();

    return(f);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\fail\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       headers.cxx
//
//  Contents:   Precompiled headers
//
//  History:    21-Jan-93 AlexT    Created
//
//--------------------------------------------------------------------------

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

#include <io.h>
#include <stdio.h>
#include <stdlib.h>

#include <windows.h>
#include <memory.h>
#include <storage.h>

#include <debnot.h>
#include <dfdeb.hxx>
#include <dfmsp.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcschr.c ===
/***
*wcschr.c - search a wide character string for a given wide character
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcschr() - search a wide character string for a wide character
*
*Revision History:
*       04-07-91  IanJa C version created.
*
*******************************************************************************/

#include <stddef.h>
#include <stdlib.h>

/***
*char *wcschr(string, c) - search a wide character string for a wide character
*
*Purpose:
*       Searches a wide character string for a given wide character, which may
*       be the null character L'\0'.
*
*Entry:
*       wchar_t *string - string to search in
*       wchar_t c - character to search for
*
*Exit:
*       returns pointer to the first occurence of c in string
*       returns NULL if c does not occur in string
*
*Exceptions:
*
*******************************************************************************/

wchar_t * __cdecl wcschr(const wchar_t * string, wchar_t ch)
{
      while (*string && *string != ch)
              string++;

      if (*string == ch)
              return (wchar_t *)string;
      return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\fail\fail.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       Fail.CXX
//
//  Contents:   Docfile Failure Test
//
//  History:    21-Jan-93 AlexT     Created
//
//  Notes:      This test cycles through all failure points for each call,
//              verifying that we clean up correctly.
//
//--------------------------------------------------------------------------

#include <headers.cxx>

#pragma hdrstop

#include <sift.hxx>

#if DBG != 1
#error FAIL.EXE requires DBG == 1
#endif

// #define BREADTHTEST  //  Comment out for depth testing (just most recent tests)

//+-------------------------------------------------------------------------
//
//  Function:   VerifyDisk
//
//  Synopsis:   verify that disk file does or does not exist
//
//  Arguments:  [fExist]    -- TRUE if file should exist, else FALSE
//              [iteration] -- iteration number
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void VerifyDisk(BOOL fExist, LONG iteration)
{
    if (_access("c:\\testfail.dfl", 0) == 0)
    {
        if (!fExist)
        {
            printf("..Iteration %ld, file still exists\n", iteration);
        }
    }
    else
    {
        if (fExist)
        {
            printf("..Iteration %ld, file doesn't exist\n", iteration);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   VerifyMemory
//
//  Arguments:  [iteration] -- iteration number
//
//  Requires:   Caller should expect 0 memory to be allocated
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void VerifyMemory(LONG iteration)
{
    if (DfGetMemAlloced() > 0L)
    {
        printf("..Iteration %ld - memory allocated\n", iteration);
        DfPrintAllocs();
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   VerifyClean
//
//  Synopsis:   checks disk, memory
//
//  Arguments:  [sc]        -- status code
//              [dwMode]    -- Docfile mode
//              [iteration] -- iteration
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

void VerifyClean(SCODE sc, DWORD dwMode, LONG iteration)
{
    VerifyDisk(SUCCEEDED(sc) &&
               !(dwMode & STGM_DELETEONRELEASE), iteration);
    VerifyMemory(iteration);
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateWorkingDocfile
//
//  Synopsis:   create and verify the test Docfile
//
//  Arguments:  [dwMode]    -- Docfile creation mode
//              [ppstg]     -- placeholder for IStorage
//              [iteration] -- iteration number
//
//  Returns:    SCODE
//
//  Modifies:   ppstg
//
//  History:    22-Jan-93 AlexT     Created
//
//--------------------------------------------------------------------------

SCODE CreateWorkingDocfile(DWORD dwMode, IStorage **ppstg, LONG iteration)
{
    SCODE sc;

    //  Make sample call
    remove("c:\\testfail.dfl");
    sc = DfGetScode(StgCreateDocfile(
            "c:\\testfail.dfl",
            dwMode,
            0,
            ppstg));

    if (FAILED(sc))
    {
        if (iteration == 0)
        {
            //  This was a prep call.  Prep calls aren't supposed to fail
            if (sc == STG_E_INVALIDFLAG)
            {
                //  Probably a bad combination of mode flags
                printf("..Iteration %ld, sc = STG_E_INVALIDFLAG (OK)\n",
                       iteration);
            }
            else if (FAILED(sc))
            {
                //  Something unexpected
                printf("..Iteration %ld failed - sc = 0x%lX\n",
                       iteration, sc);
            }
        }
        else    //  iteration != 0
        {
            if (sc == STG_E_INSUFFICIENTMEMORY || sc == STG_E_MEDIUMFULL)
            {
                //  we expected these failures;  do nothing
                ;
            }
            else
            {
                printf("..Iteration %ld failed - sc = 0x%lX (??)\n",
                       iteration, sc);
            }
        }
    }

    return(sc);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestStgCreate
//
//  Purpose:    Test StgCreateDocfile
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestStgCreate : public CTestCase
{
private:
    SCODE _sc;
    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestStgCreate::Init(void)
{
    printf("SIFT StgCreateDocfile\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestStgCreate::Prep(LONG iteration)
{
    //  inherit this?
    return(NOERROR);
}

SCODE CTestStgCreate::Call(LONG iteration)
{
    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n", _mdf.GetMode());

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, iteration);

    return(_sc);
}

void CTestStgCreate::EndCall(LONG iteration)
{
    _pstg->Release();
}

void CTestStgCreate::CallVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

void CTestStgCreate::EndPrep(LONG iteration)
{
    //  inherit this?
}

void CTestStgCreate::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestStgCreate::Next(void)
{
    if (!_mdf.Next())
        return FALSE;

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCreateStorage
//
//  Purpose:    Test IStorage::CreateStorage
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCreateStorage : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCreateStorage::Init(void)
{
    printf("SIFT IStorage::CreateStorage\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestCreateStorage::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    return(_sc);
}

SCODE CTestCreateStorage::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstg->CreateStorage(
            "TestFail Storage",
            _mstg.GetMode(),
            0,
            0,
            &_pstgChild));

    return(sc);
}

void CTestCreateStorage::EndCall(LONG iteration)
{
    _pstgChild->Release();
}

void CTestCreateStorage::CallVerify(LONG iteration)
{
}

void CTestCreateStorage::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCreateStorage::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestCreateStorage::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCreateStream
//
//  Purpose:    Test IStorage::CreateStream
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCreateStream : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCreateStream::Init(void)
{
    printf("SIFT IStorage::CreateStream\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestCreateStream::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    return(_sc);
}

SCODE CTestCreateStream::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Stream Mode 0x%lX\n",
               _mdf.GetMode(), _mstm.GetMode());

    sc = DfGetScode(_pstg->CreateStream(
        "TestFail Stream",
        _mstm.GetMode(),
        0,
        0,
        &_pstmChild));

    return(sc);
}

void CTestCreateStream::EndCall(LONG iteration)
{
    _pstmChild->Release();
}

void CTestCreateStream::CallVerify(LONG iteration)
{
}

void CTestCreateStream::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCreateStream::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestCreateStream::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestWrite
//
//  Purpose:    Test IStream::Write
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestWrite : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestWrite::Init(void)
{
    printf("SIFT IStream::Write\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestWrite::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
    }
    return(_sc);
}

SCODE CTestWrite::Call(LONG iteration)
{
    SCODE sc;
    ULONG cb = 1;
    char c = 'X';
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), cb);

    sc = DfGetScode(_pstmChild->Write(&c, cb, &cbWritten));

    if (FAILED(sc))
    {
        if (sc != STG_E_MEDIUMFULL)
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestWrite::EndCall(LONG iteration)
{
}

void CTestWrite::CallVerify(LONG iteration)
{
}

void CTestWrite::EndPrep(LONG iteration)
{
    _pstmChild->Release();
    _pstg->Release();
}

void CTestWrite::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestWrite::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestOpenStream
//
//  Purpose:    Test IStorage::OpenStream
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestOpenStream : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstm;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestOpenStream::Init(void)
{
    printf("SIFT IStorage::OpenStream\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestOpenStream::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstm));

        if (FAILED(_sc))
            _pstg->Release();
        else
            _pstm->Release();
    }
    return(_sc);
}

SCODE CTestOpenStream::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX\n",
               _mdf.GetMode(), _mstm.GetMode());

    sc = DfGetScode(_pstg->OpenStream(
            "TestFail Stream",
            0,
            _mstm.GetMode(),
            0,
            &_pstm));

    return(sc);
}

void CTestOpenStream::EndCall(LONG iteration)
{
    _pstm->Release();
}

void CTestOpenStream::CallVerify(LONG iteration)
{
}

void CTestOpenStream::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestOpenStream::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestOpenStream::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestOpenStorage
//
//  Purpose:    Test IStorage::OpenStorage
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestOpenStorage : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestOpenStorage::Init(void)
{
    printf("SIFT IStorage::OpenStorage\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestOpenStorage::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        if (FAILED(_sc))
            _pstg->Release();
        else
            _pstgChild->Release();
    }
    return(_sc);
}

SCODE CTestOpenStorage::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstg->OpenStorage("TestFail Storage", 0,
            _mstg.GetMode(), 0, 0, &_pstgChild));

    return(sc);
}

void CTestOpenStorage::EndCall(LONG iteration)
{
    _pstgChild->Release();
}

void CTestOpenStorage::CallVerify(LONG iteration)
{
}

void CTestOpenStorage::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestOpenStorage::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestOpenStorage::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit
//
//  Purpose:    Test IStream::Write
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCommit : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestCommit::Prep(LONG iteration)
{
    SCODE sc;

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(sc))
    {
        sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        if (FAILED(sc))
            _pstg->Release();
    }
    return(sc);
}

SCODE CTestCommit::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstgChild->Commit(0));

    if (FAILED(sc))
    {
        if (sc != STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit::EndCall(LONG iteration)
{
}

void CTestCommit::CallVerify(LONG iteration)
{
}

void CTestCommit::EndPrep(LONG iteration)
{
    _pstgChild->Release();
    _pstg->Release();
}

void CTestCommit::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit2
//
//  Purpose:    Test IStorage::Commit
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCommit2 : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit2::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestCommit2::Prep(LONG iteration)
{
    SCODE sc;
    ULONG cb = 1;
    char c = 'X';
    ULONG cbWritten;

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(sc))
    {
        sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        if (FAILED(sc))
            _pstg->Release();
        else
        {
            sc = DfGetScode(_pstgChild->CreateStream(
                    "TestFail Stream",
                    STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                    0,
                    0,
                    &_pstmChild));

            if (FAILED(sc))
            {
                _pstgChild->Release();
                _pstg->Release();
            }
            else
            {
                sc = DfGetScode(_pstmChild->Write(&c, cb, &cbWritten));
                if (FAILED(sc))
                {
                    _pstmChild->Release();
                    _pstgChild->Release();
                    _pstg->Release();
                }
            }
        }
    }
    return(sc);
}

SCODE CTestCommit2::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstgChild->Commit(0));

    if (FAILED(sc))
    {
        if (sc == STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit2::EndCall(LONG iteration)
{
}

void CTestCommit2::CallVerify(LONG iteration)
{
}

void CTestCommit2::EndPrep(LONG iteration)
{
    _pstmChild->Release();
    _pstgChild->Release();
    _pstg->Release();
}

void CTestCommit2::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit2::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit3
//
//  Purpose:    Test IStorage::Commit
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCommit3 : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit3::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestCommit3::Prep(LONG iteration)
{
    SCODE sc;
    ULONG cb = 1;
    char c = 'X';

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);

    if (FAILED(sc))
        return(sc);

    IStream *pstm;
    sc = DfGetScode(_pstg->CreateStream(
                "PP40",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();

    IStorage *pstgChild;
    sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstgChild));

    sc = DfGetScode(pstgChild->CreateStream(
                "One",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();
    sc = DfGetScode(pstgChild->CreateStream(
                "Two",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();
    sc = DfGetScode(pstgChild->CreateStream(
                "Three",
                STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,
                0,
                0,
                &pstm));
    pstm->Release();

    sc = DfGetScode(pstgChild->Commit(0));
    pstgChild->Release();

    return(sc);
}

SCODE CTestCommit3::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n",
               _mdf.GetMode());

    sc = DfGetScode(_pstg->Commit(0));

    if (FAILED(sc))
    {
        if (sc == STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit3::EndCall(LONG iteration)
{
}

void CTestCommit3::CallVerify(LONG iteration)
{
}

void CTestCommit3::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCommit3::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit3::Next(void)
{
    if (!_mdf.Next())
        return(FALSE);

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestCommit4
//
//  Purpose:    Test IStorage::Commit with resized streams
//
//  Interface:  CTestCase
//
//  History:    08-Sep-93 DrewB     Created
//
//--------------------------------------------------------------------------

class CTestCommit4 : public CTestCase
{
private:
    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCommit4::Init(void)
{
    printf("SIFT IStorage::Commit\n");
    _mdf.Init();
    return(TRUE);
}

#define LARGE_SIZE 4097
#define SMALL_SIZE 4095

SCODE CTestCommit4::Prep(LONG iteration)
{
    SCODE sc;
    IStream *pstm;
    ULARGE_INTEGER uli;

    sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (FAILED(sc))
        goto EH_Err;
    sc = DfGetScode(_pstg->CreateStream("Test",
                                        STGM_DIRECT | STGM_SHARE_EXCLUSIVE |
                                        STGM_READWRITE, 0, 0, &pstm));
    if (FAILED(sc))
        goto EH_pstg;
    uli.HighPart = 0;
    uli.LowPart = LARGE_SIZE;
    sc = DfGetScode(pstm->SetSize(uli));
    if (FAILED(sc))
        goto EH_pstm;
    sc = DfGetScode(_pstg->Commit(0));
    if (FAILED(sc))
        goto EH_pstm;
    uli.LowPart = SMALL_SIZE;
    sc = DfGetScode(pstm->SetSize(uli));
    if (FAILED(sc))
        goto EH_pstm;
    pstm->Release();
    return sc;

 EH_pstm:
    pstm->Release();
 EH_pstg:
    _pstg->Release();
 EH_Err:
    return sc;
}

SCODE CTestCommit4::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n",
               _mdf.GetMode());

    sc = DfGetScode(_pstg->Commit(0));

    if (FAILED(sc))
    {
        if (sc == STG_E_MEDIUMFULL)
            printf("..Iteration %ld - STG_E_MEDIUMFULL\n", iteration);
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }
    return(sc);
}

void CTestCommit4::EndCall(LONG iteration)
{
}

void CTestCommit4::CallVerify(LONG iteration)
{
    IStream *pstm;
    SCODE sc;
    STATSTG stat;

    sc = DfGetScode(_pstg->OpenStream("Test", NULL, STGM_DIRECT |
                                      STGM_SHARE_EXCLUSIVE, 0, &pstm));
    if (FAILED(sc))
    {
        printf("Can't open stream - %lX\n", sc);
        return;
    }
    sc = DfGetScode(pstm->Stat(&stat, STATFLAG_NONAME));
    pstm->Release();
    if (FAILED(sc))
    {
        printf("Can't stat stream - %lX\n", sc);
        return;
    }
    if (stat.cbSize.LowPart != SMALL_SIZE)
    {
        printf("Stream length is %lu rather than %d\n",
               stat.cbSize.LowPart, SMALL_SIZE);
        return;
    }
}

void CTestCommit4::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCommit4::EndVerify(LONG iteration)
{
    VerifyClean(S_OK, _mdf.GetMode(), iteration);
}

BOOL CTestCommit4::Next(void)
{
    if (!_mdf.Next())
        return(FALSE);

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestStgOpen
//
//  Purpose:    Test StgOpenStorage
//
//  Interface:  CTestCase
//
//  History:    28-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestStgOpen : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestStgOpen::Init(void)
{
    printf("SIFT StgOpenStorage\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestStgOpen::Prep(LONG iteration)
{
    SCODE sc;
    DWORD dwMode = STGM_DIRECT          |
                   STGM_READWRITE       |
                   STGM_SHARE_EXCLUSIVE |
                   STGM_FAILIFTHERE;
    IStorage *pstg, *pstgChild;
    IStream *pstmChild;

    sc = CreateWorkingDocfile(dwMode, &pstg, 0);
    if (SUCCEEDED(sc))
    {
        sc = DfGetScode(pstg->CreateStorage(
                "TestFail Storage",
                dwMode,
                0,
                0,
                &pstgChild));

        if (SUCCEEDED(sc))
        {
            sc = DfGetScode(pstgChild->CreateStream(
                    "TestFail Stream",
                    dwMode,
                    0,
                    0,
                    &pstmChild));

            if (SUCCEEDED(sc))
                pstmChild->Release();

            pstgChild->Release();
        }

        pstg->Release();
    }
    return(sc);
}

SCODE CTestStgOpen::Call(LONG iteration)
{
    if (iteration == 0)
        printf("Docfile Mode 0x%lX\n", _mdf.GetMode());

    _sc = DfGetScode(StgOpenStorage("c:\\testfail.dfl",
             NULL,
             _mdf.GetMode(),
             NULL,
             0,
            &_pstg));

    if (FAILED(_sc))
    {
        if (iteration == 0 && _sc == STG_E_INVALIDFLAG)
        {
            printf("..STG_E_INVALIDFLAG\n");
            //  Must have been a bad combination of flags - we
            //  ignore these for now.
        }
        else if (iteration > 0 && _sc == STG_E_INSUFFICIENTMEMORY)
        {
            //  Do nothing (expected failure)
        }
        else if (iteration > 0 && _sc == STG_E_MEDIUMFULL)
        {
            //  Do nothing (expected failure)
        }
        else
            printf("..Iteration %ld, call failed - sc = 0x%lX\n",
                   iteration, _sc);
    }
    return(_sc);
}

void CTestStgOpen::EndCall(LONG iteration)
{
    _pstg->Release();
}

void CTestStgOpen::CallVerify(LONG iteration)
{
}

void CTestStgOpen::EndPrep(LONG iteration)
{
}

void CTestStgOpen::EndVerify(LONG iteration)
{
    //  If the call failed, the file should still exist.
    //  If the call succeeded
    //    If mode was delete on release,
    //       file should not exist
    //    else file should exist

    VerifyDisk((SUCCEEDED(_sc) && (!(_mdf.GetMode() & STGM_DELETEONRELEASE))) ||
               FAILED(_sc), iteration);
    VerifyMemory(iteration);
}

BOOL CTestStgOpen::Next(void)
{
    if (!_mdf.Next())
         return(FALSE);

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestWrite2
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestWrite2 : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;

    ULONG _cbSize;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestWrite2::Init(void)
{
    printf("SIFT IStream::Write2 - large writes without Setsize\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 8;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestWrite2::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        _cbSize = 0;
        if (FAILED(_sc))
            _pstg->Release();

    }
    return(_sc);
}

SCODE CTestWrite2::Call(LONG iteration)
{
    SCODE sc;
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), _cb * _cBlock);

    for (ULONG i = 0; i < _cBlock; i++)
    {
        sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
        _cbSize += cbWritten;

        if (FAILED(sc))
        {
            if (sc != STG_E_MEDIUMFULL)
                printf("..Iteration %ld, block %lu - failed - sc = 0x%lX\n",
                       iteration, i + 1, sc);
            break;
        }
    }
    return(sc);
}

void CTestWrite2::EndCall(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cbSize)
    {
        printf("..Iteration %lu - Size of stream is %lu.  Expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cbSize);
    }
}

void CTestWrite2::CallVerify(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cbSize)
    {
        printf("..Iteration %lu - Size of stream is %lu.  Expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cbSize);
    }

}

void CTestWrite2::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestWrite2::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestWrite2::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestWrite3
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestWrite3 : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestWrite3::Init(void)
{
    printf("SIFT IStream::Write3 - large writes with prior Setsize\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 8;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestWrite3::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
        else
        {
            ULARGE_INTEGER cbSize;

            ULISet32(cbSize, _cb * _cBlock);

            _sc = DfGetScode(_pstmChild->SetSize(cbSize));

            if (FAILED(_sc))
            {
                _pstmChild->Release();
                _pstg->Release();
            }
        }
    }
    return(_sc);
}

SCODE CTestWrite3::Call(LONG iteration)
{
    SCODE sc;
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), _cb * _cBlock);
    else
        printf("ERROR - shouldn't hit iteration %lu\n", iteration);

    for (ULONG i = 0; i < _cBlock; i++)
    {
        sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
        if (FAILED(sc))
        {
            if (sc != STG_E_MEDIUMFULL)
                printf("..Iteration %ld, block %lu - failed - sc = 0x%lX\n",
                       iteration, i + 1, sc);
            break;
        }
    }
    return(sc);
}

void CTestWrite3::EndCall(LONG iteration)
{
}

void CTestWrite3::CallVerify(LONG iteration)
{
}

void CTestWrite3::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestWrite3::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestWrite3::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestSetsize
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestSetsize : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestSetsize::Init(void)
{
    printf("SIFT IStream::Setsize\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 9;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestSetsize::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
    }
    return(_sc);
}

SCODE CTestSetsize::Call(LONG iteration)
{
    SCODE sc;
    ULONG cbWritten;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Stream Mode 0x%lX, Write %ld bytes\n",
               _mdf.GetMode(), _mstm.GetMode(), _cb * _cBlock);

    ULARGE_INTEGER cbSize;

    ULISet32(cbSize, _cb * _cBlock);

    sc = DfGetScode(_pstmChild->SetSize(cbSize));


    if (FAILED(sc))
    {
        if (sc != STG_E_MEDIUMFULL)
            printf("..Iteration %ld - failed - sc = 0x%lX\n", iteration, sc);
    }
    else
    {
        for (ULONG i = 0; i < _cBlock; i++)
        {
            sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
            if (FAILED(sc))
            {
                printf("..Iteration %ld, Write %lu failed - sc == 0x%lX\n",
                       iteration, i + 1, sc);
                break;
            }
        }
    }
    return(sc);
}

void CTestSetsize::EndCall(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cb * _cBlock)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cb * _cBlock);
    }

}

void CTestSetsize::CallVerify(LONG iteration)
{
    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != 0)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected 0\n",
               iteration, ULIGetLow(stat.cbSize));
    }
}

void CTestSetsize::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestSetsize::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestSetsize::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestCreateStream2
//
//  Purpose:    Test IStorage::CreateStream2
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestCreateStream2 : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestCreateStream2::Init(void)
{
    printf("SIFT IStorage::CreateStream2\n");
    _mdf.Init();
    _mstm.Init();
    return(TRUE);
}

SCODE CTestCreateStream2::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    return(_sc);
}

SCODE CTestCreateStream2::Call(LONG iteration)
{
    SCODE sc;
    ULONG cStream = 8;

    char * pszName = "XTestFail Stream";
    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Stream Mode 0x%lX\n",
               _mdf.GetMode(), _mstm.GetMode());

    for (ULONG i = 0; i < cStream; i++)
    {
        pszName[0] = ((char)i) + '0';

        sc = DfGetScode(_pstg->CreateStream(
                pszName,
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(sc))
        {
            if ((sc == STG_E_MEDIUMFULL) || (sc == STG_E_INSUFFICIENTMEMORY))
            {
                //Do nothing. We expected these.
            }
            else printf("..Iteration %ld, stream %lu - failed - sc = 0x%lX\n",
                    iteration, i + 1, sc);
            break;
        }
        _pstmChild->Release();
    }

    return(sc);
}

void CTestCreateStream2::EndCall(LONG iteration)
{
}

void CTestCreateStream2::CallVerify(LONG iteration)
{
}

void CTestCreateStream2::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestCreateStream2::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestCreateStream2::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Class:      CTestDestroyElement
//
//  Purpose:    Test IStorage::DestroyElement
//
//  Interface:  CTestCase
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestDestroyElement : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStg _mstg;
    IStorage *_pstgChild;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestDestroyElement::Init(void)
{
    printf("SIFT IStorage::DestroyElement\n");
    _mdf.Init();
    _mstg.Init();
    return(TRUE);
}

SCODE CTestDestroyElement::Prep(LONG iteration)
{
    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStorage(
                "TestFail Storage",
                _mstg.GetMode(),
                0,
                0,
                &_pstgChild));

        _pstgChild->Release();
    }


    return(_sc);
}

SCODE CTestDestroyElement::Call(LONG iteration)
{
    SCODE sc;

    if (iteration == 0)
        printf("Docfile Mode 0x%lX, Child Storage Mode 0x%lX\n",
               _mdf.GetMode(), _mstg.GetMode());

    sc = DfGetScode(_pstg->DestroyElement("TestFail Storage"));

    if (FAILED(sc))
    {
        if ((sc == STG_E_MEDIUMFULL) || (sc == STG_E_INSUFFICIENTMEMORY))
        {
            //We expected these - do nothing.
        }
        else
            printf("..Iteration %ld - failed - sc = 0x%lX\n",
                   iteration, sc);
    }

    return(sc);
}

void CTestDestroyElement::EndCall(LONG iteration)
{
    SCODE sc;

    sc = DfGetScode(_pstg->OpenStorage(
            "TestFail Storage",
            0,
            _mstg.GetMode(),
            0,
            0,
            &_pstgChild));

    if (sc != STG_E_FILENOTFOUND)
    {
        printf("..Iteration %ld - open failed with 0x%lX, expected STG_E_FILENOTFOUND\n",
               iteration,
               sc);
    }

    if (SUCCEEDED(sc))
    {
        _pstgChild->Release();
    }
}

void CTestDestroyElement::CallVerify(LONG iteration)
{
    SCODE sc;

    sc = DfGetScode(_pstg->OpenStorage(
            "TestFail Storage",
            0,
            _mstg.GetMode(),
            0,
            0,
            &_pstgChild));

    if (FAILED(sc))
    {
        printf("..Iteration %ld - open failed with 0x%lX, expected success.\n",
               iteration,
               sc);
    }
    else
    {
        _pstgChild->Release();
    }

}

void CTestDestroyElement::EndPrep(LONG iteration)
{
    _pstg->Release();
}

void CTestDestroyElement::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestDestroyElement::Next(void)
{
    if (!_mstg.Next())
    {
        _mstg.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestSetsize2
//
//  Purpose:    Test IStream::Write for largish writes
//
//  Interface:  CTestCase
//
//  History:    16-Feb-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestSetsize2 : public CTestCase
{
private:
    SCODE _sc;

    BYTE *_pb;

    CModeDf _mdf;
    IStorage *_pstg;

    CModeStm _mstm;
    IStream *_pstmChild;

    ULONG _cb;
    ULONG _cBlock;
public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestSetsize2::Init(void)
{
    printf("SIFT IStream::Setsize2\n");
    _mdf.Init();
    _mstm.Init();

    _cb = 8192;
    _cBlock = 9;

    _pb = NULL;
    return(TRUE);
}

SCODE CTestSetsize2::Prep(LONG iteration)
{

    _pb = new BYTE[8192];
    memset(_pb, 'X', 8192);

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                _mstm.GetMode(),
                0,
                0,
                &_pstmChild));

        if (FAILED(_sc))
            _pstg->Release();
        else
        {
            ULARGE_INTEGER ulSize;
            ULISet32(ulSize, _cb * _cBlock);

            _sc = DfGetScode(_pstmChild->SetSize(ulSize));
            if (FAILED(_sc))
                printf("Setsize failed in Prep()\n");
            else
            {
                for (ULONG i = 0; i < _cBlock; i++)
                {
                    ULONG cbWritten;

                    _sc = DfGetScode(_pstmChild->Write(_pb, _cb, &cbWritten));
                    if (FAILED(_sc))
                        break;
                }
            }
        }
    }
    return(_sc);
}

SCODE CTestSetsize2::Call(LONG iteration)
{
    SCODE sc;

    ULARGE_INTEGER ulSize;
    ULISet32(ulSize, 2048L);

    sc = DfGetScode(_pstmChild->SetSize(ulSize));

    return(sc);
}

void CTestSetsize2::EndCall(LONG iteration)
{

    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != 2048L)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), 2048L);
    }

    LARGE_INTEGER newPos;
    ULISet32(newPos, 0);
    ULARGE_INTEGER dummy;

    _pstmChild->Seek(newPos, STREAM_SEEK_SET, &dummy);
    ULONG cbRead;

    _pstmChild->Read(_pb, 2048, &cbRead);
    if (cbRead != 2048)
    {
        printf("Unknown error - read %lu bytes, expected 2048\n");
    }
    else
    {
        for (ULONG i = 0; i < 2048; i ++)
        {
            if (_pb[i] != 'X')
            {
                printf("Error in buffer data.\n");
                break;
            }
        }
    }

}


void CTestSetsize2::CallVerify(LONG iteration)
{

    STATSTG stat;

    _pstmChild->Stat(&stat, STATFLAG_NONAME);

    if (ULIGetLow(stat.cbSize) != _cb * _cBlock)
    {
        printf("..Iteration %lu - Size of stream is %lu, expected %lu\n",
               iteration, ULIGetLow(stat.cbSize), _cb * _cBlock);
    }
    else
    {
        LARGE_INTEGER newPos;
        ULISet32(newPos, 0);
        ULARGE_INTEGER dummy;

        _pstmChild->Seek(newPos, STREAM_SEEK_SET, &dummy);

        for (ULONG i = 0; i < _cBlock; i++)
        {
            ULONG cbRead;

            _sc = DfGetScode(_pstmChild->Read(_pb, _cb, &cbRead));
            if (FAILED(_sc))
            {
                printf("Read failed with %lX\n", _sc);
                break;
            }
            if (cbRead != _cb)
            {
                printf("Read %lu bytes, expected %lu\n",cbRead,_cb);
                break;
            }
            for (ULONG j = 0; j < _cb; j++)
            {
                if (_pb[j] != 'X')
                {
                    printf("Data mismatch at byte %lu, block %lu\n",j,i);
                    break;
                }
            }
        }
    }
}

void CTestSetsize2::EndPrep(LONG iteration)
{
    delete _pb;
    _pb = NULL;

    _pstmChild->Release();
    _pstg->Release();
}

void CTestSetsize2::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestSetsize2::Next(void)
{
    if (!_mstm.Next())
    {
        _mstm.Init();
        if (!_mdf.Next())
            return(FALSE);
    }

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Class:      CTestSwitchToFile
//
//  Purpose:    Test SwitchToFile
//
//  Interface:  CTestCase
//
//  History:    18-Jun-93       PhilipLa        Created.
//
//  Notes:
//
//--------------------------------------------------------------------------

class CTestSwitchToFile : public CTestCase
{
private:
    SCODE _sc;

    CModeDf _mdf;
    IStorage *_pstg;

public:
    virtual BOOL Init(void);
    virtual SCODE Prep(LONG iteration);
    virtual SCODE Call(LONG iteration);
    virtual void EndCall(LONG iteration);
    virtual void CallVerify(LONG iteration);
    virtual void EndPrep(LONG iteration);
    virtual void EndVerify(LONG iteration);
    virtual BOOL Next(void);
};

BOOL CTestSwitchToFile::Init(void)
{
    printf("SIFT IStream::SwitchToFile\n");
    _mdf.Init();
    return(TRUE);
}

SCODE CTestSwitchToFile::Prep(LONG iteration)
{
    IStream *pstm;
    _unlink("c:\\tmp\\stf.dfl");

    _sc = CreateWorkingDocfile(_mdf.GetMode(), &_pstg, 0);
    if (SUCCEEDED(_sc))
    {
        _sc = DfGetScode(_pstg->CreateStream(
                "TestFail Stream",
                STGM_DIRECT|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
                0,
                0,
                &pstm));

        if (FAILED(_sc))
            _pstg->Release();
        else
        {
            ULARGE_INTEGER ul;

            ULISet32(ul, 80000);

            _sc = DfGetScode(pstm->SetSize(ul));
            pstm->Release();

            if (FAILED(_sc))
            {
                _pstg->Release();
            }
        }
    }
    return(_sc);
}

SCODE CTestSwitchToFile::Call(LONG iteration)
{
    SCODE sc;
    IRootStorage *pstgRoot;

    sc = DfGetScode(_pstg->QueryInterface(
            IID_IRootStorage,
            (void **)&pstgRoot));

    if (FAILED(sc))
        return sc;

    sc = DfGetScode(pstgRoot->SwitchToFile("c:\\tmp\\stf.dfl"));

    pstgRoot->Release();

    if (FAILED(sc))
        return sc;


    sc = DfGetScode(_pstg->Commit(STGC_OVERWRITE));

    if (FAILED(sc))
    {
        printf("... Commit with overwrite failed.\n");
    }
    else
    {
        printf("... Commit succeeded.\n");
    }

    return(sc);
}

void CTestSwitchToFile::EndCall(LONG iteration)
{
}


void CTestSwitchToFile::CallVerify(LONG iteration)
{
}

void CTestSwitchToFile::EndPrep(LONG iteration)
{
    _pstg->Release();
    _unlink("c:\\tmp\\stf.dfl");
}

void CTestSwitchToFile::EndVerify(LONG iteration)
{
    VerifyClean(_sc, _mdf.GetMode(), iteration);
}

BOOL CTestSwitchToFile::Next(void)
{
    do
    {
        if (!_mdf.Next())
            return FALSE;
    }
    while (((_mdf.GetMode() & 0x70) == STGM_SHARE_DENY_READ) ||
           (_mdf.GetMode() & 0x70) == STGM_SHARE_DENY_NONE);

    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   TestCount, TestItem
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Returns:
//
//  History:    26-Jan-93 AlexT     Created
//
//  Notes:
//
//--------------------------------------------------------------------------

CTestStgCreate      tstStgCreate;
CTestCreateStorage  tstCreateStorage;
CTestCreateStream   tstCreateStream;
CTestWrite          tstWrite;
CTestOpenStorage    tstOpenStorage;
CTestOpenStream     tstOpenStream;
CTestCommit         tstCommit;
CTestCommit2        tstCommit2;
CTestStgOpen        tstStgOpen;
CTestWrite2         tstWrite2;
CTestWrite3         tstWrite3;
CTestSetsize        tstSetsize;
CTestSetsize2       tstSetsize2;
CTestCreateStream2  tstCreateStream2;
CTestDestroyElement tstDestroyElement;
CTestSwitchToFile   tstSwitchToFile;
CTestCommit3        tstCommit3;
CTestCommit4        tstCommit4;

CTestCase *atst[] =
{
#if defined(BREADTHTEST)
    &tstStgCreate,
    &tstStgOpen,
    &tstCreateStorage,
    &tstCreateStream,
    &tstWrite,
    &tstCommit,
    &tstCommit2,
    &tstOpenStream,
    &tstOpenStorage,
    &tstWrite2,
    &tstWrite3,
    &tstSetsize,
    &tstCreateStream2,
    &tstDestroyElement,
    &tstSetsize2,
    &tstSwitchToFile,
    &tstCommit3,
#endif
    &tstCommit4
};

int TestCount(void)
{
    return(sizeof(atst)/sizeof(CTestCase *));
}

CTestCase *TestItem(int iTest)
{
    return(atst[iTest]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\utils\stgview\stgview.cxx ===
//+--------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:	stgview.cxx
//
//  Contents:	Storage viewer utility
//
//  History:	10-Dec-91	DrewB	Created
//
//---------------------------------------------------------------

#include <memory.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <ctype.h>

#include <windows.h>
#if WIN32 != 300
#include <storage.h>
#endif
#include <wchar.h>
#include <dfmsp.hxx>

#define FLG_RECURSIVE   0x00000001
#define FLG_STREAMS     0x00000002
#define FLG_VERBOSE     0x00000004

#define DFTOUCH

#ifdef DFTOUCH
#define CB_BUFFER   1024
#else
#define CB_BUFFER   16
#endif
BYTE    abBuffer[CB_BUFFER];

char *szTypes[] =
{
    "", "IStorage", "IStream", "ILockBytes"
};

void utMemFree(void *pv)
{
    IMalloc FAR* pMalloc;
    if (SUCCEEDED(GetScode(CoGetMalloc(MEMCTX_TASK, &pMalloc))))
    {
        pMalloc->Free(pv);
        pMalloc->Release();
    }
}

void LevSpace(int iLevel)
{
    int i;

    for (i = 0; i<iLevel; i++)
	printf("  ");
}

void PrintStat(STATSTG *psstg, ULONG flOptions, int iLevel)
{
    LevSpace(iLevel);
    if (flOptions & FLG_VERBOSE)
    {
#ifdef UNICODE
	wprintf(L"%s:%hs =>\n", psstg->pwcsName, szTypes[psstg->type]);
#else
	printf("%s:%s =>\n", psstg->pwcsName, szTypes[psstg->type]);
#endif

#ifdef FLAT
        SYSTEMTIME systime;
        struct tm stime;

	LevSpace(iLevel+1);
        if (((psstg->ctime.dwHighDateTime != 0) ||
             (psstg->ctime.dwLowDateTime != 0 )) &&
            FileTimeToSystemTime(&psstg->ctime, &systime))
        {
            stime.tm_sec   = systime.wSecond;
            stime.tm_min   = systime.wMinute;
            stime.tm_hour  = systime.wHour;
            stime.tm_mday  = systime.wDay;
            stime.tm_mon   = systime.wMonth - 1;
            stime.tm_year  = systime.wYear - 1900;
            stime.tm_wday  = systime.wDayOfWeek;
            stime.tm_yday  = 0;
            stime.tm_isdst = 0;

	    printf("Created : %s", asctime(&stime));
        }
        else
	   printf("Created : %lx %lx (conversion unavailable)\n",
		  psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);

	LevSpace(iLevel+1);
        if (((psstg->mtime.dwHighDateTime != 0) ||
             (psstg->mtime.dwLowDateTime != 0 )) &&
            FileTimeToSystemTime(&psstg->mtime, &systime))
        {
            stime.tm_sec   = systime.wSecond;
            stime.tm_min   = systime.wMinute;
            stime.tm_hour  = systime.wHour;
            stime.tm_mday  = systime.wDay;
            stime.tm_mon   = systime.wMonth - 1;
            stime.tm_year  = systime.wYear - 1900;
            stime.tm_wday  = systime.wDayOfWeek;
            stime.tm_yday  = 0;
            stime.tm_isdst = 0;

	    printf("Modified : %s", asctime(&stime));
        }
        else
	    printf("Modified : %lx %lx (conversion unavailable)\n",
	           psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);

	LevSpace(iLevel+1);
        if (((psstg->atime.dwHighDateTime != 0) ||
             (psstg->atime.dwLowDateTime != 0 )) &&
            FileTimeToSystemTime(&psstg->mtime, &systime))
        {
            stime.tm_sec   = systime.wSecond;
            stime.tm_min   = systime.wMinute;
            stime.tm_hour  = systime.wHour;
            stime.tm_mday  = systime.wDay;
            stime.tm_mon   = systime.wMonth - 1;
            stime.tm_year  = systime.wYear - 1900;
            stime.tm_wday  = systime.wDayOfWeek;
            stime.tm_yday  = 0;
            stime.tm_isdst = 0;

	    printf("Accessed : %s", asctime(&stime));
        }
        else
	    printf("Accessed : %lx %lx (conversion unavailable)\n",
	           psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);
#else
	LevSpace(iLevel+1);
	printf("Created : %lx %lx (conversion unavailable)\n",
	       psstg->ctime.dwHighDateTime, psstg->ctime.dwLowDateTime);
	LevSpace(iLevel+1);
	printf("Modified : %lx %lx (conversion unavailable)\n",
	       psstg->mtime.dwHighDateTime, psstg->mtime.dwLowDateTime);
	LevSpace(iLevel+1);
	printf("Accessed : %lx %lx (conversion unavailable)\n",
	       psstg->atime.dwHighDateTime, psstg->atime.dwLowDateTime);
#endif

	if (psstg->type == STGTY_STREAM || psstg->type == STGTY_LOCKBYTES)
	{
	    LevSpace(iLevel+1);
	    printf("Size: %lu:%lu\n", ULIGetHigh(psstg->cbSize),
		   ULIGetLow(psstg->cbSize));
	}
    }
    else
#ifdef UNICODE
	wprintf(L"%s\n", psstg->pwcsName);
#else
	printf("%s\n", psstg->pwcsName);
#endif
}

// ctype doesn't work properly
#define dfisprint(c) ((c) >= ' ' && (c) < 127)

void Stream(IStream *pstm, ULONG flOptions, int iLevel)
{
    ULONG   cbRead;
#ifdef DFTOUCH
    ULONG   cbTotal = 0;
#endif
    SCODE   sc;

    sc = GetScode(pstm->Read(abBuffer, CB_BUFFER, &cbRead));
    while (SUCCEEDED(sc) && (cbRead > 0))
    {
        LevSpace(iLevel);
#ifdef DFTOUCH
	cbTotal += cbRead;
	printf("Read %lu bytes\n", cbTotal);
#else
        for (ULONG ib = 0; ib < cbRead; ib++)
        {
            printf("%.2X", (int)abBuffer[ib]);
        }
        for (ib = ib; ib < CB_BUFFER + 1; ib++)
        {
            printf("  ");
        }

        for (ib = 0; ib < cbRead; ib++)
        {
            printf("%c", dfisprint(abBuffer[ib]) ? abBuffer[ib] : '.');
        }
        printf("\n");
#endif

        sc = GetScode(pstm->Read(abBuffer, CB_BUFFER, &cbRead));
    }
    if (FAILED(sc))
	printf("Read failed with 0x%lX\n", sc);
}

void Contents(IStorage *pdf, ULONG flOptions, int iLevel)
{
    IEnumSTATSTG *pdfi;
    SCODE sc;
    IStorage *pdfChild;
    IStream  *pstmChild;
    STATSTG sstg;

    if (FAILED(pdf->EnumElements(0, NULL, 0, &pdfi)))
    {
	fprintf(stderr, "Unable to create iterator\n");
	return;
    }
    for (;;)
    {
	sc = GetScode(pdfi->Next(1, &sstg, NULL));
	if (sc != S_OK)
	    break;
	PrintStat(&sstg, flOptions, iLevel);
	if ((sstg.type == STGTY_STORAGE) && (flOptions & FLG_RECURSIVE))
	{
	    if (SUCCEEDED(pdf->OpenStorage(sstg.pwcsName, NULL,
					   STGM_READ | STGM_SHARE_EXCLUSIVE,
					   NULL, 0, &pdfChild)))
	    {
		Contents(pdfChild, flOptions, iLevel+1);
		pdfChild->Release();
	    }
	    else
		fprintf(stderr, "%s: Unable to recurse\n", sstg.pwcsName);
	}
        else
        if ((sstg.type == STGTY_STREAM) && (flOptions & FLG_STREAMS))
        {
            if (SUCCEEDED(pdf->OpenStream(sstg.pwcsName, NULL,
                                          STGM_READ | STGM_SHARE_EXCLUSIVE,
                                          0, &pstmChild)))
            {
                Stream(pstmChild, flOptions, iLevel+1);
                pstmChild->Release();
            }
            else
                fprintf(stderr, "%s: Unable to open\n", sstg.pwcsName);
        }
	utMemFree(sstg.pwcsName);
    }
    pdfi->Release();
    if (FAILED(sc))
	printf("Enumeration failed with 0x%lX\n", sc);
}

void Descend(IStorage *pdf, char *pszPath, IStorage **ppdf)
{
    IStorage   *pdfNext;
    char       *pszNext = pszPath;
    char       *pszEnd  = strchr(pszNext, '\\');
    TCHAR atcName[CWCSTORAGENAME];

    while (pszNext != NULL)
    {
        if (pszEnd != NULL)
        {
            *pszEnd = '\0';
        }

#ifdef UNICODE
        if (mbstowcs(atcName, pszNext, CWCSTORAGENAME) == (size_t)-1)
        {
            pdf = NULL;

            fprintf(stderr, "Unable to convert '%s' to Unicode\n", pszNext);
            break;
        }
#else
        strcpy(atcName, pszNext);
#endif
        if (SUCCEEDED(pdf->OpenStorage(atcName, NULL,
                                       STGM_READ | STGM_SHARE_EXCLUSIVE,
                                       NULL, 0, &pdfNext)))
        {
            pdf = pdfNext;

            if (pszEnd != NULL)
            {
                *pszEnd = '\\';

                pszNext = pszEnd + 1;
                pszEnd  = strchr(pszNext, '\\');
            }
            else
            {
                pszNext = NULL;
            }
        }
        else
        {
            pdf = NULL;

            fprintf(stderr, "Unable to open '%s' in docfile\n", pszPath);
            break;
        }
    }

    *ppdf = pdf;
}

void __cdecl main(int argc, char **argv)
{
    ULONG flOptions = 0;
    IStorage *pdf;
    IStorage *pdfRoot;
    STATSTG sstg;

    argc--;
    argv++;
    while ((argc > 0) && ((*argv)[0] == '-'))
    {
        for (int ich = 1; (*argv)[ich] != '\0'; ich++)
        {
            switch((*argv)[ich])
            {
            case 's':
                flOptions |= FLG_STREAMS;
                break;
            case 'v':
                flOptions |= FLG_VERBOSE;
                break;
            case 'r':
                flOptions |= FLG_RECURSIVE;
                break;
            default:
                fprintf(stderr, "Unknown switch '%c'\n", (*argv)[ich]);
                break;
            }
        }

        argc--;
        argv++;
    }

    if ((argc != 1) && (argc != 2))
    {
	printf("Usage: stgview [-v] [-s] [-r] docfile [path]\n");
	exit(1);
    }

    SCODE sc;

#if WIN32 == 300
    if (FAILED(sc = GetScode(CoInitializeEx(NULL, COINIT_MULTITHREADED))))
#else
    if (FAILED(sc = GetScode(CoInitialize(NULL))))
#endif
    {
        fprintf(stderr, "CoInitialize failed with sc = %lx\n", sc);
        exit(1);
    }

    TCHAR atcName[_MAX_PATH];
#ifdef UNICODE
    if (mbstowcs(atcName, *argv, _MAX_PATH) == (size_t)-1)
    {
        fprintf(stderr, "Unable to convert '%s' to Unicode\n", *argv);
        exit(1);
    }
#else
    strcpy(atcName, *argv);
#endif
    if (FAILED(StgOpenStorage(atcName, NULL, STGM_READ | STGM_SHARE_DENY_WRITE,
			      NULL, 0, &pdf)))
    {
	fprintf(stderr, "Unable to open '%s'\n", *argv);
	exit(1);
    }
    else
    {
        if (argc == 2)
        {
            Descend(pdf, *(argv + 1), &pdfRoot);
        }
        else
        {
            pdf->AddRef();
            pdfRoot = pdf;
        }

        if (pdfRoot != NULL)
        {
            if (FAILED(pdfRoot->Stat(&sstg, 0)))
                fprintf(stderr, "Unable to stat root\n");
            else
            {
                PrintStat(&sstg, flOptions, 0);
                utMemFree(sstg.pwcsName);
            }
            Contents(pdfRoot, flOptions, 1);
            pdfRoot->Release();
        }
	pdf->Release();
    }

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcscmp.c ===
/***
*wcscmp.c - routine to compare 2 wide character strings (equal/less/greater)
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*       Compares two wide character strings, determining their lexical order.
*
*Revision History:
*       04-07-91  IanJa C version created.
*
*******************************************************************************/

#include <stdlib.h>

/***
*wcscmp - compare two wide character strings, returning less than, equal to,
*       or greater than
*
*Purpose:
*       WCSCMP compares two wide character strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done byte by byte on an UNSIGNED basis, which is to
*       say that Null (0) is less than any other character (1-0xffff).
*
*Entry:
*       const wchar_t * src - string for left-hand side of comparison
*       const wchar_t * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcscmp(const wchar_t * src, const wchar_t * dst)
{
        int ret = 0 ;

        while( ! (ret = *src - *dst) && *dst)
                ++src, ++dst;

        if ( ret < 0 )
                ret = -1 ;
        else if ( ret > 0 )
                ret = 1 ;

        return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcslen.c ===
/***
*wcslen.c - contains wcslen() routine
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All Rights Reserved.
*
*Purpose:
*       wcslen returns the length of a null-terminated string in number of
*       wide characters, not including the null wide character itself.
*
*Revision History:
*       04-07-91  IanJa C version created.
*
*******************************************************************************/

#include <stdlib.h>

/***
*wcslen - return the length of a null-terminated string
*
*Purpose:
*       Finds the number of wide characters in the given wide character
*       string, not including the final null character.
*
*Entry:
*       const wchat_t * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null wide character
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl wcslen(const wchar_t * str)
{
    wchar_t *string = (wchar_t *) str;

    while( *string )
            string++;

    return string - str;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcsicmp.c ===
/***
*wcsicmp.c - compares two wide character strings with case insensitivity
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcsicmp() - compares two wide character strings for lexical
*       order with case insensitivity.
*
*Revision History:
*       11-Mar-92   CarlH       Created.
*
*******************************************************************************/


#include <stdlib.h>


/***
*wchar_t wcUp(wc) - upper case wide character
*
*Notes:
*       This was copied from AlexT's version of wcsnicmp.c from the Win4
*       common project.
*/

static wchar_t wcUp(wchar_t wc)
{
    if ('a' <= wc && wc <= 'z')
        wc += (wchar_t)('A' - 'a');

    return(wc);
}


/***
*wcsicmp - compare two wide character strings with case insensitivity,
*       returning less than, equal to, or greater than
*
*Purpose:
*       WCSICMP compares two wide character strings with case insensitivity
*       and returns an integer to indicate whether the first is less than
*       the second, the two are equal, or whether the first is greater than
*       the second.
*
*       Comparison is done byte by byte on an UNSIGNED basis with lower to
*       upper case mapping by wcUp.  Null (0) is less than any other
*       character (1-0xffff).
*
*Entry:
*       const wchar_t * src - string for left-hand side of comparison
*       const wchar_t * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsicmp(const wchar_t * src, const wchar_t * dst)
{
        int ret = 0 ;

        while( ! (ret = wcUp(*src) - wcUp(*dst)) && *dst)
                ++src, ++dst;

        if ( ret < 0 )
                ret = -1 ;
        else if ( ret > 0 )
                ret = 1 ;

        return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcscpy.c ===
/***
*wcscpy.c - contains wcscpy()
*
*       Copyright (c) 1985-1988, Microsoft Corporation. All Rights Reserved.
*
*Purpose:
*       wcscpy() copies one wide character string onto another.
*
*Revision History:
*       04-07-91  IanJa C version created.
*
*******************************************************************************/

#include <stdlib.h>

/***
*wchar_t *wcscpy(dst, src) - copy one wide character string over another
*
*Purpose:
*       Copies the wide character string src into the spot specified by
*       dest; assumes enough room.
*
*Entry:
*       wchar_t * dst - wide character string over which "src" is to be copied
*       const wchar_t * src - string to be copied over "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*******************************************************************************/

wchar_t * __cdecl wcscpy(wchar_t * dst, const wchar_t * src)
{
    wchar_t * cp = dst;

    while( *cp++ = *src++ )
            ;               /* Copy src over dst */

    return dst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcsnicmp.c ===
/***
*wcsnicmp.c - compare first n characters of two wide character strings with
*             case insensitivity
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcsnicmp() - compare first n characters of two wide character
*       strings for lexical order with case insensitivity.
*
*Revision History:
*       04-07-91  IanJa C version created.
*               11-25-91  AlexT Modified from wcsncmp.c
*               04-Mar-92 ChrisMay fixed signed/unsigned warning in wcUP()
*               12-Mar-92 Fixed bug in wcsnicmp (used to  return *first - *last)
*
*******************************************************************************/

#include <stdlib.h>
/***
*wchar_t wcUp(wc) - upper case wide character
*
*/

#define wcUp(wc) (('a' <= (wchar_t) (wc) && (wchar_t) (wc) <= 'z') ? \
                  (wchar_t) (wc) + (wchar_t)('A' - 'a') : (wchar_t) (wc))

/***
*int wcsnicmp(first, last, count) - compare first count wide characters of wide
*       character strings with case insensitivity.
*
*Purpose:
*       Compares two wide character strings for lexical order.  The comparison
*       stops after: (1) a difference between the strings is found, (2) the end
*       of the strings is reached, or (3) count characters have been
*       compared.
*
*Entry:
*       char *first, *last - wide character strings to compare
*       unsigned count - maximum number of wide characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns  0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsnicmp(const wchar_t * first, const wchar_t * last, size_t count)
{
      if (!count)
              return 0;

      while (--count && *first && wcUp(*first) == wcUp(*last))
              {
              first++;
              last++;
              }

      return wcUp(*first) - wcUp(*last);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcsncmp.c ===
/***
*wcsncmp.c - compare first n characters of two wide character strings
*
*       Copyright (c) 1985-1988, Microsoft Corporation.  All rights reserved.
*
*Purpose:
*       defines wcsncmp() - compare first n characters of two wide character
*       strings for lexical order.
*
*Revision History:
*       04-07-91  IanJa C version created.
*
*******************************************************************************/

#include <stdlib.h>

/***
*int wcsncmp(first, last, count) - compare first count wide characters of wide
*       character strings
*
*Purpose:
*       Compares two wide character strings for lexical order.  The comparison
*       stops after: (1) a difference between the strings is found, (2) the end
*       of the strings is reached, or (3) count characters have been
*       compared.
*
*Entry:
*       char *first, *last - wide character strings to compare
*       unsigned count - maximum number of wide characters to compare
*
*Exit:
*       returns <0 if first < last
*       returns  0 if first == last
*       returns >0 if first > last
*
*Exceptions:
*
*******************************************************************************/

int __cdecl wcsncmp(const wchar_t * first, const wchar_t * last, size_t count)
{
      if (!count)
              return 0;

      while (--count && *first && *first == *last)
              {
              first++;
              last++;
              }

      return *first - *last;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcsrchr.c ===
//+---------------------------------------------------------------------------
//
//  File:       wcsrchr.c
//
//  Contents:   This file contains the src for the wcsrchr() function.
//
//  Classes:    none
//
//  History:    09-Oct-91   chrismay    created
//
//----------------------------------------------------------------------------

#include <stddef.h>
#include <stdlib.h>

//+---------------------------------------------------------------------------
//
//  Function:   wcsrchr()
//
//  Synopsis:   This function finds the last occurrence of the specified wide
//              character in a wide-character string.
//
//  Arguments:  wsz - wide character string, zero terminated
//              wc - wide character to be found in wsz
//
//  Returns:    returns a pointer to the beginning of the substring that
//              begins with the last occurrence of the character if found,
//              else returns NULL.
//
//  Warnings:   only works on wide-character ASCII
//
//  History:    15-Oct-91   chrismay    created
//
//----------------------------------------------------------------------------

wchar_t *__cdecl wcsrchr(const wchar_t *wcs, wchar_t wc)
{
      wchar_t *start = (wchar_t *)wcs;

      while (*wcs++)                         /* find end of string */
              ;
                                                /* search towards front */
      while (--wcs != start && *wcs != wc)
              ;

      if (*wcs == wc)                        /* character found ? */
              return (wchar_t *)wcs;
      return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\cairo.inc ===
# This is the global include file for the cairo version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=300           \
              -D_CAIRO_=300         \
              -DUNICODE             \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
	      -DCAIROLE_DISTRIBUTED \
	      -DMULTI_THREADING     \
              $(TRACELOG)

# For the Cairo build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\chicago.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=200           \
              -D_CHICAGO_=200       \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              -DMULTI_THREADING     \
              -D_WIN32_DCOM         \
              $(TRACELOG)

# For the Chicago project, we do not want to use CRTDLL.DLL, so leave this
# line commented out.
#
#

USE_LIBCMT=   1

CHICAGO_PRODUCT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\daytona.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
	      -DCAIROLE_DOWNLEVEL   \
	      -DMULTI_THREADING     \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\accctrl\client\chicago\makefile.inc ===
DEST_TREE=chicago

!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\accctrl\server\chicago\makefile.inc ===
DEST_TREE=chicago

!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\accctrl\server\daytona\makefile.inc ===
DEST_TREE=chicago

!include ..\makeidl.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\wclib\wcstr.h ===
/***
* wcstr.h - declarations for wide character string manipulation functions
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the function declarations for the string
*       manipulation functions.
*       [UNICODE/ISO]
*
****/

#ifndef _INC_WCSTR

#include <stdlib.h>

long     __cdecl wcsatol(const wchar_t *string);
int      __cdecl wcsatoi(const wchar_t *string);
wchar_t *__cdecl wcscat(wchar_t *string1, const wchar_t *string2);
wchar_t *__cdecl wcschr(const wchar_t *string1, wchar_t character);
int      __cdecl wcscmp(const wchar_t *string1, const wchar_t *string2);
int      __cdecl wcsicmp(const wchar_t *string1, const wchar_t *string2);
wchar_t *__cdecl wcscpy(wchar_t *string1, const wchar_t *string2);
size_t   __cdecl wcscspn(const wchar_t *string1, const wchar_t *string2);
wchar_t *__cdecl wcsitoa(int ival, wchar_t *string, int radix);
size_t   __cdecl wcslen(const wchar_t *string);
wchar_t *__cdecl wcsltoa(long lval, wchar_t *string, int radix);
wchar_t *__cdecl wcsncat(wchar_t *string1, const wchar_t *string2, size_t count);
int      __cdecl wcsncmp(const wchar_t *string1, const wchar_t *string2, size_t count);
int      __cdecl wcsnicmp(const wchar_t *string1, const wchar_t *string2, size_t count);
wchar_t *__cdecl wcsncpy(wchar_t *string1, const wchar_t *string2, size_t count);
wchar_t *__cdecl wcspbrk(const wchar_t *string1, const wchar_t *string2);
wchar_t *__cdecl wcsrchr(const wchar_t *string, wchar_t character);
size_t   __cdecl wcsspn(const wchar_t *string1, const wchar_t *string2);
wchar_t *__cdecl wcswcs(const wchar_t *string1, const wchar_t *string2);
int      __cdecl wcstomb(char *string, wchar_t character);
size_t   __cdecl wcstombs(char *dest, const wchar_t *string, size_t count);

int      __cdecl wcscoll(const wchar_t *wsz1, const wchar_t *wsz2);
wchar_t *__cdecl wcslwr(wchar_t *wsz);
wchar_t *__cdecl wcsupr(wchar_t *wsz);

#define _INC_WCSTR

#endif  /* _INC_WCSTR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\accctrl\client\oactestc.cxx ===
/****************************************************************************

  File: actestc.cxx
  Description: Client side of the DCOM IAccessControl test program.

****************************************************************************/


#include <windows.h>
#include <ole2.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <accctrl.h>
#include "oactest.h"
#include <oleext.h>
#include <rpcdce.h>

/* Internal program parameters */
#define BIG_BUFFER       2048
#define LINE_BUFF_SIZE 200
#define MAX_TOKENS_NUM 20
#define STR_LEN 100


// Define some bogus access masks so that we can verify the
// the validation mechanism of DCOM IAccessControl

#define BOGUS_ACCESS_RIGHT1 (COM_RIGHTS_EXECUTE*2)
#define BOGUS_ACCESS_RIGHT2 (COM_RIGHTS_EXECUTE*4)
#define BOGUS_ACCESS_RIGHT3 (COM_RIGHTS_EXECUTE*8)
#define BOGUS_ACCESS_RIGHT4 (COM_RIGHTS_EXECUTE*16)


// The following structure encapsulates all kinds of information that
// can be associated with a trustee.
typedef struct tagTRUSTEE_RECORD
{
  DWORD                         grfAccessPermissions;
  ACCESS_MODE                   grfAccessMode;
  DWORD                         grfInheritance;
  PTRUSTEE_W                    pMultipleTrustee;
  MULTIPLE_TRUSTEE_OPERATION    MultipleTrusteeOperation;
  TRUSTEE_FORM                  TrusteeForm;
  TRUSTEE_TYPE                  TrusteeType;
  LPWSTR                        pwszTrusteeName;
  PISID                         pSID;
} TRUSTEE_RECORD;


/* Global variables */
char pszUserName[STR_LEN];            // User Name
char pszBasePath[STR_LEN];
char pszResource[STR_LEN];            // Resource location
EXPLICIT_ACCESS_W   g_pLocalExplicitAccessList[100];
ULONG               g_ulNumOfLocalExplicitAccesses = 0;
ACCESS_REQUEST_W    g_pLocalAccessRequestList[100];
ULONG               g_ulNumOfLocalAccessRequests = 0;
PEXPLICIT_ACCESS_W  g_pReturnedExplicitAccessList = NULL;
ULONG               g_ulNumOfExplicitAccessesReturned = 0;
TRUSTEE_W           g_pLocalTrusteeList[100];
ULONG               g_ulNumOfLocalTrustees = 0;
TRUSTEE_RECORD      g_LocalTrusteeRecord;
IAccessControlTest  *g_pIAccessControlTest;
IUnknown            *g_pIUnknown;

const CLSID CLSID_COAccessControlTest
    = {0x20692b00,0xe710,0x11cf,{0xaf,0x0b,0x00,0xaa,0x00,0x44,0xfb,0x89}};

/* Internal function prototyoes */
void Tokenize(char *, char *[], short *);
void stringtolower(char *);
PISID GetSIDForTrustee(LPWSTR);
void AddTrusteeToExplicitAccessList(TRUSTEE_RECORD *, PEXPLICIT_ACCESS_W, ULONG *);
void DeleteTrusteeFromExplicitAccessList(ULONG, PEXPLICIT_ACCESS_W, ULONG *);
void AddTrusteeToAccessRequestList(TRUSTEE_RECORD *, PACCESS_REQUEST_W, ULONG *);
void DeleteTrusteeFromAccessRequestList(ULONG, PACCESS_REQUEST_W, ULONG *);
void MapTrusteeRecordToTrustee(TRUSTEE_RECORD *, TRUSTEE_W *);
void AddTrusteeToTrusteeList(TRUSTEE_RECORD *, TRUSTEE_W *, ULONG *);
void DeleteTrusteeFromTrusteeList(ULONG, TRUSTEE_W *, ULONG *);
void DestroyAccessRequestList(PACCESS_REQUEST_W, ULONG *);
void DestroyTrusteeList(TRUSTEE_W *, ULONG *);
void DestroyExplicitAccessList(PEXPLICIT_ACCESS_W, ULONG *);
void PrintEnvironment(void);
void DumpTrusteeRecord(TRUSTEE_RECORD *);
void DumpAccessRequestList(ULONG, ACCESS_REQUEST_W []);
void DumpExplicitAccessList(ULONG, EXPLICIT_ACCESS_W []);
void DumpAccessPermissions(DWORD);
DWORD StringToAccessPermission(CHAR *);
void DumpAccessMode(ACCESS_MODE);
void DumpTrusteeList(ULONG, TRUSTEE_W []);
void DumpTrustee(TRUSTEE_W *);
void DumpMultipleTrusteeOperation(MULTIPLE_TRUSTEE_OPERATION);
MULTIPLE_TRUSTEE_OPERATION StringToMultipleTrusteeOperation(CHAR *);
void DumpTrusteeType(TRUSTEE_TYPE);
TRUSTEE_TYPE StringToTrusteeType(CHAR *);
void DumpTrusteeForm(TRUSTEE_FORM);
TRUSTEE_FORM StringToTrusteeForm(CHAR *);
void DumpSID(PISID);
ACCESS_MODE StringToAccessMode(CHAR *);
void DumpInheritance(DWORD);
DWORD StringToInheritance(CHAR *);
void ReleaseExplicitAccessList(ULONG, PEXPLICIT_ACCESS_W);
void CopyExplicitAccessList(PEXPLICIT_ACCESS_W, PEXPLICIT_ACCESS_W, ULONG *, ULONG);
void ExecTestServer(CHAR *);
void ExecRevertAccessRights(void);
void ExecCommitAccessRights(void);
void ExecGetClassID(void);
void ExecInitNewACL(void);
void ExecLoadACL(CHAR *);
void ExecSaveACL(CHAR *);
void ExecGetSizeMax(void);
void ExecIsDirty(void);
void ExecGrantAccessRights(void);
void ExecSetAccessRights(void);
void ExecDenyAccessRights(void);
void ExecReplaceAllAccessRights(void);
void ExecRevokeExplicitAccessRights(void);
void ExecIsAccessPermitted(void);
void ExecGetEffectiveAccessRights(void);
void ExecGetExplicitAccessRights(void);
void ExecCleanupProc();


void Usage(char * pszProgramName)
{
    printf("Usage:  %s\n", pszProgramName);
    printf(" -m remote_server_name\n");
    exit(1);
}


void stringtolower
(
char *pszString
)
{
    char c;

    while(c = *pszString)
    {
        if(c <= 'Z' && c >= 'A')
        {
            *pszString = c - 'A' + 'a';
        }
        pszString++;
    }
} // stringtolower


void __cdecl main(int argc, char **argv)
{
    RPC_STATUS status;
    unsigned long ulCode;
    WCHAR                      DummyChar;
    int                       i;
    char                      aLineBuff[LINE_BUFF_SIZE];
    char                      *aTokens[MAX_TOKENS_NUM];
    short                     iNumOfTokens;
    SEC_WINNT_AUTH_IDENTITY_A auth_id;
    UCHAR                     uname[STR_LEN];
    UCHAR                     domain[STR_LEN];
    UCHAR                     password[STR_LEN];
    TRUSTEE_W                 DummyMultipleTrustee;
    ULONG                     ulStrLen;
    DWORD                     dwAccessPermission;
    BOOL                      biBatchMode = FALSE;
    HRESULT                   hr;
    OLECHAR                   pwszRemoteServer[1024];
    DWORD                     dwStrLen;

    /* allow the user to override settings with command line switches */
    for (i = 1; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/')) {
            switch (tolower(*(argv[i]+1))) {
            case 'm':  // remote server name
                dwStrLen = MultiByteToWideChar( CP_ACP
                                              , NULL
                                              , argv[++i]
                                              , -1
                                              , pwszRemoteServer
                                              , 1024);
                break;
            case 'b':
                biBatchMode = TRUE;
                break;
            case 'h':
            case '?':
            default:
                Usage(argv[0]);
            }
        }
        else
            Usage(argv[0]);
    }

    // Initialize the testing environment

    aTokens[0] = aLineBuff;

    g_LocalTrusteeRecord.grfAccessPermissions = 0;
    g_LocalTrusteeRecord.grfAccessMode = GRANT_ACCESS;
    g_LocalTrusteeRecord.grfInheritance = NO_INHERITANCE;
    g_LocalTrusteeRecord.pMultipleTrustee = NULL;
    g_LocalTrusteeRecord.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
    g_LocalTrusteeRecord.TrusteeForm = TRUSTEE_IS_NAME;
    g_LocalTrusteeRecord.TrusteeType = TRUSTEE_IS_USER;
    g_LocalTrusteeRecord.pwszTrusteeName = NULL;
    g_LocalTrusteeRecord.pSID = NULL;




    auth_id.User = uname;
    auth_id.Domain = domain;
    auth_id.Password = password;
    auth_id.Flags = 0x01; // ANSI

    // Call CoInitialize to initialize the com library
    hr = CoInitialize(NULL);

    if(FAILED(hr))
    {
        printf("Failed to initialize the COM library.");
        exit(hr);
    } // if

    // Call CoInitializeSecurity
    hr = CoInitializeSecurity( NULL
                             , -1
                             , NULL
                             , NULL
                             , RPC_C_AUTHN_LEVEL_CONNECT
                             , RPC_C_IMP_LEVEL_IMPERSONATE
                             , NULL
                             , EOAC_NONE
                             , NULL );


    if(FAILED(hr))
    {
        printf("Failed to initialize the COM call security layer.\n");
        exit(hr);
    }

    MULTI_QI MultiQI;

    MultiQI.pIID = &IID_IUnknown;
    MultiQI.pItf = NULL;

    COSERVERINFO ServerInfo;
    ServerInfo.pwszName = pwszRemoteServer;
    ServerInfo.pAuthInfo = NULL;
    ServerInfo.dwReserved1 = 0;
    ServerInfo.dwReserved2 = 0;
    // Call CoCreateInstance to create an access control test
    // object
    hr = CoCreateInstanceEx( CLSID_COAccessControlTest
                           , NULL
                           , CLSCTX_REMOTE_SERVER
                           , &ServerInfo
                           , 1
                           , &MultiQI);

    if(FAILED(hr))
    {
        printf("CoCreateInstance failed with exit code %x.\n", hr);
        exit(hr);
    }
    hr = MultiQI.hr;
    g_pIUnknown = (IUnknown *)MultiQI.pItf;

    if(FAILED(hr))
    {
        printf("Failed to create an instance of the access control test object.\n");
        exit(hr);
    }

    hr = g_pIUnknown->QueryInterface(IID_IAccessControlTest, (void **)&g_pIAccessControlTest);

    if(FAILED(hr))
    {
        printf("Failed to query for the IAccessControlTest interface.\n");
        exit(hr);
    }
    printf("\n");
    PrintEnvironment();


    printf("\n");


    /* Entering the interactive command loop */


    for(;;)
    {

        // Print out prompt
        if (!biBatchMode)
        {
            printf("Command>");
        }

        memset(aLineBuff, 0, LINE_BUFF_SIZE);

        // Read input form user
        gets(aLineBuff);

        if (biBatchMode)
        {
            printf("%s\n",aLineBuff);
        }

        Tokenize(aLineBuff,aTokens,&iNumOfTokens);

        // Process the tokens
        stringtolower(aTokens[0]);

        // Decode and execute command
        // Ignore comments
          if (iNumOfTokens == 0)
          {
            continue;
          }
          if (*aTokens[0] == '#')
          {
            continue;
          }
          printf("\n");
          if (strcmp(aTokens[0],"quit") == 0)
          {
            printf("Exit.\n");
            ExecCleanupProc();
            break;
          }
          else if (strcmp(aTokens[0],"exit") == 0)
          {
            printf("Exit.\n");
            ExecCleanupProc();
            break;
          }
          else if (strcmp(aTokens[0],"sleep") == 0)
          {
            printf("Sleep for %s milliseconds", aTokens[1]);
            Sleep(atoi(aTokens[1]));
          }
          else if (strcmp(aTokens[0], "testserver") == 0)
          {
            g_pIAccessControlTest->TestServer(aTokens[1]);
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0],"switchclientctx") == 0)
          {

            printf("User:");
            gets((CHAR *)uname);
            printf("Domain:");
            gets((CHAR *)domain);
            printf("Password:");
            gets((CHAR *)password);

            auth_id.UserLength = strlen((CHAR *)uname);
            auth_id.DomainLength = strlen((CHAR *)domain);
            auth_id.PasswordLength = strlen((CHAR *)password);
            auth_id.Flags = 0x1;

            /* Set authentication info so that the server is triggered */
            /* to cache group info for the client from the domain server */
            hr = CoSetProxyBlanket( g_pIAccessControlTest
                                  , RPC_C_AUTHN_WINNT
                                  , RPC_C_AUTHZ_NONE
                                  , NULL
                                  , RPC_C_AUTHN_LEVEL_CONNECT
                                  , RPC_C_IMP_LEVEL_IMPERSONATE
                                  , &auth_id
                                  , EOAC_NONE );

            printf("CoSetProxyBlanket returned %x\n", hr);
            if (FAILED(hr))
            {
              exit(hr);
            }
          }
          else if (strcmp(aTokens[0],"toggleaccessperm") == 0)
          {
            stringtolower(aTokens[1]);
            dwAccessPermission = StringToAccessPermission(aTokens[1]);
            if (g_LocalTrusteeRecord.grfAccessPermissions & dwAccessPermission)
            {
              g_LocalTrusteeRecord.grfAccessPermissions &= ~dwAccessPermission;
            }
            else
            {
              g_LocalTrusteeRecord.grfAccessPermissions |= dwAccessPermission;
            }
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0],"set") == 0)
          {
            stringtolower(aTokens[1]);

            if (strcmp(aTokens[1],"trusteename") == 0)
            {

                // The old SID in the global trustee record will no longer valid so we
                // may as well release it to avoid confusion
                if (g_LocalTrusteeRecord.pSID != NULL)
                {
                    midl_user_free(g_LocalTrusteeRecord.pSID);
                    g_LocalTrusteeRecord.pSID = NULL;
                }

                if (g_LocalTrusteeRecord.pwszTrusteeName != NULL)
                {
                    midl_user_free(g_LocalTrusteeRecord.pwszTrusteeName);
                }
                ulStrLen = MultiByteToWideChar( CP_ACP
                                              , 0
                                              , aTokens[2]
                                              , -1
                                              , &DummyChar
                                              , 0 );
                g_LocalTrusteeRecord.pwszTrusteeName = (LPWSTR)midl_user_allocate(sizeof(WCHAR) * (ulStrLen+1));

                MultiByteToWideChar( CP_ACP
                                   , 0
                                   , aTokens[2]
                                   , ulStrLen + 1
                                   , g_LocalTrusteeRecord.pwszTrusteeName
                                   , ulStrLen + 1);

                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessmode") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.grfAccessMode = StringToAccessMode(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "inheritance") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.grfInheritance = StringToInheritance(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "multipletrustee") == 0)
            {
                stringtolower(aTokens[2]);
                if (strcmp(aTokens[2], "null") == 0)
                {
                    g_LocalTrusteeRecord.pMultipleTrustee = NULL;
                }
                else
                {
                    g_LocalTrusteeRecord.pMultipleTrustee = &DummyMultipleTrustee;
                }
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "multipletrusteeoperation") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.MultipleTrusteeOperation = StringToMultipleTrusteeOperation(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteeform") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.TrusteeForm = StringToTrusteeForm(aTokens[2]);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteetype") == 0)
            {
                stringtolower(aTokens[2]);
                g_LocalTrusteeRecord.TrusteeType = StringToTrusteeType(aTokens[2]);
                printf("Done.\n");
            }
            else
            {
              printf("Invalid environment variable.\n");
            } // if
          }
          else if (strcmp(aTokens[0], "getsidforcurrenttrustee") == 0)
          {
            g_LocalTrusteeRecord.pSID = GetSIDForTrustee(g_LocalTrusteeRecord.pwszTrusteeName);
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0], "addtrustee") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "explicitaccesslist") == 0)
            {
                AddTrusteeToExplicitAccessList(&g_LocalTrusteeRecord, g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessrequestlist") == 0)
            {
                AddTrusteeToAccessRequestList(&g_LocalTrusteeRecord, g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteelist") == 0)
            {
                AddTrusteeToTrusteeList(&g_LocalTrusteeRecord, g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
                printf("Done.\n");
            }
            else
            {
                printf("Unknown list type.\n");
            }
          }
          else if (strcmp(aTokens[0], "deletetrustee") == 0)
          {
            stringtolower(aTokens[2]);
            if (strcmp(aTokens[2], "localexplicitaccesslist") == 0)
            {
                DeleteTrusteeFromExplicitAccessList(atoi(aTokens[1]), g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[2], "accessrequestlist") == 0)
            {
                DeleteTrusteeFromAccessRequestList(atoi(aTokens[1]), g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[2], "trusteelist") == 0)
            {
                DeleteTrusteeFromTrusteeList(atoi(aTokens[1]), g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
                printf("Done.\n");
            }
            else
            {
                printf("Unknown list type.\n");
            }
          }
          else if (strcmp(aTokens[0], "destroy") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "localexplicitaccesslist") == 0)
            {
                DestroyExplicitAccessList(g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "returnedexplicitaccessslist") == 0)
            {
                DestroyExplicitAccessList(g_pReturnedExplicitAccessList, &g_ulNumOfExplicitAccessesReturned);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessrequestlist") == 0)
            {
                DestroyAccessRequestList(g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteelist") == 0)
            {
                DestroyTrusteeList(g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
            }
            else
            {
                printf("Unknown list type.");
            }
          }
          else if (strcmp(aTokens[0], "view") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "localexplicitaccesslist") == 0)
            {
                DumpExplicitAccessList(g_ulNumOfLocalExplicitAccesses, g_pLocalExplicitAccessList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "returnedexplicitaccessslist") == 0)
            {
                DumpExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "accessrequestlist") == 0)
            {
                DumpAccessRequestList(g_ulNumOfLocalAccessRequests, g_pLocalAccessRequestList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteelist") == 0)
            {
                DumpTrusteeList(g_ulNumOfLocalTrustees, g_pLocalTrusteeList);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "trusteerecord") == 0)
            {
                DumpTrusteeRecord(&g_LocalTrusteeRecord);
                printf("Done.\n");
            }
            else if (strcmp(aTokens[1], "localenvironment") == 0)
            {
                PrintEnvironment();
            }
                else
            {
                printf("Invalid argument.");
            }

          }
          else if (strcmp(aTokens[0], "copyreturnedlist") == 0)
          {
            // release the old local explicit access list
            ReleaseExplicitAccessList(g_ulNumOfLocalExplicitAccesses, g_pLocalExplicitAccessList);

            // replace the local explicit acccess list with the explicit access list returned
            // from the last call to GetExplicitAccess
            CopyExplicitAccessList(g_pLocalExplicitAccessList, g_pReturnedExplicitAccessList, &g_ulNumOfLocalExplicitAccesses, g_ulNumOfExplicitAccessesReturned);
            printf("Done.\n");
          }
          else if (strcmp(aTokens[0], "exec") == 0)
          {
            stringtolower(aTokens[1]);
            if (strcmp(aTokens[1], "testserver") == 0)
            {
                ExecTestServer(aTokens[2]);
            }
            else if (strcmp(aTokens[1], "revertaccessrights") == 0)
            {
                ExecRevertAccessRights();
            }
            else if (strcmp(aTokens[1], "commitaccessrights") == 0)
            {
                ExecCommitAccessRights();
            }
            else if (strcmp(aTokens[1], "getclassid") == 0)
            {
                ExecGetClassID();
            }
            else if (strcmp(aTokens[1], "initnewacl") == 0)
            {
                ExecInitNewACL();
            }
            else if (strcmp(aTokens[1], "loadacl") == 0)
            {
                ExecLoadACL(aTokens[2]);
            }
            else if (strcmp(aTokens[1], "saveacl") == 0)
            {
                ExecSaveACL(aTokens[2]);
            }
            else if (strcmp(aTokens[1], "isdirty") == 0)
            {
                ExecIsDirty();
            }
            else if (strcmp(aTokens[1], "getsizemax") == 0)
            {
                ExecGetSizeMax();
            }
            else if (strcmp(aTokens[1], "grantaccessrights") == 0)
            {
                ExecGrantAccessRights();
            }
            else if (strcmp(aTokens[1], "setaccessrights") == 0)
            {
                ExecSetAccessRights();
            }
            else if (strcmp(aTokens[1], "denyaccessrights") == 0)
            {
                ExecDenyAccessRights();
            }
            else if (strcmp(aTokens[1], "replaceallaccessrights") == 0)
            {
                ExecReplaceAllAccessRights();
            }
            else if (strcmp(aTokens[1], "revokeexplicitaccessrights") == 0)
            {
                ExecRevokeExplicitAccessRights();
            }
            else if (strcmp(aTokens[1], "isaccesspermitted") == 0)
            {
                ExecIsAccessPermitted();
            }
            else if (strcmp(aTokens[1], "geteffectiveaccessrights") == 0)
            {
                ExecGetEffectiveAccessRights();
            }
            else if (strcmp(aTokens[1], "getexplicitaccessrights") == 0)
            {
                ExecGetExplicitAccessRights();
            }
            else
            {
                printf("Unknown command.\n");
            }
          }

          else
          {
            printf("Unrecognized command.\n");
          } // if

          printf("\n");


        } // for

    exit(0);

}  // end main()


PISID GetSIDForTrustee
(
LPWSTR pwszTrusteeName
)
{
    PISID            pSID;
    DWORD           dwSize = 0;
    WCHAR           pwszDomain[100];
    DWORD           dwDomainSize = 100;
    SID_NAME_USE    SIDUse;


    LookupAccountNameW( NULL
                      , pwszTrusteeName
                      , pSID
                      , &dwSize
                      , pwszDomain
                      , &dwDomainSize
                      , &SIDUse );

    pSID = (PISID)midl_user_allocate(dwSize);

    LookupAccountNameW( NULL
                      , pwszTrusteeName
                      , pSID
                      , &dwSize
                      , pwszDomain
                      , &dwDomainSize
                      , &SIDUse );

    return pSID;
}

void AddTrusteeToExplicitAccessList
(
TRUSTEE_RECORD     *pTrusteeRecord,
PEXPLICIT_ACCESS_W pExplicitAccessList,
ULONG              *pulNumOfExplicitAccesses
)
{
    PEXPLICIT_ACCESS_W pInsertionPoint;

    pInsertionPoint = pExplicitAccessList + *pulNumOfExplicitAccesses;
    pInsertionPoint->grfAccessPermissions = pTrusteeRecord->grfAccessPermissions;
    pInsertionPoint->grfAccessMode = pTrusteeRecord->grfAccessMode;
    pInsertionPoint->grfInheritance = pTrusteeRecord->grfInheritance;
    MapTrusteeRecordToTrustee(pTrusteeRecord, &(pInsertionPoint->Trustee));
    (*pulNumOfExplicitAccesses)++;


}

void DeleteTrusteeFromExplicitAccessList
(
ULONG               ulIndex,
PEXPLICIT_ACCESS_W  pExplicitAccessList,
ULONG               *pulNumOfExplicitAccesses
)
{
    PEXPLICIT_ACCESS_W pDeletionPoint;

    if(ulIndex >= *pulNumOfExplicitAccesses)
    {
        return;
    }
    pDeletionPoint = pExplicitAccessList + ulIndex;

    midl_user_free(pDeletionPoint->Trustee.ptstrName);

    (*pulNumOfExplicitAccesses)--;
    memmove(pDeletionPoint, pDeletionPoint + 1, sizeof(EXPLICIT_ACCESS_W) * (*pulNumOfExplicitAccesses - ulIndex));
}

void AddTrusteeToAccessRequestList
(
TRUSTEE_RECORD    *pTrusteeRecord,
PACCESS_REQUEST_W pAccessRequestList,
ULONG             *pulNumOfAccessRequests
)
{
    PACCESS_REQUEST_W pInsertionPoint;

    pInsertionPoint = pAccessRequestList + *pulNumOfAccessRequests;

    pInsertionPoint->grfAccessPermissions = pTrusteeRecord->grfAccessPermissions;
    MapTrusteeRecordToTrustee(pTrusteeRecord, &(pInsertionPoint->Trustee));
    (*pulNumOfAccessRequests)++;

}

void DeleteTrusteeFromAccessRequestList
(
ULONG             ulIndex,
PACCESS_REQUEST_W pAccessRequestList,
ULONG             *pulNumOfAccessRequests
)
{
    PACCESS_REQUEST_W pDeletionPoint;
    pDeletionPoint = pAccessRequestList + ulIndex;

    if (ulIndex >= *pulNumOfAccessRequests)
    {
        return;
    }

    midl_user_free(pDeletionPoint->Trustee.ptstrName);
    (*pulNumOfAccessRequests)--;

    memmove(pDeletionPoint, pDeletionPoint + 1, sizeof(ACCESS_REQUEST_W) * (*pulNumOfAccessRequests - ulIndex));
}

void MapTrusteeRecordToTrustee
(
TRUSTEE_RECORD *pTrusteeRecord,
TRUSTEE_W      *pTrustee
)
{
    ULONG ulTrusteeNameLength;
    pTrustee->pMultipleTrustee = pTrusteeRecord->pMultipleTrustee;
    pTrustee->MultipleTrusteeOperation = pTrusteeRecord->MultipleTrusteeOperation;
    pTrustee->TrusteeForm = pTrusteeRecord->TrusteeForm;
    pTrustee->TrusteeType = pTrusteeRecord->TrusteeType;
    switch(pTrusteeRecord->TrusteeForm)
    {
        case TRUSTEE_IS_SID:
            if(pTrusteeRecord->pSID== NULL)
            {
                pTrustee->ptstrName = NULL;
            }
            else
            {
                ulTrusteeNameLength = GetSidLengthRequired(pTrusteeRecord->pSID->SubAuthorityCount);
                pTrustee->ptstrName = (LPWSTR)midl_user_allocate(ulTrusteeNameLength);
                CopySid(ulTrusteeNameLength, (PSID)(pTrustee->ptstrName), pTrusteeRecord->pSID);
            }
            break;
        case TRUSTEE_IS_NAME:
            if (pTrusteeRecord->pwszTrusteeName == NULL)
            {
                pTrustee->ptstrName = NULL;
            }
            else
            {
                ulTrusteeNameLength = lstrlenW(pTrusteeRecord->pwszTrusteeName);
                pTrustee->ptstrName = (LPWSTR)midl_user_allocate((ulTrusteeNameLength + 1) * sizeof(WCHAR));
                lstrcpyW(pTrustee->ptstrName, pTrusteeRecord->pwszTrusteeName);
            }
            break;
    }
}

void AddTrusteeToTrusteeList
(
TRUSTEE_RECORD *pTrusteeRecord,
TRUSTEE_W      *pTrusteeList,
ULONG          *pulNumOfTrustees
)
{
    TRUSTEE_W *pInsertionPoint;

    pInsertionPoint = pTrusteeList + *pulNumOfTrustees;

    MapTrusteeRecordToTrustee(pTrusteeRecord, pInsertionPoint);
    (*pulNumOfTrustees)++;

}

void DeleteTrusteeFromTrusteeList
(
ULONG            ulIndex,
TRUSTEE_W        *pTrusteeList,
ULONG            *pulNumOfTrustees
)
{
    TRUSTEE_W *pDeletionPoint;
    pDeletionPoint = pTrusteeList + ulIndex;

    if (ulIndex >= *pulNumOfTrustees)
    {
        return;
    }

    midl_user_free(pDeletionPoint->ptstrName);
    (*pulNumOfTrustees)--;

    memmove(pDeletionPoint, pDeletionPoint + 1, sizeof(TRUSTEE_W) * (*pulNumOfTrustees - ulIndex));
}

void DestroyAccessRequestList
(
PACCESS_REQUEST_W pAccessRequestList,
ULONG             *pulNumOfAccessRequests
)
{
    ULONG i;
    PACCESS_REQUEST_W pAccessRequestListPtr;

    for ( i = 0, pAccessRequestListPtr = pAccessRequestList
        ; i < *pulNumOfAccessRequests
        ; i++, pAccessRequestListPtr++)
    {
        midl_user_free(pAccessRequestListPtr->Trustee.ptstrName);
    }
    *pulNumOfAccessRequests = 0;

}

void DestroyTrusteeList
(
TRUSTEE_W *pTrusteeList,
ULONG     *pulNumOfTrustees
)
{
    ULONG i;
    TRUSTEE_W *pTrusteeListPtr;

    for ( i = 0, pTrusteeListPtr = pTrusteeList
        ; i < *pulNumOfTrustees
        ; i++, pTrusteeListPtr++)
    {
        midl_user_free(pTrusteeListPtr->ptstrName);
    }
    *pulNumOfTrustees = 0;
}

void DestroyExplicitAccessList
(
PEXPLICIT_ACCESS_W pExplicitAccessList,
ULONG              *pulNumOfExplicitAccesses
)
{
    ReleaseExplicitAccessList(*pulNumOfExplicitAccesses, pExplicitAccessList);
    *pulNumOfExplicitAccesses = 0;
}


/*

Function: PrintEnvironment

Parameter: none

Return: void

Purpose: This function prints out the current setting of the
         client side global varibles.

*/

void PrintEnvironment
(
void
)
{
    printf("Local access request list:\n");
    DumpAccessRequestList(g_ulNumOfLocalAccessRequests, g_pLocalAccessRequestList);
    printf("Local explicit access list:\n");
    DumpExplicitAccessList(g_ulNumOfLocalExplicitAccesses, g_pLocalExplicitAccessList);
    printf("Local trustee list:\n");
    DumpTrusteeList(g_ulNumOfLocalTrustees, g_pLocalTrusteeList);
    printf("The explicit access list returned form the last call to GetExplicitAccessRights:\n");
    DumpExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);
    printf("Current trustee record:\n");
    DumpTrusteeRecord(&g_LocalTrusteeRecord);

} // PrintEnvironment

void DumpTrusteeRecord
(
TRUSTEE_RECORD *pTrusteeRecord
)
{
    CHAR  pszTrusteeName[200];
    ULONG ulStrLen;

    printf("Access permissions:\n");
    DumpAccessPermissions(pTrusteeRecord->grfAccessPermissions);
    printf("Access mode: ");
    DumpAccessMode(pTrusteeRecord->grfAccessMode);
    printf("Inheritance: ");
    DumpInheritance(pTrusteeRecord->grfInheritance);
    printf("pMultipleTrustree is ");
    if(pTrusteeRecord->pMultipleTrustee == NULL)
    {
        printf("NULL.\n");
    }
    else
    {
        printf("non-NULL.\n");
    }
    printf("MultipleTrusteeOperation: ");
    DumpMultipleTrusteeOperation(pTrusteeRecord->MultipleTrusteeOperation);
    printf("TrusteeForm: ");
    DumpTrusteeForm(pTrusteeRecord->TrusteeForm);
    printf("TrusteeType: ");
    DumpTrusteeType(pTrusteeRecord->TrusteeType);

    if (pTrusteeRecord->pwszTrusteeName == NULL)
    {
        strcpy(pszTrusteeName, "<NULL>");

    }
    else
    {
        ulStrLen = WideCharToMultiByte( CP_ACP
                                      , 0
                                      , pTrusteeRecord->pwszTrusteeName
                                      , -1
                                      , pszTrusteeName
                                      , 200
                                      , NULL
                                      , NULL );
    }
    printf("Trustee's name: %s\n", pszTrusteeName);


    printf("Trustee's SID: \n");
    DumpSID(pTrusteeRecord->pSID);
    printf("\n");
}


void DumpAccessRequestList
(
ULONG            ulNumOfEntries,
ACCESS_REQUEST_W pAccessRequestList[]
)
{
    ULONG i;
    PACCESS_REQUEST_W pLocalAccessRequestListPtr;

    for (i = 0, pLocalAccessRequestListPtr = pAccessRequestList; i < ulNumOfEntries; i++, pLocalAccessRequestListPtr++)
    {
        printf("Access request #%d:\n\n", i);
        printf("Access permissions: ");
        DumpAccessPermissions(pLocalAccessRequestListPtr->grfAccessPermissions);
        printf("Trustee: \n");
        DumpTrustee(&(pLocalAccessRequestListPtr->Trustee));
        printf("\n");
    }
}



/*

Function: DumpLocalExplicitAccessList

Parameters: ULONG              ulNumOfEntries - Number of EXPLICIT_ACCESS structures in the array
            EXPLICIT_ACCESS_W  pExplicitAccessList - Pointer to an array of EXPLICIT_ACCESS structures to be printed
                                                     to be printed to the console.
Purpose: This function prints an array of explicit access structures to the console

*/
void DumpExplicitAccessList
(
ULONG              ulNumOfEntries,
EXPLICIT_ACCESS_W  pExplicitAccessList[]
)
{
    ULONG i;                                       // Loop counter
    EXPLICIT_ACCESS_W *pLocalExplicitAccessListPtr; // Local pointer for stepping through the explicit access list

    for (pLocalExplicitAccessListPtr = pExplicitAccessList, i = 0; i < ulNumOfEntries; i++, pLocalExplicitAccessListPtr++)
    {
       printf("Entry #%d.\n\n", i);
       printf("Access permissions:\n");
       DumpAccessPermissions(pLocalExplicitAccessListPtr->grfAccessPermissions);
       printf("Access mode: ");
       DumpAccessMode(pLocalExplicitAccessListPtr->grfAccessMode);
       printf("Inheritance: ");
       DumpInheritance(pLocalExplicitAccessListPtr->grfInheritance);
       printf("Trustee:\n");
       DumpTrustee(&(pLocalExplicitAccessListPtr->Trustee));
       printf("End Of entry #%d.\n\n", i);
    } // for
} // DumpLocalExplicitAccessList

void DumpAccessPermissions
(
DWORD grfAccessPermissions
)
{
    if(grfAccessPermissions & COM_RIGHTS_EXECUTE)
    {
        printf("COM_RIGHTS_EXECUTE\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT1)
    {
        printf("BOGUS_ACCESS_RIGHT1\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT2)
    {
        printf("BOGUS_ACCESS_RIGHT2\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT3)
    {
        printf("BOGUS_ACCESS_RIGHT3\n");
    }
    if(grfAccessPermissions & BOGUS_ACCESS_RIGHT4)
    {
        printf("BOGUS_ACCESS_RIGHT4\n");
    }
}

DWORD StringToAccessPermission
(
CHAR *pszString
)
{
    if (strcmp(pszString, "com_rights_execute") == 0)
    {
        return COM_RIGHTS_EXECUTE;
    }
    if (strcmp(pszString, "bogus_access_right1") == 0)
    {
        return BOGUS_ACCESS_RIGHT1;
    }
    if (strcmp(pszString, "bogus_access_right2") == 0)
    {
        return BOGUS_ACCESS_RIGHT2;
    }
    if (strcmp(pszString, "bogus_access_right3") == 0)
    {
        return BOGUS_ACCESS_RIGHT3;
    }
    if (strcmp(pszString, "bogus_access_right4") == 0)
    {
        return BOGUS_ACCESS_RIGHT4;
    }
    return 0;
}

void DumpAccessMode
(
ACCESS_MODE grfAccessMode
)
{
    switch(grfAccessMode)
    {
        case NOT_USED_ACCESS:
            printf("NOT_USED_ACCESS\n");
            break;
        case GRANT_ACCESS:
            printf("GRANT_ACCESS\n");
            break;
        case DENY_ACCESS:
            printf("DENY_ACCESS\n");
            break;
        case SET_ACCESS:
            printf("SET_ACCESS\n");
            break;
        case REVOKE_ACCESS:
            printf("REVOKE_ACCESS\n");
            break;
        case SET_AUDIT_SUCCESS:
            printf("SET_AUDIT_SUCCESS\n");
            break;
        case SET_AUDIT_FAILURE:
            printf("SET_AUDIT_FAILURE\n");
            break;
    } // switch
} // DumpAccessMode

void DumpTrusteeList
(
ULONG ulNumOfTrustees,
TRUSTEE_W pTrusteeList[]
)
{
    ULONG       i;
    PTRUSTEE_W  pTrusteeListPtr;

    for( i = 0, pTrusteeListPtr = pTrusteeList
       ; i < ulNumOfTrustees
       ; i++, pTrusteeListPtr++)
    {
        printf("Trustee #%d:\n", i);
        DumpTrustee(pTrusteeListPtr);
        printf("\n");
    }
}

void DumpTrustee
(
TRUSTEE_W *pTrustee
)
{
    char  pszTrusteeName[256];
    ULONG ulStrLen;

    printf("pMultipleTrustee is ");
    if(pTrustee->pMultipleTrustee == NULL)
    {
        printf("NULL.\n");
    }
    else
    {
        printf("non-NULL.\n");
    }
    printf("MultipleTrusteeOperation: ");
    DumpMultipleTrusteeOperation(pTrustee->MultipleTrusteeOperation);
    printf("TrusteeForm: ");
    DumpTrusteeForm(pTrustee->TrusteeForm);
    printf("TrusteeType: ");
    DumpTrusteeType(pTrustee->TrusteeType);

    switch(pTrustee->TrusteeForm)
    {
        case TRUSTEE_IS_NAME:
            if (pTrustee->ptstrName == NULL)
            {
                strcpy(pszTrusteeName, "<NULL>");
            }
            else
            {
                ulStrLen = WideCharToMultiByte( CP_ACP
                                              , 0
                                              , pTrustee->ptstrName
                                              , -1
                                              , pszTrusteeName
                                              , 256
                                              , NULL
                                              , NULL );

                pszTrusteeName[ulStrLen] = '\0';
            }
            printf("Trustee's name is: %s\n", pszTrusteeName);
            break;
        case TRUSTEE_IS_SID:
            printf("Trustee's SID is:\n");
            DumpSID((PISID)(pTrustee->ptstrName));
            break;
    } // switch
}

void DumpMultipleTrusteeOperation
(
MULTIPLE_TRUSTEE_OPERATION MultipleTrusteeOperation
)
{
    switch(MultipleTrusteeOperation)
    {
        case NO_MULTIPLE_TRUSTEE:
            printf("NO_MULTIPLE_TRUSTEE\n");
            break;
        case TRUSTEE_IS_IMPERSONATE:
            printf("TRUSTEE_IS_IMPERSONATE\n");
            break;
    }
}

MULTIPLE_TRUSTEE_OPERATION StringToMultipleTrusteeOperation
(
CHAR *pszString
)
{
    if(strcmp(pszString, "no_multiple_trustee") == 0)
    {
        return NO_MULTIPLE_TRUSTEE;
    }
    if(strcmp(pszString, "trustee_is_impersonate") == 0)
    {
        return TRUSTEE_IS_IMPERSONATE;
    }
    return NO_MULTIPLE_TRUSTEE;

}

void DumpTrusteeType
(
TRUSTEE_TYPE TrusteeType
)
{
    switch (TrusteeType)
    {
        case TRUSTEE_IS_UNKNOWN:
            printf("TRUSTEE_IS_UNKNOWN\n");
            break;
        case TRUSTEE_IS_USER:
            printf("TRUSTEE_IS_USER\n");
            break;
        case TRUSTEE_IS_GROUP:
            printf("TRSUTEE_IS_GROUP\n");
            break;

    }
}

TRUSTEE_TYPE StringToTrusteeType
(
CHAR *pszString
)
{
    if(strcmp(pszString, "trustee_is_unknown") == 0)
    {
        return TRUSTEE_IS_UNKNOWN;
    }
    if(strcmp(pszString, "trustee_is_user") == 0)
    {
        return TRUSTEE_IS_USER;
    }
    if(strcmp(pszString, "trustee_is_group") == 0)
    {
        return TRUSTEE_IS_GROUP;
    }
    return TRUSTEE_IS_UNKNOWN;
}

void DumpTrusteeForm
(
TRUSTEE_FORM TrusteeForm
)
{
    switch (TrusteeForm)
    {
        case TRUSTEE_IS_NAME:
            printf("TRUSTEE_IS_NAME\n");
            break;
        case TRUSTEE_IS_SID:
            printf("TRUSTEE_IS_SID\n");
            break;
    }
}

TRUSTEE_FORM StringToTrusteeForm
(
CHAR *pszString
)
{
    if (strcmp(pszString, "trustee_is_name") == 0)
    {
        return TRUSTEE_IS_NAME;
    }
    if (strcmp(pszString, "trustee_is_sid") == 0)
    {
        return TRUSTEE_IS_SID;
    }
    return TRUSTEE_IS_NAME;
}



void DumpSID
(
PISID pSID
)
{
    ULONG i;
    if( pSID == NULL)
    {
        printf("<NULL>\n");
    }
    else
    {

        printf("Revision: %d\n", pSID->Revision);
        printf("SubAuthorityCount: %d\n", pSID->SubAuthorityCount);
        printf("IdentifierAuthority: {%d,%d,%d,%d,%d,%d}\n", (pSID->IdentifierAuthority.Value)[0]
                                                           , (pSID->IdentifierAuthority.Value)[1]
                                                           , (pSID->IdentifierAuthority.Value)[2]
                                                           , (pSID->IdentifierAuthority.Value)[3]
                                                           , (pSID->IdentifierAuthority.Value)[4]
                                                           , (pSID->IdentifierAuthority.Value)[5] );
        printf("SubAuthorities:\n");
        for (i = 0; i < pSID->SubAuthorityCount; i++)
        {
            printf("%d\n", pSID->SubAuthority[i]);
        }
    }

}

ACCESS_MODE StringToAccessMode
(
CHAR *pszString
)
{
    if(strcmp(pszString, "not_use_access") == 0)
    {
        return NOT_USED_ACCESS;
    }
    if(strcmp(pszString, "grant_access") == 0)
    {
        return GRANT_ACCESS;
    }
    if(strcmp(pszString, "set_access") == 0)
    {
        return SET_ACCESS;
    }
    if(strcmp(pszString, "deny_access") == 0)
    {
        return DENY_ACCESS;
    }
    if(strcmp(pszString, "revoke_access") == 0)
    {
        return REVOKE_ACCESS;
    }
    if(strcmp(pszString, "set_audit_success") == 0)
    {
        return SET_AUDIT_SUCCESS;
    }
    if(strcmp(pszString, "set_audit_failure") == 0)
    {
        return SET_AUDIT_FAILURE;
    }
    return NOT_USED_ACCESS;

}

void DumpInheritance
(
DWORD grfInheritance
)
{
    switch(grfInheritance)
    {
        case NO_INHERITANCE:
            printf("NO_INHERITANCE\n");
            break;
        case SUB_CONTAINERS_ONLY_INHERIT:
            printf("SUB_CONTAINERS_ONLY_INHERIT\n");
            break;
        case SUB_OBJECTS_ONLY_INHERIT:
            printf("SUB_OBJECTS_ONLY_INHERIT\n");
            break;
        case SUB_CONTAINERS_AND_OBJECTS_INHERIT:
            printf("SUB_CONTAINERS_AND_OBJECTS_INHERIT\n");
            break;
    }
}

DWORD StringToInheritance
(
CHAR *pszString
)
{
    if (strcmp(pszString, "no_inheritance") == 0)
    {
        return NO_INHERITANCE;
    }
    if (strcmp(pszString, "sub_containers_only_inherit") == 0)
    {
        return SUB_CONTAINERS_ONLY_INHERIT;
    }
    if (strcmp(pszString, "sub_objects_only_inherit") == 0)
    {
        return SUB_OBJECTS_ONLY_INHERIT;
    }
    if (strcmp(pszString, "sub_containers_and_objects_inherit") == 0)
    {
        return SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    }
    return 0;
}

void ReleaseExplicitAccessList
(
ULONG              cCount,
PEXPLICIT_ACCESS_W pExplicitAccessList
)
{
    ULONG i;

    for (i = 0; i < cCount; i++)
    {
        midl_user_free(pExplicitAccessList[i].Trustee.ptstrName);
    }
    if(pExplicitAccessList != g_pLocalExplicitAccessList)
    {
        midl_user_free(pExplicitAccessList);
    }

}


void CopyExplicitAccessList
(
PEXPLICIT_ACCESS_W pTarget,
PEXPLICIT_ACCESS_W pSource,
ULONG              *pcCount,
ULONG              cCount
)
{
    ULONG i;
    PEXPLICIT_ACCESS_W pTargetPtr;
    PEXPLICIT_ACCESS_W pSourcePtr;
    ULONG ulTrusteeNameSize;


    for ( i = 0, pTargetPtr = pTarget, pSourcePtr = pSource
        ; i < cCount
        ; i++, pTargetPtr++, pSourcePtr++)
    {
        memcpy(pTargetPtr, pSourcePtr, sizeof(EXPLICIT_ACCESS));
        switch(pTargetPtr->Trustee.TrusteeForm)
        {
            case TRUSTEE_IS_SID:
                ulTrusteeNameSize = GetSidLengthRequired(((PISID)(pTargetPtr->Trustee.ptstrName))->SubAuthorityCount);
                pTargetPtr->Trustee.ptstrName = (LPWSTR)midl_user_allocate(ulTrusteeNameSize);
                CopySid(ulTrusteeNameSize, (PISID)(pTargetPtr->Trustee.ptstrName), (PISID)(pSourcePtr->Trustee.ptstrName));
                break;
            case TRUSTEE_IS_NAME:
                ulTrusteeNameSize = lstrlenW(pSourcePtr->Trustee.ptstrName);
                pTargetPtr->Trustee.ptstrName = (LPWSTR)midl_user_allocate((ulTrusteeNameSize + 1) * sizeof(WCHAR));
                lstrcpyW(pTargetPtr->Trustee.ptstrName, pSourcePtr->Trustee.ptstrName);
                break;
        }
    }
    *pcCount = cCount;

}

void ExecTestServer
(
CHAR *pszTestString
)
{
    ULONG ulCode;
    HRESULT hr;


    printf("Calling TestServer.\n");
    g_pIAccessControlTest->TestServer(pszTestString);


} // ExecTestServer

void ExecRevertAccessRights
(
void
)
{
    ULONG ulCode;
    HRESULT hr;

    printf("Calling RevertAccessRights.\n");
    hr = g_pIAccessControlTest->RevertAccessRights();

    if(hr == E_NOTIMPL)
    {
        printf("hr is E_NOTIMPL.\n");
    }
} // ExecRevertAccessRights

void ExecCommitAccessRights
(
void
)
{
    ULONG ulCode;
    HRESULT hr;

    printf("Calling CommitAccessRights.\n");
    hr = g_pIAccessControlTest->CommitAccessRights(0);

    if(hr == E_NOTIMPL)
    {
        printf("hr is E_NOTIMPL.\n");
    }
} // ExecCommitAccessRights

void ExecGetClassID
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    CLSID    clsid;
    HRESULT  hr;


    printf("Calling GetClassID.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetClassID(&clsid, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        printf("The clsid returned is {%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}.\n"
                , clsid.Data1, clsid.Data2, clsid.Data3
                , clsid.Data4[0], clsid.Data4[1], clsid.Data4[2]
                , clsid.Data4[3], clsid.Data4[4], clsid.Data4[5]
                , clsid.Data4[6], clsid.Data4[7]);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if


    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetSizeMax

void ExecInitNewACL
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;


    printf("Calling InitNewACL.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->InitNewACL(&dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecInitNewACL

void ExecLoadACL
(
CHAR *pszFilename
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling LoadACL.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->LoadACL(pszFilename, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecLoadACL

void ExecSaveACL
(
CHAR *pszFilename
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    ULONG    ulNumOfBytesWritten;
    HRESULT  hr;


    printf("Calling SaveACL.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->SaveACL(pszFilename, TRUE, &ulNumOfBytesWritten, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The number of bytes written to the file was %d\n", ulNumOfBytesWritten);
    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecSaveACL

void ExecGetSizeMax
(
void
)
{
    ULONG    ulCode;
    DWORD    dwTotalTickCount;
    DOUBLE   dMillisec;
    ULONG    ulNumOfBytesRequired;
    HRESULT  hr;

    printf("Calling GetSizeMax.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetSizeMax(&ulNumOfBytesRequired, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The number of bytes required to save the ACL was %d\n", ulNumOfBytesRequired);
    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetSizeMax

void ExecIsDirty
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling IsDirty.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->IsDirty(&dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        if(hr == S_OK)
        {
            printf("The access control object was dirty.\n");
        }
        else
        {
            printf("The access control object was clean.\n");
        }
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecIsDirty

void ExecGrantAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling GrantAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GrantAccessRights(g_ulNumOfLocalAccessRequests, (PE_ACCESS_REQUEST)(g_pLocalAccessRequestList), &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGrantAccessRights

void ExecSetAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling SetAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->SetAccessRights(g_ulNumOfLocalAccessRequests, (PE_ACCESS_REQUEST)g_pLocalAccessRequestList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecSetAccessRights

void ExecDenyAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling DenyAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->DenyAccessRights(g_ulNumOfLocalAccessRequests, (PE_ACCESS_REQUEST)g_pLocalAccessRequestList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecDenyAccessRights

void ExecReplaceAllAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling ReplaceAllAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->ReplaceAllAccessRights(g_ulNumOfLocalExplicitAccesses, (PE_EXPLICIT_ACCESS)g_pLocalExplicitAccessList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecReplaceAllAccessRights

void ExecRevokeExplicitAccessRights
(
void
)
{
    ULONG    ulCode;
    DOUBLE   dMillisec;
    DWORD    dwTotalTickCount;
    HRESULT  hr;

    printf("Calling RevokeExplicitAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->RevokeExplicitAccessRights(g_ulNumOfLocalTrustees, (PE_TRUSTEE)g_pLocalTrusteeList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecRevokeExplicitAccessRights

void ExecIsAccessPermitted
(
void
)
{
    ULONG     ulCode;
    DOUBLE   dMillisec;
    DWORD     dwTotalTickCount;
    HRESULT   hr;
    TRUSTEE_W Trustee;

    MapTrusteeRecordToTrustee(&g_LocalTrusteeRecord, &Trustee);

    printf("Calling IsAccessPermitted.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->IsAccessPermitted((PE_TRUSTEE)&Trustee, g_LocalTrusteeRecord.grfAccessPermissions, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if (hr == S_OK)
    {
        printf("The current trustee is granted the current set of access rights.\n");
    }
    else if (hr == E_ACCESSDENIED)
    {
        printf("The current trustee is denied the current set of access rights.\n");
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecIsAccessPermitted

void ExecGetEffectiveAccessRights
(
void
)
{
    ULONG     ulCode;
    DOUBLE   dMillisec;
    DWORD     dwTotalTickCount;
    HRESULT   hr;
    TRUSTEE_W Trustee;
    DWORD     dwRights;

    MapTrusteeRecordToTrustee(&g_LocalTrusteeRecord, &Trustee);

    printf("Calling GetEffectiveAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetEffectiveAccessRights((PE_TRUSTEE)&Trustee, &dwRights, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        printf("The set of effective access rights available to the current trustee includes:\n");
        DumpAccessPermissions(dwRights);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetEffectiveAccessRights

void ExecGetExplicitAccessRights
(
void
)
{
    ULONG     ulCode;
    DOUBLE   dMillisec;
    DWORD     dwTotalTickCount;
    HRESULT   hr;

    // If the global retruned explicit access list pointer is not NULL,
    // release the old returned explicit access list
    if (g_pReturnedExplicitAccessList != NULL)
    {
        ReleaseExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);

    } // if
    g_pReturnedExplicitAccessList = NULL;

    printf("Calling GetExplicitAccessRights.\n");
    dwTotalTickCount = GetTickCount();
    hr = g_pIAccessControlTest->GetExplicitAccessRights(&g_ulNumOfExplicitAccessesReturned, (PE_EXPLICIT_ACCESS *)&g_pReturnedExplicitAccessList, &dMillisec);
    dwTotalTickCount = GetTickCount() - dwTotalTickCount;

    if(SUCCEEDED(hr))
    {
        printf("The command was executed successfully on the server side with a return code of %x.\n", hr);
        printf("The number of explicit access structures returned is %d.\n", g_ulNumOfExplicitAccessesReturned);
        printf("The returned explicit access list is as follows:\n");
        DumpExplicitAccessList(g_ulNumOfExplicitAccessesReturned, g_pReturnedExplicitAccessList);
    }
    else
    {
        printf("Execution of the command failed on the server side with a return code of %x.\n", hr);

    } // if

    printf("The time spent on the server side to execute the command was %fms.\n", dMillisec);
    printf("The total number of clock ticks spent on the DCOM call was %d.\n", dwTotalTickCount);


} // ExecGetExplicitAccessRights

void ExecCleanupProc
(
void
)
{
    ULONG ulCode;

    // Release the IAccessControlTest pointer
    g_pIAccessControlTest->Release();
    g_pIUnknown->Release();

    // Cleanup all the memory allocated for the Local list
    DestroyAccessRequestList(g_pLocalAccessRequestList, &g_ulNumOfLocalAccessRequests);
    DestroyTrusteeList(g_pLocalTrusteeList, &g_ulNumOfLocalTrustees);
    DestroyExplicitAccessList(g_pLocalExplicitAccessList, &g_ulNumOfLocalExplicitAccesses);
    DestroyExplicitAccessList(g_pReturnedExplicitAccessList, &g_ulNumOfExplicitAccessesReturned);

} // ExecCleanupProc

/*

Function: Tokenize
Parameters: [in]  char      *pLineBuffer
            [out] char      *pTokens[]
            [out] short     *piNumOfTokens

Return:  void

Purpose: This function partition a string of space delimited tokens
         to null delimited tokens and return pointers to each individual
         token in pTokens and the number of tokens ion the string in
         piNumOfTokens.

Comment: Memory for the array of char * Tokens should be allocated by
         the caller.

         This function is implemented as a simple finite state machine.
         State 0 - Outside a token
         State 1 - Inside a token

*/

void Tokenize
(
char * pLineBuffer,
char * pTokens[],
short * piNumOfTokens
)
{
  short iTokens = 0;        // Token index
  char  *pLBuffPtr = pLineBuffer; // Pointer in the line buffer
  char  c; // current character
  short state = 0; // State of the tokenizing machine

  for(;;)
  {
    c = *pLBuffPtr;

    switch(state)
    {
    case 0:
      switch(c)
      {
        case '\t': // Ignore blanks
        case ' ':
        case '\n':
          break;
        case '\0':
          goto end;
        default:
          state=1;
          pTokens[iTokens]=pLBuffPtr;
          break;
      } // switch
      break;
    case 1:
      switch(c)
      {
        case '\t':
        case ' ':
        case '\n':
          *pLBuffPtr='\0';
          iTokens++;
          state=0;
          break;
        case '\0':
          *pLBuffPtr='\0';
          iTokens++;
          pTokens[iTokens]=pLBuffPtr;
          goto end;
        default:
          break;
      }
      break;
    }
    pLBuffPtr++;
  }// switch
  end:
  *piNumOfTokens = iTokens;
  return;
} // Tokenize

/*********************************************************************/
/*                 MIDL allocate and free                            */
/*********************************************************************/

void  __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(CoTaskMemAlloc(len));
}

void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    CoTaskMemFree(ptr);
}

/* end file actestc.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\accctrl\idl\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif


MIDL_FLAGS= \
        -Zp8 \
        -Oicf \
        -char unsigned \
        -error allocation \
        -error bounds_check \
        -error stub_data \
!ifdef TARGET_CPP        
        -cpp_cmd $(TARGET_CPP) \
!endif
        -DMIDL_PASS

..\h\actest.h ..\client\actest_c.c ..\server\actest_s.c: actest.idl actest.acf
        $(MIDL) $(MIDL_FLAGS) -sstub ..\server\actest_s.c  -header ..\h\actest.h -cstub ..\client\actest_c.c actest.idl

oactest_i.c oactest_p.c dlldata.c: oactest.idl
        $(MIDL) $(MIDL_FLAGS) oactest.idl
        mv oactest.h ..\h
allps: ..\h\actest.h  ..\client\actest_c.c ..\server\actest_s.c oactest_p.c oactest_i.c dlldata.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\acttest.h ===
/*
 *  acttest.h
 */

#ifndef _CLSID_
#define _CLSID_

#ifdef __cplusplus
extern "C"{
#endif

//
// Uncomment this define to make client and server free threaded.
//
#define FREETHREADED 

//
// Uncomment this define to enable the tests to run on the private
// rpcperf domain.
//
// #define USERPCPERFDOMAIN    

extern CLSID CLSID_ActLocal;
extern CLSID CLSID_ActRemote;
extern CLSID CLSID_ActAtStorage;
extern CLSID CLSID_ActInproc;
extern CLSID CLSID_ActPreConfig;
extern CLSID CLSID_ActRunAsLoggedOn;
extern CLSID CLSID_ActService;
extern CLSID CLSID_ActServerOnly;

extern TCHAR * ClsidGoober32String;
extern TCHAR * ClsidActLocalString;
extern TCHAR * ClsidActRemoteString;
extern TCHAR * ClsidActAtStorageString;
extern TCHAR * ClsidActInprocString;
extern TCHAR * ClsidActPreConfigString;
extern TCHAR * ClsidActRunAsLoggedOnString;
extern TCHAR * ClsidActServiceString;
extern TCHAR * ClsidActServerOnlyString;

void DeleteClsidKey( TCHAR * pwszClsid );

long SetAppIDSecurity( TCHAR * pszAppID );


int AddBatchPrivilege(const TCHAR *szUser);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\client\pswrd.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <stdio.h>

BOOL SetPassword(TCHAR * szCID, TCHAR * pszPw)
{
#ifndef CHICO
    WCHAR * szPw = pszPw;
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    LSA_HANDLE hPolicy;
    LSA_UNICODE_STRING sKey;
    LSA_UNICODE_STRING sPassword;
    WCHAR szKey[256];
    swprintf(szKey, L"SCM:%s", szCID);
    sKey.Length = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.Buffer = szKey;
    sPassword.Length = (wcslen(szPw) + 1) * sizeof(WCHAR);
    sPassword.MaximumLength = 80 * sizeof(WCHAR);
    sPassword.Buffer = szPw;

    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);

    // open the local security policy
    if (!NT_SUCCESS(
            LsaOpenPolicy(
                NULL,
                &sObjAttributes,
                POLICY_CREATE_SECRET,
                &hPolicy)))
    {
        printf("LsaOpenPolicy failed with %d\n",GetLastError());
        return(FALSE);
    }

    // store private data
    if (!NT_SUCCESS(
            LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        printf("LsaStorePrivateData failed with %d\n",GetLastError());
        return(FALSE);
    }

    LsaClose(hPolicy);
#endif
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\accctrl\server\oactestp.cxx ===
/****************************************************************************

    FILE:       actestp.c

    PURPOSE:    
                
    FUNCTIONS:  
    COMMENTS:

****************************************************************************/

#include <windows.h>
#include <ole2.h>
#include <oleext.h> // IAccessControl interface definition
#include <wchar.h>
#include <tchar.h>

#include <stdlib.h>
#include <stdio.h>
#include "oactest.h"    // header file generated by MIDL compiler

void DecrementLockCount();
void IncrementLockCount();
void ObjectCreated();
void ObjectDestroyed();

const CLSID CLSID_COAccessControl_DCOM
    = {0x52c0e9e1,0xc0c0,0x11cf,{0xae,0xec,0x00,0xaa,0x00,0x44,0xfb,0x89}};

extern "C" const CLSID CLSID_COAccessControlTest;
extern ULONG g_ulFrequency;
DWORD g_dwRegister;
long  g_fClassRegistered = FALSE;

// IAccessControlTest implementation class
class CAccessControlTest : public IAccessControlTest
{
private:
    IUnknown         *m_pIUnknown;
    IPersistStream   *m_pIPersistStream;
    IAccessControl   *m_pIAccessControl;
    ULONG            m_cRef;
    BOOL             m_bInitialized;

    // destructor
    ~CAccessControlTest()
    {
        DecrementLockCount();
        ObjectDestroyed();
    }


public:
    
    // contructor
    CAccessControlTest()
    {
        m_cRef = 0;
        m_bInitialized = FALSE;
        ObjectCreated();
        IncrementLockCount();
    }


    STDMETHODIMP_(HRESULT) QueryInterface
    (
    REFIID iid,
    void **ppv
    );

    STDMETHODIMP_(ULONG) AddRef();

    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP_(HRESULT) TestServer
    (
    LPSTR pszTestString
    );

    STDMETHODIMP_(HRESULT) GetClassID
    (
    CLSID   *pClassID,
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) InitNewACL
    (
    DOUBLE*pdMillisec
    );

    STDMETHODIMP_(HRESULT) LoadACL
    (
    LPCSTR  pszFilename,
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) SaveACL
    (
    LPCSTR  pszFilename,
    BOOL    fClearDirty,
    ULONG   *pulBytesWritten,
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) GetSizeMax
    (
    ULONG           *pcdSize,
    DOUBLE          *pdMillisec
    );

    STDMETHODIMP_(HRESULT) IsDirty
    (
    DOUBLE  *pdMillisec
    );

    STDMETHODIMP_(HRESULT) GrantAccessRights
    (
    ULONG            cCount,
    E_ACCESS_REQUEST *pAccessRequestList,
    DOUBLE           *pdMillisec
    );

    STDMETHODIMP_(HRESULT) DenyAccessRights
    (
    ULONG            cCount,
    E_ACCESS_REQUEST pAccessRequestList[],
    DOUBLE           *pdMillisec
    );

    STDMETHODIMP_(HRESULT) SetAccessRights
    (
    ULONG            cCount,
    E_ACCESS_REQUEST pAccessRequestList[],
    DOUBLE           *pdMillisec
    );

    STDMETHODIMP_(HRESULT) ReplaceAllAccessRights
    (
    ULONG             cCount,
    E_EXPLICIT_ACCESS pExplicitAccessList[],
    DOUBLE            *pdMillisec
    );

    STDMETHODIMP_(HRESULT) RevokeExplicitAccessRights
    (
    ULONG      cCount,
    E_TRUSTEE  pTrustee[],
    DOUBLE     *pdMillisec
    );

    STDMETHODIMP_(HRESULT) IsAccessPermitted
    (
    E_TRUSTEE   *pTrustee,
    DWORD       grfAccessPermissions,
    DOUBLE      *pdMillisec 
    );

    STDMETHODIMP_(HRESULT) GetEffectiveAccessRights
    (
    E_TRUSTEE   *pTrustee,  
    DWORD       *pdwRights,
    DOUBLE      *pdMillisec
    );

    STDMETHODIMP_(HRESULT) GetExplicitAccessRights
    (
    ULONG               *pcCount,
    PE_EXPLICIT_ACCESS  *ppExplicitAccessList,
    DOUBLE              *pdMillisec
    );

    STDMETHODIMP_(HRESULT) RevertAccessRights
    (
    );

    STDMETHODIMP_(HRESULT) CommitAccessRights
    (
    DWORD   grfCommitFlags
    );

}; // CAccessControlTest

//+-------------------------------------------------------------------------
//
//  Method:     CAccessControlTest::AddRef, public
//
//  Synopsis:   Increment reference count
//
//  See Also:   IUnknown::AddRef
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) 
CAccessControlTest::AddRef()
{
    InterlockedIncrement((long *) &m_cRef);
    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAccessControlTest::Release, public
//
//  Synopsis:   Decrement DLL reference count
//
//  Notes:      After the m_cRef is decremented, the object may be 
//              deleted by another thread.  In order to make this code safe
//              for multiple threads, we have to access the object state 
//              before decrementing m_cRef.
//
//  See Also:   IUnknown::Release.
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAccessControlTest::Release()
{
    unsigned long count;
    
    count = m_cRef - 1;

    if(InterlockedDecrement((long *) &m_cRef) == 0)
    {
        count = 0;
        if(m_bInitialized)
        {
            m_pIUnknown->Release();
            m_pIPersistStream->Release();
            m_pIAccessControl->Release();
        }
        delete this;
    }

    return count;
}

//+-------------------------------------------------------------------------
//
//  Method:     CAccessControlTest::QueryInterface, public
//
//  Synopsis:   Query for an interface on the class factory.
//
//  See Also:   IUnknown:QueryInterface
//
//--------------------------------------------------------------------------
STDMETHODIMP_(HRESULT)
CAccessControlTest::QueryInterface
(
REFIID iid,
void **ppv
)
{
    HRESULT hr;

    if (!m_bInitialized)
    {
        hr = CoCreateInstance( CLSID_COAccessControl_DCOM
                             , NULL
                             , CLSCTX_INPROC_SERVER
                             , IID_IUnknown
                             , (void **)&m_pIUnknown);
        if(FAILED(hr))      
        {
            printf("Failed to create an instance of COAccessControl\n.");
            return hr;
        }

        hr = m_pIUnknown->QueryInterface(IID_IPersistStream, (void **)&m_pIPersistStream);

        if(FAILED(hr))      
        {
            printf("Failed to query for the IPersistStream Interface.\n");
            return hr;
        }
        hr = m_pIUnknown->QueryInterface(IID_IAccessControl, (void **)&m_pIAccessControl);

        if(FAILED(hr))
        {
            printf("Failed to query for the IAccessControl interface.\n");
            return hr;
        }
        m_bInitialized = TRUE;
    }


    if ( IsEqualGUID( iid, IID_IUnknown ) )
    {
        *ppv = (IUnknown *) this;
        ((IUnknown *)(*ppv))->AddRef();
	    hr = S_OK;
    }
    else if (IsEqualGUID( iid, IID_IAccessControlTest))
    {
        *ppv = (IUnknown *)(IAccessControlTest *)this;
        ((IAccessControlTest *)(*ppv))->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::TestServer
(
LPSTR pszTestString
)
{
    printf("The test string is: %s\n", pszTestString);

    return S_OK;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetClassID
(
CLSID   *pClassID,
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;
    CLSID      clsid;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->GetClassID(&clsid);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pClassID = clsid;
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::InitNewACL
(
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->Load(NULL);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;

}

STDMETHODIMP_(HRESULT) CAccessControlTest::LoadACL
(
LPCSTR  pszFilename,
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;
    IStream    *pIStream = NULL;
    HANDLE     FileHandle;
    DWORD      dwFileSize;
    void       *pvBuffer;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    // Open the file specified by the client
    FileHandle = CreateFileA( pszFilename
                            , GENERIC_READ
                            , FILE_SHARE_READ | FILE_SHARE_WRITE
                            , NULL
                            , OPEN_EXISTING
                            , FILE_ATTRIBUTE_NORMAL
                            , NULL );

    if( FileHandle == INVALID_HANDLE_VALUE )
    {   
        printf("Cannot open file %s.\n", pszFilename);
        *pdMillisec = 0;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Get the size of the file
    dwFileSize = GetFileSize(FileHandle, NULL);

    // Create a buffer to hold the data in the file
    pvBuffer = CoTaskMemAlloc(dwFileSize);


    DWORD dwBytesRead;
    // Read the data of the opened file into a buffer
    if(!ReadFile( FileHandle
                , pvBuffer
                , dwFileSize
                , &dwBytesRead
                , NULL ))
    {
    
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Once we have read the file data into a buffer, we can
    // close the file handle
    CloseHandle( FileHandle);

    // Create a stream on the the buffer 
    localhr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);

    if (FAILED(localhr))
    {
        printf("Cannot create stream object.\n");
        CoTaskMemFree(pvBuffer);
        *pdMillisec = 0;
        return localhr;
    }

    // Load the data in the buffer into the IStream object
    localhr = pIStream->Write(pvBuffer, dwFileSize, NULL);

    // Release the local buffer
    CoTaskMemFree(pvBuffer);


    if (FAILED(localhr))
    {
        printf("Failed to load data into stream object.\n");
        *pdMillisec = 0;
        return localhr;
    }

    // Rewind the stream pointer the starting position
    LARGE_INTEGER li;
    li.LowPart = 0;
    li.HighPart = 0;
    localhr = pIStream->Seek(li, STREAM_SEEK_SET, NULL);

    if (FAILED(localhr))
    {
        printf("Failed to set the stream pointer to the starting position.\n");
        *pdMillisec = 0;
        return localhr;
    }

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->Load(pIStream);
    QueryPerformanceCounter(&liCount2);
    

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;

    // Release the local stream pointer
    pIStream->Release();

    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::SaveACL
(
LPCSTR  pszFilename,
BOOL    fClearDirty,
ULONG   *pulNumOfBytesWritten,
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;
    IStream    *pIStream = NULL;
    HANDLE     FileHandle;
    DWORD      dwFileSize;
    void       *pvBuffer;
    STATSTG    StreamInfo;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    // Create a stream on the the buffer 
    localhr = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);

    if (FAILED(localhr))
    {
        printf("Cannot create stream object.\n");
        *pdMillisec = 0;
        return localhr;
    }

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->Save(pIStream, fClearDirty);
    QueryPerformanceCounter(&liCount2);

    if(FAILED(localhr))
    {
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return localhr;
    }

    // Get the number of bytes written to the stream
    localhr = pIStream->Stat(&StreamInfo, STATFLAG_NONAME);
    if (FAILED(localhr))
    {
        printf("Unable to get information about the local stream.\n");
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return localhr;
    }

    dwFileSize = StreamInfo.cbSize.LowPart;

    LARGE_INTEGER liOffset;

    liOffset.QuadPart = Int32x32To64(dwFileSize, -1);
    pIStream->Seek(liOffset,STREAM_SEEK_CUR, NULL);

    // Allocate a buffer to store the data in the stream
    pvBuffer = CoTaskMemAlloc(dwFileSize);

    // Write the stream
    localhr = pIStream->Read(pvBuffer, dwFileSize, NULL);

    if(FAILED(localhr))
    {
        printf("Unable to write data from stream to buffer.\n");
        CoTaskMemFree(pvBuffer);
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return localhr;
    }    

    // Open the file specified by the client
    FileHandle = CreateFileA( pszFilename
                            , GENERIC_WRITE | GENERIC_READ
                            , FILE_SHARE_READ | FILE_SHARE_WRITE
                            , NULL
                            , CREATE_ALWAYS
                            , FILE_ATTRIBUTE_NORMAL
                            , NULL );

    if( FileHandle == INVALID_HANDLE_VALUE )
    {   
        printf("Cannot open file %s.\n", pszFilename);
        CoTaskMemFree(pvBuffer);
        *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // Read the data of the opened file into a buffer
    if(!WriteFile( FileHandle
                 , pvBuffer
                 , dwFileSize
                 , pulNumOfBytesWritten
                 , NULL ))
    {
        DWORD dwLastError;
        dwLastError = GetLastError();
        printf("Write failed with error code %x.", dwLastError);
    }

    // Flush the file buffers
    FlushFileBuffers(FileHandle);

    // Close the file handle
    CloseHandle(FileHandle);

    CoTaskMemFree(pvBuffer);


    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    *pulNumOfBytesWritten = dwFileSize;


    // Release the local stream pointer
    pIStream->Release();

    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetSizeMax
(
ULONG   *pcdSize,
DOUBLE  *pdMillisec
)
{
    ULARGE_INTEGER  uliSize;
    HRESULT         localhr;    
    
    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;


    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->GetSizeMax(&uliSize);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pcdSize = uliSize.LowPart;
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::IsDirty
(
DOUBLE  *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIPersistStream->IsDirty();
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;

    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GrantAccessRights
(
ULONG            cCount,
E_ACCESS_REQUEST pAccessRequestList[],
DOUBLE           *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->GrantAccessRights(cCount, (ACCESS_REQUEST_W *)pAccessRequestList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::SetAccessRights
(
ULONG            cCount,
E_ACCESS_REQUEST pAccessRequestList[],
DOUBLE           *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->SetAccessRights(cCount, (ACCESS_REQUEST_W *)pAccessRequestList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::DenyAccessRights
(
ULONG            cCount,
E_ACCESS_REQUEST pAccessRequestList[],
DOUBLE           *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->DenyAccessRights(cCount, (ACCESS_REQUEST_W *)pAccessRequestList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::ReplaceAllAccessRights
(
ULONG             cCount,
E_EXPLICIT_ACCESS pExplicitAccessList[],
DOUBLE            *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    
    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->ReplaceAllAccessRights(cCount, (EXPLICIT_ACCESS_W *)pExplicitAccessList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::RevokeExplicitAccessRights
(
ULONG             cCount,
E_TRUSTEE         pTrustee[],
DOUBLE            *pdMillisec
)
{
    char       *pszClientName;
    RPC_STATUS status;
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->RevokeExplicitAccessRights(cCount, (TRUSTEE_W *)pTrustee);
    QueryPerformanceCounter(&liCount2);


    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::IsAccessPermitted
(
E_TRUSTEE         *pTrustee,
DWORD             grfAccessPermissions,
DOUBLE            *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->IsAccessPermitted((TRUSTEE_W *)pTrustee, grfAccessPermissions);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetEffectiveAccessRights
(
E_TRUSTEE         *pTrustee,
DWORD             *pdwRights,
DOUBLE            *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->GetEffectiveAccessRights((TRUSTEE_W *)pTrustee, pdwRights);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::GetExplicitAccessRights
(
ULONG              *pcCount,
PE_EXPLICIT_ACCESS *ppExplicitAccessList,
DOUBLE             *pdMillisec
)
{
    HRESULT    localhr;

    LARGE_INTEGER liCount1;
    LARGE_INTEGER liCount2;

    QueryPerformanceCounter(&liCount1);
    localhr = m_pIAccessControl->GetExplicitAccessRights(pcCount, (PEXPLICIT_ACCESS_W *)ppExplicitAccessList);
    QueryPerformanceCounter(&liCount2);

    // Assign calues to the out parameters
    *pdMillisec = ((DOUBLE)(liCount2.LowPart) - (DOUBLE)(liCount1.LowPart)) / (DOUBLE)(g_ulFrequency) * 1000.0;
    return localhr;
}

STDMETHODIMP_(HRESULT) CAccessControlTest::RevertAccessRights
(
)
{
    return m_pIAccessControl->RevertAccessRights();

}


STDMETHODIMP_(HRESULT) CAccessControlTest::CommitAccessRights
(
DWORD   grfCommitFlags
)
{
    return m_pIAccessControl->CommitAccessRights(grfCommitFlags);
}

class CACTestClassFactory : public IClassFactory
{
private:
    unsigned long    m_cRef;

    //destructor
    ~CACTestClassFactory()
    {
        ObjectDestroyed();
    }

public:
    //constructor
    CACTestClassFactory()
    {
        m_cRef = 0;
        ObjectCreated();
    }

	HRESULT STDMETHODCALLTYPE QueryInterface(
		REFIID iid,
	    void **ppv);
	
	ULONG STDMETHODCALLTYPE AddRef();
	
	ULONG STDMETHODCALLTYPE Release();
	
	HRESULT STDMETHODCALLTYPE CreateInstance(
	    IUnknown *punkOuter,
	    REFIID riid,
	    void **ppv);

   HRESULT STDMETHODCALLTYPE LockServer(
        BOOL fLock );

};

//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::AddRef, public
//
//  Synopsis:   Increment DLL reference counts
//
//  See Also:   IUnknown::AddRef
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE 
CACTestClassFactory::AddRef()
{
    InterlockedIncrement((long *) &m_cRef);
    return m_cRef;
}

//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::CreateInstance, public
//
//  Synopsis:   Create an instance of CAccessControlTest.
//
//  See Also:   IClassFactory::CreateInstance
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CACTestClassFactory::CreateInstance
(
    IUnknown *punkOuter,
    REFIID riid,
    void **ppv
)
{
    HRESULT hr;
    CAccessControlTest *pACTest;

    if(punkOuter != 0)
    {
        //The CAccessControlTest class doesn't support aggregation.
        return CLASS_E_NOAGGREGATION;
    }

    pACTest = new CAccessControlTest();
    if(pACTest != 0)
    {
        hr = pACTest->QueryInterface(riid, ppv);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppv = 0;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::LockServer, public
//
//  Synopsis:   Lock the server in memory (by adding an extra reference)
//
//  Notes:      The class factory will be revoked when the lock count
//              is decremented to zero.  LockServer(TRUE) will increment the
//              lock count and ensure that the class factory will
//              not be revoked.
//
//  See Also:   IClassFactory::LockServer
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CACTestClassFactory::LockServer(
    BOOL fLock )
{
    if (fLock == TRUE)
        IncrementLockCount();
    else
        DecrementLockCount();

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::QueryInterface, public
//
//  Synopsis:   Query for an interface on the class factory.
//
//  See Also:   IUnknown::QueryInterface
//
//--------------------------------------------------------------------------
HRESULT STDMETHODCALLTYPE 
CACTestClassFactory::QueryInterface (
    REFIID iid,
    void **ppv )
{
    HRESULT hr;

    if ( IsEqualGUID( iid, IID_IUnknown) ||
         IsEqualGUID( iid, IID_IClassFactory ) )
    {
        *ppv = this;
        ((IUnknown *)(*ppv))->AddRef();
        hr = S_OK;
    }
    else
    {
        *ppv = 0;
        hr = E_NOINTERFACE;
    }

    return hr;
}
//+-------------------------------------------------------------------------
//
//  Method:     CACTestClassFactory::Release, public
//
//  Synopsis:   Decrement DLL reference count
//
//  See Also:   IUnknown::Release
//
//--------------------------------------------------------------------------
ULONG STDMETHODCALLTYPE
CACTestClassFactory::Release()
{
    unsigned long count;
    
    count = m_cRef - 1;

    if(InterlockedDecrement((long *) &m_cRef) == 0)
    {
        count = 0;
        delete this;
    }
    return count;
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterClassFactory.
//
//  Synopsis:   Register the class factory if it is not currently registered.
//
//--------------------------------------------------------------------------
HRESULT RegisterClassFactory()
{
    HRESULT hr;
    CACTestClassFactory *pClassFactory;

    if(InterlockedExchange(&g_fClassRegistered, TRUE) == FALSE)
    {
        pClassFactory = new CACTestClassFactory;
        
        if(pClassFactory != 0)
        {
            hr = CoRegisterClassObject(CLSID_COAccessControlTest,
	   	        		               (IUnknown *) pClassFactory,
	    	        	               CLSCTX_LOCAL_SERVER,
		    	                       REGCLS_MULTIPLEUSE,
			                           &g_dwRegister);
        }
        else
        {
           hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_OK;
    }
    return hr;  
}

//+-------------------------------------------------------------------------
//
//  Function:   RevokeClassFactory.
//
//  Synopsis:   Revoke the registered class factories if they have not
//              already been revoked.
//
//--------------------------------------------------------------------------
HRESULT RevokeClassFactory()
{
    HRESULT hr;

    if(InterlockedExchange(&g_fClassRegistered, FALSE) == TRUE)
    {
        hr = CoRevokeClassObject(g_dwRegister);
    }
    else
    {
        hr = S_OK;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\client\client.cxx ===
/*
 * client.cxx
 */

#include "client.hxx"

#define MIN_TEST_NUMBER         1
#define MAX_TEST_NUMBER         27

BOOL UnimplementedTest();
BOOL UnsupportedTest();
BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * wszServerName, int n, DWORD ctxt);

BOOL CGCOLocalEXE();
BOOL CGCOExplicitActivator();
BOOL CILocalDLL();
BOOL CILocalEXE();
BOOL CIExplicitActivator();
BOOL CI3LocalEXE();
BOOL CI3ExplicitActivator();
BOOL CGIFFLocalEXE();
BOOL CGIFFExplicitActivator();
BOOL CGIFFRegistryActivator();
BOOL CGIFFAtStorageActivator();
BOOL IMBLocalEXE();
BOOL IMBLocalService();
BOOL IMBAtStorageActivator();
BOOL IMBAtStorageService();
BOOL IMBAtStoragePreCon();
BOOL IMBAtStorageUser();
BOOL CIFromStgLocalEXE();
BOOL CIFromStgActivator();
BOOL CICustomLocalDLL();
BOOL CICustomLocalEXE();
BOOL CILocalPreCon();
BOOL CIExplicitPreCon();
BOOL CILocalUser();
BOOL CIExplicitUser();
BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();
BOOL CILocalService();
BOOL CIExplicitService();

#ifdef NO_DCOM
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        UnsupportedTest,
        CILocalDLL,
        CILocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest
/* New tests
        UnsupportedTest,
        UnsupportedTest,
end new tests */
        CI3LocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        IMBLocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        NULL
    };
#else
#ifdef CHICO
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        CGCOExplicitActivator,
        CILocalDLL,
        CILocalEXE,
        CIExplicitActivator,
        CILocalPreCon,
        CIExplicitPreCon,
        CILocalUser,
        CIExplicitUser,
        UnsupportedTest,
        CIExplicitService,
/* new tests
        CILocalPreConACL,
        CIExplicitPreConACL,
end new tests */
        CI3LocalEXE,
        CI3ExplicitActivator,
        CICustomLocalDLL,
        CICustomLocalEXE,
        CGIFFLocalEXE,
        CGIFFExplicitActivator,
        CGIFFRegistryActivator,
        CGIFFAtStorageActivator,
        IMBLocalEXE,
        UnsupportedTest,
        IMBAtStorageActivator,
        IMBAtStorageService,
        IMBAtStoragePreCon,
        IMBAtStorageUser,
        CIFromStgLocalEXE,
        CIFromStgActivator,
        NULL
    };
#else
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        CGCOExplicitActivator,
        CILocalDLL,
        CILocalEXE,
        CIExplicitActivator,
        CILocalPreCon,
        CIExplicitPreCon,
        CILocalUser,
        CIExplicitUser,
        CILocalService,
        CIExplicitService,
/* new tests
        CILocalPreConACL,
        CIExplicitPreConACL,
end new tests */
        CI3LocalEXE,
        CI3ExplicitActivator,
        CICustomLocalDLL,
        CICustomLocalEXE,
        CGIFFLocalEXE,
        CGIFFExplicitActivator,
        CGIFFRegistryActivator,
        CGIFFAtStorageActivator,
        IMBLocalEXE,
        IMBLocalService,
        IMBAtStorageActivator,
        IMBAtStorageService,
        IMBAtStoragePreCon,
        IMBAtStorageUser,
        CIFromStgLocalEXE,
        CIFromStgActivator,
        NULL
    };
#endif // CHICO
#endif // NO_DCOM

char *  TestName[] =
        {
            NULL,
           "CoGetClassObject                    local       EXE",
           "CoGetClassObject                    explicit    activator",
           "CoCreateInstance                    local       DLL",
           "CoCreateInstance                    local       EXE",
           "CoCreateInstance                    explicit    activator",
           "CoCreateInstance                    local       pre-configured",
           "CoCreateInstance                    explicit    pre-configured",
           "CoCreateInstance                    local       user",
           "CoCreateInstance                    explicit    user",
           "CoCreateInstance                    local       service",
           "CoCreateInstance                    explicit    service",
/* new tests
           "CoCreateInstance                    local       pre-configured ACL",
           "CoCreateInstance                    explicit    pre-configured ACL",
end new tests */
           "CoCreateInstance (3 IIDs)           local       EXE",
           "CoCreateInstance (3 IIDs)           explicit    activator",
           "CoCreateInstance from custom itf.   local       DLL",
           "CoCreateInstance from custom itf.   local       EXE",
           "CoGetInstanceFromFile               local       EXE",
           "CoGetInstanceFromFile               explicit    activator",
           "CoGetInstanceFromFile               registry    activator",
           "CoGetInstanceFromFile               AtStorage   activator",
           "IMoniker::BindToObject              local       EXE",
           "IMoniker::BindToObject              local       service",
           "IMoniker::BindToObject              AtStorage   activator",
           "IMoniker::BindToObject              AtStorage   service",
           "IMoniker::BindToObject              AtStorage   pre-configured",
           "IMoniker::BindToObject              AtStorage   user",
           "CoGetInstanceFromIStorage           local       EXE",
           "CoGetInstanceFromIStorage           explicit    activator",
            NULL
        };

char    RunTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            YES,
            // CoCreateInstance
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
/* new tests
            YES,
            YES,
end new tests */
            // CoCreateInstance (3 IIDs)
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            YES,
            YES,
            YES,
            // IMoniker:Bind
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            -1
         };

char    RunLocalTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            NO,
            // CreateInstance
            YES,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
/* new tests
            YES,
            NO,
end new tests */
            // CreateInstance (3 IIDs)
            YES,
            NO,
            // CreateInstance from custom Itf.
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            NO,
            NO,
            NO,
            // IMoniker:Bind
            YES,
            YES,
            NO,
            NO,
            NO,
            NO,
            // CoGetInstanceFromIStorage
            YES,
            NO,
            -1
         };

#define ACT_SERVERNAME_LENGTH 31
#define ACT_FILENAME_LENGTH 255

TCHAR ServerName[ACT_SERVERNAME_LENGTH+1];
TCHAR RemoteFileName[ACT_FILENAME_LENGTH+1];
TCHAR * LocalFileName = TEXT("c:\\acttest.dat");
TCHAR * StorageName = TEXT("c:\\acttest.stg");
TCHAR ShareName[ACT_SERVERNAME_LENGTH+1] = TEXT("C$");
#ifndef UNICODE
WCHAR wszServerName[ACT_SERVERNAME_LENGTH+1];
WCHAR wszRemoteFileName[ACT_FILENAME_LENGTH+1];
WCHAR * wszLocalFileName = L"c:\\acttest.dat";
WCHAR * wszStorageName = L"c:\\acttest.stg";
#else
WCHAR *wszServerName = ServerName;
WCHAR *wszRemoteFileName = RemoteFileName;
WCHAR * wszLocalFileName = LocalFileName;
WCHAR * wszStorageName = StorageName;
#endif

LARGE_INTEGER liPerfFreq;
LARGE_INTEGER liStart;
LARGE_INTEGER liStop;
LARGE_INTEGER liElapsedTime;

#define RESET_CLOCK liElapsedTime.LowPart = liElapsedTime.HighPart = 0
#define START_CLOCK QueryPerformanceCounter(&liStart)
#define STOP_CLOCK      QueryPerformanceCounter(&liStop); \
                        liElapsedTime.QuadPart += liStop.QuadPart - liStart.QuadPart
#define DUMP_CLOCK DisplayElapsedTime()
#define START_LOOP for (unsigned sl_n = uIterations+1; sl_n--;){
#define STOP_LOOP if (uIterations == sl_n ) RESET_CLOCK;}
#define SLEEP_IF_LOOPING if (sl_n && !gfHoldServer) Sleep(1000)

unsigned uIterations = 0;

BOOL    gfRegister = TRUE;
BOOL    gfHoldServer = FALSE;
BOOL    gfLocal = FALSE;
BOOL    gfNolocal = FALSE;
BOOL    gfSpecificTest = FALSE;

void DisplayElapsedTime(void)
{
    LONGLONG    MicroPerIter;

    liElapsedTime.QuadPart /= uIterations;

    MicroPerIter = liElapsedTime.QuadPart * 1000000;
    MicroPerIter /= liPerfFreq.QuadPart;

    printf( "Time: %d microseconds per iteration", (DWORD) MicroPerIter );
}

BOOL AllLocal()
{
    for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x]  &&  !RunLocalTest[x])
            return(FALSE);
    }
    return(TRUE);
}

void _cdecl main( int argc, char ** argv )
{
    HRESULT         HResult;
    HANDLE          hFile;
    int             n;

#ifndef NO_DCOM
    if ( argc == 1 )
        PrintUsageAndExit( FALSE );
#endif // NO_DCOM

    if ( argc > 1 && strcmp(argv[1],"-?") == 0 )
        PrintUsageAndExit( TRUE );

    n = 1;

    while ( (n < argc) && (*argv[n] == '-') )
    {
        if ( (n < argc) && strcmp(argv[n],"-local") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfLocal = TRUE;
            memcpy(RunTest, RunLocalTest, MAX_TEST_NUMBER + MIN_TEST_NUMBER);
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-nolocal") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfNolocal = TRUE;
            for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
            {
                RunTest[x] = !RunLocalTest[x];
            }
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-noreg") == 0 )
        {
            gfRegister = FALSE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-hold") == 0 )
        {
            gfHoldServer = TRUE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-n") == 0 )
        {
            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            uIterations = atoi(argv[n++]);
        }

        if ( (n < argc) && strcmp(argv[n],"-t") == 0 )
        {
            long    TestNum1, TestNum2;

            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            TestNum1 = atoi(argv[n++]);

            if ( (n < argc) && ((TestNum2 = atoi(argv[n])) != 0) )
                n++;
            else
                TestNum2 = TestNum1;

            if ( (TestNum1 < MIN_TEST_NUMBER) || (TestNum2 > MAX_TEST_NUMBER) )
            {
                printf( "Test number(s) must be between %d and %d.\n",
                        MIN_TEST_NUMBER,
                        MAX_TEST_NUMBER );
                return;
            }

            if ( TestNum1 > TestNum2 )
            {
                printf( "Second test number must be greater than the first.\n" );
                return;
            }

            if (!gfSpecificTest)
            {
                gfSpecificTest = TRUE;
                // only do this the first time -t is found on the command line
                memset(RunTest,NO,sizeof(RunTest));
            }
            memset(&RunTest[TestNum1],YES,sizeof(char)*(TestNum2-TestNum1+1));
        }
    }

#ifndef NO_DCOM
    if ( n != argc - 1  && n != argc -2 && !AllLocal())
    {
        printf("ERROR - Selected tests require a server name.\n");
        ExitThread(0);
    }

    if ( n < argc )
    {
#ifndef UNICODE
        strcpy(ServerName, argv[n]);
#endif
        MultiByteToWideChar( CP_ACP,
                             0,
                             argv[n],
                             -1,
                             wszServerName,
                             ACT_SERVERNAME_LENGTH );
        if ( ++n < argc)
        {
#ifndef UNICODE
        strcpy(ShareName, argv[n]);
#else
        MultiByteToWideChar( CP_ACP,
                             0,
                             argv[n],
                             -1,
                             ShareName,
                             ACT_SERVERNAME_LENGTH );
#endif
        }
        else
        {
#ifdef CHICO
           printf("ERROR - On Win95 Selected tests require a share name.\n");
           ExitThread(0);
#endif
        }
    }
    else
    {
#ifndef UNICODE
        ServerName[0] = 0;
#endif
        wszServerName[0] = 0;
        ShareName[0] = 0;
    }
#endif // NO_DCOM

    hFile = CreateFile(
                LocalFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                0,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("CreateFile failed while creating local file: %d\n", GetLastError());
        return;
    }

    CloseHandle( hFile );

#ifndef NO_DCOM
    if ( ServerName[0] != 0 )
    {
        RemoteFileName[0] = 0;

        if ( ServerName[0] != TEXT('\\') )
            lstrcat( RemoteFileName, TEXT("\\\\") );

        lstrcat( RemoteFileName, ServerName );
        lstrcat( RemoteFileName, TEXT("\\") );
        lstrcat( RemoteFileName, ShareName );
        lstrcat( RemoteFileName, TEXT("\\acttest.dat") );

#ifndef UNICODE
        MultiByteToWideChar( CP_ACP,
                             0,
                             RemoteFileName,
                             -1,
                             wszRemoteFileName,
                             ACT_FILENAME_LENGTH);
#endif

        hFile = CreateFile(
                    RemoteFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    0,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    0 );

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            printf("CreateFile failed while creating remote file: %d\n", GetLastError());
            return;
        }

        CloseHandle( hFile );
    }
#endif // NO_DCOM

#ifdef FREETHREADED
    HResult = CoInitializeEx(NULL,COINIT_MULTITHREADED );
#else
    HResult = CoInitialize(NULL);
#endif

    if( FAILED(HResult) )
    {
        printf( "Client CoInitialize failed Ox%x!\n", HResult );
        return;
    }

    if ((!QueryPerformanceFrequency(&liPerfFreq)) && uIterations > 0)
    {
        printf("No high performance counter.\nTests cannot be timed.\nAborting.\n");
    }
    else
    {
        if ( ! Tests() )
            printf("\nTests FAILED\n");
        else
            printf("\nTests SUCCEEDED\n");
    }

    CoUninitialize();
    DeleteFile( LocalFileName );
#ifndef NO_DCOM
    DeleteFile( RemoteFileName );
#endif // NO_DCOM
}

BOOL Tests()
{
    HRESULT         HResult;
    long            RegStatus;

    if (gfRegister)
    {
        DeleteClsidKey( ClsidGoober32String );
        DeleteClsidKey( ClsidActLocalString );
        DeleteClsidKey( ClsidActRemoteString );
        DeleteClsidKey( ClsidActAtStorageString );
        DeleteClsidKey( ClsidActInprocString );
        DeleteClsidKey( ClsidActPreConfigString );
        DeleteClsidKey( ClsidActRunAsLoggedOnString );
        DeleteClsidKey( ClsidActServiceString );
        DeleteClsidKey( ClsidActServerOnlyString );

        if ( (RegStatus = InitializeRegistryForInproc()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForInproc failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForLocal()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForLocal failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForCustom()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForCustom failed %d.\n", RegStatus);
            return FALSE;
        }
    #ifndef NO_DCOM
        if ( (RegStatus = InitializeRegistryForRemote()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForRemote failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForService()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForService failed %d.\n", RegStatus);
            return FALSE;
        }
    #endif // NO_DCOM
    }
    BOOL fAllTests = TRUE;

    for (int x = MIN_TEST_NUMBER; x <= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x])
        {
            printf("\nTest %2d: %s\n",x, TestName[x]);
            // prime the system once to ensure the test is fully cached
            if (rgTest[x]())
            {
                printf("PASSED");
                if (uIterations)
                {
                    printf(" - ");
                    DUMP_CLOCK;
                }
                printf("\n");
            }
            else
            {
                printf("FAILED\n");
                fAllTests = FALSE;
            }

        }
    }

    return(fAllTests);
}

void PrintUsageAndExit( BOOL bListTests )
{
#ifdef NO_DCOM
    printf("Usage : %s [-hold] [-noreg] [-n #] [-t # [#]]\n", "actclt");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#else
    printf("Usage : %s [-hold] [-noreg] [[-local] | [-nolocal]] [-n #] [-t # [#]] [server_name [share_name]] \n", "actclt");
    printf("\t-hold    : Hold the server up during all iterations.\n");
    printf("\t-local   : Run only local activation tests.\n");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-nolocal : Run only remote activation tests.\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#endif // NO_DCOM

    if ( bListTests )
    {
        long    n;

        printf("\nTests :\n");
        printf("\t # Method                              Location    Security\n");
        printf("\t-- ----------------------------------- ----------- --------------\n");

        for ( n = MIN_TEST_NUMBER; n <= MAX_TEST_NUMBER; n++ )
        {
            printf("\t%2d %s\n", n, TestName[n]);
        }
    }

    ExitThread(0);
}

void * __RPC_API
MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

void __RPC_API
MIDL_user_free(void * vp)
{
    free(vp);
}

BOOL StampFileWithCLSID(WCHAR * szFilename, CLSID & clsid)
{
    HRESULT hr;
    IStorage * pStg;

    hr = StgCreateDocfile(
                szFilename,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStg);

    if (FAILED (hr))
    {
        printf("StgCreateDocfile returned 0x%x\n", hr);
        return(FALSE);
    }

    hr = WriteClassStg(pStg, clsid);

    pStg->Release();

    if (FAILED (hr))
    {
        printf("WriteClassStg returned 0x%x\n", hr);
        return(FALSE);
    }

    return(TRUE);
}

//
// Test Procedures:
//

BOOL UnimplementedTest()
{
    printf("Not implemented at this time.\n");
    return(TRUE);
}

BOOL UnsupportedTest()
{
    printf("Not supported by this version.\n");
    return(TRUE);
}

BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * wszServerName, int n, DWORD ctxt)
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    if (wszServerName)
    {
        memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
        ServerInfo.pwszName = wszServerName;
        pServerInfo = &ServerInfo;
    }
    else
    {
        pServerInfo = NULL;
    }

    MULTI_QI QIStruct[10];
    int x;
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    for (x = n; x--;)
    {
        QIStruct[x].pItf = NULL;
        QIStruct[x].pIID = (IID *) &iid;
    }


    START_CLOCK;
    hr = CoCreateInstanceEx(
        clsid,
        NULL,
        ctxt,
        pServerInfo,
        n,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    for (x = 0; x < n; x++)
    {
        if (FAILED(QIStruct[x].hr))
        {
            printf("CoCreateInstanceEx returned 0x%x for interface %d\n",
                QIStruct[x].hr, x);
            fReturn = FALSE;
        }
        else
            QIStruct[x].pItf->Release();
    }
    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CGCOLocalEXE()
{
    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_LOCAL_SERVER,
        NULL,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}

#ifndef NO_DCOM
BOOL CGCOExplicitActivator()
{
    COSERVERINFO   ServerInfo;
    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_REMOTE_SERVER,
        &ServerInfo,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}
#endif // NO_DCOM

#ifdef NO_DCOM
BOOL CILocalDLL()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActInproc,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}

BOOL CILocalEXE()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActLocal,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else
BOOL CILocalDLL()
{
    return GenericCITest(CLSID_ActInproc, IID_IUnknown, NULL, 1, CLSCTX_INPROC_SERVER);
}

BOOL CILocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, wszServerName, 1, CLSCTX_REMOTE_SERVER);
}
#endif // NO_DCOM

#ifdef NO_DCOM
// Pre-DCOM version of CI3LocalEXE which calls CoCreateInstance
// once followed by 2 calls to QueryInterface
// instead of calling CoCreateInstanceEx.
BOOL CI3LocalEXE()
{
    IUnknown * pUnknown;
    IUnknwon * punkHeld = NULL;
    IPersist * pPersist;
    IPersistFile * pPersistFile;

    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
            CLSID_ActLocal,
            NULL,
            CLSCTX_LOCAL_SERVER,
            IID_IUnknown,
            (void **) &pUnknown );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersist );
    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersistFile );
    STOP_CLOCK;

    pUnknown->Release();
    pPersist->Release();
    pPersistFile->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else // NO_DCOM

BOOL CI3LocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, NULL, 3, CLSCTX_LOCAL_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CI3ExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, wszServerName, 3, CLSCTX_REMOTE_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CGIFFLocalEXE()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    STGM_READWRITE,
                    wszLocalFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFExplicitActivator()
{
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;

    MULTI_QI QIStruct[1];

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    &ServerInfo,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    wszRemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFRegistryActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    wszRemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFAtStorageActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActAtStorage,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    wszRemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}
#endif // NO_DCOM

BOOL IMBLocalEXE()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszLocalFileName, CLSID_ActLocal))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszLocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

#ifndef NO_DCOM
BOOL IMBLocalService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszLocalFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszLocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;
    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }
    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageActivator()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActAtStorage))
        return FALSE;

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStoragePreCon()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActPreConfig))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageUser()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActRunAsLoggedOn))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgLocalEXE()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    IUnknown * punkHeld = NULL;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                wszStorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgActivator()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                wszStorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    &ServerInfo,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalDLL()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT     hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActInproc,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalEXE()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CILocalPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, wszServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, wszServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_LOCAL_SERVER,
        NULL,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CIExplicitService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;
    pServerInfo = &ServerInfo;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_REMOTE_SERVER,
        pServerInfo,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();

#endif // NO_DCOM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\common\reg.c ===
//
// reg.c
//
// Common registry manipulation routines.
//

#ifdef UNICODE
#define _UNICODE 1
#endif

#include <windows.h>
#include <ole2.h>
#include "acttest.h"
#include "tchar.h"
#ifndef CHICO
#include <subauth.h>
#include <ntlsa.h>
#endif

void DeleteSubTree( TCHAR * pszClsid, TCHAR * SubTree )
{
    HKEY        hClsidRoot;
    HKEY        hClsid;
    long        RegStatus;
    TCHAR       szKeyName[256]; 
    DWORD       KeyNameSize;
    FILETIME    FileTime;
    int         SubKey;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              SubTree,
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidRoot );

    if ( RegStatus != ERROR_SUCCESS )
        return;

    RegStatus = RegOpenKeyEx( hClsidRoot,
                              pszClsid,
                              0,
                              KEY_ALL_ACCESS,
                              &hClsid );

    if ( RegStatus != ERROR_SUCCESS )
        return;

    for ( SubKey = 0; ; SubKey++ )
    {
        KeyNameSize = sizeof(szKeyName);

        RegStatus = RegEnumKeyEx(
                        hClsid,
                        SubKey,
                        szKeyName,
                        &KeyNameSize,
                        0,
                        NULL,
                        NULL,
                        &FileTime );

        if ( RegStatus != ERROR_SUCCESS )
            break;

        RegStatus = RegDeleteKey( hClsid, szKeyName );
    }

    RegCloseKey( hClsid );
    RegDeleteKey( hClsidRoot, pszClsid );
    RegCloseKey( hClsidRoot );
}


void DeleteClsidKey( TCHAR * pwszClsid )
{

    // Note that we also delete the corresponding AppID entries

    DeleteSubTree( pwszClsid, TEXT("CLSID"));
    DeleteSubTree( pwszClsid, TEXT("AppID"));
}

long SetAppIDSecurity( TCHAR * pszAppID )
{
    HKEY        hActKey;
    HKEY        hAppIDKey;
    BYTE        SecurityDescriptor[2000];
    LONG        RegStatus;
    SECURITY_INFORMATION        SI;
    DWORD       dwSize = sizeof( SecurityDescriptor );
    DWORD       Disposition;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("AppID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hAppIDKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    pszAppID,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;
#ifndef CHICO
    RegStatus  = RegGetKeySecurity( hActKey, 
                                    OWNER_SECURITY_INFORMATION 
                                        | GROUP_SECURITY_INFORMATION 
                                        | DACL_SECURITY_INFORMATION,
                                    &SecurityDescriptor,
                                    &dwSize );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;
#endif
    RegStatus  = RegSetValueEx(
                    hActKey,
                    TEXT("LaunchPermission"),
                    0,
                    REG_BINARY,
                    SecurityDescriptor,
                    dwSize );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hActKey,
                    TEXT("AccessPermission"),
                    0,
                    REG_BINARY,
                    SecurityDescriptor,
                    dwSize );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegCloseKey(hActKey);

    // make the key for the exe
    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    TEXT("ActSrv.Exe"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hActKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (BYTE*) pszAppID,
                    (_tcslen(pszAppID) + 1) * sizeof(TCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegCloseKey(hActKey);
    RegCloseKey(hAppIDKey);

    return ERROR_SUCCESS;
}



int SetAccountRights(const TCHAR *szUser, TCHAR *szPrivilege)
{
#ifndef CHICO
    int                   err;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES objAtt;
    DWORD                 cbSid = 1;
    TCHAR                 szDomain[128];
    DWORD                 cbDomain = 128;
    PSID                  pSid = NULL;
    SID_NAME_USE          snu;
    LSA_UNICODE_STRING    privStr;

    // Get a policy handle
    memset(&objAtt, 0, sizeof(LSA_OBJECT_ATTRIBUTES));
    if (!NT_SUCCESS(LsaOpenPolicy(NULL,
                                  &objAtt,
                                  POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                                  &hPolicy)))
    {
        return GetLastError();
    }

    // Fetch the SID for the specified user
    LookupAccountName(NULL, szUser, pSid, &cbSid, szDomain, &cbDomain, &snu);
    if ((err = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
    {
        return err;
    }
    pSid = (PSID*) malloc(cbSid);
    if (pSid == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }
    if (!LookupAccountName(NULL, szUser, pSid, &cbSid,
                          szDomain, &cbDomain, &snu))
    {
        return GetLastError();
    }

    // Set the specified privilege on this account
    privStr.Length = _tcslen(szPrivilege) * sizeof(WCHAR);
    privStr.MaximumLength = privStr.Length + sizeof(WCHAR);
    privStr.Buffer = szPrivilege;
    if (!NT_SUCCESS(LsaAddAccountRights(hPolicy, pSid, &privStr, 1)))
    {
        return GetLastError();
    }

    // We're done
    free( pSid );
    LsaClose(hPolicy);
#endif
    return ERROR_SUCCESS;
}

int AddBatchPrivilege(const TCHAR *szUser)
{
#ifndef CHICO
    return !SetAccountRights( szUser, SE_BATCH_LOGON_NAME );
#else
    return(TRUE);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\common\clsid.c ===
/*
 * clsid.cxx
 *
 * IMPORTANT:  Please DO NOT change these CLSIDs.  If you need to add
 *             to this list, add new CLSIDs at the END of the list.
 *
 *             The BVTs depend on these CLSIDs being defined as they are.
 */
#ifdef UNICODE
#define _UNICODE 1
#endif

#include "windows.h"
#include "tchar.h"

//
// This is the CLSID for the custom interface proxy, just to be different.
//
CLSID CLSID_GooberProxy = { /* 00000000-0000-0000-0000-000000000001 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}
  };

//
// This one gets registered as LocalServer32.
//
CLSID CLSID_ActLocal = { /* 00000000-0000-0000-0000-000000000002 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2}
  };

//
// This one gets registered as LocalServer32 and has a Remote key on the
// client side.
//
CLSID CLSID_ActRemote = { /* 00000000-0000-0000-0000-000000000003 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3}
  };

//
// This one gets registered as LocalServer32 and has an AtStorage key on the
// client side.
//
CLSID CLSID_ActAtStorage = { /* 00000000-0000-0000-0000-000000000004 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4}
  };

//
// This one gets registered as InprocServer32.
//
CLSID CLSID_ActInproc = { /* 00000000-0000-0000-0000-000000000005 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5}
  };

//
// This one gets registered as InprocServer32.
// It has an AtStorage key on the client side.
// It is configured to run in Pre-Configured user mode on the server side.
//
CLSID CLSID_ActPreConfig = { /* 00000000-0000-0000-0000-000000000006 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6}
  };

//
// Configured with RemoteServerName on client and as
// RunAs Logged On User on the server.
//
CLSID CLSID_ActRunAsLoggedOn = { /* 00000000-0000-0000-0000-000000000007 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7}
  };

//
// This one gets registered as an AtStorage service.
//
CLSID CLSID_ActService = { /* 00000000-0000-0000-0000-000000000008 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8}
  };

//
// This CLSID is registered only in the server's registry.  Tests default
// ActivateAtStorage on the client.
//
CLSID CLSID_ActServerOnly = { /* 00000000-0000-0000-0000-000000000009 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9}
  };

typedef unsigned short wchar_t;

TCHAR * ClsidGoober32String = TEXT("{00000000-0000-0000-0000-000000000001}");
TCHAR * ClsidActLocalString = TEXT("{00000000-0000-0000-0000-000000000002}");
TCHAR * ClsidActRemoteString = TEXT("{00000000-0000-0000-0000-000000000003}");
TCHAR * ClsidActAtStorageString = TEXT("{00000000-0000-0000-0000-000000000004}");
TCHAR * ClsidActInprocString = TEXT("{00000000-0000-0000-0000-000000000005}");
TCHAR * ClsidActPreConfigString = TEXT("{00000000-0000-0000-0000-000000000006}");
TCHAR * ClsidActRunAsLoggedOnString = TEXT("{00000000-0000-0000-0000-000000000007}");
TCHAR * ClsidActServiceString = TEXT("{00000000-0000-0000-0000-000000000008}");
TCHAR * ClsidActServerOnlyString = TEXT("{00000000-0000-0000-0000-000000000009}");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\accctrl\server\oactests.cxx ===
/****************************************************************************

    FILE:       oactests.cxx


****************************************************************************/

#include <windows.h>
#include <oleext.h>
#include <stdio.h>
#include "oactest.h"    // header file generated by MIDL compiler


HRESULT RegisterClassFactory();
HRESULT RevokeClassFactory();

//Prototypes for local functions
HRESULT RegisterLocalServer(REFCLSID rclsid);
HRESULT RegisterProxyDll(const char *pszProxyDll);
HRESULT UnregisterLocalServer(REFCLSID rclsid);
HRESULT UnregisterProxyDll(const char *pszProxyDll);

extern "C" const CLSID CLSID_COAccessControlTest
    = {0x20692b00,0xe710,0x11cf,{0xaf,0x0b,0x00,0xaa,0x00,0x44,0xfb,0x89}};

extern  ULONG g_ulFrequency;
long    g_LockCount   = 0;
long    g_ObjectCount = 0;
DWORD   g_dwThreadID;
ULONG   g_ulFrequency;
//+---------------------------------------------------------------------------
//
//  Function:   DecrementLockCount
//
//  Synopsis:   Decrements the lock count.  The lock count controls the 
//              registration of the class factory in the class table.
//              DecrementLockCount revokes the class factory when the 
//              lock count is zero.
//
//  Called By:  ~CAccessControlTest, IClassFactory::LockServer(FALSE).
//
//  See Also:   ObjectCreated, ObjectDestroyed, IncrementLockCount.
//
//----------------------------------------------------------------------------
void DecrementLockCount()
{
    //Decrement the lock count.
    if(InterlockedDecrement(&g_LockCount) == 0)
    {
        //When the lock count is decremented to zero,
        //revoke the class factory.
        RevokeClassFactory();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IncrementLockCount
//
//  Synopsis:   Increments the lock count.  The lock count controls the 
//              registration of the class factory in the class table.
//              If necessary, IncrementLockCount will reregister the class
//              factory in the class table.
//
//  Called By:  CAccessControlTest, IClassFactory::LockServer(TRUE).
//
//  See Also:   DecrementLockCount, ObjectCreated, ObjectDestroyed.
//
//----------------------------------------------------------------------------
void IncrementLockCount()
{
    if(g_LockCount == 0)
    {
        //Increment the lock count.
        InterlockedIncrement(&g_LockCount);

        //Reregister the class factory if necessary.
        RegisterClassFactory();
    }
    else
    {
        //Increment the lock count.
        InterlockedIncrement(&g_LockCount);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Main entry point for the server application.  This function 
//              initializes the server and processes the message loop.
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char *argv[])
{
    HRESULT hr = S_OK;
    int i;
    BOOL fRegisterServer = FALSE;
    BOOL fUnregisterServer = FALSE;
    BOOL fEmbedding = FALSE;
    BOOL fHelp = FALSE;
    MSG msg;

    // Parse each item, skip the command name
    for (i = 1; i < argc; i++)
    {
        if (lstrcmpiA( argv[i], "-Embedding" ) == 0)
        {
            //This server has been activated by OLE.
            fEmbedding = TRUE;
        }
        else if (lstrcmpiA( argv[i], "/REGSERVER" ) == 0)
        {
            fRegisterServer = TRUE;
        }
        else if (lstrcmpiA( argv[i], "/UNREGSERVER" ) == 0)
        {
            fUnregisterServer = TRUE;
        }
        else
        {
            fHelp = TRUE;
        }
    }

    if(fHelp == TRUE)
        {
        printf("USAGE: server /REGSERVER   - Installs server in the registry.\n");
        printf("       server /UNREGSERVER - Removes server from the registry.\n");
        printf("       server -Embedding   - Server was auto-started by OLE.\n");
        return 0;
    }
    else if(fUnregisterServer == TRUE)
    {
        hr = UnregisterLocalServer(CLSID_COAccessControlTest);
        if(FAILED(hr))
        {
            printf("Failed to remove local server from the registry.\n");
        }

        hr = UnregisterProxyDll("oactest.dll");
        if(FAILED(hr))
        {
            printf("Failed to remove proxy DLL from the registry.\n");
        }
        return 0;
    }
    

    //Install the local server in the registry.
    hr = RegisterLocalServer(CLSID_COAccessControlTest);
    if(FAILED(hr))
    {
        printf("Failed to install local server in the registry.\n");
    }

    //Install the proxy DLL in the registry.
    hr = RegisterProxyDll("oactest.dll");
    if(FAILED(hr))
    {
        printf("Failed to install proxy DLL in the registry.\n");
    }

    if(fRegisterServer == TRUE)
        return 0;

  
    //
    // Initialize OLE before calling any other OLE functions.
    //

    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if(SUCCEEDED(hr))
    {   
        hr = RegisterClassFactory();

        if(SUCCEEDED(hr))
        {

            LARGE_INTEGER liFreq;

            QueryPerformanceFrequency(&liFreq);

            g_ulFrequency = liFreq.LowPart;

            printf("Waiting for client to connect...\n");
            g_dwThreadID = GetCurrentThreadId();
            // Main message loop.  We will remain in the message loop
            // until we get a WM_QUIT message.
    	    while (GetMessage(&msg, NULL, 0, 0))
    	    {
        	    TranslateMessage(&msg);
        	    DispatchMessage(&msg);
        	}

            //If the class factory is still registered in the 
            //class table, revoke it before we shut down.
            RevokeClassFactory();
	    }
        else
        {
            printf("Failed to register class factory.\n");
        }

        CoUninitialize();
    }
    else
    {
        printf("CoInitialize failed.\n");
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   ObjectCreated
//
//  Synopsis:   Increments the object count controlling the main message loop
//              of the server process.  
//
//  Called By:  CAccessControlTest, CAccessControlTestFactory.
//
//  See Also:   DecrementLockCount, IncrementLockCount, ObjectDestroyed.
//
//----------------------------------------------------------------------------
void ObjectCreated()
{
    InterlockedIncrement(&g_ObjectCount);
}


//+---------------------------------------------------------------------------
//
//  Function:   ObjectDestroyed
//
//  Synopsis:   Decrements the object count controlling the main message loop 
//              of the server process.  When the object count is decremented 
//              to zero, we post a WM_QUIT message.  The main message loop will
//              exit and terminate the server process.
//
//  Called By:  ~CAccessControlTest, ~CAccessControlTestFactory.
//
//  See Also:   DecrementLockCount, IncrementLockCount, ObjectCreated.
//
//----------------------------------------------------------------------------
void ObjectDestroyed()
{
    if(InterlockedDecrement(&g_ObjectCount) == 0)
    {
        //When the last object is released, post a quit message.
        PostThreadMessage(g_dwThreadID, WM_QUIT, NULL, NULL);
    }
}

  
//+---------------------------------------------------------------------------
//
//  Function:   RegisterLocalServer
//
//  Synopsis:   Creates a registry key for a local server.
//
//  Parameters: rclsid - Supplies the class ID of the local server.
//
//----------------------------------------------------------------------------
HRESULT RegisterLocalServer(REFCLSID rclsid)
{
    HRESULT hr;
    LONG error;
    HKEY hKeyCLSID;         // key for ...\Classes\CLSID
    HKEY hKeyClassID;
    HKEY hKey;              // current key
    DWORD dwDisposition;
    char szServer[MAX_PATH];
    char szClassID[39];
    unsigned long length;

    length = GetModuleFileNameA(0, szServer, sizeof(szServer));

    if(length == 0)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }

    //create the CLSID key
    error = RegCreateKeyExA(
            HKEY_CLASSES_ROOT, 
            "CLSID",
            0, 
            "REG_SZ", 
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            0,
            &hKeyCLSID,
            &dwDisposition);

    if(!error)
    {
        //convert the class ID to a registry key name.
        sprintf(szClassID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                rclsid.Data1, rclsid.Data2, rclsid.Data3,
                rclsid.Data4[0], rclsid.Data4[1],
                rclsid.Data4[2], rclsid.Data4[3],
                rclsid.Data4[4], rclsid.Data4[5],
                rclsid.Data4[6], rclsid.Data4[7]);
  
        //create key for the server class
        error = RegCreateKeyExA(hKeyCLSID, 
                                szClassID,
                                0, 
                                "REG_SZ", 
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                0,
                                &hKeyClassID,
                                &dwDisposition);

        if(!error)
        {
            //create LocalServer32 key.
            error = RegCreateKeyExA(hKeyClassID,           
                                    "LocalServer32",
                                    0, 
                                    "REG_SZ", 
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    0,            
                                    &hKey,
                                    &dwDisposition);

            if(!error)
            {
                //Set the server name.
                error = RegSetValueExA(hKey, 
                                       "", 
                                       0, 
                                       REG_SZ, 
                                       (const unsigned char *)szServer,
                                       lstrlenA(szServer) + 1);

                // Specifies in the registry that this
                // server supports both threading models
                error = RegSetValueExA( hKey
                                      , "ThreadingModel"
                                      , 0
                                      , REG_SZ
                                      , (const unsigned char *)"Both"
                                      , lstrlenA("Both") + 1);

                RegFlushKey(hKey);
                RegCloseKey(hKey);
            }
            RegCloseKey(hKeyClassID);
        }
        RegCloseKey(hKeyCLSID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   RegisterProxyDll
//
//  Synopsis:   Creates registry entries for the interfaces contained in a 
//              proxy DLL.  
//
//  Parameters: pszProxyDll - Supplies the filename of the proxy DLL.
//
//  Notes:      RegisterProxyDll calls the DllRegisterServer function 
//              exported from the proxy DLL.
//
//----------------------------------------------------------------------------
HRESULT RegisterProxyDll(const char *pszProxyDll)
{
    HRESULT hr;
    HINSTANCE hProxyDll;
    HRESULT (STDAPICALLTYPE *pfnDllRegisterServer)();
 
    hProxyDll = LoadLibraryA(pszProxyDll);
    
    if(hProxyDll != 0)
    {
        pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)())
            GetProcAddress(hProxyDll, "DllRegisterServer");
        
        if(pfnDllRegisterServer != 0)
            hr = (*pfnDllRegisterServer)();
        else
            hr = HRESULT_FROM_WIN32(GetLastError());

        FreeLibrary(hProxyDll);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Function:   UnregisterLocalServer
//
//  Synopsis:   Removes the registry key for a local server.
//
//  Parameters: rclsid - Supplies the class ID of the local server.
//
//----------------------------------------------------------------------------
HRESULT UnregisterLocalServer(REFCLSID rclsid)
{
    HRESULT hr;
    HKEY hKeyCLSID;
    HKEY hKeyClassID;
    long error;
    char szClassID[39];

    //open the CLSID key
    error = RegOpenKeyExA(
        HKEY_CLASSES_ROOT, 
        "CLSID",
        0, 
        KEY_ALL_ACCESS,
        &hKeyCLSID);

    if(!error)
    { 
    //convert the class ID to a registry key name.
    sprintf(szClassID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            rclsid.Data1, rclsid.Data2, rclsid.Data3,
            rclsid.Data4[0], rclsid.Data4[1],
            rclsid.Data4[2], rclsid.Data4[3],
            rclsid.Data4[4], rclsid.Data4[5],
            rclsid.Data4[6], rclsid.Data4[7]);

        //open registry key for class ID string
        error = RegOpenKeyExA(
            hKeyCLSID, 
            szClassID,
            0, 
            KEY_ALL_ACCESS,
            &hKeyClassID);

        if(!error)
        {
            //delete LocalServer32 key. 
            error = RegDeleteKeyA(hKeyClassID, "LocalServer32");
            RegCloseKey(hKeyClassID);          
        }

        error = RegDeleteKeyA(hKeyCLSID, szClassID);
        RegCloseKey(hKeyCLSID);
    }

    if(!error)
        hr = S_OK;
    else
        hr = HRESULT_FROM_WIN32(error);

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:   UnregisterProxyDll
//
//  Synopsis:   Removes registry entries for the interfaces contained in a 
//              proxy DLL.  
//
//  Parameters: pszProxyDll - Supplies the filename of the proxy DLL.
//
//  Notes:      UnregisterProxyDll calls the DllUnregisterServer function 
//              exported from the proxy DLL.
//
//----------------------------------------------------------------------------
HRESULT UnregisterProxyDll(const char *pszProxyDll)
{
    HRESULT hr;
    HINSTANCE hProxyDll;
    HRESULT (STDAPICALLTYPE *pfnDllUnregisterServer)();
    
    hProxyDll = LoadLibraryA(pszProxyDll);
    
    if(hProxyDll != 0)
    {
        pfnDllUnregisterServer = (HRESULT (STDAPICALLTYPE *)())
            GetProcAddress(hProxyDll, "DllUnregisterServer");
        
        if(pfnDllUnregisterServer != 0)
            hr = (*pfnDllUnregisterServer)();
        else
            hr = HRESULT_FROM_WIN32(GetLastError());
    
        FreeLibrary(hProxyDll);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


/* end file actestss.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\dllsrv\dllgco.cxx ===
/*
 * DllGCO.cxx
 * - DllGetClassObject implementation for inproc DLL
 */


#include "server.hxx"
#include "factory.hxx"

HANDLE hStopServiceEvent;
BOOL fStartedAsService = FALSE;

long ObjectCount = 0;

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    MyFactory * pClass  = new FactoryInproc();

    hr = pClass->QueryInterface( riid, ppv );

    return hr;
}


STDAPI  DllCanUnloadNow(void)
{
return S_FALSE;
}

void ShutDown()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\client\reg.cxx ===
//
// reg.cxx
//

#include "client.hxx"

BOOL SetPassword(TCHAR * szCID, TCHAR * szPw);

TCHAR * ServiceName = TEXT("ActTestService");
TCHAR * ServiceDisplayName = TEXT("ActTestService");
#ifdef USERPCPERFDOMAIN
TCHAR * UserName = TEXT("rpcperf\\oleuser");
#else
TCHAR * UserName = TEXT("redmond\\oleuser");
#endif
TCHAR * Password = TEXT("TwoFor1");

long InitializeRegistryForLocal()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    TCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActLocalString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    TEXT("LocalServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 2") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActLocalString,
                    (_tcslen(ClsidActLocalString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActLocalString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForInproc()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    TCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActInprocString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    TEXT("InprocServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrvd.dll") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT("ThreadingModel"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Both"),
                    (_tcslen(TEXT("Both")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

TCHAR * StringIidIGoober = TEXT("{ffffffff-0000-0000-0000-000000000000}");

long InitializeRegistryForCustom()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    TCHAR       Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("Interface"),
                              0,
                              KEY_ALL_ACCESS,
                              &hInterface );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    StringIidIGoober,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("IGoober"),
                    (_tcslen(TEXT("IGoober")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    TEXT("ProxyStubClsid32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)ClsidGoober32String,
                    (_tcslen(ClsidGoober32String) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidGoober32String,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    TEXT("InProcServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("goober.dll") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForRemote()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    TCHAR   Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRemote
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRemoteString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRemoteString,
                    (_tcslen(ClsidActRemoteString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRemoteString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    TEXT("AppID"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRemoteString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( *ServerName )
       RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RemoteServerName"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (_tcslen(ServerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActAtStorage
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActAtStorageString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActAtStorageString,
                    (_tcslen(ClsidActAtStorageString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActAtStorageString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActAtStorageString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("ActivateAtStorage"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Y"),
                    (_tcslen(TEXT("Y")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRunAsLoggedOnUser
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRunAsLoggedOnString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRunAsLoggedOnString,
                    (_tcslen(ClsidActRunAsLoggedOnString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( *ServerName )
       RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RemoteServerName"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (_tcslen(ServerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    TEXT("LocalServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 7") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RunAs"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Interactive User"),
                    (_tcslen(TEXT("Interactive User")) + 1) * sizeof(TCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // RunAs CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActPreConfigString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActPreConfigString,
                    (_tcslen(ClsidActPreConfigString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActPreConfigString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActPreConfigString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( *ServerName )
       RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RemoteServerName"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (_tcslen(ServerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    TEXT("LocalServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 6") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RunAs"),
                    0,
                    REG_SZ,
                    (const BYTE *)UserName,
                    (_tcslen(UserName) + 1) * sizeof(TCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if (!SetPassword(ClsidActPreConfigString, Password))
        return(FALSE);

    if (AddBatchPrivilege( UserName ) )
        return(FALSE);

    return ERROR_SUCCESS;
}

long InitializeRegistryForService()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    HKEY    hServices;
    TCHAR   Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    TEXT("AppID"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
		    hClsidKey,
                    ClsidActServiceString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServiceString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActServiceString,
                    (_tcslen(ClsidActServiceString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActServiceString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 8") );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("LocalService"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServiceName,
                    (_tcslen(ServiceName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("ActivateAtStorage"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Y"),
                    (_tcslen(TEXT("Y")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Services"),
                              0,
                              KEY_READ,
                              &hServices );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return InstallService(Path);
}

DWORD InstallService( TCHAR * Path )
{
#ifndef CHICO
    SC_HANDLE hManager;
    SC_HANDLE hService;

    hManager = OpenSCManager( NULL,
                              NULL,
                              SC_MANAGER_ALL_ACCESS );

    if ( ! hManager )
    {
        printf( "OpenSCManager returned %d\n", GetLastError() );
        return GetLastError();
    }

    hService = OpenService( hManager,
                            ServiceName,
                            SERVICE_ALL_ACCESS );

    if ( ! hService )
    {
        hService = CreateService(
                        hManager,
                        ServiceName,
                        ServiceDisplayName,
                        SERVICE_ALL_ACCESS,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        Path,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);
    }

    if ( ! hService )
    {
        printf( "CreateService returned %d\n", GetLastError() );
        CloseServiceHandle(hManager);
        return GetLastError();
    }

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\server\pswrd.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <stdio.h>

BOOL SetPassword(TCHAR * szCID, TCHAR * pszPw)
{
#ifndef CHICO
    WCHAR * szPw = pszPw;
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    LSA_HANDLE hPolicy;
    LSA_UNICODE_STRING sKey;
    LSA_UNICODE_STRING sPassword;
    WCHAR szKey[256];
    swprintf(szKey, L"SCM:%s", szCID);
    sKey.Length = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.Buffer = szKey;
    sPassword.Length = (wcslen(szPw) + 1) * sizeof(WCHAR);
    sPassword.MaximumLength = 80 * sizeof(WCHAR);
    sPassword.Buffer = szPw;

    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);

    // open the local security policy
    if (!NT_SUCCESS(
            LsaOpenPolicy(
                NULL,
                &sObjAttributes,
                POLICY_CREATE_SECRET,
                &hPolicy)))
    {
        printf("LsaOpenPolicy failed with %d\n",GetLastError());
        return(FALSE);
    }

    // store private data
    if (!NT_SUCCESS(
            LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        printf("LsaStorePrivateData failed with %d\n",GetLastError());
        return(FALSE);
    }

    LsaClose(hPolicy);
#else
    WCHAR szPw[256];
    MultiByteToWideChar( CP_ACP,
                     0,
                     pszPw,
                     -1,
                     szPw,
                     sizeof(szPw) / sizeof(WCHAR) );
#endif
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\srvcore\classes.cxx ===
/*
 *  classes.cxx
 */

#include "server.hxx"
#include "classes.hxx"

//
// MyObject implementation.
//

MyObject::MyObject( int ActType ) :
    Refs(0),
    ActivationType(ActType),
    PersistFileObj(this),
    PersistStorageObj(this),
    GooberObj(this)
{
}

MyObject::~MyObject()
{
}

//
// MyObject IUnknown.
//

HRESULT STDMETHODCALLTYPE
MyObject::QueryInterface (
    REFIID  iid,
    void ** ppv )
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;

    if ( memcmp(&iid, &IID_IUnknown, sizeof(IID)) == 0 )
        *ppv = this;
    else if ( (memcmp(&iid, &IID_IPersist, sizeof(IID)) == 0) ||
              (memcmp(&iid, &IID_IPersistFile, sizeof(IID)) == 0) )
        *ppv = &PersistFileObj;
    else if ( memcmp(&iid, &IID_IPersistStorage, sizeof(IID)) == 0 )
        *ppv = &PersistStorageObj;
    else if ( memcmp(&iid, &IID_IGoober, sizeof(IID)) == 0 )
        *ppv = &GooberObj;
    else
        return E_NOINTERFACE;

    ((IUnknown *)(*ppv))->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE
MyObject::AddRef()
{
    Refs++;
    return Refs;
}

ULONG STDMETHODCALLTYPE
MyObject::Release()
{
    unsigned long   Count;

    Count = --Refs;

    if ( Count == 0 )
    {
	    delete this;

	    // Decrement the object count.
        if ( --ObjectCount == 0 )
            ShutDown();
    }

    return Count;
}

//
// PersistFile implementation.
//

PersistFile::PersistFile( MyObject * pObj ) :
    pObject(pObj)
{
}

//
// PersistFile IUnknown.
//
IUnknownMETHODS( PersistFile )

//
// PersistFile IPersist.
//

HRESULT STDMETHODCALLTYPE
PersistFile::GetClassID(
    CLSID * pClassID )
{
    if ( pObject->GetActivationType() == LOCAL )
        memcpy( pClassID, &CLSID_ActLocal, sizeof(IID) );
    else if ( pObject->GetActivationType() == REMOTE )
        memcpy( pClassID, &CLSID_ActRemote, sizeof(IID) );
    else if (pObject->GetActivationType() == ATBITS )
        memcpy( pClassID, &CLSID_ActAtStorage, sizeof(IID) );
    else if (pObject->GetActivationType() == INPROC )
        memcpy( pClassID, &CLSID_ActInproc, sizeof(IID) );
    return S_OK;
}

//
// PersistFile IPersistFile
//

HRESULT STDMETHODCALLTYPE
PersistFile::IsDirty()
{
    return S_FALSE;
}

HRESULT STDMETHODCALLTYPE
PersistFile::Load(
    LPCOLESTR   pszFileName,
    DWORD       dwMode )
{
    /** Doesn't work until we have security stuff...

    HANDLE  hFile;

    //
    // Verify that we can open the file.
    //

    hFile = CreateFile(
                pszFileName,
                dwMode,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        return HRESULT_FROM_WIN32( GetLastError() );

    CloseHandle( hFile );

    **/

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistFile::Save(
    LPCOLESTR   pszFileName,
    BOOL        fRemember )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistFile::SaveCompleted(
    LPCOLESTR   pszFileName )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistFile::GetCurFile(
    LPOLESTR *  ppszFileName )
{
    *ppszFileName = 0;
    return S_OK;
}

//
// PersistStorage implementation.
//

PersistStorage::PersistStorage( MyObject * pObj ) :
    pObject(pObj)
{
}

//
// PersistStorage IUnknown.
//
IUnknownMETHODS( PersistStorage )

//
// PersistStorage IPersist.
//

HRESULT STDMETHODCALLTYPE
PersistStorage::GetClassID(
    CLSID * pClassID )
{
    if ( pObject->GetActivationType() == LOCAL )
        memcpy( pClassID, &CLSID_ActLocal, sizeof(IID) );
    else if ( pObject->GetActivationType() == REMOTE )
        memcpy( pClassID, &CLSID_ActRemote, sizeof(IID) );
    else if (pObject->GetActivationType() == ATBITS )
        memcpy( pClassID, &CLSID_ActAtStorage, sizeof(IID) );
    else if (pObject->GetActivationType() == INPROC )
        memcpy( pClassID, &CLSID_ActInproc, sizeof(IID) );
    return S_OK;
}

//
// PersistStorage IPersistStorage
//

HRESULT STDMETHODCALLTYPE
PersistStorage::IsDirty()
{
    return S_FALSE;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::InitNew(
    IStorage *  pStg )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::Load(
    IStorage *  pStg )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::Save(
    IStorage *  pStgSave,
    BOOL        fSameAsLoad )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::SaveCompleted(
    IStorage *  pStgNew )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::HandsOffStorage()
{
    return S_OK;
}

//
// Goober implementation
//
Goober::Goober( MyObject * pObj ) :
    pObject(pObj)
{
}

//
// Goober IUnknown.
//
IUnknownMETHODS( Goober )

//
// Goober IGoober.
//
HRESULT STDMETHODCALLTYPE
Goober::Ping()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\server\server.cxx ===
/*
 * server.cxx
 */

#ifdef UNICODE
#define _UNICODE 1
#endif

#include "server.hxx"
#include "factory.hxx"
#include "tchar.h"

long ObjectCount = 0;

TCHAR * AtStorageFileName = TEXT("c:\\tmp\\atbits.dat");

#ifdef USERPCPERFDOMAIN
TCHAR * UserName = TEXT("rpcperf\\oleuser");
#else
TCHAR * UserName = TEXT("redmond\\oleuser");
#endif
TCHAR * Password = TEXT("TwoFor1");
TCHAR * ServiceName = TEXT("ActTestService");
TCHAR * ServiceDisplayName = TEXT("ActTestService");
BOOL fStartedAsService = FALSE;
HANDLE hStopServiceEvent;
#ifdef FREETHREADED
HANDLE hFreeThreadEvent;
#endif
SERVICE_STATUS SStatus;
SERVICE_STATUS_HANDLE hService;
BOOL InstallService(TCHAR * );

HKEY    ghClsidRootKey = 0;
HKEY    ghAppIDRootKey = 0;

DWORD       RegHandleLocal;
DWORD       RegHandleRemote;
DWORD       RegHandleAtStorage;
DWORD       RegHandlePreConfig;
DWORD       RegHandleRunAsLoggedOn;
DWORD       RegHandleService;
DWORD       RegHandleServerOnly;
unsigned    uClassIndex = 0;

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main entry point for SCM
//
//  History:    1-18-96   stevebl   Created
//
//----------------------------------------------------------------------------
void _cdecl RealMain( int argc, char ** argv )
{
    HRESULT     hr;
    MSG         msg;

    if ( (argc > 1) &&
         ((strcmp(argv[1],"-?") == 0) || (strcmp(argv[1],"/?") == 0)) )
        PrintUsageAndExit();

    if ( (argc > 1) && (strcmp(argv[1],"-r") == 0) )
    {
        DebuggerType    eDebug = same_debugger;
        int             n;

        n = 2;

        if ( n < argc )
        {
            if (strcmp(argv[n],"-d") == 0)
                eDebug = windbg_debugger;
            else if (strcmp(argv[n],"-n") == 0 )
                eDebug = ntsd_debugger;
            else if (strcmp(argv[n],"-x") == 0 )
                eDebug = clear_debugger;
        }

        if ( hr = InitializeRegistry( eDebug ) )
            printf("InitializeRegistry failed with %08x\n", hr);
        else
            printf("Registry updated successfully.\n");

        return;
    }

    // Started manually.  Don't go away.
    if ( (argc == 1) && ! fStartedAsService )
        ObjectCount = 1;

    if ( ! fStartedAsService )
    {
        if ( (argc >= 3 && strcmp(argv[2], "-Embedding") == 0) )
            uClassIndex = argv[1][0] - '0';
        else
            uClassIndex = 0;
    }

    if ( fStartedAsService )
    {
        uClassIndex = 8;

#ifdef NT351
        hr = E_FAIL;
#else
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#endif
    }
    else
    {
#ifdef FREETHREADED
        hFreeThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
#else
        hr = CoInitialize(NULL);
#endif
    }

    if ( FAILED(hr) )
    {
        printf( "Server: CoInitialize failed(%x)\n", hr );
        return;
    }

    if (0 == uClassIndex || 2 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActLocal,
    				(IUnknown *)new FactoryLocal(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleLocal );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 3 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActRemote,
    				(IUnknown *)new FactoryRemote(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleRemote );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 4 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActAtStorage,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleAtStorage );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 6 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActPreConfig,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandlePreConfig );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
                CoRevokeClassObject( RegHandleAtStorage );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 7 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActRunAsLoggedOn,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleRunAsLoggedOn );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
                CoRevokeClassObject( RegHandleAtStorage );
                CoRevokeClassObject( RegHandlePreConfig );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 9 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActServerOnly,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleServerOnly );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
                CoRevokeClassObject( RegHandleAtStorage );
                CoRevokeClassObject( RegHandlePreConfig );
                CoRevokeClassObject( RegHandleRunAsLoggedOn );
            }
            CoUninitialize();
            return;
        }
    }

    if (fStartedAsService)
    {
        hr = CoRegisterClassObject( CLSID_ActService,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleService );

        if ( FAILED(hr) )
        {
            CoUninitialize();
            return;
        }

        WaitForSingleObject(hStopServiceEvent, INFINITE);
    }
    else
    {
#ifdef FREETHREADED
        WaitForSingleObject(hFreeThreadEvent, INFINITE);
        //
        // Make sure the thread who signaled the event executes for a while
        // before we exit.
        //
        Sleep(100);
#else
        // Only do message loop if apartment threaded non-service.
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
#endif
    }

    CoUninitialize();

    return;
}

int gargc;
char * gargv[100];

BOOL UpdateStatus(DWORD dwState)
{
    if (SERVICE_RUNNING == SStatus.dwCurrentState  &&
        SERVICE_START_PENDING == dwState)
    {
        return(TRUE);
    }

    SStatus.dwCurrentState = dwState;
    if (SERVICE_START_PENDING == dwState ||
        SERVICE_STOP_PENDING == dwState)
    {
        SStatus.dwCheckPoint++;
        SStatus.dwWaitHint = 1;
    }
    else
    {
        SStatus.dwCheckPoint = 0;
        SStatus.dwWaitHint = 0;
    }

    return(SetServiceStatus(hService, &SStatus));
}

DWORD StartMyMain(void * pArg)
{
    // reconstruct the command line args and call the real main
    RealMain(gargc, gargv);
    UpdateStatus(SERVICE_STOPPED);
    return(0);
}

void Handler(DWORD fdwControl)
{
    switch (fdwControl)
    {
    case SERVICE_CONTROL_STOP:
        UpdateStatus(SERVICE_STOP_PENDING);
        SetEvent(hStopServiceEvent);
        break;
    case SERVICE_CONTROL_INTERROGATE:
        UpdateStatus(SERVICE_RUNNING);
        break;
    default:
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ServiceMain
//
//  Synopsis:   main entry point for service
//
//  History:    1-18-96   stevebl   Created
//
//----------------------------------------------------------------------------

void ServiceMain(DWORD argc, LPTSTR * argv)
{
    fStartedAsService = TRUE;

    // register the service handler
    hService = RegisterServiceCtrlHandler(ServiceName, Handler);

    if (!hService)
        return;

    SStatus.dwServiceType               = SERVICE_WIN32_OWN_PROCESS |
                                          SERVICE_INTERACTIVE_PROCESS,
    SStatus.dwControlsAccepted          = SERVICE_CONTROL_STOP |
                                          SERVICE_CONTROL_INTERROGATE;
    SStatus.dwWin32ExitCode             = NO_ERROR;
    SStatus.dwServiceSpecificExitCode   = 0;
    SStatus.dwCheckPoint                = 0;
    SStatus.dwWaitHint                  = 0;

    if (!UpdateStatus(SERVICE_START_PENDING))
        return;

    // create an event to signal when the service is to stop
    hStopServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hStopServiceEvent)
    {
        return;
    }

    UpdateStatus(SERVICE_RUNNING);

    StartMyMain( NULL );
}

void _cdecl main( int argc, char ** argv)
{
    if (argc > 1 && strcmp(argv[1], "8") == 0)
    {
        gargc = argc;

        // save the command line arguments
        gargc = (int) argc;
        if (gargc > 100)
        {
            gargc = 100;
        }
        for (int k = 1; k <= gargc; k++)
        {
            gargv[k-1] = (char *) malloc(strlen(argv[k-1]) + 1);
            strcpy(gargv[k-1], argv[k-1]);
        }

        // Start as a service
        SERVICE_TABLE_ENTRY ServiceStart[2];
        ServiceStart[0].lpServiceName = ServiceName;
        ServiceStart[0].lpServiceProc = ServiceMain;
        ServiceStart[1].lpServiceName = NULL;
        ServiceStart[1].lpServiceProc = NULL;

        if (!StartServiceCtrlDispatcher (ServiceStart))
        {
            ExitProcess(GetLastError());
        }
        ExitProcess(0);
    }
    else
    {
        // start as a regular app
        RealMain(argc, argv);
    }
}


long InitializeRegistry( DebuggerType eDebugServer )
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hActKey;
    HKEY    hDebugKey;
    HANDLE  hFile;
    TCHAR   Path[256];
    TCHAR * pwszServerExe;
    TCHAR * pwszDebuggerName;
    DWORD   DebugFlags;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return ERROR_BAD_PATHNAME;

    hFile = CreateFile( AtStorageFileName,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        0,
                        0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("Couldn't create file %ws\n", AtStorageFileName );
        return GetLastError();
    }

    CloseHandle( hFile );

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &ghClsidRootKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("APPID"),
                              0,
                              KEY_ALL_ACCESS,
                              &ghAppIDRootKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    DeleteClsidKey( ClsidGoober32String );
    DeleteClsidKey( ClsidActLocalString );
    DeleteClsidKey( ClsidActRemoteString );
    DeleteClsidKey( ClsidActAtStorageString );
    DeleteClsidKey( ClsidActInprocString );
    DeleteClsidKey( ClsidActPreConfigString );
    DeleteClsidKey( ClsidActRunAsLoggedOnString );
    DeleteClsidKey( ClsidActServiceString );
    DeleteClsidKey( ClsidActServerOnlyString );

    //
    // Local CLSID entries.
    //

    _tcscat(Path, TEXT(" 2"));

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActLocalString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActLocalString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Remote CLSID entries.
    //

    Path[_tcslen(Path)-1] = TEXT('3');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActRemoteString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRemoteString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // AtStorage CLSID entries.
    //

    Path[_tcslen(Path)-1] = TEXT('4');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActAtStorageString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActAtStorageString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // RunAs CLSID entries.'
    //

    Path[_tcslen(Path)-1] = TEXT('6');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActPreConfigString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDRegKeyAndNamedValue(
                    ClsidActPreConfigString,
                    TEXT("RunAs"),
                    UserName,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;


    RegStatus = SetAppIDSecurity( ClsidActPreConfigString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if (!SetPassword(ClsidActPreConfigString, Password))
        return(FALSE);

    if (!AddBatchPrivilege( UserName ) )
        return(FALSE);

    //
    // RunAs logged on user CLSID entries.
    //

    Path[_tcslen(Path)-1] = TEXT('7');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActRunAsLoggedOnString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDRegKeyAndNamedValue(
                    ClsidActRunAsLoggedOnString,
                    TEXT("RunAs"),
                    TEXT("Interactive User"),
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRunAsLoggedOnString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Service CLSID entries.
    //

    RegStatus = SetAppIDRegKeyAndNamedValue(
                    ClsidActServiceString,
                    TEXT("LocalService"),
                    ServiceName,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServiceString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // Get the services key
    HKEY hServices;
    RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Services"),
                              0,
                              KEY_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                              &hServices );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    Path[_tcslen(Path)-1] = TEXT('8');


    if (!InstallService(Path))
        return TRUE;

    //
    // Server only CLSID entry.
    //

    Path[_tcslen(Path)-1] = TEXT('9');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActServerOnlyString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServerOnlyString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;


    //
    // Add entries to launch server in debugger.
    //

    if ( eDebugServer == same_debugger )
        return ERROR_SUCCESS;

    Path[_tcslen(Path)-2] = 0;
    pwszServerExe = Path + _tcslen(Path);
    while ( (pwszServerExe > Path) && (pwszServerExe[-1] != TEXT('\\')) )
        pwszServerExe--;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
                    0,
                    KEY_ALL_ACCESS,
                    &hDebugKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hDebugKey,
                    TEXT("Image File Execution Options"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hDebugKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( eDebugServer == clear_debugger )
    {
        RegDeleteKey( hDebugKey, pwszServerExe );
        return ERROR_SUCCESS;
    }

    RegStatus  = RegCreateKeyEx(
                    hDebugKey,
                    pwszServerExe,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hDebugKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( eDebugServer == ntsd_debugger )
    {
        pwszDebuggerName = TEXT("ntsd.exe -d");
    }
    else
    {
        pwszDebuggerName = TEXT("windbg.exe");
    }

    DebugFlags = 0x10f0;

    RegStatus =  RegSetValueEx(
                    hDebugKey,
                    TEXT("Debugger"),
                    0,
                    REG_SZ,
                    (const BYTE *)pwszDebuggerName,
                    (_tcslen(pwszDebuggerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hDebugKey,
                    TEXT("GlobalFlag"),
                    0,
                    REG_DWORD,
                    (const BYTE *)&DebugFlags,
                    sizeof(DWORD) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long SetClsidRegKeyAndStringValue(
    TCHAR * pwszClsid,
    TCHAR * pwszKey,
    TCHAR * pwszValue,
    HKEY *  phClsidKey,
    HKEY *  phNewKey )
{
    long    RegStatus;
    DWORD   Disposition;
    HKEY    hClsidKey;

    if ( phClsidKey )
        *phClsidKey = 0;

    if ( phNewKey )
        *phNewKey = 0;

    RegStatus  = RegCreateKeyEx(
                    ghClsidRootKey,
                    pwszClsid,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( phClsidKey )
        *phClsidKey = hClsidKey;

    return SetRegKeyAndStringValue(
                hClsidKey,
                pwszKey,
                pwszValue,
                phNewKey );
}

long SetAppIDRegKeyAndNamedValue(
    TCHAR * pwszAppID,
    TCHAR * pwszKey,
    TCHAR * pwszValue,
    HKEY *  phClsidKey )
{
    long    RegStatus;
    DWORD   Disposition;
    HKEY    hClsidKey;

    if ( phClsidKey )
        *phClsidKey = 0;

    // first, make sure the clsid has appid={appid}
    RegStatus  = RegCreateKeyEx(
                    ghClsidRootKey,
                    pwszAppID,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  SetNamedStringValue(
                hClsidKey,
                TEXT("AppID"),
                pwszAppID );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    ghAppIDRootKey,
                    pwszAppID,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( phClsidKey )
        *phClsidKey = hClsidKey;

    return SetNamedStringValue(
                hClsidKey,
                pwszKey,
                pwszValue );
}

long SetNamedStringValue(
    HKEY    hKey,
    TCHAR * pwszKey,
    TCHAR * pwszValue )
{
    long    RegStatus;
    DWORD   Disposition;

    RegStatus =  RegSetValueEx(
                    hKey,
                    pwszKey,
                    0,
                    REG_SZ,
                    (const BYTE *)pwszValue,
                    (_tcslen(pwszValue) + 1) * sizeof(TCHAR) );

    return RegStatus;
}

long SetRegKeyAndStringValue(
    HKEY    hKey,
    TCHAR * pwszKey,
    TCHAR * pwszValue,
    HKEY *  phNewKey )
{
    long    RegStatus;
    DWORD   Disposition;
    HKEY    hNewKey;

    if ( phNewKey )
        *phNewKey = 0;

    RegStatus  = RegCreateKeyEx(
                    hKey,
                    pwszKey,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hNewKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hNewKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)pwszValue,
                    (_tcslen(pwszValue) + 1) * sizeof(TCHAR) );

    if ( phNewKey )
        *phNewKey = hNewKey;

    return RegStatus;
}

BOOL InstallService(TCHAR * Path)
{
#ifndef CHICO
    SC_HANDLE hManager = OpenSCManager(
                                NULL,
                                NULL,
                                SC_MANAGER_ALL_ACCESS);
    if (NULL == hManager)
    {
        printf("OpenSCManager returned %d\n",GetLastError());
        return(FALSE);
    }

    SC_HANDLE hService = OpenService(
                                hManager,
                                ServiceName,
                                SERVICE_ALL_ACCESS);

    if (NULL != hService)
    {
        if (!ChangeServiceConfig(
                            hService,
                            SERVICE_WIN32_OWN_PROCESS |
                                SERVICE_INTERACTIVE_PROCESS,
                            SERVICE_DEMAND_START,
                            SERVICE_ERROR_NORMAL,
                            Path,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            ServiceDisplayName
                                )
            )
        {
            printf("ChangeService returned %d\n",GetLastError());
            CloseServiceHandle(hService);
            CloseServiceHandle(hManager);
            return(FALSE);
        }
        return(TRUE);
    }

    hService = CreateService(
                    hManager,
                    ServiceName,
                    ServiceDisplayName,
                    SERVICE_ALL_ACCESS,
                    SERVICE_WIN32_OWN_PROCESS |
                        SERVICE_INTERACTIVE_PROCESS,
                    SERVICE_DEMAND_START,
                    SERVICE_ERROR_NORMAL,
                    Path,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
    if (NULL == hService)
    {
        printf("CreateService returned %d\n",GetLastError());
        CloseServiceHandle(hManager);
        return(FALSE);
    }

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
#endif
    return(TRUE);
}

void PrintUsageAndExit()
{
    printf("Usage : actsrv [-r [-d | -n | -x]]\n");
    printf("\t-r : Make necessary registry changes.\n");
    printf("\t-d : Register server to start in windbg.\n");
    printf("\t-n : Register server to start with ntsd -d.\n");
    printf("\t-x : Register server and clear debugger.\n");

    ExitProcess(0);
}

void ShutDown()
{
    // The last object has been destroyed.
    if (fStartedAsService)
    {
        CoRevokeClassObject( RegHandleService );
    }

    switch( uClassIndex )
    {
    case 0 :
        CoRevokeClassObject( RegHandleLocal );
        CoRevokeClassObject( RegHandleRemote );
        CoRevokeClassObject( RegHandleAtStorage );
        CoRevokeClassObject( RegHandlePreConfig );
        CoRevokeClassObject( RegHandleRunAsLoggedOn );
        CoRevokeClassObject( RegHandleServerOnly );
        break;
    case 2:
        CoRevokeClassObject( RegHandleLocal );
        break;
    case 3:
        CoRevokeClassObject( RegHandleRemote );
        break;
    case 4:
        CoRevokeClassObject( RegHandleAtStorage );
        break;
    case 6:
        CoRevokeClassObject( RegHandlePreConfig );
        break;
    case 7 :
        CoRevokeClassObject( RegHandleRunAsLoggedOn );
        break;
    case 9 :
        CoRevokeClassObject( RegHandleServerOnly );
        break;
    }

    if (fStartedAsService)
    {
        SetEvent(hStopServiceEvent);
    }
    else
    {
#ifdef FREETHREADED 
        SetEvent(hFreeThreadEvent);
#else
        PostQuitMessage(0);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\srvcore\factory.cxx ===
/*
 *  factory.cxx
 */

#include "server.hxx"
#include "factory.hxx"
#include "classes.hxx"

//
// MyFactory methods.
//
MyFactory::MyFactory()
{
    Refs = 0;
}

MyFactory::~MyFactory()
{
}

HRESULT STDMETHODCALLTYPE
MyFactory::QueryInterface (
    REFIID  iid,
    void ** ppv )
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;

    if ((memcmp(&iid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&iid, &IID_IClassFactory, sizeof(IID)) == 0))
    {
        *ppv = this;
	AddRef();
	hr = S_OK;
    }

    return hr;
}

ULONG STDMETHODCALLTYPE
MyFactory::AddRef()
{
    Refs++;
    return Refs;
}

ULONG STDMETHODCALLTYPE
MyFactory::Release()
{
    unsigned long   Count;

    Count = --Refs;

    if ( Count == 0 )
    {
        delete this;
    }

    return Count;
}

HRESULT STDMETHODCALLTYPE
MyFactory::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    // Should never be called.
    *ppv = 0;
    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE
MyFactory::LockServer(
    BOOL    fLock )
{
    return S_OK;
}

//
// FactoryLocal methods.
//
HRESULT STDMETHODCALLTYPE
FactoryLocal::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( LOCAL );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}

//
// FactoryRemote methods.
//
HRESULT STDMETHODCALLTYPE
FactoryRemote::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( REMOTE );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}

//
// FactoryRemote methods.
//
HRESULT STDMETHODCALLTYPE
FactoryAtStorage::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( ATBITS );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}

//
// FactoryInproc methods.
//
HRESULT STDMETHODCALLTYPE
FactoryInproc::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( INPROC );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\printf.c ===
/***
*printf.c - print formatted to stdout
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4printf() - print formatted data to stdout
*	defines w4vprintf() - print formatted output to stdout, get data
*			      from an argument ptr instead of explicit args.
*******************************************************************************/

#ifdef FLAT
#include "dprintf.h"		// function prototypes

#define _W4PRINTF_
#include "printf.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\tstsvc\pswrd.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <stdio.h>

BOOL SetPassword(WCHAR * szCID, WCHAR * szPw)
{
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    LSA_HANDLE hPolicy;
    LSA_UNICODE_STRING sKey;
    LSA_UNICODE_STRING sPassword;
    WCHAR szKey[256];

    swprintf(szKey, L"SCM:%s", szCID);
    sKey.Length = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.Buffer = szKey;
    sPassword.Length = (wcslen(szPw) + 1) * sizeof(WCHAR);
    sPassword.MaximumLength = 80 * sizeof(WCHAR);
    sPassword.Buffer = szPw;

    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);

    // open the local security policy
    if (!NT_SUCCESS(
            LsaOpenPolicy(
                NULL,
                &sObjAttributes,
                POLICY_CREATE_SECRET,
                &hPolicy)))
    {
        printf("LsaOpenPolicy failed with %d\n",GetLastError());
        return(FALSE);
    }

    // store private data
    if (!NT_SUCCESS(
            LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        printf("LsaStorePrivateData failed with %d\n",GetLastError());
        return(FALSE);
    }

    LsaClose(hPolicy);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\tstsvc\client.cxx ===
/*
 * client.cxx
 */

#include "client.hxx"

#define MIN_TEST_NUMBER         1
#define MAX_TEST_NUMBER         27

BOOL UnimplementedTest();
BOOL UnsupportedTest();
BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * szServerName, int n, DWORD ctxt);

BOOL CGCOLocalEXE();
BOOL CGCOExplicitActivator();
BOOL CILocalDLL();
BOOL CILocalEXE();
BOOL CIExplicitActivator();
BOOL CI3LocalEXE();
BOOL CI3ExplicitActivator();
BOOL CGIFFLocalEXE();
BOOL CGIFFExplicitActivator();
BOOL CGIFFRegistryActivator();
BOOL CGIFFAtStorageActivator();
BOOL IMBLocalEXE();
BOOL IMBLocalService();
BOOL IMBAtStorageActivator();
BOOL IMBAtStorageService();
BOOL IMBAtStoragePreCon();
BOOL IMBAtStorageUser();
BOOL CIFromStgLocalEXE();
BOOL CIFromStgActivator();
BOOL CICustomLocalDLL();
BOOL CICustomLocalEXE();
BOOL CILocalPreCon();
BOOL CIExplicitPreCon();
BOOL CILocalUser();
BOOL CIExplicitUser();
BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();
BOOL CILocalService();
BOOL CIExplicitService();

BOOL MyStartService(WCHAR * wszServiceName, WCHAR *pwszRegServiceArgs);
BOOL MyStopService(WCHAR * wszServiceName);

#ifdef NO_DCOM
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        UnsupportedTest,
        CILocalDLL,
        CILocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest
/* New tests
        UnsupportedTest,
        UnsupportedTest,
end new tests */
        CI3LocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        IMBLocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        NULL
    };
#else
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        CGCOExplicitActivator,
        CILocalDLL,
        CILocalEXE,
        CIExplicitActivator,
        CILocalPreCon,
        CIExplicitPreCon,
        CILocalUser,
        CIExplicitUser,
        CILocalService,
        CIExplicitService,
/* new tests
        CILocalPreConACL,
        CIExplicitPreConACL,
end new tests */
        CI3LocalEXE,
        CI3ExplicitActivator,
        CICustomLocalDLL,
        CICustomLocalEXE,
        CGIFFLocalEXE,
        CGIFFExplicitActivator,
        CGIFFRegistryActivator,
        CGIFFAtStorageActivator,
        IMBLocalEXE,
        IMBLocalService,
        IMBAtStorageActivator,
        IMBAtStorageService,
        IMBAtStoragePreCon,
        IMBAtStorageUser,
        CIFromStgLocalEXE,
        CIFromStgActivator,
        NULL
    };
#endif // NO_DCOM

char *  TestName[] =
        {
            NULL,
           "CoGetClassObject                    local       EXE",
           "CoGetClassObject                    explicit    activator",
           "CoCreateInstance                    local       DLL",
           "CoCreateInstance                    local       EXE",
           "CoCreateInstance                    explicit    activator",
           "CoCreateInstance                    local       pre-configured",
           "CoCreateInstance                    explicit    pre-configured",
           "CoCreateInstance                    local       user",
           "CoCreateInstance                    explicit    user",
           "CoCreateInstance                    local       service",
           "CoCreateInstance                    explicit    service",
/* new tests
           "CoCreateInstance                    local       pre-configured ACL",
           "CoCreateInstance                    explicit    pre-configured ACL",
end new tests */
           "CoCreateInstance (3 IIDs)           local       EXE",
           "CoCreateInstance (3 IIDs)           explicit    activator",
           "CoCreateInstance from custom itf.   local       DLL",
           "CoCreateInstance from custom itf.   local       EXE",
           "CoGetInstanceFromFile               local       EXE",
           "CoGetInstanceFromFile               explicit    activator",
           "CoGetInstanceFromFile               registry    activator",
           "CoGetInstanceFromFile               AtStorage   activator",
           "IMoniker::BindToObject              local       EXE",
           "IMoniker::BindToObject              local       service",
           "IMoniker::BindToObject              AtStorage   activator",
           "IMoniker::BindToObject              AtStorage   service",
           "IMoniker::BindToObject              AtStorage   pre-configured",
           "IMoniker::BindToObject              AtStorage   user",
           "CoGetInstanceFromIStorage           local       EXE",
           "CoGetInstanceFromIStorage           explicit    activator",
           NULL
        };

char    RunTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            YES,
            // CoCreateInstance
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
/* new tests
            YES,
            YES,
end new tests */
            // CoCreateInstance (3 IIDs)
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            YES,
            YES,
            YES,
            // IMoniker:Bind
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            -1
         };

char    RunLocalTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            NO,
            // CreateInstance
            YES,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
/* new tests
            YES,
            NO,
end new tests */
            // CreateInstance (3 IIDs)
            YES,
            NO,
            // CreateInstance from custom Itf.
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            NO,
            NO,
            NO,
            // IMoniker:Bind
            YES,
            YES,
            NO,
            NO,
            NO,
            NO,
            // CoGetInstanceFromIStorage
            YES,
            NO,
            -1
         };

WCHAR ServerName[32];

WCHAR RemoteFileName[256];
WCHAR * LocalFileName = L"c:\\acttest.dat";
WCHAR * StorageName = L"c:\\acttest.stg";

LARGE_INTEGER liPerfFreq;
LARGE_INTEGER liStart;
LARGE_INTEGER liStop;
LARGE_INTEGER liElapsedTime;

#define RESET_CLOCK liElapsedTime.LowPart = liElapsedTime.HighPart = 0
#define START_CLOCK QueryPerformanceCounter(&liStart)
#define STOP_CLOCK      QueryPerformanceCounter(&liStop); \
                        liElapsedTime.QuadPart += liStop.QuadPart - liStart.QuadPart
#define DUMP_CLOCK DisplayElapsedTime()
#define START_LOOP for (unsigned sl_n = uIterations+1; sl_n--;){
#define STOP_LOOP if (uIterations == sl_n ) RESET_CLOCK;}
#define SLEEP_IF_LOOPING if (sl_n && !gfHoldServer) Sleep(1000)

unsigned uIterations = 0;

BOOL    gfRegister = TRUE;
BOOL    gfHoldServer = FALSE;
BOOL    gfLocal = FALSE;
BOOL    gfNolocal = FALSE;
BOOL    gfSpecificTest = FALSE;

DWORD dwWaitHint = 0;

void DisplayElapsedTime(void)
{
    LONGLONG    MicroPerIter;

    liElapsedTime.QuadPart /= uIterations;

    MicroPerIter = liElapsedTime.QuadPart * 1000000;
    MicroPerIter /= liPerfFreq.QuadPart;

    printf( "Time: %d microseconds per iteration", (DWORD) MicroPerIter );
}

BOOL AllLocal()
{
    for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x]  &&  !RunLocalTest[x])
            return(FALSE);
    }
    return(TRUE);
}

extern WCHAR ServiceName[];

void _cdecl main( int argc, char ** argv )
{
    HRESULT         HResult;
    HANDLE          hFile;
    int             n;
    BOOL f;

    if (argc > 1)
    {
        if (argc == 3 && (!strcmp(argv[1], "-t")))
        {
            dwWaitHint = atoi(argv[2]);
        }
        else
        {
            printf("usage: %s [-t #]\n    #   number of milliseconds between QueryServiceStatus calls\n", argv[0]);
            return;
        }
    }
    if ((!QueryPerformanceFrequency(&liPerfFreq)) && uIterations > 0)
    {
        printf("No high performance counter.\nTests cannot be timed.\nAborting.\n");
        return;
    }

    uIterations = 1;

    printf("Starting service...\n");
    RESET_CLOCK;
    START_CLOCK;
    f = MyStartService(L"ActTestService", L"");
    STOP_CLOCK;
    if (f)
        printf("succeeded - ");
    else
        printf("failed - ");
    DUMP_CLOCK;
    printf("\n");

    printf("Stopping service...\n");
    RESET_CLOCK;
    START_CLOCK;
    f = MyStopService(L"ActTestService");
    STOP_CLOCK;
    if (f)
        printf("succeeded - ");
    else
        printf("failed - ");
    DUMP_CLOCK;
    printf("\n");

    return;
#ifndef NO_DCOM
    if ( argc == 1 )
        PrintUsageAndExit( FALSE );
#endif // NO_DCOM

    if ( argc > 1 && strcmp(argv[1],"-?") == 0 )
        PrintUsageAndExit( TRUE );

    n = 1;

    while ( (n < argc) && (*argv[n] == '-') )
    {
        if ( (n < argc) && strcmp(argv[n],"-local") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfLocal = TRUE;
            memcpy(RunTest, RunLocalTest, MAX_TEST_NUMBER + MIN_TEST_NUMBER);
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-nolocal") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfNolocal = TRUE;
            for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
            {
                RunTest[x] = !RunLocalTest[x];
            }
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-noreg") == 0 )
        {
            gfRegister = FALSE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-hold") == 0 )
        {
            gfHoldServer = TRUE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-n") == 0 )
        {
            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            uIterations = atoi(argv[n++]);
        }

        if ( (n < argc) && strcmp(argv[n],"-t") == 0 )
        {
            long    TestNum1, TestNum2;

            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            TestNum1 = atoi(argv[n++]);

            if ( (n < argc) && ((TestNum2 = atoi(argv[n])) != 0) )
                n++;
            else
                TestNum2 = TestNum1;

            if ( (TestNum1 < MIN_TEST_NUMBER) || (TestNum2 > MAX_TEST_NUMBER) )
            {
                printf( "Test number(s) must be between %d and %d.\n",
                        MIN_TEST_NUMBER,
                        MAX_TEST_NUMBER );
                return;
            }

            if ( TestNum1 > TestNum2 )
            {
                printf( "Second test number must be greater than the first.\n" );
                return;
            }

            if (!gfSpecificTest)
            {
                gfSpecificTest = TRUE;
                // only do this the first time -t is found on the command line
                memset(RunTest,NO,sizeof(RunTest));
            }
            memset(&RunTest[TestNum1],YES,sizeof(char)*(TestNum2-TestNum1+1));
        }
    }

#ifndef NO_DCOM
    if ( n != argc - 1  && !AllLocal())
    {
        printf("ERROR - Selected tests require a server name.\n");
        ExitThread(0);
    }

    if ( n < argc )
    {
        MultiByteToWideChar( CP_ACP,
                             0,
                             argv[n],
                             -1,
                             ServerName,
                             sizeof(ServerName) / sizeof(WCHAR) );
    }
    else
        ServerName[0] = 0;
#endif // NO_DCOM

    hFile = CreateFile(
                LocalFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                0,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("CreateFile failed while creating local file: %d\n", GetLastError());
        return;
    }

    CloseHandle( hFile );

#ifndef NO_DCOM
    if ( ServerName[0] != 0 )
    {
        RemoteFileName[0] = 0;

        if ( ServerName[0] != L'\\' )
            wcscat( RemoteFileName, L"\\\\" );

        wcscat( RemoteFileName, ServerName );
        wcscat( RemoteFileName, L"\\c$\\acttest.dat" );

        hFile = CreateFile(
                    RemoteFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    0,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    0 );

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            printf("CreateFile failed while creating remote file: %d\n", GetLastError());
            return;
        }

        CloseHandle( hFile );
    }
#endif // NO_DCOM

    HResult = CoInitialize(NULL);

    if( FAILED(HResult) )
    {
        printf( "Client CoInitialize failed Ox%x!\n", HResult );
        return;
    }

    if ((!QueryPerformanceFrequency(&liPerfFreq)) && uIterations > 0)
    {
        printf("No high performance counter.\nTests cannot be timed.\nAborting.\n");
    }
    else
    {
        if ( ! Tests() )
            printf("\nTests FAILED\n");
        else
            printf("\nTests SUCCEEDED\n");
    }

    CoUninitialize();

    DeleteFile( LocalFileName );
#ifndef NO_DCOM
    DeleteFile( RemoteFileName );
#endif // NO_DCOM
}

BOOL Tests()
{
    HRESULT         HResult;
    long            RegStatus;

    if (gfRegister)
    {
        DeleteClsidKey( ClsidGoober32String );
        DeleteClsidKey( ClsidActLocalString );
        DeleteClsidKey( ClsidActRemoteString );
        DeleteClsidKey( ClsidActAtStorageString );
        DeleteClsidKey( ClsidActInprocString );
        DeleteClsidKey( ClsidActPreConfigString );
        DeleteClsidKey( ClsidActRunAsLoggedOnString );
        DeleteClsidKey( ClsidActServiceString );
        DeleteClsidKey( ClsidActServerOnlyString );

        if ( (RegStatus = InitializeRegistryForInproc()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForInproc failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForLocal()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForLocal failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForCustom()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForCustom failed %d.\n", RegStatus);
            return FALSE;
        }
    #ifndef NO_DCOM
        if ( (RegStatus = InitializeRegistryForRemote()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForRemote failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForService()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForService failed %d.\n", RegStatus);
            return FALSE;
        }
    #endif // NO_DCOM
    }
    BOOL fAllTests = TRUE;

    for (int x = MIN_TEST_NUMBER; x <= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x])
        {
            printf("\nTest %2d: %s\n",x, TestName[x]);
            // prime the system once to ensure the test is fully cached
            if (rgTest[x]())
            {
                printf("PASSED");
                if (uIterations)
                {
                    printf(" - ");
                    DUMP_CLOCK;
                }
                printf("\n");
            }
            else
            {
                printf("FAILED\n");
                fAllTests = FALSE;
            }

        }
    }

    return(fAllTests);
}

void PrintUsageAndExit( BOOL bListTests )
{
#ifdef NO_DCOM
    printf("Usage : %s [-hold] [-noreg] [-n #] [-t # [#]]\n", "actclt");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#else
    printf("Usage : %s [-hold] [-noreg] [[-local] | [-nolocal]] [-n #] [-t # [#]] [server_name]\n", "actclt");
    printf("\t-hold    : Hold the server up during all iterations.\n");
    printf("\t-local   : Run only local activation tests.\n");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-nolocal : Run only remote activation tests.\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#endif // NO_DCOM

    if ( bListTests )
    {
        long    n;

        printf("\nTests :\n");
        printf("\t # Method                              Location    Security\n");
        printf("\t-- ----------------------------------- ----------- --------------\n");

        for ( n = MIN_TEST_NUMBER; n <= MAX_TEST_NUMBER; n++ )
        {
            printf("\t%2d %s\n", n, TestName[n]);
        }
    }

    ExitThread(0);
}

void * __RPC_API
MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

void __RPC_API
MIDL_user_free(void * vp)
{
    free(vp);
}

BOOL StampFileWithCLSID(WCHAR * szFilename, CLSID & clsid)
{
    HRESULT hr;
    IStorage * pStg;

    hr = StgCreateDocfile(
                szFilename,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStg);

    if (FAILED (hr))
    {
        printf("StgCreateDocfile returned 0x%x\n", hr);
        return(FALSE);
    }

    hr = WriteClassStg(pStg, clsid);

    pStg->Release();

    if (FAILED (hr))
    {
        printf("WriteClassStg returned 0x%x\n", hr);
        return(FALSE);
    }

    return(TRUE);
}

//
// Test Procedures:
//

BOOL UnimplementedTest()
{
    printf("Not implemented at this time.\n");
    return(TRUE);
}

BOOL UnsupportedTest()
{
    printf("Not supported by this version.\n");
    return(TRUE);
}

BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * szServerName, int n, DWORD ctxt)
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    if (szServerName)
    {
        memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
        ServerInfo.pwszName = szServerName;
        pServerInfo = &ServerInfo;
    }
    else
    {
        pServerInfo = NULL;
    }

    MULTI_QI QIStruct[10];
    int x;
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    for (x = n; x--;)
    {
        QIStruct[x].pItf = NULL;
        QIStruct[x].pIID = (IID *) &iid;
    }


    START_CLOCK;
    hr = CoCreateInstanceEx(
        clsid,
        NULL,
        ctxt,
        pServerInfo,
        n,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    for (x = 0; x < n; x++)
    {
        if (FAILED(QIStruct[x].hr))
        {
            printf("CoCreateInstanceEx returned 0x%x for interface %d\n",
                QIStruct[x].hr, x);
            fReturn = FALSE;
        }
        else
            QIStruct[x].pItf->Release();
    }
    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CGCOLocalEXE()
{
    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_LOCAL_SERVER,	
        NULL,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}

#ifndef NO_DCOM
BOOL CGCOExplicitActivator()
{
    COSERVERINFO   ServerInfo;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;

    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_REMOTE_SERVER,	
        &ServerInfo,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}
#endif // NO_DCOM

#ifdef NO_DCOM
BOOL CILocalDLL()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActInproc,
        NULL,
        CLSCTX_INPROC_SERVER,	
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}

BOOL CILocalEXE()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActLocal,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else
BOOL CILocalDLL()
{
    return GenericCITest(CLSID_ActInproc, IID_IUnknown, NULL, 1, CLSCTX_INPROC_SERVER);
}

BOOL CILocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, ServerName, 1, CLSCTX_REMOTE_SERVER);
}
#endif // NO_DCOM

#ifdef NO_DCOM
// Pre-DCOM version of CI3LocalEXE which calls CoCreateInstance
// once followed by 2 calls to QueryInterface
// instead of calling CoCreateInstanceEx.
BOOL CI3LocalEXE()
{
    IUnknown * pUnknown;
    IUnknwon * punkHeld = NULL;
    IPersist * pPersist;
    IPersistFile * pPersistFile;

    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
            CLSID_ActLocal,
            NULL,
            CLSCTX_LOCAL_SERVER,
            IID_IUnknown,
            (void **) &pUnknown );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersist );
    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersistFile );
    STOP_CLOCK;

    pUnknown->Release();
    pPersist->Release();
    pPersistFile->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else // NO_DCOM

BOOL CI3LocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, NULL, 3, CLSCTX_LOCAL_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CI3ExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, ServerName, 3, CLSCTX_REMOTE_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CGIFFLocalEXE()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    STGM_READWRITE,
                    LocalFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFExplicitActivator()
{
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;

    MULTI_QI QIStruct[1];

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    &ServerInfo,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    RemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFRegistryActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    RemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFAtStorageActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActAtStorage,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    RemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}
#endif // NO_DCOM

BOOL IMBLocalEXE()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(LocalFileName, CLSID_ActLocal))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(LocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

#ifndef NO_DCOM
BOOL IMBLocalService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(LocalFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(LocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;
    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }
    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageActivator()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActAtStorage))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStoragePreCon()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActPreConfig))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageUser()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActRunAsLoggedOn))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgLocalEXE()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    IUnknown * punkHeld = NULL;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                StorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgActivator()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                StorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    &ServerInfo,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalDLL()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT     hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActInproc,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalEXE()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CILocalPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, ServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, ServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_LOCAL_SERVER,
        NULL,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CIExplicitService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;
    pServerInfo = &ServerInfo;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_REMOTE_SERVER,
        pServerInfo,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();

#define MAX_SERVICE_ARGS 10

BOOL MyStartService(WCHAR * wszServiceName, WCHAR *pwszRegServiceArgs)
{
    SC_HANDLE hSCManager;
    SC_HANDLE hService;
    WCHAR    *pwszServiceArgs = NULL;
    ULONG     cArgs = 0;
    WCHAR    *apwszArgs[MAX_SERVICE_ARGS];

    // Get a handle to the Service Control Manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, wszServiceName, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Formulate the arguments (if any)
            if (pwszRegServiceArgs)
            {
                UINT   k = 0;

                // Make a copy of the service arguments
                pwszServiceArgs = new WCHAR[(lstrlenW(pwszRegServiceArgs) + 1)];
                if (pwszServiceArgs == NULL)
                {
                    CloseServiceHandle(hService);
                    return FALSE;
                }
                lstrcpyW(pwszServiceArgs, pwszRegServiceArgs);

                // Scan the arguments
                do
                {
                    // Scan to the next non-whitespace character
                    while(pwszServiceArgs[k]  &&
                          (pwszServiceArgs[k] == L' '  ||
                           pwszServiceArgs[k] == L'\t'))
                    {
                        k++;
                    }

                    // Store the next argument
                    if (pwszServiceArgs[k])
                    {
                        apwszArgs[cArgs++] = &pwszServiceArgs[k];
                    }

                    // Scan to the next whitespace char
                    while(pwszServiceArgs[k]          &&
                          pwszServiceArgs[k] != L' '  &&
                          pwszServiceArgs[k] != L'\t')
                    {
                        k++;
                    }

                    // Null terminate the previous argument
                    if (pwszServiceArgs[k])
                    {
                        pwszServiceArgs[k++] = L'\0';
                    }
                } while(pwszServiceArgs[k]);
            }

            // Start the service
            if (StartService(hService, cArgs,
                               cArgs > 0 ? (LPCTSTR  *) apwszArgs : NULL))
            {
                SERVICE_STATUS ss;
                do
                {
                    QueryServiceStatus(hService, &ss);
                    if (dwWaitHint)
                    {
                        Sleep(dwWaitHint);
                    }
                    else
                        Sleep(ss.dwWaitHint);
                } while (ss.dwCurrentState == SERVICE_START_PENDING);

                CloseServiceHandle(hService);
                delete [] pwszServiceArgs;
                return TRUE;
            }
            else
            {
                CloseServiceHandle(hService);
                delete [] pwszServiceArgs;
            }
        }
        else
        {
            CloseServiceHandle(hSCManager);
        }
    }

    DWORD err = GetLastError();
    return FALSE;
}

BOOL MyStopService(WCHAR * wszServiceName)
{
    SC_HANDLE hSCManager;
    SC_HANDLE hService;
    SERVICE_STATUS ss;

    // Get a handle to the Service Control Manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, wszServiceName, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Stop the service
            if (ControlService(hService, SERVICE_CONTROL_STOP, &ss))
            {

                while (ss.dwCurrentState == SERVICE_STOP_PENDING)
                {
                    if (dwWaitHint)
                    {
                        Sleep(dwWaitHint);
                    }
                    else
                        Sleep(ss.dwWaitHint);
                    QueryServiceStatus(hService, &ss);
                };

                CloseServiceHandle(hService);
                return TRUE;
            }
            else
            {
                CloseServiceHandle(hService);
            }
        }
        else
        {
            CloseServiceHandle(hSCManager);
        }
    }

    DWORD err = GetLastError();
    return FALSE;
}

#endif // NO_DCOM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(WIN32)
#  ifndef WIN32
#    define WIN32
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>

#include <stdarg.h>
#include <stdio.h>


# include <dprintf.h>            // w4printf, w4dprintf prototypes
# include <debnot.h>
# ifdef FLAT
#   include <sem.hxx>
#   include <dllsem.hxx>
# endif // FLAT

extern "C"
{

# ifdef FLAT
#  undef FAR
#  undef NEAR
# else
#  define MessageBoxA MessageBox
# endif

# include <windows.h>
}


extern BOOL gfService = FALSE;

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
#if defined( FLAT )
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
#endif

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
# ifdef FLAT
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
# else  // FLAT
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
# endif // FLAT
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifdef FLAT
            DebugBreak();
#else
            _asm int 3;
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifdef FLAT
        DebugBreak();
#else
        _asm int 3;
#endif
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
                     //  Since this code is also used by SCM.EXE, we pass
                     //  in the following flag which causes Service pop ups
                     //  to appear on the desktop correctly

    if (gfService)
    {
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
    }
#endif // _CHICAGO_

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CDLLStaticMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
#if defined( FLAT )
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
#endif // FLAT
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
#ifdef FLAT
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  actually memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03d> ", pid, tid );
#endif
#endif // FLAT
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

#if defined( FLAT )
        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        mxs.Release();
#endif // FLAT
    }
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd;         /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth;       /* selected field with -- 0 means default */
    int fwide;
    int precision;      /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen;      /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;      /* non-zero = prodcue no output for this specifier */
    char *text;         /* pointer text to be printed, not zero terminated */
    int textlen;        /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif



/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\tstsvc\reg.cxx ===
//
// reg.cxx
//

#include "client.hxx"

BOOL SetPassword(WCHAR * szCID, WCHAR * szPw);

WCHAR * ServiceName = L"ActTestService";
WCHAR * ServiceDisplayName = L"ActTestService";
WCHAR * UserName = L"redmond\\oleuser";
WCHAR * Password = L"stocksplit";

long InitializeRegistryForLocal()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    WCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActLocalString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    L"LocalServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 2" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActLocalString,
                    (wcslen(ClsidActLocalString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActLocalString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForInproc()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    WCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActInprocString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    L"InprocServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrvd.dll" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"ThreadingModel",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Both",
                    (wcslen(L"Both") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

WCHAR * StringIidIGoober = L"{ffffffff-0000-0000-0000-000000000000}";

long InitializeRegistryForCustom()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    WCHAR       Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"Interface",
                              0,
                              KEY_ALL_ACCESS,
                              &hInterface );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    StringIidIGoober,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)L"IGoober",
                    (wcslen(L"IGoober") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    L"ProxyStubClsid32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)ClsidGoober32String,
                    (wcslen(ClsidGoober32String) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidGoober32String,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    L"InProcServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"goober.dll" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForRemote()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    WCHAR   Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRemote
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRemoteString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRemoteString,
                    (wcslen(ClsidActRemoteString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRemoteString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    L"AppID",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRemoteString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RemoteServerName",
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (wcslen(ServerName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActAtStorage
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActAtStorageString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActAtStorageString,
                    (wcslen(ClsidActAtStorageString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActAtStorageString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActAtStorageString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"ActivateAtStorage",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Y",
                    (wcslen(L"Y") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRunAsLoggedOnUser
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRunAsLoggedOnString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRunAsLoggedOnString,
                    (wcslen(ClsidActRunAsLoggedOnString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RemoteServerName",
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (wcslen(ServerName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;
    
    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    L"LocalServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 7" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RunAs",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Interactive User",
                    (wcslen(L"Interactive User") + 1) * sizeof(WCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // RunAs CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActPreConfigString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActPreConfigString,
                    (wcslen(ClsidActPreConfigString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActPreConfigString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActPreConfigString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RemoteServerName",
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (wcslen(ServerName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    L"LocalServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 6" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RunAs",
                    0,
                    REG_SZ,
                    (const BYTE *)UserName,
                    (wcslen(UserName) + 1) * sizeof(WCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if (!SetPassword(ClsidActPreConfigString, Password))
        return(FALSE);

    return ERROR_SUCCESS;
}

long InitializeRegistryForService()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    HKEY    hServices;
    WCHAR   Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    L"AppID",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
		    hClsidKey,
                    ClsidActServiceString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServiceString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActServiceString,
                    (wcslen(ClsidActServiceString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActServiceString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 8" );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"LocalService",
                    0,
                    REG_SZ,
                    (const BYTE *)ServiceName,
                    (wcslen(ServiceName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"ActivateAtStorage",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Y",
                    (wcslen(L"Y") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              L"SYSTEM\\CurrentControlSet\\Services",
                              0,
                              KEY_READ,
                              &hServices );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return InstallService(Path);
}

DWORD InstallService( WCHAR * Path )
{
    SC_HANDLE hManager;
    SC_HANDLE hService;

    hManager = OpenSCManager( NULL,
                              NULL,
                              SC_MANAGER_ALL_ACCESS );

    if ( ! hManager )
    {
        printf( "OpenSCManager returned %d\n", GetLastError() );
        return GetLastError();
    }

    hService = OpenService( hManager,
                            ServiceName,
                            SERVICE_ALL_ACCESS );

    if ( ! hService )
    {
        hService = CreateService(
                        hManager,
                        ServiceName,
                        ServiceDisplayName,
                        SERVICE_ALL_ACCESS,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        Path,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);
    }

    if ( ! hService )
    {
        printf( "CreateService returned %d\n", GetLastError() );
        CloseServiceHandle(hManager);
        return GetLastError();
    }

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\assert\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 WIN32
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <windows.h>
#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static HANDLE fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == INVALID_HANDLE_VALUE)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = GetStdHandle(ldummy)) == 0 || fh == INVALID_HANDLE_VALUE)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef WIN32
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\act\tstsvc\service.cxx ===
BOOL TimeStartService(WCHAR * wszServiceName, WCHAR *pwszRegServiceArgs, HANDLE *phProcess)
{
    SC_HANDLE hSCManager;
    SC_HANDLE hService;
    WCHAR    *pwszServiceArgs = NULL;
    ULONG     cArgs = 0;
    WCHAR    *apwszArgs[MAX_SERVICE_ARGS];

    *phProcess = NULL;

    // Get a handle to the Service Control Manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, wszServiceName, GENERIC_EXECUTE))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Formulate the arguments (if any)
            if (pwszRegServiceArgs)
            {
                UINT   k = 0;

                // Make a copy of the service arguments
                pwszServiceArgs = (WCHAR *) PrivMemAlloc(
                        (lstrlenW(pwszRegServiceArgs) + 1) * sizeof(WCHAR));
                if (pwszServiceArgs == NULL)
                {
                    CloseServiceHandle(hService);
                    return FALSE;
                }
                lstrcpyW(pwszServiceArgs, pwszRegServiceArgs);

                // Scan the arguments
                do
                {
                    // Scan to the next non-whitespace character
                    while(pwszServiceArgs[k]  &&
                          (pwszServiceArgs[k] == L' '  ||
                           pwszServiceArgs[k] == L'\t'))
                    {
                        k++;
                    }

                    // Store the next argument
                    if (pwszServiceArgs[k])
                    {
                        apwszArgs[cArgs++] = &pwszServiceArgs[k];
                    }

                    // Scan to the next whitespace char
                    while(pwszServiceArgs[k]          &&
                          pwszServiceArgs[k] != L' '  &&
                          pwszServiceArgs[k] != L'\t')
                    {
                        k++;
                    }

                    // Null terminate the previous argument
                    if (pwszServiceArgs[k])
                    {
                        pwszServiceArgs[k++] = L'\0';
                    }
                } while(pwszServiceArgs[k]);
            }

            // Start the service
            if (StartService(hService, cArgs,
                               cArgs > 0 ? (LPCTSTR  *) apwszArgs : NULL))
            {
                CloseServiceHandle(hService);
                PrivMemFree(pwszServiceArgs);
                return TRUE;
            }
            else
            {
                CloseServiceHandle(hService);
                PrivMemFree(pwszServiceArgs);
            }
        }
        else
        {
            CloseServiceHandle(hSCManager);
        }
    }

    DWORD err = GetLastError();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\chicago.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=200           \
              -D_CHICAGO_=200       \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEBALLSDIR=  $(BASEDIR)\private\oleutest\balls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\cairo.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

MAJORCOMP   = oletest
MINORCOMP   = com

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest

INCLUDES=     ..\;($BASEDIR)\cinc;$(OLEUTESTDIR)\oleprx32\proxy
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\common

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
	      -DUNICODE 	    \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
	      -DWIN32=300	    \
              -D_NT1X_=100          \
	      -DCAIROLE_DOWNLEVEL   \
	      -D_CAIRO_=300	    \
	      -D_DCOM_		    \
	      -DTHREADING_SUPPORT   \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

CAIRO_PRODUCT=1

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\daytona.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEBALLSDIR=  $(BASEDIR)\private\oleutest\balls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\types.inc ===
MAJORCOMP=cairo
MINORCOMP=types

PASS0_HEADERDIR = $(BASEDIR)\public\sdk\inc
PASS0_SOURCEDIR = ..\oleprx32\proxy
MIDL_UUIDDIR = ..\oleprx32\uuid

C_DEFINES= -DWIN32=300 -D_CAIRO_=300

TARGETPATH=obj
TARGETTYPE=NOTARGET

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\makefile.inc ===
############################################################################
#
#   Microsoft Windows
#   Copyright (C) Microsoft Corporation, 1991 - 1992.
#
#   File:       makefile.inc
#
#   Contents:   Main project makefile
#
#   History:
#
#
############################################################################

#**     Make include file
#
#       Definitions for compiler
#
#       GCFLAGS - additional flags for the C compiler, intended only
#                 to be used for global changes.  DONT EVER PUT THIS
#                 IN A MAKEFILE.
#       GAFLAGS - Same as GCFLAGS, but for the assembler.
#
#
# -------------------- Build Type Control ------------------------------------
#
# The "build type" determines what kind of internal checking is done.
# Turning on checking allows for catching more internal
# consistency errors, but slows the system down.
#
# Mechanically, one changes the build type the makefile is set for by
# editing the makefile to comment in or out the OBFLAGS line of interest.
# (Separate entry points cannot easily be used for this, this is a failing
#  of make.  That's why you have to edit the makefile.)
#
#

############################################################################
#
#   Default target is "all"
#

default: all

############################################################################
#
#   Suffixes for inference rules
#

.SUFFIXES:
.SUFFIXES: .idl .tdl .tlb .dll .h .inc .exe .obj .lst .cod .cxx .cpp
.SUFFIXES: .c .s  .lrf .lnk .map .sym .rc .lib .def .res .dgn .rtf .y .mc
.SUFFIXES: .i .ico .bmp .dlg .cur .cx2 .c2 .rc2  .hxx .pas .for .cbl .bas

##################################################
#       TGTDIR, OBJDIR selection
#
# Each build type stores obj files and built binaries in a different
# directory below the source or distribution tree.  Current directory
# naming convention is:
#
#    TGTDIR=OBJ<p><o><b>
#    OBJDIR=OBJ<p><o><b>
#
#    <p>:  i = i386
#          m = MIPS
#          a = ALPHA
#          2 = i286
#
#    <o>:  d = DOS
#          1 = NT 1.x
#          n = NT 2.0 (Cairo)
#          o = OS/2
#          w = Win16 (used when targeting Win32s)
#
#    <b>:  r = Retail
#          d = Debug
#          p = Profile (Retail with debug info)
#          <Nothing> = Release
#
# TGTEXT/RDEXT selection for MULTIDEPEND != ""
# Each build type stores depend.mk files with a different last character
# in the extension, as in "mk?".  Current extension convention is:
#    <1>:  NT 2.0 x86
#    <3>:  Chicago
#    <5>:  NT 2.0 MIPS
#    <7>:  NT 2.0 Alpha
#    <9>:  Win 3.1
#    <a>:  Dos 5.0
#    <c>:  OS/2 1.x
#    <e>:  NTKERNEL x86
#    <g>:  NTKERNEL MIPS
#    <h>:  NTKERNEL Alpha
#    <j>:  Win32s
#    <k>:  NT 1.x x86
#    <l>:  NT 1.x MIPS
#    <m>:  NT 1.x Alpha
#
# As you can see the scheme gets a bit cumbersome, so if you define
# MULTIDEPEND == MERGED then similar systems use the same letter, so:
#    <1>:  NT 2.0 all
#    <3>:  NT 1.x all, Chicago, Win32s
#    <9>:  Win 3.1
#    <a>:  Dos 5.0
#    <c>:  OS/2 1.x
#    <e>:  NTKERNEL all

OBJDIR=
TGTDIR=
TGTEXT=
RDEXT=

# set BUILDTYPE based on NTDEBUG setting
# bugbug need to base on settings in makefile.def
#

!if "$(NTDEBUG)" == "retail"
BUILDTYPE=RELEASE
!else
!if "$(NTDEBUG)" == "ntsdnodbg"
BUILDTYPE=RELEASE
!else
BUILDTYPE=DEBUG
!endif
!endif

!ifndef _NTROOT
_NTROOT=\nt
!endif

!ifndef BASEDIR
BASEDIR=$(_NTDRIVE)$(_NTROOT)
!endif

!if   "$(OPSYS)"==""
OPSYS=NT
!endif

!if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
PLAT = i
PLATFORM=I386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
PLAT = m
PLATFORM=MIPS
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
PLAT = a
PLATFORM=ALPHA
!else
!error Unknown PROCESSOR_ARCHITECTURE setting "$(PROCESSOR_ARCHITECTURE)"
!endif

!if     "$(BUILDTYPE)" == "DEBUG"
BLDT = d
!elseif "$(BUILDTYPE)" == "RETAIL"
BLDT = r
!elseif "$(BUILDTYPE)" == "PROFILE"
BLDT = p
!elseif "$(BUILDTYPE)" == "RELEASE"
BLDT =
!else
!error Unknown BUILDTYPE setting "$(BUILDTYPE)"
!endif

# DavidBak hack
!if     "$(PERFSNAP)" == "1"
BLDT = p
!endif

!if     "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
OPST = n
!elseif "$(OPSYS)" == "DOS"
OPST = d
!elseif "$(OPSYS)" == "DOS5"
OPST = 5
!elseif "$(OPSYS)" == "OS2"
OPST = o
!elseif "$(OPSYS)" == "WIN16"
OPST = w
!elseif "$(OPSYS)" == "NT1X"
OPST = 1
!else
!error Unknown OPSYS setting "$(OPSYS)"
!endif

OBJDIR = OBJ\$(PLATFORM)
TGTDIR = OBJ\$(PLATFORM)

!if "$(MULTIDEPEND)" == "MERGED"
! if     "$(OPSYS)" == "NT"
DEXT = 1
! endif
!else # !MERGED
! if "$(OPSYS)" == "NT"
PLATDIR=DAYTONA
!  if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEXT = 1
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
DEXT = 5
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEXT = 7
!  endif
! elseif "$(OPSYS)" == "NTKERNEL"
!  if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEXT = e
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
DEXT = g
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEXT = h
!  endif
! elseif "$(OPSYS)" == "DOS" && "$(PROCESSOR_ARCHITECTURE)" == "i286"
DEXT = 9
! elseif "$(OPSYS)" == "DOS5"
DEXT = a
! elseif "$(OPSYS)" == "OS2"
DEXT = c
! elseif "$(OPSYS)" == "NT1X"
PLATDIR=DAYTONA
!  if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEXT = k
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
DEXT = l
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEXT = m
!  endif
! elseif "$(PROCESSOR_ARCHITECTURE)" == "x86" && "$(OPSYS)" == "WIN16"
DEXT = j
! elseif "$(PROCESSOR_ARCHITECTURE)" == "x86" && "$(OPSYS)" == "DOS"
DEXT = 3
! endif
!endif

#bugbug, what about chicago platform

RDEXT  = $(DEXT)
TGTEXT = $(DEXT)

####################################################################################
#
#
#
#

RELEASE_BIN=

!IFDEF NTDBGFILES
!   IF "$(PROCESSOR_ARCHITECTURE)" == "x86"
BINPLACE_FLAGS=-s $(_NT386TREE)\Symbols
!   ELSE
!   IF "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
BINPLACE_FLAGS=-s $(_NTMIPSTREE)\Symbols
!       ELSE
!   IF "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
BINPLACE_FLAGS=-s $(_NTALPHATREE)\Symbols
!           ENDIF
!       ENDIF
!   ENDIF
!ELSE
BINPLACE_FLAGS=
!ENDIF

# The xxxTREE macros are set in the razzle cmd window.
# for cairo builds cairoxxxxxx macros will be set.

!ifdef CAIRO_PRODUCT
!ifdef _CAIROMIPSTREE
_NTMIPSTREE=$(_CAIROMIPSTREE)
!endif

!ifdef _CAIRO386TREE
_NT386TREE=$(_CAIRO386TREE)
!endif

!ifdef _CAIROALPHATREE
_NTALPHATREE=$(_CAIROALPHATREE)
!endif
!endif

!ifdef _NTMIPSTREE
RELEASE_BIN=TRUE
!endif

!ifdef _NT386TREE
RELEASE_BIN=TRUE
!endif

!ifdef _NTALPHATREE
RELEASE_BIN=TRUE
!endif

!ifndef BUILDDETAIL
BUILDDETAIL = quiet
!endif

!if "$(BUILDDETAIL)" == "FULL" || "$(BUILDDETAIL)" == "full"
COMPLOGO =
COMPRESP = KEEP
LINKLOGO =
LINKRESP = KEEP
!endif

!if "$(BUILDDETAIL)" == "KEEPCOMP" || "$(BUILDDETAIL)" == "keepcomp"
COMPLOGO =
COMPRESP = KEEP
LINKLOGO = -nologo
LINKRESP = NOKEEP
!endif

!if "$(BUILDDETAIL)" == "KEEPLINK" || "$(BUILDDETAIL)" == "keeplink"
COMPLOGO = -nologo
COMPRESP = NOKEEP
LINKLOGO =
LINKRESP = KEEP
!endif

!if "$(BUILDDETAIL)" == "QUIET" || "$(BUILDDETAIL)" == "quiet"
COMPLOGO = -nologo
COMPRESP = NOKEEP
LINKLOGO = -nologo
LINKRESP = NOKEEP
!endif

!if "$(NOLOGOS)" != ""
COMPLOGO = -nologo
LINKLOGO = -nologo
!endif

######################################################################
#       Destination for messages

!ifdef NOTIME
TIMESTR=
ATSTR=
!else
TIMESTR=/H:M:S
ATSTR=at
!endif

!ifndef OUTPUT
! ifdef BUILDQUIET
OUTPUT=    >nul
! else
OUTPUT=
! endif
!endif

#
# DOS doesn't let us redirect stderr output, so we use the following define
# to unify our output.
#

!if "$(HOST)" != "DOS"
OUTNUL= 1>nul 2>nul
!else
OUTNUL=
!endif

!ifndef OUTFIX
OUTFIX = $(OUTNUL)
!endif

######################################################################
#
# Set location to locate tools

# Empty toolpath so it can be used to check for invalid host type
TOOLPATH=
SDKTOOLPATH=

!if "$(HOST)" == ""
HOST = NT
!endif

HOSTBIN  = .

######################################################################
#
# Set location to copy include files

HCOPY= ..\oleprx32\daytona
LIBCP=
SEDHCOPY= ..\oleprx32\daytona

######################################################################
#
# Misc tool defines

AWK=      awk.exe
CAT=      cat.exe
CHMODE=   chmode.exe
CLASSGEN= classgen
CMP=      fcom.exe
COFF=     link32
COPY=     copy /v
CP=       $(COPY)
CTCOPY=   xcopy /v /i
CVPACK=   cvpack.exe
DEL=      del
CVTRES=   cvtres.exe
DOCGEN=   docgen.exe
ECH=      ech.exe
ECHOTIME= echotime
FLEX=     flex.exe
GENLRF=   genlrf.exe
GENORD=   genord.exe
IN=       $(SLMTOOLS)\in.exe
INCLUDES= includes.exe
MAPSYM=   mapsym.exe
MC=       mc.exe
MIDL=	  midl
MKHEADER= mkheader
MKTMPLAT= mktmplat
MKTYPLIB= mktyplib
MUNGE=    munge.exe
OUT=      out.exe
RC=       rc
REGTLB=   regtlb.exe
SED=      sed.exe
SIFTTOOL= sifttool.exe
SORT=     sort.exe
SPLITSYM= splitsym.exe
TOUCH=    touch.exe
UNIQ=     uniq.exe
UNREGTLB= unregtlb.exe
YACC=     yacc.exe

IMPORTNT = $(SDK_PATH)


TYPESDIR = $(BASEDIR)\private\oleutest\balls
SCRIPTS =  $(BASEDIR)\private\oleutest\balls

CAIROINC = $(BASEDIR)\private\cinc

BASEINC  =$(TYPESDIR)\idl

PROXYINC =$(TYPESDIR)\oleprx32\$(PLATDIR)

############################################################################
#
#   Object files and resource files
#

CXX_OBJS=$(CXXFILES:.cxx=.obj)
CXX_OBJS=$(CXX_OBJS) $(CPPFILES:.cpp=.obj)
C_OBJS=$(CFILES:.c=.obj)
RESFILES = $(RCFILES:.rc=.res)
TYPELIBS = $(TDLFILES:.tdl=.tlb)
MKHDR_H_FILES = $(TDLFILES:.tdl=.h)
MKHDR_C_FILES = $(TDLFILES:.tdl=.c)
MIDL_INCS=$(IDLFILES:.idl=.h)
MIDL_PROXYS=$(IDLFILES:.idl=.h)

#   Hack alert:
#
#   We want to use $(OBJDIR) in the replacement string, like this:
#
#       CXX_OBJS = $(CXX_OBJS:.\=$(OBJDIR)\)
#
#   Unfortunately, nmake wants no part of it.  As a workaround, we test for
#   each known value of $(OBJDIR) and perform the individual substitution
#   for each.

!if "$(MKHEADER_OUT_DIR)"==""
MKHEADER_OUT_DIR=$(TYPESDIR)\oleprx32\$(PLATDIR)\
!endif

!if "$(MIDL_OUT_DIR)"==""
MIDL_PROXYS=$(MIDL_PROXYS:.\=..\oleprx32\daytona\)
MIDL_INCS=$(MIDL_INCS:.\=..\oleprx32\daytona\)
MKHDR_H_FILES=$(MKHDR_H_FILES:.\=..\oleprx32\daytona\)
MKHDR_C_FILES=$(MKHDR_C_FILES:.\=..\oleprx32\daytona\)
MIDL_HDR_OUT_DIR=..\oleprx32\daytona
!else
MIDL_INCS=$(MIDL_INCS:.\=..\oleprx32\daytona\)
MIDL_HDR_OUT_DIR=..\oleprx32\daytona
!endif

!if "$(MIDL_OUT_DIR)"==""
MIDL_OUT_DIR=..\oleprx32\$(PLATDIR)
MIDL_HDR_OUT_DIR=..\oleprx32\daytona
!endif

!if "$(OBJDIR)" == "OBJ\I386"
CXX_OBJS = $(CXX_OBJS:.\=.\OBJ\I386\)
C_OBJS   = $(C_OBJS:.\=.\OBJ\I386\)
RESFILES = $(RESFILES:.\=OBJ\I386\)
TYPELIBS = $(TYPELIBS:.\=.\OBJ\i386\)

! elseif "$(OBJDIR)" == "OBJ\MIPS"
CXX_OBJS = $(CXX_OBJS:.\=.\OBJ\MIPS\)
C_OBJS   = $(C_OBJS:.\=.\OBJ\MIPS\)
RESFILES = $(RESFILES:.\=OBJ\MIPS\)
TYPELIBS = $(TYPELIBS:.\=.\OBJ\MIPS\)

! elseif "$(OBJDIR)" == "OBJ\ALPHA"
CXX_OBJS = $(CXX_OBJS:.\=.\OBJ\ALPHA\)
C_OBJS   = $(C_OBJS:.\=.\OBJ\ALPHA\)
RESFILES = $(RESFILES:.\=OBJ\ALPHA\)
TYPELIBS = $(TYPELIBS:.\=.\OBJ\ALPHA\)

! else
! error Unknown object directory: $(OBJDIR)

!endif  # $(OBJDIR)

############################################################################
#       Rules for generating .h, and .rc files from .mc files.
#
#
#
#

# bugbug, what about chicago builds?
# bugbug, maybe we should use other variable besides
# MIDL_OUT_DIR to determine which directory to generate
# message flies in.

!if "$(MESSAGE_FILES)" != ""

MCRESOURCE=$(MESSAGE_FILES:.mc=.rc)

MESSAGE_H_FILES=$(MESSAGE_FILES:.mc=.h)

!if "$(PLATDIR)" == "DAYTONA"
MESSAGE_H_FILES=$(MESSAGE_H_FILES:.\=..\..\..\..\public\sdk\inc\)
MC_OUT_DIR=..\..\..\..\public\sdk\inc
!endif

!if "$(OBJDIR)" == "OBJ\I386"
MCRESOURCE = $(MCRESOURCE:.\=.\OBJ\I386\)
!elseif "$(OBJDIR)"== "OBJ\MIPS"
MCRESOURCE = $(MCRESOURCE:.\=.\OBJ\MIPS\)
!elseif "$(OBJDIR)"== "OBJ\ALPHA"
MCRESOURCE = $(MCRESOURCE:.\=.\OBJ\ALPHA\)
!else
!error Uknown object directory : $(OBJDIR)
!endif

MCBIN= $(OBJDIR)\msg00001.bin

all: $(MESSAGE_H_FILES)

.mc{$(MC_OUT_DIR)}.h:
    @echo Building $< $(OUTPUT)
    @-md $(OBJDIR) $(OUTNUL)
    $(MC) $(MCFLAGS) $<  -h $(HCOPY) $(OUTPUT)
!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)"==""
    @-md $(HCOPY)\chicago $(OUTNUL)
    @echo Build_Status Releasing $(@B).h files to $(HCOPY)\chicago
    $(COPY) $(HCOPY)\$(@B).h  $(HCOPY)\chicago $(OUTNUL)
!endif

clean:  cleancomp
        -$(DEL)   $(MESSAGE_H_FILES:.mc=.h)  $(MCRESOURCE)  $(MCBIN) $(OUTNUL)

!endif

############################################################################
#
#       Rules for generating .tlb, .hxx and .cxx files from .tdl files
#       These should be before any target rules, to force code
#       generation before compiling.
#

!if "$(TDLFILES)" != ""

all: $(TYPELIBS)

.tdl{$(OBJDIR)}.tlb:
        @-md $(OBJDIR) $(OUTNUL)
        $(MKTYPLIB) $(MKTYPLIBFLAGS) $(CINC) $(TLBDIRS) -tlb$@ $<
        $(MKHEADER) $(MKHEADERFLAGS) -o $(HCOPY)\$(@B).h -u $(MKHEADER_OUT_DIR)\$(@B).c -x $(@)
        $(REGTLB) $@

$(TDLFILES): $(IDLFILES)

DEPENDFILES = $(TYPELIBS) $(MKHDR_H_FILES) $(MKHDR_C_FILES) $(DEPENDFILES)

TYPELIBS = $(TYPELIBS:.\=)

CLEANFILES = $(CLEANFILES) $(TYPELIBS) $(MKHDR_H_FILES) $(MKHDR_C_FILES)

!endif

############################################################################
#
#   Generate .h and .c files from .idl files
#                  1

# NOTE: this rule should appear before any target rules, to force
# idl-to-h translation to happen first.

!if "$(IDLFILES)" != ""

all: $(MIDL_INCS)

clean: cleanidl

#
# Due to command line limitations (yes, even NT has them), we write a script
#  to delete the idl output files.
#

cleanidl:
    @type << | $(SED) -f << > idlclean.bat
$(MIDL_INCS:.h=.h
)
$(MIDL_PROXYS:.h=_?.c
)
$(MIDL_PROXYS:.h=_?.cxx
)
$(MIDL_PROXYS:.h=_?.h
)
$(MIDL_PROXYS:.h=_?.hxx
)
<<NOKEEP
1i\
\@echo off \
\@echo Build_Status Deleting MIDL output files...
/\./!d
s/^/del /g
s/$$/ $(OUTNUL)/g
<<NOKEEP
    @-idlclean.bat
    @-$(DEL) idlclean.bat $(OUTNUL)

DEPENDFILES = $(DEPENDFILES) $(MIDL_INCS)

!endif # IDLFILES

##################################################################
#
# Rules to build the composite .h file from midl generated files                                                                                                                                                                                      #
#
#

!if "$(ITFS_BASE)" !=  "" && "$(ITFS_DIR)" != ""
ITFS_H = $(ITFS_BASE).h

all: $(ITFS_DIR)\$(ITFS_H)

$(ITFS_DIR)\$(ITFS_H): $(MIDL_INCS) $(ITFS_BASE).x $(ITFS_BASE).y
     @echo Build_Status Building $(ITFS_DIR)\$(ITFS_H) ...
     @del $(ITFS_DIR)\$(ITFS_H) $(OUTNUL)
#
#  Add the file header and base #includes.
#

     @type $(ITFS_BASE).x >> $(ITFS_DIR)\$(ITFS_H)
     @echo @echo off > copyall.cmd
     @echo cd $(ITFS_DIR)\  >> copyall.cmd
     @type << | $(SED) -f << >> copyall.cmd
$(BASE_HFILES: =
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed -e \"\/^\#include\/d\" -e \"\/\\\/\\\/  File\\\:\/d" /g
s/$$/ \>\> $(ITFS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> copyall.cmd
     @copyall.cmd
     @del copyall.cmd
#
#  Copy the initial forward declarations from all the derived h files.
#
     @type << >> $(ITFS_DIR)\$(ITFS_H)

// Forward declarations for typedefs in this file
<<NOKEEP
     @type << > $(ITFS_DIR)\forward.sed
/\/\* Forward Declarations \*\// {
N
s/\/\* Forward Declarations \*\/\ntypedef/xtypedef/
}
/xtypedef/!d
s/xtypedef/typedef/
<<NOKEEP

     @echo @echo off > forward.cmd
     @echo cd  $(ITFS_DIR) >> forward.cmd
     @type << | $(SED) -f << >> forward.cmd
$(DERIVED_HFILES: =
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed -f forward.sed /g
s/$$/ \>\> $(ITFS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> forward.cmd
     @forward.cmd
     @del forward.cmd
     @del $(ITFS_DIR)\forward.sed $(OUTNUL)
#
#  Copy the derived h files in.  Strip off any #includes along the way.
#

     @echo @echo off > copyall.cmd
     @echo cd $(ITFS_DIR)\  >> copyall.cmd
     @type << | $(SED) -f << >> copyall.cmd
$(DERIVED_HFILES: =
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed -e \"\/^\#include\/d\" -e \"\/\\\/\\\/  File\\\:\/d" /g
s/$$/ \>\> $(ITFS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> copyall.cmd
     @copyall.cmd
     @del copyall.cmd
#
#  Append API prototypes to the end of the file
#
     @type $(ITFS_BASE).y >> $(ITFS_DIR)\$(ITFS_H)
#
#  Finally, close the file #ifdef
#

     @type << >> $(ITFS_DIR)\$(ITFS_H)
#ifndef RC_INVOKED
#pragma pack()
#endif // RC_INVOKED
#endif     // __$(ITFS_BASE)_H__
<<NOKEEP

!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)" == ""
     @echo "Releaseing composite .h file for Chicago" $(OUTPUT)
     $(COPY) $(ITFS_DIR)\$(ITFS_BASE).h  $(HCOPY)\chicago
!endif
!endif # ITFS_BASE

##################################################################
#
# Rules to build the composite .h file from mc generated files                                                                                                                                                                                      #
#
#

!if "$(MCERRS_BASE)" !=  "" && "$(MCERRS_DIR)" != ""
MCERRS_H = $(MCERRS_BASE).h

all: $(MCERRS_DIR)\$(MCERRS_H)

$(MCERRS_DIR)\$(MCERRS_H): $(MESSAGE_FILES)
     @echo Build_Status Building $(MCERRS_DIR)\$(MCERRS_H) ...
     @del $(MCERRS_DIR)\$(MCERRS_H) $(OUTNUL)
#
#  Add the file header and base #includes.
#

     @echo @echo off > copyall.cmd
     @echo cd $(MCERRS_DIR)\  >> copyall.cmd
     @type << | $(SED) -f << >> copyall.cmd
$(MESSAGE_FILES:.mc=.h
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed  -e \"\/\\\/\\\/      File\\\:\/d" /g
s/$$/ \>\> $(MCERRS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> copyall.cmd
     @copyall.cmd
     @del copyall.cmd

!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)" == ""
     @echo "Releaseing composite .h file for Chicago" $(OUTPUT)
     $(COPY) $(MCERRS_DIR)\$(MCERRS_BASE).h  $(HCOPY)\chicago
!endif

cleancomp:
     @del $(MCERRS_DIR)\$(MCERRS_H)

!endif

############################################################################
#
#   Determine target type (DLL, EXE, or LIB)
#

!ifdef TARGET

TARGET = $(TARGET:.\=)

CLEANTARGET=    $(CLEANTARGET) $(TGTDIR)\$(TARGET)

#
#   Is it a DLL?
#

TARGETBASE=$(TARGET:.dll=)
! if "$(TARGETBASE)" != "$(TARGET)"
all: $(YACCFILES:.y=.h) $(TGTDIR)\$(TARGET) copy
TARGETTYPE=dll
DLLFILES=       $(DLLFILES) $(TGTDIR)\$(TARGET)
! else

#
#   Is it an EXE?
#

TARGETBASE=$(TARGET:.exe=)
!  if "$(TARGETBASE)" != "$(TARGET)"
all: $(YACCFILES:.y=.h) $(TGTDIR)\$(TARGET) copy
TARGETTYPE=exe
EXEFILES=       $(EXEFILES) $(TGTDIR)\$(TARGET)
!  else

#
#   Is it a LIB?
#

TARGETBASE=$(TARGET:.lib=)
!   if "$(TARGETBASE)" != "$(TARGET)"
all: $(YACCFILES:.y=.h) $(OBJDIR)\$(TARGET) copy
TARGETTYPE=lib
!    if "$(DEFFILE)" == ""
NO_IMPLIB= TRUE
!    endif
!   else

#
#   This is a special target used when we have files to RELEASE
#   but nothing to actually build.
#

!       if "$(TARGET)" == "RELEASE"
all:
!       else

#
#   We don't know what it is.
#

!        error Unrecognized target type: $(TARGET)
!       endif  # !RELEASE
!   endif  # !.lib
!  endif  # !.exe
! endif  # !.dll
!endif  # TARGET
#
#   If no name was given for a DEF file, make one up.
#

DEFEXT = f

!ifndef DEFBASE
DEFBASE = $(TARGETBASE)
!endif

!ifndef DEFFILE
DEFFILE=$(DEFBASE).def
!endif

!if "$(NO_IMPLIB)" == ""
DEFFILELIB = $(OBJDIR)\$(DEFBASE).lib
DEFFILEEXP = $(OBJDIR)\$(DEFBASE).exp
!endif


######################################################################
#       Make sure INCLUDE and LIB are null.

INCLUDE=
LIB=

######################################################################
#       Independent definitions for C compiler,  LINK

CFLAGS=  $(CFLAGS) -D_WINDOWS -ZB64

# The 16 bit OLE DOCFILE libraries do not want UNICODE defined.

!ifndef NO_UNICODE
! if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NT1X" || "$(OPSYS)" == "NTKERNEL"
CFLAGS = $(CFLAGS) -DUNICODE -D_UNICODE
! endif
!endif

CINC=    -I. $(CINC)

CINC=	 $(CINC) -I$(TYPESDIR)\oleprx32\$(PLATDIR)
CINC=    $(CINC) -I$(CAIROINC) -I$(BASEINC)


######################################################################
#       Debug/Retail definitions
#
# These are hardware independant debug/retail flags
#

# NOTE:  NT kernel include files require that DBG be defined.
!if "$(BUILDTYPE)" == "DEBUG"
CDEBUGFLAGS = $(CDEBUGFLAGS) -DDBG=1 -DDEVL=1
!elseif "$(BUILDTYPE)" == "RETAIL"
CDEBUGFLAGS = $(CDEBUGFLAGS) -DDBG=0 -DDEVL=1
!else
CDEBUGFLAGS = $(CDEBUGFLAGS) -DDBG=0 -DDEVL=0
!endif

CFLAGS = $(CFLAGS) $(CDEBUGFLAGS)

######################################################################
#
#       Generic Definitions
#

COMMON_LIBS = $(SDK_LIB_DEST)\$(PLATFORM)

CAIROLIB    = $(COMMON_LIBS)\commnot.lib\
              $(COMMON_LIBS)\compob32.lib\
              $(COMMON_LIBS)\storag32.lib\
              $(COMMON_LIBS)\propset.lib\
              $(COMMON_LIBS)\ole232.lib\
              $(COMMON_LIBS)\lnktrack.lib\
              $(TYPESDIR)\oleprx32\$(PLATDIR)\$(OBJDIR)\uuid.lib\
              $(COMMON_LIBS)\change.lib\
              $(COMMON_LIBS)\events.lib\
              $(COMMON_LIBS)\dsys.lib \
              $(SDK_LIB_PATH)\ntdll.lib

######################################################################
#
#       Win32 (NT 1.x/NT 2.0/Chicago/Win32s) Definitions
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86" || \
    "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || \
    "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
! if "$(PROCESSOR_ARCHITECTURE)" == "x86"

#--------------------------------------
#        X86 Specific Flags
#--------------------------------------

CC=  cl386
BUILD_EXE_COMPFLAG= cl386
BUILD_EXE_PROCTYPE=i386

CPLATFORM= -Di386=1 -D_X86_=1

CFLAGS   = $(CFLAGS) -G4f -Zl -Bbb1

# Chicago doesn't have Unicode API's
!  if "$(OPSYS)" == "DOS" || "$(OPSYS)" == "WIN16"
CFLAGS   = $(CFLAGS) -UUNICODE -U_UNICODE
!  endif

!if "$(CALLCONV)" == ""
!  ifndef 386_STDCALL
386_STDCALL = TRUE
!  endif

!  if "$(386_STDCALL)" == "TRUE"
CFLAGS = $(CFLAGS) -Gz
!  else
CFLAGS = $(CFLAGS) -Gd
!  endif
!else
CFLAGS = $(CFLAGS) $(CALLCONV)
!endif

#
#  Disable FPO for now.  If/when we determine if the debuggers can handle
#  it, and the CriticalSection code isn't dependent on the stack frame, and
#  the Stack walk-back code is updated, we should turn it back on...
#

!  ifndef OPTFLAGS
!   if "$(BUILDTYPE)" == "DEBUG" || "$(BUILDTYPE)" == "RETAIL"
OPTFLAGS = -Ogit -Oy-
!   elseif "$(BUILDTYPE)" == "RELEASE" || "$(BUILDTYPE)" == "PROFILE"
OPTFLAGS = -Owx  -Oy- -Ob1
!   endif
!  endif

# Make sure intrinsics are always on.

OPTFLAGS = $(OPTFLAGS) -Oi

# Hack to workaround cvpack types limit when building ole2prxy.dll in
#  common\types.  s/b revisted once the linker and cvpack are one.
#  BryanT  8/10/93

!if "$(NO_DEBUG)" == "1"
NTDEBUGTYPE = ntsd
!else
NTDEBUGTYPE = windbg
!endif

DLLENTRY    = @12
DRIVERENTRY = @8

#
#  (To be moved to NT section when the MIPS linker understands this flag)
#

LFLAGS = $(LFLAGS) -merge:.CRT=.data

#
#  The CUDA Linker requires this if there is no entrypoint (resource only DLL)
#

! ifdef NOEXPORTS
DLLSTARTUP=     -NOENTRY
! endif

LFLAGS   = $(LFLAGS) -NODEFAULTLIB -OPT:REF  -RELEASE

OBJFILES = $(OBJFILES) $(X86_OBJFILES)

! elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"

#--------------------------------------
#        MIPS Specific Flags
#--------------------------------------

CC=  mcl
BUILD_EXE_COMPFLAG= ClMips
BUILD_EXE_PROCTYPE=mips

CPLATFORM= -DMIPS=1 -D_MIPS_=1 -DR4000=1

CFLAGS   = $(CFLAGS) -QmipsOb2000 -QmipsG2

!  ifndef OPTFLAGS
!   if "$(BUILDTYPE)" == "DEBUG" || "$(BUILDTYPE)" == "RETAIL"
OPTFLAGS = -Oglt
!   elseif "$(BUILDTYPE)" == "RELEASE" || "$(BUILDTYPE)" == "PROFILE"
OPTFLAGS = -Owx  -Ob1
!   endif
!  endif

DLLENTRY =
DRIVERENTRY =

!  if "$(TARGETTYPE)" == "exe"
LFLAGS   =  $(LFLAGS) -GPSIZE:32
!  endif

!ifdef NEW_LINKER

!  ifdef NOEXPORTS
DLLSTARTUP=     -NOENTRY
!  endif

LFLAGS   = $(LFLAGS) -NODEFAULTLIB -OPT:REF -RELEASE

!  if "$(NO_DEBUG)" == "1"
NTDEBUGTYPE = ntsd
!  else
NTDEBUGTYPE = windbg
!  endif

!else

#
#  The MIPS Linker doesn't use a special switch to disable the entrypoint.
#

!  ifdef NOEXPORTS
DLLSTARTUP=
!  endif

LFLAGS   =  $(LFLAGS) -IGNORE:505

#
#  The MIPS Linker doesn't understand the nologo switch... Disable it for now.
#

LINKLOGO =

!endif

#  BUGBUG: For GPSIZE to really be useful, the compiler switches should include
#          -Gt32 and we should add libm.lib to the LIBS macros.  However, I'm
#          pretty sure Steve (shanson) and Sundeep haven't implemented the
#          necessary code for it to work with DLL's...  So for now, we just add
#          if to the exe link flags in case some library we link with was built
#          with -Gt...  BryanT  6/20/93

OBJFILES = $(OBJFILES) $(MIPS_OBJFILES)

! elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"

#--------------------------------------
#        ALPHA Specific Flags
#--------------------------------------

CC=  claxp
BUILD_EXE_COMPFLAG= ClAlpha
BUILD_EXE_PROCTYPE=alpha

CPLATFORM= -DALPHA=1 -D_ALPHA_=1 -DJENSEN

!  ifndef OPTFLAGS
!   if "$(BUILDTYPE)" == "DEBUG" || "$(BUILDTYPE)" == "RETAIL"
OPTFLAGS = -Oglt
!   elseif "$(BUILDTYPE)" == "RELEASE" || "$(BUILDTYPE)" == "PROFILE"
OPTFLAGS = -Owx  -Ob1
!   endif
!  endif

DLLENTRY =
DRIVERENTRY =

#
#  The ALPHA Linker doesn't use a special switch to disable the entrypoint.
#

! ifdef NOEXPORTS
DLLSTARTUP=
! endif

LFLAGS   =  $(LFLAGS) -IGNORE:505

#
#  The ALPHA Linker doesn't understand the nologo switch... Disable it for now.
#

LINKLOGO =

OBJFILES = $(OBJFILES) $(ALPHA_OBJFILES)

! endif   # PROCESSOR_ARCHITECTURE == x86 / MIPS / ALPHA

#--------------------------------------
#        NT/Chicago(DOS) Specific Flags
#--------------------------------------

CPLATFORM = $(CPLATFORM) -DFLAT

CFLAGS   = $(CFLAGS) -Zp8 -Ze -Gys -W3 -FI$(BASEDIR)\private\cinc\warning.h

!if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
CFLAGS = $(CFLAGS) -DCAIROLE_BUILD
!endif

# WIN32 ==  50 -> Win32s
# WIN32 == 100 -> NT version 1.0
# WIN32 == 200 -> Chicago version 1.0
# WIN32 == 300 -> Cairo (NT version 2.0)

!if "$(OPSYS)" == "WIN16"
CPLATFORM = $(CPLATFORM) -DWIN32=50 -D_WIN32S_=50
!elseif "$(OPSYS)" == "NT1X"
CPLATFORM = $(CPLATFORM) -DWIN32=100 -D_NT1X_=100
!elseif "$(OPSYS)" == "DOS"
CPLATFORM = $(CPLATFORM) -DWIN32=200 -D_CHICAGO_=200
!elseif "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
CPLATFORM = $(CPLATFORM) -DWIN32=300 -D_CAIRO_=300
!else
!error Unknown OPSYS: $(OPSYS)
!endif

!ifdef PERFSNAP
CFLAGS = $(CFLAGS) -DPERFSNAP=1
!endif

!ifdef NO_OLE
INCLUDES_FLAGS = $(INCLUDES_FLAGS) -nole2.h
CFLAGS = $(CFLAGS) -DNOOLETYPES
!else
CFLAGS = $(CFLAGS) -DINC_OLE2
!endif

IDLFLAGS   = $(IDLFLAGS) -Zp8

NO_SPLITSYM = TRUE   # Reenable when commnot understands .dbg files

IMAGE_TYPE_COFF = TRUE

!  if "$(BUILDTYPE)" == "RELEASE"
DBGFLAGS  =
!  else
DBGFLAGS  = -Z7
!  endif

!  if "$(NO_STRICT)" == ""
CFLAGS = $(CFLAGS) -DSTRICT
!  else
CFLAGS = $(CFLAGS) -DNO_STRICT
!  endif

CFLAGS = $(CFLAGS) $(OPTFLAGS) $(DBGFLAGS) $(CPLATFORM)

! if "$(TARGETTYPE)" != "sys" && !defined(USE_STDCRT)
USE_MSVCRT=TRUE
! endif

! ifdef USE_MSVCRT
CFLAGS=   $(CFLAGS) -D_MT -D_DLL
MTHREAD=  1
! else
!  if "$(TARGETTYPE)" == "dll" || "$(MTHREAD)" == "1"
CFLAGS=   $(CFLAGS) -D_MT
!  endif
! endif

WILDCARDOBJ = $(RTLIBDIR)\setargv.obj

! ifdef WILDCARDS
OBJFILES = $(OBJFILES) $(WILDCARDOBJ)
! endif

AFLAGS=         $(AFLAGS) -Ml -W2 -Zi -t

CRTINC=         $(OSINC)\crt

RTLIBDIR=       $(OSLIBDIR)

! if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
RTLIBST=        $(RTLIBDIR)\cairost.lib  $(RTLIBDIR)\libc.lib
RTLIBMT=        $(RTLIBDIR)\cairomt.lib  $(RTLIBDIR)\libcmt.lib
RTLIBCRTDLL=    $(RTLIBDIR)\crtdll.lib
RTLIBSYS=       $(RTLIBDIR)\cairoker.lib $(RTLIBDIR)\libcnt.lib
! else
RTLIBST=        $(RTLIBDIR)\libc.lib
RTLIBMT=        $(RTLIBDIR)\libcmt.lib
RTLIBSYS=       $(RTLIBDIR)\libcnt.lib
RTLIBCRTDLL=    $(RTLIBDIR)\crtdll.lib
! endif

RTLIBEXE=       $(RTLIBST)
RTLIBEXEQ=
RTLIBEXEFP=
RTLIBEXEFPMT=

! ifdef USE_MSVCRT
RTLIBEXEMT=     $(RTLIBCRTDLL)
RTLIBDLL=       $(RTLIBCRTDLL)
! else
RTLIBEXEMT=     $(RTLIBMT)
RTLIBDLL=       $(RTLIBMT)
! endif

RPCLIBDIR=      $(OSLIBDIR)

RPCNDRLIB=      $(RPCLIBDIR)\RpcNdr.lib
RPCRTLIB=       $(RPCLIBDIR)\RpcRt4.lib
RPCLIBS=        $(RPCRTLIB) $(RPCLIBDIR)\ntdll.lib

! if "$(SUBSYSTEMVER)" == ""
SUBSYSTEMVER = 3.10
! endif

! if "$(NO_WINMAIN)" == ""
EXESTARTUP=     -ENTRY:WinMainCRTStartup
SUBSYSTEM=      WINDOWS,$(SUBSYSTEMVER)
! else
EXESTARTUP=     -ENTRY:mainCRTStartup
!  if "$(SUBSYSTEM)" == ""
SUBSYSTEM=      CONSOLE,$(SUBSYSTEMVER)
!  else  # Make sure the subsystem version is set
!   if "$(SUBSYSTEM)" == "$(SUBSYSTEM:,=x)"
SUBSYSTEM=  $(SUBSYSTEM),$(SUBSYSTEMVER)
!   endif
!  endif # allows override of subsystem
! endif

#
# For a perfsnap build, we use a modified version of dllentr2.obj
#

!if "$(PERFSNAP)" == "1"
STARTUPFILE=dllpsnap.obj
!else
STARTUPFILE=dllentr2.obj
!endif

#
# BugBug, what do we do about the DllEntryPoint for Daytona builds?
# now we jus link with dllentr2.obj.

! ifndef NOEXPORTS
!  ifdef USE_MSVCRT
!   if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
DLLSTARTUP=     -ENTRY:DllEntryPoint$(DLLENTRY)
!   else
DLLSTARTUP=     -ENTRY:DllEntryPoint$(DLLENTRY)
!   endif
!  else
DLLSTARTUP=     -ENTRY:DllEntryPoint$(DLLENTRY)
!  endif
! endif

SYSSTARTUP=     -ENTRY:DriverEntry$(DRIVERENTRY)

!ifdef USE_OLE_MC
MCFLAGS= -r $(OBJDIR) -o
!else
MCFLAGS= -r $(OBJDIR)
!endif

RCFLAGS=        $(RCFLAGS) -r $(CDEBUGFLAGS) $(CPLATFORM) $(CINC) -fo
RCEXEFLAGS=     $(RCEXEFLAGS)

LINK=           $(COFF) -link $(LINKLOGO)
LIBUTIL=        $(COFF) -lib $(LINKLOGO)

LFLAGS=         $(LFLAGS) \
                -MACHINE:$(PLATFORM) \
                -MAP:$(OBJDIR)\$(TARGETBASE).map \
!if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
                -VERSION:2.0 \
!else
                -VERSION:1.0 \
!endif
                -SECTION:.rsrc,r \
                -SECTION:.guids,r

! if "$(BUILDTYPE)" == "RELEASE"
LFLAGS=         $(LFLAGS) -DEBUG:none
! else
!  if "$(TARGETTYPE)" == "sys"
!   if "$(PROCESSOR_ARCHITECTURE)" == "x86"
LFLAGS=         $(LFLAGS) -DEBUG:notmapped,full -DEBUGTYPE:both,fixup
NTDEBUGTYPE=windbg
!   else
LFLAGS=         $(LFLAGS) -DEBUG:notmapped,full -DEBUGTYPE:coff
NTDEBUGTYPE=ntsd
!   endif
!  else
!   if "$(NTDEBUGTYPE)" == "windbg"
!    if "$(PROCESSOR_ARCHITECTURE)" == "x86"
LFLAGS=         $(LFLAGS) -DEBUG:mapped,full -DEBUGTYPE:both,fixup
!    else
LFLAGS=         $(LFLAGS) -DEBUG:mapped,full -DEBUGTYPE:both
!    endif
!   else
LFLAGS=         $(LFLAGS) -DEBUG:mapped,full -DEBUGTYPE:coff
!   endif
!  endif
! endif

LFLAGSEXE=      $(LFLAGS)             -ALIGN:0x1000 -SUBSYSTEM:$(SUBSYSTEM)
LFLAGSDLL=      $(LFLAGS) -DLL        -ALIGN:0x1000 -SUBSYSTEM:$(SUBSYSTEM)
LFLAGSSYS=      $(LFLAGS) -DLL:system -ALIGN:0x200

# Chicago and Win32s need relocations
!if "$(OPSYS)" != "DOS" && "$(OPSYS)" != "WIN16"
LFLAGSEXE=      $(LFLAGSEXE) -FIXED
!endif

LIBFLAGS=       -MACHINE:$(PLATFORM) -DEBUGTYPE:BOTH

! ifndef IMAGEBASE
!  if "$(TARGETTYPE)" == "sys"
IMAGEBASE = 0x10000
!  elseif "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "cpl"
!   ifdef COFFBASE
IMAGEBASE=      @$(TYPESDIR)\coffbase.txt,$(COFFBASE)
!   else
!    if "$(RELEASE)" != ""
!error *** BUILD ERROR - Cannot set RELEASE w/o a COFFBASE setting ***
!    endif
!   endif
!  else
IMAGEBASE=      @$(TYPESDIR)\coffbase.txt,usermode
!  endif
! endif

IMAGEBASE=      -BASE:$(IMAGEBASE)

SPLITSYMFLAGS=  -v

!endif  # $(PROCESSOR_ARCHITECTURE) == x86/MIPS/ALPHA

##################################################
#       OS dependent Definitions for C compiler
#
# These are definitions which will change for each flavor of Win32
# supported (NT, DOS)
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86" || "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"

!if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NT1X"
OSLIBDIR= $(IMPORTNT)\lib\$(PLATFORM)
OSINC=    $(IMPORTNT)\inc

!if "$(OPSYS)" == "NT"
CAIROOSINC=$(IMPORTNT)\inc
!elseif "$(OPSYS)" == "NT1X"
CAIROOSINC=$(IMPORTNT)\inc
!endif

RPCINC=   $(IMPORTNT)\inc

!else
!error Unknown OPSYS: $(OPSYS)
!endif

OSLIBEXE= $(OSLIBDIR)\gdi32.lib  $(OSLIBDIR)\kernel32.lib \
          $(OSLIBDIR)\user32.lib $(OSLIBDIR)\advapi32.lib

OSLIBEXE= $(OSLIBEXE) $(EXTRAOSLIBS)

! if "$(PROFILE)" == "TRUE"
OSLIBEXE= $(OSLIBEXE) $(OSLIBDIR)\cap.lib
! endif  # "$(PROFILE)" == "TRUE"

OSLIBDLL= $(OSLIBEXE)
OSLIBSYS= $(OSLIBDIR)\ntoskrnl.lib $(OSLIBDIR)\hal.lib $(EXTRAOSLIBS)

! if "$(IDLBASE)" != ""
OSLIBEXE= $(OSLIBEXE) $(RPCNDRLIB)
OSLIBDLL= $(OSLIBDLL) $(RPCNDRLIB)
! endif

!endif      # PROCESSOR_ARCHITECTURE == x86/MIPS/ALPHA

CINC=     $(CINC) -I$(CRTINC) -I$(CAIROOSINC) -I$(OSINC) -I$(RPCINC)

####################################################################
#
#  Defines for the SDK Tools.
#

MKHEADERFLAGS   = $(MKHEADERFLAGS)
MKTYPLIBFLAGS   = $(MKTYPLIBFLAGS) -cpp_cmd $(CC)
MKTMPLATFLAGS   = $(MKTMPLATFLAGS)

# update TLBDIRS to point to the location of the master winole
# type library. Currently this is in $(BASEINC)\$(OBJDIR)
TLBDIRS         = $(TLBDIRS) -L$(BASEINC)\$(OBJDIR)

######################################################################
#
#       Generic rules to build OBJs from C, and CXX files.
#

CLOBJ=  $(CC) $(CFLAGS) $(OCFLAGS) $(CINC) $(GCFLAGS) -c

ALLCFLAGS = $(CFLAGS) $(OCFLAGS) $(GCFLAGS) -c

IDLMIDLFLAGS = $(MIDLFLAGS) $(IDLFLAGS)

#####################################################################
#
#   Rules for generating precompiled headers
#
#   BUGBUG: This business with adding a dummy function to the end of the pch
#           is necessitated by the compiler not doing it for us.  By doing
#           it, we force the linker to add the module to the library.  We
#           also create a .lic (Link Include) file that will follow the library
#           around and force the module to be linked in to the final image
#           so cvpack can find the types data.  4-14-93  BryanT
#
#  Define NEW_PCH_BUILD to eliminate this problem.  Instead of generating
#  a dummy function and the .lic file, we use -Yl on the compile line with
#  the name of the target.  This causes the compiler to add a special
#  symbol to the pch file.  Not turned on for the full build because
#  Centaur doesn't support it yet.  9-24-93  BryanT
#

!if "$(PCHDIR)" == ""
PCHDIR       = $(MAKEDIR)
!endif

CINC         = -I$(PCHDIR) $(CINC)

PCH_SECRET_NAME = __@@_PchDebugInfoLibrary

DUMFUNC      = $(PCH_SECRET_NAME)_$(TARGETBASE)_$(TARGETTYPE)
! if "$(PROCESSOR_ARCHITECTURE)" == "x86"
DUMINCLUDE   = -INCLUDE:_$(DUMFUNC)
! else
DUMINCLUDE   = -INCLUDE:$(DUMFUNC)
! endif
PCHOBJDIR    = $(PCHDIR)\$(OBJDIR)

# ---------------------------  PXXFILE Support  ------------------------

#bugbug
#work around for precompiled header problem.
!if "$(NTNOPCH)"!=""
PXXFILE=
!endif

!if "$(PXXFILE)" != ""

PXXFILE      = $(PXXFILE:.\=)
PXXSOURCE    = $(PCHDIR)\$(PXXFILE)
PXXHEADER    = $(PCHOBJDIR)\$(PXXFILE:.cxx=.pxh)
PRECOMPXXOBJ = $(PCHOBJDIR)\$(PXXFILE:.cxx=.obj)
PXXLIC       = $(PCHOBJDIR)\$(PXXFILE:.cxx=.lxp)
PCH_CXX_OPT  = -Yu -Fp$(PXXHEADER)
!if "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || "$(PROCESSOR_ARCHITECTURE)" == "x86" || "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
PCH_CXX_NAME = -Yl$(TARGETBASE)_$(TARGETTYPE)
!else
PCH_CXX_NAME =
!endif

! ifndef NEW_PCH_BUILD
$(PXXHEADER) $(PXXLIC): $(PXXSOURCE)
!  if "$(PCHDIR)" == "$(MAKEDIR)"
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PXXFILE:.cxx=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_CXX_NAME)
-Fp$(PXXHEADER)
-Fo$(PRECOMPXXOBJ)
-Tp$(PXXSOURCE)
<<$(COMPRESP)
      @echo $(DUMINCLUDE) > $(PXXLIC)
!  else
      @-cd $(PCHDIR)
      @-$(MAKE) -$(MAKEFLAGS)
      @-cd $(MAKEDIR)
!  endif
! else   # NEW_PCH_BUILD

$(PXXHEADER): $(PXXSOURCE)
!  if "$(PCHDIR)" == "$(MAKEDIR)"
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PXXFILE:.cxx=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_CXX_NAME)
-Fp$(PXXHEADER)
-Fo$(PRECOMPXXOBJ)
-Tp$(PXXSOURCE)
<<$(COMPRESP)
!  else
      @-cd $(PCHDIR)
      @-$(MAKE) -$(MAKEFLAGS)
      @-cd $(MAKEDIR)
!  endif
! endif  # NEW_PCH_BUILD
!else    # PXXFILE == ""

PCH_CXX_OPT  =
PRECOMPXXOBJ =

!endif

# ----------------------------  PFILE Support  -------------------------

!if "$(PFILE)" != ""

PFILE      = $(PFILE:.\=)
PSOURCE    = $(PCHDIR)\$(PFILE)
PHEADER    = $(PCHOBJDIR)\$(PFILE:.c=.ph)
PRECOMPOBJ = $(PCHOBJDIR)\$(PFILE:.c=.obj)
PLIC       = $(PCHOBJDIR)\$(PFILE:.c=.lp)
PCH_C_OPT  = -Yu -Fp$(PHEADER)
!if "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || "$(PROCESSOR_ARCHITECTURE)" == "x86" || "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
PCH_C_NAME = -Yl$(TARGETBASE)_$(TARGETTYPE)
!else
PCH_C_NAME =
!endif

! ifndef NEW_PCH_BUILD
$(PHEADER) $(PLIC): $(PSOURCE)
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PFILE:.c=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_C_NAME)
-Fp$(PHEADER)
-Fo$(PRECOMPOBJ)
-Tc$(PSOURCE)
<<$(COMPRESP)
      @echo $(DUMINCLUDE) > $(PLIC)

! else  # NEW_PCH_BUILD

$(PHEADER): $(PSOURCE)
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PFILE:.c=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_C_NAME)
-Fp$(PHEADER)
-Fo$(PRECOMPOBJ)
-Tc$(PSOURCE)
<<$(COMPRESP)
! endif   # NEW_PCH_BUILD
!else    # PFILE == ""

PCH_C_OPT  =
PRECOMPOBJ =

!endif

!ifndef NEW_PCH_BUILD
# -----------------------  Library .LIC Support  ------------------------

!if "$(TARGETTYPE)" == "lib" && ("$(PXXFILE)" != "" || "$(PFILE)" != "")

$(TGTDIR)\$(TARGET): $(TGTDIR)\$(TARGETBASE).lic

$(TGTDIR)\$(TARGETBASE).lic: $(PXXLIC) $(PLIC)
      @-md $(OBJDIR) $(OUTNUL)
      @-$(DEL) $@ $(OUTNUL)
      @for %i in ($**) do @type %i >> $@

!endif

!endif  # NEW_PCH_BUILD

#####################################################################
#
#   Rules for c files
#

.c{$(OBJDIR)}.obj:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $< $(CC) $(COMPLOGO) @$*.rsp
        @$(CC) $(COMPLOGO) @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_C_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
$(MAKEDIR)\$<
<<$(COMPRESP)
!ifdef SIFTBUILD
        $(SIFTTOOL) $(SIFTFLAGS) $*.obj
!endif

.c{$(OBJDIR)}.lst:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $< $(CC) $(COMPLOGO) -Fc$*.lst @$*.rsp
        @$(CC) $(COMPLOGO) -Fc$*.lst @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_C_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
$(MAKEDIR)\$<
<<$(COMPRESP)

#####################################################################
#
#   Rules for cxx files
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"

CFFLAGS     = +L +m7 +H63
!elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"

CFFLAGS     = +L +m7 +H63 +E$(IMPORTNT)\h\sdk\mipsxcpt.tab +M
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"

CFFLAGS     = +L +m7 +H63 +E$(IMPORTNT)\h\sdk\alphxcpt.tab +M
!endif

.cxx{$(OBJDIR)}.obj:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $< $(CC) $(COMPLOGO) @$*.rsp
        @$(CC) $(COMPLOGO) @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)
!ifdef SIFTBUILD
        $(SIFTTOOL) $(SIFTFLAGS) $*.obj
!endif

.cxx{$(OBJDIR)}.lst:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $<  $(CC) $(COMPLOGO) -Fc$*.lst @$*.rsp
        @$(CC) $(COMPLOGO) -Fc$*.lst @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)

.cpp{$(OBJDIR)}.obj:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $<  $(CC) $(COMPLOGO) @$*.rsp
        @$(CC) $(COMPLOGO) @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)
!ifdef SIFTBUILD
        $(SIFTTOOL) $(SIFTFLAGS) $*.obj
!endif

.cpp{$(OBJDIR)}.lst:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $<  $(CC) $(COMPLOGO) -Fc$*.lst @$*.rsp
        @$(CC) $(COMPLOGO) -Fc$*.lst @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)


############################################################################
#
#   Build a Version resource (NT only) for every image in the build.
#
#   The user has the choice of either defining their own version resource
#  script or letting the build make one for them on the fly.  If the user
#  defines their own, set VERSION_RC in filelist.mk to point to a valid .rc
#  file (with the same format as $(VERSION_RC), below) and don't add that
#  file to the RCFILES macro in filelist.mk.  If the user does not define
#  VERSION_RC, build a default file by using TARGET_DESCRIPTION and
#  (optionally) TARGET_INTERNAL_NAME to the internal name (By default, the
#  target name minus the extension).
#

!ifdef IMAGE_TYPE_COFF
! if "$(OPSYS)" != "DOS"  #  BUGBUG: Chicago seems to fail on version resources  BryanT 9/28/93
! if "$(TARGETTYPE)" != "lib" && "$(TARGET)" != "RELEASE" && "$(TARGET)" != ""
!  if "$(VERSION_RC)" == ""
VERSION_RC = $(OBJDIR)\$(TARGETBASE).rc1

!   ifndef TARGET_DESCRIPTION
!    if "$(RELEASE)" != ""
!error *** BUILD ERROR - TARGET_DESCRIPTION not set.  Aborting. ***
!    endif
!   endif

!   if "$(TARGET_INTERNAL_NAME)" == ""
TARGET_INTERNAL_NAME = "$(TARGETBASE)"
!   endif

#  Set the major file type to one of DRV, APP, DLL, STATIC LIB, or UNKNOWN.

!   if "$(TARGETTYPE)" == "dll"
VFT_TYPE = VFT_DLL
!   elseif "$(TARGETTYPE)" == "exe"
VFT_TYPE = VFT_APP
!   elseif "$(TARGETTYPE)" == "lib"
VFT_TYPE = VFT_STATIC_LIB
!   else
VFT_TYPE = VFT_UNKNOWN
!   endif       # if "$(TARGETTYPE)" == "sys"

#  The Minor file type distinguishes the type of driver.  All DRV's in Cairo
#  are currently SYSTEM drivers.

!   if "$(TARGETTYPE)" == "sys"
VFT_TYPE2 = VFT2_DRV_SYSTEM
!   else
VFT_TYPE2 = VFT2_UNKNOWN
!   endif

all: $(VERSION_RC)

$(VERSION_RC): $(TYPESDIR)\makefile.inc
    @-md $(OBJDIR) $(OUTNUL)
    type << > $@
#include <windows.h>
#include <ntverp.h>
#define VER_FILETYPE              $(VFT_TYPE)
#define VER_FILESUBTYPE           $(VFT_TYPE2)
#define VER_FILEDESCRIPTION_STR   $(TARGET_DESCRIPTION)
#define VER_INTERNALNAME_STR      $(TARGET_INTERNAL_NAME)
#include <common.ver>
<<NOKEEP

!  endif        # if "$(VERSION_RC)" == ""

RCFILES    = $(VERSION_RC) $(RCFILES)

!else   # TARGETTYPE != lib && TARGET != RELEASE

VERSION_RC =

! endif  # TARGETTYPE != lib && TARGET != RELEASE
!endif  # OPSYS == DOS   BUGBUG: Chicago
!endif  # IMAGE_TYPE_COFF

######################################################################
#
#       Rule to build RES from RC file.
#
#       Note:  we mess with PATH because RC is not real clever about
#       finding RCPP (it's sub-component EXE).  It looks along PATH,
#       so we limit PATH here in order to guarantee that RCPATH is
#       in PATH, and also to avoid invoking a non-compatible RCPP that
#       might just be in the user's private toolset.
#
#       In the case of an NT build, COFF can't handle more than one
#       resource obj.  So, we build a single .rc2 file that #include's
#       all the component RCFILES.
#

!ifdef IMAGE_TYPE_COFF
! if "$(RCFILES)" != ""

$(OBJDIR)\$(TARGETBASE).rc2: $(RCFILES)
        @echo $(RCFILES) --^> $@ $(OUTPUT)
        type << | $(SED) -f $(SCRIPTS)\rcfiles.sed > $@
$(RCFILES: =
)
<<NOKEEP

$(OBJDIR)\$(TARGETBASE).res: $(OBJDIR)\$(TARGETBASE).rc2

{$(OBJDIR)}.rc2{$(OBJDIR)}.res:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        $(RC) $(ORCFLAGS) -I$(OBJDIR) $(RCFLAGS) $(MAKEDIR)\$(<R).tmp $(MAKEDIR)\$<
        $(CVTRES) -$(PLATFORM) -o $*.res $(MAKEDIR)\$(<R).tmp
! endif

!else

.rc{$(OBJDIR)}.res:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @set oldpath=%%PATH%%
        @set path=$(RCPATH)
        $(RC) $(ORCFLAGS) $(RCFLAGS) $*.res $(MAKEDIR)\$<
        @set path=%%oldpath%%
        @set oldpath=

!endif

######################################################################
#
#       Rule for building .lib files from .lrf files

.lrf{$(OBJDIR)}.lib:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        -$(DEL) $*.lib $(OUTNUL)
        @echo lib32 -out:@$< $(BUILD_EXE_PROCTYPE)
        @$(LIBUTIL) $(LIBFLAGS) @$<

.lrf.lib:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        if exist $*.lib $(DEL) $*.lib $(OUTNUL)
        @echo lib32 -out:@$< $(BUILD_EXE_PROCTYPE)
        $(LIBUTIL) $(LIBFLAGS) @$*.lrf


##################################################
#
#       Rules for generating .h and .c files from .idl files
#

##
## IDLUSE == none --> generate header file only
##

.idl{$(MIDL_HDR_OUT_DIR)}.h:
    @echo $< --^> $@ $(OUTPUT)
!ifdef IMAGE_TYPE_COFF
    $(MIDL) @<<$*.rsp $<
$(IDLMIDLFLAGS)
$(CINC)
-no_format_opt
-no_warn
-char unsigned
-mode c_port
-proxy $(MIDL_OUT_DIR)\$(@B)_p.c
-iid            $(MIDL_OUT_DIR)\$(@B)_i.c
-header         $(MIDL_HDR_OUT_DIR)\$(@B).h
-caux           $(MIDL_OUT_DIR)\$(@B)_x.c
-saux           $(MIDL_OUT_DIR)\$(@B)_y.c
-cpp_cmd
$(CC)
-cpp_opt "$(COMPLOGO) -DMIDL_PASS $(CPLATFORM) $(OCFLAGS) $(CINC) -E -Tc"
<<$(COMPRESP)
!else
    $(MIDL) $(CINC) -char unsigned -mode c_port -header $@ -cpp_cmd $(CC) -cpp_opt "$(COMPLOGO) @<<$*.rsp -Tc" $<
-DMIDL_PASS
-D$(PLATFORM)
$(OCFLAGS)
$(CINC)
-D$(PLATFORM)=1
-E
<<$(COMPRESP)
!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)"==""
        @echo Build_Status Releasing Midl generated  $(@B).h files to $(HCOPY)\chicago
        copy $(MIDL_HDR)OUT_DIR)\$(@B).h $(HCOPY)\chicago
!endif
!endif

#-proxy		$(MIDL_OUT_DIR)\$(@B)_p.c

##################################################
#       Provide some includes prefixes

INCLUDES_PREFIX= -L$$(OBJDIR) -S$$(OBJDIR)

INCLUDES_ROOTS=  $(INCLUDES_ROOTS) \
                 -P$$(BASEDIR)=$(BASEDIR)


OBJS=$(CXX_OBJS) \
     $(C_OBJS)   \
     $(PRECOMPOBJ) \
     $(PRECOMPXXOBJ) \
     $(OBJFILES)

############################################################################
#
#   Build a Link Include file.
#   Basically, every library we call that has a precompiled header needs
#   to have that header obj forced into the final image.  The .lic file built
#   with the pch provides that for us.  We just make a simple one with
#   NODEFAULTLIB and append any others we can find.  BryanT 4/14/93
#

!ifdef IMAGE_TYPE_COFF
! ifndef NEW_PCH_BUILD
TARGETLICS = $(TGTDIR)\$(TARGETBASE).tlc

$(TARGETLICS): $(OBJS) $(LIBS)
    @-md $(TGTDIR) $(OUTNUL)
    @echo -NODEFAULTLIB > KTx14J.lic
    @echo @echo off > $*.cmd
    @$(SED) -f $(SCRIPTS)\licfiles.sed << >> $*.cmd
$(LIBS: =
)
$(OBJS: =
)
<<NOKEEP
    @-$*.cmd
    @-$(DEL) $@  $(OUTNUL)
    @for %%i in (*.lic) do @type %i >> $@
    @-$(DEL) *.lic  $(OUTNUL)
! else

TARGETLICS =

! endif  # NEW_PCH_BUILD

!else

TARGETLICS =

!endif

############################################################################
#
# HACK for NT COFF limitation of only 1 .res obj per image.
#
# We force a single resfile name and handle generating it with the
# .rc->.rc2->,res rules.
#

!ifdef IMAGE_TYPE_COFF
! if "$(RCFILES)" != ""

RESFILES = $(OBJDIR)\$(TARGETBASE).res

! endif
!endif

############################################################################
#
#   Build a DLL or CPL (Control Panel Applet)
#

#BUGBUG BuildDLL

!if "$(TARGETTYPE)" == "dll"

! ifdef NOEXPORTS
DLLDEF=
! else
DLLDEF=     $(DEFFILEEXP)
! endif
DLLOBJS=    $(OBJS)
! ifdef SIFTBUILD
DLLOBJS = $(DLLOBJS) $(SIFTOBJ)
! endif # SIFTBUILD
DLLLIBS=    $(LIBS) $(OSLIBDLL) $(RTLIBDLL)
DLLRES=     $(RESFILES)

! ifndef NEW_PCH_BUILD
TLRSPFILE = @$(TARGETLICS)
! else
TLRSPFILE =
! endif

#
#   Link the DLL.
#

$(TGTDIR)\$(TARGET): $(DLLOBJS) $(DLLLIBS) $(DLLRES) $(DLLDEF) $(TYPESDIR)\coffbase.txt $(TARGETLICS)
    @$(ECHOTIME) Linking $@ $(ATSTR) $(TIMESTR)...      $(OUTPUT)
    @-md $(TGTDIR) $(OUTNUL)
! ifdef IMAGE_TYPE_COFF
    @echo link32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk $(TLRSPFILE)
$(DLLDEF)
$(LFLAGSDLL: =
)
$(DLLSTARTUP)
-OUT:$@
$(IMAGEBASE)
$(DLLOBJS: =
)
$(DLLRES)
$(DLLLIBS: =
)
<<$(LINKRESP)
!  ifndef NO_SPLITSYM
    $(SPLITSYM) $(SPLITSYMFLAGS) $@
!  endif
!if  "$(RELEASE_BIN)" != ""
    binplace $(BINPLACE_FLAGS) $@
!endif
!if "$(NO_RELEASE_IMPORT_LIB)" == "" && "$(LIBCP)" != ""
    $(COPY) $*.lib $(LIBCP)
!endif


CLEANTARGET=    $(CLEANTARGET)\
                $(OBJDIR)\$(TARGETBASE).lib\
                $(OBJDIR)\$(TARGETBASE).exp

! else  # IMAGE_TYPE_COFF
    @echo link32 -out:$*.dll $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk
$(LFLAGSDLL) $(DLLSTARTUP) $(DLLOBJS: = +^
)
$*.dll
$*.map
$(DLLLIBS: = +^
)
$(DLLDEF)
<<$(LINKRESP)
    if exist $(DLLRES) $(RC) $(RCEXEFLAGS) -fe $*.dll $(DLLRES) $*.dll
    $(MAPSYM) $(MAPSYMFLAGS) $*.map

#
#   Generate the import library.
#

all: $(OBJDIR)\$(TARGETBASE).lib

$(OBJDIR)\$(TARGETBASE).lib: $(DLLDEF:.\=)

CLEANTARGET=    $(CLEANTARGET) $(OBJDIR)\$(TARGETBASE).lib

! endif # IMAGE_TYPE_COFF

!endif  # Build DLL

############################################################################
#
#   Build a LIB
#

!if "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGETBASE).lib: $(OBJS) $(LIBS)
    @$(ECHOTIME) Building $@ $(ATSTR) $(TIMESTR)... $(OUTPUT)
    @-md $(OBJDIR) $(OUTNUL)
    -$(DEL) $@  $(OUTNUL)
! ifdef IMAGE_TYPE_COFF
    @echo lib32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LIBUTIL) @<<$*.lnb
$(LIBFLAGS: =
)
$(OBJS: =
)
$(LIBS: =
)
-OUT:$@
<<$(LINKRESP)

! else      # IMAGE_TYPE_COFF
    @echo lib32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LIBUTIL) $(LIBFLAGS) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJS: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(LINKRESP)

! endif     # IMAGE_TYPE_COFF

!endif  # Build LIB

############################################################################
#
#   Build an EXE
#

!if "$(TARGETTYPE)" == "exe"
! ifdef IMAGE_TYPE_COFF
EXEDEF=
! else
!  if "$(DEFFILE)" == ""
EXEDEF=
!  else
EXEDEF=         $(DEFFILEEXP)
!  endif
! endif
EXELIBS=        $(LIBS)\
! if "$(MTHREAD)" == "1"
                $(RTLIBEXEMT)\
! else
                $(RTLIBEXE)\
! endif
                $(OSLIBEXE)

EXEOBJS=        $(OBJS)

!ifdef SIFTBUILD
EXEOBJS = $(EXEOBJS) $(SIFTOBJ)
!endif  # SIFTBUILD

EXERES=         $(RESFILES)

#
#   Link the EXE.
#

! ifndef NEW_PCH_BUILD
TLRSPFILE = @$(TARGETLICS)
! else
TLRSPFILE =
! endif

#
#   Need WINSTUB.EXE to build WIN16 targets -- "DOS" "i286"
#

WINSTUB=$(RCPATH)\winstub.exe

$(TGTDIR)\$(TARGET): $(EXEOBJS) $(EXELIBS) $(EXERES) $(EXEDEF) $(TARGETLICS)
!if "$(OPSYS)" == "DOS" && "$(PROCESSOR_ARCHITECTURE)" == "i286"
    $(COPY) $(WINSTUB) .
!endif
    @$(ECHOTIME) Linking $@ $(ATSTR) $(TIMESTR)...    $(OUTPUT)
    @-md $(TGTDIR) $(OUTNUL)
! ifdef IMAGE_TYPE_COFF
    @echo link32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk $(TLRSPFILE)
$(LFLAGSEXE: =
)
$(EXESTARTUP)
$(EXEOBJS: =
)
$(EXELIBS: =
)
$(EXERES)
-OUT:$@
$(IMAGEBASE)
!  if "$(NTDEBUGTYPE)" == "windbg" && "$(PROCESSOR_ARCHITECTURE)" == "x86"
-nopack
!  endif
<<$(LINKRESP)
!  if "$(NTDEBUGTYPE)" == "windbg" && "$(PROCESSOR_ARCHITECTURE)" == "x86"
    $(CVPACK) -nologo $@
!  endif
!  ifndef NO_SPLITSYM
   $(SPLITSYM) $(SPLITSYMFLAGS) $@
!  endif
! else   # IMAGE_TYPE_COFF
    @echo link32 -out:$*.exe $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk
$(LFLAGSEXE) $(EXESTARTUP) +
$(EXEOBJS: = +^
)
$*.exe
$*.map
$(EXELIBS: = +^
)
$(EXEDEF)
<<$(LINKRESP)
!if "$(OPSYS)" == "DOS" && "$(PROCESSOR_ARCHITECTURE)" == "i286"
    if exist $(EXERES) $(RC) $(RCEXEFLAGS) -fe $*.exe $(EXERES) $*.exe
    -$(DEL) winstub.exe
!else
    if exist $(EXERES) $(RC) $(RCEXEFLAGS) -fo $*.exe $(EXERES) $*.exe
!endif
    $(MAPSYM) $(MAPSYMFLAGS) $*.map
! endif  # IMAGE_TYPE_COFF

!endif  # Build EXE

######################################################################
#       IMPLIB files (unlike their real lib counterparts)
#       live in the source directory, not in a version
#       specific subdirectory

!if "$(NO_IMPLIB)" == ""
! ifdef IMAGE_TYPE_COFF

$(DEFFILEEXP) $(DEFFILELIB): $(DEFFILE)
    @echo $(DEFFILE) --^> $@ $(OUTPUT)
    @-md $(OBJDIR) $(OUTNUL)
    $(CC) $(COMPLOGO) @<<$*.rsp 1>$*.def
$(CPLATFORM)
$(CDEBUGFLAGS)
$(CINC: =
)
-EP
-Tc $**
<<$(COMPRESP)
    $(LIBUTIL) @<<$*.lsp
$(LIBFLAGS)
-OUT:$(DEFFILELIB)
-DEF:$*.def
<<$(LINKRESP)

.def{$(OBJDIR)}.lib:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        $(CC) $(COMPLOGO) @<<$*.rsp 1>$(OBJDIR)\$<
$(CPLATFORM)
$(CDEBUGFLAGS)
$(CINC: =
)
-EP
-Tc $<
<<$(COMPRESP)
        $(LIBUTIL) @<<$*.lsp
$(LIBFLAGS)
-OUT:$@
-DEF:$(OBJDIR)\$<
<<$(LINKRESP)

! else    # IMAGE_TYPE_COFF

IMPFLAGS=-nologo -noignorecase

.def.lib:
        @echo $< --^> $@ $(OUTPUT)
        $(IMPLIB) $(IMPFLAGS) $@ $<

$(DEFFILEEXP): $(DEFFILE)
        @echo $(DEFFILE) --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        $(CC) $(COMPLOGO) @<<$*.rsp  1>$(DEFFILEEXP)
$(ALLCFLAGS: =
)
$(CINC: =
)
-EP
-Tc $**
<<$(COMPRESP)

$(DEFFILELIB): $(DEFFILEEXP)
        @echo $(DEFFILEEXP) --^> $@ $(OUTPUT)
        $(IMPLIB) $(IMPFLAGS) $(DEFFILELIB) $(DEFFILEEXP)

! endif   # IMAGE_TYPE_COFF
!endif   # NO_IMPLIB

############################################################################
#
#   Cleanup
#

!if defined(TARGET) || defined(CLEANTARGET)

clean: cleanobj

cleanobj:
! if "$(HOST)" == "NT"
    -$(DEL) /q $(OBJDIR) $(OUTNUL)
! else
    -echo y | $(DEL) $(OBJDIR) $(OUTNUL)
! endif
    -rmdir $(OBJDIR) $(OUTNUL)

cleantarget:
! if "$(HOST)" == "NT"
    -$(DEL) /q $(CLEANTARGET) $(OUTNUL)
! else
    -echo y | $(DEL) $(CLEANTARGET) $(OUTNUL)
! endif

!endif

!ifdef CLEANFILES

clean: cleanclean

cleanclean:
    -$(DEL) $(CLEANFILES) $(OUTNUL)

!endif

!ifdef LIBCOPY
! if "$(TARGETTYPE)" == "lib" || "$(TARGETTYPE)" == "dll"

clean: cleanlibcopy

cleanlibcopy:
   -$(DEL) $(LIBCOPY)\$(TARGETBASE).lib $(OUTNUL)
   -$(DEL) $(LIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)" == ""
   -$(DEL) $(CHICAGOLIBCOPY)\$(TARGETBASE).lib $(OUTNUL)
   -$(DEL) $(CHICAGOLIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!endif

! endif
!endif

!ifdef DLLCOPY
! if "$(TARGETTYPE)" == "dll"

clean: cleandllcopy

cleandllcopy:
   -$(DEL) $(DLLCOPY)\$(TARGETBASE).dll $(OUTNUL)
   -$(DEL) $(DLLCOPY)\$(TARGETBASE).dbg $(OUTNUL)
! endif
!endif

!ifdef EXECOPY
! if "$(TARGETTYPE)" == "exe"

clean: cleanexecopy

cleanexecopy:
   -$(DEL) $(EXECOPY)\$(TARGETBASE).exe $(OUTNUL)
   -$(DEL) $(EXECOPY)\$(TARGETBASE).dbg $(OUTNUL)
! endif
!endif

!if "$(TLBCOPY)" != ""

clean: cleantlbcopy

cleantlbcopy:
        @echo WARNING - Can't clean Type Library copies in $(TLBCOPY).

!endif

############################################################################
#
#   Copy targets to other directories.
#
copy:

!ifdef LIBCOPY

! if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "lib"

copy: $(LIBCOPY)\$(TARGETBASE).lib

$(LIBCOPY)\$(TARGETBASE).lib: $(OBJDIR)\$(TARGETBASE).lib
    @echo Copying $(TARGETBASE).lib to $(LIBCOPY)... $(OUTPUT)
    @-md $(LIBCOPY) $(OUTNUL)
    @-$(CHMODE) -r $(LIBCOPY)\$(TARGETBASE).lib $(OUTNUL)
    @-$(CHMODE) -r $(LIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
    $(COPY) $(OBJDIR)\$(TARGETBASE).lib $(LIBCOPY)\$(TARGETBASE).lib
    @-$(COPY) $(OBJDIR)\$(TARGETBASE).lic $(LIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!if "$(OPSYS)" == "NT1X" && "$(NORELEASE_CHICAGO)" == ""
    @echo Releasing  $(TARGETBASE).lib for Chicago...  $(OUTPUT)
    @-md $(CHICAGOLIBCOPY) $(OUTNUL)
    @-$(CHMODE) -r $(CHICAGOLIBCOPY)$(TARGETBASE).lib $(OUTNUL)
    @-$(CHMODE) -r $(CHICAGOLIBCOPY)$(TARGETBASE).lic $(OUTNUL)
    $(COPY) $(OBJDIR)\$(TARGETBASE).lib $(CHICAGOLIBCOPY)\$(TARGETBASE).lib
    @-$(COPY) $(OBJDIR)\$(TARGETBASE).lic $(CHICAGOLIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!endif

! endif # dll or lib

!endif # LIBCOPY

!ifdef DLLCOPY

! if "$(TARGETTYPE)" == "dll"

copy: $(DLLCOPY)\$(TARGETBASE).dll

$(DLLCOPY)\$(TARGETBASE).dll: $(TGTDIR)\$(TARGETBASE).dll
    @echo Copying $(TARGETBASE).dll to $(DLLCOPY)... $(OUTPUT)
    @-md $(DLLCOPY) $(OUTNUL)
    @-$(CHMODE) -r $(DLLCOPY)\$(TARGETBASE).dll $(OUTNUL)
    @-$(CHMODE) -r $(DLLCOPY)\$(TARGETBASE).dbg $(OUTNUL)
    $(COPY) $(TGTDIR)\$(TARGETBASE).dll $(DLLCOPY)\$(TARGETBASE).dll
    @-$(COPY) $(TGTDIR)\$(TARGETBASE).dbg $(DLLCOPY)\$(TARGETBASE).dbg $(OUTNUL)
! endif # dll

!endif # DLLCOPY

!ifdef EXECOPY

! if "$(TARGETTYPE)" == "exe"

copy: $(EXECOPY)\$(TARGETBASE).exe

$(EXECOPY)\$(TARGETBASE).exe: $(TGTDIR)\$(TARGETBASE).exe
    @echo Copying $(TARGETBASE).exe to $(EXECOPY)... $(OUTPUT)
    @-md $(EXECOPY) $(OUTNUL)
    @-$(CHMODE) -r $(EXECOPY)\$(TARGETBASE).exe $(OUTNUL)
    @-$(CHMODE) -r $(EXECOPY)\$(TARGETBASE).dbg $(OUTNUL)
    $(COPY) $(TGTDIR)\$(TARGETBASE).exe $(EXECOPY)\$(TARGETBASE).exe
    @-$(COPY) $(TGTDIR)\$(TARGETBASE).dbg $(EXECOPY)\$(TARGETBASE).dbg $(OUTNUL)

! endif # exe

!endif # EXECOPY

!if "$(TLBCOPY)" != "" && "$(TYPELIBS)" != ""

copy: copytlbfiles

copytlbfiles: $(TYPELIBS)
        @echo Build_Status Copying Type Libraries to "$(TLBCOPY)"... $(OUTPUT)
        @-md $(TLBCOPY) $(OUTNUL)
        !$(COPY) $** $(TLBCOPY)
        !$(UNREGTLB) $**
        !$(REGTLB) $(TLBCOPY)\$(**F)

!else

copytlbfiles:

!endif

############################################################################
#
#   Generate external header file
#

!ifdef HFILES

all: $(TARGETBASE).h

clean: cleanh

cleanh:
    -$(DEL) $(TARGETBASE).h $(OUTNUL)

$(TARGETBASE).h: $(HFILES)
    @echo Generating $(TARGETBASE).h $(OUTPUT)
    $(SED) -f $(SCRIPTS)\public.sed $(HFILES) >$(TMP)\$(TARGETBASE).h
    -$(CMP) -s $(TMP)\$(TARGETBASE).h $@ 2>nul || $(COPY) $(TMP)\$(TARGETBASE).h $@
    -$(DEL) $(TMP)\$(TARGETBASE).h $(OUTNUL)

DEPENDFILES = $(DEPENDFILES) $(TARGETBASE).h

!endif

############################################################################
#
#   Resource files dependencies
#

!if "$(RESFILES)" != ""
$(RESFILES): $(RCFILES) $(RCOBJECTS)
!endif

############################################################################
#
#   Dependencies
#

!if "$(DEPENDSRC)" == "" && \
    "$(CXXFILES)"  == "" && \
    "$(CPPFILES)"  == "" && \
    "$(CFILES)"    == "" && \
    "$(IDLFILES)"  == "" && \
    "$(TDLFILES)"  == ""

depend:

!else

! if "$(DEPENDSRC)" == "" && \
     "$(CXXFILES)"  == "" && \
     "$(CPPFILES)"  == "" && \
     "$(CFILES)"    == ""
DEPENDSRC=
! else
DEPENDSRC=$(DEPENDSRC) $(CXXFILES) $(CPPFILES) $(CFILES)
! endif

depend: dependfile

!ifdef MULTIDEPEND
DEPENDFILE=depend.mk$(RDEXT)
NEWDEPENDFILE=depend.ne$(RDEXT)
!else
DEPENDFILE=depend.mk
NEWDEPENDFILE=depend.new
!endif

OBJPATTERN=$(OBJDIR:\=\\)

#########################################################################
#
#  Here's where the dependencies are actually generated.  We break up
#  the CINC, INCLUDES_ROOTS, and src macros to put one command on each
#  to ensure no one line is over 1024 bytes in length.  The includes
#  tool reads in 1k bytes and get's confused if any one line is split.
#

INCLUDES_FLAGS = $(INCLUDES_FLAGS) -nntos.h -nzwapi.h -dos

!if "$(OPSYS)"=="NT1X"
INCLUDES_FLAGS =$(INCLUDES_FLAGS) -nole2.h
!endif

dependfile: $(DEPENDFILES)
    $(ECHOTIME) # ; # Built automatically ; # ; >$(NEWDEPENDFILE)
!if "$(DEPENDSRC)" != ""
#
#   Source file dependencies
#
    $(ECHOTIME) # ; # Source files ; # ; >>$(NEWDEPENDFILE)
    $(INCLUDES) @<< >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
$(INCLUDES_PREFIX)
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
$(DEPENDSRC:.\=
.\)
<<NOKEEP
!endif # DEPENDSRC

#
#   MIDL dependencies
#

!if "$(IDLFILES)" != ""
    $(ECHOTIME) # ; # MIDL Source files ; # ; >>$(NEWDEPENDFILE)
    $(INCLUDES) @<<idl.tmp >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
-sh
-S$$(MIDL_HDR_OUT_DIR)
$(IDLFILES:.\=
.\)
<<NOKEEP
!endif # IDLFILES

!if "$(TDLFILES)" != ""
    $(ECHOTIME) # ; # MkTypeLib Source files ; # ; >>$(NEWDEPENDFILE)
    $(INCLUDES) @<<tdl.tmp >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
-stlb
-S$$(OBJDIR)
$(TDLFILES:.\=
.\)
<<NOKEEP

!endif # IDLFILES

#
#   C++ PCH dependencies
#

!if "$(PXXFILE)" != ""
    $(ECHOTIME) # ; # Precompiled C++ header ; # ; ; !ifdef PXXFILE >>$(NEWDEPENDFILE)
#    if exist $(PXXSOURCE) $(INCLUDES) @<<  >>$(NEWDEPENDFILE)
    if exist $(PXXSOURCE) $(INCLUDES) $(INCLUDES_FLAGS) -e -S$$(PCHDIR)\$$(OBJDIR) \
        -L$$(PCHDIR)\$$(OBJDIR) -spxh $(CINC:-I=-I) $(INCLUDES_ROOTS:-P=-P)\
        $(PXXSOURCE) >>$(NEWDEPENDFILE)
#$(INCLUDES_FLAGS)
#-e
#-S$$(PCHDIR)\$$(OBJDIR)
#-L$$(PCHDIR)\$$(OBJDIR)
#-spxh
#$(CINC:-I=
#-I)
#$(INCLUDES_ROOTS:-P=
#-P)
#$(PXXSOURCE)
#<<NOKEEP
    $(SED) "s/$(OBJPATTERN)\(.*\)/$$(OBJDIR)\1 : \
$$(PCHDIR)\\$$(OBJDIR)\\$(PXXFILE:.cxx=.pxh)/" << >>$(NEWDEPENDFILE)
$(CXX_OBJS: =^
)
<<NOKEEP
    $(ECHOTIME) !endif # PXXFILE ; ;>>$(NEWDEPENDFILE)
!endif

#
#   C PCH dependencies
#

!if "$(PFILE)" != ""
    $(ECHOTIME) # ; # Precompiled C header ; # ; ; !ifdef PFILE >>$(NEWDEPENDFILE)
    if exist $(PSOURCE) $(INCLUDES) @<< >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
-S$$(PCHDIR)\$$(OBJDIR)
-L$$(PCHDIR)\$$(OBJDIR)
-sph
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
$(PSOURCE)
<<NOKEEP
    $(ECHOTIME) $(C_OBJS:.obj =.obj ; )| \
        $(SED) "s/$(OBJPATTERN)/$$(OBJDIR)/" | \
        $(SED) "s/\.obj/.obj : $$(PCHDIR)\\$$(OBJDIR)\\$(PFILE:.c=.ph)/" >>$(NEWDEPENDFILE)
    $(ECHOTIME) !endif # PFILE ; ;>>$(NEWDEPENDFILE)
!endif
    @$(CMP) -s $(NEWDEPENDFILE) $(DEPENDFILE) $(OUTNUL) || \
        $(COPY) $(NEWDEPENDFILE) $(DEPENDFILE) $(OUTNUL) || \
        (out -f -! $(DEPENDFILE) && $(ECHOTIME) $(DEPENDFILE) checked out... & $(COPY) $(NEWDEPENDFILE) $(DEPENDFILE) $(OUTNUL))
    $(DEL) $(NEWDEPENDFILE) $(OUTNUL)

!endif # DEPENDSRC

############################################################################
#
#   Special Rules for Building NT-like parts of the tree.  For instance,
#   OFS.  Defining RELEASE=NT causes the build to be performed 2 times for
#   this part of the tree.  Once with the current BUILDTYPE, once with the
#   opposite one.  In either case, we release under the current build in
#   either a CHECK\NT\... tree (for DEBUG BUILDTYPE) or FREE\NT\... tree
#   (for RETAIL BUILDTYPE).
#

!if ("$(RELEASE)" == "NT" && "$(BUILD_BOTH)" != "FALSE") || "$(BUILD_BOTH)" == "TRUE"

! if "$(BUILDTYPE)" == "DEBUG"
SECONDBUILDTYPE = RETAIL
! else
SECONDBUILDTYPE = DEBUG
! endif

all tree clean:
      @$(MAKE) -$(MAKEFLAGS) -L BUILDTYPE=$(SECONDBUILDTYPE) RELEASETREE=$(TGTDIR:OBJ=) BUILD_BOTH=FALSE $@

!endif   # RELEASE = NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\cfrace\cfrace.h ===
#ifndef __CFRACE_H__
#define __CFRACE_H__

BOOL TestCFRace(void);

#endif // __CFRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\cfrace\cfrace.cxx ===
//+------------------------------------------------------------------
//
// File:	cfrace.cxx
//
// Contents:	test for class factory race condition
//
//--------------------------------------------------------------------
#include <tstmain.hxx>
#include "cfrace.h"
#include <iballs.h>

// BUGBUG: these should be in a public place somewhere.
DEFINE_OLEGUID(CLSID_Balls,	    0x0000013a, 1, 8);
DEFINE_OLEGUID(CLSID_Cubes,	    0x0000013b, 1, 8);
DEFINE_OLEGUID(CLSID_LoopSrv,	    0x0000013c, 1, 8);

DEFINE_OLEGUID(CLSID_QI,	    0x00000140, 0, 8);
const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

DWORD gdwSleepValue = 400;

LONG gcFails = 0;

void TEST_FAILED2(HRESULT hRes, CHAR *pszMsg)
{
    BOOL RetVal = TRUE;
    CHAR szMsg2[80];

    if (FAILED(hRes))
    {
	gcFails++;
	sprintf(szMsg2, "Error:%x %s", hRes, pszMsg);
    }

    TEST_FAILED(FAILED(hRes), (FAILED(hRes)) ? szMsg2 : pszMsg);
}

void TEST_FAILED3(ULONG cRefs, CHAR *pszMsg)
{
    BOOL RetVal = TRUE;
    CHAR szMsg2[80];

    if (cRefs != 0)
    {
	gcFails++;
	sprintf(szMsg2, "cRefs:%x %s", cRefs, pszMsg);
    }

    TEST_FAILED(cRefs != 0, (cRefs != 0) ? szMsg2 : pszMsg);
}

// ----------------------------------------------------------------------
//
//	TestCFRace - main test driver. read the ini file to determine
//		     which tests to run.
//
// ----------------------------------------------------------------------
BOOL TestCFRace(void)
{
    BOOL RetVal = TRUE;
    CHAR szMsg[80];
    LONG cLoops = 0;

    while (1)
    {
	IClassFactory	*pICF	 = NULL;
	IBalls		*pIBalls = NULL;
	ULONG		cRefs	 = 0;

	// get the class object
	HRESULT hRes = CoGetClassObject(CLSID_Balls, CLSCTX_LOCAL_SERVER, NULL,
					IID_IClassFactory, (void **)&pICF);

	TEST_FAILED2(hRes, "CoGetClassObject failed\n");

	if (SUCCEEDED(hRes))
	{
	    // lock server
	    hRes = pICF->LockServer(TRUE);
	    TEST_FAILED2(hRes, "LockServer TRUE failed\n");

	    if (SUCCEEDED(hRes))
	    {
		// create instance
		hRes = pICF->CreateInstance(NULL, IID_IBalls, (void **)&pIBalls);
		TEST_FAILED2(hRes, "CreateInstance failed\n");

		// unlock server
		hRes = pICF->LockServer(FALSE);
		TEST_FAILED2(hRes, "LockServer FALSE failed\n");
	    }

	    // release class object
	    cRefs = pICF->Release();
	    TEST_FAILED3(cRefs, "Release pICF not 0\n");

	    if (pIBalls)
	    {
		// call instance
		hRes = pIBalls->MoveBall(10, 20);
		TEST_FAILED2(hRes, "pIBalls MoveBall failed\n");

		// release instance
		cRefs = pIBalls->Release();
		TEST_FAILED3(cRefs, "Release pIBalls not 0\n");
	    }
	}

	cLoops++;
	sprintf(szMsg, "    - Iterations:%x  Fails:%x\n", cLoops, gcFails);
	OUTPUT(szMsg);
	Sleep(gdwSleepValue);
    }

    return  RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the general build options for this subtree.

!ENDIF

MAJORCOMP   = oletest
MINORCOMP   = com

!include      ..\..\..\daytona.inc

INCLUDES=     ;..;$(OLEBALLSDIR)\common;
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\daytona

UMTYPE=       windows
UMENTRY=      winmain
UMAPPL=
UMTEST=

UMLIBS=       $(OLEBALLSDIR)\common\daytona\$(O)\servers.lib	\
	      $(OLEUTESTDIR)\balls\oleprx32\uuid\daytona\$(O)\uuid.lib	   \
	      $(OLEDIR)\common\daytona\$(O)\common.lib	   \
	      $(SDK_LIB_PATH)\uuid.lib	   \
	      $(SDK_LIB_PATH)\ole32.lib	   \
              $(SDK_LIB_PATH)\rpcndr.lib       \
              $(SDK_LIB_PATH)\rpcrt4.lib       \
              $(SDK_LIB_PATH)\rpcns4.lib       \
              $(SDK_LIB_PATH)\mpr.lib          \
              $(SDK_LIB_PATH)\netapi32.lib     \
              $(SDK_LIB_PATH)\kernel32.lib     \
	      $(SDK_LIB_PATH)\user32.lib	   \
	      $(SDK_LIB_PATH)\gdi32.lib	   \
	      $(SDK_LIB_PATH)\advapi32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\cfrace\main.cxx ===
//+------------------------------------------------------------------
//
// File:	main.cxx
//
// Contents:	common entry point for test drivers.
//
//--------------------------------------------------------------------
#include    <tstmain.hxx>
#include    <cfrace.h>

//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//  Just delegates to a <main> subroutine that is common for all test
//  drivers.
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    return DriverMain(argc, argv, "Class Factory Race", &TestCFRace);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\dllhost\tdllhost.h ===
#ifndef __TDLLHOST_H__
#define __TDLLHOST_H__

BOOL TestDllHost(void);

#endif // __TDLLHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\dllhost\main.cxx ===
//+------------------------------------------------------------------
//
// File:	main.cxx
//
// Contents:	common entry point for test drivers.
//
//--------------------------------------------------------------------
#include    <tstmain.hxx>
#include    <tdllhost.h>

//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//  Just delegates to a <main> subroutine that is common for all test
//  drivers.
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    return DriverMain(argc, argv, "Dll Host", &TestDllHost);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\smarshal\smarshal.cxx ===
//+-------------------------------------------------------------------
//
//  File:	smarshal.cxx
//
//  Synopsis:	Source code for Interface Marshaling stress test main
//		driver functions. Source for individual tests is in
//		testvar.cxx
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
#include <smarshal.hxx>

//+-------------------------------------------------------------------
//
//  Globals:
//
//--------------------------------------------------------------------
BOOL  gfVerbose		= FALSE;    // print execution messages
BOOL  gfDebug		= FALSE;    // print debug messages

DWORD giThreadModel	= OPF_INITAPARTMENT; // threading model to use
int   giTestVar		= 0;	    // test variation to run
int   giHighestTestVar	= 2;	    // highest test var supported

int  gicReps		= 5;	    // number of repetitions of each test
int  gicThreads 	= 1;	    // number of threads to use on each test


//+-------------------------------------------------------------------
//
//  Private Function ProtoTypes:
//
//--------------------------------------------------------------------
HRESULT 	DoIfOperation(DWORD dwFlags, INTERFACEPARAMS *pIFD);
void		DisplayHelp(void);
BOOL		GetSwitch(CHAR *pCmdParam, CHAR *pszSwitch);
BOOL		GetSwitchInt(CHAR *pCmdParam, CHAR *pszSwitch, int *pInt);
BOOL		ParseCmdLine(int argc, char **argv);
int  _cdecl	main(int argc, char **argv);

BOOL		FreeWaitForEvent(HANDLE hEvent);
BOOL		AptWaitForEvent(HANDLE hEvent);

STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phdl);

//+-------------------------------------------------------------------
//
//  Misc:
//
//--------------------------------------------------------------------

#ifndef _CAIRO_
// COM initialization flags; passed to CoInitialize.
typedef enum tagCOINIT
{
    COINIT_MULTITHREADED      = 0,  // OLE calls objects on any thread.
    COINIT_SINGLETHREADED     = 1,  // OLE calls objects on single thread.
    COINIT_APARTMENTTHREADED  = 2   // Apartment model
} COINIT;

WINOLEAPI  CoInitializeEx(LPVOID pvReserved, DWORD);
#endif



//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE. Parse the command line, then run
//		whatever test variations were selected.
//
//  Notes:	The test variation code is in testvars.cxx.
//		The rest of this file is helper routines.
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    // parse the command line
    BOOL fRes = ParseCmdLine(argc, argv);

    if (fRes)
    {
	// run the selected test variations
	switch (giTestVar)
	{
	    case 1: fRes = TestVar1();
		    break;
	    case 2: fRes = TestVar2();
		    break;
	    default: break;
	}
    }

    // check the results
    CHKTESTRESULT(fRes, "Marshal Stress Tests");
    return 0;
}

//+-------------------------------------------------------------------
//
//  Function:	ParseCmdLine
//
//  Synopsis:	parses the execution parameters
//
//--------------------------------------------------------------------
BOOL ParseCmdLine(int argc, char **argv)
{
    BOOL fDontRun = (argc == 1) ? TRUE : FALSE;

    // the first parameter is the EXE name, skip it.
    argc--;
    argv++;

    for (int i=0; i<argc; i++, argv++)
    {
	if (GetSwitch(*argv, "v"))
	{
	    // run verbose
	    gfVerbose = TRUE;
	}
	else if (GetSwitch(*argv, "d"))
	{
	    // run debug mode
	    gfVerbose = TRUE;
	    gfDebug   = TRUE;
	}
	else if (GetSwitch(*argv, "h") || GetSwitch(*argv, "?"))
	{
	    // help wanted
	    fDontRun = TRUE;
	}
	else if (GetSwitchInt(*argv, "var:", &giTestVar))
	{
	    // selected test variation, ensure the variation is valid
	    if (giTestVar > giHighestTestVar)
	    {
		ERROUT("Unknown Test Variation:%x\n", giTestVar);
		fDontRun = TRUE;
	    }
	}
	else if (GetSwitchInt(*argv, "reps:", &gicReps))
	{
	    ; // selected repetition count
	}
	else if (GetSwitchInt(*argv, "threads:", &gicThreads))
	{
	    ; // selected thread count
	}
	else if (GetSwitch(*argv, "model:apt"))
	{
	    // run apartment model
	    giThreadModel = OPF_INITAPARTMENT;
	}
	else if (GetSwitch(*argv, "model:free"))
	{
	    // run freethreaded model
	    giThreadModel = OPF_INITFREE;
	}
	else
	{
	    // unknown switch, show help
	    ERROUT("Unknown command line switch:<%s>\n", *argv);
	    fDontRun = TRUE;
	}
    }

    if (fDontRun)
    {
	// help is wanted
	DisplayHelp();
	return FALSE;
    }

    // success, run the test
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	DisplayHelp
//
//  Synopsis:	displays a command line help message
//
//--------------------------------------------------------------------
void DisplayHelp(void)
{
    printf("\nCommand Line Switches for Marshal Stress Test:\n\n");

    printf("-d         - debug mode\n");
    printf("-v         - verbose mode\n");
    printf("-h | -?    - display this help message\n\n");

    printf("-model:[apt|free] - threading model to use for test\n");
    printf("-var:#     - test variation to execute 1-%x\n", giHighestTestVar);
    printf("-threads:# - number of threads per variation\n");
    printf("-reps:#    - number of repetitions of the test\n");

    printf("\n");
}

//+-------------------------------------------------------------------
//
//  Function:	GetSwitch
//
//  Synopsis:	returns TRUE if the specified cmd line switch is set.
//
//--------------------------------------------------------------------
BOOL GetSwitch(CHAR *pCmdParam, CHAR *pszSwitch)
{
    if (*pCmdParam == '-' || *pCmdParam == '/')
    {
	pCmdParam++;
	return (!stricmp(pCmdParam, pszSwitch));
    }
    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Function:	GetSwitchInt
//
//  Synopsis:	returns TRUE if the specified cmd line switch is set,
//		and sets the value of that switch.
//
//--------------------------------------------------------------------
BOOL GetSwitchInt(CHAR *pCmdParam, CHAR *pszSwitch, int *pInt)
{
    if (*pCmdParam == '-' || *pCmdParam == '/')
    {
	pCmdParam++;
	int len = strlen(pszSwitch);
	if (!strnicmp(pCmdParam, pszSwitch, len))
	{
	    pCmdParam += len;
	    *pInt = atoi(pCmdParam);
	    return TRUE;
	}
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Function:	CHKRESULT
//
//  Synopsis:	prints a failure message if the result code indicates
//		failure., and success message only in verbose mode.
//
//--------------------------------------------------------------------
void CHKRESULT(HRESULT hr, CHAR *pszOperation)
{
    if (FAILED(hr))
    {
	printf("FAILED hr:%x Op:%s\n", hr, pszOperation);
    }
    else if (gfVerbose)
    {
	printf("PASSED hr:%x Op:%s\n", hr, pszOperation);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	CHKOP
//
//  Synopsis:	prints a failure message if the result code indicates
//		failure, and success message only in debug mode.
//
//--------------------------------------------------------------------
void CHKOP(HRESULT hr, CHAR *pszOperation)
{
    if (FAILED(hr))
    {
	printf("FAILED hr:%x Op:%s\n", hr, pszOperation);
    }
    else if (gfDebug)
    {
	printf("PASSED hr:%x Op:%s\n", hr, pszOperation);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	CHKTESTRESULT
//
//  Synopsis:	prints a pass or fail message
//
//--------------------------------------------------------------------
void CHKTESTRESULT(BOOL fRes, CHAR *pszMsg)
{
    if (fRes)
	printf("%s PASSED\n", pszMsg);
    else
	printf("%s FAILED\n", pszMsg);
}

//+-------------------------------------------------------------------
//
//  Function:	GetEvent / ReleaseEvent
//
//  Synopsis:	allocates or releases an event
//
//  CODEWORK:	cache these for frequent use
//
//--------------------------------------------------------------------
HANDLE GetEvent()
{
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL)
    {
	ERROUT("GetEvent FAILED\n");
    }
    DBGOUT("CreateEvent hEvent:%x\n", hEvent);
    return hEvent;
}

void ReleaseEvent(HANDLE hEvent)
{
    if (hEvent)
    {
	DBGOUT("ReleaseEvent hEvent:%x\n", hEvent);
	CloseHandle(hEvent);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	WaitForEvent
//
//  Synopsis:	waits on the given event (if there is one) for a
//		certain amount of time, returns FALSE if timedout.
//
//--------------------------------------------------------------------
BOOL WaitForEvent(HANDLE hEvent)
{
    if (hEvent)
    {
	// CODEWORK: base off the Threading Model

	return (TRUE) ? AptWaitForEvent(hEvent) :
			FreeWaitForEvent(hEvent);
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	FreeWaitForEvent
//
//  Synopsis:	FreeThreaded version of WaitForEvent. Waits on the
//		given event.
//
//--------------------------------------------------------------------
BOOL FreeWaitForEvent(HANDLE hEvent)
{
    DBGOUT("FreeWaitForEvent hEvent:%x\n", hEvent);
    if (WaitForSingleObject(hEvent, 30000) == WAIT_TIMEOUT)
    {
	ERROUT("WaitForSingleObject TimedOut");
	return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	AptWaitForEvent
//
//  Synopsis:	Apartment model version of WaitForEvent. Waits on the
//		given event. Dispatches all incoming windows messages
//		while waiting.
//
//--------------------------------------------------------------------
BOOL AptWaitForEvent(HANDLE hEvent)
{
    DBGOUT("AptWaitForEvent hEvent:%x\n", hEvent);

    while (1)
    {
	HANDLE	arEvent[] = {hEvent};
	DWORD dwWakeReason = MsgWaitForMultipleObjects(1, arEvent, FALSE,
						       1000, QS_ALLINPUT);

	if (dwWakeReason == WAIT_OBJECT_0)
	{
	    // event was signalled. exit.
	    break;
	}
	else
	{
	    // check for and dispatch any messages that have arrived
	    MSG msg;
	    while (PeekMessage(&msg, 0, WM_NULL, WM_NULL, PM_REMOVE))
	    {
		DispatchMessage(&msg);
	    }
	}
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	SignalEvent
//
//  Synopsis:	signals an event (if there is one)
//
//--------------------------------------------------------------------
void SignalEvent(HANDLE hEvent)
{
    if (hEvent)
    {
	DBGOUT("SignalEvent hEvent:%x\n", hEvent);
	SetEvent(hEvent);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	GetStream / ReleaseStream
//
//  Synopsis:	allocates or releases a Stream
//
//  CODEWORK:	cache these for frequent use
//  CODEWORK:	use CStreamOnFile for cross process/machine marshaling.
//
//--------------------------------------------------------------------
IStream * GetStream(void)
{
    IStream *pStm = CreateMemStm(600, NULL);
    if (pStm == NULL)
    {
	ERROUT("ERROR: GetStream FAILED\n");
    }
    DBGOUT("GetStream pStm:%x\n", pStm);
    return pStm;
}

void ReleaseStream(IStream *pStm)
{
    if (pStm)
    {
	DBGOUT("ReleaseStream pStm:%x\n", pStm);
	pStm->Release();
    }
}

//+-------------------------------------------------------------------
//
//  Function:	ResetStream
//
//  Synopsis:	resets a steam back to the start
//
//--------------------------------------------------------------------
HRESULT ResetStream(IStream *pStm)
{
    DBGOUT("ResetStream pStm:%x\n", pStm);

    LARGE_INTEGER libMove;
    libMove.LowPart = 0;
    libMove.HighPart = 0;

    HRESULT hr = pStm->Seek(libMove, STREAM_SEEK_SET, 0);
    if (FAILED(hr))
    {
	ERROUT("ERROR: ResetStream FAILED hr:%x\n",hr);
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:	GetInterface / ReleaseInterface
//
//  Synopsis:	allocates or releases an object interface
//
//--------------------------------------------------------------------
IUnknown *GetInterface(void)
{
    IUnknown *punk = (IUnknown *) new CTestUnk();
    if (punk == NULL)
    {
	ERROUT("ERROR: GetInterface FAILED\n");
    }
    DBGOUT("GetInterface punk:%x\n", punk);
    return punk;
}

void ReleaseInterface(IUnknown *punk)
{
    if (punk)
    {
	DBGOUT("ReleaseInterface punk:%x\n", punk);
	punk->Release();
    }
}

//+-------------------------------------------------------------------
//
//  Function:	GenericExecute
//
//  Synopsis:	run all the parameter blocks on different threads
//		simultaneously.
//
//--------------------------------------------------------------------
BOOL GenericExecute(ULONG cEPs, EXECPARAMS *pEP[])
{
    BOOL fRes = TRUE;
    DBGOUT("Start GenericExecute cEPs:%x\n", cEPs);

    HANDLE hThread[50];

    // launch a thread to run each command block
    for (ULONG i=0; i<cEPs; i++)
    {
	// launch a thread to execute the parameter block
	DWORD  dwThreadId;
	hThread[i] = CreateThread(NULL, 0,
			    WorkerThread,
			    pEP[i],
			    0,
			    &dwThreadId);
    }

    // signal all the threads to start their work
    for (i=0; i<cEPs; i++)
    {
	SignalEvent(pEP[i]->hEventThreadStart);
    }

    // wait for all the threads to complete their work
    for (i=0; i<cEPs; i++)
    {
	if (pEP[i]->hEventThreadDone)
	{
	    WaitForSingleObject(pEP[i]->hEventThreadDone, 60000);
	}
    }

    // signal all the threads to exit
    for (i=0; i<cEPs; i++)
    {
	HANDLE hEventThreadExit = pEP[i]->hEventThreadExit;
	pEP[i]->hEventThreadExit = NULL;// set to NULL so only the thread will
					// release it, genericcleanup wont.
	SignalEvent(hEventThreadExit);
    }

    // wait for all the threads to exit
    for (i=0; i<cEPs; i++)
    {
	WaitForSingleObject(hThread[i], 5000);
	CloseHandle(hThread[i]);
    }

    DBGOUT("Done GenericExecute fRes:%x\n", fRes);
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	GenericCleanup
//
//  Synopsis:	clean all the parameter blocks
//
//--------------------------------------------------------------------
void GenericCleanup(ULONG cEPs, EXECPARAMS *pEP[])
{
    DBGOUT("GenericCleanup\n");

    // delete the execution parameter blocks
    for (ULONG i=0; i<cEPs; i++)
    {
	ReleaseExecParam(pEP[i]);
	// CODEWORK: get results from the parameter block?
    }
}

//+-------------------------------------------------------------------
//
//  Function:	WorkerThread
//
//  Synopsis:	entry point for thread that executes a series of
//		interface commands
//
//--------------------------------------------------------------------
DWORD _stdcall WorkerThread(void *params)
{
    DBGOUT("StartWorkerThread TID:%x pEP:%x\n", GetCurrentThreadId(), params);

    EXECPARAMS	*pEP = (EXECPARAMS *)params;
    if (pEP == NULL)
    {
	return E_OUTOFMEMORY;
    }

    HRESULT	hr = S_OK;

    // Initialize OLE for this thread.
    if (pEP->dwFlags & OPF_INITAPARTMENT)
    {
	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    }
    else
    {
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }

    if (FAILED(hr))
    {
	ERROUT("ERROR: CoInitializeEx FAILED\n");
	return hr;
    }

    // wait for signal to start the test
    if (!WaitForEvent(pEP->hEventThreadStart))
    {
	return E_OUTOFMEMORY;	// BUGBUG
    }

    // loop for the number of reps requested
    for (ULONG iRep = 0; iRep < pEP->cReps; iRep++)
    {
	// wait for the start signal
	if (!WaitForEvent(pEP->hEventRepStart))
	{
	    return E_OUTOFMEMORY;   // BUGBUG
	}

	MSGOUT("    TID:%x Rep:%x of %x\n",
		    GetCurrentThreadId(), iRep, pEP->cReps);

	// loop for the number of INTERFACEPARAMSs, performing
	// the requested operation(s) on each interface.

	for (ULONG iIP=0; iIP < pEP->cIPs; iIP++)
	{
	    hr = DoIfOperation(pEP->dwFlags, &(pEP->aIP[iIP]));
	}

	// signal the completion event
	SignalEvent(pEP->hEventRepDone);
    }

    // signal the thread completion event. Cant touch pEP after this
    // point in time since the main thread may delete it. We extract
    // the ThreadExit event and NULL it in the parameter block so that
    // the main thread wont release it. We release it after the event
    // has been signaled.

    HANDLE hEventThreadExit = pEP->hEventThreadExit;
    SignalEvent(pEP->hEventThreadDone);

    // wait on the thread exit event. This allows other threads to
    // complete their work (eg unmarshaling/Releasing interfaces on
    // object in this thread.

    WaitForEvent(hEventThreadExit);
    ReleaseEvent(hEventThreadExit);

    // uninitialize OLE for this thread
    CoUninitialize();

    DBGOUT("ExitWorkerThread TID:%x hr:%x\n", GetCurrentThreadId(), hr);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:	DoIfOperation
//
//  Synopsis:	executes one interface operation
//
//--------------------------------------------------------------------
HRESULT DoIfOperation(DWORD dwFlags, INTERFACEPARAMS *pIP)
{
    // find the interface pointers and IID in the params
    IUnknown *punk = pIP->punk;
    IStream  *pStm = pIP->pStm;
    REFIID    riid = pIP->iid;
    HRESULT   hr   = S_OK;

    DBGOUT("DoIfOperation Oper:%x pUnk:%x pStm:%x\n", dwFlags, punk, pStm);

    // wait for the start signal
    if (!WaitForEvent(pIP->hEventStart))
    {
	return -1;
    }

    // do the requested operation(s) on the interface
    if (dwFlags & OPF_MARSHAL)
    {
	// marshal the interface into the stream
	ResetStream(pStm);
	hr = CoMarshalInterface(pStm, riid, punk, 0, NULL, MSHLFLAGS_NORMAL);
	CHKOP(hr, "CoMarshalInterface");
    }

    if (dwFlags & OPF_DISCONNECT)
    {
	hr = CoDisconnectObject(punk, 0);
	CHKOP(hr, "CoDisconnectObject");
    }

    if (dwFlags & OPF_RELEASEMARSHALDATA)
    {
	// call RMD on the stream
	ResetStream(pStm);
	hr = CoReleaseMarshalData(pStm);
	CHKOP(hr, "CoReleaseMarshalData");
    }

    if (dwFlags & OPF_UNMARSHAL)
    {
	// unmarshal the interface from the stream
	ResetStream(pStm);
	hr = CoUnmarshalInterface(pStm, riid, (void **)&punk);
	CHKOP(hr, "CoUnmarshalInterface");
    }

    if (dwFlags & OPF_RELEASE)
    {
	// release the interface pointer (if there is one).
	if (punk != NULL)
	{
	    ULONG cRefs = punk->Release();
	}
    }

    SignalEvent(pIP->hEventDone);

    DBGOUT("DoIfOperation Oper:%x hr:%x\n", dwFlags, hr);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:	CreateExecParam
//
//  Synopsis:	allocates an exec parameter packet for the given # of
//		INTERFACEPARAMSs.
//
//--------------------------------------------------------------------
EXECPARAMS *CreateExecParam(ULONG cIP)
{
    // allocate memory
    ULONG ulSize = sizeof(EXECPARAMS) + (cIP * sizeof(INTERFACEPARAMS));

    EXECPARAMS *pEP = (EXECPARAMS *) new BYTE[ulSize];
    if (pEP == NULL)
    {
	DBGOUT("CreateExecParams OOM\n");
	return NULL;
    }

    // zero fill the packet
    memset((BYTE*)pEP, 0, ulSize);
    pEP->cIPs = cIP;

    DBGOUT("CreateExecParam pEP:%x\n", pEP);
    return pEP;
}

//+-------------------------------------------------------------------
//
//  Function:	FillExecParam
//
//  Synopsis:	fills an exec parameter packet
//
//--------------------------------------------------------------------
void FillExecParam(EXECPARAMS *pEP, DWORD dwFlags, ULONG cReps,
		   HANDLE hEventRepStart, HANDLE hEventRepDone,
		   HANDLE hEventThreadStart, HANDLE hEventThreadDone)
{
    DBGOUT("FillExecParam pEP:%x\n", pEP);

    pEP->dwFlags	   = dwFlags;
    pEP->hEventThreadStart = hEventThreadStart;
    pEP->hEventThreadDone  = hEventThreadDone;
    pEP->hEventThreadExit  = GetEvent();

    pEP->cReps		   = cReps;
    pEP->hEventRepStart    = hEventRepStart;
    pEP->hEventRepDone	   = hEventRepDone;
}

//+-------------------------------------------------------------------
//
//  Function:	ReleaseExecParam
//
//  Synopsis:	releases an exec parameter packet
//
//--------------------------------------------------------------------
void ReleaseExecParam(EXECPARAMS *pEP)
{
    DBGOUT("ReleaseExecParam pEP:%x\n", pEP);

    if (!pEP)
	return;

    // release the events.
    ReleaseEvent(pEP->hEventThreadStart);
    ReleaseEvent(pEP->hEventThreadDone);
    ReleaseEvent(pEP->hEventThreadExit);
    ReleaseEvent(pEP->hEventRepStart);
    ReleaseEvent(pEP->hEventRepDone);

    // release the interface parameter blocks
    for (ULONG i=0; i<pEP->cIPs; i++)
    {
	ReleaseInterfaceParam(&(pEP->aIP[i]));
    }

    // free the memory
    delete pEP;
}

//+-------------------------------------------------------------------
//
//  Function:	FillInterfaceParam
//
//  Synopsis:	fills default info into the interface parms
//
//--------------------------------------------------------------------
void FillInterfaceParam(INTERFACEPARAMS *pIP, REFIID riid, IUnknown *punk,
			IStream *pStm, HANDLE hEventStart, HANDLE hEventDone)
{
    DBGOUT("FillInterfaceParam pIP:%x\n", pIP);

    pIP->iid	      = riid;
    pIP->punk	      = punk;
    pIP->pStm	      = pStm;
    pIP->hEventStart  = hEventStart;
    pIP->hEventDone   = hEventDone;
}

//+-------------------------------------------------------------------
//
//  Function:	ReleaseInterfaceParam
//
//  Synopsis:	releases an interface parameter packet
//
//--------------------------------------------------------------------
void ReleaseInterfaceParam(INTERFACEPARAMS *pIP)
{
    DBGOUT("ReleaseInterfaceParam pIP:%x\n", pIP);

    if (!pIP)
	return;

    // release the interfaces
    ReleaseInterface(pIP->punk);
    ReleaseInterface(pIP->pStm);

    // release the events
    ReleaseEvent(pIP->hEventStart);
    ReleaseEvent(pIP->hEventDone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\smarshal\stream.cxx ===
//+-------------------------------------------------------------------
//
//  File:	stream.cxx
//
//  Contents:	Stream interface on flat File.
//
//  Classes:	CStreamOnFile
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------
#include    <ole2.h>
#include    <stream.hxx>


CStreamOnFile::CStreamOnFile(const WCHAR *pwszFileName, SCODE &sc, BOOL fRead) :
    _clRefs(1),
    _hFile(NULL),
    _lOffset(0),
    _cSize(0),
    _cbData(0),
    _fRead(fRead)
{
    _pbData = new BYTE[2048];		    // should be big enough
    if (!_pbData)
    {
	sc = E_OUTOFMEMORY;
	return;
    }

    _cbData = 2048;

    // open the file.
    DWORD fdwCreate = (_fRead) ? OPEN_EXISTING : CREATE_ALWAYS;


    _hFile = CreateFile(pwszFileName,
			GENERIC_READ | GENERIC_WRITE,	    // fdwAccess
			FILE_SHARE_READ | FILE_SHARE_WRITE, // fdwShareMode
			NULL,			// lpsaSecurity
			fdwCreate,		// creation options
			FILE_ATTRIBUTE_NORMAL,	// attributes & flags
			NULL			// hTemplateFile
			);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    // read the file into the memory block
    DWORD cbRead = 0;
    if (_fRead && ! ReadFile(_hFile,
			    _pbData,
			    _cbData,
			    &cbRead,
			    NULL))
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    if (_fRead)
    {
	_cSize = _cbData;
    }

    sc = S_OK;
}

CStreamOnFile::~CStreamOnFile(void)
{
    if (_hFile)
    {
	if (!_fRead)
	{
	    // write the data to the file
	    DWORD cbWritten = 0;
	    if (!WriteFile(_hFile,
			   _pbData,
			   _cbData,
			   &cbWritten,
			   NULL))
	    {
		SCODE sc = HRESULT_FROM_WIN32(GetLastError());
	    }
	}

	CloseHandle(_hFile);
    }
}



STDMETHODIMP CStreamOnFile::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CStreamOnFile::AddRef(void)
{
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CStreamOnFile::Release(void)
{
    if (InterlockedDecrement(&_clRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _clRefs;
}

STDMETHODIMP CStreamOnFile::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if ((LONG)cb + _lOffset > _cSize)
    {
	cb = _cSize - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv, _pbData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	return E_OUTOFMEMORY;
    }

    // copy in the new data
    memcpy(_pbData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}



STDMETHODIMP CStreamOnFile::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG  dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\dllhost\tdllhost.cxx ===
//+------------------------------------------------------------------
//
// File:	tdllhost.cxx
//
// Contents:	test for dll hosting
//
//--------------------------------------------------------------------
#include <tstmain.hxx>
#include "tdllhost.h"


// BUGBUG: these should be in a public place somewhere.
DEFINE_OLEGUID(CLSID_Balls,	    0x0000013a, 1, 8);
DEFINE_OLEGUID(CLSID_Cubes,	    0x0000013b, 1, 8);
DEFINE_OLEGUID(CLSID_LoopSrv,	    0x0000013c, 1, 8);

DEFINE_OLEGUID(CLSID_QI,	    0x00000140, 0, 8);
const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QIHANDLER1 =
    {0x00000141,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


const TCHAR *pszRegValThreadModel   = TEXT("ThreadingModel");
const TCHAR *pszSingleModel	    = TEXT("Single");
const TCHAR *pszApartmentModel	    = TEXT("Apartment");
const TCHAR *pszMultiThreadedModel  = TEXT("Free");
const TCHAR *pszBothModel	    = TEXT("Both");

BOOL  gfApt;

// ----------------------------------------------------------------------
//
//  Structures and Function Prototypes
//
// ----------------------------------------------------------------------
typedef struct tagLoadDLLParams
{
    DWORD	dwCallingTID; // tid of calling thread
    DWORD	dwCoInitFlag; // flag to initialize OLE with
    DWORD	dwItfFlag;    // flag if the resulting object should be a proxy
    BOOL	RetVal;       // return value
    HANDLE	hEvent;       // thread completion event
} SLoadDLLParam;

typedef enum tagITFFLAGS
{
    ITF_REAL	    = 1,      // expect ptr to real object
    ITF_PROXY	    = 2       // expect ptr to proxy object
} ITFFLAGS;


// worker subroutines
BOOL	       SpinThread(DWORD dwInitFlag, DWORD dwItfFlag);
DWORD _stdcall LoadDLLOnThread(void *param);
BOOL	       LoadClassObject(DWORD dwItfFlag);
BOOL	       SetRegForDll(REFCLSID rclsid, const TCHAR *pszThreadModel);


//  test routines  - return value of TRUE return means the test passed
BOOL TestLoadSingleThreaded(void);
BOOL TestLoadApartmentThreaded(void);
BOOL TestLoadMultiThreaded(void);
BOOL TestLoadBothThreaded(void);


// ----------------------------------------------------------------------
//
//	TestDllHost - main test driver. read the ini file to determine
//		      which tests to run.
//
// ----------------------------------------------------------------------
BOOL TestDllHost(void)
{
    BOOL RetVal = TRUE;

    gfApt = (gInitFlag == COINIT_APARTMENTTHREADED) ? TRUE : FALSE;

    // the driver did a CoInitialize, we dont want one so do CoUninit.
    CoUninitialize();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadSingleThreaded"),1))
	RetVal &= TestLoadSingleThreaded();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadApartmentThreaded"),1))
	RetVal &= TestLoadApartmentThreaded();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadMultiThreaded"),1))
	RetVal &= TestLoadMultiThreaded();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadBothThreaded"),1))
	RetVal &= TestLoadBothThreaded();

    // re-initialize so we dont get a complaint from OLE in debug builds
    // about an unbalanced call to Uninitialize.
    CoInitializeEx(NULL, gInitFlag);

    return  RetVal;
}



// ----------------------------------------------------------------------
//
//	TestLoadSingleThreaded
//
//	Tests loading a single-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadSingleThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = TRUE;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadSingleThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszSingleModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");


    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Single-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Single-Threaded DLL on Main Thread\n");

    OUTPUT ("\n   Load Single-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Single-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Single-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Single-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Single-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Single-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Single-Threaded DLL on Different Apartment Thread\n");


// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadSingleThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//	TestLoadApartmentThreaded
//
//	Tests loading an apartment-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadApartmentThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = FALSE;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadApartmentThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszApartmentModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");

    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Threaded DLL on Main Thread\n");

    OUTPUT ("\n   Load Apartment-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Apartment-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Apartment-Threaded DLL on Different Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadApartmentThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//	TestLoadMultiThreaded
//
//	Tests loading a multi-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadMultiThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = FALSE;;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadMultiThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszMultiThreadedModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");

    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Free-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_PROXY : ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Main Thread\n");

    OUTPUT ("\n   Load Free-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_PROXY : ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Free-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Free-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Apartment-Threaded DLL on Different Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadMultiThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//	TestLoadBothThreaded
//
//	Tests loading a both-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadBothThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = FALSE;;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadBothThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszBothModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");

    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Both-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject(ITF_REAL);
    TEST_FAILED(!RetVal2, "Both-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Both-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Both-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Free-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Free-Threaded DLL on Different Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadBothThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//  Function:	SpinThread
//
//  Synopsis:	Creates a thread to do some work for us. Waits for it to
//		complete. Returns the results.
//
// ----------------------------------------------------------------------
BOOL SpinThread(DWORD dwInitFlag, DWORD dwItfFlag)
{
    BOOL RetVal = FALSE;

    // set up paramters to pass to the thread

    SLoadDLLParam   LoadParam;
    LoadParam.dwCallingTID = GetCurrentThreadId();
    LoadParam.dwCoInitFlag = dwInitFlag;
    LoadParam.dwItfFlag    = dwItfFlag;
    LoadParam.RetVal	   = FALSE;
    LoadParam.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);

    // create the thread

    DWORD  dwThrdId = 0;
    HANDLE hThrd = CreateThread(NULL, 0,
				LoadDLLOnThread,
				&LoadParam, 0, &dwThrdId);
    if (hThrd)
    {
	// enter a message loop and wait for the other thread to run
	// We stay here until the thread posts a QUIT message.

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
	    DispatchMessage(&msg);
	}

	// close the thread handle
	CloseHandle(hThrd);
    }
    else
    {
	HRESULT hRes = GetLastError();
	TEST_FAILED(hRes, "CreateThread failed\n")
	LoadParam.RetVal = RetVal;
    }

    // wait for the other thread to complete
    WaitForSingleObject(LoadParam.hEvent, 0xffffffff);
    CloseHandle(LoadParam.hEvent);

    return LoadParam.RetVal;
}

// ----------------------------------------------------------------------
//
//  Function:	LoadDLLOnThread
//
//  Synopsis:	Initializes COM, loads the class object and creates an
//		instance, releases them, Posts a message to wake up the
//		calling thread, Uninitializes COM, then exits.
//
// ----------------------------------------------------------------------
DWORD _stdcall LoadDLLOnThread(void *param)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    SLoadDLLParam   *pLoadParam = (SLoadDLLParam *)param;

    OUTPUT ("       - LoadDLLOnThread Entered\n");
    hRes = CoInitializeEx(NULL, pLoadParam->dwCoInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitialize failed\n")

    if (SUCCEEDED(hRes))
    {
	// attempt to load the class object on this thread.
	pLoadParam->RetVal = LoadClassObject(pLoadParam->dwItfFlag);
	CoUninitialize();
    }

    // post a message to the server thread to exit now that we are done.
    PostThreadMessage(pLoadParam->dwCallingTID, WM_QUIT, 0, 0);
    SetEvent(pLoadParam->hEvent);

    OUTPUT ("       - LoadDLLOnThread Exit\n");
    return RetVal;
}

// ----------------------------------------------------------------------
//
//  Function:	LoadClassObject
//
//  Synopsis:	Loads the class object, creates an instance, releases
//		them, returns the results.
//
// ----------------------------------------------------------------------
BOOL LoadClassObject(DWORD dwItfFlag)
{
    BOOL	    RetVal = TRUE;
    IClassFactory   *pICF  = NULL;
    IUnknown	    *pIPM  = NULL;

    //	try to load the dll class object
    HRESULT hRes = CoGetClassObject(CLSID_QI, CLSCTX_INPROC_SERVER, NULL,
				    IID_IClassFactory, (void **)&pICF);

    TEST_FAILED(FAILED(hRes), "CoGetClassObject failed\n");

    if (SUCCEEDED(hRes))
    {
	hRes = pICF->QueryInterface(IID_IProxyManager, (void **)&pIPM);

	if (SUCCEEDED(hRes))
	{
	    pIPM->Release();
	    TEST_FAILED(dwItfFlag != ITF_PROXY, "Got Proxy when expected Real\n");
	}
	else
	{
	    TEST_FAILED(dwItfFlag != ITF_REAL, "Got Real when expected Proxy\n");
	}

	// CODEWORK: create an instance, then release them

	// release the class object.
	OUTPUT ("       - CoGetClassObject succeeded\n");

	ULONG ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
	pICF = NULL;
	OUTPUT ("       - Released ClassObject\n");
    }

    return RetVal;
}



//+-------------------------------------------------------------------
//
//  Function:   SetRegForDll, private
//
//  Synopsis:   Set registry entry for a DLL
//
//  Arguments:  [rclsid] - clsid for reg entry
//              [pszThreadModel] - threading model can be NULL.
//
//  Returns:    TRUE - Registry entry set successfully.
//              FALSE - Registry entry set successfully.
//
//  History:    01-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL SetRegForDll(REFCLSID rclsid, const TCHAR *pszThreadModel)
{
    BOOL fResult   = FALSE;
    HKEY hKeyClass = NULL;
    HKEY hKeyDll   = NULL;
    TCHAR aszWkBuf[MAX_PATH]; // String buffer used for various purposes

    // Build clsid registry key
    wsprintf(aszWkBuf,
        TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
        rclsid.Data1, rclsid.Data2, rclsid.Data3,
        rclsid.Data4[0], rclsid.Data4[1],
        rclsid.Data4[2], rclsid.Data4[3],
        rclsid.Data4[4], rclsid.Data4[5],
        rclsid.Data4[6], rclsid.Data4[7]);

    // Create the key for the class
    if (RegCreateKey(HKEY_CLASSES_ROOT, aszWkBuf, &hKeyClass) == ERROR_SUCCESS)
    {
	// Create the key for the DLL
	if (RegCreateKey(hKeyClass, TEXT("InprocServer32"), &hKeyDll) == ERROR_SUCCESS)
	{
	    // Set the value for the Threading Model
	    if (RegSetValueEx(hKeyDll, pszRegValThreadModel, 0,
				  REG_SZ,
				  (const unsigned char*) pszThreadModel,
				  (wcslen(pszThreadModel) + 1) * sizeof(WCHAR))
		== ERROR_SUCCESS)
	    {
		fResult = TRUE;
	    }

	    RegCloseKey(hKeyDll);
	}

        RegCloseKey(hKeyClass);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\prxytest\prxytest.cxx ===
//+-------------------------------------------------------------------
//
//  File:	climain.cxx
//
//  Contents:	server test program to test OLE2 RPC
//
//  Classes:	None
//
//  Functions:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
#include    <stdio.h>

#include    <rpctyp.h>		//  IRpcTypes interface



SCODE TestGuids(IRpcTypes *pRpc);
SCODE TestDwords(IRpcTypes *pRpc);

#define DebugOut(x) printf x



int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lpCmdLine, int nCmdShow)
{
    DebugOut (("Test: Starting\n"));

    //	initialize with OLE2
    SCODE sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
	DebugOut (("Test: OleInitialize = %x\n", sc));
	return sc;
    }

    //	create an instance
    sc = CoGetClassObject(CLSID_RpcTypes,
			  CLSCTX_LOCAL_SERVER,
			  NULL,
			  IID_IClassFactory,
			  (void **)&pCF);

    if (FAILED(sc))
    {
	DebugOut (("Test: CoGetClassObject=%x\n", sc));
	return sc;
    }

    sc = pCF->CreateInstance(NULL, IID_IRpcTypes, (void **)&pRpc);
    sc = pCF->Release();

    if (FAILED(sc))
    {
	DebugOut(("Test: CreateInstance=%x\n", sc));
	return sc;
    }


    sc = TestVoid(pRpc);

    sc = TestGuids(pRpc);

    sc = TestDwords(pRpc)

    sc = TestWindows(pRpc);

    sc = TestOleData(pRpc);


    //	finished with OLE2

    OleUninitialize();
    DebugOut (("Test: CoUninitialize called.\n"));

    return  sc;
}





SCODE TestGuids(IRpcTypes *pRpc)
{
    REFCLSID	     rclsid;
    CLSID	     clsid;
    REFIID	     riid;
    IID 	     iid;
    GUID	     guid;

    //	initialize the parameters

    SCODE sc = pRpc->GuidsIn(rclsid, clsid, riid, iid, guid);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }


    sc = pRpc->GuidsOut(&clsid, &iid, &guid);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }

    //	check the return values


    return S_OK;
}


SCODE TestDwords(IRpcTypes *pRpc)
{
    DWORD		dw = 1;
    ULONG		ul = 2;
    LONG		lg = 3;
    LARGE_INTEGER	li;
    ULARGE_INTEGER	uli;

    //	methods to test DWORD / LARGE_INTEGER parameter passing
    li.LowPart = 4;
    li.HighPart = 5;

    uli.LowPart = 6;
    uli.HighPart = 7;

    sc = pRpc->DwordIn(dw, ul, lg, li, uli);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }

    sc = pRpc->DwordIn(&dw, &ul, &lg, &li, &uli);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }

    //	check the return values

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\smarshal\testvars.cxx ===
//+-------------------------------------------------------------------
//
//  File:	testvars.cxx
//
//  Synopsis:	source code for Interface Marshaling stress test
//		variations.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
#include <smarshal.hxx>

//+-------------------------------------------------------------------
//
//  Private Function ProtoTypes:
//
//--------------------------------------------------------------------
BOOL SingleThreadOps(ULONG cThreads, ULONG cReps, DWORD dwFlags);

BOOL ThreadPairOps(ULONG cThreadPairs,	ULONG cReps,
		   DWORD dwServerFlags, DWORD dwClientFlags);


//+-------------------------------------------------------------------
//
//  Function:	TestVar1
//
//  Synopsis:	Multiple Operations on the Same Thread.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL TestVar1(void)
{
    MSGOUT("TestStart: TestLevel1\n");

    ULONG cThreads = gicThreads;
    ULONG cReps    = gicReps;
    DWORD dwOps    = 0;
    BOOL  fRes;


    // VAR1: test Marshal + ReleaseMarshalData

    dwOps = giThreadModel | OPF_MARSHAL | OPF_RELEASEMARSHALDATA;
    fRes = SingleThreadOps(cThreads, cReps, dwOps);
    CHKTESTRESULT(fRes, "TestVar1");


    // VAR2: test Marshal + Unmarshal + Release

    dwOps = giThreadModel | OPF_MARSHAL | OPF_UNMARSHAL | OPF_RELEASE;
    fRes = SingleThreadOps(cThreads, cReps, dwOps);
    CHKTESTRESULT(fRes, "TestVar2");


    // VAR3: test Marshal + Disconnect

    dwOps = giThreadModel | OPF_MARSHAL | OPF_DISCONNECT;
    fRes = SingleThreadOps(cThreads, cReps, dwOps);
    CHKTESTRESULT(fRes, "TestVar3");



    CHKTESTRESULT(fRes, "TestLevel1");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	SingleThreadOps
//
//  Synopsis:	Perform Operations on the Same Thread.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL SingleThreadOps(ULONG cThreads, ULONG cReps, DWORD dwFlags)
{
    BOOL fRes = TRUE;
    MSGOUT("SingleThreadOps Start\n");

    // CODEWORK: multiple interfaces
    ULONG cIPs = 1;

    EXECPARAMS *pEP[20];	// can launch up to 20 threads at once

    for (ULONG i=0; i<cThreads; i++)
    {
	// build an execution parameter block
	pEP[i] = CreateExecParam(cIPs);

	// fill in the execution parameter block. we dont need events
	// to synchronize the repetitions since all operations are done
	// on the same thread.

	FillExecParam(pEP[i],
		  dwFlags,	    // dwFlags (operations to perform)
		  cReps,	    // cReps
		  NULL,		    // hEventRepStart
		  NULL,		    // hEventRepDone
		  GetEvent(),	    // hEventThreadStart
		  GetEvent());	    // hEventThreadDone

	// fill in the INTERFACEPARAMSs
	for (ULONG j=0; j<cIPs; j++)
	{
	    INTERFACEPARAMS *pIP = &(pEP[i]->aIP[j]);

	    FillInterfaceParam(pIP,
		   IID_IUnknown,    // iid to operate on
		   GetInterface(),  // interface pointer to operate on
		   GetStream(),     // stream to use
		   NULL,	    // per interface start event
		   NULL);	    // per interface done  event
	}
    }

    // Execute all the command blocks simultaneously
    fRes = GenericExecute(cThreads, pEP);

    GenericCleanup(cThreads, pEP);

    CHKTESTRESULT(fRes, "SingleThreadOps");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	TestVar2
//
//  Synopsis:	Operations on Thread Pairs (1 server, 1 client)
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL TestVar2(void)
{
    MSGOUT("TestStart: TestLevel2\n");

    ULONG cThreads = gicThreads;
    ULONG cReps    = gicReps;
    DWORD dwOps    = 0;
    BOOL  fRes;


    // VAR1: test Marshal on Server, Unmarshal + Release on Client.

    DWORD dwSrvOps = giThreadModel | OPF_MARSHAL;
    DWORD dwCliOps = giThreadModel | OPF_UNMARSHAL | OPF_RELEASE;
    fRes = ThreadPairOps(cThreads, cReps, dwSrvOps, dwCliOps);
    CHKTESTRESULT(fRes, "TestVar1");


    // VAR2: test Marshal on Server, RMD on Client.

#if 0
    dwSrvOps = giThreadModel | OPF_MARSHAL;
    dwCliOps = giThreadModel | OPF_RELEASEMARSHALDATA;
    fRes = ThreadPairOps(cThreads, cReps, dwSrvOps, dwCliOps);
    CHKTESTRESULT(fRes, "TestVar1");
#endif


    CHKTESTRESULT(fRes, "TestLevel2");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	ThreadPairOps
//
//  Synopsis:	Perform Operations on two synchronized threads.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL ThreadPairOps(ULONG cThreadPairs,	ULONG cReps,
		   DWORD dwServerFlags, DWORD dwClientFlags)
{
    BOOL fRes = TRUE;
    MSGOUT("ThreadPairOps Start\n");

    // CODEWORK: multiple interfaces
    ULONG cIPs = 1;

    EXECPARAMS *pEP[20];	// can launch up to 20 threads at once

    for (ULONG i=0; i<cThreadPairs * 2; i+=2)
    {
	// build execution parameter blocks for the server and client threads.
	EXECPARAMS *pEPSrv = CreateExecParam(cIPs);
	EXECPARAMS *pEPCli = CreateExecParam(cIPs);
	pEP[i]	 = pEPSrv;
	pEP[i+1] = pEPCli;


	// fill in the server execution parameter block.
	FillExecParam(pEPSrv,
		  dwServerFlags,    // dwFlags (operations to perform)
		  cReps,	    // cReps
		  GetEvent(),	    // hEventRepStart
		  GetEvent(),	    // hEventRepDone
		  GetEvent(),	    // hEventThreadStart
		  GetEvent());	    // hEventThreadDone

	// we need to kick the hEventRepStart in order to get the ball rolling,
	// since the server thread will be waiting on it.

	SignalEvent(pEPSrv->hEventRepStart);

	// client waits for the server to complete his first repetition
	// before starting. Server waits for the client to complete his
	// first repetition before starting the next iteration.

	FillExecParam(pEPCli,
		  dwClientFlags,	    // dwFlags (operations to perform)
		  cReps,		    // cReps
		  pEPSrv->hEventRepDone,    // hEventRepStart
		  pEPSrv->hEventRepStart,   // hEventRepDone
		  GetEvent(),		    // hEventThreadStart
		  GetEvent());		    // hEventThreadDone


	// fill in the INTERFACEPARAMSs
	// CODEWORK: when multiple interfaces, will need to use events.

	for (ULONG j=0; j<cIPs; j++)
	{
	    INTERFACEPARAMS *pIPSrv = &(pEPSrv->aIP[j]);
	    INTERFACEPARAMS *pIPCli = &(pEPCli->aIP[j]);

	    FillInterfaceParam(pIPSrv,
		   IID_IUnknown,    // iid to operate on
		   GetInterface(),  // interface pointer to operate on
		   GetStream(),	    // stream to use
		   NULL,	    // per interface start event
		   NULL);	    // per interface done  event

	    // AddRef the stream pointer since both the client and server
	    // will hold pointers to it.

	    pIPSrv->pStm->AddRef();

	    FillInterfaceParam(pIPCli,
		   IID_IUnknown,    // iid to operate on
		   NULL,	    // interface pointer to operate on
		   pIPSrv->pStm,    // use same stream as the server
		   NULL,	    // per interface start event
		   NULL);	    // per interface done  event
	}
    }

    // Execute all the command blocks simultaneously
    fRes = GenericExecute(cThreadPairs * 2, pEP);

    // cleanup all the command blocks. We need to NULL out one copy of
    // those events that are shared between two command blocks.
    for (i=0; i<cThreadPairs * 2; i+=2)
    {
	EXECPARAMS *pEPCli = pEP[i+1];
	pEPCli->hEventRepStart = NULL;
	pEPCli->hEventRepDone  = NULL;

	for (ULONG j=0; j<cIPs; j++)
	{
	    INTERFACEPARAMS *pIPCli = &(pEPCli->aIP[j]);
	    pIPCli->hEventStart = NULL;
	    pIPCli->hEventDone	= NULL;
	}
    }

    GenericCleanup(cThreadPairs * 2, pEP);


    CHKTESTRESULT(fRes, "ThreadPairOps");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	TestLevel3
//
//  Synopsis:	Operations on Thread Pools (1 server, n clients)
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL TestLevel3(void)
{
    BOOL fRes = TRUE;
    MSGOUT("TestStart: TestLevel3\n");

    // build a command block

    // launch a thread to run the command block


    CHKTESTRESULT(fRes, "TestLevel3");
    return fRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\smarshal\tunk.cxx ===
// #include <oleport.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <tunk.h>


CTestUnk::CTestUnk(void) : _cRefs(1)
{
}

CTestUnk::~CTestUnk(void)
{
}


STDMETHODIMP CTestUnk::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hRslt = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IParseDisplayName))
    {
	*ppvObj = (void *)(IParseDisplayName *)this;
	AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hRslt = E_NOINTERFACE;
    }

    return  hRslt;
}



STDMETHODIMP_(ULONG) CTestUnk::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnk::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}


STDMETHODIMP CTestUnk::ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
					ULONG *pchEaten, LPMONIKER *ppmkOut)
{
    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\smarshal\tunk.h ===
#ifndef _TUNK_
#define _TUNK_

class	CTestUnk : public IParseDisplayName
{
public:
    CTestUnk(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //	IParseDisplayName
    STDMETHODIMP ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
				  ULONG *pchEaten, LPMONIKER *ppmkOut);

private:

    ~CTestUnk(void);

    ULONG   _cRefs;

};

#endif	//  _TUNK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\tmarshal\stream.cxx ===
//+-------------------------------------------------------------------
//
//  File:	stream.cxx
//
//  Contents:	Stream interface on flat File.
//
//  Classes:	CStreamOnFile
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------
#include    <ole2.h>
#include    <stream.hxx>


CStreamOnFile::CStreamOnFile(const WCHAR *pwszFileName, SCODE &sc, BOOL fRead) :
    _clRefs(1),
    _hFile(NULL),
    _lOffset(0),
    _cSize(0),
    _cbData(0),
    _fRead(fRead)
{
    _pbData = new BYTE[2048];		    // should be big enough
    if (!_pbData)
    {
	sc = E_OUTOFMEMORY;
	return;
    }

    _cbData = 2048;

    // open the file.
    DWORD fdwCreate = (_fRead) ? OPEN_EXISTING : CREATE_ALWAYS;


    _hFile = CreateFileW(pwszFileName,
			GENERIC_READ | GENERIC_WRITE,	    // fdwAccess
			FILE_SHARE_READ | FILE_SHARE_WRITE, // fdwShareMode
			NULL,			// lpsaSecurity
			fdwCreate,		// creation options
			FILE_ATTRIBUTE_NORMAL,	// attributes & flags
			NULL			// hTemplateFile
			);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    // read the file into the memory block
    DWORD cbRead = 0;
    if (_fRead && ! ReadFile(_hFile,
			    _pbData,
			    _cbData,
			    &cbRead,
			    NULL))
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    if (_fRead)
    {
	_cSize = _cbData;
    }

    sc = S_OK;
}

CStreamOnFile::~CStreamOnFile(void)
{
    if (_hFile)
    {
	if (!_fRead)
	{
	    // write the data to the file
	    DWORD cbWritten = 0;
	    if (!WriteFile(_hFile,
			   _pbData,
			   _cbData,
			   &cbWritten,
			   NULL))
	    {
		SCODE sc = HRESULT_FROM_WIN32(GetLastError());
	    }
	}

	CloseHandle(_hFile);
    }
}



STDMETHODIMP CStreamOnFile::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CStreamOnFile::AddRef(void)
{
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CStreamOnFile::Release(void)
{
    if (InterlockedDecrement(&_clRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _clRefs;
}

STDMETHODIMP CStreamOnFile::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if ((LONG)cb + _lOffset > _cSize)
    {
	cb = _cSize - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv, _pbData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	return E_OUTOFMEMORY;
    }

    // copy in the new data
    memcpy(_pbData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}



STDMETHODIMP CStreamOnFile::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG  dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\tmarshal\objref.cxx ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <malloc.h>	// _alloca
#include <obase.h>	// def'n of OBJREF

//-------------------------------------------------------------------------

// convenient mappings
#define ORCST(objref)	 objref.u_objref.u_custom
#define ORSTD(objref)	 objref.u_objref.u_standard
#define ORHDL(objref)	 objref.u_objref.u_handler


// bits that must be zero in the flags fields
#define OBJREF_RSRVD_MBZ ~(OBJREF_STANDARD | OBJREF_HANDLER | OBJREF_CUSTOM)

#define SORF_RSRVD_MBZ	 ~(SORF_NOPING | SORF_OXRES1 | SORF_OXRES2 |   \
			   SORF_OXRES3 | SORF_OXRES4 | SORF_OXRES5 |   \
			   SORF_OXRES6 | SORF_OXRES7 | SORF_OXRES8)


// Internal Uses of the reserved SORF_OXRES flags.

// SORF_TBLWEAK is needed so that RMD works correctly on TABLEWEAK
// marshaling, so it is ignored by unmarshalers. Therefore, we use one of
// the bits reserved for the object exporter that must be ignored by
// unmarshalers.
//
// SORF_WEAKREF is needed for container weak references, when handling
// an IRemUnknown::RemQueryInterface on a weak interface. This is a strictly
// local (windows) machine protocol, so we use a reserved bit.
//
// SORF_NONNDR is needed for interop of 16bit custom (non-NDR) marshalers
// with 32bit, since the 32bit guys want to use MIDL (NDR) to talk to other
// 32bit processes and remote processes, but the custom (non-NDR) format to
// talk to local 16bit guys. In particular, this is to support OLE Automation.
//
// SORF_FREETHREADED is needed when we create a proxy to the SCM interface
// in the apartment model. All apartments can use the same proxy so we avoid
// the test for calling on the correct thread.

#define SORF_TBLWEAK	  SORF_OXRES1 // (table) weak reference
#define SORF_WEAKREF	  SORF_OXRES2 // (normal) weak reference
#define SORF_NONNDR	  SORF_OXRES3 // stub does not use NDR marshaling
#define SORF_FREETHREADED SORF_OXRES4 // proxy may be used on any thread


// definition to simplify coding
const DWORD MSHLFLAGS_TABLE = MSHLFLAGS_TABLESTRONG | MSHLFLAGS_TABLEWEAK;

const DWORD MSHLFLAGS_USER_MASK = MSHLFLAGS_NORMAL | MSHLFLAGS_TABLE |
                                  MSHLFLAGS_NOPING;


// return codes
#define INVALID_SORFFLAG 90000001
#define INVALID_REFCNT	 90000002
#define INVALID_MSHLFLAG 90000003

//-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   StRead
//
//  Synopsis:   Stream read that only succeeds if all requested bytes read
//
//  Arguments:  [pStm]     -- source stream
//              [pvBuffer] -- destination buffer
//              [ulcb]     -- bytes to read
//
//  Returns:    S_OK if successful, else error code
//
//--------------------------------------------------------------------------
HRESULT StRead(IStream *pStm, void *pvBuffer, ULONG ulcb)
{
    ULONG cbRead;
    HRESULT hr = pStm->Read(pvBuffer, ulcb, &cbRead);

    if (SUCCEEDED(hr))
    {
	if (ulcb != cbRead)
        {
	    hr = STG_E_READFAULT;
	}
    }

    return hr;
}

void DbgDumpSTD(STDOBJREF *pStd)
{

}

//+-------------------------------------------------------------------------
//
//  Function:	ReadObjRef
//
//  Synopsis:	Reads an OBJREF from the stream
//
//  Arguments:	[pStm]	 -- source stream
//		[objref] -- destination buffer
//
//  Returns:    S_OK if successful, else error code
//
//--------------------------------------------------------------------------
HRESULT ReadObjRef(IStream *pStm, OBJREF &objref, STDOBJREF **ppStd)
{
    HRESULT hr = StRead(pStm, &objref, 2*sizeof(ULONG)+sizeof(IID));

    if (SUCCEEDED(hr))
    {
	if ((objref.signature != OBJREF_SIGNATURE) ||
	    (objref.flags & OBJREF_RSRVD_MBZ)	   ||
	    (objref.flags == 0))
	{
	    // the objref signature is bad, or one of the reserved
	    // bits in the flags is set, or none of the required bits
	    // in the flags is set. the objref cant be interpreted so
	    // fail the call.

	    return E_UNEXPECTED;	// BUGBUG:
	}

	// compute the size of the remainder of the objref and
	// include the size fields for the resolver string array

	STDOBJREF	*pStd = &ORSTD(objref).std;
	DUALSTRINGARRAY *psa;
	ULONG		cbToRead;

	if (objref.flags & OBJREF_STANDARD)
	{
	    cbToRead = sizeof(STDOBJREF) + sizeof(ULONG);
	    psa = &ORSTD(objref).saResAddr;
	}
	else if (objref.flags & OBJREF_HANDLER)
	{
	    cbToRead = sizeof(STDOBJREF) + sizeof(CLSID) + sizeof(ULONG);
	    psa = &ORHDL(objref).saResAddr;
	}
	else if (objref.flags & OBJREF_CUSTOM)
	{
	    cbToRead = sizeof(CLSID) + sizeof(DWORD);	// clsid + data size
	    psa = NULL;
	}

	// return ptr to STDOBJREF
	*ppStd = pStd;

	// read the rest of the (fixed sized) objref from the stream
	hr = StRead(pStm, pStd, cbToRead);

	if (SUCCEEDED(hr) && psa)
	{
	    // Non custom interface. Make sure the resolver string array
	    // has some sensible values.

	    if (psa->wSecurityOffset >= psa->wNumEntries)
	    {
		hr = E_UNEXPECTED;  // BUGBUG: correct return code
	    }
	}

	if (SUCCEEDED(hr) && psa)
	{
	    // Non custom interface. The data that follows is a variable
	    // sized string array. Allocate memory for it and then read it.

	    DbgDumpSTD(pStd);

	    cbToRead = psa->wNumEntries * sizeof(WCHAR);

	    DUALSTRINGARRAY *psaNew = (DUALSTRINGARRAY *) _alloca(cbToRead +
							     sizeof(ULONG));
	    if (psaNew != NULL)
	    {
		// update the size fields and read in the rest of the data
		psaNew->wSecurityOffset = psa->wSecurityOffset;
		psaNew->wNumEntries = psa->wNumEntries;

		hr = StRead(pStm, psaNew->aStringArray, cbToRead);
	    }
	    else
	    {
		psa->wNumEntries     = 0;
		psa->wSecurityOffset = 0;
		hr = E_OUTOFMEMORY;

		// seek the stream past what we should have read, ignore
		// seek errors, since the OOM takes precedence.

		LARGE_INTEGER libMove;
		libMove.LowPart  = cbToRead;
		libMove.HighPart = 0;
		pStm->Seek(libMove, STREAM_SEEK_CUR, 0);
	    }
	}
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:	VerifyOBJREFFormat
//
//  Synopsis:	Checks the format of the marshal packet
//
//  Arguments:	[pStm]	    -- source stream
//		[mshlflags] -- destination buffer
//
//  Returns:    S_OK if successful, else error code
//
//--------------------------------------------------------------------------
HRESULT VerifyOBJREFFormat(IStream *pStm, DWORD mshlflags)
{
    OBJREF     objref;
    STDOBJREF *pStd;
    HRESULT hr = ReadObjRef(pStm, objref, &pStd);

    // now verify the format
    if (SUCCEEDED(hr))
    {
	if (mshlflags & MSHLFLAGS_NOPING)
	{
	    // SORF_NOPING should be set (unless previously marshaled PING)
	    if (!(pStd->flags & SORF_NOPING))
		return INVALID_SORFFLAG;
	}

	if ((mshlflags & MSHLFLAGS_TABLE) == MSHLFLAGS_NORMAL)
	{
	    // refcnt should be non-zero
	    if (pStd->cPublicRefs == 0)
		return INVALID_REFCNT;

	    // table flags should not be set
	    if (pStd->flags & (SORF_WEAKREF | SORF_TBLWEAK))
		return INVALID_SORFFLAG;
	}
	else if ((mshlflags & MSHLFLAGS_TABLE) == MSHLFLAGS_TABLESTRONG)
	{
	    // refcnt should be zero
	    if (pStd->cPublicRefs != 0)
		return INVALID_REFCNT;

	}
	else if ((mshlflags & MSHLFLAGS_TABLE) == MSHLFLAGS_TABLEWEAK)
	{
	    // refcnt should be zero
	    if (pStd->cPublicRefs != 0)
		return INVALID_REFCNT;

	    // SORF_TBLWEAK should be set
	    if (!(pStd->flags & SORF_TBLWEAK))
		return INVALID_SORFFLAG;
	}
	else
	{
	    // unknown flags
	    return INVALID_MSHLFLAG;
	}
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\tmarshal\tmarshal.h ===
#ifndef __TMARSH_H__
#define __TMARSH_H__

BOOL TestMarshal(void);

#endif // __TMARSH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\tmarshal\main.cxx ===
//+------------------------------------------------------------------
//
// File:	main.cxx
//
// Contents:	common entry point for test drivers.
//
//--------------------------------------------------------------------
#include    <tstmain.hxx>
#include    <tmarshal.h>

//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//  Just delegates to a <main> subroutine that is common for all test
//  drivers.
//
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    return DriverMain(argc, argv, "InterfaceMarshal", &TestMarshal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\tmarshal\tmarshal.cxx ===
// tmarsh.cxx : various tests related to marshalling...
//
#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include "tmarshal.h"
#include "tunk.h"
#include <iballs.h>
#include <icube.h>
#include <iloop.h>
#include <stream.hxx>	    // CStreamOnFile
#include <tstmain.hxx>	    // fQuiet

//  BUGBUG: these should be in a public place somewhere.
DEFINE_OLEGUID(CLSID_Balls,	    0x0000013a, 1, 8);
DEFINE_OLEGUID(CLSID_Cubes,	    0x0000013b, 1, 8);
DEFINE_OLEGUID(CLSID_LoopSrv,	    0x0000013c, 1, 8);
DEFINE_OLEGUID(CLSID_QI,	    0x00000140, 0, 8);
DEFINE_OLEGUID(CLSID_QIHANDLER1,    0x00000141, 0, 8);

DEFINE_OLEGUID(IID_IInternalUnknown,0x00000021, 0, 0);
DEFINE_OLEGUID(IID_IStdIdentity,    0x0000001b, 0, 0);
DEFINE_OLEGUID(CLSID_OLEPSFACTORY,  0x00000320, 0, 0);

const GUID CLSID_LoopSrv =
    {0x0000013c,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// testsrv.exe
const GUID CLSID_TestEmbed =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x47}};

const GUID CLSID_Async =
    {0x00000401,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QIHANDLER1 =
    {0x00000141,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

//const GUID IID_IMultiQI =
//    {0x00000020,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID IID_IInternalUnknown =
    {0x00000021,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID IID_IStdIdentity =
    {0x0000001b,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_OLEPSFACTORY =
    {0x00000320,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern "C" const GUID CLSID_TestEmbed;


// external functions
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phdl);
HRESULT VerifyOBJREFFormat(IStream *pStm, DWORD mshlflags);
DWORD _stdcall RundownClient(void *param);

// APIs exported by OLE32 but not in the header files.
STDAPI CoGetIIDFromMarshaledInterface(IStream *pStm, IID *piid);


//  function prototypes - TRUE return means the test passed
BOOL TestMarshalFormat(void);
BOOL TestGetIIDFromMI(void);
BOOL TestLocalInterfaceNormal(void);
BOOL TestUnmarshalGUIDNULL(void);
BOOL TestUnmarshalDifferentIID(void);
BOOL TestUniqueQIPointer(void);
BOOL TestLocalInterfaceTableStrong(void);
BOOL TestLocalInterfaceTableWeak(void);
BOOL TestRemoteInterfaceNormal(void);
BOOL TestRemoteInterfaceTableStrong(void);
BOOL TestNoPing(void);
BOOL TestEcho(void);
BOOL TestMiddleMan(void);
BOOL TestLoop(void);
BOOL TestLockObjectExternal(void);
BOOL TestDisconnectObject(void);
BOOL TestHandler(void);
BOOL TestReleaseMarshalData(void);
BOOL TestCustomMarshalNormal(void);
BOOL TestCustomMarshalTable(void);
BOOL TestGetStandardMarshal(void);
BOOL TestLocalInterfaceDiffMachine(void);
BOOL TestRemoteInterfaceDiffMachine(void);
BOOL TestExpiredOXIDs(void);
BOOL TestNonNDRProxy(void);
BOOL TestTIDAndLID(void);
BOOL TestMarshalSizeMax(void);
BOOL TestMarshalStorage(void);
BOOL TestMultiQINormal(void);
BOOL TestMultiQIHandler(void);
BOOL TestCrossThread(void);
BOOL TestPSClsid(void);
BOOL TestPSClsid2(void);

BOOL TestAsync(void);
BOOL TestRundown(void);
BOOL TestAggregate(void);
BOOL TestCreateRemoteHandler(void);
BOOL TestStorageInterfaceDiffMachine(void);


WCHAR	  *pwszFileName[] = {L"c:\\mshlfile.1",
			     L"c:\\mshlfile.2",
			     L"c:\\mshlfile.3"};




//  internal subroutines
void VerifyRHRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt);
void VerifyObjRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt);

TCHAR g_szIniFile[MAX_PATH];


// ----------------------------------------------------------------------
//
//	TestMarshal - main test driver
//
// ----------------------------------------------------------------------
BOOL GetProfileValue(TCHAR *pszKeyName, int nDefault)
{
    return (GetPrivateProfileInt(TEXT("Marshal Test"),
				 pszKeyName,
				 nDefault,
				 g_szIniFile));
}

// ----------------------------------------------------------------------
//
//	TestMarshal - main test driver
//
// ----------------------------------------------------------------------
BOOL TestMarshal(void)
{
    BOOL	RetVal = TRUE;

    // Get file name of .ini file, TMARSHAL.INI in the current directory
    GetCurrentDirectory (MAX_PATH, g_szIniFile);
    lstrcat(g_szIniFile, TEXT("\\TMARSHAL.INI"));


    if (GetProfileValue(TEXT("Format"),1))
	RetVal &= TestMarshalFormat();

    if (GetProfileValue(TEXT("GetIIDFromMI"),1))
	RetVal &= TestGetIIDFromMI();

    if (GetProfileValue(TEXT("MarshalSizeMax"),1))
	RetVal &= TestMarshalSizeMax();

    if (GetProfileValue(TEXT("GetStandardMarshal"),1))
	RetVal &= TestGetStandardMarshal();

    if (GetProfileValue(TEXT("LocalInterfaceNormal"),1))
	RetVal &= TestLocalInterfaceNormal();

    if (GetProfileValue(TEXT("UniqueQIPointer"),1))
	RetVal &= TestUniqueQIPointer();

    if (GetProfileValue(TEXT("LocalInterfaceTableStrong"),1))
	RetVal &= TestLocalInterfaceTableStrong();

    if (GetProfileValue(TEXT("LocalInterfaceTableWeak"),1))
	RetVal &= TestLocalInterfaceTableWeak();

    if (GetProfileValue(TEXT("RemoteInterfaceNormal"),1))
	RetVal &= TestRemoteInterfaceNormal();

    if (GetProfileValue(TEXT("UnmarshalGUIDNULL"),1))
	RetVal &= TestUnmarshalGUIDNULL();

    if (GetProfileValue(TEXT("UnmarshalDifferentIID"),1))
	RetVal &= TestUnmarshalDifferentIID();

    if (GetProfileValue(TEXT("RemoteInterfaceTableStrong"),1))
	RetVal &= TestRemoteInterfaceTableStrong();

    if (GetProfileValue(TEXT("CrossThread"),1))
	RetVal &= TestCrossThread();

    if (GetProfileValue(TEXT("CustomMarshalNormal"),1))
	RetVal &= TestCustomMarshalNormal();

    if (GetProfileValue(TEXT("CustomMarshalTable"),1))
	RetVal &= TestCustomMarshalTable();

    if (GetProfileValue(TEXT("Echo"),1))
	RetVal &= TestEcho();

    if (GetProfileValue(TEXT("Loop"),1))
	RetVal &= TestLoop();

    if (GetProfileValue(TEXT("LockObjectExternal"),1))
	RetVal &= TestLockObjectExternal();

    if (GetProfileValue(TEXT("DisconnectObject"),1))
	RetVal &= TestDisconnectObject();

    if (GetProfileValue(TEXT("ReleaseMarshalData"),1))
	RetVal &= TestReleaseMarshalData();

    if (GetProfileValue(TEXT("MultiQINormal"),1))
	RetVal &= TestMultiQINormal();

    if (GetProfileValue(TEXT("MultiQIHandler"),1))
	RetVal &= TestMultiQIHandler();

    if (GetProfileValue(TEXT("Handler"),1))
	RetVal &= TestHandler();

    if (GetProfileValue(TEXT("MiddleMan"),1))
	RetVal &= TestMiddleMan();

    if (GetProfileValue(TEXT("MarshalStorage"),1))
	RetVal &= TestMarshalStorage();

    if (GetProfileValue(TEXT("LocalDiffMachine"),1))
	RetVal &= TestLocalInterfaceDiffMachine();

    if (GetProfileValue(TEXT("RemoteDiffMachine"),1))
	RetVal &= TestRemoteInterfaceDiffMachine();

    if (GetProfileValue(TEXT("ExpiredOXIDs"),1))
	RetVal &= TestExpiredOXIDs();

    if (GetProfileValue(TEXT("NonNDRProxy"),1))
	RetVal &= TestNonNDRProxy();

    if (GetProfileValue(TEXT("TIDAndLID"),1))
	RetVal &= TestTIDAndLID();

    if (GetProfileValue(TEXT("NoPing"),1))
	RetVal &= TestNoPing();

    if (GetProfileValue(TEXT("PSClsid"),1))
	RetVal &= TestPSClsid();

    if (GetProfileValue(TEXT("PSClsid2"),1))
	RetVal &= TestPSClsid2();

    // -------------------------------------------------------------------

    if (GetProfileValue(TEXT("Rundown"),0))
	RetVal &= TestRundown();

    if (GetProfileValue(TEXT("Async"),0))
	RetVal &= TestAsync();

    if (GetProfileValue(TEXT("StorageDiffMachine"),0))
	RetVal &= TestStorageInterfaceDiffMachine();

    if (GetProfileValue(TEXT("Aggregate"),0))
	RetVal &= TestAggregate();

    if (GetProfileValue(TEXT("CreateRemoteHandler"),0))
	RetVal &= TestCreateRemoteHandler();

    return  RetVal;
}

// ----------------------------------------------------------------------
//
//  subroutine to verify that the RH RefCnt is as expected.
//
// ----------------------------------------------------------------------

typedef IMarshal * (* PFNDBG_FINDRH)(IUnknown *punk);
PFNDBG_FINDRH gpfnFindRH = NULL;

HMODULE ghOle32Dll = NULL;
BOOL gfTriedToLoad = FALSE;


void LoadProc()
{
    if (!gfTriedToLoad)
    {
	gfTriedToLoad = TRUE;

	ghOle32Dll = LoadLibrary(TEXT("OLE32.DLL"));
	if (ghOle32Dll)
	{
	    gpfnFindRH = (PFNDBG_FINDRH) GetProcAddress(ghOle32Dll,
							"Dbg_FindRemoteHdlr");
	}
    }
}

void FreeProc()
{
    if (ghOle32Dll)
    {
	FreeLibrary(ghOle32Dll);
    }
}

// ----------------------------------------------------------------------
//
//  subroutine to verify that the RH RefCnt is as expected.
//
// ----------------------------------------------------------------------

void VerifyRHRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt)
{
    if (gpfnFindRH == NULL)
    {
	LoadProc();
    }

    if (gpfnFindRH)
    {
	// this function is internal to COMPOBJ marshalling.
	IMarshal *pIM = (gpfnFindRH)(punk);
	if (pIM == NULL)
	{
	    if (ulExpectedRefCnt != 0)
		printf ("ERROR: RH RefCnt 0, expected=%x\n", ulExpectedRefCnt);
	    return;
	}

	ULONG ulRefCnt = pIM->Release();
	if (ulRefCnt != ulExpectedRefCnt)
	{
	    printf ("ERROR: RH RefCnt=%x, expected=%x\n", ulRefCnt, ulExpectedRefCnt);
	}
    }
}

// ----------------------------------------------------------------------
//
//  subroutine to verify that the Object RefCnt is as expected.
//
// ----------------------------------------------------------------------

void VerifyObjRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt)
{
    if (ulExpectedRefCnt == 0)
	return; 		//  cant verify this

//#if DBG==1
    //	this function is internal to COMPOBJ marshalling.
    punk->AddRef();
    ULONG ulRefCnt = punk->Release();
    if (ulRefCnt != ulExpectedRefCnt)
    {
	printf ("ERROR: Object RefCnt=%x, expected=%x\n", ulRefCnt, ulExpectedRefCnt);
    }
//#endif
}


// ----------------------------------------------------------------------
//
//  MarshalAndRead
//
// ----------------------------------------------------------------------
HRESULT MarshalAndRead(IUnknown *punkIn, BYTE *pbuf, ULONG *pulSize)
{
    BOOL    RetVal = TRUE;
    HRESULT hres;

    ULARGE_INTEGER ulSeekEnd;
    LARGE_INTEGER lSeekStart;
    LISet32(lSeekStart, 0);

    IStream *pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");

    // get current seek position
    hres = pStm->Seek(lSeekStart, STREAM_SEEK_CUR, &ulSeekEnd);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    OUTPUT ("   - Seek Current OK\n");

    // go back to begining
    hres = pStm->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    OUTPUT ("   - Seek Start OK\n");

    // read in the data
    hres = pStm->Read(pbuf ,ulSeekEnd.LowPart, pulSize);
    TEST_FAILED_EXIT(FAILED(hres), "Read on stream failed\n")
    OUTPUT ("   - Read OK\n");

Cleanup:

    // release the stream
    pStm->Release();

    if (RetVal == TRUE)
	return S_OK;
    else
	return hres;
}

// ----------------------------------------------------------------------
//
//	GetTestUnk - return an inproc IUnknown ptr.
//
// ----------------------------------------------------------------------
IUnknown *GetTestUnk()
{
    IUnknown *punkIn = (IUnknown *)(IParseDisplayName *) new CTestUnk();
    return punkIn;
}


// ----------------------------------------------------------------------
//
//  RunThread - runs a thread and waits for it to complete
//
// ----------------------------------------------------------------------
void RunThread(void *param, HANDLE hEvent, LPTHREAD_START_ROUTINE pfn)
{
    DWORD dwThrdId;
    HANDLE hThrd = CreateThread(NULL, 0, pfn, param, 0, &dwThrdId);

    if (hThrd)
    {
	if (gInitFlag == COINIT_APARTMENTTHREADED)
	{
	    // enter a message pump to accept incoming calls from the
	    // other thread.

	    MSG msg;
	    while (GetMessage(&msg, NULL, 0, 0))
	    {
		DispatchMessage(&msg);
	    }
	}
	else
	{
	    // wait for the other thread to run to completion
	    WaitForSingleObject(hEvent, 0xffffffff);
	}

	// close the thread handle
	CloseHandle(hThrd);
    }
}


// ----------------------------------------------------------------------
//
//	TestAsync
//
// ----------------------------------------------------------------------
BOOL TestAsync(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    ULONG	    ulRefCnt = 0;
    IUnknown	    *pUnkSrv = NULL;
    IAdviseSink	    *pAdvSnk = NULL;

    OUTPUT ("Starting TestAsync\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_Async, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnkSrv);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    OUTPUT ("   - QI for IAdviseSink\n");
    hRes = pUnkSrv->QueryInterface(IID_IAdviseSink, (void **)&pAdvSnk);
    TEST_FAILED_EXIT(FAILED(hRes), "QI for IAdviseSink failed\n")

    // now call on the IAdviseSink Interface
    pAdvSnk->OnSave();

    Sleep(30);

    // release the interface
    pAdvSnk->Release();
    pAdvSnk = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pAdvSnk)
    {
	ulRefCnt = pAdvSnk->Release();
	TEST_FAILED(ulRefCnt != 1, "pAdvSnk RefCnt not zero\n");
    }

    if (pUnkSrv)
    {
	ulRefCnt = pUnkSrv->Release();
	TEST_FAILED(ulRefCnt != 0, "PunkSrv RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestAsync");
}


// ----------------------------------------------------------------------
//
//	test marshal format
//
// ----------------------------------------------------------------------
BOOL TestMarshalFormat(void)
{
    BOOL	  RetVal = TRUE;
    BOOL	  fSame  = TRUE;
    HRESULT	  hres;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    BYTE	  buf1[600];
    BYTE	  buf2[600];
    ULONG	  ulSize1 = sizeof(buf1);
    ULONG	  ulSize2 = sizeof(buf2);

    OUTPUT ("Starting TestMarshalFormat\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    hres = MarshalAndRead(punkIn, buf1, &ulSize1);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalAndRead failed\n")
    OUTPUT ("   - First MarshalAndRead OK\n");

    hres = MarshalAndRead(punkIn, buf2, &ulSize2);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalAndRead failed\n")
    OUTPUT ("   - Second MarshalAndRead OK\n");

    TEST_FAILED_EXIT((ulSize1 != ulSize2), "Buffer Sizes Differ\n")
    fSame = !memcmp(buf1, buf2, ulSize1);

    TEST_FAILED_EXIT(!fSame, "Buffer Contents Differ\n")
    OUTPUT ("   - Buffers Compare OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoDisconnectObject(punkIn,0);

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestMarshalFormat");
}


// ----------------------------------------------------------------------
//
//	test CoGetMarshalSizeMax
//
// ----------------------------------------------------------------------
BOOL TestMarshalSizeMax(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    ULONG	  ulSize = 0;

    OUTPUT ("Starting TestMarshalSizeMax\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    hres = CoGetMarshalSizeMax(&ulSize, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoGetMarshalSizeMax failed\n")
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoGetMarshalSizeMax OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    if (punkIn)
    {
	punkIn->Release();
	punkIn = NULL;
    }

    return TestResult(RetVal, "TestMarshalSizeMax");
}


// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceNormal(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    IUnknown	  *punkOut2 = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceNormal\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 2);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");

    //	the RH should have gone away, and we should have only the original
    //	refcnt from creation left on the object.
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------
#if 0
    // this test disabled for DCOM since we no longer write into the stream
    // to mark the thing as having been unmarshaled. This lets unmarshals
    // work with read-only streams.


    //	test unmarshalling twice. this should fail since we did marshal
    //	flags normal and already unmarshalled it once.

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut2);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoUnmarshalInterface second time succeeded but should have failed\n")
    OUTPUT ("   - Second CoUnmarshalInterface OK\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should fail because Unmarshall already called it.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoReleaseMarshalData succeeded but should have failed.\n")
    OUTPUT  ("	- CoReleaseMarshalData OK\n");

#endif
// ----------------------------------------------------------------------

    //	marshal again and try CoRelease without having first done an
    //	unmarshal. this should work.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");
    VerifyRHRefCnt(punkIn, 1);

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

    // release the object and try to unmarshal it again. Should fail
    // since the object has gone away.

    ulRefCnt = punkIn->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    punkIn = NULL;

    // go back to start of stream
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoUnmarshalInterface should have failed\n")

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkOut2)
    {
	ulRefCnt = punkOut2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut2 RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceNormal");
}


// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL when the object returns a
//	differnt interface pointer on each subsequent QI for the same
//	interface
//
// ----------------------------------------------------------------------
BOOL TestUniqueQIPointer(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    ICube	  *pCubeIn  = NULL;
    ICube	  *pCubeOut = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestUniqueQIPointer\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    hres = punkIn->QueryInterface(IID_ICube, (void **)&pCubeIn);
    TEST_FAILED_EXIT((pCubeIn == NULL), "QI for IID_ICube failed\n")
    VerifyObjRefCnt(punkIn, 2);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------
    hres = CoMarshalInterface(pStm, IID_ICube, pCubeIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(pCubeIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    // since we are unmarshalling in the same process, the RH should go away.
    hres = CoUnmarshalInterface(pStm, IID_ICube, (LPVOID FAR*)&pCubeOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(pCubeIn, 0);
    VerifyRHRefCnt(pCubeOut, 0);
    VerifyRHRefCnt(punkIn, 0);

    VerifyObjRefCnt(pCubeIn, 1);
    VerifyObjRefCnt(pCubeOut, 1);
    VerifyObjRefCnt(punkIn, 3);

    // make sure the Ctrl Unknown interface pointers are identical
    hres = pCubeOut->QueryInterface(IID_IUnknown, (void **)&punkOut);
    TEST_FAILED_EXIT((punkOut == NULL), "QI for IID_IUnknown failed\n")
    VerifyObjRefCnt(punkOut, 4);

    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    // attempt a call on the in interface pointer.
    hres = pCubeIn->MoveCube(0,0);
    TEST_FAILED_EXIT(FAILED(hres), "pCubeIn->MoveCube failed\n")

    // release the in-pointer
    ulRefCnt = pCubeIn->Release();
    TEST_FAILED(ulRefCnt != 0, "pCubeIn RefCnt not zero\n");
    pCubeIn = NULL;

    // now call on the out interface pointer
    hres = pCubeOut->MoveCube(0,0);
    TEST_FAILED_EXIT(FAILED(hres), "pCubeOut->MoveCube failed\n")

    // release the out-pointer
    ulRefCnt = pCubeOut->Release();
    TEST_FAILED(ulRefCnt != 0, "pCubeOut RefCnt not zero\n");
    pCubeOut = NULL;


Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (pCubeIn)
    {
	ulRefCnt = pCubeIn->Release();
	TEST_FAILED(ulRefCnt != 0, "pCubeIn RefCnt not zero\n");
    }

    if (pCubeOut)
    {
	ulRefCnt = pCubeOut->Release();
	TEST_FAILED(ulRefCnt != 0, "pCubeOut RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestUniqueQIPointer");
}



// ----------------------------------------------------------------------
//
//  test LOCAL interface MSHLFLAGS_TABLESTRONG
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceTableStrong(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    IUnknown	  *punkOut2 = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceTableStrong\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	unmarshalling should leave the RH intact, as it is marshalled for TABLE.
    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	test unmarshalling twice - should work since we used flags table
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut2);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface second time succeeded but should have failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Second CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut2->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut2 RefCnt is zero");
    punkOut2 = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should release the marshalled data TABLESTRONG
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkOut2)
    {
	ulRefCnt = punkOut2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut2 RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceTableStrong");
}


// ----------------------------------------------------------------------
//
//  test LOCAL interface MSHLFLAGS_TABLEWEAK
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceTableWeak(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    IUnknown	  *punkOut2 = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceTableWeak\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------

    hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punkIn, 0, NULL, MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	unmarshalling should leave the RH intact, as it is marshalled for TABLE.
    hres = CoUnmarshalInterface(pStm, IID_IParseDisplayName, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	test unmarshalling twice - should work since we used flags table
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IParseDisplayName, (LPVOID FAR*)&punkOut2);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface second time succeeded but should have failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut2)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...2nd Local Unmarshal\n")
    OUTPUT ("   - Second CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut2->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut2 RefCnt is zero");
    punkOut2 = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should release the marshalled data TABLEWEAK
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");


    ulRefCnt = punkIn->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn RefCnt is not zero");
    punkIn = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkOut2)
    {
	ulRefCnt = punkOut2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut2 RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceTableWeak");
}

// ----------------------------------------------------------------------
//
//	test calling CoUmarshalInterface with GUID_NULL
//
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
//
//  Structure passed between apartments.
//
// ----------------------------------------------------------------------
typedef struct tagThreadUnmarshalInfo
{
    HANDLE   hEvent;
    IStream  *pStm;
    IUnknown *pUnk;
    IID      iid;
    DWORD    dwInitFlag;
    DWORD    dwThreadId;
    ULONG    RelRefCnt;
    HRESULT  hr;
} ThreadUnmarshalInfo;


DWORD _stdcall ThreadTestUnmarshal(void *params)
{
    ThreadUnmarshalInfo *pInfo = (ThreadUnmarshalInfo *)params;
    BOOL      RetVal  = TRUE;
    ULONG     ulRefCnt= 0;
    IUnknown *punkOut = NULL;
    HRESULT   hres;

    hres = CoInitializeEx(NULL, pInfo->dwInitFlag);

    hres = CoUnmarshalInterface(pInfo->pStm, pInfo->iid, (LPVOID FAR*)&punkOut);
    TEST_FAILED(FAILED(hres), "CoUnmarshalInterface failed\n")

    if (SUCCEEDED(hres))
    {
	// make sure the interface pointers are identical
	if (pInfo->pUnk != NULL && pInfo->pUnk != punkOut)
	{
	    TEST_FAILED(TRUE, "Interface ptrs are wrong\n")
	}
	else
	{
	    OUTPUT ("   - CoUnmarshalInterface OK.\n");
	}

	// release the interface
	ulRefCnt = punkOut->Release();
	punkOut  = NULL;
	TEST_FAILED(ulRefCnt != pInfo->RelRefCnt, "Released punkOut RefCnt is wrong\n");

	OUTPUT ("   - Release OK\n");
    }

    pInfo->hr = hres;

    CoUninitialize();

    // signal the other thread we are done.
	// but only if we were called from a different thread

	if (pInfo->dwThreadId != 0)
	{
		if (gInitFlag == COINIT_APARTMENTTHREADED)
		{
 			PostThreadMessage(pInfo->dwThreadId, WM_QUIT, 0, 0);
		}
		else
		{
			SetEvent(pInfo->hEvent);
		}
	}

    return 0;
}


BOOL TestUnmarshalGUIDNULL(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    IUnknown	    *punkIn  = NULL;
    ULONG	    ulRefCnt, i;
    HANDLE	    hEvent = NULL;
    ThreadUnmarshalInfo Info;


    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestUnmarshalGUIDNULL\n");

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    for (i=0; i<2; i++)
    {
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	TEST_FAILED_EXIT(hEvent == NULL, "CreateEvent failed\n")

	punkIn = GetTestUnk();
	TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punkIn, 1);

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punkIn,
				  0, 0, MSHLFLAGS_NORMAL);
	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	VerifyRHRefCnt(punkIn, 1);
	OUTPUT ("   - CoMarshalInterface OK.\n");

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	Info.hEvent = hEvent;
	Info.pStm = pStm;
	Info.iid  = GUID_NULL;
	Info.dwInitFlag = gInitFlag;
	Info.dwThreadId = 0;

	if (i==0)
	{
	    // first time, call on same thread, expect original ptr and
	    // non-zero refcnt after release
	    Info.pUnk	   = punkIn;
	    Info.RelRefCnt = 1;

	    ThreadTestUnmarshal(&Info);
	}
	else
	{
	    // second time, call on different thread
	    if (gInitFlag == COINIT_APARTMENTTHREADED)
	    {
		// apartment thread, expect differnt ptr and
		// zero refcnt after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= 0;
		Info.RelRefCnt	= 0;
	    }
	    else
	    {
		// multi-thread, expect same ptr and non-zero refcnt
		// after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= punkIn;
		Info.RelRefCnt	= 1;
	    }

	    RunThread(&Info, hEvent, ThreadTestUnmarshal);
	    CloseHandle(hEvent);
	}

	// release the punkIn.
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
	punkIn = NULL;

	hres = Info.hr;
	OUTPUT ("    - Run Complete\n");
    }

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestUnmarshalGUIDNULL");
}

// ----------------------------------------------------------------------
//
//	test calling CoUmarshalInterface with an IID different from
//	the IID that was marshaled.
//
// ----------------------------------------------------------------------

BOOL TestUnmarshalDifferentIID(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    IUnknown	    *punkIn  = NULL;
    ULONG	    ulRefCnt, i;
    HANDLE	    hEvent = NULL;
    ThreadUnmarshalInfo Info;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestUnmarshalDifferentIID\n");

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    for (i=0; i<2; i++)
    {
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	TEST_FAILED_EXIT(hEvent == NULL, "CreateEvent failed\n")

	punkIn = GetTestUnk();
	TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punkIn, 1);

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punkIn,
				  0, 0, MSHLFLAGS_NORMAL);
	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	VerifyRHRefCnt(punkIn, 1);
	OUTPUT ("   - CoMarshalInterface OK.\n");

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	Info.hEvent = hEvent;
	Info.pStm   = pStm;
	Info.iid    = IID_IOleWindow;
	Info.pUnk   = punkIn;
	Info.dwInitFlag = gInitFlag;
	Info.dwThreadId = 0;

	if (i==0)
	{
	    // first time, call on same thread, expect different ptr and
	    // non-zero refcnt after release
	    Info.pUnk	   = 0;
	    Info.RelRefCnt = 1;

	    ThreadTestUnmarshal(&Info);
	}
	else
	{
	    if (gInitFlag == COINIT_APARTMENTTHREADED)
	    {
		// apartment thread, expect differnt ptr and
		// zero refcnt after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= 0;
		Info.RelRefCnt	= 0;
	    }
	    else
	    {
		// multi-thread, expect same ptr and non-zero refcnt
		// after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= 0;
		Info.RelRefCnt	= 1;
	    }

	    RunThread(&Info, hEvent, ThreadTestUnmarshal);
	    CloseHandle(hEvent);
	}

	// release the punkIn.
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
	punkIn = NULL;

	hres = Info.hr;
	OUTPUT ("    - Run Complete\n");
    }

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestUnmarshalDifferentIID");
}


// ----------------------------------------------------------------------
//
//	test REMOTE interface MSHLFLAGS_NORMAL
//
// ----------------------------------------------------------------------

BOOL TestRemoteInterfaceNormal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestRemoteInterfaceNormal\n");

    //	Create an IClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    VerifyRHRefCnt((IUnknown *)pICF, 1);
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn == NULL), "CreateInstance failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Created Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
//    VerifyRHRefCnt((IUnknown *)pICF, 0);
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    //	Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punkIn, 1);

    //	unmarshal the interface. should get the same proxy back.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 2);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Remote Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");


    //	release the interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

#if 0
    //	test unmarshalling twice. this should fail since we marshalled normal
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoUnmarshalInterface succeeded but should have failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Second CoUnmarshalInterface OK.\n");
    punkOut = NULL;

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should FAIL since we already unmarshalled it
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoReleaseMarshalData succeeded but should have failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

#endif
// ----------------------------------------------------------------------

    //	marshal again and try CoRelease without having first done an
    //	unmarshal. this should work.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (pICF)
    {
	ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestRemoteInterfaceNormal");
}


// ----------------------------------------------------------------------
//
//	test REMOTE interface MSHLFLAGS_TABLESTRONG
//
// ----------------------------------------------------------------------

BOOL TestRemoteInterfaceTableStrong(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkOut = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestRemoteInterfaceTableStrong\n");

    //	Create an IClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    // Create a shared memory stream for the marshaled moniker
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    // Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoMarshalInterface succeeded but should have failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

#if 0
    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Remote Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");

    //	release it
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	test unmarshalling twice.
    //	this should work since we did marshal flags TABLE_STRONG
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    OUTPUT ("   - Second CoUnmarshalInterface OK.\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should WORK for TABLESTRONG interfaces
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    OUTPUT  ("	- CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------
#endif
Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    }

    if (punkIn)
    {
	//  release instance
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0,"punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestRemoteInterfaceTableStrong");
}

// ----------------------------------------------------------------------
//
//	test CUSTOM interface MSHLFLAGS_NORMAL --- CODEWORK
//
// ----------------------------------------------------------------------

BOOL TestCustomMarshalNormal(void)
{
    BOOL	RetVal = TRUE;

    return TestResult(RetVal, "TestCustomMarshalNormal");
}


// ----------------------------------------------------------------------
//
//	test CUSTOM interface MSHLFLAGS_TABLESTRONG --- CODEWORK
//
// ----------------------------------------------------------------------

BOOL TestCustomMarshalTable(void)
{
    BOOL	RetVal = TRUE;

    return TestResult(RetVal, "TestCustomMarshalTableStrong");
}


// ----------------------------------------------------------------------
//
//	TestEcho
//
//	test sending an interface to a remote server and getting the same
//	interface back again. the test is done with once with a local
//	interface and once with a remote interface.
//
//		Local Interface 		Remote Interface
//
//	1.  marshal [in] local		    marshal [in] remote proxy
//	2.  unmarshal [in] remote	    unmarshal [in] local proxy
//	3.  marshal [out] remote proxy	    marshal [out] local
//	4.  unmarshal [in] local proxy	    unmarshal [out] remote
//
// ----------------------------------------------------------------------

BOOL TestEcho(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    LPCLASSFACTORY  pICF = NULL;
    IBalls	    *pIBalls = NULL;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkIn2 = NULL;
    IUnknown	    *punkOut = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestEcho\n");

    //	Create an IBall ClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IBalls, (void **)&pIBalls);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((pIBalls == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created First Instance.\n");

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn2);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn2 == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Second Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    //	create a local interface
    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    //	call a method that echos the local interface right back to us.
    hres = pIBalls->Echo(punkIn, &punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "Echo on IBalls failed\n")
    TEST_FAILED_EXIT((punkOut == NULL), "Echo on IBalls failed\n")

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..Echo\n")

    VerifyObjRefCnt(punkIn, 2);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - Echo OK.\n");

    //	release the out interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 1, "punkOut RefCnt is not 1\n");
    OUTPUT ("   - Released punkOut OK\n");

    //	release the In interface
    ulRefCnt = punkIn->Release();
    punkIn = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn RefCnt is not zero\n");
    OUTPUT ("   - Released punkIn OK\n");

    OUTPUT ("   - Echo Local Interface OK\n");

// ----------------------------------------------------------------------

    //	call a method that echos a remote interface right back to us.
    hres = pIBalls->Echo(punkIn2, &punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "Echo on IBalls failed\n")
    TEST_FAILED_EXIT((punkOut == NULL), "Echon on IBalls failed\n")

    //	make sure the interface pointers are identical
    if (punkIn2 != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..Echo\n")

    VerifyObjRefCnt(punkIn2, 2);
    VerifyRHRefCnt(punkIn2, 2);
    OUTPUT ("   - Echo OK.\n");

    //	release the out interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 1, "punkOut RefCnt is not 1\n");
    OUTPUT ("   - Released punkOut OK\n");

    //	release the In interface
    ulRefCnt = punkIn2->Release();
    punkIn2 = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn2 RefCnt is not zero\n");
    OUTPUT ("   - Released punkIn2 OK\n");

    OUTPUT ("   - Echo Remote Interface OK\n");

// ----------------------------------------------------------------------

    //	release the IBalls interface
    ulRefCnt = pIBalls->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "pIBalls RefCnt is not zero\n");
    pIBalls = NULL;
    OUTPUT  ("   - Released IBalls OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pICF)
    {
	ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    if (pIBalls)
    {
	ulRefCnt = pIBalls->Release();
	TEST_FAILED(ulRefCnt != 0, "pIBalls RefCnt not zero\n");
    }

    if (punkIn2)
    {
	ulRefCnt = punkIn2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn2 RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestEcho");
}



// ----------------------------------------------------------------------
//
//	TestMiddleMan
//
//	test sending an remote interface to a second different process.
//
//	1.  marshal [in] remote proxy
//	2.  unmarshal [in] remote proxy
//	3.  marshal [out] remote proxy
//	4.  unmarshal [in] local proxy
//
// ----------------------------------------------------------------------

BOOL TestMiddleMan(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    LPCLASSFACTORY  pICF = NULL;
    IBalls	    *pIBalls = NULL;
    ICube	    *pICubes = NULL;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkOut = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestMiddleMan\n");

    //	Create an IBall ClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject Balls failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject Balls failed\n")
    OUTPUT ("   - Aquired Remote Balls Class Object.\n");
    VerifyObjRefCnt(pICF, 1);
    VerifyRHRefCnt(pICF, 1);

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IBalls, (void **)&pIBalls);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((pIBalls == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Balls Instance.\n");

    VerifyObjRefCnt(pIBalls, 1);
    VerifyRHRefCnt(pIBalls, 1);

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Balls Class Object.\n");

// ----------------------------------------------------------------------

    //	Create an ICube ClassFactory Interface.
    grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Cubes,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject Cubes failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject Cubes failed\n")
    OUTPUT ("   - Aquired Remote Cubes Class Object.\n");
    VerifyObjRefCnt(pICF, 1);
    VerifyRHRefCnt(pICF, 1);

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_ICube, (void **)&pICubes);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance Cubes failed\n")
    TEST_FAILED_EXIT((pICubes == NULL), "CreateInstance Cubes failed\n")
    OUTPUT ("   - Created Cubes Instance.\n");

    VerifyObjRefCnt(pICubes, 1);
    VerifyRHRefCnt(pICubes, 1);

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Cubes Class Object.\n");

// ----------------------------------------------------------------------

    //	pass the remote cubes interface to the balls interface.
    hres = pIBalls->IsContainedIn(pICubes);
    TEST_FAILED_EXIT(FAILED(hres), "IsContainedIn failed\n")
    VerifyObjRefCnt(pIBalls, 1);
    VerifyRHRefCnt(pIBalls, 1);
    VerifyObjRefCnt(pICubes, 1);
    VerifyRHRefCnt(pICubes, 1);
    OUTPUT ("   - IsContainedIn OK.\n");

// ----------------------------------------------------------------------

    //	pass the remote balls interface to the cubes interface.
    hres = pICubes->Contains(pIBalls);
    TEST_FAILED_EXIT(FAILED(hres), "Contains failed\n")
    VerifyObjRefCnt(pIBalls, 1);
    VerifyRHRefCnt(pIBalls, 1);
    VerifyObjRefCnt(pICubes, 1);
    VerifyRHRefCnt(pICubes, 1);
    OUTPUT ("   - Contains OK.\n");

// ----------------------------------------------------------------------

    //	echo the remote ICubes interface to the remote IBalls interface
    hres = pICubes->QueryInterface(IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "QueryInterface IUnknown failed\n")
    VerifyRHRefCnt(pICubes, 2);
    VerifyObjRefCnt(pICubes, 2);
    OUTPUT ("   - QueryInterface OK.\n");

    hres = pIBalls->Echo(punkIn, &punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "Echo on IBalls failed\n")
    TEST_FAILED_EXIT((punkOut == NULL), "Echo on IBalls failed\n")

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..Echo\n")

    VerifyObjRefCnt(punkIn, 3);
    VerifyRHRefCnt(punkIn, 3);
    OUTPUT ("   - Echo OK.\n");

    //	release the out interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED(ulRefCnt != 2, "punkOut RefCnt is not 2\n");
    OUTPUT ("   - Released punkOut OK\n");

    //	release the In interface
    ulRefCnt = punkIn->Release();
    punkIn = NULL;
    TEST_FAILED(ulRefCnt != 1, "punkIn RefCnt is not 1\n");
    OUTPUT ("   - Released punkIn OK\n");

// ----------------------------------------------------------------------

    //	release the ICubes interface
    ulRefCnt = pICubes->Release();
    TEST_FAILED(ulRefCnt != 0, "pICubes RefCnt is not zero\n");
    pICubes = NULL;
    OUTPUT  ("   - Released ICubes OK\n");

// ----------------------------------------------------------------------

    //	release the IBalls interface
    ulRefCnt = pIBalls->Release();
    TEST_FAILED(ulRefCnt != 0, "pIBalls RefCnt is not zero\n");
    pIBalls = NULL;
    OUTPUT  ("   - Released IBalls OK\n");

// ----------------------------------------------------------------------


Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pICF)
    {
	ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    }

    if (pIBalls)
    {
	ulRefCnt = pIBalls->Release();
	TEST_FAILED(ulRefCnt != 0, "pIBalls RefCnt not zero\n");
    }

    if (pICubes)
    {
	ulRefCnt = pICubes->Release();
	TEST_FAILED(ulRefCnt != 0, "pICubes RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestMiddleMan");
}


// ----------------------------------------------------------------------
//
//	TestLoop
//
//	tests A calling B calling A calling B etc n times, to see if Rpc
//	can handle this.
//
// ----------------------------------------------------------------------

BOOL TestLoop(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    ILoop	    *pLocalLoop = NULL;
    ILoop	    *pRemoteLoop = NULL;

    OUTPUT ("Starting TestLoop\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ILoop, (void **)&pLocalLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    //	create the remote object
    hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ILoop, (void **)&pRemoteLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance Second failed\n")

    //	initialize the two instances
    OUTPUT ("   - Initializing Instances\n");
    hRes = pLocalLoop->Init(pRemoteLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "Initialize First failed\n")
    hRes = pRemoteLoop->Init(pLocalLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "Initialize Second failed\n")

    //	now start the test
    OUTPUT ("   - Running LoopTest\n");
    hRes = pLocalLoop->Loop(10);
    TEST_FAILED(FAILED(hRes), "Loop failed\n")

    //	uninitialize the two instances
    OUTPUT ("   - Uninitializing Instances\n");
    hRes = pLocalLoop->Uninit();
    TEST_FAILED_EXIT(FAILED(hRes), "Uninitialize First failed\n")
    hRes = pRemoteLoop->Uninit();
    TEST_FAILED_EXIT(FAILED(hRes), "Uninitialize Second failed\n")

Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pRemoteLoop)
	pRemoteLoop->Release();

    if (pLocalLoop)
	pLocalLoop->Release();

    return TestResult(RetVal, "TestLoop");
}

// ----------------------------------------------------------------------
//
//	TestMultiQINormal
//
//	tests IMultiQI interface on Normal proxies
//
// ----------------------------------------------------------------------

ULONG cMisc = 4;
const IID *iidMisc[] = {
		 &IID_IParseDisplayName, &IID_IPersistStorage,
		 &IID_IPersistFile,	 &IID_IStorage,
		 &IID_IOleContainer,	 &IID_IOleItemContainer,
		 &IID_IOleInPlaceSite,	 &IID_IOleInPlaceActiveObject,
		 &IID_IOleInPlaceObject, &IID_IOleInPlaceUIWindow,
		 &IID_IOleInPlaceFrame,	 &IID_IOleWindow};

MULTI_QI    arMQI[20];
MULTI_QI    *pMQIResStart = arMQI;

BOOL TestMultiQINormal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes   = S_OK;
    IUnknown	    *pUnk  = NULL;
    IUnknown	    *pUnk2 = NULL;
    IMultiQI	    *pMQI  = NULL;
    ULONG		 i = 0, j=0, cRefs = 0;
    MULTI_QI	    *pMQIRes = NULL;

// ----------------------------------------------------------------------
    ULONG cSupported = 4;
    const IID *iidSupported[] = {&IID_IUnknown,	       &IID_IMultiQI,
				 &IID_IClientSecurity, &IID_IMarshal,
				 &IID_IStdIdentity,    &IID_IProxyManager};

    ULONG cUnSupported = 2;
    const IID *iidUnSupported[] = {&IID_IInternalUnknown,
				   &IID_IServerSecurity};

// ----------------------------------------------------------------------

    OUTPUT ("Starting TestMultiQINormal\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_QI, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance QISRV failed\n")

    VerifyObjRefCnt(pUnk, 1);
    VerifyRHRefCnt(pUnk, 1);

// ----------------------------------------------------------------------

    OUTPUT ("\n   - NormalQI for supported interfaces\n");

    // loop through all the supported interfaces doing a normal QI.

    for (i=0; i<cSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidSupported[i], (void **)&pUnk2);
	TEST_FAILED(FAILED(hRes), "QueryInterface on supported interfaces failed\n")
	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    VerifyObjRefCnt(pUnk, 2);
	    VerifyRHRefCnt(pUnk, 2);

	    OUTPUT ("       - QI for supported interface OK\n");
	    pUnk2->Release();
	}
    }


    OUTPUT ("\n   - NormalQI for unsupported interfaces\n");

    // loop through all the unsupported interfaces doing a normal QI.

    for (i=0; i<cUnSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidUnSupported[i], (void **)&pUnk2);
	TEST_FAILED(SUCCEEDED(hRes), "QueryInterface on unsupported interface succeeded but should have failed\n")

	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    pUnk2->Release();
	}
	else
	{
	    VerifyObjRefCnt(pUnk, 1);
	    VerifyRHRefCnt(pUnk, 1);

	    OUTPUT ("       - QI for unsupported interface OK.\n");
	}
    }

    // should be back to normal (IUnknown)
    VerifyObjRefCnt(pUnk, 1);
    VerifyRHRefCnt(pUnk, 1);

// ----------------------------------------------------------------------

    hRes = pUnk->QueryInterface(IID_IMultiQI, (void **)&pMQI);
    TEST_FAILED_EXIT(FAILED(hRes), "QI for IMultiQI failed\n")
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);


    OUTPUT ("\n   - MultiQI for supported interfaces\n");

    // now issue a MultiQI for the supported interfaces
    pMQIRes = pMQIResStart;
    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidSupported[i];
	pMQIRes->pItf = NULL;
    }

    pMQIRes = pMQIResStart;
    hRes = pMQI->QueryMultipleInterfaces(cSupported, pMQIRes);
    TEST_FAILED(hRes != S_OK, "QueryMultipleInterfaces should have return S_OK\n")
    VerifyObjRefCnt(pUnk, 2 + cSupported);
    VerifyRHRefCnt(pUnk, 2 + cSupported);

    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf == NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(FAILED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    OUTPUT ("       - MultiQI for supported interface OK\n");
	    pMQIRes->pItf->Release();

	    VerifyObjRefCnt(pUnk, 2 + cSupported - (i+1));
	    VerifyRHRefCnt(pUnk, 2 + cSupported - (i+1));
	}
    }

    // should be back to normal (IUnknown + IMultiQI)
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

// ----------------------------------------------------------------------

    OUTPUT ("\n   - MultiQI for unsupported interfaces\n");

    // now issue a MultiQI for the unsupported interfaces
    pMQIRes = pMQIResStart;
    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidUnSupported[i];
	pMQIRes->pItf = NULL;
    }

    pMQIRes = pMQIResStart;
    hRes = pMQI->QueryMultipleInterfaces(cUnSupported, pMQIRes);
    TEST_FAILED(hRes != E_NOINTERFACE, "QueryMultipleInterfaces should have return E_NOINTERFACES\n")
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf != NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(SUCCEEDED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    pMQIRes->pItf->Release();
	}
	else
	{
	    OUTPUT ("       - MultiQI for unsupported interface OK\n");
	}
    }

    // should back to normal refcnts (IUnknown + IMultiQI)
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

// ----------------------------------------------------------------------

    // repeat this test twice, first time goes remote for the misc interfaces,
    // second time finds them already instantiated.

  for (j=0; j<2; j++)
  {
    OUTPUT ("\n   - MultiQI for combination of interfaces\n");

    pMQIRes = pMQIResStart;
    for (i=0; i<cMisc; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidMisc[i];
	pMQIRes->pItf = NULL;
    }

    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidSupported[i];
	pMQIRes->pItf = NULL;
    }

    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidUnSupported[i];
	pMQIRes->pItf = NULL;
    }

    pMQIRes = pMQIResStart;
    hRes = pMQI->QueryMultipleInterfaces(cSupported + cUnSupported + cMisc, pMQIRes);
    TEST_FAILED(hRes != S_FALSE, "QueryMultipleInterfaces should have return S_FALSE\n")
    VerifyObjRefCnt(pUnk, 2 + cSupported + cMisc);
    VerifyRHRefCnt(pUnk, 2 + cSupported + cMisc);

    for (i=0; i<cMisc; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf == NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(FAILED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    OUTPUT ("       - MultiQI for supported remote interface OK\n");
	    pMQIRes->pItf->Release();

	    VerifyObjRefCnt(pUnk, 2 + cSupported + cMisc - (i+1));
	    VerifyRHRefCnt(pUnk, 2 + cSupported + cMisc - (i+1));
	}
    }

    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf == NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(FAILED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    OUTPUT ("       - MultiQI for supported local interface OK\n");
	    pMQIRes->pItf->Release();

	    VerifyObjRefCnt(pUnk, 2 + cSupported - (i+1));
	    VerifyRHRefCnt(pUnk, 2 + cSupported - (i+1));
	}
    }

    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf != NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(SUCCEEDED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    pMQIRes->pItf->Release();
	}
	else
	{
	    OUTPUT ("       - MultiQI for unsupported local interface OK\n");
	}
    }

    // should back to normal refcnts (IUnknown + IMultiQI)
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

  } // for (j=...)

// ----------------------------------------------------------------------
Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pMQI)
    {
	pMQI->Release();
    }

    if (pUnk)
    {
	cRefs = pUnk->Release();
	TEST_FAILED(cRefs != 0, "Last release not zero\n");
    }

    return TestResult(RetVal, "TestMultiQINormal");
}

// ----------------------------------------------------------------------
//
//	TestMultiQIHandler
//
//	tests IMultiQI interface on Handlers
//
// ----------------------------------------------------------------------
BOOL TestMultiQIHandler(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes   = S_OK;
    IUnknown	    *pUnk  = NULL;
    IUnknown	    *pUnk2 = NULL;
    ULONG		 i = 0;
    MULTI_QI	    *pMQIRes = NULL;

// ----------------------------------------------------------------------
    ULONG cSupported = 4;
    const IID *iidSupported[] = {&IID_IUnknown, &IID_IMarshal,
				 &IID_IStdIdentity, &IID_IProxyManager};

    ULONG cUnSupported = 4;
    const IID *iidUnSupported[] = {&IID_IInternalUnknown, &IID_IClientSecurity,
				   &IID_IServerSecurity, &IID_IMultiQI};


// ----------------------------------------------------------------------

    OUTPUT ("Starting TestMultiQIHandler\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_QIHANDLER1, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance QIHANDLER1 failed\n")

// ----------------------------------------------------------------------

    OUTPUT ("\n   - NormalQI for supported interfaces\n");

    // loop through all the supported interfaces doing a normal QI.

    for (i=0; i<cSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidSupported[i], (void **)&pUnk2);
	TEST_FAILED(FAILED(hRes), "QueryInterface on supported interfaces failed\n")
	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    OUTPUT ("   - QI for supported interface OK\n");
	    pUnk2->Release();
	}
    }

    OUTPUT ("\n   - NormalQI for unsupported interfaces\n");

    // loop through all the unsupported interfaces doing a normal QI.

    for (i=0; i<cUnSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidUnSupported[i], (void **)&pUnk2);
	TEST_FAILED(SUCCEEDED(hRes), "QueryInterface on unsupported interface succeeded but should have failed\n")

	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    pUnk2->Release();
	}
	else
	{
	    OUTPUT ("   - QI for unsupported interface OK.\n");
	}
    }
// ----------------------------------------------------------------------
Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pUnk)
	pUnk->Release();

    return TestResult(RetVal, "TestMultiQIHandler");
}


// ----------------------------------------------------------------------
//
//	TestHandler
//
//	tests activating a server that has a handler
//
// ----------------------------------------------------------------------

BOOL TestHandler(void)
{
    BOOL	    RetVal   = TRUE;
    ULONG	    cRefs    = 0;
    HRESULT	    hRes     = S_OK;
    IUnknown	    *pUnkSrv = NULL;
    IUnknown	    *pUnkHdl = NULL;
    IRunnableObject *pIRO    = NULL;
    IOleObject	    *pIOO    = NULL;
    IDropTarget     *pIDT    = NULL;


    OUTPUT ("Starting TestHandler\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_TestEmbed, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnkSrv);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance LOCAL_SERVER failed\n")
    VerifyObjRefCnt(pUnkSrv, 1);
    OUTPUT ("   - CoCreateInstance LOCAL_SERVER succeeded\n");

    OUTPUT ("   - QI for IRunnableObject\n");
    hRes = pUnkSrv->QueryInterface(IID_IRunnableObject, (void **)&pIRO);
    TEST_FAILED(SUCCEEDED(hRes), "QI for IRO on LOCAL_SERVER succeeded\n")

    if (pIRO)
    {
	pIRO->Release();
	pIRO = NULL;
    }

    OUTPUT ("   - Releasing Instance\n");
    if (pUnkSrv)
    {
	cRefs = pUnkSrv->Release();
	TEST_FAILED(cRefs != 0, "REFCNT wrong on Release\n")
	pUnkSrv = NULL;
    }
    OUTPUT ("   - LOCAL_SERVER case complete\n");

// ----------------------------------------------------------------------
    //	create the remote object

    hRes = CoCreateInstance(CLSID_TestEmbed, NULL, CLSCTX_INPROC_HANDLER,
			    IID_IUnknown, (void **)&pUnkHdl);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance INPROC_HANDLER failed\n")
    VerifyObjRefCnt(pUnkHdl, 1);
    VerifyRHRefCnt(pUnkHdl, 1);
    OUTPUT ("   - CoCreateInstance INPROC_HANDLER succeeded\n");

// ----------------------------------------------------------------------
    // query for some unsupported interface to ensure OLE handles QI
    // when not yet connected to the server.

    OUTPUT ("   - QI for IDropTarget\n");
    hRes = pUnkHdl->QueryInterface(IID_IDropTarget, (void **)&pIDT);
    VerifyObjRefCnt(pUnkHdl, 1);
    VerifyRHRefCnt(pUnkHdl, 1);
    TEST_FAILED_EXIT(SUCCEEDED(hRes),
	"QI for IDropTarget on INPROC_HANDLER worked but should have failed!\n")

    // the return value from failed QI on a handler that was never connected
    // must be E_NOINTERFACE
    TEST_FAILED_EXIT(hRes != E_NOINTERFACE,
	"QI for IDropTarget on INPROC_HANDLER did not return E_NOINTERFACE!\n")

    OUTPUT ("   - Query for remote Interface before connected OK.\n");

// ----------------------------------------------------------------------
    //	run the remote server

    OUTPUT ("   - QI for IRunnableObject\n");
    hRes = pUnkHdl->QueryInterface(IID_IRunnableObject, (void **)&pIRO);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    TEST_FAILED_EXIT(FAILED(hRes), "QI for IRO on INPROC_HANDLER failed\n")

    hRes = pIRO->Run(NULL);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    TEST_FAILED(FAILED(hRes), "IRO->Run on INPROC_HANDLER failed\n")
    OUTPUT ("   - INPROC_HANDLER run OK\n");

// ----------------------------------------------------------------------
    // test stoping the server

    OUTPUT ("   - Stop the Server\n");
    hRes = pUnkHdl->QueryInterface(IID_IOleObject, (void **)&pIOO);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED_EXIT(FAILED(hRes), "QI for IOleObject on INPROC_HANDLER failed\n")

    hRes = pIOO->Close(OLECLOSE_NOSAVE);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED(FAILED(hRes), "IOO->Close on INPROC_HANDLER failed\n")
    pIOO->Release();
    pIOO = NULL;
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    OUTPUT ("   - INPROC_HANDLER Close OK\n");

// ----------------------------------------------------------------------
    // query again for some unsupported interface to ensure OLE handles QI
    // when disconnected from the server.

    OUTPUT ("   - QI for IDropTarget\n");
    hRes = pUnkHdl->QueryInterface(IID_IDropTarget, (void **)&pIDT);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    TEST_FAILED_EXIT(SUCCEEDED(hRes),
	"QI for IDropTarget on disconnected INPROC_HANDLER worked but should have failed!\n")

    // the return value from failed QI on a handler that has been disconnected
    // must be CO_O_OBJNOTCONNECTED

    TEST_FAILED_EXIT(hRes != CO_E_OBJNOTCONNECTED,
	"QI for IDropTarget on INPROC_HANDLER did not return CO_E_OBJNOTCONNECTED!\n")

    OUTPUT ("   - Query for remote Interface after disconnected OK.\n");

// ----------------------------------------------------------------------
    // test restarting the server

    Sleep(500);
    OUTPUT ("   - Run the Server Again\n");
    hRes = pIRO->Run(NULL);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);

    TEST_FAILED(FAILED(hRes), "Second IRO->Run on INPROC_HANDLER failed\n")
    OUTPUT ("   - Second INPROC_HANDLER Run OK\n");

// ----------------------------------------------------------------------
    // test stoping the server

    OUTPUT ("   - Stop the Server\n");
    hRes = pUnkHdl->QueryInterface(IID_IOleObject, (void **)&pIOO);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED_EXIT(FAILED(hRes), "QI for IOleObject on INPROC_HANDLER failed\n")

    hRes = pIOO->Close(OLECLOSE_NOSAVE);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED(FAILED(hRes), "IOO->Close on INPROC_HANDLER failed\n")
    pIOO->Release();
    pIOO = NULL;
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    OUTPUT ("   - INPROC_HANDLER Close OK\n");

// ----------------------------------------------------------------------
    // test using weak references

    OUTPUT ("   - Call OleSetContainedObject TRUE\n");
    hRes = OleSetContainedObject(pUnkHdl, 1);
    TEST_FAILED(FAILED(hRes), "1st OleSetContainedObject on pUnkHdl failed\n")
    OUTPUT ("   - OleSetContainedObject OK\n");

    Sleep(500);
    OUTPUT ("   - Run the Server Again\n");
    hRes = pIRO->Run(NULL);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);

    TEST_FAILED(FAILED(hRes), "Third IRO->Run on INPROC_HANDLER failed\n")
    OUTPUT ("   - Third INPROC_HANDLER Run OK\n");

    // try making the references strong again
    OUTPUT ("   - Call OleSetContainedObject FALSE\n");
    hRes = OleSetContainedObject(pUnkHdl, 0);
    TEST_FAILED(FAILED(hRes), "2nd OleSetContainedObject on pUnkHdl failed\n")
    OUTPUT ("   - OleSetContainedObject OK\n");

    // try making the references weak again
    OUTPUT ("   - Call OleSetContainedObject TRUE\n");
    hRes = OleSetContainedObject(pUnkHdl, 1);
    TEST_FAILED(FAILED(hRes), "3rd OleSetContainedObject on pUnkHdl failed\n")
    OUTPUT ("   - OleSetContainedObject OK\n");

// ----------------------------------------------------------------------
    // cleanup

    pIRO->Release();
    pIRO = NULL;
    VerifyObjRefCnt(pUnkHdl, 1);
    VerifyRHRefCnt(pUnkHdl, 1);

// ----------------------------------------------------------------------

    OUTPUT ("   - Releasing Instance\n");
    if (pUnkHdl)
    {
	cRefs = pUnkHdl->Release();
	TEST_FAILED(cRefs != 0, "REFCNT wrong on Release\n")
	pUnkHdl = NULL;
    }
    OUTPUT ("   - INPROC_HANDLER case complete\n");

// ----------------------------------------------------------------------

Cleanup:

    //	release the two instances
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (pIDT)
    {
	pIDT->Release();
    }

    if (pIRO)
    {
	pIRO->Release();
    }

    if (pIOO)
    {
	pIOO->Release();
    }

    if (pUnkSrv)
    {
	pUnkSrv->Release();
    }

    if (pUnkHdl)
    {
	pUnkHdl->Release();
    }

    return TestResult(RetVal, "TestHandler");
}

// ----------------------------------------------------------------------
//
//	TestGetStandardMarshal
//
//	test CoGetStandardMarshal API
//
// ----------------------------------------------------------------------

BOOL TestGetStandardMarshal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IMarshal	    *pIM = NULL, *pIM2 = NULL;
    IStream	    *pStm;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkOut = NULL;


    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestGetStandardMarshal\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------
    hres = CoGetStandardMarshal(IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL, &pIM);
    TEST_FAILED_EXIT(FAILED(hres), "CoGetStandardMarshal failed\n")
    VerifyRHRefCnt(punkIn, 1);

    hres = CoGetStandardMarshal(IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL, &pIM2);
    TEST_FAILED_EXIT(FAILED(hres), "second CoGetStandardMarshal failed\n")
    VerifyRHRefCnt(punkIn, 2);

    TEST_FAILED((pIM != pIM2), "CoGetStandardMarshal returned two different interfaces.\n")
    ulRefCnt = pIM2->Release();
    TEST_FAILED_EXIT(ulRefCnt != 1, "pIM2 RefCnt is wrong");
    pIM2 = NULL;

    hres = CoGetStandardMarshal(IID_IUnknown, NULL, 0, NULL, MSHLFLAGS_NORMAL, &pIM2);
    TEST_FAILED_EXIT(FAILED(hres), "third CoGetStandardMarshal failed\n")
    VerifyRHRefCnt(punkIn, 1);

    OUTPUT ("   - CoGetStandardMarshal OK\n");

// ----------------------------------------------------------------------
    hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalInterface failed\n")

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = pIM->UnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "UnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - UnmarshalInterface OK\n");

    //	release interface and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");


// ----------------------------------------------------------------------
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalInterface failed\n")

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = pIM2->UnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "UnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - Second UnmarshalInterface OK\n");

    //	release interface and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");

    ulRefCnt = pIM2->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "pIM2 RefCnt is zero");
    pIM2 = NULL;
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	release the marshalled data
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalInterface failed\n")

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = pIM->ReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "Release Marshal Data failed\n.");
    OUTPUT ("   - ReleaseMarshalData OK\n");


    //	the RH should go away, and we should have only the original
    //	refcnt from creation left on the object.
    ulRefCnt = pIM->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "pIM RefCnt not zero");
    pIM = NULL;

    //	release the original object
    ulRefCnt = punkIn->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn RefCnt not zero");
    punkIn = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestGetStandardMarshal");
}



// ----------------------------------------------------------------------
//
//	TestLockObjectExternal
//
//	test CoLockObjectExternal API
//
// ----------------------------------------------------------------------

BOOL TestLockObjectExternal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IUnknown	    *punkIn = NULL;
    IStream	    *pStm = NULL;

    OUTPUT ("Starting TestLockObjectExternal\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);


// ----------------------------------------------------------------------
    //	test calling it once, then releasing it once

    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

// ----------------------------------------------------------------------
    //	test calling it twice, then releasing it twice

    //	the first AddRef inc's the StrongCnt, the RH, and the real object.
    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    //	the second AddRef inc's the StrongCnt and the RH, but not the
    //	real object.
    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 2);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    //	the second release Dec's the StrongCnt and the RH, but not the
    //	real object.
    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

    //	the last Release dec's the StrongCnt, the RH, and the real object.
    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

// ----------------------------------------------------------------------
    //	test calling it once, then releasing the punkIn and ensuring
    //	the object is still alive.

    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    ulRefCnt = punkIn->Release();
    TEST_FAILED(ulRefCnt != 1, "Release returned incorrect value.\n");
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - punkIn->Release OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    punkIn = NULL;
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

// ----------------------------------------------------------------------
    // test calling marshal interface, followed by CLOE(F,T). This
    // should disconnect the object. This is bizarre backward compatibility
    // semantics that some LOTUS apps do rely on.

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL,
			      MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface TABLE_STRONG OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, TRUE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal(F,T) failed\n")
    VerifyObjRefCnt(punkIn, 1);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoLockObjectExternal FALSE TRUE OK\n");


    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL,
			      MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface NORMAL OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, TRUE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal(F,T) failed\n")
    VerifyObjRefCnt(punkIn, 1);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoLockObjectExternal FALSE TRUE OK\n");


    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL,
			      MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface TABLEWEAK OK\n");

    // BUGBUG: refcnts seem to be wrong on the following call:

    hres = CoLockObjectExternal(punkIn, FALSE, TRUE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal(F,T) failed\n")
    VerifyObjRefCnt(punkIn, 1);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoLockObjectExternal FALSE TRUE OK\n");

    punkIn->Release();
    punkIn = NULL;

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    if (pStm)
    {
	pStm->Release();
    }

    return TestResult(RetVal, "TestLockObjectExternal");
}


// ----------------------------------------------------------------------
//
//	TestReleaseMarshalData
//
//	test CoReleaseMarshalData API
//
// ----------------------------------------------------------------------

BOOL TestReleaseMarshalData(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    cRefs;
    IUnknown	    *punkIn = NULL;
    IStream	    *pStm = NULL;
    LARGE_INTEGER   large_int;


    OUTPUT ("Starting TestReleaseMarshalData\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    // Create a shared memory stream for the marshaled object
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    // try RMD on NORMAL marshal

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - MarshalInterface NORMAL OK\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoReleaseMarshalData NORMAL OK\n");


    // try RMD on TABLESTRONG marshal

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - MarshalInterface TABLESTRONG OK\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoReleaseMarshalData TABLESTRONG OK\n");

    // try RMD on TABLEWEAK marshal


    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - MarshalInterface TABLEWEAK OK\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoReleaseMarshalData TABLEWEAK OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (punkIn)
    {
	cRefs = punkIn->Release();
	TEST_FAILED(cRefs != 0, "punkIn RefCnt not zero\n");
    }

    if (pStm)
    {
	pStm->Release();
    }

    return TestResult(RetVal, "TestReleaseMarshalData");
}



// ----------------------------------------------------------------------
//
//	TestDisconnectObject
//
//	test CoDisconnectObject API
//
// ----------------------------------------------------------------------

BOOL TestDisconnectObject(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IUnknown	    *punkIn = NULL;
    IStream	    *pStm = NULL;
    LARGE_INTEGER   large_int;


    OUTPUT ("Starting TestDisconnectObject\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    // Create a shared memory stream for the marshaled object
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------
    //	test calling it without having ever marshalled it.

    hres = CoDisconnectObject(punkIn, 0);
    TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject succeeded but should have failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);

    OUTPUT ("   - first CoDisconnectObject OK\n");


    //	test calling after having marshalled it.

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);

    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = CoDisconnectObject(punkIn, 0);
    TEST_FAILED_EXIT(FAILED(hres), "second CoDisconnectObject failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);

    OUTPUT ("   - second CoDisconnectObject OK\n");

    //	now release the marshalled data

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);

    OUTPUT ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    if (pStm)
    {
	pStm->Release();
    }

    return TestResult(RetVal, "TestDisconnectObject");
}

// ----------------------------------------------------------------------
//
//	TestOXIDs
//
//	tests A calling B calling A calling B etc n times, to see if Rpc
//	can handle this.
//
// ----------------------------------------------------------------------
BOOL TestExpiredOXIDs(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    ILoop	    *pLocalLoop = NULL;
    IClassFactory   *pUnk = NULL;

    OUTPUT ("Starting TestExpiredOXIDs\n");

    // start the local server process manually so it stays alive for the
    // duration of the test (even though we dont have an OXIDEntry for it.

    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;
    memset(&processInfo, 0, sizeof(processInfo));
    memset(&startupInfo, 0, sizeof(startupInfo));

    RetVal = CreateProcess(TEXT("ballsrv.exe"),
			   NULL,    // command line
			   NULL,    // security for process
			   NULL,    // security for thread
			   FALSE,   // inherit handles
			   NORMAL_PRIORITY_CLASS,
			   NULL,    // environment block
			   NULL,    // current directory
			   &startupInfo,
			   &processInfo);

    if (RetVal == FALSE)
    {
        hRes = GetLastError();
        OUTPUT ("   - CreateProcess Failed\n");
    }
    else
    {
        // give the process time to register its class object
        Sleep(2000);
    }

    for (ULONG i=0; i<7; i++)
    {
        // create a new instance of a local server that is already running,
        // causing us to reuse the same OXID.

        hRes = CoGetClassObject(CLSID_Balls,
        			CLSCTX_LOCAL_SERVER,
        			NULL,		     // pvReserved
        			IID_IClassFactory,
        			(void **)&pUnk);

        TEST_FAILED_EXIT(FAILED(hRes), "CoGetClassObject ballsrv failed\n")

        // release interface (lets OXIDEntry be placed on the expired list)
        pUnk->Release();
        pUnk = NULL;

        for (ULONG j=0; j<i; j++)
        {
            // create (i) new instances of another class and release them
            // right away. This causes (i) new processes to start and (i)
            // entries of the OXID table expired list to get flushed.

            hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
        		    IID_ILoop, (void **)&pLocalLoop);
            TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")
            pLocalLoop->Release();
            pLocalLoop = NULL;
        }
    }

Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pUnk)
        pUnk->Release();

    if (pLocalLoop)
        pLocalLoop->Release();

    // kill the server process
    if (processInfo.hProcess != 0)
    {
        BOOL fKill = TerminateProcess(processInfo.hProcess, 0);
        if (!fKill)
        {
            hRes = GetLastError();
            OUTPUT ("   - TermintateProcess Failed\n");
        }

        CloseHandle(processInfo.hThread);
        CloseHandle(processInfo.hProcess);
    }

    return TestResult(RetVal, "TestExpiredOXIDs");
}




// ----------------------------------------------------------------------
//
//	TestAggregate
//
//	tests creating an RH that is aggregated.
//
// ----------------------------------------------------------------------

BOOL TestAggregate(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    IUnknown	    *punkOuter = NULL;
    IUnknown	    *pUnk = NULL;
    IBalls	    *pIBall = NULL;
    ULONG	    ulRefCnt = 0;

    OUTPUT ("Starting TestAggregate\n");

    punkOuter = GetTestUnk();
    TEST_FAILED_EXIT((punkOuter == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkOuter, 1);

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_Balls, punkOuter, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    //	now release the object
    ulRefCnt = pUnk->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "Release failed\n")

// ----------------------------------------------------------------------

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_Balls, punkOuter, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    hRes = pUnk->QueryInterface(IID_IBalls, (void **)&pIBall);
    TEST_FAILED_EXIT(FAILED(hRes), "QueryInterface failed\n")

    //	now release the interface
    ulRefCnt = pIBall->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "Release failed\n")

    //	now release the object
    ulRefCnt = pUnk->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "Release failed\n")

    //	now release the punkOuter
    ulRefCnt = punkOuter->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "Release failed\n")

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    return TestResult(RetVal, "TestAggregate");
}



// ----------------------------------------------------------------------
//
//	TestCreateRemoteHandler
//
//	test CoCreateRemoteHandler API and unmarshalling data into it.
//
// ----------------------------------------------------------------------

BOOL TestCreateRemoteHandler(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IUnknown	    *punkBall = NULL;
    IUnknown	    *punkOuter = NULL;
    IClassFactory   *pICF = NULL;


    OUTPUT ("Starting TestCreateRemoteHandler\n");


    //	create the controlling unknown for the remote object.
    punkOuter = GetTestUnk();

// ----------------------------------------------------------------------

    //	create a remote object that we will aggregate.

    //	Create an IBall ClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject Balls failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject Balls failed\n")
    OUTPUT ("   - Aquired Remote Balls Class Object.\n");
    VerifyObjRefCnt(pICF, 1);
    VerifyRHRefCnt(pICF, 1);

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(punkOuter, IID_IUnknown, (void **)&punkBall);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkBall == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Balls Instance.\n");

    VerifyObjRefCnt(punkBall, 1);
    VerifyRHRefCnt(punkBall, 1);

// ----------------------------------------------------------------------

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Balls Class Object.\n");

    //	release the remote object handler
    ulRefCnt = punkBall->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkBall RefCnt not zero");
    punkBall = NULL;

    //	release the outer
    ulRefCnt = punkOuter->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkOuter RefCnt not zero");
    punkOuter = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (punkBall)
    {
	ulRefCnt = punkBall->Release();
	TEST_FAILED(ulRefCnt != 0, "punkBall RefCnt not zero\n");
    }

    if (punkOuter)
    {
	ulRefCnt = punkOuter->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOuter RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestCreateRemoteHandler");
}


// ----------------------------------------------------------------------
//
//	TestTIDAndLID
//
//	test the values of TID and MID to ensure they are correct across
//	calls.
//
// ----------------------------------------------------------------------
HRESULT        TIDAndLIDSubroutine();
DWORD _stdcall TIDAndLIDServer(void *param);


BOOL TestTIDAndLID(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes;

    // First, try it across process boundaries.
    hRes = TIDAndLIDSubroutine();
    TEST_FAILED(FAILED(hRes), "TIDAndLID different process failed\n")


    // Next, try it across thread boundaries.
    // Spin a thread to be the server of the TIDAndLID

    HANDLE hEvent[2];
    hEvent[0]= CreateEvent(NULL, FALSE, FALSE, NULL);
    hEvent[1]= CreateEvent(NULL, FALSE, FALSE, NULL);

    DWORD dwThrdId = 0;
    HANDLE hThrd = CreateThread(NULL, 0,
			    TIDAndLIDServer,
			    &hEvent[0], 0, &dwThrdId);
    if (hThrd)
    {
	// wait for thread to register its class object
	WaitForSingleObject(hEvent[0], 0xffffffff);
	Sleep(0);

	// Now run the whole test again. This time CoGetClassObject should
	// find the server running in the other thread.

	hRes = TIDAndLIDSubroutine();
	TEST_FAILED(FAILED(hRes), "TIDAndLID different process failed\n")

	// signal the other thread to exit
	CloseHandle(hThrd);
	PostThreadMessage(dwThrdId, WM_QUIT, 0, 0);

	// wait for other thread to call CoUninitialize
	WaitForSingleObject(hEvent[1], 0xffffffff);
	CloseHandle(hEvent[0]);
	CloseHandle(hEvent[1]);
    }
    else
    {
	hRes = GetLastError();
	TEST_FAILED(hRes, "CreateThread failed\n")
    }

    return TestResult(RetVal, "TestTIDAndLID");
}

HRESULT TIDAndLIDSubroutine()
{
    BOOL	    RetVal = TRUE;
    ULONG	    ulRefCnt;
    ICube	    *pCube = NULL;
    IUnknown	    *pUnk  = NULL;
    HRESULT	    hRes;

    // create our interface to pass to the remote object.
    OUTPUT ("   - Create Instance of ICube\n");
    hRes = CoCreateInstance(CLSID_Cubes, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ICube, (void **)&pCube);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance CLSID_Cubes failed\n")
    OUTPUT ("   - Instance of ICubes created OK\n");

    pUnk = GetTestUnk();

    hRes = pCube->PrepForInputSyncCall(pUnk);
    TEST_FAILED(FAILED(hRes), "pCube->PreForInputSyncCall failed\n")

    hRes = pCube->InputSyncCall();
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	TEST_FAILED(FAILED(hRes), "pCube->InputSyncCall failed\n")
    }
    else
    {
	TEST_FAILED(SUCCEEDED(hRes), "pCube->InputSyncCall should have failed\n")
    }
    OUTPUT ("   - Completed Release inside InputSync call\n");


    OUTPUT ("   - Get the current LID information\n");
    UUID  lidCaller;
    CoGetCurrentLogicalThreadId(&lidCaller);

    OUTPUT ("   - call on ICube interface\n");
    hRes = pCube->SimpleCall(GetCurrentProcessId(),
			     GetCurrentThreadId(),
			     lidCaller);

    TEST_FAILED(FAILED(hRes), "pCube->SimpleCall failed\n")

    // release the interface
    OUTPUT ("   - Release the ICube interface\n");
    ulRefCnt = pCube->Release();
    TEST_FAILED(ulRefCnt != 0, "pCube RefCnt not zero\n");
    pCube = NULL;

Cleanup:

    OUTPUT ("   - Subroutine Complete. Doing Cleanup\n");

    if (pCube != NULL)
    {
	pCube->Release();
	pCube = NULL;
    }

    return hRes;
}

// current COINIT flag used on main thread
extern DWORD gInitFlag;

DWORD _stdcall TIDAndLIDServer(void *param)
{
    BOOL    RetVal = TRUE;

    HANDLE *pHandle = (HANDLE *) param;

    HANDLE  hEvent[2];
    hEvent[0] = *pHandle;
    hEvent[1] = *(pHandle+1);

    OUTPUT ("   - TIDAndLIDServer Start\n");

    HRESULT hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "TIDAndLIDServer CoInitialize failed\n")

    if (SUCCEEDED(hRes))
    {
	DWORD dwReg;
	IClassFactory *pICF = new CTestUnkCF();

	if (pICF)
	{
	    hRes = CoRegisterClassObject(CLSID_Cubes, pICF,
					 CLSCTX_LOCAL_SERVER,
					 REGCLS_MULTIPLEUSE, &dwReg);

	    TEST_FAILED(FAILED(hRes), "TIDAndLID CoRegisterClassObject failed\n")
	    SetEvent(hEvent[0]);

	    if (SUCCEEDED(hRes))
	    {
		MSG msg;
		while (GetMessage(&msg, NULL, 0, 0))
		{
		    DispatchMessage(&msg);
		}

		hRes = CoRevokeClassObject(dwReg);
		TEST_FAILED(FAILED(hRes), "TIDAndLID CoRevokeClassObject failed\n")
	    }
	}
	else
	{
	    // set the event anyway
	    TEST_FAILED(TRUE, "TIDAndLID new CTestUnkCF failed\n")
	    SetEvent(hEvent[0]);
	}

	CoUninitialize();
    }
    else
    {
	// wake the other guy anyway
	SetEvent(hEvent[0]);
    }

    // signal we've called CoUninitialize
    SetEvent(hEvent[1]);

    OUTPUT ("   - TIDAndLIDServer done\n");
    return hRes;
}


// ----------------------------------------------------------------------
//
//	TestNonNDRProxy
//
//	test using a non-NDR proxy and stub for ICube interface.
//
// ----------------------------------------------------------------------
BOOL TestNonNDRProxy(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes;
    ULONG	    ulRefCnt;
    ICube	    *pCube = NULL;


    OUTPUT ("Starting TestNonNDR\n");

    // stomp on the registry to use our custom proxy dll for ICube interface
    BYTE  szValueSave[MAX_PATH];
    DWORD cbValue = sizeof(szValueSave);
    DWORD dwType;

    LONG lRes = RegQueryValueEx(HKEY_CLASSES_ROOT,
		    TEXT("Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32"),
		    NULL,
		    &dwType,
		    szValueSave,
		    &cbValue);

    if (lRes == ERROR_SUCCESS)
    {
	BYTE szValueNew[40];
	strcpy((char *)&szValueNew[0], "{0000013e-0001-0008-C000-000000000046}");

	lRes = RegSetValueEx(HKEY_CLASSES_ROOT,
		    TEXT("Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32"),
		    NULL,
		    dwType,
		    szValueNew,
		    sizeof(szValueNew));
    }

    // create our interface to pass to the remote object.
    OUTPUT ("   - Create Instance of ICube\n");
    hRes = CoCreateInstance(CLSID_Cubes, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ICube, (void **)&pCube);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance failed\n")
    OUTPUT ("   - Instance of ICube created OK\n");


    OUTPUT ("   - Make first call on ICube interface\n");
    hRes = pCube->MoveCube(23, 34);
    TEST_FAILED(FAILED(hRes), "ICube->MoveCube failed\n")

    // release the interface
    OUTPUT ("   - Release the ICube interface\n");
    ulRefCnt = pCube->Release();
    TEST_FAILED(ulRefCnt != 0, "pCube RefCnt not zero\n");
    pCube = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // restore the registry to use real proxy dll for ICube interface
    if (lRes == ERROR_SUCCESS)
    {
	lRes = RegSetValueEx(HKEY_CLASSES_ROOT,
		    TEXT("Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32"),
		    NULL,
		    dwType,
		    szValueSave,
		    cbValue);
    }

    return TestResult(RetVal, "TestNonNDR");
}


// ----------------------------------------------------------------------
//
//	test rundown
//
//  - build 9 objects
//  - marshal 3 NORMAL, 3 TABLE_STRONG, 3 TABLE_WEAK.
//  - start 3 clients that each do 3 things...
//	  Unmarshal Objects
//	  Call Method on each object
//	  Release Objects
//	  each client has a sleep before one of the operations to let rundown
//	  happen.
//  - CoDisconnectObject each of the 9 objects
//
// ----------------------------------------------------------------------
BOOL TestRundown(void)
{
    BOOL	  RetVal = TRUE;
    BOOL	  fSame  = TRUE;
    ULONG	  k = 0;
    HRESULT	  hres;
    IStream	  *pstm[3] = {NULL, NULL, NULL};
    IUnknown	  *punk[9] = {NULL, NULL, NULL,
			      NULL, NULL, NULL,
			      NULL, NULL, NULL};

    DWORD	   mshlflags[3] = {MSHLFLAGS_NORMAL,
				   MSHLFLAGS_TABLESTRONG,
				   MSHLFLAGS_TABLEWEAK};

    MSG msg;
    DWORD dwEndTime;


    OUTPUT ("Starting TestRundown\n");


    // create 9 objects to play with
    OUTPUT ("Creating Nine Objects\n");
    for (ULONG i=0; i<9; i++)
    {
	punk[i] = GetTestUnk();
	TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punk[i], 1);
    }


    // create 3 streams on files
    OUTPUT ("Creating Three Streams\n");
    for (i=0; i<3; i++)
    {
	pstm[i] = (IStream *) new CStreamOnFile(pwszFileName[i] ,hres, FALSE);
	TEST_FAILED_EXIT((pstm[i] == NULL), "new CStreamOnFile failed\n")
	TEST_FAILED_EXIT(FAILED(hres),	 "CStreamOnFile failed\n")
	VerifyObjRefCnt(pstm[i], 1);
    }

// ----------------------------------------------------------------------

    // marshal the nine objects into 3 different streams on files.
    OUTPUT ("Marshal Nine Objects into Three Streams\n");


    // loop on stream
    for (i=0; i<3; i++)
    {
	// loop on marshal flags
	for (ULONG j=0; j<3; j++)
	{
	    hres = CoMarshalInterface(pstm[i], IID_IParseDisplayName, punk[k++],
				      0, NULL, mshlflags[j]);
	    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	}
    }


    // release the streams
    OUTPUT ("Releasing the streams\n");
    for (i=0; i<3; i++)
    {
	pstm[i]->Release();
	pstm[i] = NULL;
    }


    // start the 3 client processes
    OUTPUT ("Start Three Client Processes\n");

#if 0
    for (i=0; i<3; i++)
    {
	DWORD dwThrdId = 0;
	HANDLE hThrd = CreateThread(NULL, 0,
				    RundownClient,
				    (void *)i,
				    0, &dwThrdId);

	if (hThrd)
	{
	    CloseHandle(hThrd);
	}
	else
	{
	    hres = GetLastError();
	    TEST_FAILED_EXIT(hres, "CreateThread failed\n")
	}
    }
#endif

    // sleep for some time to let the clients run
    OUTPUT ("Waiting 12 minutes to let clients run\n");

    dwEndTime = GetTickCount() + 780000;

    while (GetTickCount() < dwEndTime)

    {
	if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
	{
	    if (GetMessage(&msg, NULL, 0, 0))
		DispatchMessage(&msg);
	}
	else
	{
	    Sleep(250);
	}
    }

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // disconnect the nine objects
    OUTPUT ("Disconnecting Nine Objects\n");
    for (i=0; i<9; i++)
    {
	if (punk[i] != NULL)
	{
	    hres = CoDisconnectObject(punk[i], 0);
	    punk[i] = NULL;
	    TEST_FAILED(FAILED(hres), "CoDisconnectObject failed\n")
	}
    }

    // release the streams
    OUTPUT ("Releasing the streams\n");
    for (i=0; i<3; i++)
    {
	if (pstm[i] != NULL)
	{
	    pstm[i]->Release();
	    pstm[i] = NULL;
	}
    }

    return TestResult(RetVal, "TestRundown");
}

// ----------------------------------------------------------------------
//
//	test rundown worker thread
//
//	starts a thread that will do...
//	  Unmarshal Objects
//	  Call Method on each object
//	  Release Objects
//
//	perform a sleep before one of the operations to let rundown
//	happen.
//
// ----------------------------------------------------------------------
DWORD _stdcall RundownClient(void *param)
{
    BOOL    RetVal = TRUE;
    ULONG   i = 0;
    HRESULT hres;
    IStream *pstm = NULL;
    IBindCtx *pbctx = NULL;
    IParseDisplayName *punk[3] = {NULL, NULL, NULL};


    OUTPUT ("    Starting RundownClient\n");

    // get the filename from the passed in parameter
    DWORD dwThreadNum = (DWORD)param;

    hres = CoInitialize(NULL);
    TEST_FAILED_EXIT(FAILED(hres),   "CoInitialzie failed\n")


    // create a stream on the file
    OUTPUT ("   - CreateStreamOnFile\n");
    pstm = (IStream *) new CStreamOnFile(pwszFileName[dwThreadNum], hres, TRUE);
    TEST_FAILED_EXIT((pstm == NULL), "CStreamOnFile failed\n")
    TEST_FAILED_EXIT(FAILED(hres),   "CStreamOnFile failed\n")
    VerifyObjRefCnt(pstm, 1);

// ----------------------------------------------------------------------

    if (dwThreadNum == 2)
	Sleep(5000);

    // unmarshal the interfaces
    OUTPUT ("   - Unmarshal the interfaces\n");
    for (i=0; i<3; i++)
    {
	hres = CoUnmarshalInterface(pstm, IID_IParseDisplayName,
				    (void **)&punk[i]);
	TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    }
    OUTPUT ("   - Unmarshaled the interfaces OK.\n");

// ----------------------------------------------------------------------

    if (dwThreadNum == 1)
	Sleep(5000);

    hres = CreateBindCtx(0, &pbctx);
    TEST_FAILED_EXIT(FAILED(hres), "CreateBindCtx failed\n")

    // call the objects
    for (i=0; i<3; i++)
    {
	ULONG cbEaten = 0;
	IMoniker *pmnk = NULL;

	hres = punk[i]->ParseDisplayName(pbctx, pwszFileName[dwThreadNum],
					&cbEaten, &pmnk);
	TEST_FAILED(FAILED(hres), "call on object failed\n")

	if (pmnk)
	{
	    pmnk->Release();
	}
    }
    OUTPUT ("   - Called the interfaces OK.\n");

    pbctx->Release();

// ----------------------------------------------------------------------

    if (dwThreadNum == 0)
	Sleep(5000);

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Rundown Thread Complete. Doing Cleanup\n");

    // release the objects
    for (i=0; i<3; i++)
    {
	if (punk[i] != NULL)
	{
	    punk[i]->Release();
	    punk[i] = NULL;
	}
    }
    OUTPUT ("   - Released the interfaces OK.\n");

    // release the stream
    pstm->Release();

    CoUninitialize();

    return TestResult(RetVal, "TestRundown");
}



// ----------------------------------------------------------------------
//
//	TestMarshalStorage
//
//	test marshalling a docfile
//
// ----------------------------------------------------------------------

BOOL TestMarshalStorage(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IStorage	    *pStgIn = NULL;
    IStorage	    *pStgOut = NULL;
    IStream	    *pStm = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestMarshalStorage\n");

    //	create a docfile
    hres = StgCreateDocfile(L"foo.bar",
			    STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
			    0, &pStgIn);

    TEST_FAILED_EXIT(FAILED(hres), "StgCreateDocFile failed\n")

    //	create a stream to marshal the storage into
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);


// ----------------------------------------------------------------------

    //	marshal the interface
    hres = CoMarshalInterface(pStm, IID_IStorage, pStgIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = CoUnmarshalInterface(pStm, IID_IStorage, (LPVOID FAR*)&pStgOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")

    //	make sure the interface pointers are identical
    if (pStgIn != pStgOut)
	OUTPUT("WARNING: CoUnmarshalInterface Local...ptrs dont match\n")
    else
	OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = pStgOut->Release();
    pStgOut  = NULL;
    TEST_FAILED(ulRefCnt == 0, "pStgOut RefCnt is not zero");
    OUTPUT ("   - Release OK\n");

    //	the RH should have gone away, and we should have only the original
    //	refcnt from creation left on the object.
    VerifyObjRefCnt(pStgIn, 1);


// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (pStgIn)
    {
	ulRefCnt = pStgIn->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgIn RefCnt not zero\n");
    }

    if (pStgOut)
    {
	ulRefCnt = pStgOut->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgOut RefCnt not zero\n");
    }

    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "pStm RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestMarshalStorage");
}



// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL, MSHCTX_DIFFERENTMACHINE
//
// ----------------------------------------------------------------------

BOOL TestStorageInterfaceDiffMachine(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IStorage	  *pStgIn = NULL;
    IStorage	  *pStgOut = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestStorageInterfaceDiffMachine\n");

    //	create a docfile
    hres = StgCreateDocfile(L"foo.bar",
			    STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
			    0, &pStgIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateDocfile failed\n")

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);


// ----------------------------------------------------------------------
    hres = CoMarshalInterface(pStm, IID_IStorage, pStgIn,
			      MSHCTX_DIFFERENTMACHINE, 0,
			      MSHLFLAGS_NORMAL);

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(pStgIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IStorage, (LPVOID FAR*)&pStgOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(pStgIn, 0);

    //	release them
    ulRefCnt = pStgOut->Release();
    pStgOut = NULL;
    OUTPUT ("   - Release OK\n");

    ulRefCnt = pStgIn->Release();
    pStgIn = NULL;
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (pStgIn)
    {
	ulRefCnt = pStgIn->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgIn RefCnt not zero\n");
    }

    if (pStgOut)
    {
	ulRefCnt = pStgOut->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgOut RefCnt not zero\n");
    }

    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "pStm RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestStorageInterfaceDiffMachine");
}



// ----------------------------------------------------------------------
//
//	test REMOTE interface MSHLFLAGS_NORMAL, MSHCTX_DIFFERENTMACHINE
//
// ----------------------------------------------------------------------

BOOL TestRemoteInterfaceDiffMachine(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestRemoteInterfaceDifferentMachine\n");

    //	Create an IClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    VerifyRHRefCnt((IUnknown *)pICF, 1);
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn == NULL), "CreateInstance failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Created Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    // VerifyRHRefCnt((IUnknown *)pICF, 0);
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    //	Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      MSHCTX_DIFFERENTMACHINE, 0,
			      MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punkIn, 1);

    //	unmarshal the interface. should get the same proxy back.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 2);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Remote Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");


    //	release the interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestRemoteInterfaceDiffMachine");
}

// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL, MSHCTX_DIFFERENTMACHINE
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceDiffMachine(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceDifferentMachine\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    //	Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      MSHCTX_DIFFERENTMACHINE, 0,
			      MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punkIn, 1);

    //	unmarshal the interface. should get the same proxy back.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 0);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");


    //	release the interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceDiffMachine");
}

// ----------------------------------------------------------------------
//
//	test NOPING with MSHLFLAGS NORMAL, TABLEWEAK and TABLESTRONG
//
//  CodeWork: ensure SORF_FLAG set correctly.
//	      ensure precedence rules are followed.
//	      ensure protocol is followed.
//
// ----------------------------------------------------------------------
typedef struct tagNoPingThreadInfo
{
    HANDLE  hEvent;
    IStream *pStm;
    HRESULT hr;
} NoPingThreadInfo;

DWORD _stdcall NoPingThread(void *param);

BOOL TestNoPing(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    ULONG	    ulRefCnt, i;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;
    IUnknown	    *punk[5] = {NULL, NULL, NULL, NULL, NULL};
    NoPingThreadInfo npInfo;
    DWORD	     dwThrdId = 0;
    HANDLE	    hThrd;
    IMarshal	    *pIM = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestNoPing\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    // Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    // marshal it NORMAL, TABLEWEAK and TABLESTRONG with the NOPING flag
    // set, and unmarshal each in the server apartment.

    for (i=0; i<3; i++)
    {
	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      0, 0, (i | MSHLFLAGS_NOPING));

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punkIn, 1);


	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, (i | MSHLFLAGS_NOPING));
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");


	// unmarshal the interface. should get the same proxy back.
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
	TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")


	// make sure the interface pointers are identical
	if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Local Unmarshal\n")
	OUTPUT ("   - CoUnmarshalInterface OK.\n");

	// check the refcnt on the stdid
	if (i == 0)
	{
	    // normal case, stdid should have been cleaned up
	    VerifyRHRefCnt(punkIn, 0);
	}
	else
	{
	    // table case, stdid should still exist
	    VerifyRHRefCnt(punkIn, 1);
	}

	// release the interface
	ulRefCnt = punkOut->Release();
	punkOut  = NULL;

	TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
	VerifyRHRefCnt(punkIn, (i == 0) ? 0 : 1);
	OUTPUT ("   - Release OK\n");

	if (i > 0)
	{
	    // need to release marshal data on table marshaled interfaces
	    // reset the stream
	    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	    hres = CoReleaseMarshalData(pStm);
	    TEST_FAILED_EXIT(FAILED(hres), "ReleaseMarshalData failed\n")
	}

	// reset the stream
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    }


    // check the precedence rules

    // Whatever an interface is first marshaled as is what sets the
    // PING / NOPING flags. Marshal first as normal then noping and
    // expect a normal 2nd marshal. Then marshal first as noping then
    // normal and expect a noping 2nd marshal.

    for (i=0; i<2; i++)
    {
	DWORD mshlflags1 =  (i==0) ? MSHLFLAGS_NORMAL : MSHLFLAGS_NOPING;
	DWORD mshlflags2 =  (i==0) ? MSHLFLAGS_NOPING : MSHLFLAGS_NORMAL;

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      0, 0, mshlflags1);

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punkIn, 1);

	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, mshlflags1);
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");


	// marshal it again, with the opposite flags then check the value
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      0, 0, mshlflags2);

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punkIn, 1);

	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, mshlflags1);
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");

	// release the marshaled data
	hres = CoDisconnectObject(punkIn, 0);
	TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	OUTPUT ("   - CoDisconnectObject OK.\n");

	// reset the stream
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")



	// check CoGetStandardMarshal.
	hres = CoGetStandardMarshal(IID_IUnknown, punkIn, 0, 0,
				    mshlflags1, &pIM);
	TEST_FAILED_EXIT(FAILED(hres), "CoGetStandardMarshal failed\n")
	OUTPUT ("   - CoGetStandardMarshal OK.\n");

	// Marshal the interface into the stream
	hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn,
				     0, 0, mshlflags2);
	TEST_FAILED_EXIT(FAILED(hres), "pIM->MarshalInterface failed\n")
	OUTPUT ("   - pIM->MarshalInterface OK.\n");

	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, mshlflags1);
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");

	// release the IMarshal
	pIM->Release();

	// release the marshal data
	hres = CoDisconnectObject(punkIn, 0);
	TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	OUTPUT ("   - CoDisconnectObject OK.\n");

	// reset the stream
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    }



    // marshal 3 objects, NORMAL, TABLEWEAK, and TABLESTRONG, then
    // pass the stream to another apartment and unmarshal them.

    for (i=0; i<3; i++)
    {
	punk[i] = GetTestUnk();
	TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punk[i], 1);

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IUnknown, punk[i],
			      0, 0, (i | MSHLFLAGS_NOPING));

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punk[i], 1);
    }

    // marshal one more object, NOPING
    punk[i] = GetTestUnk();
    TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punk[i], 1);

    // Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punk[i],
		      0, 0, (MSHLFLAGS_NORMAL | MSHLFLAGS_NOPING));

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punk[i], 1);


    // marshal a second interface on the same object as PING
    hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punk[i],
		      0, 0, MSHLFLAGS_NORMAL);

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punk[i], 2);


    // pass one more interface that does custom marshaling delegating
    // to standard marshaling and replacing the PING option with NOPING.
    i++;
    punk[i] = (IUnknown *) new CTestUnkMarshal();
    TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnkMarshal failed\n")
    VerifyObjRefCnt(punk[i], 1);

    // Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punk[i],
		      0, 0, MSHLFLAGS_NORMAL);

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punk[i], 2);


    // reset the stream seek ptr
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    for (i=0; i<6; i++)
    {
	// verify the marshal format
	hres = VerifyOBJREFFormat(pStm, (i | MSHLFLAGS_NOPING));
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");
    }

    // reset the stream seek ptr
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    // create thread and wait for it to complete
    npInfo.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    npInfo.pStm   = pStm;
    npInfo.hr	  = S_OK;

    hThrd = CreateThread(NULL, 0, NoPingThread,
			&npInfo, 0, &dwThrdId);
    if (hThrd)
    {
	// wait for thread to register run to completetion. Note that
	// we dont have to provide a message pump because with the NOPING
	// flag set the other thread should never call back to get or release
	// any references.

	WaitForSingleObject(npInfo.hEvent, 0xffffffff);
	Sleep(0);
	CloseHandle(npInfo.hEvent);

	// close the thread handle
	CloseHandle(hThrd);
    }

    // cleanup the leftover objects.
    for (i=0; i<5; i++)
    {
	hres = CoDisconnectObject(punk[i], 0);
	TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	OUTPUT ("   - CoDisconnectObject OK.\n");
    }


// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    for (i=0; i<5; i++)
    {
	if (punk[i] != NULL)
	{
	    ulRefCnt = punk[i]->Release();
	    TEST_FAILED(ulRefCnt != 0, "punk[i] RefCnt not zero\n");
	}
    }

    return TestResult(RetVal, "TestNoPing");
}


// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing NOPING.
//
// ----------------------------------------------------------------------
DWORD _stdcall NoPingThread(void *param)
{
    BOOL    RetVal = TRUE;
    IUnknown *punk = NULL;
    ULONG	 i = 0;

    NoPingThreadInfo *npInfo = (NoPingThreadInfo *) param;
    OUTPUT ("   - NoPingThread Start\n");

    HRESULT hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "NoPingThread CoInitialize failed\n")

    // Create a shared memory stream for the marshaled interface
    IStream *pStm = CreateMemStm(600, NULL);
    if (pStm == NULL)
    {
	TEST_FAILED((pStm == NULL), "CreateMemStm failed\n")
	hRes = E_OUTOFMEMORY;
    }

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    if (SUCCEEDED(hRes))
    {
	// unmarshal the interfaces
	for (i=0; i<6; i++)
	{

	    REFIID riid = (i==4) ? IID_IParseDisplayName : IID_IUnknown;

	    hRes = CoUnmarshalInterface(npInfo->pStm, riid, (void **)&punk);
	    TEST_FAILED(FAILED(hRes), "NoPingThread CoUnmarshalInterface failed\n")
	    OUTPUT("   - NoPingThread CoUnmarshalInterface done\n");

	    if (SUCCEEDED(hRes))
	    {
		if (i==3)
		{
		    // try remarshaling NOPING client as normal. Should end up
		    // as NOPING.

		    hRes = CoMarshalInterface(pStm, IID_IUnknown, punk,
					      0, 0, MSHLFLAGS_NORMAL);
		    TEST_FAILED(FAILED(hRes), "CoMarshalInterface failed\n")
		    OUTPUT ("   - CoMarshalInterface OK.\n");

		    // reset the stream seek ptr
		    hRes = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
		    TEST_FAILED(FAILED(hRes), "Seek on shared stream failed\n")

		    // verify the marshal format
		    hRes = VerifyOBJREFFormat(pStm, MSHLFLAGS_NOPING);
		    TEST_FAILED(FAILED(hRes), "VerifyOBJREFFormat failed\n")
		    OUTPUT ("   - VerifyOBJREFFormat OK.\n");
		}

		punk->Release();
		punk = NULL;
		OUTPUT("   - NoPingThread Release done\n");
	    }
	}

	// uninit OLE
	CoUninitialize();
    }

    if (pStm)
    {
	// release stream we created above
	pStm->Release();
    }

    OUTPUT ("   - NoPingThread Exit\n");
    npInfo->hr = hRes;
    SetEvent(npInfo->hEvent);
    return RetVal;
}


// ----------------------------------------------------------------------
//
//	test marshaling between apartments in the same process using
//	MSHLFLAGS_NORMAL, MSHLFLAGS_TABLEWEAK, and MSHLFLAGS_TABLESTRONG
//
// ----------------------------------------------------------------------
typedef struct tagCrossThreadCallInfo
{
    HANDLE  hEvent;
    IStream *pStm;
    DWORD   dwInitFlag;
    DWORD   dwThreadId;
    HRESULT hr;
} CrossThreadCallInfo;


DWORD _stdcall CrossThreadCalls(void *param);
DWORD _stdcall CrossThreadLoops(void *param);
DWORD _stdcall CrossThreadActivate(void *param);


BOOL TestCrossThread(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    ULONG	    ulRefCnt, i, j;
    IUnknown	    *punk[3] = {NULL, NULL, NULL};
    IUnknown	    *pUnk;
    ILoop   *pLocalLoop = NULL;
    CrossThreadCallInfo ctInfo;
    DWORD	    dwThrdId = 0;
    HANDLE	    hThrd;
    DWORD	    mshlflags[3] = {MSHLFLAGS_NORMAL,
				    MSHLFLAGS_TABLEWEAK,
				    MSHLFLAGS_TABLESTRONG};

    DWORD	    dwInitFlags[4] = {COINIT_APARTMENTTHREADED,
				      COINIT_APARTMENTTHREADED,
				      COINIT_MULTITHREADED,
				      COINIT_MULTITHREADED};


    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestCrossThread\n");

    // Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    for (j=0; j<4; j++)
    {
	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	// marshal an interface NORMAL, TABLEWEAK and TABLESTRONG
	// and unmarshal each in another apartment.

	for (i=0; i<3; i++)
	{
	    punk[i] = GetTestUnk();
	    TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnkCube failed\n")
	    VerifyObjRefCnt(punk[i], 1);

	    // Marshal the interface into the stream
	    hres = CoMarshalInterface(pStm, IID_ICube, punk[i],
				      0, 0, mshlflags[i]);

	    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	    OUTPUT ("   - CoMarshalInterface OK.\n");
	    VerifyRHRefCnt(punk[i], 1);
	}

	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	for (i=0; i<3; i++)
	{
	    hres = VerifyOBJREFFormat(pStm, mshlflags[i]);
	    TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	    OUTPUT ("   - VerifyOBJREFFormat OK.\n");
	}

	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")


	// create thread and wait for it to complete
	ctInfo.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);
	ctInfo.pStm	   = pStm;
	ctInfo.dwInitFlag  = dwInitFlags[j];
	ctInfo.dwThreadId  = GetCurrentThreadId();
	ctInfo.hr	   = S_OK;

	RunThread(&ctInfo, ctInfo.hEvent, CrossThreadCalls);
	CloseHandle(ctInfo.hEvent);


	// cleanup the leftover objects.
	for (i=0; i<3; i++)
	{
	    hres = CoDisconnectObject(punk[i], 0);
	    punk[i] = NULL;
	    TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	    OUTPUT ("   - CoDisconnectObject OK.\n");
	}
    }

// ----------------------------------------------------------------------
    // Now test out doing activation from different apartments.
    // create thread and wait for it to complete

    for (j=0; j<2; j++)
    {
	ctInfo.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);
	ctInfo.pStm	   = NULL;
	ctInfo.dwInitFlag  = dwInitFlags[j];
	ctInfo.dwThreadId  = GetCurrentThreadId();
	ctInfo.hr	   = S_OK;

	RunThread(&ctInfo, ctInfo.hEvent, CrossThreadActivate);
	CloseHandle(ctInfo.hEvent);

	// create an interface
	hres = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
				IID_ILoop, (void **)&pLocalLoop);
	TEST_FAILED(FAILED(hres), "CoCreateInstance Second failed\n")

	if (SUCCEEDED(hres))
	{
	    pLocalLoop->Release();
	}
    }


// ----------------------------------------------------------------------

    // Now test doing nested calls between apartments.
#if 0
    for (j=0; j<2; j++)
    {
	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	pUnk = GetTestUnk();
	TEST_FAILED_EXIT((pUnk == NULL), "new GetTestUnk failed\n")
	VerifyObjRefCnt(pUnk, 1);

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_ILoop, pUnk,
				  0, 0, MSHLFLAGS_NORMAL);

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(pUnk, 1);

	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")


	ctInfo.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);
	ctInfo.pStm	   = pStm;
	ctInfo.dwInitFlag  = dwInitFlags[j];
	ctInfo.dwThreadId  = GetCurrentThreadId();
	ctInfo.hr	   = S_OK;

	RunThread(&ctInfo, ctInfo.hEvent, CrossThreadLoops);
	CloseHandle(ctInfo.hEvent);

	pUnk->Release();
    }
#endif

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    for (i=0; i<3; i++)
    {
	if (punk[i] != NULL)
	{
	    ulRefCnt = punk[i]->Release();
	    TEST_FAILED(ulRefCnt != 0, "punk[i] RefCnt not zero\n");
	}
    }

    return TestResult(RetVal, "TestCrossThread");
}


// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing CROSSTHREAD calls.
//
// ----------------------------------------------------------------------
DWORD _stdcall CrossThreadCalls(void *param)
{
    BOOL	 RetVal	= TRUE;
    ICube	*pCube	= NULL;
    IOleWindow	*pIOW	= NULL;
    IAdviseSink *pIAS	= NULL;
    ULONG	      i = 0;

    // get the execution parameters
    CrossThreadCallInfo *ctInfo = (CrossThreadCallInfo *) param;
    OUTPUT ("   - CrossThreadCalls Start\n");

    // initialize COM
    HRESULT hRes = CoInitializeEx(NULL, ctInfo->dwInitFlag);
    TEST_FAILED(FAILED(hRes), "CrossThreadCalls CoInitializeEx failed\n")

    if (SUCCEEDED(hRes))
    {
	// unmarshal the interfaces
	for (i=0; i<3; i++)
	{
	    hRes = CoUnmarshalInterface(ctInfo->pStm, IID_ICube, (void **)&pCube);
	    TEST_FAILED(FAILED(hRes), "CrossThread CoUnmarshalInterface failed\n")
	    OUTPUT("   - CrossThread CoUnmarshalInterface done\n");

	    if (SUCCEEDED(hRes))
	    {
		// test a synchronous method call between apartments
		// (also checks the lid & tid)

		UUID	lidCaller;
		CoGetCurrentLogicalThreadId(&lidCaller);
		hRes = pCube->SimpleCall(GetCurrentProcessId(),
					 GetCurrentThreadId(),
					 lidCaller);
		TEST_FAILED(FAILED(hRes), "pCube->SimpleCall failed\n")
		OUTPUT("   - Synchronous call done\n");

		// test an input-sync method call between apartments
		hRes = pCube->QueryInterface(IID_IOleWindow, (void **)&pIOW);

		if (SUCCEEDED(hRes))
		{
		    HWND hWnd;
		    hRes = pIOW->GetWindow(&hWnd);

		    // input sync is only allowed between two apartment
		    // threaded apartments.
		    if (ctInfo->dwInitFlag == gInitFlag)
		    {
			TEST_FAILED(FAILED(hRes), "pIOW->GetWindow failed\n");
		    }
		    else
		    {
			TEST_FAILED(SUCCEEDED(hRes), "pIOW->GetWindow should have failed\n");
		    }

		    pIOW->Release();
		    OUTPUT("   - Input-Synchronous call done\n");
		}


		// test an async method call between apartments
		hRes = pCube->QueryInterface(IID_IAdviseSink, (void **)&pIAS);

		if (SUCCEEDED(hRes))
		{
		    // no return code to check
		    pIAS->OnViewChange(1,2);
		    pIAS->Release();
		    OUTPUT("   - ASynchronous call done\n");
		}

		// release the object
		pCube->Release();
		pCube = NULL;
		OUTPUT("   - CrossThread Calls and Release done\n");
	    }
	}

	// uninit OLE
	CoUninitialize();
    }

    OUTPUT ("   - CrossThreadCalls Exit\n");
    ctInfo->hr = hRes;

    // signal the other thread we are done.
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	PostThreadMessage(ctInfo->dwThreadId, WM_QUIT, 0, 0);
    }
    else
    {
	SetEvent(ctInfo->hEvent);
    }

    return hRes;
}


// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing CROSSTHREAD activation
//
// ----------------------------------------------------------------------
DWORD _stdcall CrossThreadActivate(void *param)
{
    BOOL	 RetVal	= TRUE;
    ILoop   *pLocalLoop = NULL;

    // get the execution parameters
    CrossThreadCallInfo *ctInfo = (CrossThreadCallInfo *) param;
    OUTPUT ("   - CrossThreadActivate Start\n");

    // initialize COM
    HRESULT hRes = CoInitializeEx(NULL, ctInfo->dwInitFlag);
    TEST_FAILED(FAILED(hRes), "CrossThreadActivate CoInitializeEx failed\n")

    if (SUCCEEDED(hRes))
    {
	// create an interface
	hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
				IID_ILoop, (void **)&pLocalLoop);
	TEST_FAILED(FAILED(hRes), "CoCreateInstance First failed\n")

	if (SUCCEEDED(hRes))
	{
	    pLocalLoop->Release();
	}

	// uninit OLE
	CoUninitialize();
    }

    OUTPUT ("   - CrossThreadActivate Exit\n");
    ctInfo->hr = hRes;

    // signal the other thread we are done.
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	PostThreadMessage(ctInfo->dwThreadId, WM_QUIT, 0, 0);
    }
    else
    {
	SetEvent(ctInfo->hEvent);
    }

    return hRes;
}








#if 0
// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing CROSSTHREAD calls.
//
// ----------------------------------------------------------------------
DWORD _stdcall CrossThreadLoops(void *param)
{
    BOOL	 RetVal	= TRUE;
    ILoop	*pLoop	= NULL;
    IUnknown	*punk	= NULL;
    ILoop	*pLoopLocal = NULL;

    // get the execution parameters
    CrossThreadCallInfo *ctInfo = (CrossThreadCallInfo *) param;
    OUTPUT ("   - CrossThreadLoops Start\n");

    // initialize COM
    HRESULT hRes = CoInitializeEx(NULL, ctInfo->dwInitFlag);
    TEST_FAILED(FAILED(hRes), "CrossThreadLoops CoInitializeEx failed\n")

    if (SUCCEEDED(hRes))
    {
	punk = GetTestUnk();
	punk->QueryInterface(IID_ILoop, (void **)&pLoopLocal);
	punk->Release();

	// unmarshal the interface
	hRes = CoUnmarshalInterface(ctInfo->pStm, IID_ILoop, (void **)&pLoop);
	TEST_FAILED(FAILED(hRes), "CrossThreadLoop CoUnmarshalInterface failed\n")
	OUTPUT("   - CrossThreadLoop CoUnmarshalInterface done\n");

	if (SUCCEEDED(hRes))
	{
	    // test nested synchronous method calls between apartments

	    hRes = pLoop->Init(pLoopLocal);
	    TEST_FAILED(FAILED(hRes), "pLoop->Init failed\n")

	    if (SUCCEEDED(hRes))
	    {
		hRes = pLoop->Loop(5);
		TEST_FAILED(FAILED(hRes), "pLoop->Loop failed\n")

		hRes = pLoop->Uninit();
		TEST_FAILED(FAILED(hRes), "pLoop->Uninit failed\n")
	    }

	    pLoop->Release();
	    pLoop = NULL;

	    OUTPUT("   - CrossThreadLoop Calls and Release done\n");
	}

	// uninit OLE
	CoUninitialize();
    }

    OUTPUT ("   - CrossThreadLoops Exit\n");
    ctInfo->hr = hRes;

    // signal the other thread we are done.
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	PostThreadMessage(ctInfo->dwThreadId, WM_QUIT, 0, 0);
    }
    else
    {
	SetEvent(ctInfo->hEvent);
    }

    return hRes;
}
#endif



// ----------------------------------------------------------------------
//
//  Test calling CoGetPSClsid and CoRegisterPSClsid
//
// ----------------------------------------------------------------------
BOOL TestPSClsid(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes;
    CLSID	    clsidOriginal, clsidNew;

    OUTPUT ("Starting TestPSClsid\n");

// ----------------------------------------------------------------------

    // get the PSClsid that is currently registered for this interface.

    hRes = CoGetPSClsid(IID_IViewObject, &clsidOriginal);
    TEST_FAILED(FAILED(hRes), "Failed 1st CoGetPSClsid\n");
    OUTPUT ("    - Done 1st CoGetPSClsid\n");

    // Set a new PSClsid for this interface for this process. Note that
    // if we have used the interface before, we will get an error back,
    // otherwise, this will succeed.

    hRes = CoRegisterPSClsid(IID_IViewObject, CLSID_Balls);
    TEST_FAILED(FAILED(hRes), "Failed 1st CoGRegisterPSClsid\n");
    OUTPUT ("    - Done 1st CoRegisterPSClsid\n");

    // now get the PSClsid that is registered for this interface. This
    // should match the value we just passed in.

    hRes = CoGetPSClsid(IID_IViewObject, &clsidNew);
    TEST_FAILED(FAILED(hRes), "Failed 2nd CoGetPSClsid\n");
    OUTPUT ("    - Done 2nd CoGetPSClsid\n");

    if (memcmp(&clsidNew, &CLSID_Balls, sizeof(CLSID)))
    {
	TEST_FAILED(TRUE, "Failed Compare of CLSIDs\n");
    }

    // now try to register it again. This should fail since it has
    // already been registered.

    hRes = CoRegisterPSClsid(IID_IViewObject, clsidOriginal);
    TEST_FAILED(FAILED(hRes), "Failed 2nd CoGRegisterPSClsid\n");
    OUTPUT ("    - Done 2nd CoRegisterPSClsid\n");

    // now get the PSClsid that is registered for this interface. This
    // should match the value we just passed in.

    hRes = CoGetPSClsid(IID_IViewObject, &clsidNew);
    TEST_FAILED(FAILED(hRes), "Failed 3rd CoGetPSClsid\n");
    OUTPUT ("    - Done 3rd CoGetPSClsid\n");

    if (memcmp(&clsidNew, &clsidOriginal, sizeof(CLSID)))
    {
	TEST_FAILED(TRUE, "Failed 2nd Compare of CLSIDs\n");
    }

// ----------------------------------------------------------------------

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    return TestResult(RetVal, "TestPSClsid");
}

// ----------------------------------------------------------------------
//
//  Test calling CoGetPSClsid for a LONG IID/PSCLSID pair.
//
// ----------------------------------------------------------------------
BOOL TestPSClsid2(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    CLSID	    clsidOriginal;

    OUTPUT ("Starting TestPSClsid2\n");

// ----------------------------------------------------------------------

    // get the PSClsid that is currently registered for this interface.
    hRes = CoGetPSClsid(IID_IViewObject, &clsidOriginal);
    TEST_FAILED(FAILED(hRes), "Failed 1st CoGetPSClsid\n");
    OUTPUT ("    - Done 1st CoGetPSClsid\n");

    if (!IsEqualGUID(clsidOriginal, CLSID_OLEPSFACTORY))
    {
	TEST_FAILED(FAILED(hRes), "CoGetPSClsid returned wrong value\n");
    }

// ----------------------------------------------------------------------

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    return TestResult(RetVal, "TestPSClsid2");
}



// ----------------------------------------------------------------------
//
//  TestGetIIDFromMI
//
// ----------------------------------------------------------------------
BOOL TestGetIIDFromMI(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    IUnknown	   *punkIn = NULL;
    IID 	    iid;

    OUTPUT ("Starting TestGetIIDFromMI\n");

// ----------------------------------------------------------------------

    ULARGE_INTEGER ulSeekEnd;
    LARGE_INTEGER lSeekStart;
    LISet32(lSeekStart, 0);

    IStream *pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

    punkIn = GetTestUnk();

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");

    // go back to begining
    hres = pStm->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    OUTPUT ("   - Seek Start OK\n");

#if 0	// BUGBUG: RICKHI
    // get the IID from the stream, and ensure it matches the IID we
    // marshaled. Also, ensure the stream is left where it was. This
    // is accomplished by calling CRMD on the stream.

    hres = CoGetIIDFromMarshaledInterface(pStm, &iid);
    TEST_FAILED(FAILED(hres), "CoGetIIDFromMarshaledInterface failed\n")
    OUTPUT ("   - CoGetIIDFromMarshaledInterface Done\n");

    if (!IsEqualIID(IID_IUnknown, iid))
    {
	TEST_FAILED(TRUE, "IID read does not match IID marshaled\n")
    }
#endif
    // release the marshaled interface
    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED(FAILED(hres), "CoReleaseMarshalData failed\n")
    OUTPUT ("   - CoReleaseMarshalData Done\n");

// ----------------------------------------------------------------------
Cleanup:

    if (punkIn)
    {
	punkIn->Release();
	punkIn = NULL;
    }

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    return TestResult(RetVal, "TestGetIIDFromMI");
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\common\advbnd.cxx ===
//+-------------------------------------------------------------------
//
//  Class:    CAdvBndCF
//
//  Synopsis: Class Factory for CAdvBnd
//
//  Interfaces:  IUnknown      - QueryInterface, AddRef, Release
//               IClassFactory - CreateInstance
//
//  History:  21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <advbnd.hxx>


const GUID CLSID_AdvBnd =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x48}};


//+-------------------------------------------------------------------
//
//  Member:	CAdvBndCF::CAdvBndCF()
//
//  Synopsis:	The constructor for CAdvBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::CAdvBndCF() : _cRefs(1), _pCF(NULL)
{
    return;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::~CAdvBndCF()
{
    if (_pCF)
    {
	_pCF->Release();
    }
    return;
}


//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) ||
	IsEqualIID(iid, IID_IClassFactory))
    {
	*ppv = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else
    {
        *ppv = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CAdvBndCF::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CAdvBndCF::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
    }

    return _cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------

STDMETHODIMP CAdvBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    Display(TEXT("CAdvBndCF::CreateInstance called\n"));

    HRESULT hresult;

    if (!_pCF)
    {
	// Load the class object for the class to aggregate.
	hresult = CoGetClassObject(CLSID_BasicBnd, CLSCTX_SERVER, NULL,
				   IID_IClassFactory, (void **) &_pCF);

	Win4Assert(SUCCEEDED(hresult)
	    && "CAdvBnd::CAdvBnd CoGetClassObject failed");

	if (FAILED(hresult))
	{
	    return hresult;
	}
    }

    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    CAdvBnd * lpcBB = new FAR CAdvBnd((IClassFactory *) _pCF);

    if (lpcBB == NULL)
    {
	return E_OUTOFMEMORY;
    }

    hresult = lpcBB->QueryInterface(iidInterface, ppv);

    lpcBB->Release();

    return hresult;
}

STDMETHODIMP CAdvBndCF::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}





//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::CAdvBnd()
//
//  Synopsis:	The constructor for CAdvBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::CAdvBnd(IClassFactory *pcfBase) : _xiunk(), _dwRegister(0), _cRefs(1)
{
    HRESULT hresult = pcfBase->CreateInstance((IUnknown *) this, IID_IUnknown,
	(void **) &_xiunk);

    GlobalRefs(TRUE);
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::~CAdvBnd()
{
    Display(TEXT("CAdvBndCF::~CAdvBnd called\n"));

    if (_dwRegister != 0)
    {
	// Get the running object table
	IRunningObjectTable *prot;

	HRESULT hresult = GetRunningObjectTable(0, &prot);

	Win4Assert(SUCCEEDED(hresult)
	    && "CAdvBnd::~CAdvBnd GetRunningObjectTable failed");

	hresult = prot->Revoke(_dwRegister);

	Win4Assert(SUCCEEDED(hresult)
	    && "CAdvBnd::~CAdvBnd Revoke failed");

	prot->Release();
    }

    GlobalRefs(FALSE);
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::QueryInterface
//
//  Returns:    SUCCESS_SUCCCESS
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::QueryInterface(REFIID iid, void ** ppunk)
{
    Display(TEXT("CAdvBnd::QueryInterface called\n"));

    if (IsEqualIID(iid, IID_IUnknown))
    {
	*ppunk = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else if ((IsEqualIID(iid, IID_IPersistFile)) ||
	     (IsEqualIID(iid, IID_IPersist)))
    {
	*ppunk = (IPersistFile *) this;
	AddRef();
	return S_OK;
    }

    return _xiunk->QueryInterface(iid, ppunk);
}

STDMETHODIMP_(ULONG) CAdvBnd::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CAdvBnd::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Load
//
//  Synopsis:   IPeristFile interface - needed 'cause we bind with
//              file moniker and BindToObject insists on calling this
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    Display(TEXT("CAdvBndCF::Load called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Load(lpszFileName, grfMode);

    pipfile->Release();

    if (FAILED(hresult))
    {
	// Make sure delegated too class liked what it got/
	// BUGBUG: Can't just forward hresults!
	return hresult;
    }

    // Create a file moniker. Cast to avoid const problem.
    IMoniker *pmk;
    hresult = CreateFileMoniker((LPOLESTR)lpszFileName, &pmk);

    Win4Assert(SUCCEEDED(hresult)
	&& "CAdvBnd::Load CreateFileMoniker failed");

    // Get the running object table
    IRunningObjectTable *prot;

    hresult = GetRunningObjectTable(0, &prot);

    Win4Assert(SUCCEEDED(hresult)
	&& "CAdvBnd::Load GetRunningObjectTable failed");

    // Register in the running object table
    IUnknown *punk;
    QueryInterface(IID_IUnknown, (void **) &punk);
    hresult = prot->Register(0, punk, pmk, &_dwRegister);

    Win4Assert(SUCCEEDED(hresult)
	&& "CAdvBnd::Load Register failed");

    // Set filetime to known value
    FILETIME filetime;
    memset(&filetime, 'B', sizeof(filetime));

    // Set time to some known value
    prot->NoteChangeTime(_dwRegister, &filetime);

    // Release uneeded objects
    pmk->Release();
    prot->Release();
    punk->Release();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Save
//
//  Synopsis:   IPeristFile interface - save
//              does little but here for commentry
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    Display(TEXT("CAdvBndCF::Save called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Save(lpszFileName, fRemember);

    pipfile->Release();

    return hresult;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::SaveCpmpleted
//		CAdvBnd::GetCurFile
//		CAdvBnd::IsDirty
//
//  Synopsis:   More IPeristFile interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::SaveCompleted(LPCOLESTR lpszFileName)
{
    Display(TEXT("CAdvBndCF::SaveCompleted called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->SaveCompleted(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::GetCurFile(LPOLESTR FAR *lpszFileName)
{
    Display(TEXT("CAdvBndCF::GetCurFile called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->GetCurFile(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::IsDirty()
{
    Display(TEXT("CAdvBndCF::IsDirty called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->IsDirty();

    pipfile->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//

STDMETHODIMP CAdvBnd::GetClassID(LPCLSID classid)
{
    Display(TEXT("CAdvBndCF::GetClassID called\n"));

    *classid = CLSID_AdvBnd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\tmarshal\tunk.h ===
#ifndef _TUNK_
#define _TUNK_

STDAPI CoGetCallerTID(DWORD *pTIDCaller);
STDAPI CoGetCurrentLogicalThreadId(GUID *pguid);

#include <icube.h>

class	CTestUnk : public IParseDisplayName, public IOleWindow,
		   public IAdviseSink
{
public:
    CTestUnk(void);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //	IParseDisplayName
    STDMETHODIMP ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
				  ULONG *pchEaten, LPMONIKER *ppmkOut);

    // IOleWinodw methods
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // IAdviseSink
    STDMETHOD_(void, OnDataChange)(FORMATETC *pFormatetc,
				   STGMEDIUM *pStgmed);
    STDMETHOD_(void, OnViewChange)(DWORD dwAspect,
				   LONG lindex);
    STDMETHOD_(void, OnRename)(IMoniker *pmk);
    STDMETHOD_(void, OnSave)();
    STDMETHOD_(void, OnClose)();

private:

    ~CTestUnk(void);

    ULONG   _cRefs;
};


// A new instance of this object gets created each time the caller
// does a QI for ICube on the CTestUnk object above (or on the ICube
// interface iteself). The reason for this is to test that the remoting
// layer supports this capability correctly.

class	CTestUnkCube : public ICube
{
public:
    CTestUnkCube(IUnknown *pUnkCtrl);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICube implementation
    STDMETHODIMP MoveCube(ULONG xPos, ULONG yPos);
    STDMETHODIMP GetCubePos(ULONG *xPos, ULONG *yPos);
    STDMETHODIMP Contains(IBalls *pIFDb);
    STDMETHODIMP SimpleCall(DWORD pid, DWORD tid, GUID lidCaller);
    STDMETHODIMP PrepForInputSyncCall(IUnknown *pUnkIn);
    STDMETHODIMP InputSyncCall();

private:

    ~CTestUnkCube(void);

    ULONG     _cRefs;
    IUnknown *_pUnkCtrl;
    IUnknown *_pUnkIn;
};


class CTestUnkCF : public IClassFactory
{
public:
    CTestUnkCF(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHOD(CreateInstance)(IUnknown	*punkOuter,
			      REFIID	riid,
			      void	**ppunkObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    ULONG    _cRefs;
};


class	CTestUnkMarshal : public IMarshal
{
public:
    CTestUnkMarshal(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IMarshal - IUnknown taken from derived classes
    STDMETHOD(GetUnmarshalClass)(REFIID riid, LPVOID pv, DWORD dwDestCtx,
			LPVOID pvDestCtx, DWORD mshlflags, LPCLSID pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, LPVOID pv, DWORD dwDestCtx,
			LPVOID pvDestCtx, DWORD mshlflags, LPDWORD pSize);
    STDMETHOD(MarshalInterface)(LPSTREAM pStm, REFIID riid, LPVOID pv,
			DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags);
    STDMETHOD(UnmarshalInterface)(LPSTREAM pStm, REFIID riid, LPVOID *ppv);
    STDMETHOD(ReleaseMarshalData)(LPSTREAM pStm);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

private:

    IMarshal *GetStdMarshal(void);
    ~CTestUnkMarshal(void);

    ULONG	_cRefs;
    IMarshal   *_pIM;
};

#endif	//  _TUNK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\client\tmarshal\tunk.cxx ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <tunk.h>


CTestUnk::CTestUnk(void) : _cRefs(1)
{
}

CTestUnk::~CTestUnk(void)
{
}


STDMETHODIMP CTestUnk::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hRslt = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IParseDisplayName))
    {
	*ppvObj = (void *)(IParseDisplayName *)this;
	AddRef();
    }
    else if (IsEqualIID(riid, IID_ICube))
    {
	*ppvObj = (void *) new CTestUnkCube((IUnknown *)(IParseDisplayName *)this);
	if (*ppvObj == NULL)
	{
	    hRslt = E_NOINTERFACE;
	}
    }
    else if (IsEqualIID(riid, IID_IOleWindow))
    {
	*ppvObj = (void *)(IOleWindow *)this;
	AddRef();
    }
    else if (IsEqualIID(riid, IID_IAdviseSink))
    {
	*ppvObj = (void *)(IAdviseSink *)this;
	AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hRslt = E_NOINTERFACE;
    }

    return  hRslt;
}



STDMETHODIMP_(ULONG) CTestUnk::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnk::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}


STDMETHODIMP CTestUnk::ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
					ULONG *pchEaten, LPMONIKER *ppmkOut)
{
    return  S_OK;
}

STDMETHODIMP CTestUnk::GetWindow(HWND *phwnd)
{
    *phwnd = NULL;
    return S_OK;
}

STDMETHODIMP CTestUnk::ContextSensitiveHelp(BOOL fEnterMode)
{
    return S_OK;
}

STDMETHODIMP_(void) CTestUnk::OnDataChange(FORMATETC *pFormatetc,
					   STGMEDIUM *pStgmed)
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnViewChange(DWORD dwAspect,
					   LONG lindex)
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnRename(IMoniker *pmk)
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnSave()
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnClose()
{
    return;
}



CTestUnkCube::CTestUnkCube(IUnknown *pUnkCtrl) :
    _cRefs(1),
    _pUnkCtrl(pUnkCtrl),
    _pUnkIn(NULL)
{
    _pUnkCtrl->AddRef();
}

CTestUnkCube::~CTestUnkCube(void)
{
    _pUnkCtrl->Release();
}


STDMETHODIMP CTestUnkCube::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    return  _pUnkCtrl->QueryInterface(riid, ppvObj);
}



STDMETHODIMP_(ULONG) CTestUnkCube::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnkCube::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}


// these methods dont really have to do anything, we are just testing that
// they are callable.

STDMETHODIMP CTestUnkCube::MoveCube(ULONG xPos, ULONG yPos)
{
    if (_cRefs > 0)
	return S_OK;

    return E_UNEXPECTED;
}

STDMETHODIMP CTestUnkCube::GetCubePos(ULONG *xPos, ULONG *yPos)
{
    if (_cRefs > 0)
	return S_OK;

    return E_UNEXPECTED;
}

STDMETHODIMP CTestUnkCube::Contains(IBalls *pIFDb)
{
    if (_cRefs > 0)
	return S_OK;

    return E_UNEXPECTED;
}

STDMETHODIMP CTestUnkCube::SimpleCall(DWORD pidCaller, DWORD tidCaller, GUID lidCaller)
{
    HRESULT hr = S_OK;

    GUID lid;
    HRESULT hr2 = CoGetCurrentLogicalThreadId(&lid);

    if (SUCCEEDED(hr2))
    {
	if (!IsEqualGUID(lid, lidCaller))
	{
	    // LIDs dont match, error
	    hr |= 0x80000001;
	}
    }
    else
    {
	return hr2;
    }

    DWORD tid;
    hr2 = CoGetCallerTID(&tid);

    if (SUCCEEDED(hr2))
    {
	if (pidCaller == GetCurrentProcessId())
	{
	    // if in same process, CoGetCallerTID should return S_OK
	    if (hr2 != S_OK)
	    {
		hr |= 0x80000002;
	    }
	}
	else
	{
	    // if in different process, CoGetCallerTID should return S_FALSE
	    if (hr2 != S_FALSE)
	    {
		hr |= 0x80000004;
	    }
	}
    }
    else
    {
	return hr2;
    }

    return hr;
}

STDMETHODIMP CTestUnkCube::PrepForInputSyncCall(IUnknown *pUnkIn)
{
    // just remember the input ptr

    _pUnkIn = pUnkIn;
    _pUnkIn->AddRef();

    return S_OK;
}

STDMETHODIMP CTestUnkCube::InputSyncCall()
{
    // just attempt to release an Interface Pointer inside an InputSync
    // method.

    if (_pUnkIn)
    {
	if (_pUnkIn->Release() != 0)
	    return  RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::CTestUnkCF, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
CTestUnkCF::CTestUnkCF()
{
    _cRefs = 1;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CTestUnkCF::QueryInterface(REFIID riid, void **ppUnk)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
	return S_OK;
    }

    *ppUnk = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CTestUnkCF::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnkCF::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CTestUnkCF::CreateInstance(IUnknown *punkOuter,
					       REFIID	riid,
					       void	**ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;
    *ppunkObject = NULL;	//  in case of failure

    // create an instance object.
    IUnknown *punk = (IUnknown *)(IParseDisplayName *) new CTestUnk();

    if (punk)
    {
	// get the interface the caller wants to use
	sc = punk->QueryInterface(riid, ppunkObject);

	// release our hold, since the QI got a hold for the client.
	punk->Release();
    }

    return  sc;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::LockServer, public
//
//  Synopsis:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CTestUnkCF::LockServer(BOOL fLock)
{
    return  S_OK;
}



CTestUnkMarshal::CTestUnkMarshal(void) : _cRefs(1), _pIM(NULL)
{
}

CTestUnkMarshal::~CTestUnkMarshal(void)
{
    if (_pIM)
    {
	_pIM->Release();
    }
}

STDMETHODIMP CTestUnkMarshal::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hRslt = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IMarshal))
    {
	*ppvObj = (void *)(IMarshal *)this;
	AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hRslt = E_NOINTERFACE;
    }

    return  hRslt;
}

STDMETHODIMP_(ULONG) CTestUnkMarshal::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CTestUnkMarshal::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}

STDMETHODIMP CTestUnkMarshal::GetUnmarshalClass(REFIID riid, LPVOID pv,
	DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPCLSID pClsid)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->GetUnmarshalClass(riid, pv, dwDestCtx, pvDestCtx,
				   (mshlflags | MSHLFLAGS_NOPING), pClsid);
}

STDMETHODIMP CTestUnkMarshal::GetMarshalSizeMax(REFIID riid, LPVOID pv,
	DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPDWORD pSize)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->GetMarshalSizeMax(riid, pv, dwDestCtx, pvDestCtx,
		   (mshlflags | MSHLFLAGS_NOPING), pSize);
}

STDMETHODIMP CTestUnkMarshal::MarshalInterface(LPSTREAM pStm, REFIID riid,
	LPVOID pv,  DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->MarshalInterface(pStm, riid, pv, dwDestCtx, pvDestCtx,
		   (mshlflags | MSHLFLAGS_NOPING));
}

STDMETHODIMP CTestUnkMarshal::UnmarshalInterface(LPSTREAM pStm, REFIID riid,
	LPVOID *ppv)
{
    return CoUnmarshalInterface(pStm, riid, ppv);
}

STDMETHODIMP CTestUnkMarshal::ReleaseMarshalData(LPSTREAM pStm)
{
    return CoReleaseMarshalData(pStm);
}

STDMETHODIMP CTestUnkMarshal::DisconnectObject(DWORD dwReserved)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->DisconnectObject(dwReserved);
}

IMarshal *CTestUnkMarshal::GetStdMarshal(void)
{
    if (_pIM == NULL)
    {
	HRESULT hr = CoGetStandardMarshal(IID_IUnknown, (IUnknown *)this, 0,
		    0, MSHLFLAGS_NOPING, &_pIM);
    }

    return _pIM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\common\ballscf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	ballscf.cxx
//
//  Contents:	test class factory object implementation
//
//  Classes:	CBallClassFactory
//
//  Functions:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <ballscf.hxx>	//  class definiton
#include    <cballs.hxx>	//  CBalls defines


const GUID CLSID_Balls =
    {0x0000013a,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::CBallClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

CBallClassFactory::CBallClassFactory(IUnknown *punkOuter) :
    _punkOuter(punkOuter)
{
    ENLIST_TRACKING(CBallClassFactory);
}


//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::~CBallClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

CBallClassFactory::~CBallClassFactory(void)
{
    //	automatic actions do the rest of the work
}


//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBallClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
    }
    else
    {
	if (_punkOuter)
	{
	    sc = _punkOuter->QueryInterface(riid, ppUnk);
	}
	else
	{
	    *ppUnk = NULL;
	    sc = E_NOINTERFACE;
	}
    }
    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBallClassFactory::CreateInstance(IUnknown *punkOuter,
					       REFIID	riid,
					       void	**ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    //	create a ball object.
    IUnknown *punk = (IUnknown *) new CBallCtrlUnk(punkOuter);

    if (punk)
    {
	//  get the interface the caller wants to use
	sc = punk->QueryInterface(riid, ppunkObject);

	//  release our hold on the ball, since the QI got a hold for
	//  the client.
	punk->Release();
    }

    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBallClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\common\actcf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	actcf.cxx
//
//  Contents:	object activation test class factory
//
//  Classes:	CActClassFactory
//
//  Functions:
//
//  History:	23-Nov-92   Ricksa	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma hdrstop
#include    <actcf.hxx>     //	CActClassFactory
#include    <cact.hxx>	    //	CTestAct



const GUID CLSID_TestSingleUse =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x50}};

const GUID CLSID_TestMultipleUse =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x51}};

const GUID CLSID_DistBind =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x55}};





CActClassFactory::CActClassFactory(REFCLSID rclsid, BOOL fServer)
    : _fServer(fServer), _clsid(rclsid), _cRefs(1), _cLocks(0)
{
    // Header does all the work
}

CActClassFactory::~CActClassFactory()
{
    // Default actions are enough
}


STDMETHODIMP CActClassFactory::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) ||
	IsEqualIID(iid, IID_IClassFactory))
    {
	*ppv = (IUnknown *) this;
	AddRef();
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CActClassFactory::AddRef(void)
{
    InterlockedIncrement(&_cRefs);

    if (!_fServer)
    {
	// This is not being used in a server so we want to bump the
	// reference count. In a server we use the lock count rather
	// than the reference count to tell whether we should go away.
	GlobalRefs(TRUE);
    }

    return _cRefs;
}

STDMETHODIMP_(ULONG) CActClassFactory::Release(void)
{
    BOOL fKeepObject = InterlockedDecrement(&_cRefs);

    if (!_fServer)
    {
	// This is not being used in a server so we want to bump the
	// reference count. In a server we use the lock count rather
	// than the reference count to tell whether we should go away.
	GlobalRefs(FALSE);
    }

    if (!fKeepObject)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

STDMETHODIMP CActClassFactory::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    if (pUnkOuter != NULL)
    {
	// Object does not support aggregation
	return E_NOINTERFACE;
    }

    CTestAct *ptballs = new CTestAct(_clsid);

    HRESULT hr = ptballs->QueryInterface(iidInterface, ppv);

    ptballs->Release();

    return hr;
}

STDMETHODIMP CActClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
	InterlockedIncrement(&_cLocks);

	GlobalRefs(TRUE);
    }
    else
    {
	InterlockedDecrement(&_cLocks);

	GlobalRefs(FALSE);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\common\bscbnd.cxx ===
//+-------------------------------------------------------------------
//
//  Class:    CBasicBndCF
//
//  Synopsis: Class Factory for CBasicBnd
//
//  Interfaces:  IUnknown      - QueryInterface, AddRef, Release
//               IClassFactory - CreateInstance
//
//  History:  21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <bscbnd.hxx>


const GUID CLSID_BasicBnd =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x49}};

const GUID CLSID_TestEmbed =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x47}};

ULONG	g_UseCount = 0;



//+-------------------------------------------------------------------
//
//  Member:     CBasicBndCF::CBasicBndCF()
//
//  Synopsis:   The constructor for CBAsicBnd. 
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBndCF::CBasicBndCF() : _cRefs(1)
{
    g_UseCount++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBndCF::~CBasicBndCF()
{
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) ||
	IsEqualIID(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBasicBndCF::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CBasicBndCF::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the 
//              actual class object
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::CreateInstance(IUnknown FAR* pUnkOuter,
	                                 REFIID iidInterface,
                                         void FAR* FAR* ppv)
{
    HRESULT hresult = S_OK;

    class CUnknownBasicBnd *pubb = new FAR CUnknownBasicBnd(pUnkOuter);

    if (pubb == NULL)
    {
	return E_OUTOFMEMORY;
    }

    //	Because when an aggregate is being requested, the controlling
    //	must be returned, no QI is necessary.
    if (pUnkOuter == NULL)
    {
	hresult = pubb->QueryInterface(iidInterface, ppv);

	pubb->Release();
    }
    else
    {
	*ppv = (void *) pubb;
    }

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Method:	CBasicBndCF::LockServer
//
//  Synopsis:	Who knows what this is for?
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}





//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::CBasicBnd()
//
//  Synopsis:   The constructor for CBAsicBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::CBasicBnd(IUnknown *punk)
    : _punk(punk), _pmkContainer(NULL)
{
    // Create storage for "contained" objects
    SCODE sc = StgCreateDocfile(NULL,
	STGM_DELETEONRELEASE|STGM_DFRALL|STGM_CREATE, 0, &_psStg1);

    Win4Assert((sc == S_OK) && "Create of first storage failed");

    sc = StgCreateDocfile(NULL,
	STGM_DELETEONRELEASE|STGM_DFRALL|STGM_CREATE, 0, &_psStg2);

    Win4Assert((sc == S_OK) && "Create of second storage failed");
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::~CBasicBnd()
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();
    }

    if (_psStg1)
    {
	_psStg1->Release();
    }

    if (_psStg2)
    {
	_psStg2->Release();
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::QueryInterface(REFIID iid, void **ppiuk)
{
    return _punk->QueryInterface(iid, ppiuk);
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBasicBnd::AddRef(void)
{
    return _punk->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Release
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBasicBnd::Release(void)
{
    return _punk->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Load
//
//  Synopsis:   IPeristFile interface - needed 'cause we bind with
//              file moniker and BindToObject insists on calling this
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    if (grfMode & ~(STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
    {
	// Test requires default bind storage request and caller
	// has set some other bits so we fail.
	return STG_E_INVALIDPARAMETER;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Save
//
//  Synopsis:   IPeristFile interface - save
//              does little but here for commentry
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::SaveCpmpleted
//              CBasicBnd::GetCurFile
//              CBasicBnd::IsDirty
//
//  Synopsis:   More IPeristFile interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::SaveCompleted(LPCOLESTR lpszFileName)
{
    return S_OK;
}

STDMETHODIMP CBasicBnd::GetCurFile(LPOLESTR FAR *lpszFileName)
{
    return S_OK;
}

STDMETHODIMP CBasicBnd::IsDirty()
{
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::GetClassID(LPCLSID classid)
{
    *classid = CLSID_BasicBnd;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Interface:	IOleObject
//
//  Synopsis:	IOleObject interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetClientSite(LPOLECLIENTSITE FAR* ppClientSite)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetHostNames(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObj)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Close(DWORD dwSaveOption)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();

    }

    _pmkContainer = pmk;

    pmk->AddRef();

    return S_OK;
}

STDMETHODIMP CBasicBnd::GetMoniker(
    DWORD dwAssign,
    DWORD dwWhichMoniker,
    LPMONIKER FAR* ppmk)
{
    if (_pmkContainer != NULL)
    {
	*ppmk = _pmkContainer;
	_pmkContainer->AddRef();
	return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP CBasicBnd::InitFromData(
    LPDATAOBJECT pDataObject,
    BOOL fCreation,
    DWORD dwReserved)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetClipboardData(
    DWORD dwReserved,
    LPDATAOBJECT FAR* ppDataObject)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::DoVerb(
   LONG iVerb,
   LPMSG lpmsg,
   LPOLECLIENTSITE pActiveSite,
   LONG reserved,
   HWND hwndParent,
   LPCRECT lprcPosRect)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::EnumVerbs(IEnumOLEVERB FAR* FAR* ppenumOleVerb)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Update(void)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::IsUpToDate(void)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetUserClassID(CLSID FAR* pClsid)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetUserType(DWORD dwFormOfType, LPOLESTR FAR* pszUserType)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Advise(
    IAdviseSink FAR* pAdvSink,
    DWORD FAR* pdwConnection)
{
    *pdwConnection = 0;
    return S_OK;
}

STDMETHODIMP CBasicBnd::Unadvise(DWORD dwConnection)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Interface:	IParseDisplayName
//
//  Synopsis:	IParseDisplayName interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::ParseDisplayName(
    LPBC pbc,
    LPOLESTR lpszDisplayName,
    ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    *pchEaten = olestrlen(lpszDisplayName);
    return CreateItemMoniker(OLESTR("\\"), lpszDisplayName, ppmkOut);
}

//+-------------------------------------------------------------------
//
//  Interface:	IOleContainer
//
//  Synopsis:	IOleContainer interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::EnumObjects(
    DWORD grfFlags,
    LPENUMUNKNOWN FAR* ppenumUnknown)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::LockContainer(BOOL fLock)
{
    return E_FAIL;
}

//+-------------------------------------------------------------------
//
//  Interface:	IOleItemContainer
//
//  Synopsis:	IOleItemContainer interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::GetObject(
    LPOLESTR lpszItem,
    DWORD dwSpeedNeeded,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID FAR* ppvObject)
{
    IStorage *psStorage;
    IOleObject *poo;
    IUnknown *punk;

    if (olestrcmp(lpszItem, OLESTR("1")) == 0)
    {
	psStorage = _psStg1;
    }
    else if (olestrcmp(lpszItem, OLESTR("2")) == 0)
    {
	psStorage = _psStg2;
    }
    else
    {
	return E_FAIL;
    }

    IOleClientSite * pocsObjCliSite;

    HRESULT hresult = QueryInterface(IID_IOleClientSite,
	(void **) &pocsObjCliSite);

    // Call OleCreate to create our embedded object
    hresult = OleCreate(
               CLSID_TestEmbed,         // Class ID of the object we are
                                        //   creating
               IID_IOleObject,          // Interface by which we want to talk
                                        //   to the object
               OLERENDER_NONE,          // We don't want to draw the object
                                        //   when it is not active
               NULL,                    // Used if we do draw the object when
                                        //   it is non-active
               pocsObjCliSite,          // IOleClientSite the server will use
               psStorage,               // IStorage the server will use
	       (void **) &poo);		// Pointer to the object

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject OlCreate Failed!\n");

    // Set the client site
    hresult = poo->SetClientSite(pocsObjCliSite);

    hresult = poo->QueryInterface(IID_IUnknown, (void **)&punk);

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject QI to IUnknown failed!\n");

    hresult = OleRun(punk);

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject OleRun!\n");

    punk->Release();

    LPRECT lprPosRect = (LPRECT) new RECT;

    hresult = poo->DoVerb(
		 OLEIVERB_SHOW,     // Verb we are invoking
		 NULL,		    // MSG that causes us to do this verb
		 pocsObjCliSite,    // Client site of this object
		 0,		    // Reserved - definitive value?
		 0,		    // hwndParent - ???
		 lprPosRect);	    // lprcPosRect - rectangle wrt hwndParent

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject DoVerb failed!\n");

    delete lprPosRect;

    pocsObjCliSite->Release();

    *ppvObject = (void *) poo;

    return hresult;
}

STDMETHODIMP CBasicBnd::GetObjectStorage(
    LPOLESTR lpszItem,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID FAR* ppvStorage)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::IsRunning(LPOLESTR lpszItem)
{
    return E_FAIL;
}

CUnknownBasicBnd::CUnknownBasicBnd(IUnknown *punk)
    : _pbasicbnd(NULL), _cRefs(1)
{
    if (punk == NULL)
    {
	punk = (IUnknown *) this;
    }

    // BUGBUG: No error checking!
    _pbasicbnd = new CBasicBnd(punk);
    g_UseCount++;
}

CUnknownBasicBnd::~CUnknownBasicBnd(void)
{
    g_UseCount--;
    delete _pbasicbnd;
}



//+-------------------------------------------------------------------
//
//  Member:	CUnknownBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CUnknownBasicBnd::QueryInterface(
    REFIID iid,
    void **ppiuk)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
	*ppiuk = (IUnknown *) this;
    }
    else if (IsEqualIID(iid, IID_IOleClientSite))
    {
	*ppiuk = (IOleClientSite *) _pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IPersistFile)
	|| IsEqualIID(iid, IID_IPersist))
    {
	*ppiuk = (IPersistFile *) _pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IOleObject))
    {
	*ppiuk = (IOleObject *) _pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IOleItemContainer))
    {
	*ppiuk = (IOleItemContainer *)_pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IOleContainer))
    {
	*ppiuk = (IOleContainer *)_pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
	*ppiuk = (IParseDisplayName *)_pbasicbnd;
    } 
    else
    {
        *ppiuk = NULL;
	return E_NOINTERFACE;
    }

    _pbasicbnd->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CUnknownBasicBnd::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CUnknownBasicBnd::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}



//+-------------------------------------------------------------------
//  Method:	CBasicBnd::SaveObject
//
//  Synopsis:   See spec 2.00.09 p107.  This object should be saved.
//
//  Returns:    Should always return S_OK.
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::SaveObject(void)
{
    // BUGBUG - NYI
    //   Returning S_OK tells OLE that we actually saved this object
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::GetContainer
//
//  Synopsis:   See spec 2.00.09 p108.  Return the container in which
//              this object is found.
//
//  Returns:    Should return S_OK.
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::GetContainer(LPOLECONTAINER FAR *ppContainer)
{
    return QueryInterface(IID_IOleContainer, (void **) ppContainer);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::ShowObject
//
//  Synopsis:   See spec 2.00.09 p109.  Server for this object is asking
//              us to display it.  Caller should not assume we have
//              actually worked, but we return S_OK either way.  Great!
//
//  Returns:    S_OK whether we work or not...
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::ShowObject(void)
{
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::OnShowWindow
//
//  Synopsis:   ???
//
//  Parameters: [fShow] -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::OnShowWindow(BOOL fShow)
{
    return(S_OK);
}



//+-------------------------------------------------------------------
//  Method:	CBasicBnd::RequestNewObjectLayout
//
//  Synopsis:   ???
//
//  Parameters: [fShow] -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::RequestNewObjectLayout(void)
{
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\balls\common\cact.cxx ===
//+-------------------------------------------------------------------
//
//  File:	cact.cxx
//
//  Contents:	object activation test class
//
//  Classes:	CActTest
//
//  Functions:
//
//  History:	23-Nov-92   Ricksa	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma hdrstop
#include    <cact.hxx>	    //	CTestAct

// We need a semaphore to synchronize loads and releases.
CMutexSem mxsLoadRelease;

SAFE_INTERFACE_PTR(XIStream, IStream)

#define XPOS OLESTR("XPOS")
#define YPOS OLESTR("YPOS")


HRESULT ReadPos(IStorage *pstg, LPOLESTR pwszStream, ULONG *pulPos)
{
    HRESULT hr;

    BEGIN_BLOCK

	XIStream xstrm;

	// Read the streams for xpos and ypos
	hr = pstg->OpenStream(pwszStream, NULL,
	    STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, &xstrm);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	ULONG cb;

	hr = xstrm->Read(pulPos, sizeof(*pulPos), &cb);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	hr = ResultFromScode(S_OK);

    END_BLOCK

    return hr;
}

HRESULT WritePos(IStorage *pstg, LPOLESTR pwszStream, ULONG ulPos)
{
    HRESULT hr;

    BEGIN_BLOCK

	XIStream xstrm;

	// Read the streams for xpos and ypos
	hr = pstg->CreateStream(pwszStream,
	    STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE, NULL, NULL,
		&xstrm);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}


	ULONG cb;

	hr = xstrm->Write(&ulPos, sizeof(ulPos), &cb);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	hr = ResultFromScode(S_OK);

    END_BLOCK

    return hr;
}

CTestAct::CTestAct(REFCLSID rclsid)
    : _rclsid(rclsid), _fDirty(FALSE), _xPos(0), _yPos(0),
	_fSaveInprogress(FALSE), _pstg(NULL), _dwRegister(0), _cRefs(1)
{
    // Use as a flag for whether a file name has been assigned
    _awszCurFile[0] = 0;

    GlobalRefs(TRUE);
}

CTestAct::~CTestAct(void)
{
    if (_pstg != NULL)
    {
	// Release the storage because we are done with it
	ULONG ulCnt = _pstg->Release();

#if 0
	//  this test is not valid when running stress
	if (ulCnt != 0)
	{
	    DebugBreak();
	}
#endif

    }

    if (_dwRegister)
    {
	IRunningObjectTable *prot;
	GetRunningObjectTable(NULL, &prot);
	prot->Revoke(_dwRegister);
	prot->Release();
    }

    GlobalRefs(FALSE);
}

STDMETHODIMP CTestAct::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = ResultFromScode(S_OK);

    // We support IUnknown, IPersistFile and IBalls
    if (IsEqualIID(iid, IID_IUnknown))
    {
	*ppv = (IBalls *) this;
    }
    else if (IsEqualIID(iid, IID_IPersistFile))
    {
	*ppv = (IPersistFile *) this;
    }
    else if (IsEqualIID(iid, IID_IPersistStorage))
    {
	*ppv = (IPersistStorage *) this;
    }
    else if (IsEqualIID(iid, IID_IBalls))
    {
	*ppv = (IBalls *) this;
    }
    else
    {
	*ppv = NULL;
	hr = ResultFromScode(E_NOINTERFACE);
    }

    if (SUCCEEDED(hr))
    {
	AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CTestAct::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CTestAct::Release(void)
{
    CLock lck(mxsLoadRelease);

    if (InterlockedDecrement(&_cRefs) == 0)
    {
	delete this;
	return	0;
    }

    return _cRefs;
}

STDMETHODIMP CTestAct::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = _rclsid;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestAct::IsDirty()
{
    return (_fDirty) ? ResultFromScode(S_OK) : ResultFromScode(S_FALSE);
}

STDMETHODIMP CTestAct::Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    CLock lck(mxsLoadRelease);

    HRESULT hr;

    BEGIN_BLOCK

	hr = StgOpenStorage(lpszFileName, NULL,
	    STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, NULL, &_pstg);

	if (FAILED(hr))
	{
#if 0
	    //	this test is not valid when running stress
	    if (hr == STG_E_LOCKVIOLATION)
	    {
		DebugBreak();
	    }
#endif

	    EXIT_BLOCK;
	}

	// Get the saved xposition
	hr = GetData();

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	// Since everything went Ok save the file name
	olestrcpy(_awszCurFile, lpszFileName);

	// Create a file moniker for the object.
	// Cast to non-constant string.
	IMoniker *pmk;
	CreateFileMoniker((LPOLESTR)lpszFileName, &pmk);

	// Register it in the running object table.
	IRunningObjectTable *prot;
	GetRunningObjectTable(NULL, &prot);
	prot->Register(NULL, (IPersistFile *) this, pmk, &_dwRegister);

	// Release the temporary objects
	pmk->Release();
	prot->Release();

    END_BLOCK

    return hr;
}

STDMETHODIMP CTestAct::Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    HRESULT hr;

    BEGIN_BLOCK

	IStorage *pstgNew;

	// Save the data
	if (olestrcmp(lpszFileName, _awszCurFile) == 0)
	{
	    pstgNew = _pstg;
	    _fDirty = FALSE;
	}
	else
	{
	    hr = StgCreateDocfile(lpszFileName,
		STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
		    NULL, &pstgNew);
	}

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	WriteClassStg(pstgNew, _rclsid);

	hr = SaveData(pstgNew);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	if (fRemember)
	{
	    // Save the file name
	    olestrcpy(_awszCurFile, lpszFileName);


	    // Replace the storage
	    if (_pstg && pstgNew != _pstg)
	    {
		_pstg->Release();
	    }
	    _pstg = pstgNew;

	    _fDirty = FALSE;
	}
	else
	{
	    pstgNew->Release();
	}

	_fSaveInprogress = TRUE;

	hr = ResultFromScode(S_OK);

    END_BLOCK;

    return hr;
}

STDMETHODIMP CTestAct::SaveCompleted(LPCOLESTR lpszFileName)
{
    _fSaveInprogress = FALSE;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestAct::GetCurFile(LPOLESTR FAR *lpszFileName)
{
    // Allocate a buf