       break;

			case 'p' :  // NamedPipe mode
			case 'P' :
                switch(*(s+2)) {
                    case 'm':
                    case 'M':
				        PipeType = PIPE_TYPE_MESSAGE;
				        PipeMode = PIPE_READMODE_MESSAGE;
                        break;

                    case 's':
                    case 'S':
				        PipeType = PIPE_TYPE_BYTE;
				        PipeMode = PIPE_READMODE_BYTE;
                        break;

                    default:
                        doingok = FALSE;
                }
				break;

			case 'r' : // Send size
			case 'R' :
				RecvSize = (USHORT)atoi(s+2);
				break;

			case 's' : // Send size
			case 'S' :
				SendSize = (USHORT)atoi(s+2);
				break;

			case 't' : // Test Command
			case 'T' :
				TestCmd =(UCHAR) *(s+2);
				switch(TestCmd){
				    case 't': TestCmd = 'T'; break;
				    case 'u':
				    case 'U': TestCmd = 'U'; break;
				    case 'P':
				    case 'T':
					     break;

				    default :
					printf("incorrect test command\n");
				        Usage(argv[0]);
				        pstatus = -1L;
				}
				break;

			case 'h' : // Server Name or host IP address
			case 'H' :
    			ServerName = (PCHAR)malloc(SRVNAME_LEN);
				strcpy(ServerName,(PCHAR)(s+2));

				// if XNS:SPX or IPX then get Node Address
                if ((IPCType == SCXNS)|| (IPCType == SCIPX)){
                    RtlCopyMemory( Remote_Node_Number,
				                   get_node_number(ServerName),
					               6);

                    if (Remote_Node_Number[0] == 'X') {
                        printf("incorrect node number: ");
                        printf("e.g. /h:112233445566 \n");
				        Usage(argv[0]);
				        pstatus = -1L;
                    }
                }
				break;

			case 'x' : // Xport Type
			case 'X' :
				strncpy(Xport, (PUCHAR) (s+2), 8);
                if (!_stricmp(Xport,NamePipe)) {
                    IPCType = NP;
                    break;
                }
                if (!_stricmp(Xport,NetBIOS)) {
                    IPCType = NB;
                    break;
                }
                if (!_stricmp(Xport,SocketXNS)) {
                    IPCType = SCXNS;
				    AddrFly = AF_NS;
                    break;
                }
                if (!_stricmp(Xport,SocketTCP)) {
                    IPCType = SCTCP;
				    AddrFly = AF_INET;
                    break;
                }
                if (!_stricmp(Xport,UDP)) {
                    IPCType = SCUDP;
				    AddrFly = AF_INET;
                    break;
                }
                if (!_stricmp(Xport,IPX)) {
                    IPCType = SCIPX;
				    AddrFly = AF_NS;
                    break;
                }
                if (!_stricmp(Xport,DGNetBIOS)) {
                    IPCType = DGNB;
                    break;
                }
                // bad choice of Xport
                doingok = FALSE;
				break;

			default :
                doingok = FALSE;
             }
		}
		else {
            doingok = FALSE;
		}
	}

        if (!doingok) {
	    Usage(argv[0]);
	    pstatus = -1L;
	}
        else {  // if successful then
            if ((IPCType == SCXNS) || (IPCType == SCIPX)) {
	        // make server name a 10 byte address
                RtlCopyMemory(ServerName,Remote_Node_Number,6);
                RtlCopyMemory(ServerName+6,Remote_Net_Number,4);
            }

            if (((IPCType != NB) && (IPCType != NP) && (IPCType != DGNB)) &&
	        (ServerName == NULL)) {
                printf("Please enter Server Address \n");
	        pstatus = -1L;
            }
        }

	return(pstatus);
}

/************************************************************************/
VOID Usage(char * PrgName)
{

	fprintf(stderr, "Usage: %s [/c: ] [/h:] [/s:] [/r:] [/b:] [/l:]\n",PrgName);
	fprintf(stderr, "       Opt     Default        Defines\n");
	fprintf(stderr, "       ===     =======        =======\n");
	fprintf(stderr, "       /c:       1            Number of clients\n");
	fprintf(stderr, "       /h:       NULL         SrvName/HostIPaddr.\n");
	fprintf(stderr, "          		       /Node Number for XNS\n");
	fprintf(stderr, "       /I:       1000         Number of Iterations\n");
	fprintf(stderr, "       /ns:      1            Number of Sends\n");
	fprintf(stderr, "       /nr:      1            Number of Receives\n");
	fprintf(stderr, "       /r:       32           Receive size\n");
	fprintf(stderr, "       /s:       32           Send size\n");
	fprintf(stderr, "       /t:       NULL         Special Test cmd,U,T\n");
	fprintf(stderr, "       /x:       Nmp          Xport(IPC)type\n");
	fprintf(stderr, "       	    	       Nmp/NetB/SockTCP/\n");
	fprintf(stderr, "       	    	       SockXNS/UDP/IPX/DGNetB\n");
	fprintf(stderr, "   For NNamedPipe:			\n");
	fprintf(stderr, "       /p:       m            Nmp : Pipe Type m/s\n");
	fprintf(stderr, "   For NetBIOS:			\n");
	fprintf(stderr, "       /b:       0            NetB: lana base\n");
	fprintf(stderr, "       /l:       1            NetB: lana count\n");
	fprintf(stderr, "       /m:       1            machine number\n");
	fprintf(stderr, "   For XNS:			\n");
	fprintf(stderr, "       /a:       1            Net Number for XNS\n");
}

/************************************************************************/

/*++
    This routine sets up all the function pointers based on Xport type
--*/

VOID
Setup_Function_Pointers()
{

     // I could do real OOP here and just set up one pointer to all functions
    // based on Xport type take the action
    switch(IPCType) {
        case NP:
	        IPC_Initialize	           = NMP_Initialize;
    	    IPC_PerClientInit	       = NMP_PerClientInit;	
    	    IPC_Connect_To_Server      = NMP_Connect_To_Server;	
    	    IPC_Disconnect_From_Server = NMP_Disconnect_From_Server;	
    	    IPC_Cleanup		           = NMP_Cleanup;
    	    IPC_Allocate_Memory	       = NMP_Allocate_Memory;
    	    IPC_DoHandshake        	   = NMP_DoHandshake;
    	    IPC_ReadFromIPC	           = NMP_ReadFromIPC;
    	    IPC_WriteToIPC	           = NMP_WriteToIPC;
    	    IPC_XactIO		           = NMP_XactIO;
    	    IPC_Deallocate_Memory      = NMP_Deallocate_Memory;
    	    IPC_ThreadCleanUp	       = NMP_ThreadCleanUp;
            break;
        case NB:
    	    IPC_Initialize	           = NB_Initialize;
    	    IPC_PerClientInit	       = NB_PerClientInit;	
    	    IPC_Cleanup		           = NB_Cleanup;
    	    IPC_Connect_To_Server      = NB_Connect_To_Server;	
    	    IPC_Disconnect_From_Server = NB_Disconnect_From_Server;	
    	    IPC_Allocate_Memory	       = NB_Allocate_Memory;
    	    IPC_DoHandshake	           = NB_DoHandshake;
    	    IPC_ReadFromIPC	           = NB_ReadFromIPC;
    	    IPC_WriteToIPC	           = NB_WriteToIPC;
    	    IPC_XactIO		           = NB_XactIO;
    	    IPC_Deallocate_Memory      = NB_Deallocate_Memory;
    	    IPC_ThreadCleanUp	       = NB_ThreadCleanUp;
	        break;

        case SCTCP:
    	    IPC_Initialize	           = SCTCP_Initialize;
    	    IPC_PerClientInit	       = SCTCP_PerClientInit;	
    	    IPC_Cleanup		           = SCTCP_Cleanup;
    	    IPC_Connect_To_Server      = SCTCP_Connect_To_Server;	
    	    IPC_Disconnect_From_Server = SCTCP_Disconnect_From_Server;	
    	    IPC_Allocate_Memory	       = SCTCP_Allocate_Memory;
    	    IPC_DoHandshake	           = SCTCP_DoHandshake;
    	    IPC_ReadFromIPC	           = SCTCP_ReadFromIPC;
    	    IPC_WriteToIPC	           = SCTCP_WriteToIPC;
    	    IPC_XactIO		           = SCTCP_XactIO;
    	    IPC_Deallocate_Memory      = SCTCP_Deallocate_Memory;
    	    IPC_ThreadCleanUp	       = SCTCP_ThreadCleanUp;
    	    break;

        case SCXNS:
    	    IPC_Initialize	           = SCXNS_Initialize;
    	    IPC_PerClientInit	       = SCXNS_PerClientInit;	
    	    IPC_Connect_To_Server      = SCXNS_Connect_To_Server;	
    	    IPC_Disconnect_From_Server = SCXNS_Disconnect_From_Server;	
    	    IPC_Cleanup		           = SCXNS_Cleanup;
    	    IPC_Allocate_Memory	       = SCXNS_Allocate_Memory;
    	    IPC_DoHandshake	           = SCXNS_DoHandshake;
    	    IPC_ReadFromIPC	           = SCXNS_ReadFromIPC;
    	    IPC_WriteToIPC	           = SCXNS_WriteToIPC;
    	    IPC_XactIO	         	   = SCXNS_XactIO;
    	    IPC_Deallocate_Memory      = SCXNS_Deallocate_Memory;
    	    IPC_ThreadCleanUp	       = SCXNS_ThreadCleanUp;
	        break;

        case SCUDP:
    	    IPC_Initialize	           = SCUDP_Initialize;
    	    IPC_PerClientInit	       = SCUDP_PerClientInit;	
    	    IPC_Connect_To_Server      = SCUDP_Connect_To_Server;	
    	    IPC_Disconnect_From_Server = SCUDP_Disconnect_From_Server;	
    	    IPC_Cleanup		           = SCUDP_Cleanup;
    	    IPC_Allocate_Memory	       = SCUDP_Allocate_Memory;
    	    IPC_DoHandshake	           = SCUDP_DoHandshake;
    	    IPC_ReadFromIPC	           = SCUDP_ReadFromIPC;
	        IPC_WriteToIPC	           = SCUDP_WriteToIPC;
    	    IPC_Deallocate_Memory      = SCUDP_Deallocate_Memory;
    	    IPC_ThreadCleanUp	       = SCUDP_ThreadCleanUp;
            break;

        case SCIPX:
    	    IPC_Initialize	           = SCIPX_Initialize;
    	    IPC_PerClientInit	       = SCIPX_PerClientInit;	
    	    IPC_PerClientInit	       = SCIPX_PerClientInit;	
    	    IPC_Connect_To_Server      = SCIPX_Connect_To_Server;	
    	    IPC_Disconnect_From_Server = SCIPX_Disconnect_From_Server;	
    	    IPC_Cleanup		           = SCIPX_Cleanup;
    	    IPC_Allocate_Memory	       = SCIPX_Allocate_Memory;
            IPC_DoHandshake	           = SCIPX_DoHandshake;
    	    IPC_ReadFromIPC	           = SCIPX_ReadFromIPC;
	        IPC_WriteToIPC	           = SCIPX_WriteToIPC;
    	    IPC_Deallocate_Memory      = SCIPX_Deallocate_Memory;
    	    IPC_ThreadCleanUp	       = SCIPX_ThreadCleanUp;
            break;

        case DGNB:
    	    IPC_Initialize	           = DGNB_Initialize;
    	    IPC_PerClientInit	       = DGNB_PerClientInit;	
    	    IPC_Cleanup		           = DGNB_Cleanup;
    	    IPC_Connect_To_Server      = DGNB_Connect_To_Server;	
    	    IPC_Disconnect_From_Server = DGNB_Disconnect_From_Server;	
    	    IPC_Allocate_Memory	       = DGNB_Allocate_Memory;
    	    IPC_DoHandshake	           = DGNB_DoHandshake;
    	    IPC_ReadFromIPC	           = DGNB_ReadFromIPC;
    	    IPC_WriteToIPC	           = DGNB_WriteToIPC;
    	    IPC_XactIO		           = DGNB_XactIO;
    	    IPC_Deallocate_Memory      = DGNB_Deallocate_Memory;
    	    IPC_ThreadCleanUp	       = DGNB_ThreadCleanUp;
	        break;

        default :
            // problem here
            printf("Incorrect Xport selection\n");
    }
}
/************************************************************************/

/*++
    This routine makes the main thread wait for all the client threads to
    exit.
--*/

NTSTATUS
Wait_For_Client_Threads(VOID)

{

    NTSTATUS 		wstatus;
    // LARGE_INTEGER 	MTimeout;
    DWORD           MTimeout;

    // printf("Main thread waiting for Client threads ");
    printf("..Wait");

    // MTimeout.LowPart   = 0xFFFFFFFF;
    // MTimeout.HighPart  = 0x7FFFFFFF; // -1L DIDN't work
    MTimeout = INFINITE;

    wstatus = WaitForMultipleObjectsEx( NClients,
		                                Threads,
		                                TRUE,
		                                MTimeout,     // Default timeout
                                        TRUE);        // Alertable

    printf("..Over..Results:\n");

    if (!NT_SUCCESS(wstatus)) {
       printf ("Failed on wait err=%lx\n",wstatus);
    }

    return wstatus;
}

/************************************************************************/

VOID
Cleanup(VOID)
{
    USHORT		Cindex     = 0; // client index
    NTSTATUS	exitstatus = 0;
    NTSTATUS	cstatus;


    for (Cindex = 0; Cindex < NClients; Cindex++) {
	    // terminate the thread
        cstatus = TerminateThread(Clients[Cindex].c_hThHandle, exitstatus);
/*
        if (!NT_SUCCESS(cstatus)) {
              printf("Failed to terminate thread no:%d err=%lx\n",
	   Cindex,cstatus);
        }
*/
    }
    // printf("Terminated All Threads\n");
}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\postmsg\server\server.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    server.c

Abstract:

    Server side of post message test.  Note, this guy is a hidden
    win32 app.  The client controls it via PostMessage.  It's ugly.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:
--*/

#include <rpcperf.h>
#include <pmsgtest.h>

HANDLE hRequestEvent;
HANDLE hReplyEvent;
HANDLE hWorkerEvent;
HANDLE hWorkerThread;
BOOL   fShutdown = FALSE;
LONG   lIterations;
LONG   lTestCase;
BOOL   fMsgMO = 0;

BOOL APIENTRY InitInstance(HINSTANCE, INT);
LRESULT APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);

DWORD WINAPI Worker (LPVOID);

int APIENTRY WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    ULONG cCount = 1;
    ULONG status;
    int fStop;
    MSG msg;

    UNREFERENCED_PARAMETER( lpCmdLine );

    if (hPrevInstance)
        {
        return FALSE;
        }

    if (!InitInstance(hInstance, nCmdShow))
        return FALSE;

    fStop = 0;
    while (!fStop)
        {
        if (fMsgMO)
            {
            status = MsgWaitForMultipleObjects(cCount,
                                               &hRequestEvent,
                                               FALSE,
                                               2000,
                                               QS_ALLINPUT);
            if (status == WAIT_OBJECT_0)
                {

                if (lTestCase == 11)
                    SetEvent(hWorkerEvent);
                else
                    SetEvent(hReplyEvent);

                continue;

                }
            else if (status == WAIT_OBJECT_0 + 1)
                {
                // Fall through and do a GetMessage and DispatchMessage.
                }
            else
                {
                *(long *)status = 10;  //GPF on error.
                }
            }

        if (GetMessage(&msg, NULL, 0, 0) == FALSE)
            {
            break;
            }

        DispatchMessage(&msg);
        }
    return (int) msg.wParam;
}

BOOL APIENTRY InitInstance( HINSTANCE hInstance, INT nCmdShow )
{
    HWND     hWnd;
    WNDCLASS wc;
    DWORD    dwThreadId;

    wc.style = 0; //CS_HREDRAW | CS_VREDRAW;        // redraw if size changes
    wc.lpfnWndProc = MainWndProc;                   // points to window proc.
    wc.cbClsExtra = 0;                              // no extra class memory
    wc.cbWndExtra = 0;                              //  no extra window memory
    wc.hInstance = hInstance;                       // handle of instance
    wc.hIcon = LoadIcon(NULL,IDI_APPLICATION);      // predefined app. icon
    wc.hCursor = LoadCursor(NULL,IDC_ARROW);        // predefined arrow
    wc.hbrBackground = GetStockObject(WHITE_BRUSH); // white background brush
    wc.lpszMenuName =  0; //"MainMenu";             // name of menu resource
    wc.lpszClassName = CLASS;                       // name of window class

    if (RegisterClass(&wc) == 0)
        return !GetLastError();

    hWnd = CreateWindow(
                        CLASS,
                        TITLE,
                        0,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        hInstance,
                        NULL
                        );

    if (!hWnd) {
        return !GetLastError();
        }

    hRequestEvent = CreateEvent(0,
                                FALSE,
                                FALSE,
                                REQUEST_EVENT);
    if (!hRequestEvent) return FALSE;

    hReplyEvent = CreateEvent(0,
                              FALSE,
                              FALSE,
                              REPLY_EVENT);
    if (!hReplyEvent) return FALSE;

    hWorkerEvent = CreateEvent(0,
                               FALSE,
                               FALSE,
                               WORKER_EVENT);
    if (!hWorkerEvent) return FALSE;

    hWorkerThread = CreateThread(0,
                                 0,
                                 Worker,
                                 0,
                                 0,
                                 &dwThreadId
                                 );
    if (!hWorkerThread) return FALSE;

    return TRUE;
}


LRESULT APIENTRY MainWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

    switch(message)
        {
        case WM_DESTROY:
            CloseHandle(hReplyEvent);
            fShutdown = TRUE;
            SetEvent(hWorkerEvent);
            CloseHandle(hWorkerThread);
            CloseHandle(hWorkerEvent);
            CloseHandle(hReplyEvent);
            CloseHandle(hRequestEvent);
            PostQuitMessage(0);
            break;

        case MSG_PERF_MESSAGE:
            {
            switch(wParam)
                {
                case 3:
                case 9:
                case 11:
                    fMsgMO = TRUE;
                    // Fall through
                case 1:
                case 5:
                case 7:

                    lIterations = (long)lParam;
                    lTestCase   = (long)wParam;
                    SetEvent(hWorkerEvent);

                    // Worker now completes required test and tells the
                    // client when finished.

                    break;

                case 4:
                    fMsgMO = TRUE;
                    // Fall through
                case 2:
                    if (lParam == 0)
                        {
                        // Client sends many messages (queues them up),
                        // server must signal when the last message arrives.
                        SetEvent(hReplyEvent);
                        }
                    break;

                case 6:   // send message
                    return 69;

                case 10:
                    fMsgMO = TRUE;
                    // Fall through
                case 8:
                    SetEvent(hReplyEvent);
                    break;

                case 12:
                    fMsgMO = TRUE;

                default:
                    break;
                }
            }

            case MSG_PERF_MESSAGE2:
            {

                // lParam is the number of iterations left
                // wParam the test case.

                if ( (lParam == 1)
                    || (wParam == 7)
                    || (wParam == 9) )
                    {
                    // Finished all the iterations, or we are running
                    // the force context-switch version. Let the worker know.

                    SetEvent(hWorkerEvent);
                    }

                break;
            }
            case WM_COPYDATA:
            {
            COPYDATASTRUCT *pData = (COPYDATASTRUCT *)lParam;
            return TRUE;
            }
        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
        }

    return TRUE;
}

DWORD WINAPI Worker (LPVOID pArg)
{
    LONG i;
    HWND hWnd = FindWindow(CLASS, TITLE);
    UNREFERENCED_PARAMETER(pArg);

    WaitForSingleObject(hWorkerEvent, INFINITE);
    if (fShutdown) return 0;

    if (lTestCase == 5)
        {
        // SendMessage test case.
        
        for(i = lIterations; i >= 0; i--)
            SendMessage(hWnd, MSG_PERF_MESSAGE2, lTestCase, i);

        goto worker_done;
        }

    if (lTestCase == 11)
        {
        // SetEvent/MsgWaitForMultipleObjects

        for(i = lIterations; i; i--)
            {
            SetEvent(hRequestEvent);
            WaitForSingleObject(hWorkerEvent, INFINITE);
            }
        goto worker_done;
        }

    for (i = lIterations; i; i--)
        {
        // One of the PostMessage test cases.

        PostMessage(hWnd, MSG_PERF_MESSAGE2, lTestCase, i);

        if (lTestCase > 4)
            {
            // Forced context switch version, wait for server
            // to process the last message.

            WaitForSingleObject(hWorkerEvent, INFINITE);
            }
        }

    if (lTestCase <= 4)
        {
        // Wait for the server to finish processing the queued-up messages.
        WaitForSingleObject(hWorkerEvent, INFINITE);
        }

worker_done:
    SetEvent(hReplyEvent);  // Tell the client that we finished this
                            // in process test.
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\client\client.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       client.h
//
//--------------------------------------------------------------------------

#define SRVNAME_LEN	16
#define CLIENT		1


/************************************************************************/
// Local function prototypes
/************************************************************************/

VOID
Usage(
    IN PSZ PrgName
    );

VOID
Setup_Function_Pointers(
);

NTSTATUS
Wait_For_Client_Threads(
);


NTSTATUS
Parse_Cmd_Line(
    IN  USHORT argc,
    IN  PSZ    argv[]
    );

NTSTATUS
Delay_Trigger_Wait(
    VOID
);

VOID
CliService(
    IN PUSHORT pTindex
);

VOID
Display_Results(
);

VOID
Cleanup(
);

/************************************************************************/
// Local functions required for SPX/IPX 
/************************************************************************/

//***>begin changes mkj
/**********************************************************************
    g e t _ h e x _ b y t e

    Converts the character passed in to a hexadecimal nibble.

    Arguments:    char    character to convert

    Returns:      UCHAR   hex nibble
**************************************************************************/
CHAR get_hex_byte(char ch)
{
    if (ch >= '0' && ch <= '9')
	return (ch - '0');

    if (ch >= 'A' && ch <= 'F')
	return ((ch - 'A') + 0x0A);

    return -1;
}
/**********************************************************************
    g e t _ h e x _ s t r i n g

    Reads in a character string containing hex digits and converts
    it to a hexadecimal number.

    Arguments:    LPSTR  => source string
		  LPSTR  => destination for hex number
		  int    number of bytes to convert

    Returns:      nothing
**************************************************************************/
CHAR get_hex_string(LPSTR src, LPSTR dest, int num)
{
    LPSTR q = src;
    CHAR  hexbyte1,hexbyte2;

    _strupr(q);
    while (num--)
      {hexbyte1 = get_hex_byte(*q++);
       hexbyte2 = get_hex_byte(*q++);
       if ( (hexbyte1 < 0) || (hexbyte2 < 0) )
	  return -1;
       *dest++ = (hexbyte1 << 4) + hexbyte2;
      }

    return(0);
}
/*************************************************************************
    g e t _ n o d e _ n u m b e r

    Reads a node number from the given string.

    Arguments:    LPSTR  => string to read from

    Returns:      LPSTR  => hex node number
**************************************************************************/
LPSTR get_node_number(LPSTR cmd)
{
    static char hex_num[6];

    memset(hex_num, 0, 6);

    if (strlen(cmd) != 12){
	hex_num[0] = 'X';
	return hex_num;
       }

    if (get_hex_string(cmd, hex_num, 6) < 0)
	hex_num[0] = 'X';
    return hex_num;
}
/**************************************************************************
    g e t _ n e t w o k _ n u m b e r

    Reads a network number from the given string.

    Arguments:    LPSTR  => string to read from

    Returns:      LPSTR  => hex network number
**************************************************************************/
LPSTR get_network_number(LPSTR cmd)
{
    static char hex_num[4];

    memset(hex_num, 0, 4);

    if (strlen(cmd) != 8) {
	hex_num[0] = 'X';
	return(hex_num);
    }

    if (get_hex_string(cmd, hex_num, 4) < 0)
	hex_num[0] = 'X';

    return hex_num;
}
//***>end changes mkj

/************************************************************************/
// External function prototypes
/************************************************************************/

/*++ 
    For NamedPipe

--*/
extern
NTSTATUS
NMP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
NMP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
NMP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
NMP_Cleanup(
    VOID
);

extern
NTSTATUS
NMP_Connect_To_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
NMP_Disconnect_From_Server(
    IN  USHORT CIndex
);


extern
NTSTATUS
NMP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN	   BOOLEAN	FirstIter
);

extern
NTSTATUS
NMP_ThreadCleanUp(
    IN  USHORT CIndex
);


/*++**********************************************************************
    For NetBIOS

--*/
extern
NTSTATUS
NB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
NB_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
NB_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);

extern
NTSTATUS
NB_Connect_To_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
NB_Disconnect_From_Server(
    IN  USHORT CIndex
);


extern
NTSTATUS
NB_Cleanup(
    VOID
);

extern
NTSTATUS
NB_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
NB_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN	   BOOLEAN	FirstIter
);

extern
NTSTATUS
NB_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets TCP/IP

--*/
extern
NTSTATUS
SCTCP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCTCP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCTCP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_Connect_To_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCTCP_Disconnect_From_Server(
    IN  USHORT CIndex
);


extern
NTSTATUS
SCTCP_Cleanup(
    VOID
);

extern
NTSTATUS
SCTCP_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCTCP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN	   BOOLEAN	FirstIter
);

extern
NTSTATUS
SCTCP_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets SPX(XNS)

--*/
extern
NTSTATUS
SCXNS_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCXNS_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCXNS_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
SCXNS_Connect_To_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCXNS_Disconnect_From_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCXNS_Cleanup(
    VOID
);

extern
NTSTATUS
SCXNS_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCXNS_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN	   BOOLEAN	FirstIter
);

extern
NTSTATUS
SCXNS_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets UDP

--*/
extern
NTSTATUS
SCUDP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCUDP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCUDP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
SCUDP_Cleanup(
    VOID
);

extern
NTSTATUS
SCUDP_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCUDP_Connect_To_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCUDP_Disconnect_From_Server(
    IN  USHORT CIndex
);


extern
NTSTATUS
SCUDP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets IPX

--*/
extern
NTSTATUS
SCIPX_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCIPX_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCIPX_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
SCIPX_Cleanup(
    VOID
);

extern
NTSTATUS
SCIPX_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCIPX_Connect_To_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCIPX_Disconnect_From_Server(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCIPX_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_ThreadCleanUp(
    IN  USHORT CIndex
);


/*++**********************************************************************
    For Datagram NetBIOS

--*/
extern
NTSTATUS
DGNB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
DGNB_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
DGNB_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
DGNB_Cleanup(
    VOID
);

extern
NTSTATUS
DGNB_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
DGNB_Disconnect_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
DGNB_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN     BOOLEAN	FirstIter
);

extern
NTSTATUS
DGNB_ThreadCleanUp(
    IN  USHORT CIndex
);


NTSTATUS
DGNB_Connect_To_Server(
  IN  USHORT CIndex
);

NTSTATUS
DGNB_Disconnect_From_Server(
  IN  USHORT CIndex
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\dgnb.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dgnb.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: dgnb.c
//
// Description: This file contains common routines for NetBios I/O
//              routines for use with IPC raw network performance
//              tests.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "dgnb.h"
#include "nb.h"

/************************************************************************/
/*++
    This routine is responsible for adding a given name on a net.
--*/

UCHAR
DGNetBIOS_AddName(
    IN     PCHAR	LocalName,
    IN	   UCHAR	LanaNumber,
    OUT	   PUCHAR	NameNumber)
{
    NCB		AddNameNCB;
    UCHAR	RetCode;

    RetCode =0;
    ClearNCB(&AddNameNCB);		// does cleanup everything

    AddNameNCB.ncb_command	= NCBADDNAME;
    RtlMoveMemory(AddNameNCB.ncb_name,LocalName,NCBNAMSZ);
    AddNameNCB.ncb_lana_num	= LanaNumber;

    RetCode = Netbios(&AddNameNCB);	// submit to NetBIOS

    if (AddNameNCB.ncb_retcode != NRC_GOODRET) {
	    printf("Addname failed %x\n", AddNameNCB.ncb_retcode);
	    return RetCode;
    }
    *NameNumber = AddNameNCB.ncb_num;

    return RetCode;
}

/************************************************************************/
/*++
    This routine is responsible for deleting a given name on a net.
--*/

UCHAR
DGNetBIOS_DelName(
    IN     PCHAR	LocalName,
    IN	   UCHAR	LanaNumber)
{
    NCB		DelNameNCB;
    UCHAR	RetCode;

    RetCode =0;
    ClearNCB(&DelNameNCB);		// does cleanup everything

    DelNameNCB.ncb_command	= NCBDELNAME;
    RtlMoveMemory(DelNameNCB.ncb_name,LocalName,NCBNAMSZ);
    DelNameNCB.ncb_lana_num	= LanaNumber;

    RetCode = Netbios(&DelNameNCB);	// submit to NetBIOS

    if (DelNameNCB.ncb_retcode != NRC_GOODRET) {
	    printf("Delname failed %x\n", DelNameNCB.ncb_retcode);
	    return RetCode;
    }
    return RetCode;
}

/************************************************************************/
UCHAR
DGNetBIOS_Reset(
    IN	   UCHAR	LanaNumber)
{
    NCB		ResetNCB;
    UCHAR	RetCode;

    RetCode =0;
    ClearNCB(&ResetNCB);		// does cleanup everything

    ResetNCB.ncb_command	= NCBRESET;
    ResetNCB.ncb_lana_num	= LanaNumber;
    ResetNCB.ncb_lsn		= 0;
    ResetNCB.ncb_callname[0]	= 0;	 //16 sessions
    ResetNCB.ncb_callname[1]	= 0;	 //16 commands
    ResetNCB.ncb_callname[2]	= 0;	 //8  names

    RetCode = Netbios(&ResetNCB);	// submit to NetBIOS

    if (ResetNCB.ncb_retcode != NRC_GOODRET) {
	    printf("Reset failed %x\n", ResetNCB.ncb_retcode);
	    return RetCode;
    }
    return RetCode;
}
/************************************************************************/
UCHAR
DGNetBIOS_Receive(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen)
{
    NCB		ReceiveNCB;
    NTSTATUS    rstatus;
    UCHAR	RetCode;

    //DbgPrint("Entering Recv..");
    RetCode =0;
    ClearNCB(&ReceiveNCB);		// does cleanup everything

    ReceiveNCB.ncb_command	= NCBDGRECV | ASYNCH;
    ReceiveNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    ReceiveNCB.ncb_num		= Clients[TIndex].c_NetB.c_NameNum;
    ReceiveNCB.ncb_lsn		= Clients[TIndex].c_NetB.c_LSN;
    ReceiveNCB.ncb_buffer	= RecvBuffer;
    ReceiveNCB.ncb_length	= RecvLen;
    ReceiveNCB.ncb_event	= Clients[TIndex].c_NetB.c_RecvEvent;

    //DbgPrint("Posting Recv..");
    RetCode = Netbios(&ReceiveNCB);	// submit to NetBIOS

    if (ReceiveNCB.ncb_cmd_cplt == NRC_PENDING){
        rstatus = WaitForSingleObjectEx(ReceiveNCB.ncb_event,
                                        INFINITE,
                                        TRUE);
    }
    if (ReceiveNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //DbgPrint("NBSRV:NB:Receive failed %x\n", ReceiveNCB.ncb_cmd_cplt);
    }
    //DbgPrint("Exit Recv\n");
    return ReceiveNCB.ncb_cmd_cplt;
}
/************************************************************************/
UCHAR
DGNetBIOS_Send(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen)
{
    NCB		SendNCB;
    NTSTATUS    rstatus;
    UCHAR	RetCode;

    //DbgPrint("Enter Send\n");
    RetCode =0;
    ClearNCB(&SendNCB);		// does cleanup everything

    SendNCB.ncb_command		= NCBDGSEND | ASYNCH;
    SendNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    SendNCB.ncb_num		    = Clients[TIndex].c_NetB.c_NameNum;
    SendNCB.ncb_lsn		    = Clients[TIndex].c_NetB.c_LSN;
    SendNCB.ncb_buffer		= SendBuffer;
    SendNCB.ncb_length		= SendLen;
    SendNCB.ncb_event		= Clients[TIndex].c_NetB.c_SendEvent;

    RtlMoveMemory(SendNCB.ncb_callname,RemoteName,NCBNAMSZ);

    RetCode = Netbios(&SendNCB);	// submit to NetBIOS

    if (SendNCB.ncb_cmd_cplt == NRC_PENDING){
        rstatus = WaitForSingleObjectEx(SendNCB.ncb_event,
                                        INFINITE,
                                        TRUE);
    }
    if (SendNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //DbgPrint("NBSRV:NBS:Send failed %x RetCode:%x\n",SendNCB.ncb_cmd_cplt,RetCode);
    }
    //DbgPrint("Exit Send\n");
    return SendNCB.ncb_cmd_cplt;
}
/************************************************************************/

NTSTATUS
DGNB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        IServerName,
    IN     USHORT	SrvCli)
{
    NTSTATUS 	Istatus;
    UCHAR	RetCode;
    USHORT	LanaNum;
    CHAR	Tmp[10];  // for holding numbers

    //
    // First Reset all the adapters
    // Add the server name if provided otherwise use the default name
    // To take care of TCP/IP and other Lana Bases

    LanaNum = LanaBase;

    // initialize all the named
    MyDbgPrint("Initialize both Local/Remote Names\n");

    if (SrvCli) {  // for server copy the given name as a local
        RtlMoveMemory(RemoteName, ALL_CLIENTS,  NCBNAMSZ);

        if (IServerName) {
            RtlMoveMemory(LocalName,  IServerName, NCBNAMSZ);
        }
        else {
            RtlMoveMemory(LocalName,  PERF_NETBIOS, NCBNAMSZ);
        }
    }
    else { // for a client copy the name as a remote name
        if (IServerName) {
            RtlMoveMemory(RemoteName, IServerName, NCBNAMSZ);
        }
        else {
            RtlMoveMemory(RemoteName, PERF_NETBIOS, NCBNAMSZ);
        }
        // copy  local name for client
        // use Rtl routines
        strcpy(LocalName,CLINAME);
        strcat(LocalName,_itoa(MachineNumber,Tmp,10));
    }
    while (LanaNum < LanaCount*2) { // for Jet and TCP/IP
        RetCode = NetBIOS_Reset((UCHAR) LanaNum);

        if (RetCode) {
            MyDbgPrint("Error in Reset\n");
            return(Istatus = -1L);
        }
        // we could assign Lana Numbers to clients and do AddName here too
        RetCode = NetBIOS_AddName(
		                LocalName,
		                (UCHAR) LanaNum,
                        &NameNumber);
        if (RetCode) {
            //MyDbgPrint("NB: Error in Add Name retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Add the Name number to Client's structure

        LanaNum = LanaNum+2;
    }
    //DbgPrint("NB: Reset Done\n");

    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
     This routine is responsible adding a NetBIOS name for the given
     thread.

--*/

NTSTATUS
DGNB_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli )	
{
    //NTSTATUS	pstatus;
    //UCHAR	    RetCode;
    //CHAR	    Tmp[10];  // for holding numbers

    // initialize proper client data structures
    Clients[CIndex].c_client_num = CIndex;

    // distribute clients evenly on all net cards
    Clients[CIndex].c_NetB.c_LanaNumber = ((CIndex % LanaCount)*2)+LanaBase;

    // Add the Name number to Client's structure
    Clients[CIndex].c_NetB.c_NameNum = NameNumber;

    // Set all events to Null
    Clients[CIndex].c_NetB.c_SendEvent  = NULL;
    Clients[CIndex].c_NetB.c_RecvEvent  = NULL;
    Clients[CIndex].c_NetB.c_RecvEventG = NULL;

    // create events to associate with an NCB for this thread
    Clients[CIndex].c_NetB.c_SendEvent = CreateEvent(
                                             NULL,
                                             TRUE,  // manual reset event
                                             FALSE, // initial state of the event
                                             NULL); // no event name

    Clients[CIndex].c_NetB.c_RecvEvent = CreateEvent(
                                             NULL,
                                             TRUE,  // manual reset event
                                             FALSE, // initial state of the event
                                             NULL); // no event name

    Clients[CIndex].c_NetB.c_RecvEventG = CreateEvent(
                                             NULL,
                                             TRUE,  // manual reset event
                                             FALSE, // initial state of the event
                                             NULL); // no event name
    /*
    pstatus = NtCreateEvent(
		&(Clients[CIndex].c_NetB.c_SendEvent),
		EVENT_ALL_ACCESS,
		NULL,
		NotificationEvent,
		(BOOLEAN)FALSE);
	
    if (!NT_SUCCESS(pstatus)) {
       MyDbgPrint ("Err: Create an Send Event:%d err=%lx\n",CIndex,pstatus);
       return(pstatus);
    }

    pstatus = NtCreateEvent(
		&(Clients[CIndex].c_NetB.c_RecvEvent),
		EVENT_ALL_ACCESS,
		NULL,
		NotificationEvent,
		(BOOLEAN)FALSE);

    if (!NT_SUCCESS(pstatus)) {
       MyDbgPrint ("Err: Create an Recv Event:%d err=%lx\n",CIndex,pstatus);
       return(pstatus);
    }

    pstatus = NtCreateEvent(
		&(Clients[CIndex].c_NetB.c_RecvEventG),
		EVENT_ALL_ACCESS,
		NULL,
		NotificationEvent,
		(BOOLEAN)FALSE);
	
    if (!NT_SUCCESS(pstatus)) {
       MyDbgPrint ("Err: Create GRecv Event:%d err=%lx\n",CIndex,pstatus);
       return(pstatus);
    }
    */
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Listen and waiting till a
     client is connected. When this routine returns successfully we can
     assume that a connection is established.
--*/

NTSTATUS
DGNB_Wait_For_Client(
  IN  USHORT CIndex)	// client index
{
    //UCHAR    RetCode;
    // post a listen

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Disconnect to close the
     connection with a client.
--*/

NTSTATUS
DGNB_Disconnect_Client(
  IN  USHORT CIndex)	// client index
{
    //UCHAR    RetCode;
    // post a Disconnect

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for establishing a connection to the
     server side. When this routine returns successfully we can assume that
     a connection is established.
--*/

NTSTATUS
DGNB_Connect_To_Server(
  IN  USHORT CIndex)	// client index
{
    //UCHAR    RetCode;

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine allocates memory required for all the buffers for a client.

--*/

NTSTATUS
DGNB_Allocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	astatus = 0;  
    ULONG	AllocSize;

    // AllocSize = Clients[CIndex].c_reqbuf.SendSize;
    AllocSize = MAXBUFSIZE;

    // Allocate memory for Send Buffer
    /*
    astatus = NtAllocateVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		0L,
		&(AllocSize),
		MEM_COMMIT,
		PAGE_READWRITE);

    if (!NT_SUCCESS(astatus)) {
        DbgPrint("Nmp SendBuf: Allocate memory failed: err: %lx \n", astatus);
        return astatus;
    }
    */
    (LPVOID) Clients[CIndex].c_pSendBuf = VirtualAlloc(
                                         (LPVOID) Clients[CIndex].c_pSendBuf,
                                         (DWORD)AllocSize,
                                         (DWORD)MEM_COMMIT,
                                         (DWORD)PAGE_READWRITE);
    sprintf(Clients[CIndex].c_pSendBuf,"Client%d Send Data", CIndex+1);

    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;

    // Allocate memory for Receive Buffer
    /*
    astatus = NtAllocateVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		0L,
		&(AllocSize),
		MEM_COMMIT,
		PAGE_READWRITE);

    if (!NT_SUCCESS(astatus)) {
        DbgPrint("Nmp RecvBuf :Allocate memory failed: err: %lx \n", astatus);
        return astatus;
    }
    */
    (LPVOID) Clients[CIndex].c_pRecvBuf = VirtualAlloc(
                                            (LPVOID) Clients[CIndex].c_pRecvBuf,
                                            (DWORD)AllocSize,
                                            (DWORD)MEM_COMMIT,
                                            (DWORD)PAGE_READWRITE);
    sprintf(Clients[CIndex].c_pRecvBuf,"Client%d Recv Data", CIndex+1);

    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;

    // Allocate memory for Global Receive Buffer
    /*
    astatus = NtAllocateVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_NetB.c_pRecvBufG)),
		0L,
		&(AllocSize),
		MEM_COMMIT,
		PAGE_READWRITE);

    if (!NT_SUCCESS(astatus)) {
        DbgPrint("Nmp RecvBufG :Allocate memory failed: err: %lx \n", astatus);
        return astatus;
    }
    */
    (LPVOID) Clients[CIndex].c_NetB.c_pRecvBufG = VirtualAlloc(
                                                    (LPVOID) Clients[CIndex].c_NetB.c_pRecvBufG,
                                                    AllocSize,
                                                    MEM_COMMIT,
                                                    PAGE_READWRITE);
    sprintf(Clients[CIndex].c_NetB.c_pRecvBufG,"Client%d RecvG Data", CIndex+1);

    return astatus;
}
/************************************************************************/
/*++
    This routine deallocates memory for a client.

--*/

NTSTATUS
DGNB_Deallocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	dstatus;
    ULONG	DeallocSize;

    // Deallocate memory for Send Buffer
    // DeallocSize = Clients[CIndex].c_reqbuf.SendSize;
    DeallocSize = MAXBUFSIZE;
    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pSendBuf,
                   DeallocSize,
                   MEM_DECOMMIT);
    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp SendBuf: Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }
    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Receive Buffer
    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pRecvBuf,
                   DeallocSize,
                   MEM_DECOMMIT);
    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }
    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Global Receive Buffer
    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_NetB.c_pRecvBufG)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_NetB.c_pRecvBufG,
                   DeallocSize,
                   MEM_DECOMMIT);
    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }
    return dstatus;
}
/************************************************************************/
/*++
     This routine is responsible for disconnecting a session.

--*/

NTSTATUS
DGNB_Disconnect_From_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    //UCHAR    RetCode;

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does handshake with it's peer. For Server this means
    receiving request message from a client. For Client it means just the
    opposite.
--*/

NTSTATUS
DGNB_DoHandshake(
  IN  USHORT CIndex,	// client index and namedpipe instance number
  IN  USHORT SrvCli)     // if it's a server or client
{
    //NTSTATUS	dstatus;
    //ULONG	    RWLen;
    ULONG	    RWreqLen;
    UCHAR	    RetCode;

    RWreqLen = sizeof(struct reqbuf);

    // for server do receive for a request buffer
    if (SrvCli) {
        RetCode = DGNetBIOS_Receive(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (USHORT) RWreqLen);
        if (RetCode) {
            //MyDbgPrint("NB: Err in Receive HandShake retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
    }
    else { // for Client do send of reqbuf size
        RetCode = DGNetBIOS_Send(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (USHORT) RWreqLen);
        if (RetCode) {
            //MyDbgPrint("NB: Err in Send HandShake retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Reads data from IPC.  For server it means reading data
    NumSends times in SendBuffers and for a client NumRecvs times into
    RecvBuffer.

--*/

NTSTATUS
DGNB_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli )   // if it's a server or client
{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    UCHAR	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumReads = Clients[CIndex].c_reqbuf.NumSends;
        ReadBuf  = Clients[CIndex].c_pSendBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    else { // for client do proper settings
	    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    while (NumReads--) {
        RetCode = DGNetBIOS_Receive(
			                CIndex,
			                (PVOID) ReadBuf,
			                (USHORT) ReadLen);
        if (RetCode) {
            //MyDbgPrint("NB: Err in Recv ReadFromIPC retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Set Read data length; I should check this from NCB
        *pReadDone = ReadLen;
    }
    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
    This routine Writes data to IPC.  For server it means writing data
    NumRecvs times in RecvBuffers and for a client NumSends times into
    SendBuffer.

--*/

NTSTATUS
DGNB_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli)    // if it's a server or client
{
    ULONG	NumWrites;
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    UCHAR	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumWrites = Clients[CIndex].c_reqbuf.NumRecvs;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
	    NumWrites = Clients[CIndex].c_reqbuf.NumSends;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    while (NumWrites--) {
        RetCode = DGNetBIOS_Send(
			            CIndex,
			            (PVOID) WriteBuf,
			            (USHORT) WriteLen);
        if (RetCode) {
            //MyDbgPrint("NB: Err in Send WritetoIPC retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Set written data length; I should check this from NCB
        *pWriteDone = WriteLen;
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does Transact I/O to IPC.

--*/

NTSTATUS
DGNB_XactIO(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli, // if it's a server or client
  IN	 BOOLEAN FirstIter)	
{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    UCHAR	RetCode;

    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;

    if (SrvCli) {  // set proper iterations and buffer for Server
        ReadBuf   = Clients[CIndex].c_pSendBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.SendSize;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
        ReadBuf   = Clients[CIndex].c_pRecvBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.RecvSize;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    while (NumReads--) {
        // for Srv and First Iteration just post a receive
        if (SrvCli && FirstIter) {
            RetCode = DGNetBIOS_Receive(
		                        CIndex,
		                        (PVOID) ReadBuf,
		                        (USHORT) ReadLen);
            if (RetCode) {
                //MyDbgPrint("NB: Err in Recv ReadFromIPC retc: %C \n", RetCode);
                return (STATUS_UNSUCCESSFUL);
            }
        }
        else {
            RetCode = DGNetBIOS_RecvSend(
		                        CIndex,
                                WriteBuf,
		                        (USHORT) WriteLen,
		                        ReadBuf,
		                        (USHORT) ReadLen);
            if (RetCode) {
                //MyDbgPrint("NB: Err in XactIO retc: %C \n", RetCode);
                return (STATUS_UNSUCCESSFUL);
            }
        }
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
NTSTATUS
DGNB_Cleanup(VOID)
{
    //USHORT		Cindex      = 0; // client index
    //NTSTATUS 	cstatus;
    //NTSTATUS 	exitstatus  = 0;
/*
    for (Cindex = 0; Cindex < NClients; Cindex++) {

    }
*/
    return (STATUS_SUCCESS);
}
/************************************************************************/

/*++
     This routine does a client specific cleanup work.
--*/

NTSTATUS
DGNB_ThreadCleanUp(
  IN  USHORT CIndex)
{
    NTSTATUS	tstatus;
    UCHAR	    RetCode;
    // Close all the events

    tstatus = CloseHandle(Clients[CIndex].c_NetB.c_SendEvent);
    tstatus = CloseHandle(Clients[CIndex].c_NetB.c_RecvEvent);
    tstatus = CloseHandle(Clients[CIndex].c_NetB.c_RecvEventG);

    // Delete the name Added
    RetCode = NetBIOS_DelName(
		            LocalName,
		            (UCHAR) Clients[CIndex].c_NetB.c_LanaNumber);
    if (RetCode) {
        //MyDbgPrint("NB: Error in DelName retc: %C \n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return STATUS_SUCCESS;
}

/************************************************************************/
UCHAR
DGNetBIOS_RecvSend(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen)
{
    NCB		ReceiveNCB; // Make it a part of client
    NCB		SendNCB;    // Make it a part of client struc
    NTSTATUS    rstatus, sstatus;
    UCHAR	RRetCode, SRetCode;

    RRetCode = SRetCode = 0;
    ClearNCB(&ReceiveNCB);	//  cleanup everything
    ClearNCB(&SendNCB);	//  cleanup everything

    // First post Receive but don't wait as this is for the next
    // request block
    ReceiveNCB.ncb_command	= NCBDGRECV | ASYNCH;
    ReceiveNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    ReceiveNCB.ncb_lsn		= Clients[TIndex].c_NetB.c_LSN;
    ReceiveNCB.ncb_buffer	= RecvBuffer;
    ReceiveNCB.ncb_length	= RecvLen;
    ReceiveNCB.ncb_event	= Clients[TIndex].c_NetB.c_RecvEvent;

    RRetCode = Netbios(&ReceiveNCB);	// submit to NetBIOS

    if (ReceiveNCB.ncb_cmd_cplt == NRC_PENDING){
        // now do all the send(s)
        SendNCB.ncb_command	    = NCBDGSEND | ASYNCH;
        SendNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
        SendNCB.ncb_lsn		    = Clients[TIndex].c_NetB.c_LSN;
        SendNCB.ncb_buffer	    = SendBuffer;
        SendNCB.ncb_length	    = SendLen;
        SendNCB.ncb_event	    = Clients[TIndex].c_NetB.c_SendEvent;

        SRetCode = Netbios(&SendNCB);	// submit to NetBIOS

        // First wait on Send , if successful then wait on receive
        if (SendNCB.ncb_cmd_cplt == NRC_PENDING){
            // First wait for the Send to complete
            sstatus = WaitForSingleObjectEx(SendNCB.ncb_event,
                                            INFINITE,
                                            TRUE);
        }
        if (SendNCB.ncb_cmd_cplt != NRC_GOODRET) {
	        //DbgPrint("NBSRV:NBSR:Send failed %x RetCode:%x\n",SendNCB.ncb_cmd_cplt,SRetCode);
            // Cancel the receive posted earlier
	        return SendNCB.ncb_cmd_cplt;
        }
        // Now wait for the receive to complete
        rstatus = WaitForSingleObjectEx(ReceiveNCB.ncb_event,
                                        INFINITE,
                                        TRUE);
        // check for status success here
    }
    if (ReceiveNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //DbgPrint("NBSRV:NBSR:Receive failed %x RetCode:%x\n",ReceiveNCB.ncb_cmd_cplt,RRetCode);
    }
    return ReceiveNCB.ncb_cmd_cplt;
}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\dgsccomn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dgsccomn.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: dgsccomn.c
//
// Description: This file contains common routines for Datagram Socket I/O
//              routines for use with IPC raw network performance
//              tests.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "dgsccomn.h"

/************************************************************************/
INTEGER
DGSocket_Recv(
    IN USHORT	  CIndex,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen)
{
    INTEGER 	RetCode;
    ULONG	    Buflen;
    PCHAR	    Bufp;

    Bufp   = PReadBuf;
    Buflen = *rpdatalen; // use this for getting request packet length

    *rpdatalen = 0;	// total data received

    // we have make sure that the data received is same as the data
    // requested

    while (Buflen) { // till we receive all the data
        RetCode = recv(Clients[CIndex].c_Sock.c_Sockid, Bufp, Buflen, 0);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Error: Receive:%ld\n",WSAGetLastError());
            break;
        }
        else {
            if (RetCode){
                *rpdatalen += (ULONG)RetCode;  // bytes received
                Buflen     -= (ULONG)RetCode;  // bytes yet to receive
                Bufp       += (USHORT)RetCode;  // Move the buffer pointer
            }
            else { break; }
        }
    } // check to see if it's 0

    return(RetCode);
}
/************************************************************************/
INTEGER
DGSocket_RecvFrom(
    IN USHORT	        CIndex,
    IN OUT PVOID        PReadBuf,
    IN OUT PULONG       rpdatalen,
    IN OUT PSOCKADDR    pcaddr,
    IN OUT PUSHORT      pcaddrlen)
{
    INTEGER 	RetCode;
    ULONG	    Buflen;
    PCHAR	    Bufp;

    Bufp   = PReadBuf;
    Buflen = *rpdatalen; // use this for getting request packet length

    *rpdatalen = 0;	// total data received

    // we have make sure that the data received is same as the data
    // requested

    while (Buflen) { // till we receive all the data
        RetCode = recvfrom(
                        Clients[CIndex].c_Sock.c_Sockid,
                        Bufp,
                        Buflen,
                        0,
			            pcaddr,
                        (int *)pcaddrlen);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Error: Receive:%ld\n",WSAGetLastError());
            break;
        }
        else {
            if (RetCode){
                *rpdatalen += (ULONG)RetCode;  // bytes received
                Buflen     -= (ULONG)RetCode;  // bytes yet to receive
                Bufp       += (USHORT)RetCode;  // Move the buffer pointer
            }
            else { break; }
        }
    } // check to see if it's 0
    return(RetCode);
}
/************************************************************************/
INTEGER
DGSocket_Send(
    IN USHORT	  CIndex,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen)
{
    INTEGER	RetCode;
    ULONG	Buflen;

    Buflen = *spdatalen; // total data to be sent

    *spdatalen = 0;	

    // Could use write also
    RetCode = send(Clients[CIndex].c_Sock.c_Sockid, PWriteBuf, Buflen, 0);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Send:%ld\n",WSAGetLastError());
    }
    else {
        *spdatalen = (ULONG) RetCode;
    } // check to see if send length is 0

    return(RetCode);
}
/************************************************************************/
INTEGER
DGSocket_SendTo(
    IN USHORT	        CIndex,
    IN OUT PVOID        PWriteBuf,
    IN OUT PULONG       spdatalen,
    IN OUT PSOCKADDR 	pcaddr,
    IN OUT PUSHORT      pcaddrlen)
{
    INTEGER	RetCode;
    ULONG	Buflen;

    Buflen = *spdatalen; // total data to be sent

    *spdatalen = 0;	

    // Could use write also
    RetCode = sendto(Clients[CIndex].c_Sock.c_Sockid, PWriteBuf, Buflen, 0,
		     pcaddr, *pcaddrlen);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Send:%ld\n",WSAGetLastError());
    }
    else {
        *spdatalen = (ULONG) RetCode;
    } // check to see if SendTo Length is 0
    return(RetCode);
}
/************************************************************************/
INTEGER
DGSocket_Close(
    IN  USHORT	  CIndex)
{
    INTEGER 		RetCode;

    RetCode = closesocket(Clients[CIndex].c_Sock.c_Sockid);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Close Socket Id  %ld\n",WSAGetLastError());
        return(RetCode);
    }
    return(RetCode);
}
/************************************************************************/
INTEGER
DGSocket_Connect(
    IN  USHORT	  CIndex,
    IN  PSOCKADDR pcsockaddr)
{
    INTEGER	RetCode;

    RetCode = connect(Clients[CIndex].c_Sock.c_Sockid,
		                pcsockaddr,
		                sizeof(SOCKADDR));

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("DGSock: Connect %ld\n",WSAGetLastError());
        return(RetCode);
    }
    return(RetCode);
}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\nb.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       nb.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: nb.c
//
// Description: This file contains common routines for NetBios I/O
//              routines for use with IPC raw network performance
//              tests.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "nb.h"

/************************************************************************/
/*++
    This routine is responsible for adding a given name on a net.
--*/

UCHAR
NetBIOS_AddName(
    IN     PCHAR	LocalName,
    IN	   UCHAR	LanaNumber,
    OUT	   PUCHAR	NameNumber)
{
    NCB		AddNameNCB;
    UCHAR	RetCode;

    //printf("\n\nNetBIOS_AddName::\n  LocalName: %s\n  LanaNumber: %uc \n\n", LocalName, LanaNumber);

    RetCode =0;
    ClearNCB(&AddNameNCB);		// does cleanup everything

    AddNameNCB.ncb_command	= NCBADDNAME;
    RtlMoveMemory(AddNameNCB.ncb_name,LocalName,NCBNAMSZ);
    AddNameNCB.ncb_lana_num	= LanaNumber;

    RetCode = Netbios(&AddNameNCB);	// submit to NetBIOS

    if (AddNameNCB.ncb_retcode != NRC_GOODRET) {
	    printf("Addname failed %x\n", AddNameNCB.ncb_retcode);
	    return RetCode;
    }

    *NameNumber = AddNameNCB.ncb_num;

    return RetCode;
}

/************************************************************************/
/*++
    This routine is responsible for deleting a given name on a net.
--*/

UCHAR
NetBIOS_DelName(
    IN     PCHAR	LocalName,
    IN	   UCHAR	LanaNumber)
{
    NCB		DelNameNCB;
    UCHAR	RetCode;

    RetCode =0;
    ClearNCB(&DelNameNCB);		// does cleanup everything

    DelNameNCB.ncb_command	= NCBDELNAME;
    RtlMoveMemory(DelNameNCB.ncb_name,LocalName,NCBNAMSZ);
    DelNameNCB.ncb_lana_num	= LanaNumber;

    RetCode = Netbios(&DelNameNCB);	// submit to NetBIOS

    if (DelNameNCB.ncb_retcode != NRC_GOODRET) {
	    printf("Delname failed %x\n", DelNameNCB.ncb_retcode);
	    return RetCode;
    }

    return RetCode;
}

/************************************************************************/
UCHAR
NetBIOS_Reset(
    IN	   UCHAR	LanaNumber)
{
    NCB		ResetNCB;
    UCHAR	RetCode;

    RetCode =0;
    ClearNCB(&ResetNCB);		// does cleanup everything

    ResetNCB.ncb_command	= NCBRESET;
    ResetNCB.ncb_lana_num	= LanaNumber;
    ResetNCB.ncb_lsn		= 0;
    ResetNCB.ncb_callname[0]	= 0;	 //16 sessions
    ResetNCB.ncb_callname[1]	= 0;	 //16 commands
    ResetNCB.ncb_callname[2]	= 0;	 //8  names

    RetCode = Netbios(&ResetNCB);	// submit to NetBIOS

    if (ResetNCB.ncb_retcode != NRC_GOODRET) {
	    printf("Reset failed %x\n", ResetNCB.ncb_retcode);
	    return RetCode;
    }

    return RetCode;
}
/************************************************************************/
// Used only by NetBIOS Client
UCHAR
NetBIOS_Call(
    IN	   USHORT	CIndex,		// Client Index
    IN	   PCHAR	LocalName,
    IN	   PCHAR	RemoteName)
{
    NCB		    CallNCB;
    NTSTATUS    cstatus;
    UCHAR	    RetCode;

    RetCode = 0;
    ClearNCB(&CallNCB);		// does cleanup everything

    //printf("\n\nNetBIOS_Call::\n  LocalName: %s , RemoteName: %s \n  LanaNumber: %c\n\n", \
    //       LocalName, RemoteName, Clients[CIndex].c_NetB.c_LanaNumber);

    CallNCB.ncb_command	 = NCBCALL | ASYNCH;
    CallNCB.ncb_lana_num = (UCHAR) Clients[CIndex].c_NetB.c_LanaNumber;
    CallNCB.ncb_lsn 	 = 0Xff;
    CallNCB.ncb_sto 	 = CallNCB.ncb_rto = (UCHAR) 1000; // 1000*500 ms timeout
    CallNCB.ncb_post	 = NULL;
    // associate an event with this NCB
    CallNCB.ncb_event	 = Clients[CIndex].c_NetB.c_SendEvent;

    RtlMoveMemory(CallNCB.ncb_name,LocalName,NCBNAMSZ);
    RtlMoveMemory(CallNCB.ncb_callname,RemoteName,NCBNAMSZ);

    RetCode = Netbios(&CallNCB);	// submit to NetBIOS

    if (CallNCB.ncb_cmd_cplt == NRC_PENDING){
        cstatus = WaitForSingleObjectEx(CallNCB.ncb_event,  // handle of the object to wait for
				                        INFINITE,           // wait forever
				                        TRUE);              // Alertable
    }

    if (CallNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    // MyDbgPrint("NBSRV:Call failed %x\n", CallNCB.ncb_cmd_cplt);
        printf("Command completion returns %08x\n", CallNCB.ncb_cmd_cplt);
	    return CallNCB.ncb_cmd_cplt;
    }
    // get value for LSN
    Clients[CIndex].c_NetB.c_LSN = CallNCB.ncb_lsn;

    return CallNCB.ncb_cmd_cplt;
    //return STATUS_SUCCESS;
}
/************************************************************************/
UCHAR
NetBIOS_Listen(
    IN	   USHORT	TIndex,		// Client Index
    IN	   PCHAR	LocalName,
    IN	   PCHAR	RemoteName,
    IN	   UCHAR	NameNumber)
{
    NCB		ListenNCB;
    NTSTATUS    lstatus;
    UCHAR	RetCode;

    RetCode =0;
    ClearNCB(&ListenNCB);		// does cleanup everything

    ListenNCB.ncb_command	= NCBLISTEN | ASYNCH;
    ListenNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    ListenNCB.ncb_sto 		= ListenNCB.ncb_rto = (UCHAR) 1000;
    				// 1000*500 ms timeout
    ListenNCB.ncb_num 		= NameNumber;
    ListenNCB.ncb_post		= NULL;

    // associate an event with this NCB
    ListenNCB.ncb_event	= Clients[TIndex].c_NetB.c_SendEvent;

    RtlMoveMemory(ListenNCB.ncb_name,LocalName,NCBNAMSZ);
    RtlMoveMemory(ListenNCB.ncb_callname,RemoteName,NCBNAMSZ);


    RetCode = Netbios(&ListenNCB);	// submit to NetBIOS

    if (ListenNCB.ncb_cmd_cplt == NRC_PENDING){
        lstatus = WaitForSingleObjectEx(ListenNCB.ncb_event,   // handle of the object
					                    INFINITE,              // default timeout
					                    TRUE);                 // alertable
    }

    if (ListenNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //MyDbgPrint("NBSRV:Listen failed %x\n", ListenNCB.ncb_cmd_cplt);
	    return ListenNCB.ncb_cmd_cplt;
    }

    // get value for LSN
    Clients[TIndex].c_NetB.c_LSN = ListenNCB.ncb_lsn;

    return ListenNCB.ncb_cmd_cplt;
}
/************************************************************************/
UCHAR
NetBIOS_Receive(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen)
{
    NCB		    ReceiveNCB;
    NTSTATUS    rstatus;
    UCHAR	    RetCode;

    RetCode =0;
    ClearNCB(&ReceiveNCB);		// does cleanup everything

    ReceiveNCB.ncb_command	= NCBRECV | ASYNCH;
    ReceiveNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    ReceiveNCB.ncb_lsn		= Clients[TIndex].c_NetB.c_LSN;
    ReceiveNCB.ncb_buffer	= RecvBuffer;
    ReceiveNCB.ncb_length	= RecvLen;
    ReceiveNCB.ncb_event	= Clients[TIndex].c_NetB.c_RecvEvent;


    RetCode = Netbios(&ReceiveNCB);	// submit to NetBIOS

    if (ReceiveNCB.ncb_cmd_cplt == NRC_PENDING){
        rstatus = WaitForSingleObjectEx(ReceiveNCB.ncb_event, // handle to object
					                    INFINITE,             // default timeout
					                    TRUE);                // alertable
    }

    if (ReceiveNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //MyDbgPrint("NBSRV:NB:Receive failed %x\n", ReceiveNCB.ncb_cmd_cplt);
    }
    return ReceiveNCB.ncb_cmd_cplt;

}
/************************************************************************/
UCHAR
NetBIOS_Send(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen)
{
    NCB		    SendNCB;
    NTSTATUS    rstatus;
    UCHAR	    RetCode;

    RetCode =0;
    ClearNCB(&SendNCB);		// does cleanup everything

    SendNCB.ncb_command		= NCBSEND | ASYNCH;
    SendNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    SendNCB.ncb_lsn		    = Clients[TIndex].c_NetB.c_LSN;
    SendNCB.ncb_buffer		= SendBuffer;
    SendNCB.ncb_length		= SendLen;
    SendNCB.ncb_event		= Clients[TIndex].c_NetB.c_SendEvent;

    RetCode = Netbios(&SendNCB);	// submit to NetBIOS

    if (SendNCB.ncb_cmd_cplt == NRC_PENDING){
        rstatus = WaitForSingleObjectEx(SendNCB.ncb_event,      // handle to object
					                    INFINITE,               // default timeout
					                    TRUE);                  // alertable
    }

    if (SendNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //MyDbgPrint("NBSRV:NBS:Send failed %x RetCode:%x\n",SendNCB.ncb_cmd_cplt,RetCode);
    }
    return SendNCB.ncb_cmd_cplt;
}
/************************************************************************/
UCHAR
NetBIOS_HangUP(
    IN	   USHORT	TIndex)
{
    NCB		    HangUPNCB;
    //NTSTATUS    rstatus;
    UCHAR	    RetCode;

    RetCode = 0;
    ClearNCB(&HangUPNCB);		// does cleanup everything

    HangUPNCB.ncb_command	= NCBHANGUP;
    HangUPNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    HangUPNCB.ncb_lsn		= Clients[TIndex].c_NetB.c_LSN;

    RetCode = Netbios(&HangUPNCB);	// submit to NetBIOS

    if (HangUPNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //MyDbgPrint("NBSRV:HangUP failed %x\n", HangUPNCB.ncb_cmd_cplt);
    }
    return HangUPNCB.ncb_cmd_cplt;
}
/************************************************************************/
UCHAR
NetBIOS_RecvSend(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen)
{
    NCB		    ReceiveNCB; // Make it a part of client
    NCB		    SendNCB;    // Make it a part of client struc
    NTSTATUS    rstatus, sstatus;
    UCHAR	    RRetCode, SRetCode;

    RRetCode = SRetCode = 0;
    ClearNCB(&ReceiveNCB);	//  cleanup everything
    ClearNCB(&SendNCB);	//  cleanup everything

    // First post Receive but don't wait as this is for the next
    // request block
    ReceiveNCB.ncb_command	= NCBRECV | ASYNCH;
    ReceiveNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    ReceiveNCB.ncb_lsn		= Clients[TIndex].c_NetB.c_LSN;
    ReceiveNCB.ncb_buffer	= RecvBuffer;
    ReceiveNCB.ncb_length	= RecvLen;
    ReceiveNCB.ncb_event	= Clients[TIndex].c_NetB.c_RecvEvent;

    RRetCode = Netbios(&ReceiveNCB);	// submit to NetBIOS

    if (ReceiveNCB.ncb_cmd_cplt == NRC_PENDING){
        // now do all the send(s)
        SendNCB.ncb_command	    = NCBSEND | ASYNCH;
        SendNCB.ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
        SendNCB.ncb_lsn		    = Clients[TIndex].c_NetB.c_LSN;
        SendNCB.ncb_buffer	    = SendBuffer;
        SendNCB.ncb_length	    = SendLen;
        SendNCB.ncb_event	    = Clients[TIndex].c_NetB.c_SendEvent;

        SRetCode = Netbios(&SendNCB);	// submit to NetBIOS

        // First wait on Send , if successful then wait on receive
        if (SendNCB.ncb_cmd_cplt == NRC_PENDING){
            // First wait for the Send to complete
            sstatus = WaitForSingleObjectEx(SendNCB.ncb_event,
                                            INFINITE,
                                            TRUE);
        }

        if (SendNCB.ncb_cmd_cplt != NRC_GOODRET) {
	        //MyDbgPrint("NBSRV:NBSR:Send failed %x RetCode:%x\n",SendNCB.ncb_cmd_cplt,SRetCode);
            // Cancel the receive posted earlier
	        return SendNCB.ncb_cmd_cplt;
        }

        // Now wait for the receive to complete
        rstatus = WaitForSingleObjectEx(ReceiveNCB.ncb_event,
                                        INFINITE,
                                        TRUE);
        // check for status success here
    }

    if (ReceiveNCB.ncb_cmd_cplt != NRC_GOODRET) {
	    //MyDbgPrint("NBSRV:NBSR:Receive failed %x RetCode:%x\n",ReceiveNCB.ncb_cmd_cplt,RRetCode);
    }

    return ReceiveNCB.ncb_cmd_cplt;
}
/************************************************************************/

UCHAR
NetBIOS_SPReceive(
    IN	   USHORT	TIndex,
    IN	   NCB      *PRecvNCB,
    IN	   USHORT	Global,		// global= 1 or local = 0
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen)
{
    UCHAR	RetCode;

    RetCode =0;
    ClearNCB(PRecvNCB);		// does cleanup everything

    PRecvNCB->ncb_command	= NCBRECV | ASYNCH;
    PRecvNCB->ncb_lana_num	= (UCHAR) Clients[TIndex].c_NetB.c_LanaNumber;
    PRecvNCB->ncb_lsn		= Clients[TIndex].c_NetB.c_LSN;
    PRecvNCB->ncb_buffer	= RecvBuffer;
    PRecvNCB->ncb_length	= RecvLen;

    if (Global) {
        PRecvNCB->ncb_event	= Clients[TIndex].c_NetB.c_RecvEventG;
    }
    else {
        PRecvNCB->ncb_event	= Clients[TIndex].c_NetB.c_RecvEvent;
    }


    RetCode = Netbios(PRecvNCB);	// submit to NetBIOS

    return RetCode;
}
/************************************************************************/

NTSTATUS
NB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR    IServerName,
    IN     USHORT	SrvCli)
{
    NTSTATUS 	Istatus;
    UCHAR	    RetCode;
    USHORT	    LanaNum;
    CHAR	    Tmp[10];  // for holding numbers

    //
    // First Reset all the adapters
    // Add the server name if provided otherwise use the default name
    // To take care of TCP/IP and other Lana Bases

    LanaNum = LanaBase;

    // initialize all the named
    MyDbgPrint("Initialize both Local/Remote Names\n");

    if (SrvCli) {  // for server copy the given name as a local
        RtlMoveMemory(RemoteName, ALL_CLIENTS,  NCBNAMSZ);
        if (IServerName) {
            RtlMoveMemory(LocalName,  IServerName, NCBNAMSZ);
        }
        else {
            RtlMoveMemory(LocalName,  PERF_NETBIOS, NCBNAMSZ);
        }
    }
    else { // for a client copy the name as a remote name

        if (IServerName) {
            RtlMoveMemory(RemoteName, IServerName, NCBNAMSZ);
        }
        else {
            RtlMoveMemory(RemoteName, PERF_NETBIOS, NCBNAMSZ);
        }

        // copy  local name for client
        // use Rtl routines
        strcpy(LocalName,CLINAME);
        strcat(LocalName,_itoa(MachineNumber,Tmp,10));
    }

    while (LanaNum < LanaCount*2) { // for Jet and TCP/IP

        RetCode = NetBIOS_Reset((UCHAR) LanaNum);

        if (RetCode) {
            MyDbgPrint("Error in Reset\n");
            return(Istatus = -1L);
        }

        // we could assign Lana Numbers to clients and do AddName here too
        RetCode = NetBIOS_AddName(LocalName,
		                          (UCHAR) LanaNum,
                                  &NameNumber);

        if (RetCode) {
            //MyDbgPrint("NB: Error in Add Name retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }

       // Add the Name number to Client's structure

        LanaNum = LanaNum+2;
    }

    OutputDebugString("NB: Reset Done\n");

    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
     This routine is responsible adding a NetBIOS name for the given
     thread.

--*/

NTSTATUS
NB_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli )	
{
    //NTSTATUS	pstatus;
    //UCHAR	    RetCode;
    //CHAR	    Tmp[10];  // for holding numbers

    // initialize proper client data structures
    Clients[CIndex].c_client_num = CIndex;

    // distribute clients evenly on all net cards
    Clients[CIndex].c_NetB.c_LanaNumber = ((CIndex % LanaCount)*2)+LanaBase;

    // Add the Name number to Client's structure
    Clients[CIndex].c_NetB.c_NameNum = NameNumber;

    // Set all events to Null
    Clients[CIndex].c_NetB.c_SendEvent  = NULL;
    Clients[CIndex].c_NetB.c_RecvEvent  = NULL;
    Clients[CIndex].c_NetB.c_RecvEventG = NULL;


    // create events to associate with an NCB for this thread

    Clients[CIndex].c_NetB.c_SendEvent = CreateEvent(
                                             NULL,
                                             TRUE,  // manual reset event
                                             FALSE, // initial state of the event
                                             NULL); // no event name

    Clients[CIndex].c_NetB.c_RecvEvent = CreateEvent(
                                             NULL,
                                             TRUE,  // manual reset event
                                             FALSE, // initial state of the event
                                             NULL); // no event name

    Clients[CIndex].c_NetB.c_RecvEventG = CreateEvent(
                                             NULL,
                                             TRUE,  // manual reset event
                                             FALSE, // initial state of the event
                                             NULL); // no event name

/*
    // Create appropriate Name and do Add Name
    // For server do Nothing
    // for client make a name using machine+Client number

    if (!SrvCli) {
        // use Rtl routines
        strcpy(LocalName,CLINAME);

        strcat(LocalName,_itoa(MachineNumber,Tmp,10));
        strcat(LocalName,_itoa(CIndex,Tmp,10));
    }

    RetCode = NetBIOS_AddName(
		            LocalName,
		            (UCHAR) Clients[CIndex].c_NetB.c_LanaNumber,
                    &NameNum);
    if (RetCode) {
        // MyDbgPrint("NB: Error in Add Name retc: %C \n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
*/


    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Listen and waiting till a
     client is connected. When this routine returns successfully we can
     assume that a connection is established.
--*/

NTSTATUS
NB_Wait_For_Client(
  IN  USHORT CIndex)	// client index
{

    UCHAR    RetCode;
    // post a listen

    RetCode = NetBIOS_Listen(
        	    CIndex,
 		        LocalName,
		        RemoteName,
                (UCHAR)Clients[CIndex].c_NetB.c_NameNum);

    if (RetCode) {
        //MyDbgPrint("NB: Err in Listen retc: %C \n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Disconnect to close the
     connection with a client.
--*/

NTSTATUS
NB_Disconnect_Client(
  IN  USHORT CIndex)	// client index
{
    UCHAR    RetCode;
    // post a Disconnect

    RetCode = NetBIOS_HangUP(CIndex);

    if (RetCode) {
        // MyDbgPrint("NB: Err in Disconnect retc: %C \n", RetCode);
        // return (STATUS_UNSUCCESSFUL);
        // just ignore the error for the  time being
    }

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for establishing a connection to the
     server side. When this routine returns successfully we can assume that
     a connection is established.
--*/

NTSTATUS
NB_Connect_To_Server(
  IN  USHORT CIndex)	// client index
{

    UCHAR    RetCode;

    RetCode = NetBIOS_Call(
		        CIndex,
		        LocalName,
		        RemoteName);


    if (RetCode) {
        //MyDbgPrint("NB: Err in Call retc: %C \n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine allocates memory required for all the buffers for a client.

--*/

NTSTATUS
NB_Allocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	astatus   = STATUS_SUCCESS;
    ULONG	    AllocSize;

    // AllocSize = Clients[CIndex].c_reqbuf.SendSize;
    AllocSize = MAXBUFSIZE;

    // Allocate memory for Send Buffer
    (LPVOID) Clients[CIndex].c_pSendBuf = VirtualAlloc(
                                         (LPVOID) Clients[CIndex].c_pSendBuf,
                                         (DWORD)AllocSize,
                                         (DWORD)MEM_COMMIT,
                                         (DWORD)PAGE_READWRITE);
    sprintf(Clients[CIndex].c_pSendBuf,"Client%d Send Data", CIndex+1);
    if (Clients[CIndex].c_pSendBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;

    // Allocate memory for Receive Buffer
    (LPVOID) Clients[CIndex].c_pRecvBuf = VirtualAlloc(
                                            (LPVOID) Clients[CIndex].c_pRecvBuf,
                                            (DWORD)AllocSize,
                                            (DWORD)MEM_COMMIT,
                                            (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pRecvBuf,"Client%d Recv Data", CIndex+1);
    if (Clients[CIndex].c_pRecvBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;

    // Allocate memory for Global Receive Buffer
    (LPVOID) Clients[CIndex].c_NetB.c_pRecvBufG = VirtualAlloc(
                                                    (LPVOID) Clients[CIndex].c_NetB.c_pRecvBufG,
                                                    AllocSize,
                                                    MEM_COMMIT,
                                                    PAGE_READWRITE);

    sprintf(Clients[CIndex].c_NetB.c_pRecvBufG,"Client%d RecvG Data", CIndex+1);
    if (Clients[CIndex].c_NetB.c_pRecvBufG == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    return astatus;
}
/************************************************************************/
/*++
    This routine deallocates memory for a client.

--*/

NTSTATUS
NB_Deallocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	dstatus;
    ULONG	DeallocSize;

    // Deallocate memory for Send Buffer
    // DeallocSize = Clients[CIndex].c_reqbuf.SendSize;
    DeallocSize = MAXBUFSIZE;

    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pSendBuf,
                   DeallocSize,
                   MEM_DECOMMIT);
/*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
*/

    if (!NT_SUCCESS(dstatus)) {
        // DbgPrint("Nmp SendBuf: Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }

    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Receive Buffer
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pRecvBuf,
                   DeallocSize,
                   MEM_DECOMMIT);

/*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
*/

    if (!NT_SUCCESS(dstatus)) {
        // DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }

    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Global Receive Buffer
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_NetB.c_pRecvBufG,
                   DeallocSize,
                   MEM_DECOMMIT);
/*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_NetB.c_pRecvBufG)),
		&(DeallocSize),
		MEM_DECOMMIT);
*/

    if (!NT_SUCCESS(dstatus)) {
        // DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }


   return dstatus;

}
/************************************************************************/
/*++
     This routine is responsible for disconnecting a session.

--*/

NTSTATUS
NB_Disconnect_From_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    UCHAR    RetCode;

    RetCode = NetBIOS_HangUP(CIndex);

   /*
    // Session could be closed; check for errc=a
    if (RetCode) {
        // MyDbgPrint("NB: Err in Hang Up retc: %C \n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
   */

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does handshake with it's peer. For Server this means
    receiving request message from a client. For Client it means just the
    opposite.
--*/

NTSTATUS
NB_DoHandshake(
  IN  USHORT CIndex,	// client index and namedpipe instance number
  IN  USHORT SrvCli)     // if it's a server or client
{
    //NTSTATUS	dstatus;
    //ULONG	    RWLen;
    USHORT	    RWreqLen;
    UCHAR	    RetCode;

    RWreqLen = sizeof(struct reqbuf);

    // for server do receive for a request buffer

    if (SrvCli) {
        RetCode = NetBIOS_Receive(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            RWreqLen);
        if (RetCode) {
            // MyDbgPrint("NB: Err in Receive HandShake retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
    }
    else { // for Client do send of reqbuf size
        RetCode = NetBIOS_Send(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            RWreqLen);
			
        if (RetCode) {
            // MyDbgPrint("NB: Err in Send HandShake retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }

    }

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Reads data from IPC.  For server it means reading data
    NumSends times in SendBuffers and for a client NumRecvs times into
    RecvBuffer.

--*/

NTSTATUS
NB_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli     // if it's a server or client
)	

{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    UCHAR	RetCode;

    if (SrvCli) {   // set proper iterations and buffer for Server
	    NumReads = Clients[CIndex].c_reqbuf.NumSends;
        ReadBuf  = Clients[CIndex].c_pSendBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    else {          // for client do proper settings
	    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }


    while (NumReads--) {
        RetCode = NetBIOS_Receive(
			        CIndex,
			        (PVOID) ReadBuf,
			        (USHORT) ReadLen);
        if (RetCode) {
            // MyDbgPrint("NB: Err in Recv ReadFromIPC retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Set Read data length; I should check this from NCB
        *pReadDone = ReadLen;
    }

    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
    This routine Writes data to IPC.  For server it means writing data
    NumRecvs times in RecvBuffers and for a client NumSends times into
    SendBuffer.

--*/

NTSTATUS
NB_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli     // if it's a server or client
)	

{
    ULONG	NumWrites;
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    UCHAR	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumWrites = Clients[CIndex].c_reqbuf.NumRecvs;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
	    NumWrites = Clients[CIndex].c_reqbuf.NumSends;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }

    while (NumWrites--) {
        RetCode = NetBIOS_Send(
			        CIndex,
			        (PVOID) WriteBuf,
			        (USHORT) WriteLen);
        if (RetCode) {
            // MyDbgPrint("NB: Err in Send WritetoIPC retc: %C \n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Set written data length; I should check this from NCB
        *pWriteDone = WriteLen;
    }

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does Transact I/O to IPC.

--*/

NTSTATUS
NB_XactIO(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli, // if it's a server or client
  IN	 BOOLEAN FirstIter
)	

{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    UCHAR	RetCode;

    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;

    if (SrvCli) {  // set proper iterations and buffer for Server
        ReadBuf   = Clients[CIndex].c_pSendBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.SendSize;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
        ReadBuf   = Clients[CIndex].c_pRecvBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.RecvSize;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }

    while (NumReads--) {
        // for Srv and First Iteration just post a receive
        if (SrvCli && FirstIter) {
            RetCode = NetBIOS_Receive(
		                CIndex,
		                (PVOID) ReadBuf,
		                (USHORT) ReadLen);
            if (RetCode) {
                // MyDbgPrint("NB: Err in Recv ReadFromIPC retc: %C \n", RetCode);
                return (STATUS_UNSUCCESSFUL);
            }
        }
        else {
            RetCode = NetBIOS_RecvSend(
		                    CIndex,
                            WriteBuf,
		                    (USHORT) WriteLen,
		                    ReadBuf,
		                    (USHORT) ReadLen);
            if (RetCode) {
                //  MyDbgPrint("NB: Err in XactIO retc: %C \n", RetCode);
                return (STATUS_UNSUCCESSFUL);
            }
        }
    }

    return (STATUS_SUCCESS);
}

/************************************************************************/
NTSTATUS
NB_Cleanup(VOID)
{
    USHORT		Cindex = 0; // client index
    //NTSTATUS 		cstatus;
    NTSTATUS 		exitstatus = 0;

/*
    for (Cindex = 0; Cindex < NClients; Cindex++) {

    }
*/
    return (STATUS_SUCCESS);
}
/************************************************************************/

/*++
     This routine does a client specific cleanup work.
--*/

NTSTATUS
NB_ThreadCleanUp(
  IN  USHORT CIndex
)

{
    NTSTATUS	tstatus;
    UCHAR	    RetCode;
    // Close all the events

    tstatus = CloseHandle(Clients[CIndex].c_NetB.c_SendEvent);
    tstatus = CloseHandle(Clients[CIndex].c_NetB.c_RecvEvent);
    tstatus = CloseHandle(Clients[CIndex].c_NetB.c_RecvEventG);


    // Delete the name Added
    RetCode = NetBIOS_DelName(
		        LocalName,
		        (UCHAR) Clients[CIndex].c_NetB.c_LanaNumber);

    if (RetCode) {
        // MyDbgPrint("NB: Error in DelName retc: %C \n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }

    return STATUS_SUCCESS;

}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\sccomn.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       sccomn.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: sccomn.c
//
// Description: This file contains common routines for socket I/O
//              routines for use with IPC raw network performance
//              tests.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "sccomn.h"

/************************************************************************/
// Socket specific functions
/************************************************************************/
INTEGER
Socket_Listen(
    IN  USHORT	CliIndx)
{
    INTEGER 		RetCode;

    // now post listen on this handle
    RetCode = listen(Clients[CliIndx].c_Sock.c_Listenid, 1);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Listen:%ld\n",WSAGetLastError());
    }
    //MyDbgPrint("Sock: Listen success for %d\n", CliIndx);
    return(RetCode);
}

/************************************************************************/
INTEGER
Socket_Accept(
    IN  USHORT	CliIndx)
{

    INTEGER 		RetCode;
    SOCKADDR		saddr;		// socket address
    INTEGER		saddrlen;

    saddrlen = sizeof(saddr);

    ClearSocket(&saddr);		// cleanup the structure

    // accept the connection
    RetCode = (INTEGER)accept(Clients[CliIndx].c_Sock.c_Listenid, &saddr, &saddrlen);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Accept:%ld\n", WSAGetLastError());
    }
    else {
        Clients[CliIndx].c_Sock.c_Sockid = RetCode; 	// valid socket id
    }
    return(RetCode);
}
/************************************************************************/

INTEGER
Socket_Recv(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen)
{

    INTEGER 	RetCode;
    ULONG	    Buflen;
    PCHAR	    Bufp;

    Bufp   = PReadBuf;
    Buflen = *rpdatalen; // use this for getting request packet length

    *rpdatalen = 0;	// total data received

    // we have make sure that the data received is same as the data
    // requested

    while (Buflen) { // till we receive all the data

        RetCode = recv(Clients[CliIndx].c_Sock.c_Sockid, Bufp, Buflen, 0);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Error: Receive:%ld\n",WSAGetLastError());
            break;
        }
        else {
            if (RetCode){
                *rpdatalen += (ULONG)RetCode;  // bytes received
                Buflen     -= (ULONG)RetCode;  // bytes yet to receive
                Bufp       += (USHORT)RetCode;  // Move the buffer pointer
            }
            else { break; }
        }
    } // check to see if it's 0

    // DbgPrint("Recvd %ld bytes\n", *rpdatalen);

    return(RetCode);
}
/************************************************************************/
INTEGER
Socket_Send(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen)
{
    INTEGER	RetCode;
    ULONG	Buflen;

    Buflen = *spdatalen; // total data to be sent

    *spdatalen = 0;	

    // Could use write also
    RetCode = send(Clients[CliIndx].c_Sock.c_Sockid, PWriteBuf, Buflen, 0);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Send:%ld\n",WSAGetLastError());
    }
    else {
        *spdatalen = (ULONG) RetCode;
        // DbgPrint("Sent  %ld bytes\n", *spdatalen);
    } // check to see if it's 0
    return(RetCode);
}
/************************************************************************/
INTEGER
Socket_Close(
    IN  USHORT	  CliIndx)
{
    INTEGER 		RetCode;

    RetCode = closesocket(Clients[CliIndx].c_Sock.c_Sockid);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Close Socket Id \n");
        return(RetCode);
    }
    return(RetCode);
}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\np.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       np.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: np.c
//
// Description: This file contains common routines for named pipe
//              routines for use with IPC raw networl performance
//              tests.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "np.h"

/*++
   NamedPipe function implementations
--*/

/************************************************************************/
NTSTATUS
NMP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR    ServerName,
    IN     USHORT	SrvCli)
{
    CHAR TempSrv[256];
    // use local pipe name for server or if Name not provided
    if (SrvCli || (!ServerName)) {
	    strcpy(TempSrv,PERF_PIPE);
    }
    else{
        if (!ServerName) {
	        strcpy(TempSrv, RM_PERF_PIPE_PRFX);
        }
        else {
	        strcpy(TempSrv, (const char *)ServerName);
        }
	    strcat(TempSrv, RM_PERF_PIPE_SUFX);
    }
    printf("NMP: Pipe name - %s\n", TempSrv);
    pipeName = _strdup(TempSrv);
    return(STATUS_SUCCESS);
}
/************************************************************************/
/*++
     This routine is responsible Creating a NamedPipe instance for the given
     thread.

--*/

NTSTATUS
NMP_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli )	
{
    NTSTATUS pstatus = 0;

    if (SrvCli) {
        // create namedpipe for this client
        pstatus = CreateNamedPipeInstance(CIndex);
    }
    else { // for Client initialize all the thread parameters
        ;
    }
    return pstatus;
}

/************************************************************************/
/*++
     This routine is responsible for issueing Listen and waiting till a
     client is connected. When this routine returns successfully we can
     assume that a connection is established.
--*/

NTSTATUS
NMP_Wait_For_Client(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	wstatus;
    wstatus = ConnectNamedPipe(Clients[CIndex].c_Nmp.c_PipeHandle,
                               NULL);

    if (wstatus == FALSE) {
        printf("Error: ConnectNamedPipe - 0x%08x, %ld\n", GetLastError(), GetLastError());
    }
    return (wstatus);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Disconnect to close the
     connection with a client.
--*/

NTSTATUS
NMP_Disconnect_Client(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS dstatus;

    // post a Disconnect
    // first find the status of the pipe to make sure that it's empty

   dstatus = FlushFileBuffers(Clients[CIndex].c_Nmp.c_PipeHandle);
   if (dstatus == FALSE) {
       printf("Error: FlushFileBuffers failed - 0x%08x\n", GetLastError());
   }
   dstatus = DisconnectNamedPipe(Clients[CIndex].c_Nmp.c_PipeHandle);
   if (dstatus == FALSE) {
       printf("Error: DisconnectNamedPipe failed - 0x%08x, %ld\n", GetLastError(), GetLastError());
   }
   return dstatus;
}

/************************************************************************/
/*++
     This routine is responsible for establishing a connection to the
     server side. When this routine returns successfully we can assume that
     a connection is established.
--*/

NTSTATUS
NMP_Connect_To_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS			    cstatus;
    DWORD                   dwPipeMode;

    Clients[CIndex].c_Nmp.c_PipeHandle = CreateFile(            //connect to the server
                                            pipeName,           // address of filename
                                            GENERIC_READ | GENERIC_WRITE,   // access mode
                                            0L,                 // share mode
                                            NULL,               // security attributes
                                            OPEN_EXISTING,      // create mode
                                            0L,                 // attributes and flags
                                            NULL);              // template file handle
    if (Clients[CIndex].c_Nmp.c_PipeHandle == INVALID_HANDLE_VALUE) {
        printf("Error: CreateFile failed - 0x%08x\n", GetLastError());
        cstatus = FALSE;
    }
    else {
        dwPipeMode = PIPE_READMODE_MESSAGE;
        cstatus = SetNamedPipeHandleState(Clients[CIndex].c_Nmp.c_PipeHandle, // pipe handle
                                          &dwPipeMode,                        // new pipe mode
                                          NULL,                               // do not set the max bytes
                                          NULL);                              // do not set the max time
        if (cstatus == FALSE) {
            printf("Error: SetNamedPipeHandleState failed - 0x%08x\n", GetLastError());
        }
    }
    return(cstatus);
}

/************************************************************************/
/*++
    This routine allocates memory required for all the buffers for a client.

--*/

NTSTATUS
NMP_Allocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	astatus     = STATUS_SUCCESS;
    ULONG	    AllocSize;

    AllocSize = MAXBUFSIZE;
    (LPVOID) Clients[CIndex].c_pSendBuf = VirtualAlloc(
                                         (LPVOID) Clients[CIndex].c_pSendBuf,
                                         (DWORD)AllocSize,
                                         (DWORD)MEM_COMMIT,
                                         (DWORD)PAGE_READWRITE);
    sprintf(Clients[CIndex].c_pSendBuf,"Client%d Send Data",CIndex+1);
    if (Clients[CIndex].c_pSendBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    AllocSize = MAXBUFSIZE;
    (LPVOID) Clients[CIndex].c_pRecvBuf = VirtualAlloc(
                                            (LPVOID) Clients[CIndex].c_pRecvBuf,
                                            (DWORD)AllocSize,
                                            (DWORD)MEM_COMMIT,
                                            (DWORD)PAGE_READWRITE);
    sprintf(Clients[CIndex].c_pRecvBuf,"Client%d Recv Data",CIndex+1);
    if (Clients[CIndex].c_pRecvBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    return astatus;
}
/************************************************************************/
/*++
    This routine deallocates memory for a client.

--*/

NTSTATUS
NMP_Deallocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	dstatus;
    ULONG	DeallocSize;

    DeallocSize = MAXBUFSIZE;
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pSendBuf,
                   DeallocSize,
                   MEM_DECOMMIT);
    if (!NT_SUCCESS(dstatus)) {
        return dstatus;
    }

    DeallocSize = MAXBUFSIZE;
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pRecvBuf,
                   DeallocSize,
                   MEM_DECOMMIT);
    if (!NT_SUCCESS(dstatus)) {
        return dstatus;
    }
    return dstatus;
}
/************************************************************************/
/*++
     This routine is responsible for disconnecting a session.

--*/

NTSTATUS
NMP_Disconnect_From_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
   NTSTATUS	dstatus;

   dstatus = CloseHandle(Clients[CIndex].c_Nmp.c_PipeHandle);

   if (!NT_SUCCESS(dstatus)) {
      //DbgPrint("Nmp: Error in Disconnect err: %lx \n", dstatus);
   }
   return (dstatus);
}

/************************************************************************/
// no need for this function
/*
NTSTATUS
NamedPipe_FsControl(
    IN     HANDLE	lhandle,
    IN	   ULONG	FsControlCode,
    IN	   PVOID	pInBuffer,
    IN	   ULONG	InBufLen,
    OUT	   PVOID	pOutBuffer,
    IN	   ULONG	OutBufLen)
{

    NTSTATUS 		lstatus;
    IO_STATUS_BLOCK ioStatusBlock;
    DWORD           actOutBufLen;

    // now post listen on this handle

    lstatus = NtFsControlFile (
        lhandle,
        NULL,
        NULL,
        NULL,
        &ioStatusBlock,
	    FsControlCode,	 // LISTEN or DISCONNECT or TRANSCEIVE maybe PEEK
        pInBuffer,
        InBufLen,
        pOutBuffer,	// Xceive or Peek buffer NULL otherwise
        OutBufLen	// Xceive or peek buffer length 0L otherwise
    );

    lstatus = TransactNamedPipe(lhandle,        // pipe handle
                                pInBuffer,      // write buffer
                                InBufLen,       // write buffer length
                                pOutBuffer,     // read buffer
                                OutBufLen,      // read buffer length
                                &actOutBufLen,  // the actual number of bytes read from the buffer
                                NULL);
    if (lstatus == STATUS_PENDING) {
        lstatus = WaitForSingleObjectEx(lhandle,
                                        INFINITE,
                                        TRUE);
        if (NT_SUCCESS(lstatus)) {
	        lstatus = ioStatusBlock.Status;
            if (!NT_SUCCESS(lstatus) &&(FsControlCode != FSCTL_PIPE_TRANSCEIVE)) {
                //DbgPrint("Listen/Disconn/Xceive failed, err=%lx\n", lstatus);
            }
	    }
	    else {
            //DbgPrint("Error in Wait while FsCtrl %lx\n",lstatus);}
        }
    else {
	    if (NT_SUCCESS(lstatus)) {
            lstatus = ioStatusBlock.Status;
        }
        else {
            //DbgPrint("Error in FSCTL: %lx\n", lstatus);
        }
    }

    return(lstatus);

}
/*
/************************************************************************/
/*++
    This routine does handshake with it's peer. For Server this means
    receiving request message from a client. For Client it means just the
    opposite.
--*/

NTSTATUS
NMP_DoHandshake(
  IN  USHORT CIndex,	// client index and namedpipe instance number
  IN  USHORT SrvCli     // if it's a server or client
)	
{
    NTSTATUS	dstatus;
    ULONG	    RWLen;
    ULONG	    RWreqLen;

    RWreqLen = sizeof(struct reqbuf);
    // for server do receive for a request buffer

    if (SrvCli) {
        dstatus = ReadNamedPipe(
			            Clients[CIndex].c_Nmp.c_PipeHandle,
			            RWreqLen,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (PULONG) &RWLen);
        if (!NT_SUCCESS(dstatus)) {
            //DbgPrint("Nmp: Error in ReadNamedPipe: err:%lx \n", dstatus);
            return dstatus;
        }

    }
    else { // for Client do send of reqbuf size
           // Based on TestCmd make changes i.e. 'U'->'P'
        dstatus = WriteNamedPipe(
			                Clients[CIndex].c_Nmp.c_PipeHandle,
			                RWreqLen,
			                (PVOID) &(Clients[CIndex].c_reqbuf),
			                (PULONG) &RWLen);
        if (!NT_SUCCESS(dstatus)) {
            //DbgPrint("Nmp: Error in WriteNamedPipe: err:%lx \n", dstatus);
            return dstatus;
        }
    }
    // check if read/write length is ok
    if (RWLen != sizeof(struct reqbuf)) {
        //DbgPrint("Nmp: Read/WriteNamedPipe Len mismatch: read %ld \n", RWLen);
    }
    // MyDbgPrint("handshake: Sendl:%ld Recvl:%ld \n",Clients[CIndex].c_reqbuf.SendSize,Clients[CIndex].c_reqbuf.RecvSize);
    return dstatus;
}

/************************************************************************/
/*++
    This routine Reads data from IPC.  For server it means reading data
    NumSends times in SendBuffers and for a client NumRecvs times into
    RecvBuffer.

--*/

NTSTATUS
NMP_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli)    // if it's a server or client
{
    NTSTATUS	rstatus;
    ULONG	    NumReads;
    ULONG	    ReadLen;
    PCHAR	    ReadBuf;	

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumReads = Clients[CIndex].c_reqbuf.NumSends;
        ReadBuf  = Clients[CIndex].c_pSendBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    else { // for client do proper settings
	    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    while (NumReads--) {
        rstatus = ReadNamedPipe(
			        Clients[CIndex].c_Nmp.c_PipeHandle,
			        ReadLen,
			        (PVOID) ReadBuf,
			        (PULONG) pReadDone);
        if (!NT_SUCCESS(rstatus)) {
            //DbgPrint("Nmp: Error in ReadNamedPipe: err:%lx \n", rstatus);
            break;
        }
    }
    return rstatus;
}
/************************************************************************/
NTSTATUS
ReadNamedPipe(
    IN     HANDLE	rhandle,
    IN	   ULONG	rlength,
    IN OUT PVOID	rpbuffer,
    IN OUT PULONG	rpdatalen)
{
    NTSTATUS		rstatus;
    DWORD           actRLength;

    rstatus = ReadFile( rhandle,        // pipe handle
                        rpbuffer,       // buffer to receive reply
                        rlength,        // size of the buffer
                        &actRLength,    // number of bytes read
                        NULL);          // not overlapped
    if (rstatus == TRUE) {
        *rpdatalen = actRLength;
    }
    else {
        if (GetLastError() == ERROR_MORE_DATA) {
            rstatus = WaitForSingleObjectEx(rhandle,
                                            INFINITE,
                                            TRUE);
            if (rstatus == TRUE) {
                *rpdatalen = actRLength;
                if (rlength != *rpdatalen) {
                    printf("Error: No. of bytes read != buffer length\n");
                }
            }
        }
    }
    return(rstatus);
}

/************************************************************************/
/*++
    This routine Writes data to IPC.  For server it means writing data
    NumRecvs times in RecvBuffers and for a client NumSends times into
    SendBuffer.

--*/

NTSTATUS
NMP_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli)    // if it's a server or client
{
    NTSTATUS	wstatus;
    ULONG	    NumWrites;
    ULONG	    WriteLen;
    PCHAR	    WriteBuf;	

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumWrites = Clients[CIndex].c_reqbuf.NumRecvs;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
	    NumWrites = Clients[CIndex].c_reqbuf.NumSends;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    while (NumWrites--) {
        wstatus = WriteNamedPipe(
			            Clients[CIndex].c_Nmp.c_PipeHandle,
			            WriteLen,
			            (PVOID) WriteBuf,
			            (PULONG) pWriteDone);
        if (!NT_SUCCESS(wstatus)) {
            //DbgPrint("Nmp: Error in WriteNamedPipe: err:%lx \n", wstatus);
            break;
        }
    }
    return wstatus;
}

/************************************************************************/
/*++
    This routine does transaction type IO  to IPC. This just assumes that
    both Number of reads and writes are equal and will use Number of reads
    as it's basis.

--*/

NTSTATUS
NMP_XactIO(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli,     // if it's a server or client
  IN	 BOOLEAN FirstIter)  // ignore for NamedPipe
{
    NTSTATUS	xstatus;
    ULONG	    NumReads;
    ULONG	    ReadLen;
    PCHAR	    ReadBuf;	
    ULONG	    WriteLen;
    PCHAR	    WriteBuf;	
    DWORD       actReadLen;

    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;

    if (SrvCli) {  // set proper iterations and buffer for Server
        ReadBuf   = Clients[CIndex].c_pSendBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.SendSize;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
        ReadBuf   = Clients[CIndex].c_pRecvBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.RecvSize;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    while (NumReads--) {
        xstatus = TransactNamedPipe(Clients[CIndex].c_Nmp.c_PipeHandle, // pipe name
                                    WriteBuf,                           // write buffer
                                    WriteLen,                           // write buffer length
                                    ReadBuf,                            // read buffer
                                    ReadLen,                            // read buffer length
                                    &actReadLen,                        // actual read buffer length
                                    NULL);                              // not overlapped
        if (xstatus == FALSE) {
            printf("Error: TransactNamedPipe failed - 0x%08x\n", GetLastError());
            *pReadDone  = 0L;
            *pWriteDone = 0L;
            break;
        }
        *pReadDone  = ReadLen;
        *pWriteDone = WriteLen;
    }
    return xstatus;
}

/************************************************************************/
NTSTATUS
WriteNamedPipe(
    IN     HANDLE	whandle,
    IN	   ULONG	wlength,
    IN OUT PVOID	wpbuffer,
    IN OUT PULONG	wpdatalen)
{
    NTSTATUS		wstatus;
    DWORD           actWLength;

    wstatus = WriteFile(whandle,    // pipe handle
                        wpbuffer,   // address of data buffer to write to file
                        wlength,    // length of data buffer
                        &actWLength,// actual length of data read
                        NULL);      // not overlapped
    if (wstatus == TRUE) {
        *wpdatalen = actWLength;
    }
    else {
        if (GetLastError() == ERROR_MORE_DATA) {
            wstatus = WaitForSingleObjectEx(whandle,
                                            INFINITE,
                                            TRUE);
            if (wstatus == TRUE) {
                *wpdatalen = actWLength;
                if (wlength != *wpdatalen) {
                    printf("Error: No. of bytes written != buffer length\n");
                }
            }
        }
    }
    return(wstatus);
}
/************************************************************************/
// this is now a win32 defined function
/*
NTSTATUS DisconnectNamedPipe(IN HANDLE dhandle)
{

    NTSTATUS		wstatus;
//  IO_STATUS_BLOCK 	ioStatusBlock;
    wstatus = NamedPipe_FsControl(	// post DisConnect
		    dhandle,
		    FSCTL_PIPE_DISCONNECT,
		    NULL,	// input buffer
		    0L,		// inbuf len
		    NULL,	// output buffer
		    0L);	// outbuf len
    if (!NT_SUCCESS(wstatus)) {
        //DbgPrint ("Pipe Disconnect failed, err=%lx\n", wstatus);
    }
    return(wstatus);
}
*/

/************************************************************************/
/*++ This routine creates one instance of NamedPipe for a given client.
     A client is identified by its index number.
--*/

NTSTATUS
CreateNamedPipeInstance(
  IN  USHORT Nindex)	// client index and namedpipe instance number
{
    NTSTATUS    nstatus = 0;
    HANDLE		NMPhandle;

    NMPhandle = CreateNamedPipe(pipeName,                       // the given pipe name entered by the user
                                PIPE_ACCESS_DUPLEX,             // GENERIC_READ | GENERIC_WRITE
                                PIPE_READMODE_MESSAGE |         // pipe mode (message...)
                                PIPE_TYPE_MESSAGE     |
                                PIPE_WAIT,
                                NClients,                       // max number of instances(clients)
                                Quotas,                         // max in buffer length
                                Quotas,                         // max out buffer length
                                600000,                          // 60 second default timeout
                                NULL);                          // default security attributes
    if (NMPhandle == INVALID_HANDLE_VALUE) {
        nstatus = GetLastError();
        printf ("Failed to Create NamedPipe, err=%lx, %ld\n", nstatus, nstatus);
    }
    else {
        // initialize this client's values
        Clients[Nindex].c_Nmp.c_PipeHandle = NMPhandle;
        Clients[Nindex].c_client_num = Nindex;//index into the Client array
    }
    return(nstatus);
}
/************************************************************************/
NTSTATUS
NMP_Cleanup(VOID)
{
    return STATUS_SUCCESS;
}
/************************************************************************/

/*++
     This routine does a client specific cleanup work.
--*/

NTSTATUS
NMP_ThreadCleanUp(
  IN  USHORT CIndex)
{
    return STATUS_SUCCESS;
}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\sct.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       sct.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: sct.c
//
// Description: This file contains common routines for socket I/O
//              routines for use with IPC raw network performance
//              tests.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "sct.h"

/************************************************************************/
// Socket specific functions
/************************************************************************/

INTEGER
TCPSocket_Connect(
    IN  int	AddrFly,
    IN  USHORT	CIndex,
    IN	PCHAR	srvaddr)
{

    INTEGER 		RetCode;
    SOCKADDR		csockaddr;   // socket address for connecting

    PSOCKADDR_IN	paddr_in = (PSOCKADDR_IN)&csockaddr;

    paddr_in->sin_family        = (short)AddrFly;

    // use port number based on either client number or machine number
    // i.e. if NClients > MachineNumber then use CIndex otherwise use
    // machine number. We can run one client each from different machines
    // or run multiple clients from same machine.

    paddr_in->sin_port	    	= htons((USHORT)(SERV_TCP_PORT + CIndex));
    paddr_in->sin_addr.s_addr   = inet_addr(srvaddr);


    RetCode=connect(Clients[CIndex].c_Sock.c_Sockid,
		        &csockaddr,
		        sizeof(SOCKADDR));

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Connect:%ld\n",WSAGetLastError());
    }
    //MyDbgPrint("Successfully connected \n");

    return(RetCode);
}
/************************************************************************/
/*++
    This routine just initializes for socket programming
--*/

NTSTATUS
SCTCP_Initialize(

    IN	    USHORT	NClients,   // Number of clients
    IN	    PCHAR	ServerName, // Server IP address
    IN      USHORT	SrvCli)	    // server or client
{

    INTEGER 		RetCode = 0;
    WSADATA		WsaData;	// got from RCP prog

    RetCode = WSAStartup(0x0101, &WsaData);

    if (RetCode == SOCKET_ERROR) {
	    //DbgPrint("Error: WSAStartup : %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);
}
/************************************************************************/

/*++
     This routine is responsible Creating a Socket instance  and doing bind for
     for a thread.

--*/

NTSTATUS
SCTCP_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli )	
{
    //NTSTATUS	pstatus;
    INTEGER	    RetCode;
    SOCKADDR	saddr;		// socket address
    //INTEGER	    saddrlen;
    SOCKET	    isockid;

    // We can combine this with SPX routines later
    PSOCKADDR_IN	paddr_in = (PSOCKADDR_IN)&saddr;
    int			protocol = IPPROTO_TCP;

    // First create a socket for this client
    if ((isockid = socket(AddrFly, SOCK_STREAM, protocol)) == INVALID_SOCKET) {
	    //DbgPrint("Error: Invalid Socket: %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }

    Clients[CIndex].c_Sock.c_Sockid = isockid;

    // now do the address binding part
    // should get ip address from Name

    ClearSocket(&saddr);		// cleanup the structure
    paddr_in->sin_family      = (short)AddrFly;

    if (SrvCli) { // if it's a server only then do the binding
        paddr_in->sin_port        = htons((USHORT)(SERV_TCP_PORT + CIndex));
        paddr_in->sin_addr.s_addr = inet_addr(HostName); // use htonl
    }
    else { // for client assign socket id.
        paddr_in->sin_port        = 0;
        paddr_in->sin_addr.s_addr = 0;
    }

    RetCode = bind(isockid, &saddr, sizeof(saddr));

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Bind: %ld\n",WSAGetLastError());;
        closesocket(isockid);
        return (STATUS_UNSUCCESSFUL);
    }
    else {
        if (SrvCli) { Clients[CIndex].c_Sock.c_Listenid = isockid; }
        else        { Clients[CIndex].c_Sock.c_Sockid   = isockid; }
    }

    // post a listen  if it's a server
    if (SrvCli) {
        if (RetCode = Socket_Listen(CIndex) == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Listen %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
	// Listen posted Successfully
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Listen and waiting till a
     client is connected. When this routine returns successfully we can
     assume that a connection is established.
--*/

NTSTATUS
SCTCP_Wait_For_Client(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    //NTSTATUS	wstatus;
    INTEGER	    RetCode;

/*
    // post a listen
    if (RetCode = Socket_Listen(CIndex) == SOCKET_ERROR) {
        DbgPrint("Sock: Error in Listen %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }

    // If listen was completed successfully then accept the connection
*/
    if (RetCode = Socket_Accept(CIndex) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Accept %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Disconnect to close the
     connection with a client.
--*/

NTSTATUS
SCTCP_Disconnect_Client(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;

    //Close the socket so that it can disconnect
    if ( (RetCode = Socket_Close(CIndex)) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Close Sockid %d\n", RetCode);
        // return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for establishing a connection to the
     server side. When this routine returns successfully we can assume that
     a connection is established.
--*/

NTSTATUS
SCTCP_Connect_To_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;

    RetCode = TCPSocket_Connect(AddrFly, CIndex, ServerName);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Connect %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
	
}

/************************************************************************/
/*++
    This routine allocates memory required for all the buffers for a client.

--*/

NTSTATUS
SCTCP_Allocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    //NTSTATUS	astatus;
    ULONG	    AllocSize;

    // AllocSize = Clients[CIndex].c_reqbuf.SendSize;
    AllocSize = MAXBUFSIZE;

    // Allocate memory for Send Buffer
    //MyDbgPrint("Alloc Send Buf: %ld \n", Clients[CIndex].c_reqbuf.SendSize);
/*
    astatus = NtAllocateVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		0L,
		&(AllocSize),
		MEM_COMMIT,
		PAGE_READWRITE);

    if (!NT_SUCCESS(astatus)) {
        DbgPrint("Nmp SendBuf: Allocate memory failed: err: %lx \n", astatus);
        return astatus;
    }
*/
    (LPVOID) Clients[CIndex].c_pSendBuf = VirtualAlloc(
                                         (LPVOID) Clients[CIndex].c_pSendBuf,
                                         (DWORD)AllocSize,
                                         (DWORD)MEM_COMMIT,
                                         (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pSendBuf,"Client%d Send Data", CIndex+1);


    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;

    //MyDbgPrint("Alloc: Recv Buf: %ld \n", Clients[CIndex].c_reqbuf.RecvSize);

    // Allocate memory for Receive Buffer
/*
    astatus = NtAllocateVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		0L,
		&(AllocSize),
		MEM_COMMIT,
		PAGE_READWRITE);

    if (!NT_SUCCESS(astatus)) {
        DbgPrint("Nmp RecvBuf :Allocate memory failed: err: %lx \n", astatus);
        return astatus;
    }
*/
    (LPVOID) Clients[CIndex].c_pRecvBuf = VirtualAlloc(
                                            (LPVOID) Clients[CIndex].c_pRecvBuf,
                                            (DWORD)AllocSize,
                                            (DWORD)MEM_COMMIT,
                                            (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pRecvBuf,"Client%d Recv Data", CIndex+1);

    //return astatus;
    return STATUS_SUCCESS;
}
/************************************************************************/
/*++
    This routine deallocates memory for a client.

--*/

NTSTATUS
SCTCP_Deallocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	dstatus;
    ULONG	    DeallocSize;

    // Deallocate memory for Send Buffer
    // DeallocSize = Clients[CIndex].c_reqbuf.SendSize;
    DeallocSize = MAXBUFSIZE;

    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pSendBuf,
                   DeallocSize,
                   MEM_DECOMMIT);

    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp SendBuf: Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }

    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Receive Buffer
    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */

    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pRecvBuf,
                   DeallocSize,
                   MEM_DECOMMIT);

    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
    }

   return dstatus;

}
/************************************************************************/
/*++
     This routine is responsible for disconnecting a session.

--*/

NTSTATUS
SCTCP_Disconnect_From_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;

    //Close the socket so that it can disconnect
    if ( (RetCode = Socket_Close(CIndex)) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Close Sockid %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does handshake with it's peer. For Server this means
    receiving request message from a client. For Client it means just the
    opposite.
--*/

NTSTATUS
SCTCP_DoHandshake(
  IN  USHORT CIndex,	// client index
  IN  USHORT SrvCli     // if it's a server or client
)	
{
    ULONG	RWreqLen;
    INTEGER	RetCode = 0;

    RWreqLen = sizeof(struct reqbuf);

    // for server do receive for a request buffer

    if (SrvCli) {
        RetCode = Socket_Recv(
			        CIndex,
			        (PVOID) &(Clients[CIndex].c_reqbuf),
			        (PULONG) &RWreqLen);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Recv %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
    }
    else { // for Client do send of reqbuf size

        // Based on TestCmd make changes i.e. 'U'->'P'
        RetCode = Socket_Send(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (PULONG) &RWreqLen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Send %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
    }

    // check if read/write length is ok
    if (RWreqLen != sizeof(struct reqbuf)) {
        //DbgPrint("Sock:Read/Write Len mismatch: read %ld \n", RWreqLen);
    }
    /*
    MyDbgPrint("handshake: Sendl:%ld Recvl:%ld \n",
              Clients[CIndex].c_reqbuf.SendSize,
              Clients[CIndex].c_reqbuf.RecvSize);
    */
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Reads data from IPC.  For server it means reading data
    NumSends times in SendBuffers and for a client NumRecvs times into
    RecvBuffer.

--*/

NTSTATUS
SCTCP_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli     // if it's a server or client
)	
{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    INTEGER	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumReads = Clients[CIndex].c_reqbuf.NumSends;
        ReadBuf  = Clients[CIndex].c_pSendBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.SendSize;

    }
    else { // for client do proper settings
	    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }

    while (NumReads--) {
        RetCode =  Socket_Recv(
                        CIndex,
			            (PVOID) ReadBuf,
			            (PULONG)&ReadLen);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Recv %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Assign the read length
        *pReadDone = ReadLen;
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Writes data to IPC.  For server it means writing data
    NumRecvs times in RecvBuffers and for a client NumSends times into
    SendBuffer.

--*/

NTSTATUS
SCTCP_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli     // if it's a server or client
)	
{
    ULONG	NumWrites;
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    INTEGER	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumWrites = Clients[CIndex].c_reqbuf.NumRecvs;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
	    NumWrites = Clients[CIndex].c_reqbuf.NumSends;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    while (NumWrites--) {
        RetCode =  Socket_Send(
			            CIndex,
			            (PVOID) WriteBuf,
			            (PULONG) &WriteLen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Send %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        *pWriteDone = WriteLen;
    }
    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
    This routine does transaction type IO  to IPC. This just assumes that
    both Number of reads and writes are equal and will use Number of reads
    as it's basis.

--*/

NTSTATUS
SCTCP_XactIO(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli,     // if it's a server or client
  IN	 BOOLEAN FirstIter
)	
{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    //INTEGER	RetCode;

    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;

    if (SrvCli) {  // set proper iterations and buffer for Server
        ReadBuf   = Clients[CIndex].c_pSendBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.SendSize;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
/*
    while (NumReads--) {

        *pReadDone  = ReadLen;
        *pWriteDone = WriteLen;
    }
*/
    return (STATUS_SUCCESS);
}

/************************************************************************/
NTSTATUS
SCTCP_Cleanup(VOID)
{
    USHORT		Cindex = 0; // client index
    //NTSTATUS 	cstatus;
    NTSTATUS 	exitstatus = 0;
/*
    for (Cindex = 0; Cindex < NClients; Cindex++) {

	// if the client was used then close the NamedPipe handle
        cstatus = NtClose (Clients[Cindex].c_Nmp.c_PipeHandle);
	
    	if (!NT_SUCCESS(cstatus)) {
           printf("Failed to close NMPhandle thno:%d err=%lx\n",
	      Cindex,cstatus);
    	}

	// terminate the thread
       cstatus = NtTerminateThread(
	    Clients[Cindex].c_hThHandle,
	    exitstatus);

       if (!NT_SUCCESS(cstatus)) {
            printf("Failed to terminate thread no:%d err=%lx\n",
	   Cindex,cstatus);
    	}
    }
*/
    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
     This routine does a client specific cleanup work.
--*/

NTSTATUS
SCTCP_ThreadCleanUp(
  IN  USHORT CIndex
)
{
    //NTSTATUS	tstatus;
    // For Server Close the ListenId

    return STATUS_SUCCESS;
}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\scipx.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       scipx.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: scipx.c
//
// Description: This file contains common routines for socket I/O
//              routines for use with IPC raw network performance
//              tests.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "scipx.h"

/************************************************************************/

NTSTATUS
SCIPX_Initialize(

    IN	    USHORT	NClients,   // Number of clients
    IN	    PCHAR	ServerName, // Server IP address
    IN      USHORT	SrvCli)	    // server or client
{
    INTEGER 	RetCode = 0;
    WSADATA		WsaData;	// got from RCP prog

    RetCode = WSAStartup(0x0101, &WsaData);

    if (RetCode == SOCKET_ERROR) {
	    //DbgPrint("Error: WSAStartup : %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);
}
/************************************************************************/

/*++
     This routine is responsible Creating a Socket instance  and doing bind for
     for a thread.

--*/

NTSTATUS
SCIPX_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli )	
{
    NTSTATUS	pstatus;
    INTEGER	    RetCode;
    SOCKADDR	saddr;		// socket address
    INTEGER	    saddrlen;
    SOCKET	    isockid;

    // We can combine this with SPX routines later
    PSOCKADDR_NS	paddr_ns = (PSOCKADDR_NS)&saddr;
    int			    protocol = NSPROTO_IPX;

    // First create a socket for this client
    if ((isockid = socket(AddrFly, SOCK_DGRAM, protocol)) == INVALID_SOCKET) {
	    //DbgPrint("Error: Invalid Socket: %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }
    Clients[CIndex].c_Sock.c_Sockid = isockid;

    // now do the address binding part
    // should get ip address from Name

    ClearSocket(&saddr);		// cleanup the structure
    paddr_ns->sa_family = (short)AddrFly;

    if (SrvCli) { //
        paddr_ns->sa_socket = htons((USHORT)(SERV_IPX_PORT + CIndex));
    }
    else { // for client assign socket id.
        paddr_ns->sa_socket = 0;
    }

    RetCode = bind(isockid, &saddr, sizeof(saddr));

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Bind: %ld\n",WSAGetLastError());;
        closesocket(isockid);
        return (STATUS_UNSUCCESSFUL);
    }
    else {
        Clients[CIndex].c_Sock.c_Sockid   = isockid;
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for Connecting a server address to a
     socket if Connected flag is true.
--*/

NTSTATUS
SCIPX_Connect_To_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;
    SOCKADDR_NS	saddr;		// socket address

    saddr.sa_family       = (short)AddrFly;		// Address family
    saddr.sa_socket       = htons((USHORT)(SERV_IPX_PORT + CIndex));

    RtlCopyMemory((saddr.sa_nodenum), ServerName,6);
    RtlCopyMemory((saddr.sa_netnum), ServerName+6,4);

    RetCode = DGSocket_Connect(CIndex, (PSOCKADDR)&saddr);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Connect %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine allocates memory required for all the buffers for a client.

--*/

NTSTATUS
SCIPX_Allocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	astatus;
    ULONG	AllocSize;

    // AllocSize = Clients[CIndex].c_reqbuf.SendSize;
    AllocSize = MAXBUFSIZE;
    (LPVOID) Clients[CIndex].c_pSendBuf = VirtualAlloc(
                                         (LPVOID) Clients[CIndex].c_pSendBuf,
                                         (DWORD)AllocSize,
                                         (DWORD)MEM_COMMIT,
                                         (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pSendBuf,"Client%d Send Data",CIndex+1);
    if (Clients[CIndex].c_pSendBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;
    (LPVOID) Clients[CIndex].c_pRecvBuf = VirtualAlloc(
                                            (LPVOID) Clients[CIndex].c_pRecvBuf,
                                            (DWORD)AllocSize,
                                            (DWORD)MEM_COMMIT,
                                            (DWORD)PAGE_READWRITE);
    sprintf(Clients[CIndex].c_pRecvBuf,"Client%d Recv Data",CIndex+1);
    if (Clients[CIndex].c_pRecvBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    return astatus;
}

/************************************************************************/
/*++
    This routine deallocates memory for a client.

--*/

NTSTATUS
SCIPX_Deallocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	dstatus;
    ULONG	DeallocSize;

    // Deallocate memory for Send Buffer
    // DeallocSize = Clients[CIndex].c_reqbuf.SendSize;
    DeallocSize = MAXBUFSIZE;
    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                       (LPVOID) Clients[CIndex].c_pSendBuf,
                       DeallocSize,
                       MEM_DECOMMIT);
    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp SendBuf: Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }

    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Receive Buffer
    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pRecvBuf,
                   DeallocSize,
                   MEM_DECOMMIT);
    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
    }
    return dstatus;
}
/************************************************************************/
/*++
     This routine is responsible for disconnecting a session.

--*/

NTSTATUS
SCIPX_Disconnect_From_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;

    //Close the socket so that it can disconnect
    if ( (RetCode = DGSocket_Close(CIndex)) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Close Sockid %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does handshake with it's peer. For Server this means
    receiving request message from a client. For Client it means just the
    opposite.
--*/

NTSTATUS
SCIPX_DoHandshake(
  IN  USHORT CIndex,	// client index
  IN  USHORT SrvCli)    // if it's a server or client
{
    ULONG	RWreqLen;
    INTEGER	RetCode = 0;
    SOCKADDR_NS	daddr;
    USHORT	daddrlen = 16;

    RWreqLen = sizeof(struct reqbuf);

    // for server do receivefrom for a request buffer
    if (SrvCli) {
        RetCode = DGSocket_RecvFrom(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (PULONG) &RWreqLen,
			            (PSOCKADDR)&daddr,
 			            &daddrlen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Recv %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Now connect this address to client's Socket
        RetCode = DGSocket_Connect(CIndex, (PSOCKADDR)&daddr);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Connect %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
    }
    else { // for Client do send of reqbuf size
       // Client always does Send
       RetCode = DGSocket_Send(
		                CIndex,
		                (PVOID) &(Clients[CIndex].c_reqbuf),
		                (PULONG) &RWreqLen);
       if (RetCode == SOCKET_ERROR) {
           //DbgPrint("Sock: Error in Send %d\n", RetCode);
           return (STATUS_UNSUCCESSFUL);
       }
    }
    // check if read/write length is ok
    if (RWreqLen != sizeof(struct reqbuf)) {
        //DbgPrint("Sock:Read/Write Len mismatch: read %ld \n", RWreqLen);
    }
    /*
    MyDbgPrint("handshake: Sendl:%ld Recvl:%ld \n",
              Clients[CIndex].c_reqbuf.SendSize,
              Clients[CIndex].c_reqbuf.RecvSize);
    */
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Reads data from IPC.  For server it means reading data
    NumSends times in SendBuffers and for a client NumRecvs times into
    RecvBuffer.

--*/

NTSTATUS
SCIPX_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli)    // if it's a server or client
{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    INTEGER	RetCode;
    // SOCKADDR_NS raddr;
    // INTEGER	raddrlen;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumReads = Clients[CIndex].c_reqbuf.NumSends;
        ReadBuf  = Clients[CIndex].c_pSendBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    else { // for client do proper settings
	    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    while (NumReads--) {
        RetCode =  DGSocket_Recv(
                        CIndex,
	   	                (PVOID) ReadBuf,
			            (PULONG)&ReadLen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("DGSock: Error in Recv %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Assign the read length
        *pReadDone = ReadLen;
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Writes data to IPC.  For server it means writing data
    NumRecvs times in RecvBuffers and for a client NumSends times into
    SendBuffer.

--*/

NTSTATUS
SCIPX_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli)    // if it's a server or client
{
    ULONG	NumWrites;
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    INTEGER	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumWrites = Clients[CIndex].c_reqbuf.NumRecvs;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
	    NumWrites = Clients[CIndex].c_reqbuf.NumSends;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    while (NumWrites--) {
        RetCode =  DGSocket_Send(
		                CIndex,
		                (PVOID) WriteBuf,
		                (PULONG) &WriteLen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Send %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        *pWriteDone = WriteLen;
    }
    return (STATUS_SUCCESS);
}
/************************************************************************/
NTSTATUS
SCIPX_Cleanup(VOID)
{
    USHORT		    Cindex      = 0; // client index
    NTSTATUS 		cstatus;
    NTSTATUS 		exitstatus  = 0;

    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
     This routine does a client specific cleanup work.
--*/

NTSTATUS
SCIPX_ThreadCleanUp(
  IN  USHORT CIndex)
{
    // For Server Close the ListenId

    return STATUS_SUCCESS;
}
/************************************************************************/

/*++
    For IPX do nothing.
--*/

NTSTATUS
SCIPX_Wait_For_Client(
  IN  USHORT CIndex)	// client index
{
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Disconnect to close the
     connection with a client.
--*/

NTSTATUS
SCIPX_Disconnect_Client(
  IN  USHORT CIndex)	// client index
{
    INTEGER	RetCode;
    SOCKADDR_NS	daddr;		// socket address

    ClearSocket(&daddr);

    RetCode = DGSocket_Connect(CIndex, (PSOCKADDR)&daddr);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Sock: in Disconnect Client: Sock_Connect %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\scx.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       scx.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: scx.c
//
// Description: This file contains the source code for common routines
//              use for Socket I/O.
//              This module is written using win32 API calls.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "scx.h"
#include "msipx.h"

/************************************************************************/
// Socket specific functions
/************************************************************************/
INTEGER
SPXSocket_Connect(
    IN  int	AddrFly,
    IN  USHORT	CIndex,
    IN	PCHAR	srvaddr)
{

    INTEGER 		RetCode;
    SOCKADDR		csockaddr;   // socket address for connecting
    // CHAR		Tmp[12];

    PSOCKADDR_NS	paddr_ns = (PSOCKADDR_NS)&csockaddr;

    paddr_ns->sa_family        = (short)AddrFly;
    paddr_ns->sa_socket	       = htons((USHORT)(SERV_SPX_PORT + CIndex));

    // Now copy both 6 byte NodeNumber and 4 byte NetNumber

    RtlCopyMemory(paddr_ns->sa_nodenum,srvaddr,6);
    RtlCopyMemory(paddr_ns->sa_netnum,srvaddr+6,4);

/*
    RtlCopyMemory(Tmp, srvaddr, 10); Tmp[10] = '\0';
    DbgPrint("Server address %s %X\n",Tmp, Tmp);
*/

    RetCode=connect(Clients[CIndex].c_Sock.c_Sockid,
		        &csockaddr,
		        sizeof(SOCKADDR));

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Connect:%ld\n",WSAGetLastError());
    }

    // MyDbgPrint("Successfully connected \n");

    return(RetCode);
}
/************************************************************************/
/*++
    This routine just initializes for socket programming
--*/

NTSTATUS
SCXNS_Initialize(

    IN	    USHORT	NClients,   // Number of clients
    IN	    PCHAR	ServerName, // Server IP address
    IN      USHORT	SrvCli)	    // server or client
{

    INTEGER 		RetCode = 0;
    WSADATA		WsaData;	// got from RCP prog

    RetCode = WSAStartup(0x0101, &WsaData);

    if (RetCode == SOCKET_ERROR) {
	    //DbgPrint("Error: WSAStartup : %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }

    return(STATUS_SUCCESS);
}
/************************************************************************/

/*++
     This routine is responsible Creating a Socket instance  and doing bind for
     for a thread.

--*/

NTSTATUS
SCXNS_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli )	
{
    //NTSTATUS	pstatus;
    INTEGER	    RetCode;
    SOCKADDR	saddr;		// socket address
    //INTEGER	    saddrlen;
    SOCKET	    isockid;

    // We can combine this with SPX routines later
    PSOCKADDR_NS	paddr_ns = (SOCKADDR_NS *) &saddr;
    int			    protocol = NSPROTO_SPX;

    // First create a socket for this client
    if ((isockid = socket(AddrFly, SOCK_STREAM, protocol)) == INVALID_SOCKET) {
	    //DbgPrint("Error: Invalid Socket: %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }

    Clients[CIndex].c_Sock.c_Sockid = isockid;

    // now do the address binding part
    // should get ip address from Name

    ClearSocket(&saddr);		// cleanup the structure
    paddr_ns->sa_family      = (short)AddrFly;

    if (SrvCli) { // if it's a server only then do the binding
        paddr_ns->sa_socket        = htons((USHORT)(SERV_SPX_PORT + CIndex));
    }
    else { // for client assign socket id.
        paddr_ns->sa_socket       = 0;
    }

    RetCode = bind(isockid, &saddr, sizeof(saddr));

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Bind: %ld\n",WSAGetLastError());;
        closesocket(isockid);
        return (STATUS_UNSUCCESSFUL);
    }
    else {
        if (SrvCli) {
            Clients[CIndex].c_Sock.c_Listenid = isockid;
        }
        else {
            Clients[CIndex].c_Sock.c_Sockid   = isockid;
        }
    }

    // post a listen  if it's a server
    if (SrvCli) {
        if (RetCode = Socket_Listen(CIndex) == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Listen %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
	// Listen posted Successfully
        // DbgPrint("SPX Srv: Listen posted successfully\n");
    }

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Listen and waiting till a
     client is connected. When this routine returns successfully we can
     assume that a connection is established.
--*/

NTSTATUS
SCXNS_Wait_For_Client(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    //NTSTATUS	wstatus;
    INTEGER	    RetCode;

    if (RetCode = Socket_Accept(CIndex) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Accept %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    //DbgPrint("SPX: Client connection accepted\n");

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Disconnect to close the
     connection with a client.
--*/

NTSTATUS
SCXNS_Disconnect_Client(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;

    //Close the socket so that it can disconnect
    if ( (RetCode = Socket_Close(CIndex)) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Close Sockid %d\n", RetCode);
        // return (STATUS_UNSUCCESSFUL);
    }

   return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for establishing a connection to the
     server side. When this routine returns successfully we can assume that
     a connection is established.
--*/

NTSTATUS
SCXNS_Connect_To_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;

    RetCode = SPXSocket_Connect(AddrFly, CIndex, ServerName);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Connect %d\n", RetCode);
        printf("SPXSocket_Connecy error \n");
        return (STATUS_UNSUCCESSFUL);
    }
    //DbgPrint("SPX: Client connected to the server \n");

   return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine allocates memory required for all the buffers for a client.

--*/

NTSTATUS
SCXNS_Allocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	astatus = STATUS_SUCCESS;
    ULONG	    AllocSize;

    // AllocSize = Clients[CIndex].c_reqbuf.SendSize;
    AllocSize = MAXBUFSIZE;

    (LPVOID) Clients[CIndex].c_pSendBuf = VirtualAlloc(
                                         (LPVOID) Clients[CIndex].c_pSendBuf,
                                         (DWORD)AllocSize,
                                         (DWORD)MEM_COMMIT,
                                         (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pSendBuf,"Client%d Send Data",CIndex+1);
    if (Clients[CIndex].c_pSendBuf == NULL) {
        astatus = GetLastError();
    }
    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;

    (LPVOID) Clients[CIndex].c_pRecvBuf = VirtualAlloc(
                                            (LPVOID) Clients[CIndex].c_pRecvBuf,
                                            (DWORD)AllocSize,
                                            (DWORD)MEM_COMMIT,
                                            (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pRecvBuf,"Client%d Recv Data",CIndex+1);
    if (Clients[CIndex].c_pRecvBuf == NULL) {
        astatus = GetLastError();
    }
    return astatus;
}
/************************************************************************/
/*++
    This routine deallocates memory for a client.

--*/

NTSTATUS
SCXNS_Deallocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	dstatus;
    ULONG	DeallocSize;

    // Deallocate memory for Send Buffer
    // DeallocSize = Clients[CIndex].c_reqbuf.SendSize;
    DeallocSize = MAXBUFSIZE;
/*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
*/
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pSendBuf,
                   DeallocSize,
                   MEM_DECOMMIT);

    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp SendBuf: Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }

    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Receive Buffer
/*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
*/
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pRecvBuf,
                   DeallocSize,
                   MEM_DECOMMIT);

    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
    }

   return dstatus;

}
/************************************************************************/
/*++
     This routine is responsible for disconnecting a session.

--*/

NTSTATUS
SCXNS_Disconnect_From_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{

    INTEGER	RetCode;

    //Close the socket so that it can disconnect
    if ( (RetCode = Socket_Close(CIndex)) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Close Sockid %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
   return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does handshake with it's peer. For Server this means
    receiving request message from a client. For Client it means just the
    opposite.
--*/

NTSTATUS
SCXNS_DoHandshake(
  IN  USHORT CIndex,	// client index
  IN  USHORT SrvCli     // if it's a server or client
)	
{
    ULONG	RWreqLen;
    INTEGER	RetCode = 0;

    RWreqLen = sizeof(struct reqbuf);

    // for server do receive for a request buffer
    if (SrvCli) {
        RetCode = Socket_Recv(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (PULONG) &RWreqLen);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Recv %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        //DbgPrint("Srv handshake recv ok\n");
    }
    else { // for Client do send of reqbuf size

        // Based on TestCmd make changes i.e. 'U'->'P'
        RetCode = Socket_Send(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (PULONG) &RWreqLen);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Send %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        //DbgPrint("Cli handshake Send ok\n");
    }

    // check if read/write length is ok
    if (RWreqLen != sizeof(struct reqbuf)) {
        //DbgPrint("Sock:Read/Write Len mismatch: read %ld \n", RWreqLen);
    }

    /*
    MyDbgPrint("handshake: Sendl:%ld Recvl:%ld \n",
              Clients[CIndex].c_reqbuf.SendSize,
              Clients[CIndex].c_reqbuf.RecvSize);
    */

    return (STATUS_SUCCESS);

}

/************************************************************************/
/*++
    This routine Reads data from IPC.  For server it means reading data
    NumSends times in SendBuffers and for a client NumRecvs times into
    RecvBuffer.

--*/

NTSTATUS
SCXNS_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli     // if it's a server or client
)	

{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    INTEGER	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumReads = Clients[CIndex].c_reqbuf.NumSends;
        ReadBuf  = Clients[CIndex].c_pSendBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    else { // for client do proper settings
	    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }

    while (NumReads--) {
        RetCode =  Socket_Recv(
                        CIndex,
			            (PVOID) ReadBuf,
			            (PULONG)&ReadLen);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Recv %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }

        // Assign the read length
        *pReadDone = ReadLen;
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Writes data to IPC.  For server it means writing data
    NumRecvs times in RecvBuffers and for a client NumSends times into
    SendBuffer.

--*/

NTSTATUS
SCXNS_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli     // if it's a server or client
)	

{
    ULONG	NumWrites;
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    INTEGER	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumWrites = Clients[CIndex].c_reqbuf.NumRecvs;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
	    NumWrites = Clients[CIndex].c_reqbuf.NumSends;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }

    while (NumWrites--) {
        RetCode =  Socket_Send(
			            CIndex,
			            (PVOID) WriteBuf,
			            (PULONG) &WriteLen);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Send %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        *pWriteDone = WriteLen;
    }
    return (STATUS_SUCCESS);

}
/************************************************************************/
/*++
    This routine does transaction type IO  to IPC. This just assumes that
    both Number of reads and writes are equal and will use Number of reads
    as it's basis.

--*/

NTSTATUS
SCXNS_XactIO(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli,     // if it's a server or client
  IN	 BOOLEAN FirstIter
)	

{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    //INTEGER	RetCode;

    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;

    if (SrvCli) {  // set proper iterations and buffer for Server
        ReadBuf   = Clients[CIndex].c_pSendBuf;
        ReadLen   = Clients[CIndex].c_reqbuf.SendSize;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
/*
    while (NumReads--) {

        *pReadDone  = ReadLen;
        *pWriteDone = WriteLen;
    }
*/
    return (STATUS_SUCCESS);
}

/************************************************************************/
NTSTATUS
SCXNS_Cleanup(VOID)
{
    //USHORT	Cindex = 0; // client index
    //NTSTATUS  cstatus;
    //NTSTATUS	exitstatus = 0;

/*
    for (Cindex = 0; Cindex < NClients; Cindex++) {

	// if the client was used then close the NamedPipe handle
        cstatus = NtClose (Clients[Cindex].c_Nmp.c_PipeHandle);
	
    	if (!NT_SUCCESS(cstatus)) {
           printf("Failed to close NMPhandle thno:%d err=%lx\n",
	      Cindex,cstatus);
    	}

	// terminate the thread
       cstatus = NtTerminateThread(
	    Clients[Cindex].c_hThHandle,
	    exitstatus);

       if (!NT_SUCCESS(cstatus)) {
            printf("Failed to terminate thread no:%d err=%lx\n",
	   Cindex,cstatus);
    	}
    }
*/
    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
     This routine does a client specific cleanup work.
--*/

NTSTATUS
SCXNS_ThreadCleanUp(
  IN  USHORT CIndex
)

{
    //NTSTATUS	tstatus;
    // For Server Close the ListenId

    return STATUS_SUCCESS;

}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\common\scudp.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       scudp.c
//
//--------------------------------------------------------------------------

/************************************************************************
 *  This file contains Common routines for Socket  I/O
 *  Mahesh Keni
 ************************************************************************
*/

#include "rawcom.h"
#include "scudp.h"

/************************************************************************/

NTSTATUS
SCUDP_Initialize(

    IN	    USHORT	NClients,   // Number of clients
    IN	    PCHAR	ServerName, // Server IP address
    IN      USHORT	SrvCli)	    // server or client
{
    INTEGER 		RetCode = 0;
    WSADATA		WsaData;	// got from RCP prog

    RetCode = WSAStartup(0x0101, &WsaData);

    if (RetCode == SOCKET_ERROR) {
	    //DbgPrint("Error: WSAStartup : %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }
    return(STATUS_SUCCESS);
}
/************************************************************************/

/*++
     This routine is responsible Creating a Socket instance  and doing bind for
     for a thread.

--*/

NTSTATUS
SCUDP_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli )	
{
    //NTSTATUS	pstatus;
    INTEGER	    RetCode;
    SOCKADDR	saddr;		// socket address
    //INTEGER	    saddrlen;
    SOCKET	    isockid;

    // We can combine this with SPX routines later
    PSOCKADDR_IN	paddr_in = (PSOCKADDR_IN)&saddr;
    int			    protocol = IPPROTO_UDP;

    // First create a socket for this client
    if ((isockid = socket(AddrFly, SOCK_DGRAM, protocol)) == INVALID_SOCKET) {
	    //DbgPrint("Error: Invalid Socket: %ld \n",WSAGetLastError());
	    return(STATUS_UNSUCCESSFUL);
    }
    Clients[CIndex].c_Sock.c_Sockid = isockid;
    // now do the address binding part
    // should get ip address from Name

    ClearSocket(&saddr);		// cleanup the structure
    paddr_in->sin_family      = (short)AddrFly;

    if (SrvCli) { // if it's a server only then do the binding
        paddr_in->sin_port        = htons((USHORT)(SERV_UDP_PORT + CIndex));
        paddr_in->sin_addr.s_addr = inet_addr(HostName); // use htonl
    }
    else { // for client assign socket id.
        paddr_in->sin_port        = 0;
        paddr_in->sin_addr.s_addr = 0;
    }

    RetCode = bind(isockid, &saddr, sizeof(saddr));

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Error: Bind: %ld\n",WSAGetLastError());;
        closesocket(isockid);
        return (STATUS_UNSUCCESSFUL);
    }
    else {
        Clients[CIndex].c_Sock.c_Sockid   = isockid;
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for Connecting a server address to a
     socket if Connected flag is true.
--*/

NTSTATUS
SCUDP_Connect_To_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;
    SOCKADDR_IN	saddr;		// socket address

    saddr.sin_family      = (short)AddrFly;		// Address family
    saddr.sin_port        = htons((USHORT)(SERV_UDP_PORT + CIndex));
    saddr.sin_addr.s_addr = inet_addr(ServerName);

    RetCode = DGSocket_Connect(CIndex, (PSOCKADDR)&saddr);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Connect %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine allocates memory required for all the buffers for a client.

--*/

NTSTATUS
SCUDP_Allocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	astatus;
    ULONG	AllocSize;

    // AllocSize = Clients[CIndex].c_reqbuf.SendSize;
    AllocSize = MAXBUFSIZE;
    (LPVOID) Clients[CIndex].c_pSendBuf = VirtualAlloc(
                                         (LPVOID) Clients[CIndex].c_pSendBuf,
                                         (DWORD)AllocSize,
                                         (DWORD)MEM_COMMIT,
                                         (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pSendBuf,"Client%d Send Data",CIndex+1);
    if (Clients[CIndex].c_pSendBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    // AllocSize = Clients[CIndex].c_reqbuf.RecvSize;
    AllocSize = MAXBUFSIZE;
    (LPVOID) Clients[CIndex].c_pRecvBuf = VirtualAlloc(
                                            (LPVOID) Clients[CIndex].c_pRecvBuf,
                                            (DWORD)AllocSize,
                                            (DWORD)MEM_COMMIT,
                                            (DWORD)PAGE_READWRITE);

    sprintf(Clients[CIndex].c_pRecvBuf,"Client%d Recv Data",CIndex+1);
    if (Clients[CIndex].c_pRecvBuf == NULL) {
        astatus = GetLastError();
        printf("\nVirtual Alloc error\n");
    }
    return astatus;
}
/************************************************************************/
/*++
    This routine deallocates memory for a client.

--*/

NTSTATUS
SCUDP_Deallocate_Memory(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    NTSTATUS	dstatus;
    ULONG	DeallocSize;

    // Deallocate memory for Send Buffer
    // DeallocSize = Clients[CIndex].c_reqbuf.SendSize;
    DeallocSize = MAXBUFSIZE;

    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pSendBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pSendBuf,
                   DeallocSize,
                   MEM_DECOMMIT);

    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp SendBuf: Deallocate memory failed: err: %lx \n", dstatus);
        return dstatus;
    }

    // DeallocSize = Clients[CIndex].c_reqbuf.RecvSize;
    DeallocSize = MAXBUFSIZE;

    // Deallocate memory for Receive Buffer
    /*
    dstatus = NtFreeVirtualMemory(
    		NtCurrentProcess(),
		(PVOID *) (&(Clients[CIndex].c_pRecvBuf)),
		&(DeallocSize),
		MEM_DECOMMIT);
    */
    dstatus = VirtualFree(
                   (LPVOID) Clients[CIndex].c_pRecvBuf,
                   DeallocSize,
                   MEM_DECOMMIT);

    if (!NT_SUCCESS(dstatus)) {
        //DbgPrint("Nmp RecvBuf :Deallocate memory failed: err: %lx \n", dstatus);
    }
    return dstatus;
}
/************************************************************************/
/*++
     This routine is responsible for disconnecting a session.

--*/

NTSTATUS
SCUDP_Disconnect_From_Server(
  IN  USHORT CIndex)	// client index and namedpipe instance number
{
    INTEGER	RetCode;

    //Close the socket so that it can disconnect
    if ( (RetCode = DGSocket_Close(CIndex)) == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Close Sockid %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine does handshake with it's peer. For Server this means
    receiving request message from a client. For Client it means just the
    opposite.
--*/

NTSTATUS
SCUDP_DoHandshake(
  IN  USHORT CIndex,	// client index
  IN  USHORT SrvCli)     // if it's a server or client	
{
    ULONG	RWreqLen;
    INTEGER	RetCode = 0;
    SOCKADDR_IN	daddr;
    INTEGER	daddrlen = 16;

    RWreqLen = sizeof(struct reqbuf);

    // for server do receivefrom for a request buffer

    if (SrvCli) {
        RetCode = DGSocket_RecvFrom(
			            CIndex,
			            (PVOID) &(Clients[CIndex].c_reqbuf),
			            (PULONG) &RWreqLen,
			            (PSOCKADDR) &daddr,
 			            (USHORT *) &daddrlen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in RecvFrom %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Connect this address to client's Socket
        RetCode = DGSocket_Connect(CIndex, (PSOCKADDR)&daddr);

        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Connect %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
    }
    else { // for Client do send of reqbuf size
       // Client always does Send
       RetCode = DGSocket_Send(
		                CIndex,
		                (PVOID) &(Clients[CIndex].c_reqbuf),
		                (PULONG) &RWreqLen);
       if (RetCode == SOCKET_ERROR) {
           //DbgPrint("Sock: Error in Send %d\n", RetCode);
           return (STATUS_UNSUCCESSFUL);
       }
    }
    // check if read/write length is ok
    if (RWreqLen != sizeof(struct reqbuf)) {
        //DbgPrint("Sock:Read/Write Len mismatch: read %ld \n", RWreqLen);
    }
    /*
    MyDbgPrint("handshake: Sendl:%ld Recvl:%ld \n",
              Clients[CIndex].c_reqbuf.SendSize,
              Clients[CIndex].c_reqbuf.RecvSize);
    */
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Reads data from IPC.  For server it means reading data
    NumSends times in SendBuffers and for a client NumRecvs times into
    RecvBuffer.

--*/

NTSTATUS
SCUDP_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli)    // if it's a server or client
{
    ULONG	NumReads;
    ULONG	ReadLen;
    PCHAR	ReadBuf;	
    INTEGER	RetCode;
    // SOCKADDR_IN raddr;
    // INTEGER	raddrlen;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumReads = Clients[CIndex].c_reqbuf.NumSends;
        ReadBuf  = Clients[CIndex].c_pSendBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    else { // for client do proper settings
	    NumReads = Clients[CIndex].c_reqbuf.NumRecvs;
        ReadBuf  = Clients[CIndex].c_pRecvBuf;
        ReadLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    while (NumReads--) {
        RetCode =  DGSocket_Recv(
                        CIndex,
	   	                (PVOID) ReadBuf,
			            (PULONG)&ReadLen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("DGSock: Error in Recv %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        // Assign the read length
        *pReadDone = ReadLen;
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
    This routine Writes data to IPC.  For server it means writing data
    NumRecvs times in RecvBuffers and for a client NumSends times into
    SendBuffer.

--*/

NTSTATUS
SCUDP_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli)    // if it's a server or client
{
    ULONG	NumWrites;
    ULONG	WriteLen;
    PCHAR	WriteBuf;	
    INTEGER	RetCode;

    if (SrvCli) {  // set proper iterations and buffer for Server
	    NumWrites = Clients[CIndex].c_reqbuf.NumRecvs;
        WriteBuf  = Clients[CIndex].c_pRecvBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.RecvSize;
    }
    else { // for client do proper settings
	    NumWrites = Clients[CIndex].c_reqbuf.NumSends;
        WriteBuf  = Clients[CIndex].c_pSendBuf;
        WriteLen  = Clients[CIndex].c_reqbuf.SendSize;
    }
    while (NumWrites--) {
        RetCode =  DGSocket_Send(
		                    CIndex,
		                    (PVOID) WriteBuf,
		                    (PULONG) &WriteLen);
        if (RetCode == SOCKET_ERROR) {
            //DbgPrint("Sock: Error in Send %d\n", RetCode);
            return (STATUS_UNSUCCESSFUL);
        }
        *pWriteDone = WriteLen;
    }
    return (STATUS_SUCCESS);
}
/************************************************************************/
NTSTATUS
SCUDP_Cleanup(VOID)
{
    //USHORT		Cindex = 0; // client index
    //NTSTATUS 	cstatus;
    //NTSTATUS 	exitstatus = 0;

    return (STATUS_SUCCESS);
}
/************************************************************************/
/*++
     This routine does a client specific cleanup work.
--*/

NTSTATUS
SCUDP_ThreadCleanUp(
  IN  USHORT CIndex)
{
    //NTSTATUS	tstatus;
    // For Server Close the ListenId

    return STATUS_SUCCESS;
}
/************************************************************************/

/*++
    For UDP do nothing.
--*/

NTSTATUS
SCUDP_Wait_For_Client(
  IN  USHORT CIndex)	// client index
{
    //NTSTATUS	wstatus;
    //INTEGER   RetCode;

    return (STATUS_SUCCESS);
}

/************************************************************************/
/*++
     This routine is responsible for issueing Disconnect to close the
     connection with a client.
--*/

NTSTATUS
SCUDP_Disconnect_Client(
  IN  USHORT CIndex)	// client index
{
    INTEGER	RetCode;
    SOCKADDR_IN	daddr;

    // Dissociate address from the socket handle
    // Connect to zero address

    ClearSocket(&daddr);		// cleanup the structure

    // Connect this address to client's Socket to disassociate server
    // address from this socket

    RetCode = DGSocket_Connect(CIndex, (PSOCKADDR)&daddr);

    if (RetCode == SOCKET_ERROR) {
        //DbgPrint("Sock: Error in Connect %d\n", RetCode);
        return (STATUS_UNSUCCESSFUL);
    }
    return (STATUS_SUCCESS);
}

/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\dgnb.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dgnb.h
//
//--------------------------------------------------------------------------

/************************************************************************/
//  This file contains NetBIOS specific definitions
/************************************************************************/


//			 1234567890123456
#define PERF_NETBIOS	"perftest123456  "
#define CLINAME         "perfCli"
#define ALL_CLIENTS	"*               "
#define SPACES	        "                "

#define ClearNCB( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }



/**********************************************************************/
// Local Function prototypes
/**********************************************************************/


UCHAR
DGNetBIOS_AddName(
    IN     PCHAR	LocalName,
    IN	   UCHAR	LanaNumber,
    OUT	   PUCHAR	NameNumber
);

UCHAR
DGNetBIOS_Reset(
    IN	   UCHAR	LanaNumber
);


UCHAR
DGNetBIOS_Receive(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen
);

UCHAR
DGNetBIOS_Send(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen
);

UCHAR
DGNetBIOS_RecvSend(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen
);

NTSTATUS
DGNB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

NTSTATUS
DGNB_PerClientInit(
  IN  USHORT CIndex,   // client index 
  IN  USHORT SrvCli
);
	

NTSTATUS
DGNB_Wait_For_Client(
  IN  USHORT CIndex
);

NTSTATUS
DGNB_Disconnect_Client(
  IN  USHORT CIndex
);

NTSTATUS
DGNB_Connect_To_Server(
  IN  USHORT CIndex
);

NTSTATUS
DGNB_Allocate_Memory(
  IN  USHORT CIndex
);


NTSTATUS
DGNB_Deallocate_Memory(
  IN  USHORT CIndex
);

NTSTATUS
DGNB_Disconnect_From_Server(
  IN  USHORT CIndex
);

NTSTATUS
DGNB_DoHandshake(
  IN  USHORT CIndex,	// client index and namedpipe instance number
  IN  USHORT SrvCli     // if it's a server or client
);
	

NTSTATUS
DGNB_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli     // if it's a server or client
);

NTSTATUS
DGNB_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli     // if it's a server or client
);
	
NTSTATUS
DGNB_XactIO(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli,     // if it's a server or client
  IN	  BOOLEAN FirstIter
);
	
NTSTATUS
DGNB_Cleanup(
   VOID
);


NTSTATUS
DGNB_ThreadCleanUp(
  IN  USHORT CIndex
);


/**********************************************************************/
// External variables
/**********************************************************************/

// For NetBIOS only
extern USHORT	LanaCount;
extern USHORT	LanaBase;
extern UCHAR	NameNumber;
extern CHAR	LocalName[NCBNAMSZ];
extern CHAR	RemoteName[NCBNAMSZ];

extern struct client	Clients[MAXCLIENTS];    // all the client data 
extern USHORT		NClients;
extern USHORT		MachineNumber;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\nb.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       nb.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: nb.h
//
// Description: This file contains definitions for NetBios routines
//              for use with IPC raw network performance tests.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

//			 1234567890123456
#define PERF_NETBIOS	"perftest123456  "
#define CLINAME         "perfCli"
#define ALL_CLIENTS	"*               "
#define SPACES	        "                "

#define ClearNCB( PNCB ) {                                          \
    RtlZeroMemory( PNCB , sizeof (NCB) );                           \
    RtlMoveMemory( (PNCB)->ncb_name,     SPACES, sizeof(SPACES)-1 );\
    RtlMoveMemory( (PNCB)->ncb_callname, SPACES, sizeof(SPACES)-1 );\
    }



/**********************************************************************/
// Local Function prototypes
/**********************************************************************/


UCHAR
NetBIOS_AddName(
    IN     PCHAR	LocalName,
    IN	   UCHAR	LanaNumber,
    OUT	   PUCHAR	NameNumber
);

UCHAR
NetBIOS_DelName(
    IN     PCHAR	LocalName,
    IN	   UCHAR	LanaNumber
);

UCHAR
NetBIOS_Reset(
    IN	   UCHAR	LanaNumber
);

UCHAR
NetBIOS_Call(
    IN	   USHORT	CIndex,		// Client Index
    IN	   PCHAR	LocalName,
    IN	   PCHAR	RemoteName
);

UCHAR
NetBIOS_Listen(
    IN	   USHORT	TIndex,		// Client Index
    IN	   PCHAR	LocalName,
    IN	   PCHAR	RemoteName,
    IN	   UCHAR	NameNumber
);

UCHAR
NetBIOS_Receive(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen
);

UCHAR
NetBIOS_Send(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen
);

UCHAR
NetBIOS_HangUP(
    IN	   USHORT	TIndex
);

UCHAR
NetBIOS_RecvSend(
    IN	   USHORT	TIndex,
    IN	   PUCHAR	SendBuffer,
    IN     USHORT	SendLen,
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen
);


UCHAR
NetBIOS_SPReceive(
    IN	   USHORT	TIndex,
    IN	   NCB *	PRecvNCB,
    IN	   USHORT	Global,		// global= 1 or local = 0
    IN	   PUCHAR	RecvBuffer,
    IN     USHORT	RecvLen
);


NTSTATUS
NB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

NTSTATUS
NB_PerClientInit(
  IN  USHORT CIndex,   // client index
  IN  USHORT SrvCli
);
	

NTSTATUS
NB_Wait_For_Client(
  IN  USHORT CIndex
);

NTSTATUS
NB_Disconnect_Client(
  IN  USHORT CIndex
);

NTSTATUS
NB_Connect_To_Server(
  IN  USHORT CIndex
);

NTSTATUS
NB_Allocate_Memory(
  IN  USHORT CIndex
);


NTSTATUS
NB_Deallocate_Memory(
  IN  USHORT CIndex
);

NTSTATUS
NB_Disconnect_From_Server(
  IN  USHORT CIndex
);

NTSTATUS
NB_DoHandshake(
  IN  USHORT CIndex,	// client index and namedpipe instance number
  IN  USHORT SrvCli     // if it's a server or client
);
	

NTSTATUS
NB_ReadFromIPC(
  IN      USHORT CIndex,    // client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN      USHORT SrvCli     // if it's a server or client
);

NTSTATUS
NB_WriteToIPC(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli     // if it's a server or client
);
	
NTSTATUS
NB_XactIO(
  IN      USHORT CIndex,	// client index and namedpipe instance number
  IN  OUT PULONG pReadDone,
  IN  OUT PULONG pWriteDone,
  IN      USHORT SrvCli,     // if it's a server or client
  IN	  BOOLEAN FirstIter
);
	
NTSTATUS
NB_Cleanup(
   VOID
);


NTSTATUS
NB_ThreadCleanUp(
  IN  USHORT CIndex
);


/**********************************************************************/
// External variables
/**********************************************************************/

// For NetBIOS only
extern USHORT	LanaCount;
extern USHORT	LanaBase;
extern UCHAR	NameNumber;
extern CHAR	LocalName[NCBNAMSZ];
extern CHAR	RemoteName[NCBNAMSZ];

extern struct client	Clients[MAXCLIENTS];    // all the client data
extern USHORT		NClients;
extern USHORT		MachineNumber;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\dgsccomn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dgsccomn.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: dgsccomn.h
//
// Description: This file contains definitions for datagram socket I/O routines
//              for use with IPC raw network performance tests.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

typedef int   INTEGER;
#define ClearSocket(PSOCK) {RtlZeroMemory(PSOCK ,sizeof (SOCKADDR));}

/************************************************************************/
INTEGER
DGSocket_Recv(
    IN USHORT	  CIndex,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen
);

INTEGER
DGSocket_RecvFrom(
    IN USHORT	        CIndex,
    IN OUT PVOID        PReadBuf,
    IN OUT PULONG       rpdatalen,
    IN OUT PSOCKADDR    pcaddr,
    IN OUT PUSHORT      pcaddrlen
);

INTEGER
DGSocket_Send(
    IN USHORT	  CIndex,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen
);

INTEGER
DGSocket_SendTo(
    IN USHORT	        CIndex,
    IN OUT PVOID        PWriteBuf,
    IN OUT PULONG       spdatalen,
    IN OUT PSOCKADDR 	pcaddr,
    IN OUT PUSHORT      pcaddrlen
);

INTEGER
DGSocket_Close(
    IN  USHORT	  CIndex
);

INTEGER
DGSocket_Connect(
    IN USHORT	  CIndex,
    IN PSOCKADDR  pdsockaddr
);


/************************************************************************/
// External variables
/************************************************************************/
extern PCHAR		HostName;
extern PCHAR		ServerName;
extern int		AddrFly;
extern BOOLEAN		Connected;

extern struct client	Clients[MAXCLIENTS];    // all the client data
extern USHORT		NClients;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\np.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       np.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: np.h
//
// Description: This file contains definitions for Named Pipe routines
//              for use with IPC raw network performance tests.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#define PERF_PIPE "\\\\.\\pipe\\perftest"
#define RM_PERF_PIPE_PRFX "\\\\."
#define RM_PERF_PIPE_SUFX "\\pipe\\perftest"
#define PERF_EVENT "\\prfEvent"
#define PIPE_LEN	2048



/************************************************************************/
// Local function prototypes
/************************************************************************/
NTSTATUS
CreateNamedPipeInstance(
  IN  USHORT Nindex
);	
/*
NTSTATUS
NamedPipe_FsControl(
    IN     HANDLE	lhandle,
    IN	   ULONG	FsControlCode,
    IN	   PVOID	pInBuffer,
    IN	   ULONG	InBufLen,
    OUT	   PVOID	pOutBuffer,
    IN	   ULONG	OutBufLen
);
*/
NTSTATUS
ReadNamedPipe(
    IN     HANDLE	rhandle,
    IN	   ULONG	rlength,
    IN OUT PVOID	rpbuffer,
    IN OUT PULONG	rpdatalen
);

NTSTATUS
WriteNamedPipe(
    IN     HANDLE	whandle,
    IN	   ULONG	wlength,
    IN OUT PVOID	wpbuffer,
    IN OUT PULONG	wpdatalen
);

NTSTATUS
NMP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

NTSTATUS
NMP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

NTSTATUS
NMP_Allocate_Memory(
    IN	   USHORT	CIndex
);

NTSTATUS
NMP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


NTSTATUS
NMP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


NTSTATUS
NMP_Cleanup(
    VOID
);

NTSTATUS
NMP_Wait_For_Client(
    IN  USHORT CIndex
);

NTSTATUS
NMP_Disconnect_Client(
    IN  USHORT CIndex
);


NTSTATUS
NMP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

NTSTATUS
NMP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

NTSTATUS
NMP_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN	   BOOLEAN	FirstIter
);

NTSTATUS
NMP_ThreadCleanUp(
    IN	   USHORT	CIndex
);


/************************************************************************/
// External function prototypes
/************************************************************************/
extern LPCSTR       pipeName;
extern ULONG		Quotas;
extern ULONG		PipeType;
extern ULONG		PipeMode;
extern ULONG		BlockorNot;

extern struct client	Clients[MAXCLIENTS];    // all the client data
extern USHORT		    NClients;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\msipx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       msipx.h
//
//--------------------------------------------------------------------------

/*========================================================
	M C S S O C K . H

	This include file is for use with the Windows NT
	WinSock interface.

	This file includes defines and structures for
	IPX and XNS.
=========================================================*/

/**
    This is the structure of the SOCKADDR structure
    for IPX and XNS.
**/

typedef struct _SOCKADDR_NS {
    short sa_family;
    char  sa_netnum[4];
    char  sa_nodenum[6];
    unsigned short sa_socket;
} SOCKADDR_NS, *PSOCKADDR_NS;

/**************************************************************
    	These are the socket options that we support.

	All of these are made with the level set
	to SOL_SOCKET;
***************************************************************/

/** These are for SOCK_DGRAM sockets only **/
/* 0x4000 - 0x407f */

#define SO_SETPTYPE		0x4000	/* Set send packet type	*/
#define SO_GETPTYPE		0x4001	/* Get current send packet type */
#define SO_SETFILTERPTYPE	0x4002	/* Set pkt type to filter recv on */
#define SO_GETFILTERPTYPE	0x4003  /* Get pkt type filtering recv on */
#define SO_STOPFILTERPTYPE	0x4004  /* Stop filtering recv on pkt type*/
#define SO_GETMAXSIZE		0x4005  /* Get max packet size can send   */
#define SO_ENABLE_EXTENDED_ADDRESS  0x4006 /* Put pkt type in address	  */
#define SO_DISABLE_EXTENDED_ADDRESS 0x4007 /* Don't pkt type in address	  */

/** These are for both SOCK_STREAM and SOCK_DGRAM sockets **/
/** 0x4080 - 0x40ff */

#define SO_ENABLE_RECVHDR	0x4080  /* Send pcol hdr on recv as data  */
#define SO_DISABLE_RECVHDR	0x4081  /* Stop sending pcol hdr on recv  */

/** These are for SOCK_STREAM sockets only **/
/* 0x4100 - 0x417f */

#define SO_SETDSTYPE		0x4100  /* Set the datastream type	  */
#define SO_GETDSTYPE		0x4101  /* Get the current datastream type*/

/**************************************************************
    	These are the protocol family values to use in the socket
    	call for SPP and SPX.
***************************************************************/

#define NSPROTO_SPX	1256
#define NSPROTO_SPP	2256

/**
    These are the protocol values for IPX to be used
    in the socket call.  They will assign the default packet
    type.
**/

#define NSPROTO_IPX	    1000	/* Set send pkt type to 0 */
#define NSPROTO_IPX_PT1     1001	/* Set send pkt type to 1 */
#define NSPROTO_IPX_PT2     1002
#define NSPROTO_IPX_PT3     1003
#define NSPROTO_IPX_PT4     1004
#define NSPROTO_IPX_PT5     1005
#define NSPROTO_IPX_PT6     1006
#define NSPROTO_IPX_PT7     1007
#define NSPROTO_IPX_PT8     1008
#define NSPROTO_IPX_PT9     1009
#define NSPROTO_IPX_PT10    1010
#define NSPROTO_IPX_PT11    1011
#define NSPROTO_IPX_PT12    1012
#define NSPROTO_IPX_PT13    1013
#define NSPROTO_IPX_PT14    1014
#define NSPROTO_IPX_PT15    1015
#define NSPROTO_IPX_PT16    1016
#define NSPROTO_IPX_PT17    1017
#define NSPROTO_IPX_PT18    1018
#define NSPROTO_IPX_PT19    1019
#define NSPROTO_IPX_PT20    1020
#define NSPROTO_IPX_PT21    1021
#define NSPROTO_IPX_PT22    1022
#define NSPROTO_IPX_PT23    1023
#define NSPROTO_IPX_PT24    1024
#define NSPROTO_IPX_PT25    1025
#define NSPROTO_IPX_PT26    1026
#define NSPROTO_IPX_PT27    1027
#define NSPROTO_IPX_PT28    1028
#define NSPROTO_IPX_PT29    1029
#define NSPROTO_IPX_PT30    1030
#define NSPROTO_IPX_PT31    1031
#define NSPROTO_IPX_PT32    1032
#define NSPROTO_IPX_PT33    1033
#define NSPROTO_IPX_PT34    1034
#define NSPROTO_IPX_PT35    1035
#define NSPROTO_IPX_PT36    1036
#define NSPROTO_IPX_PT37    1037
#define NSPROTO_IPX_PT38    1038
#define NSPROTO_IPX_PT39    1039
#define NSPROTO_IPX_PT40    1040
#define NSPROTO_IPX_PT41    1041
#define NSPROTO_IPX_PT42    1042
#define NSPROTO_IPX_PT43    1043
#define NSPROTO_IPX_PT44    1044
#define NSPROTO_IPX_PT45    1045
#define NSPROTO_IPX_PT46    1046
#define NSPROTO_IPX_PT47    1047
#define NSPROTO_IPX_PT48    1048
#define NSPROTO_IPX_PT49    1049
#define NSPROTO_IPX_PT50    1050
#define NSPROTO_IPX_PT51    1051
#define NSPROTO_IPX_PT52    1052
#define NSPROTO_IPX_PT53    1053
#define NSPROTO_IPX_PT54    1054
#define NSPROTO_IPX_PT55    1055
#define NSPROTO_IPX_PT56    1056
#define NSPROTO_IPX_PT57    1057
#define NSPROTO_IPX_PT58    1058
#define NSPROTO_IPX_PT59    1059
#define NSPROTO_IPX_PT60    1060
#define NSPROTO_IPX_PT61    1061
#define NSPROTO_IPX_PT62    1062
#define NSPROTO_IPX_PT63    1063
#define NSPROTO_IPX_PT64    1064
#define NSPROTO_IPX_PT65    1065
#define NSPROTO_IPX_PT66    1066
#define NSPROTO_IPX_PT67    1067
#define NSPROTO_IPX_PT68    1068
#define NSPROTO_IPX_PT69    1069
#define NSPROTO_IPX_PT70    1070
#define NSPROTO_IPX_PT71    1071
#define NSPROTO_IPX_PT72    1072
#define NSPROTO_IPX_PT73    1073
#define NSPROTO_IPX_PT74    1074
#define NSPROTO_IPX_PT75    1075
#define NSPROTO_IPX_PT76    1076
#define NSPROTO_IPX_PT77    1077
#define NSPROTO_IPX_PT78    1078
#define NSPROTO_IPX_PT79    1079
#define NSPROTO_IPX_PT80    1080
#define NSPROTO_IPX_PT81    1081
#define NSPROTO_IPX_PT82    1082
#define NSPROTO_IPX_PT83    1083
#define NSPROTO_IPX_PT84    1084
#define NSPROTO_IPX_PT85    1085
#define NSPROTO_IPX_PT86    1086
#define NSPROTO_IPX_PT87    1087
#define NSPROTO_IPX_PT88    1088
#define NSPROTO_IPX_PT89    1089
#define NSPROTO_IPX_PT90    1090
#define NSPROTO_IPX_PT91    1091
#define NSPROTO_IPX_PT92    1092
#define NSPROTO_IPX_PT93    1093
#define NSPROTO_IPX_PT94    1094
#define NSPROTO_IPX_PT95    1095
#define NSPROTO_IPX_PT96    1096
#define NSPROTO_IPX_PT97    1097
#define NSPROTO_IPX_PT98    1098
#define NSPROTO_IPX_PT99    1099
#define NSPROTO_IPX_PT100   1100
#define NSPROTO_IPX_PT101   1101
#define NSPROTO_IPX_PT102   1102
#define NSPROTO_IPX_PT103   1103
#define NSPROTO_IPX_PT104   1104
#define NSPROTO_IPX_PT105   1105
#define NSPROTO_IPX_PT106   1106
#define NSPROTO_IPX_PT107   1107
#define NSPROTO_IPX_PT108   1108
#define NSPROTO_IPX_PT109   1109
#define NSPROTO_IPX_PT110   1110
#define NSPROTO_IPX_PT111   1111
#define NSPROTO_IPX_PT112   1112
#define NSPROTO_IPX_PT113   1113
#define NSPROTO_IPX_PT114   1114
#define NSPROTO_IPX_PT115   1115
#define NSPROTO_IPX_PT116   1116
#define NSPROTO_IPX_PT117   1117
#define NSPROTO_IPX_PT118   1118
#define NSPROTO_IPX_PT119   1119
#define NSPROTO_IPX_PT120   1120
#define NSPROTO_IPX_PT121   1121
#define NSPROTO_IPX_PT122   1122
#define NSPROTO_IPX_PT123   1123
#define NSPROTO_IPX_PT124   1124
#define NSPROTO_IPX_PT125   1125
#define NSPROTO_IPX_PT126   1126
#define NSPROTO_IPX_PT127   1127
#define NSPROTO_IPX_PT128   1128
#define NSPROTO_IPX_PT129   1129
#define NSPROTO_IPX_PT130   1130
#define NSPROTO_IPX_PT131   1131
#define NSPROTO_IPX_PT132   1132
#define NSPROTO_IPX_PT133   1133
#define NSPROTO_IPX_PT134   1134
#define NSPROTO_IPX_PT135   1135
#define NSPROTO_IPX_PT136   1136
#define NSPROTO_IPX_PT137   1137
#define NSPROTO_IPX_PT138   1138
#define NSPROTO_IPX_PT139   1139
#define NSPROTO_IPX_PT140   1140
#define NSPROTO_IPX_PT141   1141
#define NSPROTO_IPX_PT142   1142
#define NSPROTO_IPX_PT143   1143
#define NSPROTO_IPX_PT144   1144
#define NSPROTO_IPX_PT145   1145
#define NSPROTO_IPX_PT146   1146
#define NSPROTO_IPX_PT147   1147
#define NSPROTO_IPX_PT148   1148
#define NSPROTO_IPX_PT149   1149
#define NSPROTO_IPX_PT150   1150
#define NSPROTO_IPX_PT151   1151
#define NSPROTO_IPX_PT152   1152
#define NSPROTO_IPX_PT153   1153
#define NSPROTO_IPX_PT154   1154
#define NSPROTO_IPX_PT155   1155
#define NSPROTO_IPX_PT156   1156
#define NSPROTO_IPX_PT157   1157
#define NSPROTO_IPX_PT158   1158
#define NSPROTO_IPX_PT159   1159
#define NSPROTO_IPX_PT160   1160
#define NSPROTO_IPX_PT161   1161
#define NSPROTO_IPX_PT162   1162
#define NSPROTO_IPX_PT163   1163
#define NSPROTO_IPX_PT164   1164
#define NSPROTO_IPX_PT165   1165
#define NSPROTO_IPX_PT166   1166
#define NSPROTO_IPX_PT167   1167
#define NSPROTO_IPX_PT168   1168
#define NSPROTO_IPX_PT169   1169
#define NSPROTO_IPX_PT170   1170
#define NSPROTO_IPX_PT171   1171
#define NSPROTO_IPX_PT172   1172
#define NSPROTO_IPX_PT173   1173
#define NSPROTO_IPX_PT174   1174
#define NSPROTO_IPX_PT175   1175
#define NSPROTO_IPX_PT176   1176
#define NSPROTO_IPX_PT177   1177
#define NSPROTO_IPX_PT178   1178
#define NSPROTO_IPX_PT179   1179
#define NSPROTO_IPX_PT180   1180
#define NSPROTO_IPX_PT181   1181
#define NSPROTO_IPX_PT182   1182
#define NSPROTO_IPX_PT183   1183
#define NSPROTO_IPX_PT184   1184
#define NSPROTO_IPX_PT185   1185
#define NSPROTO_IPX_PT186   1186
#define NSPROTO_IPX_PT187   1187
#define NSPROTO_IPX_PT188   1188
#define NSPROTO_IPX_PT189   1189
#define NSPROTO_IPX_PT190   1190
#define NSPROTO_IPX_PT191   1191
#define NSPROTO_IPX_PT192   1192
#define NSPROTO_IPX_PT193   1193
#define NSPROTO_IPX_PT194   1194
#define NSPROTO_IPX_PT195   1195
#define NSPROTO_IPX_PT196   1196
#define NSPROTO_IPX_PT197   1197
#define NSPROTO_IPX_PT198   1198
#define NSPROTO_IPX_PT199   1199
#define NSPROTO_IPX_PT200   1200
#define NSPROTO_IPX_PT201   1201
#define NSPROTO_IPX_PT202   1202
#define NSPROTO_IPX_PT203   1203
#define NSPROTO_IPX_PT204   1204
#define NSPROTO_IPX_PT205   1205
#define NSPROTO_IPX_PT206   1206
#define NSPROTO_IPX_PT207   1207
#define NSPROTO_IPX_PT208   1208
#define NSPROTO_IPX_PT209   1209
#define NSPROTO_IPX_PT210   1210
#define NSPROTO_IPX_PT211   1211
#define NSPROTO_IPX_PT212   1212
#define NSPROTO_IPX_PT213   1213
#define NSPROTO_IPX_PT214   1214
#define NSPROTO_IPX_PT215   1215
#define NSPROTO_IPX_PT216   1216
#define NSPROTO_IPX_PT217   1217
#define NSPROTO_IPX_PT218   1218
#define NSPROTO_IPX_PT219   1219
#define NSPROTO_IPX_PT220   1220
#define NSPROTO_IPX_PT221   1221
#define NSPROTO_IPX_PT222   1222
#define NSPROTO_IPX_PT223   1223
#define NSPROTO_IPX_PT224   1224
#define NSPROTO_IPX_PT225   1225
#define NSPROTO_IPX_PT226   1226
#define NSPROTO_IPX_PT227   1227
#define NSPROTO_IPX_PT228   1228
#define NSPROTO_IPX_PT229   1229
#define NSPROTO_IPX_PT230   1230
#define NSPROTO_IPX_PT231   1231
#define NSPROTO_IPX_PT232   1232
#define NSPROTO_IPX_PT233   1233
#define NSPROTO_IPX_PT234   1234
#define NSPROTO_IPX_PT235   1235
#define NSPROTO_IPX_PT236   1236
#define NSPROTO_IPX_PT237   1237
#define NSPROTO_IPX_PT238   1238
#define NSPROTO_IPX_PT239   1239
#define NSPROTO_IPX_PT240   1240
#define NSPROTO_IPX_PT241   1241
#define NSPROTO_IPX_PT242   1242
#define NSPROTO_IPX_PT243   1243
#define NSPROTO_IPX_PT244   1244
#define NSPROTO_IPX_PT245   1245
#define NSPROTO_IPX_PT246   1246
#define NSPROTO_IPX_PT247   1247
#define NSPROTO_IPX_PT248   1248
#define NSPROTO_IPX_PT249   1249
#define NSPROTO_IPX_PT250   1250
#define NSPROTO_IPX_PT251   1251
#define NSPROTO_IPX_PT252   1252
#define NSPROTO_IPX_PT253   1253
#define NSPROTO_IPX_PT254   1254
#define NSPROTO_IPX_PT255   1255

/**
    These are the protocol values for IDP to be used
    in the socket call.  They will assign the default packet
    type.
**/

#define NSPROTO_IDP	    2000	/* Set send pkt type to 0 */
#define NSPROTO_IDP_PT1     2001	/* Set send pkt type to 1 */
#define NSPROTO_IDP_PT2     2002
#define NSPROTO_IDP_PT3     2003
#define NSPROTO_IDP_PT4     2004
#define NSPROTO_IDP_PT5     2005
#define NSPROTO_IDP_PT6     2006
#define NSPROTO_IDP_PT7     2007
#define NSPROTO_IDP_PT8     2008
#define NSPROTO_IDP_PT9     2009
#define NSPROTO_IDP_PT10    2010
#define NSPROTO_IDP_PT11    2011
#define NSPROTO_IDP_PT12    2012
#define NSPROTO_IDP_PT13    2013
#define NSPROTO_IDP_PT14    2014
#define NSPROTO_IDP_PT15    2015
#define NSPROTO_IDP_PT16    2016
#define NSPROTO_IDP_PT17    2017
#define NSPROTO_IDP_PT18    2018
#define NSPROTO_IDP_PT19    2019
#define NSPROTO_IDP_PT20    2020
#define NSPROTO_IDP_PT21    2021
#define NSPROTO_IDP_PT22    2022
#define NSPROTO_IDP_PT23    2023
#define NSPROTO_IDP_PT24    2024
#define NSPROTO_IDP_PT25    2025
#define NSPROTO_IDP_PT26    2026
#define NSPROTO_IDP_PT27    2027
#define NSPROTO_IDP_PT28    2028
#define NSPROTO_IDP_PT29    2029
#define NSPROTO_IDP_PT30    2030
#define NSPROTO_IDP_PT31    2031
#define NSPROTO_IDP_PT32    2032
#define NSPROTO_IDP_PT33    2033
#define NSPROTO_IDP_PT34    2034
#define NSPROTO_IDP_PT35    2035
#define NSPROTO_IDP_PT36    2036
#define NSPROTO_IDP_PT37    2037
#define NSPROTO_IDP_PT38    2038
#define NSPROTO_IDP_PT39    2039
#define NSPROTO_IDP_PT40    2040
#define NSPROTO_IDP_PT41    2041
#define NSPROTO_IDP_PT42    2042
#define NSPROTO_IDP_PT43    2043
#define NSPROTO_IDP_PT44    2044
#define NSPROTO_IDP_PT45    2045
#define NSPROTO_IDP_PT46    2046
#define NSPROTO_IDP_PT47    2047
#define NSPROTO_IDP_PT48    2048
#define NSPROTO_IDP_PT49    2049
#define NSPROTO_IDP_PT50    2050
#define NSPROTO_IDP_PT51    2051
#define NSPROTO_IDP_PT52    2052
#define NSPROTO_IDP_PT53    2053
#define NSPROTO_IDP_PT54    2054
#define NSPROTO_IDP_PT55    2055
#define NSPROTO_IDP_PT56    2056
#define NSPROTO_IDP_PT57    2057
#define NSPROTO_IDP_PT58    2058
#define NSPROTO_IDP_PT59    2059
#define NSPROTO_IDP_PT60    2060
#define NSPROTO_IDP_PT61    2061
#define NSPROTO_IDP_PT62    2062
#define NSPROTO_IDP_PT63    2063
#define NSPROTO_IDP_PT64    2064
#define NSPROTO_IDP_PT65    2065
#define NSPROTO_IDP_PT66    2066
#define NSPROTO_IDP_PT67    2067
#define NSPROTO_IDP_PT68    2068
#define NSPROTO_IDP_PT69    2069
#define NSPROTO_IDP_PT70    2070
#define NSPROTO_IDP_PT71    2071
#define NSPROTO_IDP_PT72    2072
#define NSPROTO_IDP_PT73    2073
#define NSPROTO_IDP_PT74    2074
#define NSPROTO_IDP_PT75    2075
#define NSPROTO_IDP_PT76    2076
#define NSPROTO_IDP_PT77    2077
#define NSPROTO_IDP_PT78    2078
#define NSPROTO_IDP_PT79    2079
#define NSPROTO_IDP_PT80    2080
#define NSPROTO_IDP_PT81    2081
#define NSPROTO_IDP_PT82    2082
#define NSPROTO_IDP_PT83    2083
#define NSPROTO_IDP_PT84    2084
#define NSPROTO_IDP_PT85    2085
#define NSPROTO_IDP_PT86    2086
#define NSPROTO_IDP_PT87    2087
#define NSPROTO_IDP_PT88    2088
#define NSPROTO_IDP_PT89    2089
#define NSPROTO_IDP_PT90    2090
#define NSPROTO_IDP_PT91    2091
#define NSPROTO_IDP_PT92    2092
#define NSPROTO_IDP_PT93    2093
#define NSPROTO_IDP_PT94    2094
#define NSPROTO_IDP_PT95    2095
#define NSPROTO_IDP_PT96    2096
#define NSPROTO_IDP_PT97    2097
#define NSPROTO_IDP_PT98    2098
#define NSPROTO_IDP_PT99    2099
#define NSPROTO_IDP_PT100   2100
#define NSPROTO_IDP_PT101   2101
#define NSPROTO_IDP_PT102   2102
#define NSPROTO_IDP_PT103   2103
#define NSPROTO_IDP_PT104   2104
#define NSPROTO_IDP_PT105   2105
#define NSPROTO_IDP_PT106   2106
#define NSPROTO_IDP_PT107   2107
#define NSPROTO_IDP_PT108   2108
#define NSPROTO_IDP_PT109   2109
#define NSPROTO_IDP_PT110   2110
#define NSPROTO_IDP_PT111   2111
#define NSPROTO_IDP_PT112   2112
#define NSPROTO_IDP_PT113   2113
#define NSPROTO_IDP_PT114   2114
#define NSPROTO_IDP_PT115   2115
#define NSPROTO_IDP_PT116   2116
#define NSPROTO_IDP_PT117   2117
#define NSPROTO_IDP_PT118   2118
#define NSPROTO_IDP_PT119   2119
#define NSPROTO_IDP_PT120   2120
#define NSPROTO_IDP_PT121   2121
#define NSPROTO_IDP_PT122   2122
#define NSPROTO_IDP_PT123   2123
#define NSPROTO_IDP_PT124   2124
#define NSPROTO_IDP_PT125   2125
#define NSPROTO_IDP_PT126   2126
#define NSPROTO_IDP_PT127   2127
#define NSPROTO_IDP_PT128   2128
#define NSPROTO_IDP_PT129   2129
#define NSPROTO_IDP_PT130   2130
#define NSPROTO_IDP_PT131   2131
#define NSPROTO_IDP_PT132   2132
#define NSPROTO_IDP_PT133   2133
#define NSPROTO_IDP_PT134   2134
#define NSPROTO_IDP_PT135   2135
#define NSPROTO_IDP_PT136   2136
#define NSPROTO_IDP_PT137   2137
#define NSPROTO_IDP_PT138   2138
#define NSPROTO_IDP_PT139   2139
#define NSPROTO_IDP_PT140   2140
#define NSPROTO_IDP_PT141   2141
#define NSPROTO_IDP_PT142   2142
#define NSPROTO_IDP_PT143   2143
#define NSPROTO_IDP_PT144   2144
#define NSPROTO_IDP_PT145   2145
#define NSPROTO_IDP_PT146   2146
#define NSPROTO_IDP_PT147   2147
#define NSPROTO_IDP_PT148   2148
#define NSPROTO_IDP_PT149   2149
#define NSPROTO_IDP_PT150   2150
#define NSPROTO_IDP_PT151   2151
#define NSPROTO_IDP_PT152   2152
#define NSPROTO_IDP_PT153   2153
#define NSPROTO_IDP_PT154   2154
#define NSPROTO_IDP_PT155   2155
#define NSPROTO_IDP_PT156   2156
#define NSPROTO_IDP_PT157   2157
#define NSPROTO_IDP_PT158   2158
#define NSPROTO_IDP_PT159   2159
#define NSPROTO_IDP_PT160   2160
#define NSPROTO_IDP_PT161   2161
#define NSPROTO_IDP_PT162   2162
#define NSPROTO_IDP_PT163   2163
#define NSPROTO_IDP_PT164   2164
#define NSPROTO_IDP_PT165   2165
#define NSPROTO_IDP_PT166   2166
#define NSPROTO_IDP_PT167   2167
#define NSPROTO_IDP_PT168   2168
#define NSPROTO_IDP_PT169   2169
#define NSPROTO_IDP_PT170   2170
#define NSPROTO_IDP_PT171   2171
#define NSPROTO_IDP_PT172   2172
#define NSPROTO_IDP_PT173   2173
#define NSPROTO_IDP_PT174   2174
#define NSPROTO_IDP_PT175   2175
#define NSPROTO_IDP_PT176   2176
#define NSPROTO_IDP_PT177   2177
#define NSPROTO_IDP_PT178   2178
#define NSPROTO_IDP_PT179   2179
#define NSPROTO_IDP_PT180   2180
#define NSPROTO_IDP_PT181   2181
#define NSPROTO_IDP_PT182   2182
#define NSPROTO_IDP_PT183   2183
#define NSPROTO_IDP_PT184   2184
#define NSPROTO_IDP_PT185   2185
#define NSPROTO_IDP_PT186   2186
#define NSPROTO_IDP_PT187   2187
#define NSPROTO_IDP_PT188   2188
#define NSPROTO_IDP_PT189   2189
#define NSPROTO_IDP_PT190   2190
#define NSPROTO_IDP_PT191   2191
#define NSPROTO_IDP_PT192   2192
#define NSPROTO_IDP_PT193   2193
#define NSPROTO_IDP_PT194   2194
#define NSPROTO_IDP_PT195   2195
#define NSPROTO_IDP_PT196   2196
#define NSPROTO_IDP_PT197   2197
#define NSPROTO_IDP_PT198   2198
#define NSPROTO_IDP_PT199   2199
#define NSPROTO_IDP_PT200   2200
#define NSPROTO_IDP_PT201   2201
#define NSPROTO_IDP_PT202   2202
#define NSPROTO_IDP_PT203   2203
#define NSPROTO_IDP_PT204   2204
#define NSPROTO_IDP_PT205   2205
#define NSPROTO_IDP_PT206   2206
#define NSPROTO_IDP_PT207   2207
#define NSPROTO_IDP_PT208   2208
#define NSPROTO_IDP_PT209   2209
#define NSPROTO_IDP_PT210   2210
#define NSPROTO_IDP_PT211   2211
#define NSPROTO_IDP_PT212   2212
#define NSPROTO_IDP_PT213   2213
#define NSPROTO_IDP_PT214   2214
#define NSPROTO_IDP_PT215   2215
#define NSPROTO_IDP_PT216   2216
#define NSPROTO_IDP_PT217   2217
#define NSPROTO_IDP_PT218   2218
#define NSPROTO_IDP_PT219   2219
#define NSPROTO_IDP_PT220   2220
#define NSPROTO_IDP_PT221   2221
#define NSPROTO_IDP_PT222   2222
#define NSPROTO_IDP_PT223   2223
#define NSPROTO_IDP_PT224   2224
#define NSPROTO_IDP_PT225   2225
#define NSPROTO_IDP_PT226   2226
#define NSPROTO_IDP_PT227   2227
#define NSPROTO_IDP_PT228   2228
#define NSPROTO_IDP_PT229   2229
#define NSPROTO_IDP_PT230   2230
#define NSPROTO_IDP_PT231   2231
#define NSPROTO_IDP_PT232   2232
#define NSPROTO_IDP_PT233   2233
#define NSPROTO_IDP_PT234   2234
#define NSPROTO_IDP_PT235   2235
#define NSPROTO_IDP_PT236   2236
#define NSPROTO_IDP_PT237   2237
#define NSPROTO_IDP_PT238   2238
#define NSPROTO_IDP_PT239   2239
#define NSPROTO_IDP_PT240   2240
#define NSPROTO_IDP_PT241   2241
#define NSPROTO_IDP_PT242   2242
#define NSPROTO_IDP_PT243   2243
#define NSPROTO_IDP_PT244   2244
#define NSPROTO_IDP_PT245   2245
#define NSPROTO_IDP_PT246   2246
#define NSPROTO_IDP_PT247   2247
#define NSPROTO_IDP_PT248   2248
#define NSPROTO_IDP_PT249   2249
#define NSPROTO_IDP_PT250   2250
#define NSPROTO_IDP_PT251   2251
#define NSPROTO_IDP_PT252   2252
#define NSPROTO_IDP_PT253   2253
#define NSPROTO_IDP_PT254   2254
#define NSPROTO_IDP_PT255   2255
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\sccomn.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       sccomn.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: sccomn.h
//
// Description: This file contains routines for Socket I/O
//              for use with IPC raw network performance tests.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

typedef int   INTEGER;
typedef struct reqbuf * PREQBUF;
#define ClearSocket(PSOCK) {RtlZeroMemory(PSOCK ,sizeof (SOCKADDR));}

INTEGER
Socket_Listen(
    IN  USHORT	CliIndx
);

INTEGER
Socket_Accept(
    IN  USHORT	CliIndx
);

INTEGER
Socket_Recv(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen
);

INTEGER
Socket_Send(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen
);

INTEGER
Socket_Close(
    IN  USHORT	  CliIndx
);

/************************************************************************/


/************************************************************************/
// External variables
/************************************************************************/
extern PCHAR		HostName;
extern PCHAR		ServerName;
extern int		AddrFly;

extern struct client	Clients[MAXCLIENTS];    // all the client data
extern USHORT		NClients;

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\rawcom.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       rawcom.h
//
//--------------------------------------------------------------------------

/************************************************************************/
// Include Files
/************************************************************************/

// #include <nt.h>
// #include <ntrtl.h>
// #include <nturtl.h>
// #include <ntcsrdll.h>
#include <windef.h>
#include <windows.h>
#include <nb30.h>
#include <winsock.h>
#include "rpc.h"
#include "rpcndr.h"

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// #include "np.h"
// #include "nb.h"
// #include "sct.h"
// #include "scx.h"

#define  DEBUG 0

/************************************************************************/
// Typedef for NTSTATUS and NT_SUCCESS macro
/************************************************************************/
typedef LONG NTSTATUS;
typedef NTSTATUS *PNTSTATUS;

#define NT_SUCCESS(status)  ((NTSTATUS)(status) >= 0)
#define STATUS_UNSUCCESSFUL ((NTSTATUS)0xC0000001L)
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define FSCTL_PIPE_LISTEN CTL_CODE(FILE_DEVICE_NAMED_PIPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define STATUS_PIPE_BROKEN               ((NTSTATUS)0xC000014BL)
#define STATUS_INVALID_PIPE_STATE        ((NTSTATUS)0xC00000ADL)

typedef struct _CLIENT_ID {
    HANDLE UniqueProcess;
    HANDLE UniqueThread;
}CLIENT_ID, *PCLIENT_ID;

/************************************************************************/
// Constants etc.
/************************************************************************/
#define     MAXBUFSIZE	65000
#define     TRUE	1
#define     FALSE	0
#define     STACK_SIZE	1024
#define	    MAXCLIENTS	32
#define	    SRV		1
#define	    CLI		0

#define     BASEIPC	0
#define     NP	        BASEIPC+0
#define     NB	        BASEIPC+1
#define     SCTCP       BASEIPC+2
#define     SCSPX       BASEIPC+3
#define     SCXNS       BASEIPC+3
#define     SCUDP       BASEIPC+4
#define     SCIPX       BASEIPC+5
#define     DGNB        BASEIPC+6

#define     NamePipe    "Nmp"
#define	    NetBIOS	"NetB"
#define	    SocketTCP	"SockTCP"
#define	    SocketXNS	"SockXNS"
#define	    UDP		"UDP"
#define	    IPX		"IPX"
#define	    DGNetBIOS	"DGNetB"


#define     PERFSRV      "IPCSRV"
#define     PERFCLI      "IPCCLI"

// Memory allocation mechanisms

#define AllocType	MEM_COMMIT
#define DeallocType	MEM_DECOMMIT

/*
#define FAIL_CHECK(x,y,z) if (!NT_SUCCESS(z)) { \
			   DbgPrint("%s:Error in %s: status:%lx\n", x,y,z); \
                           Failure = TRUE; \
                           break; \
                          }
*/

#define FAIL_CHECK(x,y,z)   if (!NT_SUCCESS(z)) { \
                                char outputDebugBuffer[100]; \
                                _snprintf(outputDebugBuffer, 100, "%s:Error in %s: status:%lx\n", x, y, z); \
                                OutputDebugString(outputDebugBuffer); \
                                Failure = TRUE; \
                                break; \
                            }
/*
#define FAIL_CHECK_EXIT(x,y,z) if (!NT_SUCCESS(z)) { \
			   DbgPrint("%s:Error in %s: status:%lx\n", x,y,z); \
                          Failure = TRUE; \
                           return; \
                          }
*/

#define FAIL_CHECK_EXIT(x,y,z)  if (!NT_SUCCESS(z)) { \
                                    char outputDebugBuffer[100]; \
                                    _snprintf(outputDebugBuffer, 100, "%s:Error in %s: status:%lx\n", x, y, z); \
                                    OutputDebugString(outputDebugBuffer); \
                                    Failure = TRUE; \
                                    return; \
                                }

#define MyDbgPrint(x)   if (DEBUG) { \
                            char outputDebugBuffer[100]; \
                            _snprintf(outputDebugBuffer, 100, (x)); \
                            OutputDebugString(outputDebugBuffer); \
                        }

#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#ifndef _DBGNT_
ULONG
DbgPrint(
    PCH Format,
    ...
    );
#endif // _DBGNT_

/************************************************************************/
// Local Structures
/************************************************************************/
struct reqbuf {
    ULONG	Iterations;
    ULONG	SendSize;
    ULONG	NumSends;
    ULONG	RecvSize;
    ULONG	NumRecvs;
    USHORT	ClientNumber;
    UCHAR	TestCmd;	// only for  'E' and transact NamedPipe	U/T
    UCHAR	RSVD[9];
};

// Client structure is organized into IPC independent fields followed by IPC
// dependent part.

// NamedPipe info structure
struct NmpInfo {	
	HANDLE		c_PipeHandle;
    BOOLEAN		c_DoTransact;
};

// NetBIOS info structure
struct NetBInfo {
	UCHAR		c_LSN;
	UCHAR		c_NameNum;
	PUCHAR		c_pRecvBufG;	// global buffer for double receives
    USHORT		c_LanaNumber;   // lana number for a client
    HANDLE		c_SendEvent;
    HANDLE		c_RecvEvent;
    HANDLE		c_RecvEventG;
	BOOLEAN		c_RecvPosted;   // while doing RecvSend

};

// Socket info structure
struct SockInfo {
	SOCKET		c_Sockid;
	SOCKET		c_Listenid;
};

struct client {
	USHORT		    c_client_num;	  // This client number
    HANDLE		    c_hThHandle;	  // Thread handle
    CLIENT_ID	    c_ThClientID;	  // Thread client Id.
	struct reqbuf   c_reqbuf;	      // Request buffer
	PCHAR           c_pSendBuf;	      // Ptr. to the send buffer
	PCHAR           c_pRecvBuf;	      // Ptr. to the Recv buffer
	DWORD		    c_Duration;       // Total time in msecs.
    union IPCinfo {
          struct NmpInfo  c_Nmp; 	  // NamedPipe specific info
          struct NetBInfo c_NetB;	  // NetBIOS info.
          struct SockInfo c_Sock;	  // Socket Info.
    };
};

typedef struct _THREADPARAMS {
    PHANDLE		phThHandle;
    PCLIENT_ID		pThClientID;
} THREADPARAMS;


/************************************************************************/
// Local function prototypes
/************************************************************************/
VOID
Usage(
    IN PSZ PrgName
    );


NTSTATUS
Parse_Cmd_Line(
    IN  USHORT argc,
    IN  PSZ    argv[]
    );


VOID
SrvService(
    IN PUSHORT pTindex
);

VOID
Cleanup(
);

/************************************************************************/
// External function prototypes
/************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\sct.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       sct.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: sct.h
//
// Description: This file contains routines for Socket I/O
//              for use with IPC raw network performance tests.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#define MSIPX (AddrFly == AF_NS)

#define MAXSEQ		8
#define SERV_TCP_PORT	6666
#define SERV_UDP_PORT	6900
#define SERV_HOST_ADDR  11.30.11.20
#define CLINAME         11.30.11.22
#define SRVNAME_LEN	16

#define REQ	0
#define DATA	1


#define ClearSocket(PSOCK) {RtlZeroMemory(PSOCK ,sizeof (SOCKADDR));}

typedef int INTEGER;
typedef struct reqbuf * PREQBUF;


/************************************************************************/
// External variables
/************************************************************************/
extern PCHAR		HostName;
extern PCHAR		ServerName;
extern int		AddrFly;

extern struct client	Clients[MAXCLIENTS];    // all the client data
extern USHORT		NClients;

/************************************************************************/
// External Function prototypes
/************************************************************************/

INTEGER
TCPSocket_Connect(
    IN  int	AddrFly,
    IN  USHORT  CIndex,
    IN  PCHAR	srvaddr
);

NTSTATUS
SCTCP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

NTSTATUS
SCTCP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

NTSTATUS
SCTCP_Allocate_Memory(
    IN	   USHORT	CIndex
);

NTSTATUS
SCTCP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


NTSTATUS
SCTCP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


NTSTATUS
SCTCP_Cleanup(
    VOID
);

NTSTATUS
SCTCP_Wait_For_Client(
    IN  USHORT CIndex
);

NTSTATUS
SCTCP_Disconnect_Client(
    IN  USHORT CIndex
);


NTSTATUS
SCTCP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

NTSTATUS
SCTCP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

NTSTATUS
SCTCP_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN	   BOOLEAN	FirstIter
);

NTSTATUS
SCTCP_ThreadCleanUp(
    IN	   USHORT	CIndex
);

/************************************************************************/
// External Function prototypes
/************************************************************************/

extern
INTEGER
Socket_Listen(
    IN  USHORT	CliIndx
);

extern
INTEGER
Socket_Accept(
    IN  USHORT	CliIndx
);

extern
INTEGER
Socket_Recv(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen
);

extern
INTEGER
Socket_Send(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen
);

extern
INTEGER
Socket_Close(
    IN  USHORT	  CliIndx
);

/************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\scipx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       scipx.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: scipx.h
//
// Description: This file contains routines for Socket I/O
//              for use with IPC raw network performance tests.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "msipx.h"

#define MSIPX (AddrFly == AF_NS)

#define MAXSEQ		8
#define SERV_TCP_PORT	6666
#define SERV_IPX_PORT	6900
#define SERV_HOST_ADDR  11.30.11.20
#define CLINAME         11.30.11.22
#define SRVNAME_LEN	16

#define REQ	0
#define DATA	1


#define ClearSocket(PSOCK) {RtlZeroMemory(PSOCK ,sizeof (SOCKADDR));}

typedef int INTEGER;
typedef struct reqbuf * PREQBUF;


/************************************************************************/
// External variables
/************************************************************************/
extern PCHAR	HostName;
extern PCHAR	ServerName;
extern int	AddrFly;
extern BOOLEAN	Connected;

extern struct client	Clients[MAXCLIENTS];    // all the client data
extern USHORT		NClients;

/************************************************************************/
// External Function prototypes
/************************************************************************/


NTSTATUS
SCIPX_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

NTSTATUS
SCIPX_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

NTSTATUS
SCIPX_Allocate_Memory(
    IN	   USHORT	CIndex
);

NTSTATUS
SCIPX_Deallocate_Memory(
    IN	   USHORT	CIndex
);


NTSTATUS
SCIPX_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


NTSTATUS
SCIPX_Cleanup(
    VOID
);


NTSTATUS
SCIPX_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

NTSTATUS
SCIPX_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);


NTSTATUS
SCIPX_ThreadCleanUp(
    IN	   USHORT	CIndex
);

/************************************************************************/
// External Function prototypes
/************************************************************************/

extern
INTEGER
DGSocket_Recv(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen
);

extern
INTEGER
DGSocket_RecvFrom(
    IN USHORT	        CliIndx,
    IN OUT PVOID        PReadBuf,
    IN OUT PULONG       rpdatalen,
    IN OUT PSOCKADDR    pcaddr,
    IN OUT PUSHORT      pcaddrlen
);

extern
INTEGER
DGSocket_Send(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen
);

extern
INTEGER
DGSocket_SendTo(
    IN USHORT	        CliIndx,
    IN OUT PVOID        PWriteBuf,
    IN OUT PULONG       spdatalen,
    IN OUT PSOCKADDR 	pcaddr,
    IN OUT PUSHORT      pcaddrlen
);

extern
INTEGER
DGSocket_Close(
    IN  USHORT	  CliIndx
);

extern
INTEGER
DGSocket_Connect(
    IN USHORT	  CIndex,
    IN PSOCKADDR  pdsockaddr
);


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\scudp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       scudp.h
//
//--------------------------------------------------------------------------

/**********************************************************************/
//   This file contains Socket specific  routines for Socket  I/O 
/**********************************************************************/


#define MSIPX (AddrFly == AF_NS)

#define MAXSEQ		8
#define SERV_TCP_PORT	6666
#define SERV_UDP_PORT	6900
#define SERV_HOST_ADDR  11.30.11.20
#define CLINAME         11.30.11.22
#define SRVNAME_LEN	16

#define REQ	0
#define DATA	1


#define ClearSocket(PSOCK) {RtlZeroMemory(PSOCK ,sizeof (SOCKADDR));}

typedef int INTEGER;
typedef struct reqbuf * PREQBUF;


/************************************************************************/
// External variables 
/************************************************************************/
extern PCHAR	HostName;
extern PCHAR	ServerName;
extern int	AddrFly;
extern BOOLEAN	Connected;

extern struct client	Clients[MAXCLIENTS];    // all the client data 
extern USHORT		NClients;

/************************************************************************/
// External Function prototypes
/************************************************************************/


NTSTATUS
SCUDP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

NTSTATUS
SCUDP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

NTSTATUS
SCUDP_Allocate_Memory(
    IN	   USHORT	CIndex
);

NTSTATUS
SCUDP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


NTSTATUS
SCUDP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


NTSTATUS
SCUDP_Cleanup(
    VOID
);


NTSTATUS
SCUDP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

NTSTATUS
SCUDP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);


NTSTATUS
SCUDP_ThreadCleanUp(
    IN	   USHORT	CIndex
);

/************************************************************************/
// External Function prototypes
/************************************************************************/

extern
INTEGER
DGSocket_Recv(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen
);

extern
INTEGER
DGSocket_RecvFrom(
    IN USHORT	        CliIndx,
    IN OUT PVOID        PReadBuf,
    IN OUT PULONG       rpdatalen,
    IN OUT PSOCKADDR    pcaddr,
    IN OUT PUSHORT      pcaddrlen
);

extern
INTEGER
DGSocket_Send(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen
);

extern
INTEGER
DGSocket_SendTo(
    IN USHORT	        CliIndx,
    IN OUT PVOID        PWriteBuf,
    IN OUT PULONG       spdatalen,
    IN OUT PSOCKADDR 	pcaddr,
    IN OUT PUSHORT      pcaddrlen
);

extern
INTEGER
DGSocket_Close(
    IN  USHORT	  CliIndx
);

extern
INTEGER
DGSocket_Connect(
    IN USHORT	  CIndex,
    IN PSOCKADDR  pdsockaddr
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\inc\scx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       scx.h
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: scx.h
//
// Description: This file contains routines for Socket I/O
//              for use with IPC raw network performance tests.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////


#define MSIPX (AddrFly == AF_NS)

#define MAXSEQ		8
#define SERV_TCP_PORT	6666
#define SERV_SPX_PORT	6666
#define SERV_UDP_PORT	6900
#define SERV_HOST_ADDR  11.30.11.20
#define SRVNAME_LEN	16

#define REQ	0
#define DATA	1


#define ClearSocket(PSOCK) {RtlZeroMemory(PSOCK ,sizeof (SOCKADDR));}

typedef int INTEGER;
typedef struct reqbuf * PREQBUF;

/************************************************************************/
// External variables
/************************************************************************/
extern PCHAR		HostName;
extern PCHAR		ServerName;
extern int		AddrFly;

extern struct client	Clients[MAXCLIENTS];    // all the client data
extern USHORT		NClients;

/************************************************************************/
// Local Function prototypes
/************************************************************************/
INTEGER
SPXSocket_Connect(
    IN    int	  AddrFly,
    IN    USHORT  CIndex,
    IN    PCHAR   srvaddr
);


NTSTATUS
SCXNS_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

NTSTATUS
SCXNS_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

NTSTATUS
SCXNS_Allocate_Memory(
    IN	   USHORT	CIndex
);

NTSTATUS
SCXNS_Deallocate_Memory(
    IN	   USHORT	CIndex
);


NTSTATUS
SCXNS_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


NTSTATUS
SCXNS_Cleanup(
    VOID
);

NTSTATUS
SCXNS_Wait_For_Client(
    IN  USHORT CIndex
);

NTSTATUS
SCXNS_Disconnect_Client(
    IN  USHORT CIndex
);


NTSTATUS
SCXNS_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

NTSTATUS
SCXNS_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

NTSTATUS
SCXNS_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN	   BOOLEAN	FirstIter
);

NTSTATUS
SCXNS_ThreadCleanUp(
    IN	   USHORT	CIndex
);

/************************************************************************/
// External Function prototypes
/************************************************************************/

extern
INTEGER
Socket_Listen(
    IN  USHORT	CliIndx
);

extern
INTEGER
Socket_Accept(
    IN  USHORT	CliIndx
);

extern
INTEGER
Socket_Recv(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PReadBuf,
    IN OUT PULONG rpdatalen
);

extern
INTEGER
Socket_Send(
    IN USHORT	  CliIndx,
    IN OUT PVOID  PWriteBuf,
    IN OUT PULONG spdatalen
);

extern
INTEGER
Socket_Close(
    IN  USHORT	  CliIndx
);

/************************************************************************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\server\server.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       server.h
//
//--------------------------------------------------------------------------


/************************************************************************/
// Local function prototypes
/************************************************************************/

VOID
Usage(
    IN PSZ PrgName
    );

VOID
Setup_Function_Pointers(
);

NTSTATUS
Wait_For_Client_Threads(
);


NTSTATUS
Parse_Cmd_Line(
    IN  USHORT argc,
    IN  PSZ    argv[]
    );


VOID
SrvService(
    IN PUSHORT pTindex
);

VOID
Cleanup(
);

/************************************************************************/
// External function prototypes
/************************************************************************/

/*++ 
    For NamedPipe

--*/
extern
NTSTATUS
NMP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
NMP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
NMP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
NMP_Cleanup(
    VOID
);

extern
NTSTATUS
NMP_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
NMP_Disconnect_Client(
    IN  USHORT CIndex
);


extern
NTSTATUS
NMP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NMP_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN     BOOLEAN	FirstIter
);

extern
NTSTATUS
NMP_ThreadCleanUp(
    IN  USHORT CIndex
);


/*++**********************************************************************
    For NetBIOS

--*/
extern
NTSTATUS
NB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
NB_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
NB_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
NB_Cleanup(
    VOID
);

extern
NTSTATUS
NB_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
NB_Disconnect_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
NB_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
NB_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN     BOOLEAN	FirstIter
);

extern
NTSTATUS
NB_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets TCP/IP

--*/
extern
NTSTATUS
SCTCP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCTCP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCTCP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
SCTCP_Cleanup(
    VOID
);

extern
NTSTATUS
SCTCP_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCTCP_Disconnect_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCTCP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCTCP_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN     BOOLEAN	FirstIter
);

extern
NTSTATUS
SCTCP_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets SPX(XNS)

--*/
extern
NTSTATUS
SCXNS_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCXNS_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCXNS_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
SCXNS_Cleanup(
    VOID
);

extern
NTSTATUS
SCXNS_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCXNS_Disconnect_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCXNS_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCXNS_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN     BOOLEAN	FirstIter
);

extern
NTSTATUS
SCXNS_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets UDP

--*/
extern
NTSTATUS
SCUDP_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCUDP_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCUDP_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
SCUDP_Cleanup(
    VOID
);

extern
NTSTATUS
SCUDP_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCUDP_Disconnect_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCUDP_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCUDP_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Sockets IPX

--*/
extern
NTSTATUS
SCIPX_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
SCIPX_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
SCIPX_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
SCIPX_Cleanup(
    VOID
);

extern
NTSTATUS
SCIPX_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCIPX_Disconnect_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
SCIPX_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
SCIPX_ThreadCleanUp(
    IN  USHORT CIndex
);

/*++**********************************************************************
    For Datagram NetBIOS

--*/
extern
NTSTATUS
DGNB_Initialize(
    IN     USHORT	NClients,
    IN     PCHAR        ServerName,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_PerClientInit(
    IN	   USHORT	CIndex,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_Allocate_Memory(
    IN	   USHORT	CIndex
);

extern
NTSTATUS
DGNB_Deallocate_Memory(
    IN	   USHORT	CIndex
);


extern
NTSTATUS
DGNB_DoHandshake(
    IN	   USHORT	CIndex,
    IN	   USHORT	SrvCli
);


extern
NTSTATUS
DGNB_Cleanup(
    VOID
);

extern
NTSTATUS
DGNB_Wait_For_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
DGNB_Disconnect_Client(
    IN  USHORT CIndex
);

extern
NTSTATUS
DGNB_ReadFromIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_WriteToIPC(
    IN     USHORT       CIndex,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli
);

extern
NTSTATUS
DGNB_XactIO(
    IN     USHORT       CIndex,
    IN OUT PULONG	pReadDone,
    IN OUT PULONG	pWriteDone,
    IN     USHORT	SrvCli,
    IN     BOOLEAN	FirstIter
);

extern
NTSTATUS
DGNB_ThreadCleanUp(
    IN  USHORT CIndex
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rawio\ioclnt.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ipclnt.h

Abstract:

    Io completion port client header.

Author:

    Win32 SDK sample

Revision History:

    MarioGo     3/3/1996    Cloned from win32 sdk sockets sample.

--*/

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <winsock.h>
#include <wsipx.h>
#include <commdef.h>

BOOL fVerbose;
BOOL fRandom;
DWORD dwIterations;
DWORD dwTransferSize;
IN_ADDR RemoteIpAddress;

CLIENT_IO_BUFFER SendBuffer;
CHAR ReceiveBuffer[CLIENT_OUTBOUND_BUFFER_MAX];

VOID
WINAPI
ShowUsage (
             VOID
);

VOID
WINAPI
ParseSwitch (
               CHAR chSwitch,
               int *pArgc,
               char **pArgv[]
);

VOID
WINAPI
CompleteBenchmark (
                     VOID
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\raw\server\server.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       server.c
//
//--------------------------------------------------------------------------

/////////////////////////////////////////////////////////////////////////
//
// Filename: server.c
//
// Description: This file contains the source code for IPC performance.
//              This module is written using win32 API calls, and will
//              generate a console server app.
//
// Authors: Scott Holden (Translator from NT API to win32 API)
//          Mahesh Keni  (Mahesh wrote this application using mostly
//                        NT native API calls)
//
/////////////////////////////////////////////////////////////////////////

#include "rawcom.h"
#include "server.h"

/************************************************************************/
// Global variables
/************************************************************************/

struct client	Clients[MAXCLIENTS];    // all the client data
HANDLE 		    Threads[MAXCLIENTS];
USHORT		    NClients    = 1;		// number of clients
USHORT		    IPCType     = NP;		// IPC type
LARGE_INTEGER	Timeout;		        // for the main thread
CHAR    	    Xport[9];	    	    // Xport type Name
USHORT		    ThreadError = 0;
BOOLEAN		    Failure     = FALSE;

// function pointers for redirecting calls according to Xport types
NTSTATUS 	(* IPC_Initialize)();	
NTSTATUS 	(* IPC_PerClientInit)();	
NTSTATUS 	(* IPC_Wait_For_Client)();	
NTSTATUS 	(* IPC_Disconnect_Client)();	
NTSTATUS 	(* IPC_Cleanup)();	
NTSTATUS 	(* IPC_Allocate_Memory)();	
NTSTATUS 	(* IPC_DoHandshake)();	
NTSTATUS 	(* IPC_ReadFromIPC)();	
NTSTATUS 	(* IPC_WriteToIPC)();	
NTSTATUS 	(* IPC_XactIO)();	
NTSTATUS 	(* IPC_Deallocate_Memory)();	
NTSTATUS 	(* IPC_ThreadCleanUp)();	

// Later all of this should move under an union
// Globals for NamedPipe
//OBJECT_ATTRIBUTES   objectAttributes;
//UNICODE_STRING	    unicodePipeName;
char        *pipeName;
ULONG		Quotas      = 32768;			        // read/write quota
ULONG		PipeType    = PIPE_TYPE_MESSAGE;        // pipe type
ULONG		PipeMode    = PIPE_READMODE_MESSAGE;    // read mode
ULONG		BlockorNot  = PIPE_NOWAIT;              // non blocking

// Globals for NetBIOS
USHORT		LanaCount = 1;		
USHORT		LanaBase  = 0;		
USHORT		MachineNumber  = 1;		
UCHAR		NameNumber = 1;		
CHAR		LocalName[NCBNAMSZ];
CHAR		RemoteName[NCBNAMSZ];

// GLobals for Sockets
PCHAR		ServerName = NULL;	// local host ip address
PCHAR		HostName = NULL;	// local host ip address
int		    AddrFly;

/************************************************************************/
NTSTATUS
__cdecl main (
    IN USHORT argc,
    IN PSZ argv[],
    IN PSZ envp[])
{
    NTSTATUS 		mstatus;
    USHORT		    Cindex = 0; // client index
    //UCHAR		    NBretcode;  // NetBIOS call return code
    //USHORT	    LanaNumber;

    // argc, argv, envp; // Shut up the compiler
    mstatus = Parse_Cmd_Line(argc, argv);
    if (!NT_SUCCESS(mstatus)) {
        return(1);
    }
    // based on the Xport type set up all the function pointers
    Setup_Function_Pointers();

    // do IPC dependent initializing
    mstatus = IPC_Initialize(NClients, HostName, SRV);
    if (!NT_SUCCESS(mstatus)) {
        return(1);
    }
    // now create worker threads for handling NetBIOS I/O requests
    printf("Creating %s Server threads...", Xport);
    for (Cindex = 0; Cindex < NClients; Cindex++) {
        // do appropriate per client initialization
        mstatus = IPC_PerClientInit(Cindex,SRV);

	    // use win32 API instead of NT native so that NetBIOS works fine
        Clients[Cindex].c_hThHandle = CreateThread(
				                            NULL,
				                            0,
				                            (LPTHREAD_START_ROUTINE)&SrvService,
			                                (PUSHORT)&(Clients[Cindex].c_client_num),
				                            0,
				                            (LPDWORD)&(Clients[Cindex].c_ThClientID));
	    Threads[Cindex] = Clients[Cindex].c_hThHandle; //*get rid of one handle
	    printf("%d..",Cindex+1);
    }
    printf("\n");

    //The main thread should now wait for all the other threads
    if (!mstatus) { 	// if no error then wait for everyone to sync
        mstatus = Wait_For_Client_Threads();
   	    if (!NT_SUCCESS(mstatus)) {
            printf ("Failed on wait err=%lx\n",mstatus);
    	}
    }
    // now do the cleanup. i.e.  clear all memory and close all handles
    IPC_Cleanup(NClients);
    exit(0);
} // main

/************************************************************************/
/*++
    This routine sets up all the function pointers based on Xport type
    I could just set one pointer to a function table supporting all the
    functions and move all tis initialization in individual init routines.
    Will be done in future.
--*/

VOID
Setup_Function_Pointers()
{
    // based on Xport type take the action
    switch(IPCType) {
        case NP:
    	    IPC_Initialize	      = NMP_Initialize;
    	    IPC_PerClientInit	  = NMP_PerClientInit;	
    	    IPC_Wait_For_Client	  = NMP_Wait_For_Client;	
    	    IPC_Disconnect_Client = NMP_Disconnect_Client;
    	    IPC_Cleanup		      = NMP_Cleanup;
    	    IPC_Allocate_Memory	  = NMP_Allocate_Memory;
    	    IPC_DoHandshake	      = NMP_DoHandshake;
    	    IPC_ReadFromIPC       = NMP_ReadFromIPC;
    	    IPC_WriteToIPC	      = NMP_WriteToIPC;
    	    IPC_XactIO		      = NMP_XactIO;
    	    IPC_Deallocate_Memory = NMP_Deallocate_Memory;
    	    IPC_ThreadCleanUp	  = NMP_ThreadCleanUp;
    	    break;
        case NB:
    	    IPC_Initialize	      = NB_Initialize;
    	    IPC_PerClientInit	  = NB_PerClientInit;	
    	    IPC_Cleanup		      = NB_Cleanup;
    	    IPC_Wait_For_Client	  = NB_Wait_For_Client;	
    	    IPC_Disconnect_Client = NB_Disconnect_Client;
    	    IPC_Allocate_Memory	  = NB_Allocate_Memory;
    	    IPC_DoHandshake	      = NB_DoHandshake;
    	    IPC_ReadFromIPC	      = NB_ReadFromIPC;
    	    IPC_WriteToIPC	      = NB_WriteToIPC;
    	    IPC_XactIO		      = NB_XactIO;
    	    IPC_Deallocate_Memory = NB_Deallocate_Memory;
    	    IPC_ThreadCleanUp	  = NB_ThreadCleanUp;
    	    break;

        case SCTCP:
    	    IPC_Initialize	      = SCTCP_Initialize;
    	    IPC_PerClientInit	  = SCTCP_PerClientInit;	
    	    IPC_Cleanup		      = SCTCP_Cleanup;
    	    IPC_Wait_For_Client	  = SCTCP_Wait_For_Client;	
    	    IPC_Disconnect_Client = SCTCP_Disconnect_Client;
    	    IPC_Allocate_Memory	  = SCTCP_Allocate_Memory;
    	    IPC_DoHandshake	      = SCTCP_DoHandshake;
    	    IPC_ReadFromIPC	      = SCTCP_ReadFromIPC;
    	    IPC_WriteToIPC	      = SCTCP_WriteToIPC;
    	    IPC_XactIO		      = SCTCP_XactIO;
    	    IPC_Deallocate_Memory = SCTCP_Deallocate_Memory;
    	    IPC_ThreadCleanUp	  = SCTCP_ThreadCleanUp;
    	    break;

        case SCXNS:
    	    IPC_Initialize	      = SCXNS_Initialize;
    	    IPC_PerClientInit	  = SCXNS_PerClientInit;	
    	    IPC_Wait_For_Client	  = SCXNS_Wait_For_Client;	
    	    IPC_Disconnect_Client = SCXNS_Disconnect_Client;
    	    IPC_Cleanup		      = SCXNS_Cleanup;
    	    IPC_Allocate_Memory	  = SCXNS_Allocate_Memory;
    	    IPC_DoHandshake	      = SCXNS_DoHandshake;
    	    IPC_ReadFromIPC	      = SCXNS_ReadFromIPC;
    	    IPC_WriteToIPC	      = SCXNS_WriteToIPC;
    	    IPC_XactIO		      = SCXNS_XactIO;
    	    IPC_Deallocate_Memory = SCXNS_Deallocate_Memory;
    	    IPC_ThreadCleanUp	  = SCXNS_ThreadCleanUp;
    	    break;

        case SCUDP:
    	    IPC_Initialize	      = SCUDP_Initialize;
    	    IPC_PerClientInit	  = SCUDP_PerClientInit;	
    	    IPC_Wait_For_Client	  = SCUDP_Wait_For_Client;	
    	    IPC_Disconnect_Client = SCUDP_Disconnect_Client;
    	    IPC_Cleanup		      = SCUDP_Cleanup;
    	    IPC_Allocate_Memory	  = SCUDP_Allocate_Memory;
    	    IPC_DoHandshake	      = SCUDP_DoHandshake;
    	    IPC_ReadFromIPC	      = SCUDP_ReadFromIPC;
    	    IPC_WriteToIPC	      = SCUDP_WriteToIPC;
    	    IPC_Deallocate_Memory = SCUDP_Deallocate_Memory;
    	    IPC_ThreadCleanUp	  = SCUDP_ThreadCleanUp;
    	    break;

        case SCIPX:
    	    IPC_Initialize	      = SCIPX_Initialize;
    	    IPC_PerClientInit	  = SCIPX_PerClientInit;	
    	    IPC_Wait_For_Client	  = SCIPX_Wait_For_Client;	
    	    IPC_Disconnect_Client = SCIPX_Disconnect_Client;
    	    IPC_Cleanup		      = SCIPX_Cleanup;
    	    IPC_Allocate_Memory	  = SCIPX_Allocate_Memory;
    	    IPC_DoHandshake	      = SCIPX_DoHandshake;
    	    IPC_ReadFromIPC	      = SCIPX_ReadFromIPC;
    	    IPC_WriteToIPC	      = SCIPX_WriteToIPC;
    	    IPC_Deallocate_Memory = SCIPX_Deallocate_Memory;
    	    IPC_ThreadCleanUp	  = SCIPX_ThreadCleanUp;
            break;

        case DGNB:
    	    IPC_Initialize	      = DGNB_Initialize;
    	    IPC_PerClientInit	  = DGNB_PerClientInit;	
    	    IPC_Cleanup		      = DGNB_Cleanup;
    	    IPC_Wait_For_Client	  = DGNB_Wait_For_Client;	
    	    IPC_Disconnect_Client = DGNB_Disconnect_Client;
    	    IPC_Allocate_Memory	  = DGNB_Allocate_Memory;
    	    IPC_DoHandshake	      = DGNB_DoHandshake;
    	    IPC_ReadFromIPC	      = DGNB_ReadFromIPC;
    	    IPC_WriteToIPC	      = DGNB_WriteToIPC;
    	    IPC_XactIO		      = DGNB_XactIO;
    	    IPC_Deallocate_Memory = DGNB_Deallocate_Memory;
    	    IPC_ThreadCleanUp	  = DGNB_ThreadCleanUp;
    	    break;

        default :
            // problem here
            printf("Incorrect Xport selection\n");
    }
}
/************************************************************************/

/*++
    This routine makes the main thread wait for all the client threads to
    exit.
--*/

NTSTATUS
Wait_For_Client_Threads(VOID)
{
    NTSTATUS 		wstatus;
    DWORD MTimeout  = INFINITE;

    printf("Main thread waiting for Client threads ");

    wstatus = WaitForMultipleObjectsEx(NClients,
		                               Threads,
		                               TRUE,           // Wait for all objects
                                       MTimeout,       // Default timeout
                                       TRUE);          // Alertable
    printf(".. Wait over with status:%lx\n",wstatus);

    if (!NT_SUCCESS(wstatus)) {
       printf ("Failed on wait err=%lx\n",wstatus);
    }
    if (ThreadError) {
        printf("Thread Error: %d \n", ThreadError);
    }
    return wstatus;
}

/************************************************************************/
/*++
    This routine  is the thread service routine. It first waits for clients to
    connect. Then it does a handshake to gather all the test info. Then it
    services all requests.
--*/

VOID
SrvService(	// provides server service
  IN  PUSHORT pTindex)
{
    NTSTATUS 	tstatus;
    USHORT	    tCindex;
    //UCHAR	    RetCode;
    BOOLEAN	    keepdoing;
    BOOLEAN	    Terminate;
    ULONG	    RecvLen     = 0;	
    ULONG	    SendLen     = 0;	
    ULONG	    Iterations  = 0;
    BOOLEAN	    First       = TRUE;

    tCindex     = *pTindex;
    keepdoing   = TRUE;
    ThreadError = 0;
    Failure     = FALSE;

    do {  // keep doing the work till it receives 'E' from client
        //DbgPrint("Srv:Waiting for a client %d\n",tCindex);
        // First post listen for a client's connection request
        tstatus = IPC_Wait_For_Client(tCindex);

        ThreadError = 1;
        FAIL_CHECK(PERFSRV, " Wait for Client" , tstatus);

        // now the thread has been connected

        // now do the handshake to read the request message
        tstatus = IPC_DoHandshake(tCindex,SRV);

        ThreadError = 2;
        FAIL_CHECK(PERFSRV, " Doing Handshake" , tstatus);

        // allocate memory for data buffers and start the I/O

        tstatus = IPC_Allocate_Memory(tCindex);

        ThreadError = 3;
        FAIL_CHECK(PERFSRV, " Memory Allocation" , tstatus);


        // check if the client wants to quit.
        // Set up number of iterations

        Iterations = Clients[tCindex].c_reqbuf.Iterations;

        Terminate = FALSE;
        First     = TRUE;

        while (Iterations--) {
            if (Clients[tCindex].c_reqbuf.TestCmd = 'P') {
                // now the server has to first receive X messages and then
                // send Y messages.

                MyDbgPrint("Srv:Reading \n");
                tstatus = IPC_ReadFromIPC( tCindex, &RecvLen,SRV);

                ThreadError = 4;
                FAIL_CHECK(PERFSRV, " Read from IPC" , tstatus);


                // We can check for recv length and data integrity out here

                MyDbgPrint("Srv:Writing \n");
                tstatus = IPC_WriteToIPC( tCindex, &SendLen, SRV);

                ThreadError = 5;
                FAIL_CHECK(PERFSRV, " Read from IPC" , tstatus);
             }
             else { // for 'U' or 'T' do transct I/O
                 // We have to do something different for NetBIOS as
                 // it sould first post a receive and then do RecvSend for
                 // Other iterations. for Client this works fine as it always
 		         //  does send/Recv.


                tstatus = IPC_XactIO( tCindex, &SendLen, &RecvLen, SRV,First);

                // FAIL_CHECK(PERFSRV, " Xact IPC" , tstatus);
                ThreadError = 6;
                if (!NT_SUCCESS(tstatus)) {
                   if ((tstatus != STATUS_PIPE_BROKEN) &&
                       (tstatus != STATUS_INVALID_PIPE_STATE)) {

                       //DbgPrint("Error in XactIO: %lx \n", tstatus);
                   }
                   break;
                }
                First = FALSE;
             }
        }
        // now we are done with the current tests so do the cleanup and
        // start all over again
        tstatus = IPC_Disconnect_Client(tCindex);

        ThreadError = 7;
        FAIL_CHECK(PERFSRV, " Disconnect Client " , tstatus);

        tstatus = IPC_Deallocate_Memory(tCindex);

        ThreadError = 8;
        FAIL_CHECK(PERFSRV, " Memory Deallocation" , tstatus);

        ThreadError = 0;

    } while (keepdoing); // till we receive 'E' or bad status

    // we should check if we have to deallocate all the buffers.
    // Do all the thread cleanup work

    tstatus = IPC_ThreadCleanUp(tCindex);
}
/************************************************************************/
VOID
Cleanup(VOID)
{
    USHORT		Cindex = 0; // client index
    NTSTATUS 		cstatus;
    NTSTATUS 		exitstatus = 0;

    for (Cindex = 0; Cindex < NClients; Cindex++) {
	//  terminate the thread
        cstatus = TerminateThread(Clients[Cindex].c_hThHandle, exitstatus);

        if (!NT_SUCCESS(cstatus)) {
              printf("Failed to terminate thread no:%d err=%lx\n", Cindex,cstatus);
        }
    }
    printf("Terminated All Threads\n");
}
/************************************************************************/
NTSTATUS
Parse_Cmd_Line(USHORT argc, CHAR *argv[])
{
	USHORT		i;
	PCHAR		s;
	NTSTATUS 	pstatus = 0L;
    BOOLEAN		doingok = TRUE;

	if (argc > 5) {
	    printf("Too many arguments \n");
	    pstatus = -1L;
	}
    // copy default Xport name : Nmp
    strncpy(Xport, NamePipe, 8);

	for (i=1; (doingok) && (i< argc); i++) {

		s = argv[i];

		if ((*s == '/') &&(*(s+2) == ':'))
		{
		    s++;

		    switch(*s) {

			case 'b' :
			case 'B' :
				LanaBase = (USHORT)atoi(s+2);
				break;

			case 'c' :  // number of Clients
			case 'C' :
				NClients = (USHORT)atoi(s+2);
				break;

			case 'h' :
			case 'H' :
                HostName = (PCHAR) malloc(strlen(s+2)+1);
				strcpy(HostName,s+2);
                        // check for the validity of the address
				break;

			case 'l' :
			case 'L' :
				LanaCount = (USHORT)atoi(s+2);
				break;

			case 'p' :  // NamedPipe mode
			case 'P' :
                        switch(*(s+2)) {
                            case 'm':
                            case 'M':
				                PipeType = PIPE_TYPE_MESSAGE;
				                PipeMode = PIPE_READMODE_MESSAGE;
                                break;

                            case 's':
                            case 'S':
				                PipeType = PIPE_TYPE_BYTE;
				                PipeMode = PIPE_READMODE_BYTE;
                                break;

                            default:
                                doingok = FALSE;
		    		            break;
                        }

			case 'x' : // Xport Type
			case 'X' :
				strncpy(Xport, (PUCHAR) (s+2), 8);

                if (!_stricmp(Xport,NamePipe)) {
                    IPCType = NP;
                    break;
                }

                if (!_stricmp(Xport,NetBIOS)) {
                    IPCType = NB;
                    break;
                }

                if (!_stricmp(Xport,SocketXNS)) {
                    IPCType = SCXNS;
                    AddrFly = AF_NS;
                    break;
                }

                if (!_stricmp(Xport,SocketTCP)) {
                    IPCType = SCTCP;
                    AddrFly = AF_INET;
                    break;
                }

                if (!_stricmp(Xport,UDP)) {
                    IPCType = SCUDP;
                    AddrFly = AF_INET;
                    break;
                }

                if (!_stricmp(Xport,IPX)) {
                    IPCType = SCIPX;
                    AddrFly = AF_NS;
                    break;
                }

                if (!_stricmp(Xport,DGNetBIOS)) {
                    IPCType = DGNB;
                    break;
                }

                // bad choice of Xport
                doingok = FALSE;
				break;

			default :
                doingok = FALSE;

			}
		}
		else {
            doingok = FALSE;
		}
	}

    if (!doingok) {
	    Usage(argv[0]);
	    pstatus = -1L;
	}
    else {
        if (((IPCType == SCTCP)|| (IPCType == SCXNS)) && (HostName == NULL)) {
            printf("Please enter Host address \n");
	        pstatus = -1L;
        }
    }

	return(pstatus);
}

/************************************************************************/
VOID Usage(char * PrgName)
{

	fprintf(stderr, "Usage: %s  [/c: ] [/x: ] \n", PrgName);
	fprintf(stderr, "       Opt     Default        Defines\n");
	fprintf(stderr, "       ===     =======        =======\n");
	fprintf(stderr, "       /c:       1            Number of clients\n");
	fprintf(stderr, "       /x:       Nmp          Xport(IPC)type\n");
	fprintf(stderr, "       	    	             Nmp/NetB/SockTCP/\n");
	fprintf(stderr, "       	    	             SockXNS/UDP/IPX/DGNetB\n");
	fprintf(stderr, "       /p:       m            Nmp : Pip Type m/s\n");
	fprintf(stderr, "       /l:       0            NetB: lana count\n");
	fprintf(stderr, "       /b:       0            NetB: lana base\n");
	fprintf(stderr, "       /h:       NULL         Server Name/Host IP addr.\n");
}
/************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rawio\ioclnt.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ioclnt.c

Abstract:

    I/O completion port perf 

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/3/1996    Improved version of win32 sdk sockets sample.

--*/

#include "ioperf.h"
#include <tchar.h>

enum PROTOCOL {
    TCP = 0,
    SPX,
    NMPIPE,
    UDP
    } Protocol = TCP;

CHAR *ProtocolNames[] = { "TCP/IP", "SPX", "Named Pipes", "UDP/IP" };

typedef long STATUS;

BOOL fUseTransact = 0;

const char *USAGE = "-n <threads> -t <protocol> -s <server addr> -n <options>\n"
                    "\t-n - Each threads acts as an additional client\n"
                    "\t-t - tcp, spx, nmpipe (protseqs ok)\n"
                    "\t-s - protocol specific address\n"
                    "\t-n - Options:\n"
                    "\t     (named pipes) 0 - use writes/reads only\n"
                    "\t     (named pipes) 1 - use transactions for write-read\n"
                    "\tDefault: 1 thread, named pipes, transactions, loopback\n"
                    ;

DWORD
WINAPI
NmWorker (
    PVOID ignored
)
{
    HANDLE hserver;
    DWORD startTime;
    DWORD endTime;
    DWORD totalTime;
    DWORD ReceiveBufferSize;
    DWORD SendBufferSize;
    MESSAGE Message;
    PMESSAGE pMessage;
    PMESSAGE pMessage2;
    INT err;
    DWORD i;
    BOOL b;
    DWORD nbytes, bytes_read;
    DWORD RequestSize;
    DWORD ReplySize;
    DWORD CompletedCalls;

    // Connect to the server

    TCHAR buffer[256];
    i = 0;
    while(buffer[i] = NetworkAddr[i])
        i++;
    _tcscat(buffer, NM_CLIENT_PORT);

    hserver = CreateFile(buffer,
                         GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                         0,
                         OPEN_ALWAYS,
                         (FILE_FLAG_OVERLAPPED, 0), // **********
                         0);

    if (hserver == INVALID_HANDLE_VALUE)
        {
        ApiError("CreateFile", GetLastError());
        }

    i = PIPE_READMODE_MESSAGE | PIPE_WAIT;
    b = SetNamedPipeHandleState(hserver,
                                &i,
                                0,
                                0);
    if (!b)
        {
        ApiError("SetNamedPipeHandleState", GetLastError());
        }

    // Prompt server for first test case
    Message.MessageType = CONNECT;
    b = WriteFile(hserver, (PVOID) &Message, sizeof (Message), &i, 0);

    if (!b || i != sizeof(Message))
        {
        ApiError("WriteFile", GetLastError());
        }

    // Wait for test case setup message
    
    b = ReadFile(hserver, &Message, sizeof(MESSAGE), &nbytes, 0);
 
    if (!b || nbytes != sizeof(MESSAGE))
        {
        ApiError("ReadFile", GetLastError());
        }
 
    if (Message.MessageType != SETUP)
        {
        printf("Expected message %08x, got %08x\n", SETUP, Message.MessageType);
        ApiError("Test sync", GetLastError());
        }
 
    RequestSize = Message.u.Setup.RequestSize;
    ReplySize = Message.u.Setup.ReplySize;
 
    // Allocate messages
    pMessage = Allocate(max(RequestSize, ReplySize));
    pMessage2 = Allocate(max(RequestSize, ReplySize));

    CompletedCalls = 0;

    startTime = GetTickCount ();
    do
        {
        DWORD bytes_written = 0;
        DWORD bytes_read;

        pMessage->MessageType = DATA_RQ;
        pMessage->u.Data.TotalSize = RequestSize;

        #define MAX_NM_BUF ((64*1024) - 1)

        while (RequestSize - bytes_written >= MAX_NM_BUF)
            {
            b = WriteFile(hserver, (PBYTE)pMessage + bytes_written, MAX_NM_BUF, &nbytes, 0);
            dbgprintf("WriteFile: %d %d (of %d)\n", b, nbytes, MAX_NM_BUF);
            if (!b || nbytes != MAX_NM_BUF)
                {
                ApiError("WriteFile", GetLastError());
                }
            bytes_written += MAX_NM_BUF;
            } // write >64k loop

        if (fUseTransact)
            {
            // write left over data and wait for reply
            b = TransactNamedPipe(hserver,
                                  pMessage,
                                  RequestSize - bytes_written,
                                  pMessage2,
                                  ((ReplySize >= MAX_NM_BUF) ? (MAX_NM_BUF) - 1: ReplySize),
                                  &nbytes,
                                  0);
            bytes_read = nbytes;
            //dbgprintf("Transact: %d %d written, %d read\n", b, RequestSize - bytes_written, nbytes);
            
            if (!b && GetLastError() != ERROR_MORE_DATA && GetLastError() != ERROR_PIPE_BUSY)
                {
                ApiError("TransctNamedPipe", GetLastError());
                }
            }
        else
            {
            // read/write only case, write left over data
            if (bytes_written != RequestSize)
                {
                b = WriteFile(hserver, pMessage, RequestSize - bytes_written, &nbytes, 0);
                dbgprintf("WriteFile: %d %d (of %d)\n", b, nbytes, RequestSize - bytes_written);
                if (!b)
                    {
                    ApiError("WriteFile", GetLastError());
                    }
                }
    
            bytes_read = 0;
            }

        while(bytes_read < ReplySize)
            {
            if (bytes_read > sizeof(MESSAGE))
                {
                if (   (   pMessage2->MessageType != DATA_RP
                        && pMessage2->MessageType != FINISH )
                    || pMessage2->u.Data.TotalSize != ReplySize )
                    {
                    printf("Got message %08x and size %d\n"
                           "Expected message %08x and size %d\n",
                           pMessage2->MessageType,
                           pMessage2->u.Data.TotalSize,
                           DATA_RP, ReplySize);
                    ApiError("test sync", 0);
                    }
                }

            b = ReadFile(hserver,
                         (PBYTE)pMessage2 + bytes_read,
                         ReplySize - bytes_read, &nbytes, 0);

            bytes_read += nbytes;

            dbgprintf("ReadFile: %d %d (of %d)\n", b, bytes_read, ReplySize);

            if (!b || nbytes == 0)
                {
                ApiError("ReadFile", GetLastError());
                }

            // Make sure we're doing ok.
            if (bytes_read > sizeof(MESSAGE))
                {
                }
            } // read loop

       CompletedCalls++;

       }
    while (pMessage2->MessageType != FINISH);
             
    endTime = GetTickCount ();
    totalTime = endTime - startTime;

    // Print results
    printf("Completed %d transactions in %d ms\n"
           "Sent %d bytes and received %d bytes\n"
           "%d T/S or %3d.%03d ms/T\n\n",
           CompletedCalls,
           totalTime,
           CompletedCalls * RequestSize,
           CompletedCalls * ReplySize,
           (CompletedCalls * 1000) / totalTime,
           totalTime / CompletedCalls,
           ((totalTime % CompletedCalls) * 1000) / CompletedCalls
           );
       
    Sleep(2000);

    // Close connection to remote host
    b = CloseHandle(hserver);
    if (!b)
        {
        ApiError("CloseHandle", GetLastError());
        }

    return(0);
}

DWORD
WINAPI
Worker (
    PVOID ignored
)
{
   HANDLE hserver;
   DWORD startTime;
   DWORD endTime;
   DWORD totalTime;
   DWORD ReceiveBufferSize;
   DWORD SendBufferSize;
   MESSAGE Message;
   PMESSAGE pMessage;
   DWORD iterations;
   INT err;
   DWORD i;
   DWORD bytesReceived;
   DWORD RequestSize;
   DWORD ReplySize;
   DWORD CompletedCalls;

   // TCP stuff
   SOCKET s;
   IN_ADDR TcpAddr;
   SOCKADDR_IN ServerAddrTcp;

   // SPX stuff

   if (Protocol == TCP)
       {
       //
       // Default to the loopback address for the Benchmark
       //
       TcpAddr.s_addr = htonl (INADDR_LOOPBACK);

       if (NetworkAddr != 0)
           {
           TcpAddr.s_addr = inet_addr(NetworkAddr);
           if (TcpAddr.s_addr == -1)
               {
               UNALIGNED struct hostent *phostent = gethostbyname(NetworkAddr);
               if (phostent == 0)
                   {
                   ApiError("Unable to resolve server address", GetLastError());
                   }
               CopyMemory(&TcpAddr, phostent->h_addr, phostent->h_length);
               }
           }

       // Open a socket using the Internet Address family and TCP

       s = socket(AF_INET, SOCK_STREAM, 0);
       if (s == INVALID_SOCKET)
           {
           ApiError("socket", GetLastError());
           }

       // Connect to the server
       ZeroMemory (&ServerAddrTcp, sizeof (ServerAddrTcp));

       ServerAddrTcp.sin_family = AF_INET;
       ServerAddrTcp.sin_port = htons (TCP_PORT);
       ServerAddrTcp.sin_addr = TcpAddr;

       err = connect (s, (PSOCKADDR) & ServerAddrTcp, sizeof (ServerAddrTcp));
       if (err == SOCKET_ERROR)
           {
           ApiError("connect", GetLastError());
           }
       }
   else
       {
       ApiError("non-TCP not implemented yet", 0);
       }

#if 0
   //
   // Set the receive buffer size...
   //
   err = setsockopt (s, SOL_SOCKET, SO_RCVBUF, (char *) &ReceiveBufferSize, sizeof (ReceiveBufferSize));
   if (err == SOCKET_ERROR)
       {
       printf ("DoEcho: setsockopt( SO_RCVBUF ) failed: %ld\n", GetLastError ());
       closesocket (s);
       return;
       }

   //
   // ...and the send buffer size for our new socket
   //
   err = setsockopt (s, SOL_SOCKET, SO_SNDBUF, (char *) &SendBufferSize, sizeof (SendBufferSize));
   if (err == SOCKET_ERROR)
       {
       printf ("DoEcho: setsockopt( SO_SNDBUF ) failed: %ld\n", GetLastError ());
       closesocket (s);
       return;
       }
#endif

   // Prompt server for first test case
   Message.MessageType = CONNECT;
   send(s, (CHAR *) &Message, sizeof (Message), 0);

   bytesReceived = 0;
   do
       {
       // Will block here until all clients are ready for the test
       err = recv(s, (PUCHAR)&Message, sizeof(MESSAGE), 0);
       if (err == SOCKET_ERROR)
           {
           ApiError("recv", GetLastError());
           }
       bytesReceived += err;
       }
   while (bytesReceived < sizeof(MESSAGE));

   if (Message.MessageType != SETUP)
       {
       printf("Expected message %08x, got %08x\n", SETUP, Message.MessageType);
       ApiError("Test sync", GetLastError());
       }

   RequestSize = Message.u.Setup.RequestSize;
   ReplySize = Message.u.Setup.ReplySize;

   // Allocate message
   pMessage = Allocate(max(RequestSize, ReplySize));

   CompletedCalls = 0;

   startTime = GetTickCount();
   do
       {
       pMessage->MessageType = DATA_RQ;
       pMessage->u.Data.TotalSize = RequestSize;

       // Send request

       err = send(s, (PCHAR)pMessage, RequestSize, 0);
       if ((DWORD)err != RequestSize)
           {
           ApiError("send", GetLastError());
           }

       // Read as much as the remote host should send

       bytesReceived = 0;
       do
           {
           err = recv (s,
                       ((PUCHAR)pMessage)+bytesReceived,
                       ReplySize-bytesReceived,
                       0
                       );

           if (err == SOCKET_ERROR)
               {
               ApiError("recv", GetLastError());
               }

           // FIX: Handle zero byte read as close
           bytesReceived += err;

           // Make sure we're doing ok.
           if (bytesReceived >= sizeof(MESSAGE))
               {
               if (   (   pMessage->MessageType != DATA_RP
                       && pMessage->MessageType != FINISH)
                   || pMessage->u.Data.TotalSize != ReplySize )
                   {
                   printf("Got message %08x and size %d\n"
                          "Expected message %08x and size %d\n",
                          pMessage->MessageType,
                          pMessage->u.Data.TotalSize,
                          DATA_RP, ReplySize);
                   ApiError("test sync", 0);
                   }
               }
           if (bytesReceived < ReplySize)
               {
               dbgprintf("Partial recv of %d (of %d)\n",
               bytesReceived, ReplySize);
               }
           }
       while (bytesReceived < (INT) ReplySize);

       CompletedCalls++;

       }
   while(pMessage->MessageType != FINISH);
        
   endTime = GetTickCount ();
   totalTime = endTime - startTime;

   // Print results
   printf("Completed %d transactions in %d ms\n"
          "Sent %d bytes and received %d bytes\n"
          "%d T/S or %3d.%03d ms/T\n\n",
          CompletedCalls,
          totalTime,
          CompletedCalls * RequestSize,
          CompletedCalls * ReplySize,
          (CompletedCalls * 1000) / totalTime,
          totalTime / CompletedCalls,
          ((totalTime % CompletedCalls) * 1000) / CompletedCalls
          );

   Sleep(2000);

   // Close connection to remote host
   err = closesocket (s);
   if (err == SOCKET_ERROR)
       {
       ApiError("closesocket", GetLastError());
       }

   return(0);
}

DWORD
WINAPI
UdpWorker(
    PVOID ignored
)
{
   HANDLE hserver;
   DWORD startTime;
   DWORD endTime;
   DWORD totalTime;
   DWORD ReceiveBufferSize;
   DWORD SendBufferSize;
   MESSAGE Message;
   PMESSAGE pMessage;
   DWORD iterations;
   INT err;
   DWORD i;
   DWORD Timeout;
   SOCKET s;
   IN_ADDR IpAddr;
   SOCKADDR_IN ServerAddr;
   SOCKADDR *pAddr = (PSOCKADDR)&ServerAddr;
   DWORD len = sizeof(SOCKADDR_IN);
   DWORD bytesReceived;
   DWORD RequestSize;
   DWORD ReplySize;
   DWORD CompletedCalls;
   //
   // Default to the loopback address for the Benchmark
   //
   IpAddr.s_addr = htonl (INADDR_LOOPBACK);

   if (NetworkAddr != 0)
       {
       IpAddr.s_addr = inet_addr(NetworkAddr);
       if (IpAddr.s_addr == -1)
           {
           UNALIGNED struct hostent *phostent = gethostbyname(NetworkAddr);
           if (phostent == 0)
               {
               ApiError("Unable to resolve server address", GetLastError());
               }
           CopyMemory(&IpAddr, phostent->h_addr, phostent->h_length);
           }
       }

   s = WSASocketW(AF_INET, SOCK_DGRAM, IPPROTO_UDP, 0, 0, 0);
   if (s == INVALID_SOCKET)
       {
       ApiError("socket", GetLastError());
       }

   ZeroMemory (&ServerAddr, sizeof (ServerAddr));

   ServerAddr.sin_family = AF_INET;
   ServerAddr.sin_port = htons(TCP_PORT);
   ServerAddr.sin_addr = IpAddr;

#if 0
   // Connect to the server

   err = connect (s, (PSOCKADDR) &ServerAddr, sizeof (ServerAddr));
   if (err == SOCKET_ERROR)
       {
       ApiError("connect", GetLastError());
       }
#endif

   // Prompt server for first test case
   Message.MessageType = CONNECT;

   Timeout = 1000;
   err = setsockopt(s,
                    SOL_SOCKET,
                    SO_RCVTIMEO,
                    (char *) &Timeout,
                    sizeof(Timeout)
                    );
   if (err)
       {
       ApiError("setsockopt", GetLastError());
       }

   do
       {
       err = sendto(s, (CHAR *) &Message, sizeof (Message), 0, pAddr, len);
       if (err != sizeof(Message))
           {
           ApiError("sendto", GetLastError());
           }

       err = recvfrom(s, (PUCHAR)&Message, sizeof(MESSAGE), 0, pAddr, &len);
       if (err == sizeof(MESSAGE))
           {
           break;
           }

       if (GetLastError() == WSAETIMEDOUT)
           {
           printf("Request time out..\n");
           }
       }
   while (GetLastError() == WSAETIMEDOUT);


   if (err != sizeof(MESSAGE))
       {
       ApiError("recv", GetLastError());
       }

   pMessage = 0;

   Timeout = 1000;
   err = setsockopt(s,
                    SOL_SOCKET,
                    SO_RCVTIMEO,
                    (char *) &Timeout,
                    sizeof(Timeout)
                    );

   if (err)
       {
       ApiError("setsockopt", GetLastError());
       }


   if (Message.MessageType != SETUP)
       {
       printf("Expected message %08x, got %08x\n", SETUP, Message.MessageType);
       ApiError("Test sync", GetLastError());
       }

   RequestSize = Message.u.Setup.RequestSize;
   ReplySize = Message.u.Setup.ReplySize;

   // Allocate message
   pMessage = Allocate(max(RequestSize, ReplySize));

   CompletedCalls = 0;
   startTime = GetTickCount ();
   do
       {
       pMessage->MessageType = DATA_RQ;
       pMessage->u.Data.TotalSize = RequestSize;

       // Send request

       do
           {
           err = sendto(s, (CHAR *) pMessage, RequestSize, 0, pAddr, len);
           if ((DWORD)err != RequestSize)
               {
               ApiError("sendto", GetLastError());
               }
        
           err = recvfrom(s, (PUCHAR)pMessage, ReplySize, 0, pAddr, &len);
           if ((DWORD)err == ReplySize)
               {
               break;
               }

           if (GetLastError() == WSAETIMEDOUT)
               {
               printf("Request time out..\n");
               }
           }
       while (GetLastError() == WSAETIMEDOUT);

       if ((DWORD)err != ReplySize)
           {
           ApiError("recv", GetLastError());
           }

       // Make sure we're doing ok.
       if (   (   pMessage->MessageType != DATA_RP
               && pMessage->MessageType != FINISH)
           || pMessage->u.Data.TotalSize != ReplySize )
           {
           printf("Got message %08x and size %d\n"
                  "Expected message %08x and size %d\n",
                  pMessage->MessageType,
                  pMessage->u.Data.TotalSize,
                  DATA_RP, ReplySize);
           ApiError("test sync", 0);
           }

       CompletedCalls++;
       }
   while(pMessage->MessageType != FINISH);
        
   endTime = GetTickCount ();
   totalTime = endTime - startTime;

   printf("Completed %d transactions in %d ms\n"
          "Sent %d bytes and received %d bytes\n"
          "%d T/S or %3d.%03d ms/T\n\n",
          CompletedCalls,
          totalTime,
          CompletedCalls * RequestSize,
          CompletedCalls * ReplySize,
          (CompletedCalls * 1000) / totalTime,
          totalTime / CompletedCalls,
          ((totalTime % CompletedCalls) * 1000) / CompletedCalls
          );

   Sleep(2000);
       
    // Close socket
    err = closesocket (s);
    if (err == SOCKET_ERROR)
        {
        ApiError("closesocket", GetLastError());
        }

    return(0);
}

typedef DWORD (*WORKER_FN) (LPVOID);

int __cdecl
main (
        int argc,
        char *argv[],
        char *envp[]
)
{
   WSADATA WsaData;
   STATUS status;
   DWORD threads;
   HANDLE *aClientThreads;
   int i;
   WORKER_FN pWorker;

   ParseArgv(argc, argv);

   if (_stricmp(Protseq, "tcp") == 0 || _stricmp(Protseq, "ncacn_ip_tcp") == 0 )
       {
       pWorker = Worker;
       Protocol = TCP;
       }
   else if ( _stricmp(Protseq, "spx") == 0 || _stricmp(Protseq, "ncacn_spx") == 0 )
       {
       pWorker = Worker;
       Protocol = SPX;
       }
   else if ( _stricmp(Protseq, "nmpipe") == 0 || _stricmp(Protseq, "ncacn_np") == 0 )
       {
       pWorker = NmWorker;
       Protocol = NMPIPE;
       }
   else if ( _stricmp(Protseq, "udp") == 0 || _stricmp(Protseq, "ncadg_ip_udp") == 0 )
       {
       pWorker = UdpWorker;
       Protocol = UDP;
       }

   if (Options[0] > 0)
       threads = Options[0];
   else
       threads = 1;

   if (Options[1] > 0)
       {
       if (Protocol == NMPIPE)
           {
           fUseTransact = Options[1];
           }
       }

   printf("%d client threads starting on %s\n", threads, ProtocolNames[Protocol]);

   if (Protocol != NMPIPE)
       {
       status = WSAStartup (0x2, &WsaData);
       CHECK_STATUS(status, "WSAStartup");
       }


   if (threads > 1)
       {
       DWORD i;

       aClientThreads = (HANDLE *)Allocate(sizeof(HANDLE) * threads);

       for (i = 0 ; i < threads; i++)
           {
           aClientThreads[i] = CreateThread(NULL,
                                            0,
                                            pWorker,
                                            0,
                                            0,
                                            &status
                                            );
           if (aClientThreads[i] == 0)
               {
               ApiError("CreateThread", GetLastError());
               }
           }

       status = WaitForMultipleObjects(threads,
                                       aClientThreads,
                                       TRUE,
                                       INFINITE
                                       );

       if (status == WAIT_FAILED)
           {
           ApiError("WaitForMultipleObjects", GetLastError());
           }
       }
   else
       (pWorker)(0);

   printf("TEST DONE\n");
   return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rawio\iosvr.c ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    iosvr.c

Abstract:

    I/O completion port perf test.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     3/3/1996    Based on win32 sdk winnt\sockets sample.

--*/

#include "ioperf.h"

// PERF CHECK: Must be less for 4K for optimum perf on small tests ??

enum PROTOCOL {
    TCP = 0,
    SPX,
    NMPIPE,
    UDP
    } Protocol = TCP;

CHAR *ProtocolNames[] = { "TCP/IP", "SPX", "Named Pipes", "UDP/IP" };

DWORD ProtocolFrameSize[] = { 1460, 1400 /* ? */, ((64 * 1024) - 1)/4, 1472 };

DWORD MaxWriteSize;

BOOL  fUseSend = FALSE;

const char *USAGE = "-n <# clients> -n <request size> -n <reply size> -n <test case> -n <# threads> -n <concurrency factor> -t <protocol>\n"
                    "\t-n <# clients> - for connection protocols.  On datagram this\n"
                    "\t                 controls the number of outstanding recv's\n"
                    "\t-n <request size> - bytes, default 24\n"
                    "\t-n <reply size> - bytes, default 24\n"
                    "\t-n <test case>\n"
                    "\t        1 - Uses async writes (64*frame size)\n"
                    "\t        2 - Uses async writes (4096) - default \n"
                    "\t        3 - (winsock only) Uses send() for reply\n"
                    "\t-n <# threads> - worker threads, default # of processors * 2\n"
                    "\t-n <concurrency factor> - default # of processors\n"
                    "\t-t - tcp, spx, nmpipe (protseqs ok)\n"
                    ;

typedef long STATUS;

typedef struct _PER_CLIENT_DATA {
    HANDLE hClient;
    struct _PER_CLIENT_DATA *pMe;
    OVERLAPPED OverlappedRead;
    struct _PER_CLIENT_DATA *pMe2;
    OVERLAPPED OverlappedWrite;
    PMESSAGE pRequest;
    PMESSAGE pReply;
    DWORD dwPreviousRead;
    DWORD dwPreviousWrite;
    DWORD dwTotalToWrite;
    DWORD dwRequestsProcessed;
    SOCKADDR_IN DgSendAddr;
    SOCKADDR_IN DgRecvAddr;
    DWORD dwRecvAddrSize;
    } PER_CLIENT_DATA, *PPER_CLIENT_DATA;

PPER_CLIENT_DATA *ClientData;

typedef struct _PER_THREAD_DATA {
    DWORD TotalTransactions;
    DWORD TotalRequestBytes;
    DWORD TotalReplyBytes;
    } PER_THREAD_DATA, *PPER_THREAD_DATA;

PPER_THREAD_DATA *ThreadData;

DWORD dwNumberOfClients;
DWORD dwNumberOfWorkers;
DWORD dwConcurrency;
DWORD dwWorkIndex;
DWORD dwRequestSize;
DWORD dwReplySize;
SYSTEM_INFO SystemInfo;
HANDLE CompletionPort;
DWORD dwActiveClientCount;
HANDLE hBenchmarkStart;
BOOL fClientsGoHome = FALSE;

BOOL
WINAPI
CreateNetConnections(
    VOID
    );

BOOL
WINAPI
CreateWorkers(
    VOID
    );

DWORD
WINAPI
WorkerThread(
    LPVOID WorkContext
    );

VOID
WINAPI
CompleteBenchmark(
    VOID
    );

int __cdecl
main (
        int argc,
        char *argv[],
        char *envp[]
)
{
    ParseArgv(argc, argv);

    //
    // try to get timing more accurate... Avoid context
    // switch that could occur when threads are released
    //

    SetThreadPriority (GetCurrentThread (), THREAD_PRIORITY_TIME_CRITICAL);
    
    //
    // Figure out how many processors we have to size the minimum
    // number of worker threads and concurrency
    //

    GetSystemInfo (&SystemInfo);

    dwNumberOfClients = 1;
    dwNumberOfWorkers = 2 * SystemInfo.dwNumberOfProcessors;
    dwConcurrency = SystemInfo.dwNumberOfProcessors;
    dwRequestSize = 24;
    dwReplySize = 24;

    if (Iterations == 1000)
        {
        Dump("Assuming 4 iterations for scalability test\n");
        Iterations = 4;
        }

    if (sizeof(MESSAGE) > 24)
        {
        ApiError("Configuration problem, message size > 24", 0);
        }

    if (_stricmp(Protseq, "tcp") == 0 || _stricmp(Protseq, "ncacn_ip_tcp") == 0 )
        {
        Protocol = TCP;
        }
    else if ( _stricmp(Protseq, "spx") == 0 || _stricmp(Protseq, "ncacn_spx") == 0 )
        {
        Protocol = SPX;
        }
    else if ( _stricmp(Protseq, "nmpipe") == 0 || _stricmp(Protseq, "ncacn_np") == 0 )
        {
        Protocol = NMPIPE;
        }
    else if ( _stricmp(Protseq, "udp") == 0 || _stricmp(Protseq, "ncadg_ip_udp") == 0 )
        {
        Protocol = UDP;
        }
    
    if (Options[0] > 0)
        dwNumberOfClients = Options[0];

    if (Options[1] > 0)
        {
        dwRequestSize = Options[1];
        }

    if (Options[2] > 0)
        {
        dwReplySize = Options[2];
        }

    if (Options[3] > 0)
        {
        switch(Options[3])
            {
            case 1:
                MaxWriteSize = 4 * ProtocolFrameSize[Protocol];
                break;
            case 2:
                MaxWriteSize = 4096;
                break;
            case 3:
                fUseSend = TRUE;
                break;
            default:
                printf("Invalid test case: %d\n", Options[3]);
                return(0);
                break;
            }
        }
    else
        {
        MaxWriteSize = 4096;
        }

    if (Options[4] > 0)
        {
        dwNumberOfWorkers = Options[4];
        }

    if (Options[5] > 0)
        {
        dwConcurrency = Options[5];
        }

    printf("%2d Clients %2d Workers Concurrency %d, listening on %s\n",
            dwNumberOfClients,
            dwNumberOfWorkers,
            dwConcurrency,
            ProtocolNames[Protocol]
          );

    ClientData = (PPER_CLIENT_DATA *)Allocate(sizeof(PPER_CLIENT_DATA) * dwNumberOfClients);
    ThreadData = (PPER_THREAD_DATA *)Allocate(sizeof(PPER_THREAD_DATA) * dwNumberOfWorkers);

    if (!ThreadData || !ClientData)
        {
        ApiError("malloc", GetLastError());
        }

    if (!CreateNetConnections())
        {
        return 1;
        }

    if (!CreateWorkers())
        {
        return 1;
        }

    CompleteBenchmark();

    return 0;
}

VOID
SubmitWrite(PER_CLIENT_DATA *pClient, DWORD size)
{
    DWORD t1, t2;
    INT write_type = Protocol;
    BOOL b;
    INT err;
    DWORD status;
    WSABUF buf;

    pClient->dwTotalToWrite = size;
    pClient->dwPreviousWrite = size;

    if ( (    write_type == TCP
           || write_type == SPX )
        && !fUseSend )
        {
        // We want to use WriteFile for TCP & SPX if not using send.
        write_type = NMPIPE;
        }

    switch(write_type)
        {
        case NMPIPE:

            if (size > MaxWriteSize)
                {
                size = MaxWriteSize;
                }

            pClient->dwPreviousWrite = size;

            b = WriteFile(pClient->hClient,
                          pClient->pReply,
                          size,
                          &t1,
                          &pClient->OverlappedWrite);

            if (!b && GetLastError() != ERROR_IO_PENDING)
                {
                ApiError("WriteFile", GetLastError());
                }
            break;

        case UDP:

            memcpy(&pClient->DgSendAddr, &pClient->DgRecvAddr, sizeof(SOCKADDR_IN));
            buf.buf = (PCHAR) pClient->pReply;
            buf.len = size;
            t1 = 0;
            err = WSASendTo((SOCKET)pClient->hClient,
                            &buf,
                            1,
                            &t1,
                            0,
                            (PSOCKADDR)&pClient->DgSendAddr,
                            sizeof(SOCKADDR_IN),
                            &pClient->OverlappedWrite,
                            0);

            if (err != 0 && GetLastError() != ERROR_IO_PENDING)
                {
                ApiError("WSASendTo", GetLastError());
                }
            break;

        case TCP:
        case SPX:
            err = send((SOCKET)pClient->hClient,
                   (PCHAR)pClient->pReply,
                   sizeof(MESSAGE),
                   0);

            if (err == SOCKET_ERROR)
                {
                ApiError("send", GetLastError());
                }

            break;
        default:
            ApiError("Bad protocol", 0);
        }

    return;
}

VOID
SubmitRead(PER_CLIENT_DATA *pClient)
{
    DWORD t1, t2, t3;
    BOOL b;
    DWORD status;
    INT err;

    if (Protocol == UDP)
        {
        WSABUF buf;
        t1 = t2 = 0;
        pClient->dwRecvAddrSize = sizeof(pClient->DgRecvAddr);
        buf.buf = (PCHAR)pClient->pRequest;
        buf.len = dwRequestSize;
        status = WSARecvFrom((SOCKET)pClient->hClient,
                             &buf,
                             1,
                             &t1,
                             &t2,
                             (PSOCKADDR)&pClient->DgRecvAddr,
                             &pClient->dwRecvAddrSize,
                             &pClient->OverlappedRead,
                             0);
        if (status != NO_ERROR && GetLastError() != ERROR_IO_PENDING)
            {
            ApiError("WSARecvFrom", GetLastError());
            }
        }
    else
        {
        b = ReadFile(pClient->hClient,
                     pClient->pRequest,
                     dwRequestSize,
                     &t1,
                     &pClient->OverlappedRead
                     );
        if (!b && GetLastError () != ERROR_IO_PENDING)
            {
            ApiError("ReadFile", GetLastError());
            }
        }
    return;
}

VOID
WINAPI
CompleteBenchmark (
                  VOID
)
{
    DWORD StartCalls;
    DWORD TotalTicks, FinalCalls, MaxCalls, MinCalls, TotalCalls;
    DWORD i, j;

    PPER_CLIENT_DATA pClient;

    SetEvent(hBenchmarkStart);
    Sleep(1000);

    for (i = 0; i < Iterations; i++)
        {

        StartTime();

        StartCalls = 0;

        for (j = 0; j < dwNumberOfClients; j++ )
            {
            pClient = ClientData[j];
            StartCalls += pClient->dwRequestsProcessed;
            }

        Sleep(Interval * 1000);


        FinalCalls = MaxCalls = 0;
        MinCalls = ~0;
        for (j = 0; j < dwNumberOfClients; j++)
            {
            pClient = ClientData[j];
            FinalCalls += pClient->dwRequestsProcessed;
            if (pClient->dwRequestsProcessed < MinCalls )
                {
                MinCalls = pClient->dwRequestsProcessed;
                }
            if (pClient->dwRequestsProcessed > MaxCalls)
                {
                MaxCalls = pClient->dwRequestsProcessed;
                }
            }

        TotalCalls = FinalCalls - StartCalls;

        TotalTicks = FinishTiming();

        Dump("Ticks: %4d, Total: %4d, Average %4d, TPS %3d\n",
             TotalTicks,
             TotalCalls,
             TotalCalls / dwNumberOfClients,
             TotalCalls * 1000 / TotalTicks
             );

        Verbose("Max: %d, Min: %d\n", MaxCalls, MinCalls);
        }

    // Clients will be shutdown on next call...
    fClientsGoHome = TRUE;

    Sleep(5000);
   
    printf("Test Complete\n");

    for (i = 0; i < dwNumberOfWorkers; i++)
        {
        printf("\tThread[%2d] %d request and %d reply bytes in %d IOs\n",
               i,
               ThreadData[i]->TotalRequestBytes,
               ThreadData[i]->TotalReplyBytes,
               ThreadData[i]->TotalTransactions
               );
        }
}

BOOL
WINAPI
CreateNetConnections(
                    void
)
{
    STATUS status;
    DWORD i;
    SOCKET listener;
    INT err;
    WSADATA WsaData;
    DWORD nbytes;
    BOOL b;
    PPER_CLIENT_DATA pClient;

    if (Protocol == TCP || Protocol == SPX)
        {
        status = WSAStartup (0x2, &WsaData);
        CHECK_STATUS(status, "WSAStartup");

        //
        // Open a socket to listen for incoming connections.
        //

        if (Protocol == TCP)
            {
            SOCKADDR_IN localAddr;

            listener = WSASocketW(AF_INET, SOCK_STREAM, 0, 0, 0, WSA_FLAG_OVERLAPPED);
            if (listener == INVALID_SOCKET)
                {
                ApiError("socket", GetLastError());
                }
    
            //
            // Bind our server to the agreed upon port number.
            //
            ZeroMemory (&localAddr, sizeof (localAddr));
            localAddr.sin_port = htons (TCP_PORT);
            localAddr.sin_family = AF_INET;
    
            err = bind (listener, (PSOCKADDR) & localAddr, sizeof (localAddr));
            if (err == SOCKET_ERROR)
                {
                ApiError("bind", GetLastError());
                }
            }
        else if (Protocol == SPX)
            {
            SOCKADDR_IPX localAddr;
    
            listener = socket (AF_IPX, SOCK_STREAM, NSPROTO_SPX);
            if (listener == INVALID_SOCKET)
                {
                ApiError("socket", GetLastError());
                }
    
            ZeroMemory (&localAddr, sizeof (localAddr));
            localAddr.sa_socket = htons (SPX_PORT);
            localAddr.sa_family = AF_IPX;
    
            err = bind (listener, (PSOCKADDR) & localAddr, sizeof (localAddr));
            if (err == SOCKET_ERROR)
                {
                ApiError("bind", GetLastError());
                }
            }
        else if (Protocol == SPX)
            {
            ApiError("Case not implemented", 0);
            }

        // Prepare to accept client connections.  Allow up to 5 pending
        // connections.
    
        err = listen (listener, 5);
        if (err == SOCKET_ERROR)
            {
            ApiError("listen", GetLastError());
            }
    
        //
        // Only Handle a single Queue
        //
    
        for (i = 0; i < dwNumberOfClients; i++)
            {
            SOCKET s;

            pClient = Allocate(sizeof(PER_CLIENT_DATA));
            if (!pClient)
                {
                ApiError("Allocate", GetLastError());
                }
    
            pClient->pRequest = Allocate(dwRequestSize);
            pClient->pReply = Allocate(dwReplySize);
    
            if (   !pClient->pRequest
                || !pClient->pReply)
                {
                ApiError("Allocate", GetLastError());
                }
    
            // Accept incoming connect requests
    
            s = accept (listener, NULL, NULL);
            if (s == INVALID_SOCKET)
                {
                // exiting anyway, no need to cleanup.
                ApiError("accept", GetLastError());
                }
    
            dbgprintf("Accepted client %d\n", i);
    
            // Note that dwConcurrency says how many concurrent cpu bound threads to
            // allow thru this should be tunable based on the requests. CPU bound requests
            // will really really honor this.

            pClient->hClient = (HANDLE)s;

            CompletionPort = CreateIoCompletionPort(pClient->hClient,
                                                    CompletionPort,
                                                    (ULONG_PTR)pClient,
                                                    dwConcurrency);
            if (!CompletionPort)
                {
                ApiError("CreateIoCompletionPort", GetLastError());
                }
    
            //
            // Start off an asynchronous read on the socket.
            //
    
            pClient->dwPreviousRead = 0;
            pClient->dwRequestsProcessed = 0;
            ZeroMemory(&pClient->OverlappedRead, sizeof(OVERLAPPED));
            ZeroMemory(&pClient->OverlappedWrite, sizeof(OVERLAPPED));
    
            b = ReadFile(pClient->hClient,
                         pClient->pRequest,
                         dwRequestSize,
                         &nbytes,
                         &pClient->OverlappedRead
                        );
    
            if (!b && GetLastError() != ERROR_IO_PENDING)
                {
                ApiError("ReadFile", GetLastError());
                }
    
            ClientData[i] = pClient;
            }
    
        dwActiveClientCount = dwNumberOfClients;

        }
    else if (Protocol == NMPIPE)
        {
        HANDLE h;
        OVERLAPPED *lpo;
        DWORD nbytes, index;
        BOOL b;

        for (i = 0; i < dwNumberOfClients; i++)
            {
            h = CreateNamedPipe(NM_PORT,
                                PIPE_ACCESS_DUPLEX
                                    | FILE_FLAG_OVERLAPPED,
                                PIPE_TYPE_MESSAGE
                                    | (PIPE_READMODE_MESSAGE, 0)  // ************
                                    | PIPE_WAIT,
                                PIPE_UNLIMITED_INSTANCES,
                                4096, // ***************
                                4096, // ***************
                                INFINITE,
                                0);
            if (!h)
                {
                ApiError("CreateNamedPipe", GetLastError());
                }

            //
            // Wait for clients to connect
            //


            pClient = Allocate(sizeof(PER_CLIENT_DATA));
            if (!pClient)
                {
                ApiError("Allocate", GetLastError());
                }

            ZeroMemory(pClient, sizeof(PER_CLIENT_DATA));
    
            pClient->pRequest = Allocate(dwRequestSize);
            pClient->pReply = Allocate(dwReplySize);
    
            if (   !pClient->pRequest
                || !pClient->pReply)
                {
                ApiError("Allocate", GetLastError());
                }
    
            // Accept incoming connect requests

            pClient->hClient = h;

            b = ConnectNamedPipe(pClient->hClient,
                                 &pClient->OverlappedRead);

            dbgprintf("ConnectNamedPipe: %d %d\n", b, GetLastError());

            if (b == 0)
                {
                if (GetLastError() == ERROR_IO_PENDING)
                    {
                    b = GetOverlappedResult(pClient->hClient,
                                           &pClient->OverlappedRead,
                                           &nbytes,
                                           TRUE);

                    if (b == 0)
                        {
                        ApiError("GetOverlappedResult", GetLastError());
                        }
                    dbgprintf("Client connected\n");
                    }
                else
                    {
                    ApiError("ConnectNamedPipe", GetLastError());
                    }
                }

            // Add the clients pipe instance to the completion port.

            CompletionPort = CreateIoCompletionPort(h,
                                                    CompletionPort,
                                                    (ULONG_PTR)pClient,
                                                    dwConcurrency);

            if (!CompletionPort)
                {
                ApiError("CreteIoCompletionPort", GetLastError());
                }
            //
            // Start off an asynchronous read on the socket.
            //
    
            pClient->dwPreviousRead = 0;
            pClient->dwRequestsProcessed = 0;
            ZeroMemory(&pClient->OverlappedRead, sizeof(OVERLAPPED));
            ZeroMemory(&pClient->OverlappedWrite, sizeof(OVERLAPPED));
    
            b = ReadFile(pClient->hClient,
                         pClient->pRequest,
                         dwRequestSize,
                         &nbytes,
                         &pClient->OverlappedRead
                        );
    
            if (!b && GetLastError() != ERROR_IO_PENDING)
                {
                ApiError("ReadFile", GetLastError());
                }
    
            ClientData[i] = pClient;
            }
    
        dwActiveClientCount = dwNumberOfClients;
        }
    else if (Protocol == UDP)
        {
        SOCKADDR_IN localAddr;

        status = WSAStartup (0x2, &WsaData);
        CHECK_STATUS(status, "WSAStartup");

        listener = WSASocketW(AF_INET, SOCK_DGRAM, IPPROTO_UDP, 0,
                              0, WSA_FLAG_OVERLAPPED);
        if (listener == INVALID_SOCKET)
            {
            ApiError("socket", GetLastError());
            }
    
        //
        // Bind our server to the agreed upon port number.
        //
        ZeroMemory (&localAddr, sizeof (localAddr));
        localAddr.sin_port = htons (UDP_PORT);
        localAddr.sin_family = AF_INET;
    
        err = bind (listener, (PSOCKADDR) & localAddr, sizeof (localAddr));
        if (err == SOCKET_ERROR)
            {
            ApiError("bind", GetLastError());
            }

        CompletionPort = CreateIoCompletionPort((HANDLE) listener,
                                                CompletionPort,
                                                0,
                                                dwConcurrency);
        if (!CompletionPort)
            {
            ApiError("CreateIoCompletionPort", GetLastError());
            }

        //
        // Start off asynchronous reads on the socket.
        //
        for(i = 0; i < dwNumberOfClients; i++)
            {
            pClient = Allocate(sizeof(PER_CLIENT_DATA));
            if (!pClient)
                {
                ApiError("Allocate", GetLastError());
                }
    
            pClient->pRequest = Allocate(dwRequestSize);
            pClient->pReply = Allocate(dwReplySize);
    
            if (   !pClient->pRequest
                || !pClient->pReply)
                {
                ApiError("Allocate", GetLastError());
                }
 
            ZeroMemory(&pClient->OverlappedRead, sizeof(OVERLAPPED));
            ZeroMemory(&pClient->OverlappedWrite, sizeof(OVERLAPPED));

            pClient->hClient = (HANDLE)listener;
            pClient->dwPreviousRead = 0;
            pClient->dwRequestsProcessed = 0;
            pClient->pMe = pClient;
            pClient->pMe2 = pClient;

            Trace("Created: %p %p %p\n", pClient, &pClient->OverlappedRead,
                  &pClient->OverlappedWrite);

            ClientData[i] = pClient;
            SubmitRead(pClient);
            }
    
        dwActiveClientCount = dwNumberOfClients;
        }
    else
        {
        ApiError("Invalid protocol", 0);
        }

    // Protocol independent part

    hBenchmarkStart = CreateEvent (NULL, TRUE, FALSE, NULL);

    if (!hBenchmarkStart)
        {
        ApiError("CreateEvent", GetLastError());
        }

   return TRUE;
}

BOOL
WINAPI
CreateWorkers(
             void
)
{
    DWORD ThreadId;
    HANDLE ThreadHandle;
    DWORD i;
    PPER_THREAD_DATA pThreadData;

    for (i = 0; i < dwNumberOfWorkers; i++)
        {
        pThreadData = Allocate(sizeof(PER_THREAD_DATA));

        if (!pThreadData)
            {
            ApiError("malloc", GetLastError());
            }

        ZeroMemory(pThreadData, sizeof(PER_THREAD_DATA));

        ThreadHandle = CreateThread(NULL,
                                    0,
                                    WorkerThread,
                                    (LPVOID)pThreadData,
                                    0,
                                    &ThreadId
                                    );
        if (!ThreadHandle)
            {
            ApiError("CreateThread", GetLastError());
            }

        CloseHandle(ThreadHandle);

        ThreadData[i] = pThreadData;
        }

   return TRUE;
}

DWORD
WINAPI
WorkerThread (
                LPVOID WorkContext
)
{
    PPER_THREAD_DATA Me;
    INT err;
    DWORD ResponseLength;
    BOOL b;
    LPOVERLAPPED lpo;
    DWORD nbytes;
    ULONG_PTR WorkIndex;
    PPER_CLIENT_DATA pClient;
    LONG count;

    WaitForSingleObject (hBenchmarkStart, INFINITE);

    Me = (PPER_THREAD_DATA) WorkContext;

    for (;;)
        {
        lpo = 0;

        b = GetQueuedCompletionStatus(CompletionPort,
                                      &nbytes,
                                      &WorkIndex,
                                      &lpo,
                                      INFINITE
                                      );

        // dbgprintf("GetQueuedCompletionStatus: %d %d %p\n", b, nbytes, lpo);
        
        if (WorkIndex == 0)
            {
            // Must be a datagram read or write
            WorkIndex = (ULONG_PTR)((unsigned char *)lpo - 4);
            WorkIndex = *(PDWORD)WorkIndex;
            }

        Me->TotalTransactions++;

        if (b || lpo)
            {
            if (b)
                {
                DWORD nbytes2;

                pClient = (PPER_CLIENT_DATA)WorkIndex;

                if (lpo == &pClient->OverlappedWrite)
                    {
                    dbgprintf("Write completed %d (%p)\n", nbytes, pClient);
                    Me->TotalReplyBytes += nbytes;

                    nbytes = pClient->dwTotalToWrite - pClient->dwPreviousWrite;

                    if (nbytes)
                        {
                        if (nbytes > MaxWriteSize)
                            {
                            nbytes = MaxWriteSize;
                            }

                        pClient->dwPreviousWrite += nbytes;

                        b = WriteFile(pClient->hClient,
                                      (PBYTE)pClient->pReply + pClient->dwPreviousWrite - nbytes,
                                      nbytes,
                                      &nbytes2,
                                      &pClient->OverlappedWrite);

                        dbgprintf("Write completed: %d %d (of %d) %d (of %d)\n", b, nbytes2, nbytes, pClient->dwPreviousWrite, dwReplySize);
                        
                        if (!b && GetLastError() != ERROR_IO_PENDING)
                            {
                            ApiError("WriteFile", GetLastError());
                            }
                        }
                    }
                else
                    {
                    Me->TotalRequestBytes += nbytes;

                    dbgprintf(" Read completed %d (%p)\n", nbytes, pClient);

                    if (nbytes == 0)
                        {
                        Trace("Connection closed (zero byte read)\n");
                        CloseHandle(pClient->hClient);
                        continue;
                        }

                    switch (pClient->pRequest->MessageType)
                        {
                        case CONNECT:
                        // Send test parameters back to the client
                        pClient->pReply->MessageType = SETUP;
                        pClient->pReply->u.Setup.RequestSize = dwRequestSize;
                        pClient->pReply->u.Setup.ReplySize = dwReplySize;

                        SubmitWrite(pClient, sizeof(MESSAGE));

                        pClient->dwPreviousRead = 0;

                        SubmitRead(pClient);
                        
                        break;

                        case DATA_RQ:
                        // Make sure we got all the data and no more.

                        pClient->dwRequestsProcessed++;

                        nbytes += pClient->dwPreviousRead;

                        if (nbytes > dwRequestSize)
                            {
                            ApiError("Too much data returned\n", 0);
                            }

                        if (nbytes < dwRequestSize)
                            {
                            dbgprintf("Partial receive of %d (of %d)\n", nbytes, dwRequestSize);
                            // Resubmit the IO for the rest of the request.
                            pClient->dwPreviousRead = nbytes;

                            b = ReadFile(pClient->hClient,
                                         ((PBYTE)pClient->pRequest) + nbytes,
                                         dwRequestSize - nbytes,
                                         &nbytes,
                                         &pClient->OverlappedRead);

                            if (!b && GetLastError () != ERROR_IO_PENDING)
                                {
                                ApiError("ReadFile for remainder", GetLastError());
                                }
                            // Pickup this or another IO 
                            break;
                            }

                        if (nbytes != pClient->pRequest->u.Data.TotalSize)
                            {
                            printf("Invalid request size, got %d, expected %d\n",
                                   nbytes, pClient->pRequest->u.Data.TotalSize);
                            ApiError("test sync", 0);
                            }

                        pClient->dwPreviousRead = 0;

                        // Could sleep/do work here.

                        // Send a response and post another asynchronous read on the
                        // socket.

                        if (fClientsGoHome == FALSE)
                            {
                            pClient->pReply->MessageType = DATA_RP;
                            }
                        else
                            {
                            pClient->pReply->MessageType = FINISH;
                            }

                        pClient->pReply->u.Data.TotalSize = dwReplySize;
                        SubmitWrite(pClient, dwReplySize);

                        SubmitRead(pClient);

                        break;

                        default:
                        ApiError("Invalid message type", pClient->pRequest->MessageType);
                        }
                    } // read or write
                }
            else
                {
                Trace("Client closed connection\n", GetLastError());
                }
            }
        else
            {
            ApiError("Wait failed", GetLastError());
            }
        }   // loop

    // not reached
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rawio\ioperf.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    ioperf.h

Abstract:

    Shared definitions between io perf client and server.

Author:

    Mario Goertzel [MarioGo]

Revision History:

    MarioGo     3/3/1996    Based on win32 SDK sockets sample

--*/

#include <rpcperf.h>
#include <tchar.h>
#include <winsock2.h>
#include <wsipx.h>

typedef struct
{
    DWORD Empty;
} CONNECT_MSG;

typedef struct
{
    DWORD RequestSize;
    DWORD ReplySize;
} SETUP_MSG;

typedef struct
{
   DWORD TotalTicks;
} FINISH_MSG;

typedef struct
{
    DWORD TotalSize;
    BYTE Array[];
} DATA_MSG;

//
// Message types
//
#define CONNECT 0xAAAAAAA
#define SETUP   0xBBBBBBB
#define FINISH  0xCCCCCCC
#define DATA_RQ 0xFFFFFF0
#define DATA_RP 0xFFFFFF1

typedef struct
{
   DWORD MessageType;
   union
   {
   CONNECT_MSG Connect;
   SETUP_MSG Setup;
   FINISH_MSG Finish;
   DATA_MSG Data;
   } u;
}
MESSAGE, *PMESSAGE;

//
// Choose arbitrary endpoints.  May need to be changed if
// it conflicts with an existing application.
//
#define TCP_PORT        12396
#define SPX_PORT        12396
#define UDP_PORT        12396
#define NM_PORT         TEXT("\\\\.\\pipe\\ioperf")
#define NM_CLIENT_PORT  TEXT("\\pipe\\ioperf")

//
// Memory allocates
//

#define Allocate(s) malloc(s)
#define Free(p) free(p)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\scale\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

RT_IDL = rpcrt

RT_CSTUB  = $(RT_IDL)_c.c
RT_SSTUB  = $(RT_IDL)_s.c
RT_HEADER = obj\$(RT_IDL).h

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) -error ref

#

allidl: rpcrt

#
# MIDL COMPILE
#
rpcrt: $(RT_HEADER) $(RT_CSTUB) $(RT_SSTUB)

$(RT_HEADER) $(RT_CSTUB) $(RT_SSTUB) : .\$(RT_IDL).idl
    midl  -ms_ext -c_ext -prefix server _ $(CPP) $(INCS) -header $(RT_HEADER) \
          -cstub $(RT_CSTUB) -sstub $(RT_SSTUB) .\$(RT_IDL).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rpcrt\server\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETPATH=..\..\..\bin\$(ALT_BIN_TARGET)
TARGETNAME=rpcsrv
TARGETTYPE=PROGRAM
TARGETLIBS=..\..\..\lib\*\rpcperf.lib

INCLUDES=..\..;..\..\..\inc

SOURCES=..\server.c \
        ..\rpcrt_s.c

LINKLIBS= $(LINKLIBS) \
            $(SDK_LIB_DEST)\$(ALT_LINKLIB_PATH)\*\rpcrt4.lib          \
            $(SDK_LIB_PATH)\kernel32.lib   \
            $(SDK_LIB_PATH)\ntdll.lib

C_DEFINES=$(RPCENV)

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rpcrt\server\server.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    Server.c

Abstract:

    Server side of RPC runtime performance test.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:

--*/

#include <rpcperf.h>
#include <rpcrt.h>

// Usage
const char *USAGE =
           "[-i iterations] [-l logfile] [-n clients] [-n minthreads] [-n case]*\n"
           "      Client     - default 1\n"
           "      MinThreads - default 3\n"
           "      Cases, you may specify up to five, default is all:\n"
           "        0: Null Call\n"
           "        1: Null Call (Non-Idem)\n"
           "        2: 1K  IN\n"
           "        3: 1K  OUT\n"
           "        4: 4K  IN\n"
           "        5: 4K  OUT\n"
           "        6: 32K IN\n"
           "        7: 32K OUT\n"
           "        8: Null Call (Non-Idem) w/ Context handle\n"
           "        9: Bind (fixed endpoint)\n"
           "       10: Re-Bind\n"
           "       11: Bind (dynamic endpoint)\n"
           "       12: Async Null Call\n"
#ifdef WIN98
           "       13: Async STA Null Call\n"
#endif
           "\n"
           "        Note: Results are milliseconds/call/client\n"
           ;

//
// Globals making it easier.
//

int  CurrentCase;
char TestCases[TEST_MAX];  

long CurrentIter;
unsigned long *Results;

long Clients, ActiveClients, ClientsLeft;

CRITICAL_SECTION CritSec;
HANDLE GoEvent   = 0;
HANDLE DoneEvent = 0;

char *TestNames[TEST_MAX] =
    {
    "Void Call",
    "Void Call (non-idem)",
    "1Kb Write (in)",
    "1Kb Read (out)",
    "4Kb Write (in)",
    "4Kb Read (out)",
    "32Kb Write (in)",
    "32Kb Read (out)",
    "Context Handle",
    "Bind (fixed ep)",
    "Re-bind",
    "Bind (dynamic ep)",
    "Async Void Call"
#ifdef WIN98
    , "Async STA Void Call"
#endif
    };

long TestIterFactors[TEST_MAX] =
    {
    1,1,
    1,1,
    4,4,
    16,16,
    1,
    8,
    2,
    16,
    1
#ifdef WIN98
    ,1
#endif
    };

//
// Figure out what we're testing and start listening.
// 

int __cdecl
main (int argc, char **argv)
{
    unsigned int MinThreads;
    unsigned long i, status;
    RPC_BINDING_VECTOR *pBindingVector;
#ifdef WIN98
    BOOL fIsPortseqWmsg;
    HWND hWnd;
#endif

    ParseArgv(argc, argv);

    InitAllocator();

#ifdef WIN98
    if (strcmp(Protseq, "mswmsg") == 0)
        fIsPortseqWmsg = TRUE;
    else
        fIsPortseqWmsg = FALSE;
#endif

    MinThreads = 3;
    ClientsLeft = Clients = 1;
    ActiveClients = 0;

    if (Options[0] > 0)
        ClientsLeft = Clients = Options[0];

    Results = MIDL_user_allocate(4 * Clients);

    if (Options[1] > 0)
        MinThreads = Options[1];

    if (Options[2] < 0)
        {
        memset(TestCases, 1, TEST_MAX);
        }
    else
        {
        memset(TestCases, 0, TEST_MAX);
        for(i = 2; i < 7; i++)
            {
            if ( Options[i] < 0)
                break;
            if ( Options[i] >= TEST_MAX)
                break;
            TestCases[Options[i]] = 1;
            }
        }

    CurrentCase = 0;
    for(i = 0; i < TEST_MAX; i++)
        {
        if (TestCases[i])
            {
            CurrentCase = i;
            break;
            }
        }

    if (i == TEST_MAX)
        {
        printf("No test cases selected!\n");
        return 1;
        }

    CurrentIter = Iterations / TestIterFactors[CurrentCase];

    if (CurrentIter == 0) CurrentIter = 1;

    InitializeCriticalSection(&CritSec);

    GoEvent = CreateEvent(0,
                          TRUE,
                          FALSE,
                          0);

    DoneEvent = CreateEvent(0,
                            TRUE,
                            FALSE,
                            0);

    //
    // Actually start the server
    //

    if (Endpoint)
        {
        status = RpcServerUseProtseqEp(Protseq, 100, Endpoint, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");
        }
    else
        {
        char *string_binding;

        status = RpcServerUseProtseq(Protseq, 100, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");

        status = RpcServerInqBindings(&pBindingVector);
        CHECK_STATUS(status, "RpcServerInqBindings");

        status = RpcEpRegister(RpcRuntimePerf_v2_0_s_ifspec,
                               pBindingVector,
                               0,
                               0);
        CHECK_STATUS(status, "RpcEpRegister");

        status = RpcBindingToStringBinding(pBindingVector->BindingH[0],
                                           &string_binding);
        CHECK_STATUS(status, "RpcBindingToStringBinding");

        status = RpcStringBindingParse(string_binding,
                                       0, 0, 0, &Endpoint, 0);

        CHECK_STATUS(status, "RpcStringBindingParse");
        printf("Listening to %s:[%s]\n\n", Protseq, Endpoint);
        }

#ifdef WIN98
    if (fIsPortseqWmsg)
        {
        hWnd = CreateSTAWindow("Perf Server");
        if (hWnd == NULL)
            {
            printf("Creation of an STA window failed: %ld\n", GetLastError());
            return 2;
            }
        I_RpcServerStartListening(hWnd);
        }
#endif

    status =
    RpcServerRegisterIf(RpcRuntimePerf_v2_0_s_ifspec,0,0);
    CHECK_STATUS(status, "RpcServerRegisterIf");

    status = RpcServerRegisterAuthInfo(NULL,
                                       RPC_C_AUTHN_WINNT,
                                       NULL,
                                       NULL);
    CHECK_STATUS(status, "RpcServerRegisterAuthInfo");

    printf("Base Iterations: %d, Clients %d, MinThreads %d\n",
           Iterations,
           Clients,
           MinThreads);

    printf("Server listening\n");

#ifndef WIN98
    status = RpcServerListen(MinThreads, 100, 0);
    CHECK_STATUS(status, "RpcServerListen");
#else
    if (fIsPortseqWmsg)
        {
        status = RpcServerListen(MinThreads, 100, TRUE);
        CHECK_STATUS(status, "RpcServerListen");

        RunMessageLoop(hWnd);
        }
    else
        {
        status = RpcServerListen(MinThreads, 100, 0);
        CHECK_STATUS(status, "RpcServerListen");
        }
#endif

    printf("This doesn't stop listening..hmm\n");
    return 0;
}

//
// Control APIs that the client(s) call to sync on test cases, iterations
// and to report results.
//

error_status_t
BeginTest(handle_t b,
          long *ClientId)
{
    long status = 0;
    EnterCriticalSection(&CritSec);

    if (ActiveClients < Clients)
        {
        ActiveClients++;
        *ClientId = ActiveClients;
        }
    else
        {
        status = PERF_TOO_MANY_CLIENTS;
        }
    LeaveCriticalSection(&CritSec);

    return status;
}

error_status_t
NextTest(handle_t b,
         TEST_TYPE *Test,
         long *Iters)
{
    long wait   = 1;
    long done   = 0;
    int i;

    EnterCriticalSection(&CritSec);

    *Test = CurrentCase;
    *Iters = CurrentIter;

    ClientsLeft--;

    if (CurrentCase == TEST_MAX)
        {
        done = 1;
        }

    if (ClientsLeft == 0)
        {
        //
        // Let all the waiting clients go
        //
        wait = 0;
        ResetEvent(DoneEvent);
        SetEvent(GoEvent);
        }

    LeaveCriticalSection(&CritSec);

    if (wait)
        {
        WaitForSingleObject(GoEvent, INFINITE);
        }

    if (done)
        {

        if (ClientsLeft == 0)
            {
            // I'm the last client, sleep and then reset for
            // a new set of clients.  Sleep avoids a race (usually).

            Sleep(1000);

            for(i = 0; i < TEST_MAX; i++)
                {
                if (TestCases[i])
                    {
                    CurrentCase = i;
                    break;
                    }
                }

            CurrentIter = Iterations / TestIterFactors[CurrentCase];
            if (CurrentIter == 0) CurrentIter = 1;

            ActiveClients = 0;
            ClientsLeft   = Clients;

            ResetEvent(GoEvent);
            ResetEvent(DoneEvent);
            }

        return PERF_TESTS_DONE;
        }

    return 0;
}

error_status_t
EndTest(handle_t b,
        unsigned long mseconds)
{
    long status, i;
    long wait = 1;

    EnterCriticalSection(&CritSec);

    Results[ClientsLeft] = mseconds;

    ClientsLeft++;

    if (ClientsLeft == Clients)
        {
        // All clients have finished

        // Report results

        printf("| % 3d | %-20s | % 6d |",
               CurrentCase,
               TestNames[CurrentCase],
               CurrentIter
               );

        for(i = 0; i < Clients; i++)
            printf(" % 3d.%03d |",
                   Results[i] / CurrentIter,
                   Results[i] % CurrentIter * 1000 / CurrentIter    
                   );

        printf("\n");

        // Setup next case

        for(i = CurrentCase + 1; i < TEST_MAX; i++)
            {
#ifdef PROTOCOL_TRIM
            if (i == 11)
                continue;
#endif

#ifndef WIN98
            // NT does not test Async STA calls.
            if (i == 13)
                continue;
#else
            // Win9x also doesn't want to test Async STA calls unless the protseq is 

            if ((i == 13) && (strcmp(Protseq, "mswmsg") != 0))
                continue;
#endif

            if (TestCases[i])
                {
                CurrentCase = i;
                break;
                }
            }

        if (i == TEST_MAX)
            {
            CurrentCase = TEST_MAX;
            printf("TEST DONE\n");
            }
        else
            {
            CurrentIter = Iterations / TestIterFactors[CurrentCase];
            if (CurrentIter == 0) CurrentIter = 1;
            }
        //
        // We're setup for the next test (or to finish) let the clients go.
        //

        wait = 0;
        ResetEvent(GoEvent);
        SetEvent(DoneEvent);

        }
    LeaveCriticalSection(&CritSec);

    if (wait)
        WaitForSingleObject(DoneEvent, INFINITE);

    return 0;
}

//
// For fixed endpoint and re-bind test case
//

unsigned char *GetFixedEp(handle_t h)
{
    char *r;

    r = malloc(strlen(Endpoint) + 1);
    strcpy(r, Endpoint);
    return (unsigned char *)r;
}

//
// For context handle tests
//

PERF_CONTEXT OpenContext (handle_t b) { return (PERF_CONTEXT)1; }
void         CloseContext(PERF_CONTEXT *pp) { *pp = 0; }

void PERF_CONTEXT_rundown(PERF_CONTEXT pp)
{
    printf("Failure - a context randown\n");
}

//
// Regular test calls do nothing...
//

void NullCall(handle_t h)             { return; }
void NICall  (handle_t h)             { return; }
void ContextNullCall (PERF_CONTEXT h) { return; }
void Write1K (handle_t h, unsigned char *p) { return; }
void Read1K  (handle_t h, unsigned char *p) { return; }
void Write4K (handle_t h, unsigned char *p) { return; }
void Read4K  (handle_t h, unsigned char *p) { return; }
void Write32K(handle_t h, unsigned char *p) { return; }
void Read32K (handle_t h, unsigned char *p) { return; }
void AsyncNullCall(RPC_ASYNC_STATE *AsyncHandle, handle_t h)              
{
    RpcAsyncCompleteCall(AsyncHandle, NULL);
}

void AsyncSTANullCall(RPC_ASYNC_STATE *AsyncHandle, handle_t h)
{
    RpcAsyncCompleteCall(AsyncHandle, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rawio\iosvr.h ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) Microsoft Corporation, 1993 - 1999  All Rights Reserved.
//
//  MODULE:   socksrv.h
//
//  PURPOSE:  Definitions and prototypes for socksrv.c
//

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>
#include <winsock.h>
#include <wsipx.h>
#include <commdef.h>

#define MAXIMUM_NUMBER_OF_CLIENTS   64
#define MAXIMUM_NUMBER_OF_WORKERS   32
#define FILE_SIZE ((1024*1024*8)-CLIENT_OUTBOUND_BUFFER_MAX)

#define SIXTY_FOUR_K    (64*1024)
#define SIXTEEN_K       (16*1024)
DWORD InitialBuffer[SIXTY_FOUR_K/sizeof(DWORD)];
#define NUMBER_OF_WRITES ((FILE_SIZE+CLIENT_OUTBOUND_BUFFER_MAX)/SIXTY_FOUR_K)

#define CLIENT_CONNECTED    0x00000001
#define CLIENT_DONE         0x00000002

typedef struct _PER_CLIENT_DATA {
    SOCKET Socket;
    OVERLAPPED Overlapped;
    CLIENT_IO_BUFFER IoBuffer;
    CHAR OutboundBuffer[CLIENT_OUTBOUND_BUFFER_MAX];
    DWORD Flags;
    HANDLE hEvent;
} PER_CLIENT_DATA, *PPER_CLIENT_DATA;

typedef struct _PER_THREAD_DATA {
    DWORD TotalTransactions;
    DWORD TotalBytesTransferred;
} PER_THREAD_DATA, *PPER_THREAD_DATA;

PER_THREAD_DATA ThreadData[MAXIMUM_NUMBER_OF_WORKERS];
PER_CLIENT_DATA ClientData[MAXIMUM_NUMBER_OF_CLIENTS];
BOOL fVerbose;
BOOL fTcp;
DWORD dwNumberOfClients;
DWORD dwNumberOfWorkers;
DWORD dwConcurrency;
DWORD dwWorkIndex;
SYSTEM_INFO SystemInfo;
HANDLE CompletionPort;
DWORD dwActiveClientCount;
HANDLE hBenchmarkComplete;
HANDLE hBenchmarkStart;
DWORD StartTime;
DWORD EndTime;
HANDLE hFile;

DWORD
WINAPI
Random (
    DWORD nMaxValue
    );


VOID
WINAPI
ShowUsage(
    VOID
    );

VOID
WINAPI
ParseSwitch(
    CHAR chSwitch,
    int *pArgc,
    char **pArgv[]
    );

BOOL
WINAPI
CreateNetConnections(
    VOID
    );

BOOL
WINAPI
CreateWorkers(
    VOID
    );

DWORD
WINAPI
WorkerThread(
    LPVOID WorkContext
    );

VOID
WINAPI
CompleteBenchmark(
    VOID
    );

VOID
WINAPI
SortTheBuffer(
    LPDWORD Destination,
    LPDWORD Source,
    int DwordCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rpcrt\client\client.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    Client.c

Abstract:

    Client side of basic RPC performance test.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:

--*/

#include <rpcperf.h>
#include <rpcrt.h>

#ifdef MAC
extern void _cdecl PrintToConsole(const char *lpszFormat, ...) ;
extern unsigned long ulSecurityPackage ;
#else
#define PrintToConsole printf
unsigned long ulSecurityPackage = RPC_C_AUTHN_WINNT ;
#endif

// Usage

const char *USAGE = "-n <threads> -a <authnlevel> -s <server> -t <protseq> -w <wait_method>\n"
                    "Server controls iterations, test cases, and compiles the results.\n"
                    "AuthnLevel: none, connect, call, pkt, integrity, privacy.\n"
                    "Default threads=1, authnlevel=none\n";

#define CHECK_RET(status, string) if (status)\
        {  PrintToConsole("%s failed -- %lu (0x%08X)\n", string,\
                      (unsigned long)status, (unsigned long)status);\
        return (status); \
        }

#ifdef WIN98
RPC_DISPATCH_TABLE DummyDispatchTable =
{
    1, NULL
};

RPC_SERVER_INTERFACE DummyInterfaceInformation =
{
    sizeof(RPC_SERVER_INTERFACE),
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {1,1}},
    {{1,2,2,{3,3,3,3,3,3,3,3}},
     {0,0}},
    &DummyDispatchTable,
    0,
    NULL,
    NULL,
    NULL,
    0
};
#endif

RPC_STATUS DoRpcBindingSetAuthInfo(handle_t Binding)
{
    if (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        return RpcBindingSetAuthInfo(Binding,
                                     NULL,
                                     AuthnLevel,
                                     ulSecurityPackage,
                                     NULL,
                                     RPC_C_AUTHZ_NONE);
    else
        return(RPC_S_OK);
}

//
// Test wrappers
//

unsigned long DoNullCall(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        NullCall(*b);

    return (FinishTiming());
}

unsigned long DoNICall(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        NICall(*b);

    return (FinishTiming());
}

unsigned long DoWrite1K(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        Write1K(*b,p);

    return (FinishTiming());
}

unsigned long DoRead1K(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        Read1K(*b,p);

    return (FinishTiming());
}

unsigned long DoWrite4K(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        Write4K(*b,p);

    return (FinishTiming());
}

unsigned long DoRead4K(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        Read4K(*b,p);

    return (FinishTiming());
}

unsigned long DoWrite32K(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        Write32K(*b,p);

    return (FinishTiming());
}

unsigned long DoRead32K(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    StartTime();

    while(i--)
        Read32K(*b,p);

    return (FinishTiming());
}

unsigned long DoContextNullCall(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    unsigned long Time;
    PERF_CONTEXT pContext = OpenContext(*b);

    StartTime();

    while(i--)
        ContextNullCall(pContext);

    Time = FinishTiming();

    CloseContext(&pContext);

    return (Time);
}

unsigned long DoFixedBinding(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    unsigned long status;
    unsigned long Time;
    char *stringBinding;
    char *ep = GetFixedEp(*b);
    handle_t binding;

    RpcBindingFree(b); 

    RpcStringBindingCompose(0,
                            Protseq,
                            NetworkAddr,
                            ep,
                            0,
                            &stringBinding);

    MIDL_user_free(ep);

    StartTime();
    while(i--)
        {
        RpcBindingFromStringBinding(stringBinding, &binding);

	    status = DoRpcBindingSetAuthInfo(binding);
	    CHECK_RET(status, "RpcBindingSetAuthInfo");

        NullCall(binding);

        RpcBindingFree(&binding);
        }
    Time = FinishTiming();

    //
    // Restore binding for the rest of the test.
    //

    RpcBindingFromStringBinding(stringBinding, b);
    NullCall(*b);
    NullCall(*b);
    RpcStringFree(&stringBinding);

    return (Time);
}

unsigned long DoReBinding(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    unsigned long status;
    unsigned long Time;
    char *stringBinding;
    char *ep = GetFixedEp(*b);
    handle_t binding;

    RpcStringBindingCompose(0,
                            Protseq,
                            NetworkAddr,
                            ep,
                            0,
                            &stringBinding);

    MIDL_user_free(ep);

    StartTime();
    while(i--)
        {
        RpcBindingFromStringBinding(stringBinding, &binding);

	    status = DoRpcBindingSetAuthInfo(binding);
	    CHECK_RET(status, "RpcBindingSetAuthInfo");

        NullCall(binding);

        RpcBindingFree(&binding);
        }
    Time = FinishTiming();

    RpcStringFree(&stringBinding);

    return (Time);
}

unsigned long DoDynamicBinding(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    unsigned long status;
    unsigned long Time;
    char *stringBinding;
    handle_t binding;

    RpcBindingFree(b); 

    RpcStringBindingCompose(0,
                            Protseq,
                            NetworkAddr,
                            0,
                            0,
                            &stringBinding);

    StartTime();
    while(i--)
        {
        RpcBindingFromStringBinding(stringBinding, &binding);

	    status = DoRpcBindingSetAuthInfo(binding);
	    CHECK_RET(status, "RpcBindingSetAuthInfo");

        NullCall(binding);

        RpcBindingFree(&binding);
        }
    Time = FinishTiming();

    //
    // Restore binding for test to use.
    //

    RpcBindingFromStringBinding(stringBinding, b);
    NullCall(*b);
    NullCall(*b);
    RpcStringFree(&stringBinding);

    return (Time);
}

void AsyncProc(IN PRPC_ASYNC_STATE pAsync, IN void *context, IN RPC_ASYNC_EVENT asyncEvent)
{
    // no-op
}

void AsyncCallbackProc(IN PRPC_ASYNC_STATE pAsync, IN void *context, IN RPC_ASYNC_EVENT asyncEvent)
{
    // wake up our thread
    // in hThread we actually keep an event
    HANDLE hEvent = pAsync->u.APC.hThread;

    SetEvent(hEvent);
}

void NotifyProc(IN PRPC_ASYNC_STATE pAsync, IN void *context, IN RPC_ASYNC_EVENT asyncEvent)
{
    // no-op
}

unsigned long DoAsyncNullCallWithEvent(IN PRPC_ASYNC_STATE pAsync, handle_t __RPC_FAR * b, 
                                       long i, char __RPC_FAR *p)
{
    HANDLE hEvent = pAsync->u.hEvent;
    RPC_STATUS RpcStatus;

    StartTime();

    while(i--)
        {
        RpcStatus = RpcAsyncInitializeHandle(pAsync, RPC_ASYNC_VERSION_1_0);

        if (RpcStatus != RPC_S_OK)
            {
            printf("RpcAsyncInitializeHandle failed: %ld\n", GetLastError());
            return 0;
            }

        pAsync->NotificationType = RpcNotificationTypeEvent;
        pAsync->u.hEvent = hEvent;

        AsyncNullCall(pAsync, *b);
        WaitForSingleObject(hEvent, INFINITE);
        RpcAsyncCompleteCall(pAsync, NULL);
        }

    return (FinishTiming());
}

unsigned long DoAsyncNullCallWithApc(IN PRPC_ASYNC_STATE pAsync, handle_t __RPC_FAR * b, 
                                       long i, char __RPC_FAR *p)
{
    RPC_STATUS RpcStatus;

    StartTime();

    while(i--)
        {
        RpcStatus = RpcAsyncInitializeHandle(pAsync, RPC_ASYNC_VERSION_1_0);

        if (RpcStatus != RPC_S_OK)
            {
            printf("RpcAsyncInitializeHandle failed: %ld\n", GetLastError());
            return 0;
            }

        pAsync->NotificationType = RpcNotificationTypeApc;
        pAsync->u.APC.NotificationRoutine = AsyncProc;
        pAsync->u.APC.hThread = 0;

        AsyncNullCall(pAsync, *b);
        SleepEx(INFINITE, TRUE);
        RpcAsyncCompleteCall(pAsync, NULL);
        }

    return (FinishTiming());
}

unsigned long DoAsyncNullCallWithCallback(IN PRPC_ASYNC_STATE pAsync, handle_t __RPC_FAR * b, 
                                       long i, char __RPC_FAR *p)
{
    RPC_STATUS RpcStatus;
    HANDLE hEvent;
    unsigned long nTiming;

    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hEvent)
        {
        printf("CreateEvent failed: %ld\n", GetLastError());
        return 0;
        }

#ifdef WIN98
    // under Win9x, the client needs a running server to use callback
    // notifications. This assumption is Ok, since only OLE uses
    // callbacks, and in OLE every process is both client and server
    RpcStatus = RpcServerUseProtseqEp("ncalrpc", 1, "dummy", NULL);
    if (RpcStatus != RPC_S_OK)
        return 0;

    RpcStatus = RpcServerRegisterIf(&DummyInterfaceInformation, NULL, NULL);
    if (RpcStatus != RPC_S_OK)
        return 0;

    RpcStatus = RpcServerListen(1, 2, TRUE);
    if (RpcStatus != RPC_S_OK)
        return 0;

#endif

    StartTime();

    while(i--)
        {
        RpcStatus = RpcAsyncInitializeHandle(pAsync, RPC_ASYNC_VERSION_1_0);

        if (RpcStatus != RPC_S_OK)
            {
            printf("RpcAsyncInitializeHandle failed: %ld\n", GetLastError());
            return 0;
            }

        pAsync->NotificationType = RpcNotificationTypeCallback;
        pAsync->u.NotificationRoutine = AsyncCallbackProc;
        // just a little bit of a hack. We know that the we cannot use
        // the hEvent data member of u as we wished, because it occupies
        // the same memory location as the callback routine, so we
        // use the APC.hThread member which occupies the same DWORD
        pAsync->u.APC.hThread = hEvent;

        AsyncNullCall(pAsync, *b);
        WaitForSingleObject(hEvent, INFINITE);
        RpcAsyncCompleteCall(pAsync, NULL);
        }

    CloseHandle(hEvent);
    nTiming = FinishTiming();

#ifdef WIN98
    RpcStatus = RpcMgmtStopServerListening(NULL);
    if (RpcStatus == RPC_S_OK)
        {
        RpcMgmtWaitServerListen();
        }
#endif

    return nTiming;
}

unsigned long DoAsyncNullCallWithNone(IN PRPC_ASYNC_STATE pAsync, handle_t __RPC_FAR * b, 
                                       long i, char __RPC_FAR *p)
{
    RPC_STATUS RpcStatus;

    StartTime();

    while(i--)
        {
        RpcStatus = RpcAsyncInitializeHandle(pAsync, RPC_ASYNC_VERSION_1_0);

        if (RpcStatus != RPC_S_OK)
            {
            printf("RpcAsyncInitializeHandle failed: %ld\n", GetLastError());
            return 0;
            }

        pAsync->NotificationType = RpcNotificationTypeNone;

        AsyncNullCall(pAsync, *b);
        // make sure we catch even the slightest variations in performance. Loop all the time ...
        while (RpcAsyncGetCallStatus(pAsync) == RPC_S_ASYNC_CALL_PENDING)
            ;
        RpcAsyncCompleteCall(pAsync, NULL);
        }

    return (FinishTiming());
}

unsigned long DoAsyncNullCallWithHwnd(IN PRPC_ASYNC_STATE pAsync, handle_t __RPC_FAR * b, 
                                       long i, char __RPC_FAR *p)
{
    RPC_STATUS RpcStatus;
    HWND hWnd = pAsync->u.HWND.hWnd;

    StartTime();

    while(i--)
        {
        RpcStatus = RpcAsyncInitializeHandle(pAsync, RPC_ASYNC_VERSION_1_0);

        if (RpcStatus != RPC_S_OK)
            {
            printf("RpcAsyncInitializeHandle failed: %ld\n", GetLastError());
            return 0;
            }

        pAsync->NotificationType = RpcNotificationTypeHwnd;
        pAsync->u.HWND.hWnd = hWnd;
        pAsync->u.HWND.Msg = PERF_TEST_NOTIFY;

        AsyncNullCall(pAsync, *b);
        PumpMessage();
        RpcAsyncCompleteCall(pAsync, NULL);
        }

    return (FinishTiming());
}

unsigned long DoAsyncNullCall(handle_t __RPC_FAR * b, long i, char __RPC_FAR *p)
{
    RPC_ASYNC_STATE asyncState;
    RPC_STATUS RpcStatus;
    BOOL fCallComplete = FALSE;

    RpcStatus = RpcAsyncInitializeHandle(&asyncState, RPC_ASYNC_VERSION_1_0);

    if (RpcStatus != RPC_S_OK)
        {
        printf("RpcAsyncInitializeHandle failed: %ld\n", GetLastError());
        return 0;
        }

    asyncState.NotificationType = NotificationType;

    switch (NotificationType)
        {
        case RpcNotificationTypeEvent:
            asyncState.u.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (asyncState.u.hEvent == NULL)
                {
                printf("CreateEvent failed: %ld\n", GetLastError());
                return 0;
                }
            return DoAsyncNullCallWithEvent(&asyncState, b, i, p);

        case RpcNotificationTypeApc:
            return DoAsyncNullCallWithApc(&asyncState, b, i, p);

        case RpcNotificationTypeNone:
            return DoAsyncNullCallWithNone(&asyncState, b, i, p);

        case RpcNotificationTypeHwnd:
            asyncState.u.HWND.hWnd = CreateSTAWindow("Noname");
            if (asyncState.u.HWND.hWnd == NULL)
                {
                printf("CreateEvent failed: %ld\n", GetLastError());
                return 0;
                }
            asyncState.u.HWND.Msg = PERF_TEST_NOTIFY;
            return DoAsyncNullCallWithHwnd(&asyncState, b, i, p);

        case RpcNotificationTypeCallback:
            return DoAsyncNullCallWithCallback(&asyncState, b, i, p);
            
        default:
            printf("Invalid Notification option\n");
            return FALSE;
        }
}

unsigned long DoAsyncSTANullCall(handle_t __RPC_FAR * b, HWND hWnd, long i, char __RPC_FAR *p)
{
    RPC_STATUS RpcStatus;
    RPC_ASYNC_STATE asyncState;

    StartTime();

    while(i--)
        {
        RpcStatus = RpcAsyncInitializeHandle(&asyncState, RPC_ASYNC_VERSION_1_0);

        if (RpcStatus != RPC_S_OK)
            {
            printf("RpcAsyncInitializeHandle failed: %ld\n", GetLastError());
            return 0;
            }

        asyncState.NotificationType = RpcNotificationTypeCallback;
        asyncState.u.NotificationRoutine = NotifyProc;

        AsyncSTANullCall(&asyncState, *b);
        PumpMessage();
        RpcAsyncCompleteCall(&asyncState, NULL);
        }

    return (FinishTiming());
}

static const unsigned long (*TestTable[TEST_MAX])(handle_t __RPC_FAR *, long, char __RPC_FAR *) =
    {
    DoNullCall,
    DoNICall,
    DoWrite1K,
    DoRead1K,
    DoWrite4K,
    DoRead4K,
    DoWrite32K,
    DoRead32K,
    DoContextNullCall,
    DoFixedBinding,
    DoReBinding,
    DoDynamicBinding,
    DoAsyncNullCall
#ifdef WIN98
    , DoAsyncSTANullCall
#endif
    };

//
// Worker calls the correct tests.  Maybe multithreaded on NT
//

unsigned long Worker(unsigned long l)
{
    unsigned long status;
    unsigned long lTest;
    long lIterations, lClientId;
    unsigned long lTime;
    char __RPC_FAR *pBuffer;
    char __RPC_FAR *stringBinding;
    handle_t binding;
#ifdef WIN98
    BOOL fIsPortseqWmsg;
    HWND hWnd;
    HWND hServerWnd;
    DWORD dwServerTid;
#endif

#ifdef WIN98
    if (strcmp(Protseq, "mswmsg") == 0)
        {
        fIsPortseqWmsg = TRUE;
        hWnd = CreateSTAWindow("Perf Client");
        if (hWnd == NULL)
            {
            printf("Couldn't create STA window: %ld\n", GetLastError());
            return 0;
            }

        status = I_RpcServerStartListening(hWnd);
        if (status != RPC_S_OK)
            {
            printf("Failed to I_RpcServerStartListening: %ld\n", status);
            return 0;
            }
        }
    else
        fIsPortseqWmsg = FALSE;
#endif

    pBuffer = MIDL_user_allocate(32*1024L);
    if (pBuffer == 0)
        {
        PrintToConsole("Out of memory!");
        return 1;
        }

    status =
    RpcStringBindingCompose(0,
                            Protseq,
                            NetworkAddr,
                            Endpoint,
                            0,
                            &stringBinding);
    CHECK_RET(status, "RpcStringBindingCompose");


    status =
    RpcBindingFromStringBinding(stringBinding, &binding);
    CHECK_RET(status, "RpcBindingFromStringBinding");

    status =
    DoRpcBindingSetAuthInfo(binding);
    CHECK_RET(status, "RpcBindingSetAuthInfo");

    RpcStringFree(&stringBinding);

#ifdef WIN98
    if (fIsPortseqWmsg == TRUE)
        {
        while (TRUE)
            {
            hServerWnd = FindWindow(NULL, "Perf Server");
            if (hServerWnd)
                {
                dwServerTid = (DWORD)GetWindowLong(hServerWnd, GWL_USERDATA);
                break;
                }
            printf(".");
            Sleep(100);
            }

        status = I_RpcBindingSetAsync(binding, NULL, dwServerTid);
        if (status != RPC_S_OK)
            {
            printf("Failed to I_RpcBindingSetAsync: %ld\n", status);
            return 0;
            }

        PrintToConsole("(%ld iterations of case %ld: ", 10000, 13);

        lTime = DoAsyncSTANullCall(&binding, hWnd, 10000, pBuffer);

        PrintToConsole("%ld mseconds)\n",
               lTime
               );

        return RPC_S_OK;
        }
#endif

    RpcTryExcept
    {
        status =
        BeginTest(binding, &lClientId);
    }
    RpcExcept(1)
    {
        PrintToConsole("First call failed %ld (%08lx)\n",
               (unsigned long)RpcExceptionCode(),
               (unsigned long)RpcExceptionCode());
        goto Cleanup;
    }
    RpcEndExcept

    if (status == PERF_TOO_MANY_CLIENTS)
        {
        PrintToConsole("Too many clients, I'm exiting\n");
        goto Cleanup ;
        }
    CHECK_RET(status, "ClientConnect");

    PrintToConsole("Client %ld connected\n", lClientId);

    do
        {
        status = NextTest(binding, (TEST_TYPE *)&lTest, &lIterations);


        if (status == PERF_TESTS_DONE)
            {
            goto Cleanup;
            }

        CHECK_RET(status, "NextTest");

        PrintToConsole("(%ld iterations of case %ld: ", lIterations, lTest);

        RpcTryExcept
            {

            lTime = ( (TestTable[lTest])(&binding, lIterations, pBuffer));

            PrintToConsole("%ld mseconds)\n",
                   lTime
                   );

            status =
                EndTest(binding, lTime);

            CHECK_RET(status, "EndTest");

            }
        RpcExcept(1)
            {
            PrintToConsole("\nTest case %ld raised exception %lu (0x%08lX)\n",
                   lTest,
                   (unsigned long)RpcExceptionCode(),
                   (unsigned long)RpcExceptionCode());
            status = RpcExceptionCode();
            }
        RpcEndExcept

        }
    while(status == 0);

Cleanup:
    RpcBindingFree(&binding) ;
    return status;
}

//
// The Win32 main starts worker threads, otherwise we just call the worker.
//

#ifdef WIN32
int __cdecl
main (int argc, char **argv)
{
    char option;
    unsigned long status, i;
    HANDLE *pClientThreads;
#ifdef WIN98
    BOOL fIsPortseqWmsg;
#endif

    ParseArgv(argc, argv);

    PrintToConsole("Authentication Level is: %s\n", AuthnLevelStr);

    if (Options[0] < 0)
        Options[0] = 1;

    InitAllocator();

#ifdef WIN98
    if (strcmp(Protseq, "mswmsg") == 0)
        {
        fIsPortseqWmsg = TRUE;

        status = RpcServerUseProtseqEp(Protseq, 1, "Perf Client", NULL);
        if (status != RPC_S_OK)
            {
            printf("Failed to use protseq: %ld\n", status);
            return 3;
            }
        }
    else
        fIsPortseqWmsg = FALSE;
#endif

    pClientThreads = MIDL_user_allocate(sizeof(HANDLE) * Options[0]);

    for(i = 0; i < (unsigned long)Options[0]; i++)
        {
        pClientThreads[i] = CreateThread(0,
                                         0,
                                         (LPTHREAD_START_ROUTINE)Worker,
                                         0,
                                         0,
                                         &status);
        if (pClientThreads[i] == 0)
            ApiError("CreateThread", GetLastError());
        }


    status = WaitForMultipleObjects(Options[0],
                                    pClientThreads,
                                    TRUE,  // Wait for all client threads
                                    INFINITE);
    if (status == WAIT_FAILED)
        {
        ApiError("WaitForMultipleObjects", GetLastError());
        }

    PrintToConsole("TEST DONE\n");
    return(0);
}
#else  // !WIN32
#ifdef WIN 
#define main c_main

// We need the following to force the linker to load WinMain from the
// Windows STDIO library
extern int PASCAL WinMain(HANDLE, HANDLE, LPSTR, int);
static int (PASCAL *wm_ptr)(HANDLE, HANDLE, LPSTR, int) = WinMain;

#endif

#ifndef MAC
#ifndef FAR
#define FAR __far
#endif
#else
#define FAR
#define main c_main
#endif

int main (int argc, char FAR * FAR * argv)
{
#ifndef MAC
    ParseArgv(argc, argv);
#endif
    Worker(0);

    PrintToConsole("TEST DONE\n");

    return(0);
}
#endif // NTENV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\rpcrt\client\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETPATH=..\..\..\bin\$(ALT_BIN_TARGET)
TARGETNAME=rpcclnt
TARGETTYPE=PROGRAM
TARGETLIBS=..\..\..\lib\*\rpcperf.lib

INCLUDES=..\..;..\..\..\inc

SOURCES=..\client.c \
        ..\rpcrt_c.c

#USE_LIBCMT=1

LINKLIBS=   $(LINKLIBS) \
	    $(SDK_LIB_DEST)\$(ALT_LINKLIBS_PATH)\*\rpcrt4.lib          \
            $(SDK_LIB_PATH)\kernel32.lib	    \
	    $(SDK_LIB_PATH)\user32.lib              \
	    $(SDK_LIB_PATH)\ntdll.lib

C_DEFINES=$(RPCENV)

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\scale\rtsvr.c ===
/*++

Copyright (C) Microsoft Corporation, 1994-1999

Module Name:

    RtSvr.c

Abstract:

    Server side of RPC runtime scale performance test.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:

    18/7/96 [MarioGo] - cloned from rpcrt test server.

--*/

#include <rpcperf.h>
#include <rpcrt.h>

// Usage
const char *USAGE =
           "[-i iterations] -r [report interval] [-l logfile] [-n clients] [-n minthreads] [-n case]\n"
           "      Iterations - 4\n"
           "      Report     - 15 seconds\n"
           "      Clients    - default 1\n"
           "      MinThreads - default 3\n"
           "      Cases, you may specify one, default is 1:\n"
           "        1: Null Call\n"
           "        2: Null Call (Non-Idem)\n"
           "        3: Buffers Call\n"
           "           Add [-n in size], [-n out size], defaults of 500 in/out\n"
           "        4: Maybe Call\n"
           "        5: Bind and Call\n"
           "\n"
           ;

//
// Globals making it easier.
//


BOOL fClientsGoHome = FALSE;

long Clients, ActiveClients, ClientsLeft;

DWORD TestCase = 1;
DWORD InSize = 500;
DWORD OutSize = 500;

CRITICAL_SECTION CritSec;
HANDLE GoEvent   = 0;

#define RPC_PH_KEEP_STATS   100
#define RPC_PH_ACCOUNT_FOR_MAX_CALLS 101

#ifdef STATS
BOOL RPCRTAPI RPC_ENTRY RpcSetPerformanceHint(int PerformanceHint, void *pValue);
#endif

char *TestNames[TEST_MAX] =
    {
    "Void Call\n",
    "Void Call (non-idem)\n",
    "Buffer Call %d (in) %d (out)\n",
    "Maybe Calls\n",
    "Bind calls\n"
    };

typedef struct
    {
    DWORD dwRequestsProcessed;
    } CLIENT_STATE;

CLIENT_STATE *ClientState;

#ifdef STATS
// exported by RPCRT4
void I_RpcGetStats(DWORD *pdwStat1, DWORD *pdwStat2, DWORD *pdwStat3, DWORD *pdwStat4);
#endif

void WhackReg(void);

//
// Figure out what we're testing and start listening.
// 

int __cdecl
main (int argc, char **argv)
{
    unsigned int MinThreads;
    unsigned long i, j, status;
    RPC_BINDING_VECTOR *pBindingVector;
    SYSTEMTIME localTime;
    OSVERSIONINFO verInfo;

    DWORD StartCalls, FinalCalls, TotalCalls, TotalTicks, MinCalls, MaxCalls;
    DWORD dwStat1, dwStat2, dwStat3, dwStat4;

    InitAllocator();    

    ParseArgv(argc, argv);

    MinThreads = 3;
    ClientsLeft = Clients = 1;
    ActiveClients = 0;

//     DoTest();

    if (Options[0] > 0)
        ClientsLeft = Clients = Options[0];

    ClientState = MIDL_user_allocate(sizeof(CLIENT_STATE) * Clients);
    ZeroMemory(ClientState, sizeof(CLIENT_STATE) * Clients);

    if (Options[1] > 0)
        MinThreads = Options[1];

    if (Options[2] < 0)
        {
        TestCase = 1;
        }
    else
        {
        TestCase = Options[2];
        if (TestCase < 1 || TestCase > TEST_MAX)
            {
            printf("Error: test case %d out of range\n", Options[2]);
            TestCase = 1;
            }
        }

    TestCase--;

#ifdef STATS
    if (TestCase == 0)
        {
        BOOL fValue = FALSE;
        RpcSetPerformanceHint(RPC_PH_KEEP_STATS, &fValue);
        RpcSetPerformanceHint(RPC_PH_ACCOUNT_FOR_MAX_CALLS, &fValue);
        }
#endif

    if (Iterations == 1000)
        {
        Iterations = 4;
        }

    if (Options[3] > 0)
        {
        InSize = Options[3];
        }

    if (Options[4] > 0)
        {
        OutSize = Options[4];
        }

    // if a log file is on, make the output a bit more log-file friendly
    if (LogFileName)
        {
        GetLocalTime(&localTime);
        Dump("\n\n\n**** Perf Test Run ****");
        Dump("%d/%d/%d %d:%d:%d\n", localTime.wMonth, localTime.wDay, localTime.wYear,
            localTime.wHour, localTime.wMinute, localTime.wSecond);
        }

    InitializeCriticalSection(&CritSec);

#ifdef _WIN64
//    NtCurrentTeb()->ReservedForNtRpc = (PVOID)1;

//    WhackReg();
#endif

    GoEvent = CreateEvent(0,
                          TRUE,
                          FALSE,
                          0);

    //
    // Actually start the server
    //

    if (Endpoint)
        {
        status = RpcServerUseProtseqEpA(Protseq, 300, Endpoint, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");
        }
    else
        {
        char *string_binding;

        status = RpcServerUseProtseqA(Protseq, 300, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");

        status = RpcServerInqBindings(&pBindingVector);
        CHECK_STATUS(status, "RpcServerInqBindings");

        status = RpcEpRegister(_RpcRuntimeScalePerf_v1_0_s_ifspec,
                               pBindingVector,
                               0,
                               0);
        CHECK_STATUS(status, "RpcEpRegister");

        status = RpcBindingToStringBindingA(pBindingVector->BindingH[0],
                                           &string_binding);
        CHECK_STATUS(status, "RpcBindingToStringBinding");

        status = RpcStringBindingParseA(string_binding,
                                       0, 0, 0, &Endpoint, 0);

        CHECK_STATUS(status, "RpcStringBindingParse");
        printf("Listening to %s:[%s]\n\n", Protseq, Endpoint);
        }

    status =
    RpcServerRegisterIf(_RpcRuntimeScalePerf_v1_0_s_ifspec,0,0);
    CHECK_STATUS(status, "RpcServerRegisterIf");

    status = RpcServerRegisterAuthInfo(NULL,
                                       RPC_C_AUTHN_WINNT,
                                       NULL,
                                       NULL);
    CHECK_STATUS(status, "RpcServerRegisterAuthInfo (NTLM)");

    memset(&verInfo, 0, sizeof(verInfo));
    verInfo.dwOSVersionInfoSize = sizeof(verInfo);
    status = GetVersionEx(&verInfo);
    if (status == FALSE)
        {
        printf("Couldn't get system version (%d) - exitting\n", GetLastError());
        exit(2);
        }

    if ((verInfo.dwMajorVersion >= 5) && (verInfo.dwPlatformId == VER_PLATFORM_WIN32_NT))
        {
        status = RpcServerRegisterAuthInfo(NULL,
                                           RPC_C_AUTHN_GSS_KERBEROS,
                                           NULL,
                                           NULL);
        CHECK_STATUS(status, "RpcServerRegisterAuthInfo (KERBEROS)");

        status = RpcServerRegisterAuthInfo(NULL,
                                           RPC_C_AUTHN_GSS_NEGOTIATE,
                                           NULL,
                                           NULL);
        CHECK_STATUS(status, "RpcServerRegisterAuthInfo (SNEGO)");
        }

    printf("Clients %d, MinThreads %d\n",
           Clients,
           MinThreads);

    printf("Server listening\n\n");

    status = RpcServerListen(MinThreads, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    CHECK_STATUS(status, "RpcServerListen");

    printf("Running test: ");
    printf(TestNames[TestCase], InSize, OutSize);

    WaitForSingleObject(GoEvent, INFINITE);

    Sleep(1000);

    // Collect and report results.  Signal test shutdown when finished.

    for (i = 0; i < Iterations; i++)
        {

        StartTime();

        StartCalls = 0;
        for (j = 0; j < (ULONG)Clients; j++ )
            {
            StartCalls += ClientState[j].dwRequestsProcessed;
            }

        Sleep(Interval * 1000);

        FinalCalls = MaxCalls = 0;
        MinCalls = ~0;
        for (j = 0; j < (ULONG)Clients; j++)
            {
            DWORD t;

            t = ClientState[j].dwRequestsProcessed;

            FinalCalls += t;

            if (t < MinCalls)
                {
                MinCalls = t;
                }
            if (t > MaxCalls)
                {
                MaxCalls = t;
                }
            }

        TotalCalls = FinalCalls - StartCalls;

        TotalTicks = FinishTiming();

        Dump("Ticks: %4d, Total: %4d, Average %4d, TPS %3d\n",
             TotalTicks,
             TotalCalls,
             TotalCalls / Clients,
             TotalCalls * 1000 / TotalTicks
             );

        Verbose("Max: %d, Min: %d\n", MaxCalls, MinCalls);
        }

    fClientsGoHome = TRUE;

    Sleep(5000);

#ifdef STATS
    I_RpcGetStats(&dwStat1, &dwStat2, &dwStat3, &dwStat4);
    printf("Stats are: %ld, %ld, %ld, %ld\n", dwStat1, dwStat2, dwStat3, dwStat4);
#endif

    printf("Test Complete\n");

    return 0;
}

//
// Control APIs that the client(s) call to sync on test cases, iterations
// and to report results.
//

error_status_t
_BeginTest(handle_t b,
          DWORD *ClientId,
          DWORD *pTestCase,
          DWORD *pInSize,
          DWORD *pOutSize )
{
    long status = 0;

    EnterCriticalSection(&CritSec);

    if (ActiveClients < Clients)
        {
        *ClientId = ActiveClients;
        ActiveClients++;
        }
    else
        {
        status = PERF_TOO_MANY_CLIENTS;
        }
    LeaveCriticalSection(&CritSec);

    *pTestCase = TestCase;
    *pInSize = InSize;
    *pOutSize = OutSize;

    // Either wait for the rest of the clients or signal the clients to go.
    if (status == 0)
        {
        if (*ClientId < (ULONG)Clients - 1 )
            {
            // WaitForSingleObject(GoEvent, INFINITE);
            }
        else
            {
            SetEvent(GoEvent);
            }
        }

    return status;
}

#define TEST_BODY { ClientState[client].dwRequestsProcessed++;  \
                    if (fClientsGoHome) return PERF_TESTS_DONE; \
                    return 0;                                   \
                  }


DWORD _NullCall(handle_t h, DWORD client)
    TEST_BODY

void _MaybeCall  (handle_t h, DWORD client)
{
    ClientState[client].dwRequestsProcessed++;
}

DWORD _NICall  (handle_t h, DWORD client)
    TEST_BODY

DWORD _BufferCall(handle_t h, DWORD client, long crq, byte inb[], long crp, byte outb[])
    TEST_BODY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\splay\tstsplay.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       tstsplay.cxx
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////
//
//  File name: testsplay.cxx
//
//  Title: Splay Tree class
//
//  Desciption: Used for testing the splay tree class
//
//  Author: Scott Holden (t-scotth)
//
//  Date: August 16, 1994
//
////////////////////////////////////////////////////////////


#include <iostream.h>
#include <fstream.h>
#include "String.hxx"
#include "splaytre.hxx"

void __cdecl
main( int argc, char *argv[] )
{
    if ( argc != 2 ) {
        cerr << "Error: wrong number of arguments" << endl;
        return;
    }

    ifstream dictionary( argv[1] );
    if ( !dictionary ) {
        cerr << "Error: cannot open dictionary file" << endl;
        return;
    }
    String words;
    SplayTree<String> *DictTree = new SplayTree<String>;
    for ( ; !dictionary.eof();  ) {
        dictionary >> words;
        DictTree->Insert( new String( words ) );
    }
	
    String entry;
    String saveWord( "A" );
    String *FindDelWord;

	for ( ; ; ) {
		cout << "Options: quit, add <word>, find <word>, delete <word>, size (of dict), +, -, max, min\n" << endl;	
		cin >> entry;

		if ( ( entry == "quit" ) || ( entry == "q" ) ) {
			break;
		}
        else if ( ( entry == "size" ) || ( entry == "s" ) ) {
            cout << DictTree->Size() << " words in the dictionary\n" << endl;
        }
    #ifdef DEBUGRPC
        else if ( ( entry == "height" ) || ( entry == "h" ) ) {
            cout << DictTree->Depth() << " is the current heigth of the tree\n" << endl;
        }
    #endif // DEBUGRPC
		else if ( ( entry == "add" ) || ( entry == "a" ) ) {
            cin >> words;
			DictTree->Insert( new String( words ) );
            cout << endl;
            saveWord = words;
		}
		else if ( ( entry == "find" ) || ( entry == "f" ) ) {
            cin >> words;
			FindDelWord = DictTree->Find( &words );
            if ( FindDelWord ) {
                cout << *FindDelWord << " is in the dictionary\n" << endl;
                saveWord = *FindDelWord;
            }
            else cout << "The word is not in the dictionary\n" << endl;
		}
		else if ( ( entry == "delete" ) || ( entry == "d" ) ) {
            cin >> words;
            DictTree->Delete( &words );
            cout << endl;
        }
        else if ( entry == "+" ) {
            FindDelWord = DictTree->Successor( &saveWord );
            if ( FindDelWord ) {
                cout << "Successor of previous find/insert: " << *FindDelWord << endl << endl;
                saveWord = *FindDelWord;
            }
        }
        else if ( entry == "-" ) {
            FindDelWord = DictTree->Predecessor( &saveWord );
            if ( FindDelWord ) {
                cout << "Predecessor of previous find/insert: " << *FindDelWord << endl << endl;
                saveWord = *FindDelWord;
            }
        }
        else if ( entry == "max" ) {
            FindDelWord = DictTree->Maximum();
            if ( FindDelWord ) {
                cout << "The greatest word in the dictionary is: " << *FindDelWord << endl << endl;
            }
        }
        else if ( entry == "min" ) {
            FindDelWord = DictTree->Minimum();
            if ( FindDelWord ) {
                cout << "The smallest word in the dictionary is: " << *FindDelWord << endl << endl;
            }
        }
        else cerr << "Error: Wrong options" << endl;
	}

    //DictTree->Print();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\scale\rtclnt.c ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    Rtclnt.c

Abstract:

    Client side of basic RPC scale performance test.

Author:

    Mario Goertzel (mariogo)   31-Mar-1994

Revision History:

    18/7/96 [MarioGo] - Cloned from rpcrt test 

--*/

#include <rpcperf.h>
#include <rpcrt.h>

#ifdef MAC
extern void _cdecl PrintToConsole(const char *lpszFormat, ...) ;
extern unsigned long ulSecurityPackage ;
#else
#define PrintToConsole printf
extern unsigned long ulSecurityPackage;
#endif

// Usage

const char *USAGE = "-n <threads> -a <authnlevel> -s <server> -t <protseq>\n"
                    "Server controls iterations, test cases, and compiles the results.\n"
                    "AuthnLevel: none, connect, call, pkt, integrity, privacy.\n"
                    "Default threads=1, authnlevel=none\n";


unsigned long gInSize = 500 - IN_ADJUSTMENT;
unsigned long gOutSize = 500 - OUT_ADJUSTMENT;

#ifdef STATS
// exported by RPCRT4
void I_RpcGetStats(DWORD *pdwStat1, DWORD *pdwStat2, DWORD *pdwStat3, DWORD *pdwStat4);
#endif

// Error stuff

#define CHECK_RET(status, string) if (status)\
        {  PrintToConsole("%s failed -- %lu (0x%08X)\n", string,\
                      (unsigned long)status, (unsigned long)status);\
        return (status); }

RPC_STATUS DoRpcBindingSetAuthInfo(handle_t Binding)
{
    if (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        return RpcBindingSetAuthInfoA(Binding,
                                     ServerPrincipalName,
                                     AuthnLevel,
                                     ulSecurityPackage,
                                     NULL,
                                     RPC_C_AUTHZ_NONE);
    else
        return(RPC_S_OK);
}

//
// Test wrappers
//

unsigned long DoNullCall(handle_t *pb, char *stringBinding, unsigned long c, char __RPC_FAR *p)
{
    unsigned long status;
    unsigned long calls = 0;

    do
        {
        status = NullCall(*pb, c);
        calls++;

        }
    while (status == 0);

    if (status != PERF_TESTS_DONE)
        {
        RpcRaiseException(status);
        }

    return(calls);
}

unsigned long DoMaybeCall(handle_t *pb, char *stringBinding, unsigned long c, char __RPC_FAR *p)
{
    unsigned long calls = 0;

    for(calls = 10000; calls; calls--)
        {
        MaybeCall(*pb, c);
        }

    return(10000);
}


unsigned long DoNICall(handle_t *pb, char *stringBinding, unsigned long c, char __RPC_FAR *p)
{
    unsigned long status;
    unsigned long calls = 0;

    do
        {
        status = NICall(*pb, c);
        calls++;

        }
    while (status == 0);

    if (status != PERF_TESTS_DONE)
        {
        RpcRaiseException(status);
        }

    return(calls);
}

unsigned long DoBufferCall(handle_t *pb, char *stringBinding, unsigned long c, char __RPC_FAR *p)
{
    unsigned long status;
    unsigned long calls = 0;

    do
        {
        RpcTryExcept
            {
            status = BufferCall(*pb, c, gInSize, p, gOutSize, p);
            }
        RpcExcept(1)
            {
            PrintToConsole("\nException %lu (0x%08lX)\n",
                       (unsigned long)RpcExceptionCode(),
                       (unsigned long)RpcExceptionCode());
            }
        RpcEndExcept
        calls++;

        }
    while (status != PERF_TESTS_DONE);

    if (status != PERF_TESTS_DONE)
        {
        RpcRaiseException(status);
        }

    return(calls);
}

unsigned long DoBindCall(handle_t *pb, char *stringBinding, unsigned long c, char __RPC_FAR *p)
{
    unsigned long status;
    unsigned long calls = 0;

    do
        {
        status = RpcBindingFree(pb);
        if (status)
            {
            break;
            }

        status = RpcBindingFromStringBindingA(stringBinding, pb);
        if (status)
            {
            break;
            }

        status = NullCall(*pb, c);

        calls++;
        }
    while (status == 0);

    if (status != PERF_TESTS_DONE)
        {
        RpcRaiseException(status);
        }

    return(calls);
}


static const unsigned long (*TestTable[TEST_MAX])(handle_t *pb, char *stringBinding, unsigned long, char __RPC_FAR *) =
    {
    DoNullCall,
    DoNICall,
    DoBufferCall,
    DoMaybeCall,
    DoBindCall
    };

//
// Worker calls the correct tests.  Maybe multithreaded on NT
//

unsigned long Worker(unsigned long l)
{
    unsigned long status;
    unsigned long Test;
    unsigned long ClientId;
    unsigned long InSize, OutSize;
    unsigned long Time, Calls;
    char __RPC_FAR *pBuffer;
    char __RPC_FAR *stringBinding;
    handle_t binding;
    RPC_STATUS RpcErr;
    int Retries;

    pBuffer = MIDL_user_allocate(128*1024L);
    if (pBuffer == 0)
        {
        PrintToConsole("Out of memory!");
        return 1;
        }

    status =
    RpcStringBindingComposeA(0,
                            Protseq,
                            NetworkAddr,
                            Endpoint,
                            0,
                            &stringBinding);
    CHECK_RET(status, "RpcStringBindingCompose");

    status =
    RpcBindingFromStringBindingA(stringBinding, &binding);
    CHECK_RET(status, "RpcBindingFromStringBinding");

    status =
    DoRpcBindingSetAuthInfo(binding);
    CHECK_RET(status, "RpcBindingSetAuthInfo");

    Retries = 15;

    do
        {
        status = BeginTest(binding, &ClientId, &Test, &InSize, &OutSize);

        if (status == PERF_TOO_MANY_CLIENTS)
            {
            PrintToConsole("Too many clients, I'm exiting\n");
            goto Cleanup ;
            }

        Retries --;
        if ((status == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0))
            {
            PrintToConsole("Server too busy - retrying ...\n");
            }
        }
    while ((status == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0));

    if (status)
        {
        RPC_STATUS Status2;
        RPC_ERROR_ENUM_HANDLE EnumHandle;

        Status2 = RpcErrorStartEnumeration(&EnumHandle);
        if (Status2 == RPC_S_ENTRY_NOT_FOUND)
            {
            CHECK_RET(status, "ClientConnect");
            }
        else if (Status2 != RPC_S_OK)
            {
            PrintToConsole("Couldn't get EEInfo: %d\n", Status2);
            CHECK_RET(status, "ClientConnect");            
            }
        else
            {
            RPC_EXTENDED_ERROR_INFO ErrorInfo;
            int Records;
            BOOL Result;
            BOOL CopyStrings = TRUE;
            PVOID Blob;
            size_t BlobSize;
            BOOL fUseFileTime = TRUE;
            SYSTEMTIME *SystemTimeToUse;
            SYSTEMTIME SystemTimeBuffer;

            Status2 = RpcErrorGetNumberOfRecords(&EnumHandle, &Records);
            if (Status2 == RPC_S_OK)
                {
                PrintToConsole("Number of records is: %d\n", Records);
                }

            while (Status2 == RPC_S_OK)
                {
                ErrorInfo.Version = RPC_EEINFO_VERSION;
                ErrorInfo.Flags = 0;
                ErrorInfo.NumberOfParameters = 4;
                if (fUseFileTime)
                    {
                    ErrorInfo.Flags |= EEInfoUseFileTime;
                    }

                Status2 = RpcErrorGetNextRecord(&EnumHandle, CopyStrings, &ErrorInfo);
                if (Status2 == RPC_S_ENTRY_NOT_FOUND)
                    {
                    RpcErrorResetEnumeration(&EnumHandle);
                    break;
                    }
                else if (Status2 != RPC_S_OK)
                    {
                    PrintToConsole("Couldn't finish enumeration: %d\n", Status2);
                    break;
                    }
                else
                    {
                    int i;

                    if (ErrorInfo.ComputerName)
                        {
                        PrintToConsole("ComputerName is %S\n", ErrorInfo.ComputerName);
                        if (CopyStrings)
                            {
                            Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.ComputerName);
                            ASSERT(Result);
                            }
                        }
                    PrintToConsole("ProcessID is %d\n", ErrorInfo.ProcessID);
                    if (fUseFileTime)
                        {
                        Result = FileTimeToSystemTime(&ErrorInfo.u.FileTime, &SystemTimeBuffer);
                        ASSERT(Result);
                        SystemTimeToUse = &SystemTimeBuffer;
                        }
                    else
                        SystemTimeToUse = &ErrorInfo.u.SystemTime;

                    PrintToConsole("System Time is: %d/%d/%d %d:%d:%d:%d\n", 
                        SystemTimeToUse->wMonth,
                        SystemTimeToUse->wDay,
                        SystemTimeToUse->wYear,
                        SystemTimeToUse->wHour,
                        SystemTimeToUse->wMinute,
                        SystemTimeToUse->wSecond,
                        SystemTimeToUse->wMilliseconds);
                    PrintToConsole("Generating component is %d\n", ErrorInfo.GeneratingComponent);
                    PrintToConsole("Status is %d\n", ErrorInfo.Status);
                    PrintToConsole("Detection location is %d\n", (int)ErrorInfo.DetectionLocation);
                    PrintToConsole("Flags is %d\n", ErrorInfo.Flags);
                    PrintToConsole("NumberOfParameters is %d\n", ErrorInfo.NumberOfParameters);
                    for (i = 0; i < ErrorInfo.NumberOfParameters; i ++)
                        {
                        switch(ErrorInfo.Parameters[i].ParameterType)
                            {
                            case eeptAnsiString:
                                PrintToConsole("Ansi string: %s\n", ErrorInfo.Parameters[i].u.AnsiString);
                                if (CopyStrings)
                                    {
                                    Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.Parameters[i].u.AnsiString);
                                    ASSERT(Result);
                                    }
                                break;

                            case eeptUnicodeString:
                                PrintToConsole("Unicode string: %S\n", ErrorInfo.Parameters[i].u.UnicodeString);
                                if (CopyStrings)
                                    {
                                    Result = HeapFree(GetProcessHeap(), 0, ErrorInfo.Parameters[i].u.UnicodeString);
                                    ASSERT(Result);
                                    }
                                break;

                            case eeptLongVal:
                                PrintToConsole("Long val: %d\n", ErrorInfo.Parameters[i].u.LVal);
                                break;

                            case eeptShortVal:
                                PrintToConsole("Short val: %d\n", (int)ErrorInfo.Parameters[i].u.SVal);
                                break;

                            case eeptPointerVal:
                                PrintToConsole("Pointer val: %d\n", ErrorInfo.Parameters[i].u.PVal);
                                break;

                            case eeptNone:
                                PrintToConsole("Truncated\n");
                                break;

                            default:
                                PrintToConsole("Invalid type: %d\n", ErrorInfo.Parameters[i].ParameterType);
                            }
                        }
                    }
                }
            Status2 = RpcErrorSaveErrorInfo(&EnumHandle, &Blob, &BlobSize);
            CHECK_RET(Status2, "RpcErrorSaveErrorInfo");
            RpcErrorClearInformation();
            RpcErrorEndEnumeration(&EnumHandle);
            Status2 = RpcErrorLoadErrorInfo(Blob, BlobSize, &EnumHandle);
            CHECK_RET(Status2, "RpcErrorLoadErrorInfo");
            }
        }

    CHECK_RET(status, "ClientConnect");

    if (InSize > IN_ADJUSTMENT)
        {
        InSize -= IN_ADJUSTMENT;
        }
    else
        {
        InSize = 0;
        }

    if (OutSize > OUT_ADJUSTMENT)
        {
        OutSize -= OUT_ADJUSTMENT;
        }
    else
        {
        OutSize = 0;
        }

    gInSize = InSize;
    gOutSize = OutSize;

    PrintToConsole("Client %ld connected\n", ClientId);

    Retries = 15;

    do
        {
        RpcTryExcept
            {
            RpcErr = RPC_S_OK;

            Time = GetTickCount();

            Calls = ( (TestTable[Test])(&binding, stringBinding, ClientId, pBuffer) );

            Time = GetTickCount() - Time;
       
            Dump("Completed %d calls in %d ms\n"
                   "%d T/S or %3d.%03d ms/T\n\n",
                   Calls,
                   Time,
                   (Calls * 1000) / Time,
                   Time / Calls,
                   ((Time % Calls) * 1000) / Calls
                   );
            }
        RpcExcept(1)
            {
            RpcErr = (unsigned long)RpcExceptionCode();
            PrintToConsole("\nException %lu (0x%08lX)\n",
                       RpcErr, RpcErr);
            }
        RpcEndExcept
        Retries --;
        if ((RpcErr == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0))
            {
            PrintToConsole("Server too busy - retrying ...\n");
            }
        }
    while ((RpcErr == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0));

Cleanup:
    RpcBindingFree(&binding);
    return status;
}

//
// The Win32 main starts worker threads, otherwise we just call the worker.
//

#ifdef WIN32
int __cdecl
main (int argc, char **argv)
{
    char option;
    unsigned long status, i;
    HANDLE *pClientThreads;
    DWORD dwStat1, dwStat2, dwStat3, dwStat4;

    InitAllocator();

    ulSecurityPackage = RPC_C_AUTHN_WINNT;
    ParseArgv(argc, argv);

    PrintToConsole("Authentication Level is: %s\n", AuthnLevelStr);

    if (Options[0] < 0)
        Options[0] = 1;

    pClientThreads = MIDL_user_allocate(sizeof(HANDLE) * Options[0]);

    for(i = 0; i < (unsigned long)Options[0]; i++)
        {
        pClientThreads[i] = CreateThread(0,
                                         0,
                                         (LPTHREAD_START_ROUTINE)Worker,
                                         0,
                                         0,
                                         &status);
        if (pClientThreads[i] == 0)
            ApiError("CreateThread", GetLastError());
        }


    status = WaitForMultipleObjects(Options[0],
                                    pClientThreads,
                                    TRUE,  // Wait for all client threads
                                    INFINITE);
    if (status == WAIT_FAILED)
        {
        ApiError("WaitForMultipleObjects", GetLastError());
        }

#ifdef STATS
    I_RpcGetStats(&dwStat1, &dwStat2, &dwStat3, &dwStat4);
    printf("Stats are: %ld, %ld, %ld, %ld\n", dwStat1, dwStat2, dwStat3, dwStat4);
#endif

    PrintToConsole("TEST DONE\n");
    return(0);
}
#else  // !WIN32
#ifdef WIN 
#define main c_main

// We need the following to force the linker to load WinMain from the
// Windows STDIO library
extern int PASCAL WinMain(HANDLE, HANDLE, LPSTR, int);
static int (PASCAL *wm_ptr)(HANDLE, HANDLE, LPSTR, int) = WinMain;

#endif

#ifndef MAC
#ifndef FAR
#define FAR __far
#endif
#else
#define FAR
#define main c_main
#endif

int main (int argc, char FAR * FAR * argv)
{
#ifndef MAC
    ParseArgv(argc, argv);
#endif
    Worker(0);

    PrintToConsole("TEST DONE\n");

    return(0);
}
#endif // NTENV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\splay\string.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       string.cxx
//
//--------------------------------------------------------------------------

//
//
// Filename: String.cxx
//
// Description: contains class functions for a basic
//              string class
//
// Author: Scott Holden (t-scotth)
//
//

#include "String.hxx"

String::String( const char *str )
{
    _length = strlen( str );
    _string = new char[ _length + 1 ];
    strcpy( _string, str );
}

String::String( const String& str )
{
	_length = str._length;
    _string = new char[ _length + 1 ];
    strcpy( _string, str._string );
}

String&
String::operator=( const String& str )
{
    if ( this != &str ) { //bad things happen if s=s
        if ( _string ) {
            delete[] _string;
        }
        _length = str._length;
        _string = new char[ _length + 1 ];
        strcpy( _string, str._string );
    }
    return *this;
}

String&
String::operator=( const char* str )
{
    if ( _string ) {
        delete[] _string;
    }
    _length = strlen( str );
    _string = new char[ _length + 1 ];
    strcpy( _string, str );
    return *this;
}

ostream&
operator<<( ostream& s, const String &x )
{
    return  s << x._string;
}

istream&
operator>>( istream& s, String &x )
{
    char buf[100];
    s >> buf;
    x = buf;
    //cout << x._string << " \t[" << x._length << "]" << endl;
    return s;
}

char&
String::operator[]( int i )
{
    if ( ( i < 0 ) || ( _length <= i ) ) {
        cerr << "Error: index out of range" << endl;
    }
    return _string[i];
}

const char&
String::operator[]( int i ) const
{
    if ( ( i < 0 ) || ( _length <= i ) ) {
        cerr << "Error: index out of range" << endl;
    }
    return _string[i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\syncmgr\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

SM_IDL = smgr

SM_CSTUB  = $(SM_IDL)_c.c
SM_SSTUB  = $(SM_IDL)_s.c
SM_HEADER = obj\$(SM_IDL).h

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) -error ref

#

allidl: smgr

#
# MIDL COMPILE
#
smgr: $(SM_HEADER) $(SM_CSTUB) $(SM_SSTUB)

$(SM_HEADER) $(SM_CSTUB) $(SM_SSTUB) : .\$(SM_IDL).idl
    midl  -ms_ext -c_ext -prefix server _ $(CPP) $(INCS) -header $(SM_HEADER) \
          -cstub $(SM_CSTUB) -sstub $(SM_SSTUB) .\$(SM_IDL).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\syncmgr\syncclnt.cpp ===
#define DBG     1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <rpc.h>
#include <midles.h>
#include "..\smgr.h"

#define RPC_CHAR WCHAR

#define CHECK_STATUS(status, string) if (status) {                       \
        printf("%s failed - %d (%08x)\n", (string), (status), (status)); \
        exit(1);                                                         \
        } else printf("%s okay\n", (string));

PVOID SystemHeap = NULL;

extern "C" {

void  __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t bytes)
{
    return RtlAllocateHeap(SystemHeap, 0, bytes);
}

void  __RPC_USER MIDL_user_free(void __RPC_FAR * p)
{
    RtlFreeHeap(SystemHeap, 0, p);
}

}

int __cdecl main(int argc, char *argv[])
{
    RPC_STATUS status;
    unsigned char __RPC_FAR *stringBinding;
    handle_t binding;
    SyncManagerCommands CurrentCommand;
    UString *param = NULL;
    int ClientOrServer;
    BOOL bResult;
    STARTUPINFO startInfo;
    PROCESS_INFORMATION processInfo;
    RPC_CHAR CmdLine[400];

    memset(&startInfo, 0, sizeof(startInfo));
    startInfo.cb = sizeof(startInfo);

    SystemHeap = GetProcessHeap();

    if (argc != 3)
        {
        printf("Usage:\n\tsyncclnt s|c syncmgr_server\n");
        return 2;
        }

    if (*argv[1] == 'c' || *argv[1] == 'C')
        ClientOrServer = 1;
    else
        ClientOrServer = 0;

    status = RpcStringBindingComposeA(0,
                            (unsigned char *)"ncacn_ip_tcp",
                            (unsigned char *)argv[2],
                            (unsigned char *)"",
                            0,
                            &stringBinding);

    CHECK_STATUS(status, "RpcStringBindingCompose");

    status = RpcBindingFromStringBindingA(stringBinding, &binding);
    CHECK_STATUS(status, "RpcBindingFromStringBinding");

    RpcStringFreeA(&stringBinding);

    DeleteFile(L"c:\\perf.log");

    RpcMgmtSetComTimeout(binding, RPC_C_BINDING_INFINITE_TIMEOUT);

    // start the loop
    do
        {
        GetCommand(binding, ClientOrServer, &CurrentCommand, &param);
        switch (CurrentCommand)
            {
            case smcNOP:
                continue;

            case smcExec:
                wcscpy(CmdLine, param->pString);
                CmdLine[param->nlength] = 0;
                MIDL_user_free(param);
                param = NULL;
                bResult = CreateProcess(NULL, CmdLine, NULL, NULL, FALSE, CREATE_NEW_CONSOLE, NULL,
                    NULL, &startInfo, &processInfo);
                if (bResult)
                    {
                    CloseHandle(processInfo.hThread);
                    WaitForSingleObject(processInfo.hProcess, INFINITE);
                    CloseHandle(processInfo.hProcess);
                    }
                else
                    {
                    printf("CreateProcess failed: %S, %d\n", CmdLine, GetLastError());
                    return 2;
                    }
                break;

            }
        }
    while(CurrentCommand != smcExit);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\syncmgr\syncman.cpp ===
#define DBG     1
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif
#include <windows.h>
#include <rpc.h>
#include <midles.h>
#include "smgr.h"

#define RPC_CHAR WCHAR

#define CHECK_STATUS(status, string) if (status) {                       \
        printf("%s failed - %d (%08x)\n", (string), (status), (status)); \
        exit(1);                                                         \
        } else printf("%s okay\n", (string));

PVOID SystemHeap = NULL;

extern "C" {

void  __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t bytes)
{
    return RtlAllocateHeap(SystemHeap, 0, bytes);
}

void  __RPC_USER MIDL_user_free(void __RPC_FAR * p)
{
    RtlFreeHeap(SystemHeap, 0, p);
}

}

inline UString *AllocateUString(unsigned short *pString)
{
    int nStringSize = wcslen(pString);  // we don't do + 1, because the UString data structure
                                        // has one slot
    UString *pNewString;

    pNewString = (UString *)RtlAllocateHeap(SystemHeap, 0, sizeof(UString) + nStringSize * 2);
    if (pNewString)
        {
        pNewString->nlength = nStringSize + 1;
        wcscpy(&(pNewString->pString[0]), pString);
        }
    return pNewString;
}

inline UString *DuplicateUString(UString *pString)
{
    if (pString)
        {
        // -1 because we have on slot in the structure
        int nMemSize = sizeof(UString) + (pString->nlength - 1) * 2;
        UString *pNewString;

        pNewString = (UString *)RtlAllocateHeap(SystemHeap, 0, nMemSize);
        memcpy(pNewString, pString, nMemSize);
        return pNewString;
        }
    else
        return NULL;
}

typedef enum tagSyncManagerState
{
    smsRunning,
    smsDone,
    smsWaiting
} SyncManagerState;

FILE *fp;
FILE *fpLogFile;
long AvailableClients = 0;
long NeededClients = 0;
long RunningClients = 0;
BOOL fServerAvailable = FALSE;
SyncManagerCommands CurrentClientCommand = smcExec;
SyncManagerCommands CurrentServerCommand = smcExec;
UString *CurrentClientParam = NULL;
UString *CurrentServerParam = NULL;
SyncManagerState state = smsDone;
CRITICAL_SECTION ActionLock;
HANDLE GoEvent;

int __cdecl main(int argc, char *argv[])
{
    RPC_STATUS status;
    RPC_CHAR *string_binding;
    RPC_BINDING_VECTOR *pBindingVector;
    RPC_CHAR *Endpoint;

    SystemHeap = GetProcessHeap();

    if (argc != 2)
        {
        printf("Usage:\n\tsyncmgr script_file\n");
        return 2;
        }

    fp = fopen(argv[1], "rt");
    if (fp == NULL)
        {
        printf("Couldn't open file: %s\n", argv[1]);
        return 2;
        }

    fpLogFile = fopen("c:\\syncmgr.log", "wt");
    if (fpLogFile == NULL)
        {
        printf("Couldn't open log file: %s\n", "c:\\syncmgr.log");
        return 2;
        }

    InitializeCriticalSection(&ActionLock);

    GoEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    status = RpcServerUseProtseqW(L"ncacn_ip_tcp", 300, 0);
    CHECK_STATUS(status, "RpcServerUseProtseqW");

    status = RpcServerInqBindings(&pBindingVector);
    CHECK_STATUS(status, "RpcServerInqBindings");

    status = RpcEpRegister(_SyncManager_v1_0_s_ifspec,
                           pBindingVector,
                           0,
                           0);
    CHECK_STATUS(status, "RpcEpRegister");

    status = RpcBindingToStringBindingW(pBindingVector->BindingH[0],
                                       &string_binding);
    CHECK_STATUS(status, "RpcBindingToStringBinding");

    status = RpcStringBindingParseW(string_binding,
                                   0, 0, 0, &Endpoint, 0);

    CHECK_STATUS(status, "RpcStringBindingParse");
    printf("Listening to %S:[%S]\n\n", "ncacn_ip_tcp", Endpoint);

    status = RpcServerRegisterIf(_SyncManager_v1_0_s_ifspec,0,0);
    CHECK_STATUS(status, "RpcServerRegisterIf");

    printf("Server listening\n\n");

    status = RpcServerListen(3, RPC_C_LISTEN_MAX_CALLS_DEFAULT, FALSE);
    CHECK_STATUS(status, "RpcServerListen");

    return 0;
}

inline BOOL IsWhiteSpace(int c)
{
    return ((c == '\n')
        || (c == '\t')
        || (c == ' '));
}

void _GetCommand(handle_t IDL_handle, int ClientOrServer, SyncManagerCommands __RPC_FAR *cmd, 
                UString __RPC_FAR *__RPC_FAR *param)
{
    RPC_CHAR NewCommand[400];
    RPC_CHAR *pPosition;
    RPC_CHAR *Clients;
    RPC_CHAR *ClientCmd;
    RPC_CHAR *SvrCmd;
    RPC_CHAR *Ignored;
    handle_t hClientHandle;
    RPC_STATUS RpcStatus;
    RPC_CHAR *StringBinding;
    DWORD WaitResult;

    RpcStatus = RpcBindingServerFromClient(IDL_handle, &hClientHandle);
    if (RpcStatus != RPC_S_OK)
        {
        printf("RpcBindingServerFromClient failed: %d\n", RpcStatus);
        *cmd = smcExit;
        *param = NULL;
        return;
        }

    RpcStatus = RpcBindingToStringBindingW(hClientHandle, &StringBinding);
    if (RpcStatus != RPC_S_OK)
        {
        printf("RpcBindingToStringBindingW failed: %d\n", RpcStatus);
        RpcBindingFree(&hClientHandle);
        *cmd = smcExit;
        *param = NULL;
        return;
        }

    RpcBindingFree(&hClientHandle);

    // if we came in the middle of a test, wait for it to finish
    while (TRUE)
        {
        EnterCriticalSection(&ActionLock);
        if (state != smsRunning)
            break;
        else
            {
            LeaveCriticalSection(&ActionLock);
            printf("%S came in the middle of a test - waiting for it to finish\n", StringBinding);
            Sleep(60000);
            }
        }

    // are we the first one after a run?
    if (state == smsDone)
        {
        printf("Client %S is reading next command\n", StringBinding);
        ResetEvent(GoEvent);
        RunningClients = 0;

        // free old arguments if any
        if (CurrentClientParam)
            {
            MIDL_user_free(CurrentClientParam);
            CurrentClientParam = NULL;
            }
        if (CurrentServerParam)
            {
            MIDL_user_free(CurrentServerParam);
            CurrentServerParam = NULL;
            }

        while (TRUE)
            {
            // get the new command line
            pPosition = fgetws(NewCommand, sizeof(NewCommand), fp);
            if (pPosition == NULL)
                {
                CurrentClientCommand = smcExit;
                CurrentServerCommand = smcExit;
                CurrentClientParam = NULL;
                CurrentServerParam = NULL;
                fprintf(fpLogFile, "End of file encountered\n");
                break;
                }
            else
                {
                // parse the command
                // first, trim spaces from the end
                pPosition = wcschr(NewCommand, '\0') - 1;
                while (IsWhiteSpace(*pPosition) && (pPosition > NewCommand))
                    {
                    *pPosition = 0;
                    pPosition --;
                    }

                // was anything left?
                if (pPosition == NewCommand)
                    continue;

                // is this a comment line?
                if (NewCommand[0] == ';')
                    continue;

                // real line - should have the format #,srv_cmd,clnt_cmd
                pPosition = wcschr(NewCommand, ',');
                *pPosition = '\0';
                Clients = NewCommand;

                pPosition ++;
                SvrCmd = pPosition;
                pPosition = wcschr(pPosition, ',');
                *pPosition = '\0';

                ClientCmd = pPosition + 1;

                NeededClients = wcstol(Clients, &Ignored, 10);

                CurrentServerParam = AllocateUString(SvrCmd);
                CurrentClientParam = AllocateUString(ClientCmd);
                break;
                }
            }
        state = smsWaiting;
        }

    if (CurrentClientCommand == smcExit)
        {
        printf("Client %S is getting exit command\n", StringBinding);
        if (ClientOrServer)
            {
            *cmd = CurrentClientCommand;
            *param = DuplicateUString(CurrentClientParam);
            LeaveCriticalSection(&ActionLock);
            goto CleanupAndExit;
            }
        else
            {
            *cmd = CurrentServerCommand;
            *param = DuplicateUString(CurrentServerParam);
            LeaveCriticalSection(&ActionLock);
            goto CleanupAndExit;
            }
        }

    if (ClientOrServer)
        {
        AvailableClients ++;
        printf("Client %S has increased the number of available clients to %d (%d needed)\n",
            StringBinding, AvailableClients, NeededClients);
        }
    else
        {
        fServerAvailable = TRUE;
        printf("Server %S has become available\n", StringBinding);
        }

    // we have everybody for this test - kick it off
    if ((AvailableClients >= NeededClients) && fServerAvailable)
        {
        printf("Client %S is kicking off tests\n", StringBinding);
        *cmd = smcExec;
        if (ClientOrServer)
            {
            AvailableClients --;
            RunningClients = 1;
            *param = DuplicateUString(CurrentClientParam);
            }
        else
            {
            fServerAvailable = FALSE;
            *param = DuplicateUString(CurrentServerParam);
            }
        state = smsRunning;
        LeaveCriticalSection(&ActionLock);
        SetEvent(GoEvent);

        // if we were client, create artificial delay for server to start
        if (ClientOrServer)
            Sleep(40000);

        printf("Client %S kicked off test and returns\n", StringBinding);
        goto CleanupAndExit;
        }
    else
        {
        // we don't have enough clients or the server is not there yet
        LeaveCriticalSection(&ActionLock);
        printf("Client %S starts waiting .... Tid is 0x%x\n", StringBinding, GetCurrentThreadId());
        }

    do
        {
        WaitResult = WaitForSingleObject(GoEvent, 600000);
        if (WaitResult == WAIT_TIMEOUT)
            {
            printf("Client %S is still waiting for GoEvent ...\n", StringBinding);
            }
        }
    while (WaitResult != WAIT_OBJECT_0);

    EnterCriticalSection(&ActionLock);

    if (ClientOrServer)
        AvailableClients --;
    else
        fServerAvailable = FALSE;

    if ((AvailableClients == 0) && (fServerAvailable == FALSE))
        state = smsDone;

    // if we are client and were left out don't do anything
    if (ClientOrServer && ((RunningClients + 1) > NeededClients))
        {
        printf("Client %S was left out and returns. Available: %d\n", StringBinding, AvailableClients);
        *param = NULL;
        *cmd = smcNOP;
        }
    else
        {
        printf("Client %S picked a command and returns\n", StringBinding);
        if (ClientOrServer)
            RunningClients ++;
        *cmd = smcExec;
        if (ClientOrServer)
            *param = DuplicateUString(CurrentClientParam);
        else
            *param = DuplicateUString(CurrentServerParam);
        }
    LeaveCriticalSection(&ActionLock);

    // if we were a client, create a 15 second artificial delay, giving the 
    // server a chance to start - this saves us some more sync-ing
    if ((*cmd == smcExec) && ClientOrServer)
        Sleep(15000);

CleanupAndExit:
    RpcStringFreeW(&StringBinding);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\splay\splaytre.inl ===
////////////////////////////////////////////////////////////
//
//  File name: splaytree.cxx
//
//  Title: Splay Tree class
//
//  Desciption:
//
//  Author: Scott Holden (t-scotth)
//
//  Date: August 16, 1994
//
////////////////////////////////////////////////////////////

#include <sysinc.h>
#include "splaytre.hxx"

template<class T>
void
SplayTree<T>::Splay(
        SplayNode<T> *node
        )
{
    SplayNode<T> *Current = node;
    SplayNode<T> *Parent;
    SplayNode<T> *GrandParent;

    while ( !IsRoot( Current ) ) {
        Parent      = Current->_Parent;
        GrandParent = Parent->_Parent;
        if ( IsLeftChild( Current ) ) {
            if ( IsRoot( Parent ) ) {
                //
                //            P               C
                //           / \             / \
                //          C   x   ==>     y   P
                //         / \                 / \
                //        y   z               z   x
                //
                Parent->_LeftChild = Current->_RightChild;
                if ( Parent->_LeftChild != NULL ) {
                    Parent->_LeftChild->_Parent = Parent;
                }
                Current->_RightChild = Parent;
                _Root = Current;
                Current->_Parent = NULL;
                Parent->_Parent = Current;
            }
            else
            if ( IsLeftChild( Parent ) ) {
                //
                //           |                |
                //           G                C
                //          / \              / \
                //         P   z    ==>     u   P
                //        / \y                 / \
                //       C                    x   G
                //      / \                      / \
                //     u   x                    y   z
                //

                // connect Parent and x
                Parent->_LeftChild = Current->_RightChild;
                if ( Parent->_LeftChild != NULL ) {
                    Parent->_LeftChild->_Parent = Parent;
                }
                // connect GrandParent and y
                GrandParent->_LeftChild = Parent->_RightChild;
                if ( GrandParent->_LeftChild != NULL ) {
                    GrandParent->_LeftChild->_Parent = GrandParent;
                }
                // connect Current to Great GrandParent or assign as Root
                if ( IsRoot( GrandParent ) ) {
                    _Root = Current;
                    Current->_Parent = NULL;
                }
                else {
                    Current->_Parent = GrandParent->_Parent;
                    if ( IsLeftChild( GrandParent ) ) {
                        Current->_Parent->_LeftChild = Current;
                    }
                    else { // GrandParent was a RightChild
                        Current->_Parent->_RightChild = Current;
                    }
                }
                // connect Current and Parent
                Current->_RightChild = Parent;
                Parent->_Parent = Current;
                // connect Parent and GrandParent
                Parent->_RightChild = GrandParent;
                GrandParent->_Parent = Parent;
            }
            else { // else Parent is a RightChild
                //
                //         |                     |
                //         G                     C
                //        / \                  /   \
                //       u   P                G     P
                //          / \       ==>    / \   / \
                //         C    z           u   x y   z
                //        / \
                //       x   y
                //

                // connect GrandParent and x
                GrandParent->_RightChild = Current->_LeftChild;
                if ( GrandParent->_RightChild != NULL ) {
                    GrandParent->_RightChild->_Parent = GrandParent;
                }
                // connect Parent and y
                Parent->_LeftChild = Current->_RightChild;
                if ( Parent->_LeftChild != NULL ) {
                    Parent->_LeftChild->_Parent = Parent;
                }
                // connect Current and Great GrandParent or assign as Root
                if ( IsRoot( GrandParent ) ) {
                    _Root = Current;
                    Current->_Parent = NULL;
                }
                else {
                    Current->_Parent = GrandParent->_Parent;
                    if ( IsLeftChild( GrandParent ) ) {
                        Current->_Parent->_LeftChild = Current;
                    }
                    else { // GrandParent was a RightChild
                        Current->_Parent->_RightChild = Current;
                    }
                }
                // connect Current to GrandParent
                Current->_LeftChild = GrandParent;
                GrandParent->_Parent = Current;
                // connect Current to Parent
                Current->_RightChild = Parent;
                Parent->_Parent = Current;
            }
        }
        else {  // else Current is a RightChild
            if ( IsRoot( Parent ) ){
                //
                //             P                   C
                //            / \                 / \
                //           x   C      ==>      P   z
                //              / \             / \
                //             y   z           x   y
                //
                Parent->_RightChild = Current->_LeftChild;
                if ( Parent->_RightChild != NULL ) {
                    Parent->_RightChild->_Parent = Parent;
                }
                Current->_LeftChild = Parent;
                _Root = Current;
                Current->_Parent = NULL;
                Parent->_Parent = Current;
            }
            else
            if ( IsRightChild( Parent ) ) {
                //
                //            |                    |
                //            G                    C
                //           / \                  / \
                //          u   P                P   z
                //             / \     ==>      / \
                //            x   C            G   y
                //               / \          / \
                //              y   z        u   x
                //
                // connect Parent and x
                Parent->_RightChild = Current->_LeftChild;
                if ( Parent->_RightChild != NULL ) {
                    Parent->_RightChild->_Parent = Parent;
                }
                // connect GrandParent and y
                GrandParent->_RightChild = Parent->_LeftChild;
                if ( GrandParent->_RightChild != NULL ) {
                    GrandParent->_RightChild->_Parent = GrandParent;
                }
                // connect Current to Great GrandParent or assign as Root
                if ( IsRoot( GrandParent ) ) {
                    _Root = Current;
                    Current->_Parent = NULL;
                }
                else {
                    Current->_Parent = GrandParent->_Parent;
                    if ( IsLeftChild( GrandParent ) ) {
                        Current->_Parent->_LeftChild = Current;
                    }
                    else { // GrandParent was a RightChild
                        Current->_Parent->_RightChild = Current;
                    }
                }
                // connect Current and Parent
                Current->_LeftChild = Parent;
                Parent->_Parent = Current;
                // connect Parent and GrandParent
                Parent->_LeftChild = GrandParent;
                GrandParent->_Parent = Parent;
            }
            else { // else Parent is a LeftChild
                //
                //           |                      |
                //           G                      C
                //          / \                   /   \
                //         P   z                 P     G
                //        / \         ==>       / \   / \
                //       u   C                 u   x y   z
                //          / \
                //         x   y
                //
                // connect GrandParent and x
                GrandParent->_LeftChild = Current->_RightChild;
                if ( GrandParent->_LeftChild != NULL ) {
                    GrandParent->_LeftChild->_Parent = GrandParent;
                }
                // connect Parent and y
                Parent->_RightChild = Current->_LeftChild;
                if ( Parent->_RightChild != NULL ) {
                    Parent->_RightChild->_Parent = Parent;
                }
                // connect Current and Great GrandParent or assign as Root
                if ( IsRoot( GrandParent ) ) {
                    _Root = Current;
                    Current->_Parent = NULL;
                }
                else {
                    Current->_Parent = GrandParent->_Parent;
                    if ( IsLeftChild( GrandParent ) ) {
                        Current->_Parent->_LeftChild = Current;
                    }
                    else { // GrandParent was a RightChild
                        Current->_Parent->_RightChild = Current;
                    }
                }
                // connect Current to GrandParent
                Current->_RightChild = GrandParent;
                GrandParent->_Parent = Current;
                // connect Current to Parent
                Current->_LeftChild = Parent;
                Parent->_Parent = Current;
            }
        }
    }
}

template<class T>
void
SplayTree<T>::Delete(
        SplayNode<T> * node
        )
{
    SplayNode<T> *x;
    SplayNode<T> *y;

	if ( node == NULL ) {
		return;
	}
    if ( ( node->_RightChild == NULL ) ||
         ( node->_LeftChild == NULL ) )  {
             y = node;
    }
    else {
        y = Successor( node );
    }

    if ( y->_LeftChild != NULL ) {
        x = y->_LeftChild;
    }
    else {
        x = y->_RightChild;
    }

    if ( x  != NULL ) {
        x->_Parent = y->_Parent;
    }

    if ( y->_Parent == NULL ) {
        _Root = x;
    }
    else if ( IsLeftChild( y ) ) {
        y->_Parent->_LeftChild = x;
    }
    else {
        y->_Parent->_RightChild = x;
    }

    if ( y != node ) {
        node->_Data = y->_Data;
    }
    if ( y ) {
        delete y;
    }
    return;
}

//
// This function takes a pointer to two nodes. The parent node must
// be a member of the tree and must NOT have a right child. The child
// node must NOT be a current member of the tree, and must NOT
// already have a parent
//
template<class T>
SplayNode<T>*
SplayTree<T>::InsertAsRightChild(
        SplayNode<T> *Parent,
        SplayNode<T> *Child
        )
{
	if ( ( Parent == NULL ) || ( Child == NULL ) ) {
		return NULL;
	}
    if ( Parent->_RightChild == NULL ) {
        Parent->_RightChild = Child;
        Child->_Parent      = Parent;
        return Child;
    }
    return NULL;
}

//
// This function takes a pointer to two nodes. The parent node must
// be a member of the tree and must NOT have a left child. The child
// node must NOT be a current member of the tree, and must NOT
// already have a parent
//
template<class T>
SplayNode<T>*
SplayTree<T>::InsertAsLeftChild(
        SplayNode<T> *Parent,
        SplayNode<T> *Child
        )
{
    if ( ( Parent == NULL ) || ( Child == NULL ) ) {
		return NULL;
	}
	if ( Parent->_LeftChild == NULL ) {
        Parent->_LeftChild = Child;
        Child->_Parent     = Parent;
        return Child;
    }
    return NULL;
}

//
// The Successor takes an input to a node in the tree
// and returns a pointer to the successor of that
// node in the entire tree. If there is no successor
// a NULL value is returned.
//
template<class T>
SplayNode<T>*
SplayTree<T>::Successor(
        SplayNode<T> *Node
        )
{
    if ( Node == NULL ) {
		return NULL;
	}

    // if a success exists in a subtree ...
    SplayNode<T> *Temp = SubtreeSuccessor( Node );

    if ( Temp ) {
        return Temp;
    }
    // else there is no right child, so find the first
    // ancestor that we are the left decendent of.
    Temp = Node;
    while (IsRightChild( Temp ) ) {
        Temp = Temp->_Parent;
    }
    if ( IsLeftChild( Temp ) ) {
        return Temp->_Parent;
    }
    return NULL;
}

//
// The Predecessor takes an input to a node in the tree
// and returns a pointer  to the predecessor of that
// node in the entire tree. If there is no predecessor,
// a NULL value is returned.
//
template<class T>
SplayNode<T>*
SplayTree<T>::Predecessor(
        SplayNode<T> *Node
        )
{
	if ( Node == NULL ) {
		return NULL;
	}
    // if a predecessor exists in the subtree
    SplayNode<T> *Temp = SubtreePredecessor( Node );

    if ( Temp ) {
        return Temp;
    }
    // else there is no left child, so find the first
    // ancestor that we are the right decendent of
    Temp = Node;
    while ( IsLeftChild( Temp ) ) {
        Temp = Temp->_Parent;
    }
    if ( IsRightChild( Temp ) ) {
        return Temp->_Parent;
    }
    return NULL;
}

//
// The SubtreePredecessor takes an input to a node in the tree
// and returns a pointer to the predecessor of a subtree
// rooted at the input node. If there is no predecessor, a
// NULL value is returned.
//
template<class T>
SplayNode<T>*
SplayTree<T>::SubtreePredecessor(
        SplayNode<T> *Node
        )
{
    if ( Node == NULL ) {
        return NULL;
    }

    // the predecessor is the right-most node in the left sub-tree
    SplayNode<T> *Temp = Node->_LeftChild;

    if ( Temp != NULL ) {
        while ( Temp->_RightChild != NULL ) {
            Temp = Temp->_RightChild;
        }
        return Temp;
    }
    return NULL;
}

//
// The SubtreeSuccessor takes an input to a node in the tree
// and returns a pointer to the successor of a subtree
// rooted at the input node. If there is no successor, a
// NULL value is returned.
//
template<class T>
SplayNode<T>*
SplayTree<T>::SubtreeSuccessor(
        SplayNode<T> *Node
        )
{
    if ( Node == NULL ) {
        return NULL;
    }

    // the successor is the left-most node in the right sub tree
    SplayNode<T> *Temp = Node->_RightChild;

    if ( Temp != NULL ) {
        while ( Temp->_LeftChild != NULL ) {
            Temp = Temp->_LeftChild;
        }
        return Temp;
    }
    return NULL;
}

template<class T>
void
SplayTree<T>::Insert(
        T *NewData
        )
{
    SplayNode<T> *Temp     = NULL;
    SplayNode<T> *TempRoot = _Root;
    SplayNode<T> *NewNode  = NULL;

    while ( TempRoot != NULL ) {
        Temp = TempRoot;
		ASSERT( *( NewData ) != *( TempRoot->_Data ) );
		//if ( *( NewData ) == *( TempRoot->_Data ) ) {
		//	return;
		//}
        if ( *( NewData ) < *( TempRoot->_Data ) ) {
            TempRoot = TempRoot->_LeftChild;
        }
        //else {
        else if ( *( NewData ) > *( TempRoot->_Data ) ) {
            TempRoot = TempRoot->_RightChild;
        }
        else return; // *NewData == *TempRoot->_Data
    }
    if ( Temp == NULL ) {
        _Root = new SplayNode<T>( NewData );
    }
    else
    if ( *( NewData ) < *( Temp->_Data ) ) {
        NewNode = InsertAsLeftChild( Temp, new SplayNode<T>( NewData ) );
		Splay( NewNode );
    }
    else {
        NewNode = InsertAsRightChild( Temp, new SplayNode<T>( NewData ) );
		Splay( NewNode );
    }
    _Size++;
    return;
}

//
// Given an element, find the element in the tree
// (if it exists) and return a pointer to the element.
// If the element is not found, then the return
// value is NULL.
//
template<class T>
T*
SplayTree<T>::Find(
        T *FindData
        )
{
	if ( FindData == NULL ) {
		return NULL;
	}
    SplayNode<T> *DataNode = Find( _Root, FindData );
    if ( DataNode == NULL ) {
        return NULL;
    }
    Splay( DataNode );
    return ( DataNode->_Data );
}

//
// Given a pointer to a node (which is the root of a
// subtree) and a pointer to an element, determine
// if the element exists in the tree.
// If the element exist, return a pointer to the node
// containing such an element, or return a NULL.
//
template<class T>
SplayNode<T>*
SplayTree<T>::Find(
        SplayNode<T> *SubRoot,
        T *FindData
        )
{
    //if ( ( SubRoot == NULL ) ||
    //     ( *( FindData ) == *( SubRoot->_Data ) ) ) {
    //         return SubRoot;
    //}
    if ( !SubRoot ) {
        return SubRoot;
    }
    if ( *( FindData ) < *( SubRoot->_Data ) ) {
        return Find( SubRoot->_LeftChild, FindData );
    }
    else if ( *( FindData ) > * ( SubRoot->_Data ) ) {
        return Find( SubRoot->_RightChild, FindData );
    }
    else return SubRoot; // *FindData == *SubRoot->_Data
}

//
// Given an element, find the element in the tree
// (if it exists) and delete the element from the
// tree. The function returns a pointer to the
// element. If the element is not found, then
// the return value is NULL.
//
template<class T>
T*
SplayTree<T>::Delete(
        T *DeleteData
        )
{
    SplayNode<T> *DeleteNode = Find( _Root, DeleteData );
	// must copy the data out of the node, since a Delete( ..)
	// is allowed to change the data within the node
	T *Data = DeleteNode->_Data;
    if ( DeleteNode ) {
        Delete( DeleteNode );
        _Size--;
        return Data;
    }
    return NULL;
}

//
// Find the node in the tree with the smallest value,
// and return a pointer to such a node.
// If there are no nodes in the tree, return a NULL.
//
template<class T>
SplayNode<T>*
SplayTree<T>::MinimumNode( )
{
    SplayNode<T> *SubRoot = _Root;

    if ( _Root == NULL ) {
        return NULL;
    }

    while ( SubRoot->_LeftChild != NULL ) {
        SubRoot = SubRoot->_LeftChild;
    }
    return SubRoot;
}

//
// Find the node in the tree with the largest value.
// and return a pointer to such a node.
// If there are no nodes in the tree, return a NULL.
//
template<class T>
SplayNode<T>*
SplayTree<T>::MaximumNode( )
{
    SplayNode<T> *SubRoot = _Root;

    if ( _Root == NULL ) {
        return NULL;
    }

    while ( SubRoot->_RightChild != NULL ) {
        SubRoot = SubRoot->_RightChild;
    }
    return SubRoot;
}

template<class T>
T*
SplayTree<T>::Successor( T *Data )
{
    SplayNode<T> *DataNode;
    SplayNode<T> *SuccNode;

    if ( Data ) {
        DataNode = Find( _Root, Data );
        if ( DataNode ) {
            SuccNode = Successor( DataNode );
            if ( SuccNode ) {
                Splay( SuccNode );
                return SuccNode->_Data;
            }
        }
    }
    return NULL;
}

template<class T>
T*
SplayTree<T>::Predecessor( T *Data )
{
    SplayNode<T> *DataNode;
    SplayNode<T> *PredNode;

    if ( Data ) {
        DataNode = Find( _Root, Data );
        if ( DataNode ) {
            PredNode = Predecessor( DataNode );
            if ( PredNode ) {
                Splay( PredNode );
                return PredNode->_Data;
            }
        }
    }
    return NULL;
}

#ifdef DEBUGRPC

template<class T>
void
SplayTree<T>::Print()
{
    if ( _Root == NULL ) {
        return;
    }
    Print( _Root );
}

template<class T>
void
SplayTree<T>::Print( SplayNode<T> *TempRoot )
{
    if ( TempRoot == NULL ) {
        return;
    }

    Print( TempRoot->_LeftChild );

    if ( IsLeftChild( TempRoot ) ) {
        if ( *( TempRoot->_Parent->_Data ) < *( TempRoot->_Data ) ) {
                cout << "Bastard tree! ";
            }
            else cout << "OK ";
    }
    else
    if ( IsRightChild( TempRoot ) ) {
            if ( *( TempRoot->_Parent->_Data ) > *( TempRoot->_Data ) ) {
                cout << "Bastard tree! ";
            }
            else cout << "OK ";
    }
    cout << *( TempRoot->_Data ) << " \n";

    Print( TempRoot->_RightChild );
    return;
}

template<class T>
unsigned int
SplayTree<T>::Depth( SplayNode<T> *TempRoot, unsigned int CurrentDepth )
{
    unsigned int right = 0;
    unsigned int left  = 0;
    if ( TempRoot->_RightChild ) {
        right = Depth( TempRoot->_RightChild, CurrentDepth + 1 );
    }
    if ( TempRoot->_LeftChild ) {
        left  = Depth( TempRoot->_LeftChild, CurrentDepth + 1 );
    }
    if ( ( right > left ) && ( right > CurrentDepth ) ) {
        return right;
    }
    else
    if ( (left > right ) && ( left > CurrentDepth ) ) {
        return left;
    }
    return ( CurrentDepth + 1 );
}

#endif // DEBUGRPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\workset\client\client.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    client.c

Abstract:

    Client side of RPC development performance tests.  This test is used
    to measure working set.

Author:

    Mario Goertzel (mariogo)   29-Mar-1994

Revision History:

--*/

#include<rpcperf.h>  // Common Performance functions.

#include<rpcws.h>    // MIDL generated from RPC working set interface.

const char *USAGE = 0;

int __cdecl main(int argc, char **argv)
{
    RPC_STATUS status;
    handle_t binding;
    char *stringBinding;

    //
    // Common layer sets variables defined in rpcperf.h
    //

    ParseArgv(argc, argv);


    PauseForUser("Started, ready to bind and make first RPC\n");

    status =
    RpcStringBindingCompose(0,
                            Protseq,
                            NetworkAddr,
                            Endpoint,
                            0,
                            &stringBinding );
    CHECK_STATUS(status, "RpcStringBindingCompose");

    status =
    RpcBindingFromStringBinding(stringBinding, &binding);
    CHECK_STATUS(status, "RpcBindingFromStringBinding");

    //
    // Client Case 1: measure working set (w/o memory preasure)
    //                of a minimal client starting and binding to a server.

    Call(binding);

    PauseForUser("Client has made its first call\n");

    //
    // Client Case 2: flush client memory and make another call.
    //

    FlushProcessWorkingSet();

    Call(binding);

    PauseForUser("Client has flushed and made another call\n");

    Flush(binding);
    Call(binding);

    PauseForUser("Client has flushed the server and made another call\n");

    Shutdown(binding);
    RpcBindingFree(&binding);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\charconv\convbvt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       convbvt.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>
#include "CharConv.hxx"

int main()
{
	WCHAR wt1[] = L"Hello world!";
	WCHAR we[] = L"";
	char at1[] = "Hello world!";
	char ae[] = "";
	char abuf[100];
	WCHAR wbuf[100];
	CHeapUnicode hu;
	CHeapAnsi ha;
	CNlUnicode nu;
	CNlAnsi na;
	CStackUnicode su;
	CStackAnsi sa;
	USES_CONVERSION;

	// test heap conversions
	ATTEMPT_HEAP_W2A(ha, wt1);
	ASSERT(lstrcmpA(ha, at1) == 0);
	ATTEMPT_HEAP_A2W(hu, at1);
	ASSERT(lstrcmpW(hu, wt1) == 0);

	// test Nl conversions
	ATTEMPT_NL_W2A(na, wt1);
	ASSERT(lstrcmpA(na, at1) == 0);
	ATTEMPT_NL_A2W(nu, at1);
	ASSERT(lstrcmpW(nu, wt1) == 0);

	// test stack conversions
	ATTEMPT_STACK_W2A(sa, wt1);
	ASSERT(lstrcmpA(sa, at1) == 0);
	ATTEMPT_STACK_A2W(su, at1);
	ASSERT(lstrcmpW(su, wt1) == 0);
	
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\charconv\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=CharConv
TARGETTYPE=LIBRARY
TARGETPATH=obj

INCLUDES=..;$(BASEDIR)\private\inc;..\..\mtrt

#
# Setup for application developer to set breakpoints with windbg
#

MSC_WARNING_LEVEL=/W3 /WX

#NTDEBUG=ntsd
#NTDEBUGTYPE=windbg
#MSC_OPTIMIZATION=/Od

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES=             \
        ..\CharConv.cxx

RPCENV= $(RPCENV) -DNTENV -DWIN32RPC -DNTWIN32RPC -D_RPCRT4_

C_DEFINES=$(RPCENV) $(RPCTARGETENV) /DMSWMSG -D_RPCRT4_

# Used only for unit tests
USE_MSVCRT=1

UMTEST=ConvBVT
UMTYPE=console
UMLIBS= \
    $(SDK_LIB_PATH)\ntdll.lib \
    $(SDK_LIB_PATH)\kernel32.lib \
    $(SDK_LIB_PATH)\advapi32.lib \
    $(O)\charconv.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\charconv\charconv.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       charconv.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>
#include "Charconv.hxx"

RPC_STATUS A2WAttachHelper(char *pszAnsi, WCHAR **ppUnicode)
{
	int nAnsiLength;
	ASSERT(pszAnsi != NULL);
	nAnsiLength = lstrlenA(pszAnsi) + 1;

	*ppUnicode = new WCHAR[nAnsiLength];
	if (*ppUnicode == NULL)
		return(RPC_S_OUT_OF_MEMORY);
	RtlMultiByteToUnicodeN(*ppUnicode, nAnsiLength * 2, NULL, pszAnsi, nAnsiLength);

	return(RPC_S_OK);
}

RPC_STATUS W2AAttachHelper(WCHAR *pUnicode, char **ppAnsi)
{
    int nUnicodeLength;
    ASSERT(pUnicode != NULL);

    NTSTATUS status;
    status = RtlUnicodeToMultiByteSize((unsigned long *)&nUnicodeLength, 
        pUnicode, lstrlenW(pUnicode) * 2);
    if (status)
        return RPC_S_INVALID_ARG;
    nUnicodeLength ++;

    *ppAnsi = new char[nUnicodeLength];
    if (*ppAnsi == NULL)
        return(RPC_S_OUT_OF_MEMORY);
    RtlUnicodeToMultiByteN(*ppAnsi, nUnicodeLength, NULL, pUnicode, nUnicodeLength * 2);

    return(RPC_S_OK);
}

RPC_STATUS CHeapUnicode::Attach(char *pszAnsi)
{
    ANSI_STRING AnsiString;
    NTSTATUS NtStatus;

    RtlInitAnsiString(&AnsiString, (PSZ)pszAnsi);
    NtStatus = RtlAnsiStringToUnicodeString(&m_UnicodeString, &AnsiString, TRUE);
    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}

RPC_STATUS CHeapAnsi::Attach(WCHAR *pszUnicode)
{
    UNICODE_STRING UnicodeString;
    NTSTATUS NtStatus;

    RtlInitUnicodeString(&UnicodeString, pszUnicode);
    NtStatus = RtlUnicodeStringToAnsiString(&m_AnsiString, &UnicodeString, TRUE);
    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\rpccfg\rpccfg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rpccfg.cxx
//
//--------------------------------------------------------------------------

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include<stdio.h>
#include<string.h>
#include<memory.h>
#include<malloc.h>
#include<stdlib.h>
#include <windows.h>
#include <winsock2.h>
extern "C" {
#include <iphlpapi.h>
};

void
ListInterfaces()
{
    PMIB_IFTABLE pMib;
    DWORD Size = 20*sizeof(MIB_IFROW)+sizeof(DWORD);
    unsigned int i;
    DWORD Status;

    for (i = 0; i < 2; i++)
        {
        pMib = (PMIB_IFTABLE) malloc(Size);
        if (pMib == 0)
            {
            return;
            }

        memset(pMib, 0, Size);

        Status = GetIfTable(pMib, &Size, 0);
        if (Status == 0)
            {
            break;
            }

        free(pMib);
        }

    if (Status != 0)
        {
        return;
        }

    for (i = 0; i < pMib->dwNumEntries; i++)
        {
        printf("IF[%d]: Ethernet: %s\n", ((pMib->table[i].dwIndex) & 0x00FFFFFF),
                 (char *) pMib->table[i].bDescr);
        }
}

#define RPC_NIC_INDEXES "System\\CurrentControlSet\\Services\\Rpc\\Linkage"
#define RPC_PORT_SETTINGS "Software\\Microsoft\\Rpc\\Internet"

DWORD
NextIndex(
    char **Ptr
    )
{
    char *Index = *Ptr ;
    if (*Index == 0)
        {
        return -1;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    return (DWORD) atoi(Index) ;
}


BOOL
GetCardIndexTable (
    DWORD **IndexTable,
    DWORD *NumIndexes
    )
{
    HKEY hKey;
    DWORD Size ;
    DWORD Type;
    char *Buffer;
    DWORD Status;

    Status =
    RegOpenKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_NIC_INDEXES,
                  0,
                  KEY_READ,
                  &hKey);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        *IndexTable = NULL;
        return TRUE;
        }

    if (Status != ERROR_SUCCESS)
        {
        return FALSE;
        }

    Size = 512 ;
    Buffer = (char *) malloc(Size) ;
    if (Buffer == 0)
        {
        return FALSE;
        }

    while(TRUE)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "Bind",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        if (Status == ERROR_SUCCESS)
            {
            break;
            }

        if (Status == ERROR_MORE_DATA)
            {
            free(Buffer) ;
            Buffer = (char *) malloc(Size) ;
            if (Buffer == 0)
                {
                RegCloseKey(hKey);
                return FALSE ;
                }
            continue;
            }

        if (Status == ERROR_FILE_NOT_FOUND)
            {
            free(Buffer) ;
            *IndexTable = NULL;
            RegCloseKey(hKey);
            return TRUE;
            }

        free(Buffer) ;
        RegCloseKey(hKey);
        return FALSE;
        }

    if (*Buffer == 0)
        {
        RegCloseKey(hKey);
        return FALSE;
        }

    //
    // we know this much will be enough
    //
    *IndexTable = (DWORD *) malloc(Size * sizeof(DWORD));
    if (*IndexTable == 0)
        {
        RegCloseKey(hKey);
        return FALSE;
        }

    *NumIndexes = 0;
    int Index;
    while ((Index = NextIndex(&Buffer)) != -1)
        {
        (*IndexTable)[*NumIndexes] = Index;
        (*NumIndexes)++;
        }

    RegCloseKey(hKey);
    return TRUE;
}

void ResetState (
    )
{
    DWORD Status;
    HKEY hKey;

    //
    // Reset interface state to default
    //
    Status =
    RegOpenKeyExA(
                  HKEY_LOCAL_MACHINE,
                  "System\\CurrentControlSet\\Services\\Rpc",
                  0,
                  KEY_ALL_ACCESS,
                  &hKey);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        printf("RPCCFG: State reset to default\n");
        return;
        }

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    Status = RegDeleteKeyA(hKey, "Linkage");
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        RegCloseKey(hKey);
        return;
        }

    RegCloseKey(hKey);


    //
    // Reset Port state to default
    //
    Status =
    RegOpenKeyExA(
              HKEY_LOCAL_MACHINE,
              "Software\\Microsoft\\Rpc",
              0,
              KEY_ALL_ACCESS,
              &hKey);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        printf("RPCCFG: State reset to default\n");
        return;
        }

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    Status = RegDeleteKeyA(hKey, "Internet");
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        RegCloseKey(hKey);
        return;
        }

    RegCloseKey(hKey);

    printf("RPCCFG: State reset to default\n");
}


void
ListCurrentInterfaces(
    )
{
    DWORD *IndexTable;
    DWORD NumIndexes;
    DWORD Status;
    unsigned int i;

    if (GetCardIndexTable(&IndexTable, &NumIndexes) == FALSE)
        {
        printf("RPCCFG: Could not list the Interfaces\n");
        ResetState();
        return;
        }

    if (IndexTable == 0)
        {
        printf("RPCCFG: Listening on all interfaces (default configuration)\n");
        return;
        }

    printf("RPCCFG: Listening on the following interfaces\n");
    for (i = 0; i < NumIndexes; i++)
        {
        MIB_IFROW IfEntry;

        memset(&IfEntry, 0, sizeof(MIB_IFROW));

        //
        // Set the index in the row
        //

        IfEntry.dwIndex = IndexTable[i];

        Status = GetIfEntry(&IfEntry);

        if (Status != 0)
            {
            printf("RPCCFG: Could not list the Interfaces\n");
            break;
            }
        printf("IF[%d]: Ethernet: %s\n", IndexTable[i], (char *) IfEntry.bDescr);
        }
}

void
ListenOnInterfaces (
    USHORT *IfIndices,
    USHORT Count
    )
{
    int i;
    HKEY hKey;
    DWORD Status;
    DWORD disposition;

    Status =
    RegCreateKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_NIC_INDEXES,
                  0,
                  "",
                  REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hKey,
                  &disposition);
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    int cbIndices = 0;

    char *lpIndices = (char *) malloc(17*Count+1);
    if (lpIndices == 0)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    char *current = lpIndices;

    for (i = 0; i < Count; i++)
        {
        sprintf(current, "%d", IfIndices[i]);

        int length = strlen(current)+1;

        current += length;
        cbIndices += length;
        }

    *current = 0;
    cbIndices++;

    Status = RegSetValueExA(hKey,
                            "Bind",
                            0,
                            REG_MULTI_SZ,
                            (unsigned char *) lpIndices,
                            cbIndices);
    free(lpIndices);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }
}

char *
NextPortRange(
    char **Ptr
    )
{
    char *Port = *Ptr ;
    if (*Port == 0)
        {
        return 0;
        }

    while (**Ptr) (*Ptr)++ ;
    (*Ptr)++ ;

    return Port ;
}

void
ListCurrentPortSettings (
    )
{
    HKEY hKey;
    DWORD Size ;
    DWORD Type;
    char *Buffer;
    DWORD Status;

    Status =
    RegOpenKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_PORT_SETTINGS,
                  0,
                  KEY_READ,
                  &hKey);

    if (Status == ERROR_FILE_NOT_FOUND)
        {
        printf("RPCCFG: Using default port settings\n", Status);
        return;
        }

    if (Status != ERROR_SUCCESS)
        {
        return;
        }

    Size = 2048;
    Buffer = (char *) malloc(Size) ;
    if (Buffer == 0)
        {
        RegCloseKey(hKey);
        return;
        }

    while(TRUE)
        {
        Status =
        RegQueryValueExA(
            hKey,
            "Ports",
            0,
            &Type,
            (unsigned char *) Buffer,
            &Size);

        if (Status == ERROR_SUCCESS)
            {
            break;
            }

        if (Status == ERROR_MORE_DATA)
            {
            free(Buffer) ;
            Buffer = (char *) malloc(Size) ;
            if (Buffer == 0)
                {
                RegCloseKey(hKey);
                printf("RPCCFG: Could not perform operation, out of memory\n");
                return;
                }
            continue;
            }

        if (Status == ERROR_FILE_NOT_FOUND)
            {
            free(Buffer) ;
            printf("RPCCFG: Using default port settings\n", Status);
            RegCloseKey(hKey);
            return;
            }

        printf("RPCCFG: Could not perform operation\n");
        free(Buffer) ;
        RegCloseKey(hKey);
        return;
        }

    if (*Buffer == 0)
        {
        printf("RPCCFG: Bad settings\n");
        RegCloseKey(hKey);

        ResetState();
        return;
        }

    char *PortRange;
    char Flags[32];

    Size = 32;

    Status =
    RegQueryValueExA(
        hKey,
        "PortsInternetAvailable",
        0,
        &Type,
        (unsigned char *) Flags,
        &Size);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        RegCloseKey(hKey);
        return;
        }

    printf("The following ports/port ranges will be used for ");

    if (Flags[0] == 'Y')
        {
        printf("Internet ports\n");
        }
    else
        {
        printf("Intranet ports\n");
        }

    while ((PortRange = NextPortRange(&Buffer)) != 0)
        {
        printf("\t%s\n", PortRange);
        }

    Size = 32;

    Status =
    RegQueryValueExA(
        hKey,
        "UseInternetPorts",
        0,
        &Type,
        (unsigned char *) Flags,
        &Size);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        RegCloseKey(hKey);
        return;
        }

    printf("\nDefault port allocation is from ");
    if (Flags[0] == 'Y')
        {
        printf("Internet ports\n");
        }
    else
        {
        printf("Intranet ports\n");
        }

    RegCloseKey(hKey);
}

void
SetPortRange(
    char **PortRangeTable,
    int NumEntries,
    char *InternetAvailable
    )
{
    int i;
    DWORD Status;
    DWORD disposition;
    HKEY hKey;

    Status =
    RegCreateKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_PORT_SETTINGS,
                  0,
                  "",
                  REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hKey,
                  &disposition);
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    int cbPorts = 0;

    char *lpPorts = (char *) malloc(257*NumEntries+1);
    if (lpPorts == 0)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    char *current = lpPorts;

    for (i = 0; i < NumEntries; i++)
        {
        strcpy(current, PortRangeTable[i]);

        int length = strlen(current)+1;

        current += length;
        cbPorts += length;
        }

    *current = 0;
    cbPorts++;

    Status = RegSetValueExA(hKey,
                            "Ports",
                            0,
                            REG_MULTI_SZ,
                            (unsigned char *) lpPorts,
                            cbPorts);
    free(lpPorts);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    Status = RegSetValueExA(hKey,
                        "PortsInternetAvailable",
                        0,
                        REG_SZ,
                        (unsigned char *) InternetAvailable,
                        strlen(InternetAvailable)+1);
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }
}

void
SetDefaultPortSetting (
    char *PortSetting
    )
{
    int i;
    HKEY hKey;
    DWORD Status;
    DWORD disposition;

    Status =
    RegCreateKeyExA(
                  HKEY_LOCAL_MACHINE,
                  RPC_PORT_SETTINGS,
                  0,
                  "",
                  REG_OPTION_NON_VOLATILE,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hKey,
                  &disposition);
    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    if (PortSetting[0] == '0')
        {
        PortSetting = "Y";
        }
    else
        {
        PortSetting = "N";
        }

    Status = RegSetValueExA(hKey,
                            "UseInternetPorts",
                            0,
                            REG_SZ,
                            (unsigned char *) PortSetting,
                            strlen(PortSetting)+1);

    if (Status != ERROR_SUCCESS)
        {
        printf("RPCCFG: Could not perform operation (%d)\n", Status);
        return;
        }

    RegCloseKey(hKey);
}

void
Help (
    )
{
    printf("usage: RPCCFG [-l] [-a ifindex1 [ifindex2 ...]] [-r] [-q] [-d 0|1] \n");
    printf("              [-pi port|port-range ...] [-pe port|port-range ...] \n");
    printf("\t-?: This help message\n");
    printf("\t-l: List all the interfaces\n");
    printf("\t-q: List the interface indices on which we are currently listening\n");
    printf("\t    and our port usage settings\n");
    printf("\t-r: Reset the interface and port settings to default\n");
    printf("\t-a: Listen on the listed interface indices (eg: -a 1 3 5)\n");
    printf("\t    this will cause RPC servers to listen on the listed interfaces\n");
    printf("\t    by default. The interfaces listed are typically inside the firewall\n");
    printf("\t-pi:Specify the intranet available ports, the ports may be single\n");
    printf("\t    values or ranges (eg: -pi 555 600-700 900), this option may not be\n");
    printf("\t    used with the -pe option\n");
    printf("\t-pe:Specify the internet available ports, the ports may be single\n");
    printf("\t    values or ranges this option may not be used with the -pi option\n");
    printf("\t-d: Specify the default port usage\n");
    printf("\t    0: Use internet available ports by default\n");
    printf("\t    1: Use intranet available ports by default\n");
}

void
__cdecl main (int argc, char *argv[])
{
    int argscan;
    USHORT IfIndices[512];
    char *PortRangeTable[512];
    int i;
    BOOL fPortChanged = 0;
    BOOL fInterfaceChanged = 0;

    if (argc == 1)
        {
        Help();
        }

    for (argscan = 1; argscan < argc;argscan++)
        {
        if (strcmp(argv[argscan], "-l") == 0)
            {
            ListInterfaces();
            }
        else if (strcmp(argv[argscan], "-?") == 0)
            {
            Help();
            }
        else if (strcmp(argv[argscan], "-r") == 0)
            {
            fPortChanged = 1;
            fInterfaceChanged = 1;

            ResetState();
            }
        else if (strcmp(argv[argscan], "-q") == 0)
            {
            ListCurrentInterfaces();
            printf("\n");
            ListCurrentPortSettings();
            }
        else if (strcmp(argv[argscan], "-a") == 0)
            {
            int count = 0;

            for (i = 0; i < 512; i++)
                {
                argscan++;
                if (argscan == argc)
                    {
                    break;
                    }

                if (argv[argscan][0] == '-')
                    {
                    argscan--;
                    break;
                    }

                count++;

                IfIndices[i] = (USHORT)atoi(argv[argscan]);
                if (IfIndices[i] == 0)
                    {
                    printf("RPCCFG: Bad interface index\n");
                    return;
                    }
                }

            if (i == 512)
                {
                printf("RPCCFG: Too many interfaces\n");
                return;
                }

            if (count)
                {
                ListenOnInterfaces(IfIndices, (USHORT)count);
                fInterfaceChanged = 1;
                }
            }
        else if (strncmp(argv[argscan], "-p", 2) == 0)
            {
            int count = 0;
            char *option = argv[argscan];

            for (i = 0; i < 512; i++)
                {
                argscan++;
                if (argscan == argc)
                    {
                    break;
                    }

                if (argv[argscan][0] == '-')
                    {
                    argscan--;
                    break;
                    }

                count++;
                PortRangeTable[i] = argv[argscan];
                }

            if (i == 512)
                {
                printf("RPCCFG: Too many ports\n");
                return;
                }

            if (strcmp(option, "-pi") == 0)
                {
                SetPortRange(PortRangeTable, count, "N");
                }
            else
                {
                SetPortRange(PortRangeTable, count, "Y");
                }
            fPortChanged = 1;
            }
        else if (strcmp(argv[argscan], "-d") == 0)
            {
            argscan++;
            if (argscan == argc)
                {
                break;
                }
            SetDefaultPortSetting(argv[argscan]);
            fPortChanged = 1;
            }
        }

    if (fInterfaceChanged)
        {
        ListCurrentInterfaces();
        printf("\n");
        }

    if (fPortChanged)
        {
        ListCurrentPortSettings();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\perf\workset\server\server.c ===
/*++

Copyright (C) Microsoft Corporation, 1994 - 1999

Module Name:

    server.c

Abstract:

    Server side of RPC development performance tests.  This test is used
    to measure working set.

Author:

    Mario Goertzel (mariogo)   29-Mar-1994

Revision History:

--*/

#include<rpcperf.h>  // Common Performance functions.

#include<rpcws.h>    // MIDL generated from RPC working set interface.

const char *USAGE = 0;

int __cdecl main(int argc, char **argv)
{
    RPC_STATUS status;
    handle_t binding;
    char *stringBinding;
    RPC_BINDING_VECTOR *pBindingVector;

    //
    // Common layer sets variables defined in rpcperf.h
    //

    ParseArgv(argc, argv);


    PauseForUser("Started, about to start listening\n");

    if (Endpoint)
        {
        status = RpcServerUseProtseqEp(Protseq, 100, Endpoint, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");
        }
    else
        {
        status = RpcServerUseProtseq(Protseq, 100, 0);
        CHECK_STATUS(status, "RpcServerUseProtseqEp");

        status = RpcServerInqBindings(&pBindingVector);
        CHECK_STATUS(status, "RpcServerInqBindings");

        status = RpcEpRegister(rpcws_v1_0_s_ifspec,
                               pBindingVector,
                               0,
                               0);
        CHECK_STATUS(status, "RpcEpRegister");        
        }

    status =
    RpcServerRegisterIf(rpcws_v1_0_s_ifspec,0,0);
    CHECK_STATUS(status, "RpcServerRegisterIf");
                               

    printf("Server listening\n");
    status = RpcServerListen(MinThreads, 100, 0);
    CHECK_STATUS(status, "RpcServerListen");

    return 0;
}


void Flush(handle_t h)
{
    printf("Client flushed working set\n");
    FlushProcessWorkingSet();
}

void Shutdown(handle_t h)
{
    RPC_STATUS status =
    RpcMgmtStopServerListening(0);
    CHECK_STATUS(status, "RpcMgmtStopServerListening");
}

void Call(handle_t h)
{
    printf("Called\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbgcmd\dbgrpc.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    RpcDbg.cxx

Abstract:

    RPC Extended Debugging Utility

Author:

    Kamen Moutafov (kamenm)   11-30-99

Revision History:

--*/

#include <sysinc.h>

#include <CellDef.hxx>

// Usage

const char *USAGE = "-s <server> -p <protseq> -C <CallID> -I <IfStart>\n"
                    "-N <ProcNum> -P <ProcessID> -L <CellID1.CellID2>\n"
                    "-E <EndpointName> -T <ThreadID> -r <radix> -c -l -e -t -a\n"
                    "Exactly one of -c, -l, -e, -t, or -a have to be specified.\n"
                    "The valid combinations are:\n"
                    "-c [-C <CallID>] [-I <IfStart>] [-N <ProcNum>] [-P <ProcessID>]\n"
                    "-l -P <ProcessID> -L <CellID1.CellID2>\n"
                    "-e -E <EndpointName>\n"
                    "-t -P <ProcessID> [-T <ThreadID>]\n"
                    "-a [-C <CallID>] [-I <IfStart>] [-N <ProcNum>] [-P <ProcessID>]\n"
                    "-s, -p and -r are independent to the other options. -r affects"
                    "only options after it on the command line. Default is 16 (hex)";


// Error stuff

#define CHECK_RET(status, string) if (status)\
        {  printf("%s failed -- %lu (0x%08X)\n", string,\
                      (unsigned long)status, (unsigned long)status);\
        return (status); }

DWORD CallID = 0;
DWORD IfStart = 0;
DWORD ProcNum = RPCDBG_NO_PROCNUM_SPECIFIED;
DWORD ProcessID = 0;
DebugCellID CellID = {0, 0};
char *EndpointName = NULL;
DWORD ThreadID = 0;
char *Protseq = "ncacn_np";
char *NetworkAddr = NULL;
int radix = 16;
char *BindingEndpoint = 0;

enum tagChosenDebugAction
{
    cdaInvalid,
    cdaCallInfo,
    cdaDebugCellInfo,
    cdaEndpointInfo,
    cdaThreadInfo,
    cdaClientCallInfo
} ChosenDebugAction;

int Action = cdaInvalid;

BOOL CheckForCellID(void)
{
    if ((CellID.SectionID != 0) || (CellID.CellID != 0))
        {
        printf("A cell ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForEndpointName(void)
{
    if (EndpointName)
        {
        printf("An endpoint name cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForThreadID(void)
{
    if (ThreadID)
        {
        printf("A thread ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForCallID(void)
{
    if (CallID)
        {
        printf("A call ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForIfStart(void)
{
    if (IfStart)
        {
        printf("An interface UUID start cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForProcNum(void)
{
    if (ProcNum != RPCDBG_NO_PROCNUM_SPECIFIED)
        {
        printf("A procedure number cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

BOOL CheckForProcessID(void)
{
    if (ProcessID)
        {
        printf("A process ID cannot be specified for this action\n");
        return TRUE;
        }
    else
        return FALSE;
}

void __cdecl DumpToConsole(PCSTR lpFormat, ...)
{
    va_list arglist;

    va_start(arglist, lpFormat);
    vfprintf(stdout, lpFormat, arglist);
    va_end(arglist);
}


void __RPC_FAR * __RPC_API MIDL_user_allocate(size_t  Size)
{
    void PAPI * pvBuf;

    pvBuf = new char [Size];

    return(pvBuf);
}

void __RPC_API MIDL_user_free (void __RPC_FAR *Buf)
{
    delete (Buf);
}

const char *ValidProtocolSequences[] = {"ncacn_np", "ncacn_ip_tcp"};
const char *ValidEnpoints[] = {"epmapper", "135"};

#define ARRAY_SIZE_OF(a)    (sizeof(a) / sizeof(a[0]))

void ParseArgv(int argc, char **argv)
{
    int fMissingParm = 0;
    char *Name = *argv;
    char option;
    char *TempString;
    char *Delimiter;
    char *Ignored;
    BOOL fInvalidArg;
    int i;

    argc--;
    argv++;
    while(argc)
        {
        if (**argv != '/' &&
            **argv != '-')
            {
            printf("Invalid switch: %s\n", *argv);
            argc--;
            argv++;
            }
        else
            {
            option = argv[0][1];
            argc--;
            argv++;

            // Most switches require a second command line arg.
            if (argc < 1)
                fMissingParm = 1;

            switch(option)
                {
                case 'C':
                    CallID = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'p':
                    Protseq = *argv;
                    for (i = 0; i < ARRAY_SIZE_OF(ValidProtocolSequences); i ++)
                        {
                        if (_strcmpi(Protseq, ValidProtocolSequences[i]) == 0)
                            {
                            break;
                            }
                        }
                    if (i < ARRAY_SIZE_OF(ValidProtocolSequences))
                        {
                        BindingEndpoint = (char *) ValidEnpoints[i];
                        argc--;
                        argv++;
                        break;
                        }
                    else
                        {
                        printf("Invalid protocol sequence: %s\n", Protseq);
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                case 's':
                    NetworkAddr = *argv;
                    argc--;
                    argv++;
                    break;
                case 'I':
                    IfStart = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'N':
                    ProcNum = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'L':
                    TempString = *argv;
                    Delimiter = strchr(TempString, '.');
                    if (Delimiter == NULL)
                        {
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    *Delimiter = 0;
                    Delimiter ++;
                    CellID.SectionID = (unsigned short)strtoul(TempString, &Ignored, radix);
                    CellID.CellID = (unsigned short)strtoul(Delimiter, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'E':
                    EndpointName = *argv;
                    argc--;
                    argv++;
                    break;
                case 'T':
                    ThreadID = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'P':
                    ProcessID = strtoul(*argv, &Ignored, radix);
                    argc--;
                    argv++;
                    break;
                case 'c':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaCallInfo;
                    fMissingParm = 0;
                    break;
                case 'l':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaDebugCellInfo;
                    fMissingParm = 0;
                    break;
                case 'e':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaEndpointInfo;
                    fMissingParm = 0;
                    break;
                case 't':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaThreadInfo;
                    fMissingParm = 0;
                    break;
                case 'a':
                    if (Action != cdaInvalid)
                        {
                        printf("The action to be performed can be specified only once on the command line\n");
                        printf("Usage: %s: %s\n", Name, USAGE);
                        exit(2);
                        }
                    Action = cdaClientCallInfo;
                    fMissingParm = 0;
                    break;
                case 'r':
                    radix = atoi(*argv);
                    fMissingParm = 0;
                    break;
                default:
                    fMissingParm = 0;
                    printf("Usage: %s: %s\n", Name, USAGE);
                    exit(2);
                    break;
                }

            if (fMissingParm)
                {
                printf("Invalid switch %s, missing required parameter\n", *argv);
                exit(2);
                }
            }
        } // while argc

    // verify that the options are consistent
    fInvalidArg = FALSE;
    switch (Action)
        {
        case cdaInvalid:
            printf("The action to be performed should be specified exactly once on the command line\n");
            printf("Usage: %s: %s\n", Name, USAGE);
            exit(2);

        case cdaCallInfo:
        case cdaClientCallInfo:
            fInvalidArg = CheckForCellID();
            fInvalidArg |= CheckForEndpointName();
            fInvalidArg |= CheckForThreadID();

            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        case cdaDebugCellInfo:
            if ((CellID.SectionID == 0) && (CellID.CellID == 0))
                {
                printf("A cell ID must be specified for this action\n");
                fInvalidArg = TRUE;
                }

            if (ProcessID == 0)
                {
                printf("A process ID must be specified for this action\n");
                fInvalidArg = TRUE;
                }

            fInvalidArg |= CheckForEndpointName();
            fInvalidArg |= CheckForThreadID();
            fInvalidArg |= CheckForCallID();
            fInvalidArg |= CheckForIfStart();
            fInvalidArg |= CheckForProcNum();

            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        case cdaEndpointInfo:

            fInvalidArg |= CheckForCellID();
            fInvalidArg |= CheckForThreadID();
            fInvalidArg |= CheckForCallID();
            fInvalidArg |= CheckForIfStart();
            fInvalidArg |= CheckForProcNum();
            fInvalidArg |= CheckForProcessID();

            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        case cdaThreadInfo:
            if (ProcessID == 0)
                {
                printf("A process ID must be specified for this action\n");
                fInvalidArg = TRUE;
                }

            fInvalidArg |= CheckForCellID();
            fInvalidArg |= CheckForCallID();
            fInvalidArg |= CheckForIfStart();
            fInvalidArg |= CheckForProcNum();
            if (fInvalidArg)
                {
                printf("Usage: %s: %s\n", Name, USAGE);
                exit(2);
                }
            break;

        default:
            printf("Internal error. Chosen action is %d\n", Action);
            exit(2);
        }
}

/*
RPC_STATUS DoRpcBindingSetAuthInfo(handle_t Binding)
{
    if (AuthnLevel != RPC_C_AUTHN_LEVEL_NONE)
        return RpcBindingSetAuthInfo(Binding,
                                     NULL,
                                     AuthnLevel,
                                     ulSecurityPackage,
                                     NULL,
                                     RPC_C_AUTHZ_NONE);
    else
        return(RPC_S_OK);
}

unsigned long Worker(unsigned long l)
{
    unsigned long status;
    unsigned long Test;
    unsigned long ClientId;
    unsigned long InSize, OutSize;
    unsigned long Time, Calls;
    char __RPC_FAR *pBuffer;
    char __RPC_FAR *stringBinding;
    handle_t binding;
    RPC_STATUS RpcErr;
    int Retries;

    pBuffer = MIDL_user_allocate(128*1024L);
    if (pBuffer == 0)
        {
        PrintToConsole("Out of memory!");
        return 1;
        }

    status =
    RpcStringBindingComposeA(0,
                            Protseq,
                            NetworkAddr,
                            Endpoint,
                            0,
                            &stringBinding);
    CHECK_RET(status, "RpcStringBindingCompose");

    status =
    RpcBindingFromStringBindingA(stringBinding, &binding);
    CHECK_RET(status, "RpcBindingFromStringBinding");

    status =
    DoRpcBindingSetAuthInfo(binding);
    CHECK_RET(status, "RpcBindingSetAuthInfo");

    RpcStringFreeA(&stringBinding);

    Retries = 15;

    do
        {
        status = BeginTest(binding, &ClientId, &Test, &InSize, &OutSize);

        if (status == PERF_TOO_MANY_CLIENTS)
            {
            PrintToConsole("Too many clients, I'm exiting\n");
            goto Cleanup ;
            }

        Retries --;
        if ((status == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0))
            {
            PrintToConsole("Server too busy - retrying ...\n");
            }
        }
    while ((status == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0));

    CHECK_RET(status, "ClientConnect");

    if (InSize > IN_ADJUSTMENT)
        {
        InSize -= IN_ADJUSTMENT;
        }
    else
        {
        InSize = 0;
        }

    if (OutSize > OUT_ADJUSTMENT)
        {
        OutSize -= OUT_ADJUSTMENT;
        }
    else
        {
        OutSize = 0;
        }

    gInSize = InSize;
    gOutSize = OutSize;

    PrintToConsole("Client %ld connected\n", ClientId);

    Retries = 15;

    do
        {
        RpcTryExcept
            {
            RpcErr = RPC_S_OK;

            Time = GetTickCount();

            Calls = ( (TestTable[Test])(binding, ClientId, pBuffer) );

            Time = GetTickCount() - Time;
       
            Dump("Completed %d calls in %d ms\n"
                   "%d T/S or %3d.%03d ms/T\n\n",
                   Calls,
                   Time,
                   (Calls * 1000) / Time,
                   Time / Calls,
                   ((Time % Calls) * 1000) / Calls
                   );
            }
        RpcExcept(1)
            {
            RpcErr = (unsigned long)RpcExceptionCode();
            PrintToConsole("\nException %lu (0x%08lX)\n",
                       RpcErr, RpcErr);
            }
        RpcEndExcept
        Retries --;
        if ((RpcErr == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0))
            {
            PrintToConsole("Server too busy - retrying ...\n");
            }
        }
    while ((RpcErr == RPC_S_SERVER_UNAVAILABLE) && (Retries > 0));

Cleanup:
    RpcBindingFree(&binding);
    return status;
}
*/

////////////////////////////////////////////////////////////////////
/// Local representation to wire representation translation routines
////////////////////////////////////////////////////////////////////
BOOL TranslateRemoteCallInfoToLocalCallInfo(IN RemoteDebugCallInfo *RemoteCallInfo, 
                                            OUT DebugCallInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteCallInfo->Type;
    LocalDebugInfo->Status = RemoteCallInfo->Status;
    LocalDebugInfo->ProcNum = RemoteCallInfo->ProcNum;
    LocalDebugInfo->InterfaceUUIDStart = RemoteCallInfo->InterfaceUUIDStart;
    LocalDebugInfo->ServicingTID = RemoteCallInfo->ServicingTID;
    LocalDebugInfo->CallFlags = RemoteCallInfo->CallFlags;
    LocalDebugInfo->CallID = RemoteCallInfo->CallID;
    LocalDebugInfo->LastUpdateTime = RemoteCallInfo->LastUpdateTime;
    if (RemoteCallInfo->ConnectionType == crtLrpcConnection)
        {
        ASSERT(LocalDebugInfo->CallFlags & DBGCELL_LRPC_CALL);
        LocalDebugInfo->Connection = RemoteCallInfo->connInfo.Connection;
        }
    else if (RemoteCallInfo->ConnectionType == crtOsfConnection)
        {
        LocalDebugInfo->PID = RemoteCallInfo->connInfo.Caller.PID;
        LocalDebugInfo->TID = RemoteCallInfo->connInfo.Caller.TID;
        }
    else
        {
        PrintToConsole("Invalid type for call info connection type: %d\n", 
            RemoteCallInfo->ConnectionType);
        return FALSE;
        }
    return TRUE;
}

void TranslateRemoteEndpointInfoToLocalEndpointInfo(IN RemoteDebugEndpointInfo *RemoteEndpointInfo, 
                                                    OUT DebugEndpointInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteEndpointInfo->Type;
    LocalDebugInfo->ProtseqType = RemoteEndpointInfo->ProtseqType;
    LocalDebugInfo->Status = RemoteEndpointInfo->Status;

    if (RemoteEndpointInfo->EndpointName)
        {
        memcpy(LocalDebugInfo->EndpointName,
            RemoteEndpointInfo->EndpointName,
            DebugEndpointNameLength);
        MIDL_user_free(RemoteEndpointInfo->EndpointName);
        RemoteEndpointInfo->EndpointName = 0;
        }
    else
        LocalDebugInfo->EndpointName[0] = 0;
}

void TranslateRemoteThreadInfoToLocalThreadInfo(IN RemoteDebugThreadInfo *RemoteThreadInfo, 
                                                OUT DebugThreadInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteThreadInfo->Type;
    LocalDebugInfo->Status = RemoteThreadInfo->Status;
    LocalDebugInfo->LastUpdateTime = RemoteThreadInfo->LastUpdateTime;
    LocalDebugInfo->TID = RemoteThreadInfo->TID;
    LocalDebugInfo->Endpoint = RemoteThreadInfo->Endpoint;
}

void TranslateRemoteClientCallInfoToLocalClientCallInfo(IN RemoteDebugClientCallInfo *RemoteClientCallInfo, 
                                                        OUT DebugClientCallInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteClientCallInfo->Type;
    LocalDebugInfo->ProcNum = RemoteClientCallInfo->ProcNum;
    LocalDebugInfo->ServicingThread = RemoteClientCallInfo->ServicingThread;
    LocalDebugInfo->IfStart = RemoteClientCallInfo->IfStart;
    LocalDebugInfo->CallID = RemoteClientCallInfo->CallID;
    LocalDebugInfo->CallTargetID = RemoteClientCallInfo->CallTargetID;

    if (RemoteClientCallInfo->Endpoint)
        {
        memcpy(LocalDebugInfo->Endpoint,
            RemoteClientCallInfo->Endpoint,
            ClientCallEndpointLength);
        MIDL_user_free(RemoteClientCallInfo->Endpoint);
        RemoteClientCallInfo->Endpoint = 0;
        } 
    else
        LocalDebugInfo->Endpoint[0] = 0;
}

void TranslateRemoteConnectionInfoToLocalConnectionInfo(IN RemoteDebugConnectionInfo *RemoteConnectionInfo, 
                                                        OUT DebugConnectionInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteConnectionInfo->Type;
    LocalDebugInfo->Flags = RemoteConnectionInfo->Flags;
    LocalDebugInfo->LastTransmitFragmentSize = 
        RemoteConnectionInfo->LastTransmitFragmentSize;
    LocalDebugInfo->Endpoint = RemoteConnectionInfo->Endpoint;
    LocalDebugInfo->ConnectionID[0] = ULongToPtr(RemoteConnectionInfo->ConnectionID[0]);
    LocalDebugInfo->ConnectionID[1] = ULongToPtr(RemoteConnectionInfo->ConnectionID[1]);
    LocalDebugInfo->LastSendTime = RemoteConnectionInfo->LastSendTime;
    LocalDebugInfo->LastReceiveTime = RemoteConnectionInfo->LastReceiveTime;
}

void TranslateRemoteCallTargetInfoToLocalCallTargetInfo(IN RemoteDebugCallTargetInfo *RemoteCallTargetInfo, 
                                                        OUT DebugCallTargetInfo *LocalDebugInfo)
{
    LocalDebugInfo->Type = RemoteCallTargetInfo->Type;
    LocalDebugInfo->ProtocolSequence = RemoteCallTargetInfo->ProtocolSequence;
    LocalDebugInfo->LastUpdateTime = RemoteCallTargetInfo->LastUpdateTime;

    if (RemoteCallTargetInfo->TargetServer)
        {
        memcpy(LocalDebugInfo->TargetServer, RemoteCallTargetInfo->TargetServer,
            TargetServerNameLength);
        MIDL_user_free(RemoteCallTargetInfo->TargetServer);
        RemoteCallTargetInfo->TargetServer = 0;
        }
}

BOOL TranslateRemoteDebugCellInfoToLocalDebugCellInfo(RemoteDebugCellUnion *RemoteCellInfo, 
                                                      DebugCellUnion *Container)
{
    switch (RemoteCellInfo->UnionType)
        {
        case dctCallInfo:
            return TranslateRemoteCallInfoToLocalCallInfo(&RemoteCellInfo->debugInfo.callInfo,
                &Container->callInfo);
            break;

        case dctThreadInfo:
            TranslateRemoteThreadInfoToLocalThreadInfo(&RemoteCellInfo->debugInfo.threadInfo,
                &Container->threadInfo);
            break;

        case dctEndpointInfo:
            TranslateRemoteEndpointInfoToLocalEndpointInfo(&RemoteCellInfo->debugInfo.endpointInfo,
                &Container->endpointInfo);
            break;

        case dctClientCallInfo:
            TranslateRemoteClientCallInfoToLocalClientCallInfo(&RemoteCellInfo->debugInfo.clientCallInfo,
                &Container->clientCallInfo);
            break;

        case dctConnectionInfo:
            TranslateRemoteConnectionInfoToLocalConnectionInfo(&RemoteCellInfo->debugInfo.connectionInfo,
                &Container->connectionInfo);
            break;

        case dctCallTargetInfo:
            TranslateRemoteCallTargetInfoToLocalCallTargetInfo(&RemoteCellInfo->debugInfo.callTargetInfo,
                &Container->callTargetInfo);
            break;

        default:
            PrintToConsole("Invalid debug cell type: %d\n", RemoteCellInfo->UnionType);
            return FALSE;
        }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
/// Helper routines for enumerating remote information
//////////////////////////////////////////////////////////////////////////////
void GetAndPrintRemoteCallInfo(IN handle_t Binding)
{
    RemoteDebugCallInfo *RemoteCallInfo;
    DebugCellID CellID;
    DbgCallEnumHandle rh;
    DebugCallInfo LocalCallInfo;
    RPC_STATUS Status;

    RemoteCallInfo = NULL;
    DumpToConsole("Getting remote call info ...\n");

    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugCallInfoEnumeration(Binding, &rh, CallID, IfStart, ProcNum, ProcessID);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintCallInfoHeader(DumpToConsole);
    do
        {
        RemoteCallInfo = NULL;
        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugCallInfo(rh, &RemoteCallInfo, &CellID, &ProcessID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            TranslateRemoteCallInfoToLocalCallInfo(RemoteCallInfo, &LocalCallInfo);
            MIDL_user_free(RemoteCallInfo);
            PrintCallInfoBody(ProcessID, CellID, &LocalCallInfo, DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugCallInfoEnumeration(&rh);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

void GetAndPrintRemoteEndpointInfo(IN handle_t Binding)
{
    DWORD CurrentPID;
    RPC_STATUS Status;
    DebugEndpointInfo EndpointInfo;
    RemoteDebugEndpointInfo *RemoteEndpointInfo;
    DbgEndpointEnumHandle rh;
    DebugCellID CellID;

    DumpToConsole("Getting remote endpoint info ...\n");
    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugEndpointInfoEnumeration(Binding, &rh, 
            (EndpointName != NULL) ? (strlen(EndpointName) + 1) : 0, 
            (unsigned char *) EndpointName);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugEndpointInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintEndpointInfoHeader(DumpToConsole);
    do
        {
        RemoteEndpointInfo = NULL;
        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugEndpointInfo(rh, &RemoteEndpointInfo, &CellID, &CurrentPID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            TranslateRemoteEndpointInfoToLocalEndpointInfo(RemoteEndpointInfo, &EndpointInfo);
            MIDL_user_free(RemoteEndpointInfo);
            PrintEndpointInfoBody(CurrentPID, CellID, &EndpointInfo, DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugEndpointInfoEnumeration(&rh);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

void GetAndPrintRemoteThreadInfo(IN handle_t Binding)
{
    RPC_STATUS Status;
    DbgThreadEnumHandle rh;
    RemoteDebugThreadInfo *RemoteThreadInfo;
    DebugThreadInfo LocalThreadInfo;
    DebugCellID CellID;
    DWORD CurrentPID;

    DumpToConsole("Getting remote thread info ...\n");
    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugThreadInfoEnumeration(Binding, &rh, ProcessID, ThreadID);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugThreadInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintThreadInfoHeader(DumpToConsole);
    do
        {
        RemoteThreadInfo = NULL;
        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugThreadInfo(rh, &RemoteThreadInfo, &CellID, &CurrentPID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            TranslateRemoteThreadInfoToLocalThreadInfo(RemoteThreadInfo, &LocalThreadInfo);
            MIDL_user_free(RemoteThreadInfo);
            PrintThreadInfoBody(CurrentPID, CellID, &LocalThreadInfo, DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugThreadInfoEnumeration(&rh);    
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

void GetAndPrintRemoteClientCallInfo(IN handle_t Binding)
{
    DWORD CurrentPID;
    DebugCellID CellID;

    DebugClientCallInfo LocalClientCall;
    DebugCallTargetInfo LocalCallTarget;

    RemoteDebugClientCallInfo *RemoteClientCallInfo;
    RemoteDebugCallTargetInfo *RemoteCallTargetInfo;

    RPC_STATUS Status;
    DbgClientCallEnumHandle rh;

    DumpToConsole("Getting remote call info ...\n");
    RpcTryExcept
        {
        Status = RemoteOpenRPCDebugClientCallInfoEnumeration(Binding, &rh, CallID, IfStart, ProcNum, ProcessID);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
    if (Status != RPC_S_OK)
        {
        DumpToConsole("RemoteOpenRPCDebugClientCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintClientCallInfoHeader(DumpToConsole);
    do
        {
        RemoteClientCallInfo = NULL;
        RemoteCallTargetInfo = NULL;

        RpcTryExcept
            {
            Status = RemoteGetNextRPCDebugClientCallInfo(rh, &RemoteClientCallInfo, &RemoteCallTargetInfo, 
                &CellID, &CurrentPID);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept
        if (Status == RPC_S_OK)
            {
            if ((RemoteCallTargetInfo != NULL) && (RemoteCallTargetInfo->Type != dctCallTargetInfo))
                {
                DumpToConsole("Inconsistent information detected - skipping ...\n");
                MIDL_user_free(RemoteClientCallInfo);
                MIDL_user_free(RemoteCallTargetInfo);
                continue;
                }

            TranslateRemoteClientCallInfoToLocalClientCallInfo(RemoteClientCallInfo, &LocalClientCall);
            MIDL_user_free(RemoteClientCallInfo);
            TranslateRemoteCallTargetInfoToLocalCallTargetInfo(RemoteCallTargetInfo, &LocalCallTarget);
            MIDL_user_free(RemoteCallTargetInfo);
            PrintClientCallInfoBody(CurrentPID, CellID, &LocalClientCall, &LocalCallTarget,
                DumpToConsole);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        DumpToConsole("Enumeration aborted with error %d\n", Status);
        }

    RpcTryExcept
        {
        RemoteFinishRPCDebugClientCallInfoEnumeration(&rh);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        Status = RpcExceptionCode();
        }
    RpcEndExcept
}

int __cdecl
main (int argc, char **argv)
{
    unsigned long Status, i;
    unsigned char *StringBinding;
    handle_t Binding;
    RemoteDebugCellUnion *RemoteDebugCell;
    DebugCellUnion Container;
    DebugCellUnion EndpointContainer;
    DebugCellUnion *EndpointContainerPointer;
    BOOL fResult;

    ParseArgv(argc, argv);

    // by now, we must have all valid arguments. Depending on local/remote
    // case and on action chosen, we actually do the work
    if (NetworkAddr == NULL)
        {
        // in local case, just do the work
        switch (Action)
            {
            case cdaCallInfo:
                GetAndPrintCallInfo(CallID, IfStart, ProcNum, ProcessID, DumpToConsole);
                break;

            case cdaClientCallInfo:
                GetAndPrintClientCallInfo(CallID, IfStart, ProcNum, ProcessID, DumpToConsole);
                break;

            case cdaDebugCellInfo:
                GetAndPrintDbgCellInfo(ProcessID, CellID, DumpToConsole);
                break;

            case cdaEndpointInfo:
                GetAndPrintEndpointInfo(EndpointName, DumpToConsole);
                break;

            case cdaThreadInfo:
                GetAndPrintThreadInfo(ProcessID, ThreadID, DumpToConsole);
                break;

            }
        }
    else
        {
        Status = RpcStringBindingComposeA(0, (unsigned char *)Protseq, 
            (unsigned char *)NetworkAddr, (unsigned char *)BindingEndpoint, 0, &StringBinding);
        CHECK_RET(Status, "RpcStringBindingCompose");

        Status = RpcBindingFromStringBindingA(StringBinding, &Binding);
        CHECK_RET(Status, "RpcBindingFromStringBinding");

        RpcStringFreeA(&StringBinding);

        Status = RpcBindingSetAuthInfo(Binding, NULL, RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_GSS_NEGOTIATE,
                                     NULL, RPC_C_AUTHZ_NONE);
        CHECK_RET(Status, "RpcBindingSetAuthInfo");

        // in remote case, call the remote RPCSS
        switch (Action)
            {
            case cdaCallInfo:
                GetAndPrintRemoteCallInfo(Binding);
                break;

            case cdaClientCallInfo:
                GetAndPrintRemoteClientCallInfo(Binding);
                break;

            case cdaDebugCellInfo:
                RemoteDebugCell = NULL;
                DumpToConsole("Getting remote cell info ...\n");
                RpcTryExcept
                    {
                    Status = RemoteGetCellByDebugCellID(Binding, ProcessID, CellID, &RemoteDebugCell);
                    }
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                    Status = RpcExceptionCode();
                    }
                RpcEndExcept

                if (Status != RPC_S_OK)
                    {
                    DumpToConsole("Remote call failed with error %d\n", Status);
                    break;
                    }

                // get back the idl representation into a DbgCell representation
                fResult = TranslateRemoteDebugCellInfoToLocalDebugCellInfo(RemoteDebugCell, &Container);

                MIDL_user_free(RemoteDebugCell);

                // if FALSE is returned, error info should have already been printed out
                if (!fResult)
                    break;

                if (Container.genericCell.Type == dctConnectionInfo)
                    {
                    RemoteDebugCell = NULL;

                    DumpToConsole("Getting remote endpoint info for connection ...\n");

                    RpcTryExcept
                        {
                        Status = RemoteGetCellByDebugCellID(Binding, ProcessID, 
                            Container.connectionInfo.Endpoint, &RemoteDebugCell);
                        }
                    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                        {
                        Status = RpcExceptionCode();
                        }
                    RpcEndExcept

                    if (Status != RPC_S_OK)
                        {
                        DumpToConsole("Remote call failed with error %d\n", Status);
                        break;
                        }

                    fResult = TranslateRemoteDebugCellInfoToLocalDebugCellInfo(RemoteDebugCell,
                        &EndpointContainer);

                    MIDL_user_free(RemoteDebugCell);

                    if (!fResult)
                        break;

                    EndpointContainerPointer = &EndpointContainer;
                    }
                else
                    EndpointContainerPointer = NULL;

                PrintDbgCellInfo(&Container, EndpointContainerPointer, DumpToConsole);
                break;

            case cdaEndpointInfo:
                GetAndPrintRemoteEndpointInfo(Binding);
                break;

            case cdaThreadInfo:
                GetAndPrintRemoteThreadInfo(Binding);
                break;

            }

        RpcBindingFree(&Binding);
        }

    /*
    PrintToConsole("Authentication Level is: %s\n", AuthnLevelStr);

    if (Options[0] < 0)
        Options[0] = 1;

    pClientThreads = MIDL_user_allocate(sizeof(HANDLE) * Options[0]);

    for(i = 0; i < (unsigned long)Options[0]; i++)
        {
        pClientThreads[i] = CreateThread(0,
                                         0,
                                         (LPTHREAD_START_ROUTINE)Worker,
                                         0,
                                         0,
                                         &status);
        if (pClientThreads[i] == 0)
            ApiError("CreateThread", GetLastError());
        }


    status = WaitForMultipleObjects(Options[0],
                                    pClientThreads,
                                    TRUE,  // Wait for all client threads
                                    INFINITE);
    if (status == WAIT_FAILED)
        {
        ApiError("WaitForMultipleObjects", GetLastError());
        }
        */
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbglib\dbginit.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DbgInit.cxx

Abstract:

    Initialization and utility functions for the debug library

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>

static DWORD gPageSize = 0;
BOOL g_fDbgLibInitialized = FALSE;

DWORD GetPageSize(void)
{
    return gPageSize;
}

RPC_STATUS InitializeDbgLib(void)
{
    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;

    if (g_fDbgLibInitialized)
        return RPC_S_OK;

    Status = NtQuerySystemInformation(
                            SystemBasicInformation,
                            &BasicInfo,
                            sizeof(BasicInfo),
                            NULL
                            );
    if ( !NT_SUCCESS(Status) )
        {
        DbgPrint("RPCDBGLIG: NtQuerySystemInformation failed: %x\n", Status);
        return RPC_S_INTERNAL_ERROR;
        }

    gPageSize = BasicInfo.PageSize;
    g_fDbgLibInitialized = TRUE;
    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbglib\cellutil.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CellUtil.cxx

Abstract:

    Utility functions for manipulating cells

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <DbgLib.hxx>

DebugCellUnion *GetCellByIndex(IN OpenedDbgSection *pSection, IN DWORD CellIndex)
{
    DWORD LocalPageSize = GetPageSize();
    DebugCellGeneric *LastCellForSection;
    DebugCellGeneric *CurrentCell;

    ASSERT(pSection != NULL);
    ASSERT(pSection->SectionCopy != NULL);

#ifdef _WIN64
    if (CellIndex <= 1)
        return NULL;
#else
    if (CellIndex == 0)
        return NULL;
#endif

    LastCellForSection = GetLastCellForSection(pSection, LocalPageSize);
    CurrentCell = GetCellForSection(pSection, CellIndex);

    ASSERT(CurrentCell <= LastCellForSection);
    return (DebugCellUnion *) CurrentCell;
}

DebugCellUnion *GetCellByDebugCellID(IN CellEnumerationHandle CellEnumHandle, IN DebugCellID CellID)
{
    SectionsSnapshot *Snapshot;
    OpenedDbgSection *CurrentSection;
    DebugCellUnion *Cell = NULL;

    Snapshot = (SectionsSnapshot *)CellEnumHandle;

    ASSERT(Snapshot != NULL);

    CurrentSection = Snapshot->FirstOpenedSection;
    while (TRUE)
        {
        if (CurrentSection->SectionID == CellID.SectionID)
            {
            Cell = GetCellByIndex(CurrentSection, CellID.CellID);
            break;
            }

        if (CurrentSection->SectionsList.Flink == NULL)
            break;

        CurrentSection = CONTAINING_RECORD(CurrentSection->SectionsList.Flink, OpenedDbgSection, SectionsList);
        }

    return Cell;
}

RPC_STATUS GetCellByDebugCellID(IN DWORD ProcessID, IN DebugCellID CellID, OUT DebugCellUnion *Container)
{
    RPC_STATUS Status;
    CellEnumerationHandle CellEnumHandle;
    DebugCellUnion *Cell;

    ASSERT(Container != NULL);
    Status = OpenRPCServerDebugInfo(ProcessID, &CellEnumHandle);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Cell = GetCellByDebugCellID(CellEnumHandle, CellID);
    if (Cell)
        {
        memcpy(Container, Cell, sizeof(DebugCellUnion));
        }
    else
        Status = ERROR_FILE_NOT_FOUND;

    CloseRPCServerDebugInfo(&CellEnumHandle);
    return Status;
}

/////////////////////////////////////////////////////
typedef struct tagRPCDebugCallInfoEnumState
{
    DWORD CallID;
    DWORD IfStart;
    int ProcNum;
    DWORD ProcessID;
    union
        {
        // if ProcessID != 0, cellEnum is used (i.e. we have process wide enumeration
        // otherwise, systemWideEnum is used - we have system wide enumeration
        RPCSystemWideCellEnumerationHandle systemWideEnum;
        CellEnumerationHandle cellEnum;
        };
} RPCDebugCallInfoEnumState;

RPC_STATUS OpenRPCDebugCallInfoEnumeration(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                                           IN int ProcNum OPTIONAL,
                                           IN DWORD ProcessID OPTIONAL, 
                                           OUT CallInfoEnumerationHandle *pHandle)
{
    RPCDebugCallInfoEnumState *pCallEnumeration;
    RPC_STATUS Status;

    *pHandle = NULL;
    pCallEnumeration = new RPCDebugCallInfoEnumState;
    if (pCallEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    pCallEnumeration->CallID = CallID;
    pCallEnumeration->IfStart = IfStart;
    pCallEnumeration->ProcessID = ProcessID;
    pCallEnumeration->ProcNum = ProcNum;

    if (ProcessID != 0)
        {
        Status = OpenRPCServerDebugInfo(ProcessID, &pCallEnumeration->cellEnum);
        if (Status == ERROR_FILE_NOT_FOUND)
            {
            delete pCallEnumeration;
            return RPC_S_DBG_NOT_AN_RPC_SERVER;
            }
        else if (Status != RPC_S_OK)
            {
            delete pCallEnumeration;
            return Status;
            }
        }
    else
        {
        Status = OpenRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        if (Status != RPC_S_OK)
            return Status;
        }

    *pHandle = (CallInfoEnumerationHandle) pCallEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugCallInfo(IN CallInfoEnumerationHandle handle, OUT DebugCallInfo **NextCall,
                                   OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugCallInfoEnumState *pCallEnumeration = (RPCDebugCallInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugCallInfo *CallInfo;
    DebugCellUnion *NextCell;

    ASSERT(pCallEnumeration != NULL);
    ASSERT(NextCall != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        if (pCallEnumeration->ProcessID != 0)
            {
            *ServerPID = pCallEnumeration->ProcessID;
            NextCell = GetNextDebugCellInfo(pCallEnumeration->cellEnum, CellID);
            if (NextCell == NULL)
                return RPC_S_DBG_ENUMERATION_DONE;
            }
        else
            {
            Status = GetNextRPCSystemWideCell(pCallEnumeration->systemWideEnum, &NextCell, CellID, ServerPID);
            if (Status == RPC_S_INVALID_BOUND)
                return RPC_S_DBG_ENUMERATION_DONE;
            if (Status != RPC_S_OK)
                return Status;
            }
        // NextCell must be non-NULL here, or we have a bug
        ASSERT(NextCell != NULL);

        if (NextCell->callInfo.Type != dctCallInfo)
            continue;

        CallInfo = &NextCell->callInfo;

        if ((pCallEnumeration->CallID != 0) && (CallInfo->CallID != pCallEnumeration->CallID))
            continue;

        if ((pCallEnumeration->IfStart != 0) && (CallInfo->InterfaceUUIDStart != pCallEnumeration->IfStart))
            continue;

        if (((USHORT)pCallEnumeration->ProcNum != (USHORT)RPCDBG_NO_PROCNUM_SPECIFIED) 
            && (CallInfo->ProcNum != pCallEnumeration->ProcNum))
            continue;

        // if we have survived all checks until now, we have found it - return it
        *NextCall = CallInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugCallInfoEnumeration(IN OUT CallInfoEnumerationHandle *pHandle)
{
    RPCDebugCallInfoEnumState *pCallEnumeration;

    ASSERT(pHandle != NULL);
    pCallEnumeration = (RPCDebugCallInfoEnumState *)*pHandle;
    ASSERT(pCallEnumeration != NULL);

    if (pCallEnumeration->ProcessID != 0)
        {
        CloseRPCServerDebugInfo(&pCallEnumeration->cellEnum);
        }
    else
        {
        FinishRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        }
}

RPC_STATUS ResetRPCDebugCallInfoEnumeration(IN CallInfoEnumerationHandle handle)
{
    RPCDebugCallInfoEnumState *pCallEnumeration = (RPCDebugCallInfoEnumState *)handle;

    ASSERT(pCallEnumeration != NULL);
    if (pCallEnumeration->ProcessID != 0)
        {
        ResetRPCServerDebugInfo(pCallEnumeration->cellEnum);
        return RPC_S_OK;
        }
    else
        {
        return ResetRPCSystemWideCellEnumeration(pCallEnumeration->systemWideEnum);
        }
}


////////////////////////////////////
typedef struct tagRPCDebugEndpointInfoEnumState
{
    char *Endpoint;
    RPCSystemWideCellEnumerationHandle systemWideEnum;
} RPCDebugEndpointInfoEnumState;

RPC_STATUS OpenRPCDebugEndpointInfoEnumeration(IN char *Endpoint OPTIONAL, 
                                               OUT EndpointInfoEnumerationHandle *pHandle)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration;
    RPC_STATUS Status;
    int EndpointLength;

    *pHandle = NULL;
    pEndpointEnumeration = new RPCDebugEndpointInfoEnumState;
    if (pEndpointEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    if (ARGUMENT_PRESENT(Endpoint))
        {
        EndpointLength = strlen(Endpoint);
        pEndpointEnumeration->Endpoint = new char [EndpointLength + 1];
        if (pEndpointEnumeration->Endpoint == NULL)
            {
            delete pEndpointEnumeration;
            return RPC_S_OUT_OF_MEMORY;
            }
        memcpy(pEndpointEnumeration->Endpoint, Endpoint, EndpointLength + 1);
        }
    else
        {
        pEndpointEnumeration->Endpoint = NULL;
        }

    Status = OpenRPCSystemWideCellEnumeration(&pEndpointEnumeration->systemWideEnum);
    if (Status != RPC_S_OK)
        return Status;

    *pHandle = (EndpointInfoEnumerationHandle) pEndpointEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugEndpointInfo(IN CallInfoEnumerationHandle handle, OUT DebugEndpointInfo **NextEndpoint,
                                       OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration = (RPCDebugEndpointInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugEndpointInfo *EndpointInfo;
    DebugCellUnion *NextCell;

    ASSERT(pEndpointEnumeration != NULL);
    ASSERT(NextEndpoint != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        Status = GetNextRPCSystemWideCell(pEndpointEnumeration->systemWideEnum, &NextCell, CellID, ServerPID);
        if (Status == RPC_S_INVALID_BOUND)
            return RPC_S_DBG_ENUMERATION_DONE;

        if (Status != RPC_S_OK)
            return Status;

        // NextCell must be non-NULL here, or we have a bug
        ASSERT(NextCell != NULL);

        if (NextCell->callInfo.Type != dctEndpointInfo)
            continue;

        EndpointInfo = &NextCell->endpointInfo;

        if (pEndpointEnumeration->Endpoint != NULL) 
            {
            if (strncmp(EndpointInfo->EndpointName, pEndpointEnumeration->Endpoint, sizeof(EndpointInfo->EndpointName)) != 0)
                continue;
            }

        // if we have survived all checks until now, we have found it - return it
        *NextEndpoint = EndpointInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugEndpointInfoEnumeration(IN OUT EndpointInfoEnumerationHandle *pHandle)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration;

    ASSERT(pHandle != NULL);
    pEndpointEnumeration = (RPCDebugEndpointInfoEnumState *)*pHandle;
    ASSERT(pEndpointEnumeration != NULL);

    FinishRPCSystemWideCellEnumeration(&pEndpointEnumeration->systemWideEnum);
}

RPC_STATUS ResetRPCDebugEndpointInfoEnumeration(IN EndpointInfoEnumerationHandle handle)
{
    RPCDebugEndpointInfoEnumState *pEndpointEnumeration = (RPCDebugEndpointInfoEnumState *)handle;

    ASSERT(pEndpointEnumeration != NULL);
    return ResetRPCSystemWideCellEnumeration(pEndpointEnumeration->systemWideEnum);
}


////////////////////////////////////////////////
typedef struct tagRPCDebugThreadInfoEnumState
{
    DWORD ProcessID;
    DWORD ThreadID;
    CellEnumerationHandle cellEnum;
} RPCDebugThreadInfoEnumState;

RPC_STATUS OpenRPCDebugThreadInfoEnumeration(IN DWORD ProcessID, 
                                             IN DWORD ThreadID OPTIONAL,
                                             OUT ThreadInfoEnumerationHandle *pHandle)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration;
    RPC_STATUS Status;

    ASSERT(ProcessID != 0);

    *pHandle = NULL;
    pThreadEnumeration = new RPCDebugThreadInfoEnumState;
    if (pThreadEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    pThreadEnumeration->ProcessID = ProcessID;
    pThreadEnumeration->ThreadID = ThreadID;

    Status = OpenRPCServerDebugInfo(ProcessID, &pThreadEnumeration->cellEnum);
    if (Status == ERROR_FILE_NOT_FOUND)
        {
        delete pThreadEnumeration;
        return RPC_S_DBG_NOT_AN_RPC_SERVER;
        }
    else if (Status != RPC_S_OK)
        {
        delete pThreadEnumeration;
        return Status;
        }

    *pHandle = (ThreadInfoEnumerationHandle) pThreadEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugThreadInfo(IN ThreadInfoEnumerationHandle handle, OUT DebugThreadInfo **NextThread,
                                     OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration = (RPCDebugThreadInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugThreadInfo *ThreadInfo;
    DebugCellUnion *NextCell;

    ASSERT(pThreadEnumeration != NULL);
    ASSERT(NextThread != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        *ServerPID = pThreadEnumeration->ProcessID;
        NextCell = GetNextDebugCellInfo(pThreadEnumeration->cellEnum, CellID);

        if (NextCell == NULL)
            return RPC_S_DBG_ENUMERATION_DONE;

        if (NextCell->callInfo.Type != dctThreadInfo)
            continue;

        ThreadInfo = &NextCell->threadInfo;

        if ((pThreadEnumeration->ThreadID != 0) && (ThreadInfo->TID != pThreadEnumeration->ThreadID))
            continue;

        // if we have survived all checks until now, we have found it - return it
        *NextThread = ThreadInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugThreadInfoEnumeration(IN OUT ThreadInfoEnumerationHandle *pHandle)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration;

    ASSERT(pHandle != NULL);
    pThreadEnumeration = (RPCDebugThreadInfoEnumState *)*pHandle;
    ASSERT(pThreadEnumeration != NULL);

    CloseRPCServerDebugInfo(&pThreadEnumeration->cellEnum);
}


RPC_STATUS ResetRPCDebugThreadInfoEnumeration(IN ThreadInfoEnumerationHandle handle)
{
    RPCDebugThreadInfoEnumState *pThreadEnumeration = (RPCDebugThreadInfoEnumState *)handle;

    ASSERT(pThreadEnumeration != NULL);
    ResetRPCServerDebugInfo(pThreadEnumeration->cellEnum);
    return RPC_S_OK;
}

/////////////////////////////////////////////////////
typedef struct tagRPCDebugClientCallInfoEnumState
{
    DWORD CallID;
    DWORD IfStart;
    int ProcNum;
    DWORD ProcessID;
    union
        {
        // if ProcessID != 0, cellEnum is used (i.e. we have process wide enumeration
        // otherwise, systemWideEnum is used - we have system wide enumeration
        RPCSystemWideCellEnumerationHandle systemWideEnum;
        CellEnumerationHandle cellEnum;
        };
} RPCDebugClientCallInfoEnumState;

RPC_STATUS OpenRPCDebugClientCallInfoEnumeration(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                                                 IN int ProcNum OPTIONAL,
                                                 IN DWORD ProcessID OPTIONAL, 
                                                 OUT ClientCallInfoEnumerationHandle *pHandle)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration;
    RPC_STATUS Status;

    *pHandle = NULL;
    pCallEnumeration = new RPCDebugClientCallInfoEnumState;
    if (pCallEnumeration == NULL)
        return RPC_S_OUT_OF_MEMORY;

    pCallEnumeration->CallID = CallID;
    pCallEnumeration->IfStart = IfStart;
    pCallEnumeration->ProcessID = ProcessID;
    pCallEnumeration->ProcNum = ProcNum;

    if (ProcessID != 0)
        {
        Status = OpenRPCServerDebugInfo(ProcessID, &pCallEnumeration->cellEnum);
        if (Status == ERROR_FILE_NOT_FOUND)
            {
            delete pCallEnumeration;
            return RPC_S_DBG_NOT_AN_RPC_SERVER;
            }
        else if (Status != RPC_S_OK)
            {
            delete pCallEnumeration;
            return Status;
            }
        }
    else
        {
        Status = OpenRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        if (Status != RPC_S_OK)
            return Status;
        }

    *pHandle = (ClientCallInfoEnumerationHandle) pCallEnumeration;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCDebugClientCallInfo(IN ClientCallInfoEnumerationHandle handle, 
                                         OUT DebugClientCallInfo **NextCall,
                                         OUT DebugCallTargetInfo **NextCallTarget,
                                         OUT DebugCellID *CellID, OUT DWORD *ServerPID)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration = (RPCDebugClientCallInfoEnumState *)handle;
    RPC_STATUS Status;
    DebugClientCallInfo *CallInfo;
    DebugCallTargetInfo *CallTargetInfo;
    DebugCellUnion *NextCell;

    ASSERT(pCallEnumeration != NULL);
    ASSERT(NextCall != NULL);
    ASSERT(ServerPID != NULL);

    // loop until we find something or run out of cells/servers
    while (TRUE)
        {
        if (pCallEnumeration->ProcessID != 0)
            {
            *ServerPID = pCallEnumeration->ProcessID;
            NextCell = GetNextDebugCellInfo(pCallEnumeration->cellEnum, CellID);
            if (NextCell == NULL)
                return RPC_S_DBG_ENUMERATION_DONE;
            }
        else
            {
            Status = GetNextRPCSystemWideCell(pCallEnumeration->systemWideEnum, &NextCell, CellID, ServerPID);
            if (Status == RPC_S_INVALID_BOUND)
                return RPC_S_DBG_ENUMERATION_DONE;
            if (Status != RPC_S_OK)
                return Status;
            }
        // NextCell must be non-NULL here, or we have a bug
        ASSERT(NextCell != NULL);

        if (NextCell->callInfo.Type != dctClientCallInfo)
            continue;

        CallInfo = &NextCell->clientCallInfo;

        if ((pCallEnumeration->CallID != 0) && (CallInfo->CallID != pCallEnumeration->CallID))
            continue;

        if ((pCallEnumeration->IfStart != 0) && (CallInfo->IfStart != pCallEnumeration->IfStart))
            continue;

        if (((USHORT)pCallEnumeration->ProcNum != (USHORT)RPCDBG_NO_PROCNUM_SPECIFIED) 
            && (CallInfo->ProcNum != pCallEnumeration->ProcNum))
            continue;

        if (pCallEnumeration->ProcessID != 0)
            {
            CallTargetInfo = (DebugCallTargetInfo *) GetCellByDebugCellID(pCallEnumeration->cellEnum, 
                NextCell->clientCallInfo.CallTargetID);
            }
        else
            {
            CallTargetInfo = (DebugCallTargetInfo *) GetRPCSystemWideCellFromCellID(pCallEnumeration->systemWideEnum,
                NextCell->clientCallInfo.CallTargetID);
            }

        // if we have survived all checks until now, we have found it - return it
        *NextCall = CallInfo;
        *NextCallTarget = CallTargetInfo;
        return RPC_S_OK;
        }
}

void FinishRPCDebugClientCallInfoEnumeration(IN OUT ClientCallInfoEnumerationHandle *pHandle)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration;

    ASSERT(pHandle != NULL);
    pCallEnumeration = (RPCDebugClientCallInfoEnumState *)*pHandle;
    ASSERT(pCallEnumeration != NULL);

    if (pCallEnumeration->ProcessID != 0)
        {
        CloseRPCServerDebugInfo(&pCallEnumeration->cellEnum);
        }
    else
        {
        FinishRPCSystemWideCellEnumeration(&pCallEnumeration->systemWideEnum);
        }
}

RPC_STATUS ResetRPCDebugClientCallInfoEnumeration(IN CallInfoEnumerationHandle handle)
{
    RPCDebugClientCallInfoEnumState *pCallEnumeration = (RPCDebugClientCallInfoEnumState *)handle;

    ASSERT(pCallEnumeration != NULL);
    if (pCallEnumeration->ProcessID != 0)
        {
        ResetRPCServerDebugInfo(pCallEnumeration->cellEnum);
        return RPC_S_OK;
        }
    else
        {
        return ResetRPCSystemWideCellEnumeration(pCallEnumeration->systemWideEnum);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbglib\secname.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SecName.cxx

Abstract:

    Function(s) for manipulating the section name

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>

void GenerateSectionName(OUT RPC_CHAR *Buffer, IN int BufferLength, 
    IN DWORD ProcessID, IN DWORD *pSectionNumbers OPTIONAL)
{
    RPC_CHAR *CurrentPosition;
    
    ASSERT(BufferLength >= RpcSectionNameMaxSize);

    RpcpStringCopy(Buffer, RpcSectionPrefix);
    CurrentPosition = Buffer + RpcSectionPrefixSize;

    // add the PID
    _ultow(ProcessID, CurrentPosition, 16);

    if (pSectionNumbers)
        {
        // find the end of the conversion
        while (*CurrentPosition != 0)
            CurrentPosition ++;

        // add the first portion of the section number
        _ultow(pSectionNumbers[0], CurrentPosition, 16);
        // find the end of the conversion
        while (*CurrentPosition != 0)
            CurrentPosition ++;

        // add the second portion of the section number
        _ultow(pSectionNumbers[1], CurrentPosition, 16);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dll\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=rpcrt4
TARGETTYPE=DYNLINK
TARGETPATH=obj

DLLDEF=$(O)\rpcrt4.def

MSC_WARNING_LEVEL=/WX /W3

SOURCES=             \
        ..\rpcrt4.rc

RPCENV=$(RPCENV) -DNTENV -DWIN32RPC -DNTWIN32RPC

C_DEFINES= $(C_DEFINES) $(RPCENV) $(RPCTARGETENV) /DMSWMSG -DEXPORT_RT -DEXPORT_NDR

!if $(IA64) || $(AMD64)
BUILD_NDR64=1
!endif

!ifdef BUILD_NDR64FAKE
BUILD_NDR64=1
!endif


!ifdef BUILD_NDR64
C_DEFINES= $(C_DEFINES) -DEXPORT_NDR64
!endif

DLLENTRY=InitializeDLL
TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\advapi32.lib \
            $(DS_LIB_PATH)\rsa32.lib       \
            $(DS_LIB_PATH)\randlib.lib  \

RPCRUNTIME=..\..

LINKLIBS= \
         $(LINKLIBS) \
         $(RPCRUNTIME)\mtrt\$(ALT_PROJECT)\$(O)\rpcmtrt.lib    \
         $(PROJECT_ROOT)\lib\$(O)\RpcDbg.lib \
         $(RPCRUNTIME)\rtifs\$(O)\rtifs.lib     \
         $(RPCRUNTIME)\..\ndrlib\daytona\$(O)\rpcndrp.lib \
         $(RPCRUNTIME)\..\ndr20\daytona\$(O)\rpcndr20.lib \
         $(RPCRUNTIME)\CharConv\$(CHARCONV_DIR)\$(O)\CharConv.lib \
         $(RPCRUNTIME)\trans\common\$(CHARCONV_DIR)\$(O)\rpctrans.lib \

!ifdef BUILD_NDR64
LINKLIBS=$(LINKLIBS) \
         $(RPCRUNTIME)\..\ndr64\ndr64\$(O)\rpcndr64.lib
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbglib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=RpcDbg
TARGETTYPE=LIBRARY
# TARGETPATH in daytona\sources and wow6432\sources.

INCLUDES=..\;..\..\mtrt;..\..\inc;..\..\CharConv;$(INCLUDES);..\..\rtifs\$(O)

BLDCRT=1

#
# Setup for application developer to set breakpoints with windbg
#

MSC_WARNING_LEVEL=/W3 /WX

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_CXX=1

SOURCES=$(SOURCES)   \
        CellUtil.cxx \
        DbgInit.cxx  \
        DbgPrint.cxx \
        SecName.cxx  \
        SecUtil.cxx  \
        SvrUtil.cxx

RPCENV= $(RPCENV) -DWIN32RPC -DNTWIN32RPC -D_RPCRT4_

C_DEFINES=$(RPCENV) $(RPCTARGETENV) /DMSWMSG -D_RPCRT4_

# Used only for unit tests
#USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbglib\secutil.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SecUtil.cxx

Abstract:

    Utility functions for manipulating cell sections

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>

RPC_STATUS OpenDbgSection(OUT HANDLE *pHandle, OUT PVOID *pSection, 
    IN DWORD ProcessID, IN DWORD *pSectionNumbers OPTIONAL)
{
    UNICODE_STRING SectionNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS NtStatus;
    RPC_CHAR SectionName[RpcSectionNameMaxSize];

    GenerateSectionName(SectionName, sizeof(SectionName), ProcessID, pSectionNumbers);
    RtlInitUnicodeString(&SectionNameString, SectionName);

    InitializeObjectAttributes(&ObjectAttributes,
        &SectionNameString,
        OBJ_CASE_INSENSITIVE,
        0,
        0);

    NtStatus = NtOpenSection(pHandle, FILE_MAP_READ, &ObjectAttributes);
    if (!NT_SUCCESS(NtStatus))
        {
        if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND)
            return ERROR_FILE_NOT_FOUND;
        else if (NtStatus == STATUS_ACCESS_DENIED)
            return ERROR_ACCESS_DENIED;
        return RPC_S_OUT_OF_MEMORY;
        }

    *pSection = MapViewOfFileEx(*pHandle, FILE_MAP_READ, 0, 0, 0, NULL);
    if (*pSection == NULL)
        {
        CloseHandle(*pHandle);
        *pHandle = NULL;
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}

void CloseDbgSection(IN HANDLE SecHandle, PVOID SecPointer)
{
    BOOL fResult;

    ASSERT(SecHandle != NULL);
    ASSERT(SecPointer != NULL);

    fResult = UnmapViewOfFile(SecPointer);
    ASSERT(fResult);

    fResult = CloseHandle(SecHandle);
    ASSERT(fResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbglib\dbgprint.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DbgPrint.cxx

Abstract:

    Functions for printing debug information

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpctrans.hxx>

void PrintTimeInSeconds(RPC_CHAR *HeaderString, DWORD TimeInMilliseconds, 
                        PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("%S (in seconds since boot):%d.%d (0x%X.%X)\n", HeaderString,
        TimeInMilliseconds / 1000, TimeInMilliseconds % 1000,
        TimeInMilliseconds / 1000, TimeInMilliseconds % 1000);
}

void PrintDebugCellID(RPC_CHAR *HeaderString, DebugCellID CellID,
                      PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("%S: 0x%X.%X\n", HeaderString, CellID.SectionID, CellID.CellID);    
}

const RPC_CHAR *CallStatusStrings[] = {L"Allocated", L"Active", L"Dispatched"};
#define UnknownValueLiteral (L"Unknown/Invalid")
const RPC_CHAR *UnknownValue = UnknownValueLiteral;

const RPC_CHAR *ConnectionAuthLevelStrings[] = {L"Default", L"None", L"Connect", L"Call", L"Packet",
            L"Packet Integrity", L"Packet Privacy", UnknownValueLiteral, UnknownValueLiteral};

const RPC_CHAR *ConnectionAuthServiceStrings[] = {L"None", L"NTLM", L"Kerberos/Snego", L"Other"};

const RPC_CHAR *ProtocolSequenceStrings[] = {L"TCP", L"UDP", L"LRPC", UnknownValueLiteral, UnknownValueLiteral,
    L"SPX", UnknownValueLiteral, L"IPX", L"NMP", UnknownValueLiteral, UnknownValueLiteral, L"NB", 
    UnknownValueLiteral, UnknownValueLiteral, UnknownValueLiteral, L"DSP", L"DDP", UnknownValueLiteral, 
    UnknownValueLiteral, L"SPP", UnknownValueLiteral, UnknownValueLiteral, 
    L"MQ", UnknownValueLiteral, L"HTTP"};

const int FirstProtocolSequenceTowerID = TCP_TOWER_ID;
const int LastProtocolSequenceTowerID = HTTP_TOWER_ID;

RPC_CHAR *GetProtocolSequenceString(int ProtocolSequenceID)
{
    RPC_CHAR *CurrentString;

    if ((ProtocolSequenceID < FirstProtocolSequenceTowerID) 
        || (ProtocolSequenceID > LastProtocolSequenceTowerID))
        {
        CurrentString = (RPC_CHAR *) UnknownValue;
        }
    else
        {
        CurrentString = (RPC_CHAR *) ProtocolSequenceStrings[
            ProtocolSequenceID - FirstProtocolSequenceTowerID];
        }

    ASSERT(CurrentString != NULL);
    return CurrentString;
}

void PrintCallInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   ST PNO IFSTART  THRDCELL  CALLFLAG CALLID   LASTTIME CONN/CLN\n");
    PrintRoutine("----------------------------------------------------------------------------\n");
}

void PrintCallInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                       IN DebugCallInfo *CallInfo, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("%04x %04x.%04x %02x %03x %08lx %04x.%04x %08lx %08lx %08lx ",
        ProcessID, CellID.SectionID, CellID.CellID, CallInfo->Status, 
        CallInfo->ProcNum, CallInfo->InterfaceUUIDStart,
        CallInfo->ServicingTID.SectionID, CallInfo->ServicingTID.CellID,
        CallInfo->CallFlags, CallInfo->CallID, CallInfo->LastUpdateTime);
    if (CallInfo->CallFlags & DBGCELL_LRPC_CALL)
        {
        PrintRoutine("%04x.%04x\n", (DWORD)CallInfo->PID, (DWORD)CallInfo->TID);
        }
    else
        {
        PrintRoutine("%04x.%04x\n", (DWORD)CallInfo->Connection.SectionID, 
            (DWORD)CallInfo->Connection.CellID);
        }
}

void GetAndPrintCallInfo(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                         IN int ProcNum OPTIONAL, IN DWORD ProcessID OPTIONAL,
                         PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    CallInfoEnumerationHandle h;
    RPC_STATUS Status;
    DebugCallInfo *NextCall;
    DebugCellID CellID;
    DWORD CurrentPID;

    PrintRoutine("Searching for call info ...\n");
    Status = OpenRPCDebugCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintCallInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugCallInfo(h, &NextCall, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            PrintCallInfoBody(CurrentPID, CellID, NextCall, PrintRoutine);
            /*
            // print the information we obtained
            PrintRoutine("%04x %04x.%04x %02x %03x %08lx %04x.%04x %08lx %08lx %08lx ",
                CurrentPID, CellID.SectionID, CellID.CellID, NextCall->Status, 
                NextCall->ProcNum, NextCall->InterfaceUUIDStart,
                NextCall->ServicingTID.SectionID, NextCall->ServicingTID.CellID,
                NextCall->CallFlags, NextCall->CallID, NextCall->LastUpdateTime);
            if (NextCall->CallFlags & DBGCELL_LRPC_CALL)
                {
                PrintRoutine("%04x.%04x\n", (DWORD)NextCall->PID, (DWORD)NextCall->TID);
                }
            else
                {
                PrintRoutine("%04x.%04x\n", (DWORD)NextCall->Connection.SectionID, 
                    (DWORD)NextCall->Connection.CellID);
                }
                */
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugCallInfoEnumeration(&h);    
}

void PrintDbgCellInfo(IN DebugCellUnion *Container, IN DebugCellUnion *EndpointContainer OPTIONAL,
                      PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    RPC_CHAR *CurrentString;
    DWORD LocalFlags;
    BOOL fFirstTime;
    char EndpointString[DebugEndpointNameLength + 1];
    int ConnectionAuthLevel;
    int ConnectionAuthService;
    HANDLE LocalIPAddress;
    HANDLE LocalIPAddress2;
    int i;
    HANDLE LocalIPAddressElement;
    HANDLE LocalSessionID;

    switch(Container->genericCell.Type)
        {
        case dctFree:
            PrintRoutine("Free cell\n");
            break;

        case dctCallInfo:
            PrintRoutine("Call\n");
            if ((Container->callInfo.Status < CallStatusFirst)
                || (Container->callInfo.Status > CallStatusLast))
                {
                CurrentString = (RPC_CHAR *)UnknownValue;
                }
            else
                {
                CurrentString = (RPC_CHAR *)CallStatusStrings[Container->callInfo.Status];
                }
            PrintRoutine("Status: %S\n", CurrentString);
            PrintRoutine("Procedure Number: %d\n", Container->callInfo.ProcNum);
            PrintRoutine("Interface UUID start (first DWORD only): %X\n", Container->callInfo.InterfaceUUIDStart);
            PrintRoutine("Call ID: 0x%x (%d)\n", Container->callInfo.CallID, Container->callInfo.CallID);
            PrintDebugCellID(L"Servicing thread identifier", Container->callInfo.ServicingTID, PrintRoutine);
            PrintRoutine("Call Flags:");
            LocalFlags = Container->callInfo.CallFlags;
            fFirstTime = TRUE;
            if (LocalFlags & DBGCELL_CACHED_CALL)
                {
                PrintRoutine(" cached");
                fFirstTime = FALSE;
                }

            if (LocalFlags & DBGCELL_ASYNC_CALL)
                {
                if (fFirstTime == FALSE)
                    {
                    PrintRoutine(", ");
                    }
                PrintRoutine("async");
                fFirstTime = FALSE;
                }

            if (LocalFlags & DBGCELL_PIPE_CALL)
                {
                if (fFirstTime == FALSE)
                    {
                    PrintRoutine(", ");
                    }
                PrintRoutine("pipe");
                fFirstTime = FALSE;
                }

            if (LocalFlags & DBGCELL_LRPC_CALL)
                {
                if (fFirstTime == FALSE)
                    {
                    PrintRoutine(", ");
                    }
                PrintRoutine("LRPC");
                fFirstTime = FALSE;
                }

            if (fFirstTime == TRUE)
                {
                PrintRoutine("none");
                }
            PrintRoutine("\n");

            PrintTimeInSeconds(L"Last update time", Container->callInfo.LastUpdateTime, PrintRoutine);

            if (LocalFlags & DBGCELL_LRPC_CALL)
                {
                PrintRoutine("Caller (PID/TID) is: %x.%x (%d.%d)\n", Container->callInfo.PID, 
                    Container->callInfo.TID, Container->callInfo.PID, Container->callInfo.TID);
                }
            else
                PrintDebugCellID(L"Owning connection identifier", Container->callInfo.Connection, PrintRoutine);

            break;

        case dctThreadInfo:
            PrintRoutine("Thread\n");
            PrintRoutine("Status: ");
            switch (Container->threadInfo.Status)
                {
                case dtsProcessing:
                    PrintRoutine("Processing\n");
                    break;

                case dtsDispatched:
                    PrintRoutine("Dispatched\n");
                    break;

                case dtsAllocated:
                    PrintRoutine("Allocated\n");
                    break;

                case dtsIdle:
                    PrintRoutine("Idle\n");
                    break;

                default:
                    PrintRoutine("Unknown (%d)\n", Container->threadInfo.Status);
                }
            PrintRoutine("Thread ID: 0x%X (%d)\n", Container->threadInfo.TID, Container->threadInfo.TID);
            if ((Container->threadInfo.Endpoint.CellID == 0) && (Container->threadInfo.Endpoint.SectionID == 0))
                {
                PrintRoutine("Thread is an IO completion thread\n");
                }
            else
                {
                PrintDebugCellID(L"Associated Endpoint:", Container->threadInfo.Endpoint, PrintRoutine);
                }
            PrintTimeInSeconds(L"Last update time", Container->threadInfo.LastUpdateTime, PrintRoutine);
            break;

        case dctEndpointInfo:
            PrintRoutine("Endpoint\n");
            PrintRoutine("Status: ");
            switch (Container->endpointInfo.Status)
                {
                case desAllocated:
                    PrintRoutine("Allocated\n");
                    break;

                case desActive:
                    PrintRoutine("Active\n");
                    break;

                case desInactive:
                    PrintRoutine("Inactive\n");
                    break;

                default:
                    PrintRoutine("Unknown (%d)\n", Container->endpointInfo.Status);

                }

            CurrentString = GetProtocolSequenceString(Container->endpointInfo.ProtseqType);
            PrintRoutine("Protocol Sequence: %S\n", CurrentString);
            memcpy(EndpointString, Container->endpointInfo.EndpointName, 
                sizeof(Container->endpointInfo.EndpointName));
            EndpointString[DebugEndpointNameLength] = 0;
            PrintRoutine("Endpoint name: %s\n", EndpointString);
            break;

        case dctClientCallInfo:
            PrintRoutine("Client call info\n");
            PrintRoutine("Procedure number: %d\n", Container->clientCallInfo.ProcNum);
            PrintRoutine("Interface UUID start (first DWORD only): %X\n", Container->clientCallInfo.IfStart);
            PrintRoutine("Call ID: 0x%x (%d)\n", Container->clientCallInfo.CallID, 
                Container->clientCallInfo.CallID);
            PrintDebugCellID(L"Calling thread identifier", Container->clientCallInfo.ServicingThread, 
                PrintRoutine);
            PrintDebugCellID(L"Call target identifier", Container->clientCallInfo.CallTargetID, PrintRoutine);

            ASSERT(sizeof(Container->clientCallInfo.Endpoint) < sizeof(EndpointString));

            memcpy(EndpointString, Container->clientCallInfo.Endpoint, sizeof(Container->clientCallInfo.Endpoint));
            EndpointString[ClientCallEndpointLength] = 0;
            PrintRoutine("Call target endpoint: %s\n", EndpointString);
            break;

        case dctCallTargetInfo:
            PrintRoutine("Call target info\n");
            CurrentString = GetProtocolSequenceString(Container->callTargetInfo.ProtocolSequence);
            PrintRoutine("Protocol Sequence: %S\n", CurrentString);
            PrintTimeInSeconds(L"Last update time", Container->callTargetInfo.LastUpdateTime, PrintRoutine);
            
            ASSERT(sizeof(Container->callTargetInfo.TargetServer) < sizeof(EndpointString));

            memcpy(EndpointString, Container->callTargetInfo.TargetServer, 
                sizeof(Container->callTargetInfo.TargetServer));
            EndpointString[sizeof(Container->callTargetInfo.TargetServer)] = 0;
            PrintRoutine("Target server is: %s\n", EndpointString);
            break;

        case dctConnectionInfo:
            PrintRoutine("Connection\n");
            LocalFlags = Container->connectionInfo.Flags;
            fFirstTime = TRUE;
            PrintRoutine("Connection flags: ");

            if (LocalFlags & 1)
                {
                PrintRoutine("Exclusive\n");
                }
            else
                {
                PrintRoutine("None\n");
                }

            ConnectionAuthLevel = 
                (Container->connectionInfo.Flags & ConnectionAuthLevelMask) >> ConnectionAuthLevelShift;
            ConnectionAuthService = 
                (Container->connectionInfo.Flags & ConnectionAuthServiceMask) >> ConnectionAuthServiceShift;

            PrintRoutine("Authentication Level: %S\n", ConnectionAuthLevelStrings[ConnectionAuthLevel]);

            PrintRoutine("Authentication Service: %S\n", ConnectionAuthServiceStrings[ConnectionAuthService]);

            PrintRoutine("Last Transmit Fragment Size: %d (0x%X)\n", 
                Container->connectionInfo.LastTransmitFragmentSize);

            PrintDebugCellID(L"Endpoint for the connection", Container->connectionInfo.Endpoint, PrintRoutine);

            PrintTimeInSeconds(L"Last send time", Container->connectionInfo.LastSendTime, PrintRoutine);
            PrintTimeInSeconds(L"Last receive time", Container->connectionInfo.LastReceiveTime, PrintRoutine);
            PrintRoutine("Getting endpoint info ...\n");

            switch(EndpointContainer->endpointInfo.ProtseqType)
                {
                case TCP_TOWER_ID:
                case UDP_TOWER_ID:
                case HTTP_TOWER_ID:
                    // IP address of some sort
                    PrintRoutine("Caller is");
                    LocalIPAddress = Container->connectionInfo.ConnectionID[1];
                    LocalIPAddress2 = Container->connectionInfo.ConnectionID[0];
                    if (LocalIPAddress2 == 0)
                        {
                        PrintRoutine("(IPv4): ");
                        for (i = 0; i < 4; i ++)
                            {
                            LocalIPAddressElement = (HANDLE)((ULONGLONG)LocalIPAddress & 0xFF);
                            LocalIPAddress = (HANDLE)((ULONGLONG)LocalIPAddress >> 8);
                            PrintRoutine("%d", HandleToUlong(LocalIPAddressElement));
                            if (i < 3)
                                {
                                PrintRoutine(".");
                                }
                            else
                                {
                                PrintRoutine("\n");
                                }
                            }
                        }
                    else
                        {
                        PrintRoutine("(IPv6 - last two DWORDS): ");
                        PrintRoutine("%d::%d\n", HandleToUlong(LocalIPAddress2), HandleToULong(LocalIPAddress));
                        }
                    break;

                case NMP_TOWER_ID:
                    LocalSessionID = Container->connectionInfo.ConnectionID[0];
                    if (LocalSessionID)
                        {
                        PrintRoutine("Cannot determine caller for remote named pipes\n");
                        }
                    else
                        {
                        LocalSessionID = Container->connectionInfo.ConnectionID[1];
                        PrintRoutine("Process object for caller is 0x%X\n", LocalSessionID);
                        }
                    break;

                default:
                    CurrentString = GetProtocolSequenceString(EndpointContainer->endpointInfo.ProtseqType);
                    PrintRoutine("Cannot determine caller for this type of protocol sequence %S (%d)\n", 
                        CurrentString, EndpointContainer->endpointInfo.ProtseqType);
                }
            break;

        case dctUsedGeneric:
            break;

        default:
            PrintRoutine("Invalid cell type: %d\n", Container->genericCell.Type);

        }
}

void GetAndPrintDbgCellInfo(DWORD ProcessID, DebugCellID CellID,
                            PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DebugCellUnion Container;
    DebugCellUnion EndpointContainer;
    RPC_STATUS Status;

    PrintRoutine("Getting cell info ...\n");
    Status = GetCellByDebugCellID(ProcessID, CellID, &Container);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("Getting cell info failed with error %d\n", Status);
        return;
        }

    if (Container.genericCell.Type == dctConnectionInfo)
        {
        Status = GetCellByDebugCellID(ProcessID, Container.connectionInfo.Endpoint, &EndpointContainer);
        if (Status != RPC_S_OK)
            {
            PrintRoutine("Getting endpoint info failed with error %d\n", Status);
            return;
            }
        }

    PrintDbgCellInfo(&Container, &EndpointContainer, PrintRoutine);
}

void PrintEndpointInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   ST PROTSEQ        ENDPOINT                    \n");
    PrintRoutine("-------------------------------------------------------------\n");
}

void PrintEndpointInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                           IN DebugEndpointInfo *EndpointInfo, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    RPC_CHAR *ProtseqName;
    char CurrentEndpoint[DebugEndpointNameLength + 1];

    ProtseqName = GetProtocolSequenceString(EndpointInfo->ProtseqType);
    CurrentEndpoint[DebugEndpointNameLength] = 0;
    memcpy(CurrentEndpoint, EndpointInfo->EndpointName, DebugEndpointNameLength);
    // print the information we obtained
    PrintRoutine("%04x %04x.%04x %02x %14S %s\n",
        ProcessID, CellID.SectionID, CellID.CellID, EndpointInfo->Status, 
        ProtseqName, CurrentEndpoint);
}

void GetAndPrintEndpointInfo(IN char *Endpoint OPTIONAL, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DWORD CurrentPID;
    RPC_STATUS Status;
    DebugEndpointInfo *NextEndpoint;
    EndpointInfoEnumerationHandle h;
    DebugCellID CellID;

    PrintRoutine("Searching for endpoint info ...\n");
    Status = OpenRPCDebugEndpointInfoEnumeration(Endpoint, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugEndpointInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintEndpointInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugEndpointInfo(h, &NextEndpoint, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            PrintEndpointInfoBody(CurrentPID, CellID, NextEndpoint, PrintRoutine);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugEndpointInfoEnumeration(&h);    
}

void PrintThreadInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   ST TID      ENDPOINT  LASTTIME\n");
    PrintRoutine("---------------------------------------------\n");
}

void PrintThreadInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                         IN DebugThreadInfo *ThreadInfo, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    // print the information we obtained
    PrintRoutine("%04x %04x.%04x %02x %08x %04x.%04x %08x\n",
        ProcessID, CellID.SectionID, CellID.CellID, ThreadInfo->Status, 
        ThreadInfo->TID, ThreadInfo->Endpoint.SectionID,
        ThreadInfo->Endpoint.CellID, ThreadInfo->LastUpdateTime);
}

void GetAndPrintThreadInfo(DWORD ProcessID, DWORD ThreadID OPTIONAL, PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DebugThreadInfo *NextThread;
    RPC_STATUS Status;
    ThreadInfoEnumerationHandle h;
    DebugCellID CellID;
    DWORD CurrentPID;

    PrintRoutine("Searching for thread info ...\n");
    Status = OpenRPCDebugThreadInfoEnumeration(ProcessID, ThreadID, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugThreadInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintThreadInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugThreadInfo(h, &NextThread, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            PrintThreadInfoBody(CurrentPID, CellID, NextThread, PrintRoutine);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugThreadInfoEnumeration(&h);    
}

void PrintClientCallInfoHeader(PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    PrintRoutine("PID  CELL ID   PNO  IFSTART  TIDNUMBER CALLID   LASTTIME PS CLTNUMBER ENDPOINT\n");
    PrintRoutine("------------------------------------------------------------------------------\n");
}

void PrintClientCallInfoBody(IN DWORD ProcessID, IN DebugCellID CellID, 
                             IN DebugClientCallInfo *ClientCallInfo, 
                             IN DebugCallTargetInfo *CallTargetInfo,
                             PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    char TempString[DebugEndpointNameLength + 1];

    ASSERT(sizeof(TempString) > sizeof(CallTargetInfo->TargetServer));
    ASSERT(sizeof(TempString) > sizeof(ClientCallInfo->Endpoint));

    memcpy(TempString, ClientCallInfo->Endpoint, sizeof(ClientCallInfo->Endpoint));
    TempString[sizeof(ClientCallInfo->Endpoint)] = 0;

    // print the information we obtained
    PrintRoutine("%04x %04x.%04x %04x %08lx %04x.%04x %08lx %08lx %02x %04x.%04x %s\n",
        ProcessID, CellID.SectionID, CellID.CellID, ClientCallInfo->ProcNum, 
        ClientCallInfo->IfStart, ClientCallInfo->ServicingThread.SectionID,
        ClientCallInfo->ServicingThread.CellID, ClientCallInfo->CallID,
        CallTargetInfo->LastUpdateTime, CallTargetInfo->ProtocolSequence, 
        ClientCallInfo->CallTargetID.SectionID, ClientCallInfo->CallTargetID.CellID,
        TempString);

}

void GetAndPrintClientCallInfo(IN DWORD CallID OPTIONAL, IN DWORD IfStart OPTIONAL, 
                         IN int ProcNum OPTIONAL, IN DWORD ProcessID OPTIONAL,
                         PRPCDEBUG_OUTPUT_ROUTINE PrintRoutine)
{
    DWORD CurrentPID;
    DebugCellID CellID;

    DebugClientCallInfo *NextClientCall;
    DebugCallTargetInfo *NextCallTarget;

    RPC_STATUS Status;
    CallInfoEnumerationHandle h;

    PrintRoutine("Searching for call info ...\n");
    Status = OpenRPCDebugClientCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &h);
    if (Status != RPC_S_OK)
        {
        PrintRoutine("OpenRPCDebugClientCallInfoEnumeration failed: %d\n", Status);
        return;
        }

    PrintClientCallInfoHeader(PrintRoutine);
    do
        {
        Status = GetNextRPCDebugClientCallInfo(h, &NextClientCall, &NextCallTarget, &CellID, &CurrentPID);
        if (Status == RPC_S_OK)
            {
            if ((NextCallTarget != NULL) && (NextCallTarget->Type != dctCallTargetInfo))
                {
                PrintRoutine("Inconsistent information detected - skipping ...\n");
                continue;
                }

            PrintClientCallInfoBody(CurrentPID, CellID, NextClientCall, NextCallTarget,
                PrintRoutine);
            }
        }
    while (Status == RPC_S_OK);

    if (Status != RPC_S_DBG_ENUMERATION_DONE)
        {
        PrintRoutine("Enumeration aborted with error %d\n", Status);
        }

    FinishRPCDebugClientCallInfoEnumeration(&h);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\dbglib\svrutil.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    SvrUtil.cxx

Abstract:

    Utility functions for querying RPC Server debug data

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <DbgLib.hxx>

typedef struct tagServerEnumerationState
{
    int CurrentPosition;
    int NumberOfProcesses;
    // the actual size is NumberOfProcesses
    ULONG ProcessUniqueId[1];
} ServerEnumerationState;

RPC_STATUS StartServerEnumeration(ServerEnumerationHandle *pHandle)
{
    ServerEnumerationState *pNewState;
    void *pProcessDataBuffer = NULL;
    NTSTATUS NtStatus;
    int CurrentAllocatedSize = 0x6000;
    SYSTEM_PROCESS_INFORMATION *pCurrentProcessInfo;
    unsigned char *pCurrentPos;
    int NumberOfProcesses;
    int i;
    BOOL fResult;

    do
        {
        if (pProcessDataBuffer)
            {
            fResult = VirtualFree(pProcessDataBuffer, 0, MEM_RELEASE);
            ASSERT(fResult);
            }

        CurrentAllocatedSize += 4096 * 2;
        pProcessDataBuffer = VirtualAlloc(NULL, CurrentAllocatedSize, MEM_COMMIT, PAGE_READWRITE);
        if (pProcessDataBuffer == NULL)
            return RPC_S_OUT_OF_MEMORY;

        NtStatus = NtQuerySystemInformation(SystemProcessInformation, pProcessDataBuffer,
            CurrentAllocatedSize, NULL);
        }
    while (NtStatus == STATUS_INFO_LENGTH_MISMATCH);

    if (!NT_SUCCESS(NtStatus))
        return RPC_S_OUT_OF_MEMORY;

    // walk the buffer - on first pass, we just count the entries
    pCurrentPos = (unsigned char *)pProcessDataBuffer;
    pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
    NumberOfProcesses = 0;
    while (TRUE)
        {
        // we skip idle process and zombie processes
        if (pCurrentProcessInfo->UniqueProcessId != NULL)
            {
            NumberOfProcesses ++;
            }
        // is there a place to advance to?
        if (pCurrentProcessInfo->NextEntryOffset == 0)
            break;
        pCurrentPos += pCurrentProcessInfo->NextEntryOffset;
        pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
        }

    pNewState = (ServerEnumerationState *) new char [
        sizeof(ServerEnumerationState) + (NumberOfProcesses - 1) * sizeof(ULONG)];
    // implicit placement
//    pNewState = new ((NumberOfProcesses - 1) * sizeof(ULONG)) ServerEnumerationState;
    if (pNewState == NULL)
        {
        fResult = VirtualFree(pProcessDataBuffer, 0, MEM_RELEASE);
        ASSERT(fResult);
        return RPC_S_OUT_OF_MEMORY;
        }

    new (pNewState) ServerEnumerationState;
    // make the second pass - actual copying of data
    pCurrentPos = (unsigned char *)pProcessDataBuffer;
    pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
    i = 0;
    while (TRUE)
        {
        // we skip idle process and zombie processes
        if (pCurrentProcessInfo->UniqueProcessId != NULL)
            {
            pNewState->ProcessUniqueId[i] = PtrToUlong(pCurrentProcessInfo->UniqueProcessId);
            i ++;
            }
        // is there a place to advance to?
        if (pCurrentProcessInfo->NextEntryOffset == 0)
            break;
        pCurrentPos += pCurrentProcessInfo->NextEntryOffset;
        pCurrentProcessInfo = (SYSTEM_PROCESS_INFORMATION *)pCurrentPos;
        }

    ASSERT(i == NumberOfProcesses);

    fResult = VirtualFree(pProcessDataBuffer, 0, MEM_RELEASE);
    ASSERT(fResult);

    // make the data available to the user
    pNewState->CurrentPosition = 0;
    pNewState->NumberOfProcesses = NumberOfProcesses;
    *pHandle = pNewState;
    return RPC_S_OK;
}

RPC_STATUS OpenNextRPCServer(IN ServerEnumerationHandle Handle, OUT CellEnumerationHandle *pHandle)
{
    ServerEnumerationState *ServerState = (ServerEnumerationState *)Handle;
    int CurrentPosition;
    RPC_STATUS RpcStatus;
    
    ASSERT(ServerState != NULL);
    ASSERT(pHandle != NULL);

    do
        {
        CurrentPosition = ServerState->CurrentPosition;

        if (CurrentPosition >= ServerState->NumberOfProcesses)
            return RPC_S_INVALID_BOUND;

        ServerState->CurrentPosition ++;
    
        RpcStatus = OpenRPCServerDebugInfo(ServerState->ProcessUniqueId[CurrentPosition], pHandle);
        }
    while(RpcStatus == ERROR_FILE_NOT_FOUND);

    return RpcStatus;
}

void ResetServerEnumeration(IN ServerEnumerationHandle Handle)
{
    ServerEnumerationState *ServerState = (ServerEnumerationState *)Handle;
    
    ASSERT(ServerState != NULL);
    ServerState->CurrentPosition = 0;
}

void FinishServerEnumeration(ServerEnumerationHandle *pHandle)
{
    ServerEnumerationState *ServerState;

    ASSERT (pHandle != NULL);
    ServerState = *(ServerEnumerationState **)pHandle;
    ASSERT(ServerState != NULL);
    delete ServerState;
    *pHandle = NULL;
}

DWORD GetCurrentServerPID(IN ServerEnumerationHandle Handle)
{
    ServerEnumerationState *ServerState = (ServerEnumerationState *)Handle;
    
    ASSERT(ServerState != NULL);
    // -1, because the CurrentPosition points to the next server
    return (DWORD)ServerState->ProcessUniqueId[ServerState->CurrentPosition - 1];
}

// a helper function
// whenever we detect an inconsistency in one of the lists,
// we can call this function, which will determine what to do
// with the current section, and will transfer sections between
// the OpenedSections list and the InconsistentSections list
void InconsistencyDetected(IN LIST_ENTRY *OpenedSections, IN LIST_ENTRY *InconsistentSections,
                           IN LIST_ENTRY *CurrentListEntry, IN OpenedDbgSection *pCurrentSection,
                           BOOL fExceptionOccurred)
{
    LIST_ENTRY *NextEntry;
    LIST_ENTRY *LastEntry;

    // if an exception occurred, throw away this section altogether
    if (fExceptionOccurred)
        {
        // save the next entry before we delete this one
        NextEntry = CurrentListEntry->Flink;
        RemoveEntryList(CurrentListEntry);
        CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
        delete pCurrentSection;

        CurrentListEntry = NextEntry;
        pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);

        // if the bad section was the last on the list,
        // there is nothing to add to the grab bag - just
        // return
        if (CurrentListEntry == OpenedSections)
            {
            return;
            }
        }

    // the chain is broken - we need to throw the rest of the list in
    // the grab bag
    // unchain this segment from the opened sections list
    LastEntry = OpenedSections->Blink;
    OpenedSections->Blink = CurrentListEntry->Blink;
    CurrentListEntry->Blink->Flink = OpenedSections;
    // chain the segment to the inconsistent sections list
    CurrentListEntry->Blink = InconsistentSections->Blink;
    InconsistentSections->Blink->Flink = CurrentListEntry;
    InconsistentSections->Blink = LastEntry;
    LastEntry->Flink = InconsistentSections;
}

RPC_STATUS OpenRPCServerDebugInfo(IN DWORD ProcessID, OUT CellEnumerationHandle *pHandle)
{
    RPC_STATUS RpcStatus;
    HANDLE SecHandle;
    PVOID SecPointer;
    int Retries = 10;
    BOOL fConsistentSnapshotObtained = FALSE;
    BOOL fNeedToRetry;
    CellSection *CurrentSection;
    DWORD SectionNumbers[2];
    OpenedDbgSection *pCurrentSection;
    // each section as it is opened, is linked on one of those lists
    // if the view of the sections is consistent, we link it to opened
    // sections. Otherwise, we link it to InconsistentSections
    LIST_ENTRY OpenedSections;
    LIST_ENTRY InconsistentSections;
    LIST_ENTRY *CurrentListEntry;
    DWORD *pActualSectionNumbers;
    BOOL fExceptionOccurred;
    LIST_ENTRY *LastEntry;
    BOOL fFound;
    int NumberOfCommittedPages;
    BOOL fConsistencyPass = FALSE;
    DWORD LocalPageSize;
    SectionsSnapshot *LocalSectionsSnapshot;
    BOOL fResult;

    RpcStatus = InitializeDbgLib();
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    LocalPageSize = GetPageSize();

    // loop until we obtain a consistent snapshot or we are out of 
    // retry attempts. We declare a snapshot to be consistent
    // if we manage to:
    //   - open all sections
    //   - copy their contents to a private memory location
    //   - verify that the section chain is still consistent after the copying
    // For this purpose, when we copy all the sections, we make one more
    // pass at the section chain to verify it is consistent using the special
    // flag fConsistencyPass.
    InconsistentSections.Blink = InconsistentSections.Flink = &InconsistentSections;
    OpenedSections.Blink = OpenedSections.Flink = &OpenedSections;

    while (Retries > 0)
        {
        // on entry to the loop, the state will be this - OpenSections will
        // contain a consistent view of the sections. Inconsistent sections
        // will be a grab bag of sections we could not bring into
        // consistent view. It's used as a cache to facilitate quick
        // recovery

        // we are just starting, or we are recovering from an inconsistency
        // found somewhere. As soon as somebody detects an inconsistency,
        // they will jump here. First thing is to try to establish what
        // part of the chain is consistent. Walk the open sections for
        // this purpose. We walk as far as we can, and then we declare
        // the rest of the sections inconsistent, and we throw them in
        // the grab bag
        SectionNumbers[0] = SectionNumbers[1] = 0;
        CurrentListEntry = OpenedSections.Flink;
        fNeedToRetry = FALSE;
        while (CurrentListEntry != &OpenedSections)
            {
            pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
            if ((SectionNumbers[0] != pCurrentSection->SectionNumbers[0])
                || (SectionNumbers[1] != pCurrentSection->SectionNumbers[1]))
                {
                fNeedToRetry = TRUE;
                }
            else
                {
                __try
                    {
                    // attempt to read the numbers of the next section
                    // we do this within try/except since server may free this
                    // memory and we will get toast
                    SectionNumbers[0] = pCurrentSection->SectionPointer->NextSectionId[0];
                    SectionNumbers[1] = pCurrentSection->SectionPointer->NextSectionId[1];

                    fExceptionOccurred = FALSE;

                    // note that the SectionNumbers array will be used after the end of
                    // the loop - make sure we don't whack them
                    }
                __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                    fExceptionOccurred = TRUE;
                    fNeedToRetry = TRUE;
                    }
                }

            if (fNeedToRetry)
                {
                // if this is the first section, the server went down. There is no
                // legal way for the server to have inconsistent first section
                if (CurrentListEntry == OpenedSections.Flink)
                    {
                    RpcStatus = ERROR_FILE_NOT_FOUND;
                    goto CleanupAndExit;
                    }

                InconsistencyDetected(&OpenedSections, &InconsistentSections, CurrentListEntry,
                    pCurrentSection, fExceptionOccurred);

                fNeedToRetry = TRUE;
                break;
                }

            CurrentListEntry = CurrentListEntry->Flink;
            }

        // walking is complete. Did we detect inconsistency?
        if (fNeedToRetry)
            {
            Retries --;
            fConsistencyPass = FALSE;
            continue;
            }
        else if (fConsistencyPass)
            {
            // this is the only place we break out of the loop -
            // the consistency pass has passed
            break;
            }

        // whatever we have in the opened sections list is consistent
        // if there was something in the list keep reading,
        // otherwise, start reading
        if (IsListEmpty(&OpenedSections))
            {
            pActualSectionNumbers = NULL;
            }
        else
            {
            pCurrentSection = CONTAINING_RECORD(OpenedSections.Blink, OpenedDbgSection, SectionsList);
            // we re-use the section numbers from the loop above. They can be 0 at
            // this point if the last section got dropped
            pActualSectionNumbers = SectionNumbers;
            }

        // make a pass over the sections, opening each one, but only if
        // case we're missing parts of the chain or this is the first time. 
        // Otherwise, skip this step
        while ((SectionNumbers[0] != 0) || (SectionNumbers[1] != 0) || (pActualSectionNumbers == NULL))
            {
            // we know which section we're looking for
            // first, search the grab bag. We can only do this for a non-first
            // section. The first section never goes to the grab bag
            // pActualSectionNumbers will contain the section we're looking for
            fFound = FALSE;
            if (pActualSectionNumbers)
                {
                CurrentListEntry = InconsistentSections.Flink;
                while (CurrentListEntry != &InconsistentSections)
                    {
                    pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
                    // it is impossible that a well behaving server will have
                    // opened a different section with the same numbers, because we
                    // keep the section object opened.
                    if ((pActualSectionNumbers[0] == pCurrentSection->SectionNumbers[0])
                        && (pActualSectionNumbers[1] == pCurrentSection->SectionNumbers[1]))
                        {
                        // found something
                        RemoveEntryList(CurrentListEntry);

                        // if we had already made a copy of this one, free it, as it is
                        // probably inconsistent
                        if (pCurrentSection->SectionCopy)
                            {
                            fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
                            ASSERT(fResult);
                            pCurrentSection->SectionCopy = NULL;
                            }
                        fFound = TRUE;
                        break;
                        }
                    CurrentListEntry = CurrentListEntry->Flink;
                    }
                }

            if (fFound == FALSE)
                {
                // nothing in the grab bag - try to open it the normal way
                RpcStatus = OpenDbgSection(&SecHandle, &SecPointer, ProcessID, pActualSectionNumbers);
                if (RpcStatus == ERROR_FILE_NOT_FOUND)
                    {
                    // if this is the first time, this is not a server - bail out
                    if (pActualSectionNumbers == NULL)
                        {
                        goto CleanupAndExit;
                        }

                    // not the first time - we have an inconsistent view - need to retry
                    fNeedToRetry = TRUE;
                    break;
                    }
                else if (RpcStatus != RPC_S_OK)
                    {
                    goto CleanupAndExit;
                    }

                pCurrentSection = new OpenedDbgSection;
                if (pCurrentSection == NULL)
                    {
                    RpcStatus = RPC_S_OUT_OF_MEMORY;
                    CloseDbgSection(SecHandle, SecPointer);
                    goto CleanupAndExit;
                    }

                pCurrentSection->SectionHandle = SecHandle;
                if (pActualSectionNumbers)
                    {
                    pCurrentSection->SectionNumbers[0] = pActualSectionNumbers[0];
                    pCurrentSection->SectionNumbers[1] = pActualSectionNumbers[1];
                    }
                else
                    {
                    pCurrentSection->SectionNumbers[0] = pCurrentSection->SectionNumbers[1] = 0;
                    }
                pCurrentSection->SectionPointer = (CellSection *) SecPointer;
                pCurrentSection->SectionCopy = NULL;
                }

            // either we have found this in the grab bag, or we have just opened it
            // both ways, try to get the section numbers we expect for the next section
            __try
                {
                // load the section numbers that we expect for the next iteration of the
                // loop
                SectionNumbers[0] = pCurrentSection->SectionPointer->NextSectionId[0];
                SectionNumbers[1] = pCurrentSection->SectionPointer->NextSectionId[1];
                pActualSectionNumbers = SectionNumbers;
                fExceptionOccurred = FALSE;
                }
            __except (EXCEPTION_EXECUTE_HANDLER)
                {
                fExceptionOccurred = TRUE;
                }

            if (fExceptionOccurred)
                {
                delete pCurrentSection;
                CloseDbgSection(SecHandle, SecPointer);
                fNeedToRetry = TRUE;
                break;
                }

            InsertTailList(&OpenedSections, &pCurrentSection->SectionsList);
            }

        if (fNeedToRetry)
            {
            Retries --;
            fConsistencyPass = FALSE;
            continue;
            }

        // at this point, we have opened all the sections
        // now we need to allocate memory for the snapshots and to do the copying
        CurrentListEntry = OpenedSections.Flink;
        while (CurrentListEntry != &OpenedSections)
            {
            pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
            __try
                {
                // do all the allocation and copying only if it hasn't been done yet
                if (pCurrentSection->SectionCopy == NULL)
                    {
                    NumberOfCommittedPages = pCurrentSection->SectionPointer->LastCommittedPage;
                    pCurrentSection->SectionCopy = (CellSection *)VirtualAlloc(NULL, 
                        NumberOfCommittedPages * LocalPageSize, MEM_COMMIT, PAGE_READWRITE);
                    if (pCurrentSection->SectionCopy == NULL)
                        {
                        RpcStatus = RPC_S_OUT_OF_MEMORY;
                        goto CleanupAndExit;
                        }
                    memcpy(pCurrentSection->SectionCopy, pCurrentSection->SectionPointer, 
                        NumberOfCommittedPages * LocalPageSize);
                    pCurrentSection->SectionID = pCurrentSection->SectionPointer->SectionID;
                    pCurrentSection->CommittedPagesInSection = NumberOfCommittedPages;
                    }
                fExceptionOccurred = FALSE;
                }
            __except (EXCEPTION_EXECUTE_HANDLER)
                {
                fExceptionOccurred = TRUE;
                }

            if (fExceptionOccurred)
                {
                if (pCurrentSection->SectionCopy)
                    {
                    fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
                    ASSERT(fResult);
                    pCurrentSection->SectionCopy = NULL;
                    }

                // the section got out of sync
                InconsistencyDetected(&OpenedSections, &InconsistentSections, CurrentListEntry,
                    pCurrentSection, fExceptionOccurred);
                fNeedToRetry = TRUE;
                break;
                }

            CurrentListEntry = CurrentListEntry->Flink;
            }

        if (fNeedToRetry)
            {
            Retries --;
            fConsistencyPass = FALSE;
            continue;
            }
        else
            {
            fConsistencyPass = TRUE;
            }
        }

        // if we managed to get a consistent view, unmap the shared sections and 
        // save the opened section list
        if (Retries != 0)
            {
            ASSERT(fConsistencyPass == TRUE);
            ASSERT(fNeedToRetry == FALSE);
            ASSERT(!IsListEmpty(&OpenedSections));

            CurrentListEntry = OpenedSections.Flink;
            while (CurrentListEntry != &OpenedSections)
                {
                pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);

                CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
                pCurrentSection->SectionHandle = NULL;
                pCurrentSection->SectionPointer = NULL;
                pCurrentSection->SectionNumbers[0] = pCurrentSection->SectionNumbers[1] = 0;

                CurrentListEntry = CurrentListEntry->Flink;
                }

            // save the opened section list
            CurrentListEntry = OpenedSections.Flink;
            pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
            LocalSectionsSnapshot = new SectionsSnapshot;
            if (LocalSectionsSnapshot != NULL)
                {
                LocalSectionsSnapshot->CellIndex = 0;
                LocalSectionsSnapshot->FirstOpenedSection = pCurrentSection;
                LocalSectionsSnapshot->CurrentOpenedSection = pCurrentSection;

                // unchain the opened sections
                // terminate the chain with NULL
                OpenedSections.Blink->Flink = NULL;
                OpenedSections.Blink = OpenedSections.Flink = &OpenedSections;

                // that's the only place where we return success
                *pHandle = (CellEnumerationHandle)LocalSectionsSnapshot;
                RpcStatus = RPC_S_OK;
                }
            else
                {
                // let the CleanupAndExit code destroy the lists
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                }
            }
        else
            {
            // we couldn't get a consistent snapshot of the server and
            // we ran out of retries
            RpcStatus = RPC_S_CANNOT_SUPPORT;
            }

CleanupAndExit:

    // walk the two lists, and free all sections on them
    CurrentListEntry = OpenedSections.Flink;
    while (CurrentListEntry != &OpenedSections)
        {
        pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
        // advance the pointer while we haven't freed the stuff
        CurrentListEntry = CurrentListEntry->Flink;
        if (pCurrentSection->SectionCopy)
            {
            fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
            ASSERT(fResult);
            }
        if (pCurrentSection->SectionHandle)
            {
            ASSERT(pCurrentSection->SectionPointer);
            CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
            }
        delete pCurrentSection;
        }

    CurrentListEntry = InconsistentSections.Flink;
    while (CurrentListEntry != &InconsistentSections)
        {
        pCurrentSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
        // advance the pointer while we haven't freed the stuff
        CurrentListEntry = CurrentListEntry->Flink;
        if (pCurrentSection->SectionCopy)
            {
            fResult = VirtualFree(pCurrentSection->SectionCopy, 0, MEM_RELEASE);
            ASSERT(fResult);
            }
        if (pCurrentSection->SectionHandle)
            {
            ASSERT(pCurrentSection->SectionPointer);
            CloseDbgSection(pCurrentSection->SectionHandle, pCurrentSection->SectionPointer);
            }
        delete pCurrentSection;
        }
    return RpcStatus;
}

DebugCellUnion *GetNextDebugCellInfo(IN CellEnumerationHandle Handle, OUT DebugCellID *CellID)
{
    SectionsSnapshot *Snapshot = (SectionsSnapshot *)Handle;
    OpenedDbgSection *CurrentSection, *NextSection;
    DebugCellGeneric *CurrentCell;
    int CurrentCellIndex;
    DebugCellGeneric *LastCellForCurrentSection;
    DWORD LocalPageSize = GetPageSize();

    ASSERT(Handle != NULL);

    CurrentSection = Snapshot->CurrentOpenedSection;
    LastCellForCurrentSection = GetLastCellForSection(CurrentSection, LocalPageSize);
    if (Snapshot->CellIndex == 0)
        {
#ifdef _WIN64
        Snapshot->CellIndex = 2;
#else
        Snapshot->CellIndex = 1;
#endif
        }
    CurrentCell = GetCellForSection(CurrentSection, Snapshot->CellIndex);

    while (TRUE)
        {
        // did we exhaust the current section?
        if (CurrentCell > LastCellForCurrentSection)
            {
            // try to advance to the next one
            if (CurrentSection->SectionsList.Flink)
                {
                CurrentSection = CONTAINING_RECORD(CurrentSection->SectionsList.Flink, 
                    OpenedDbgSection, SectionsList);
                Snapshot->CurrentOpenedSection = CurrentSection;
#ifdef _WIN64
                Snapshot->CellIndex = 2;
#else
                Snapshot->CellIndex = 1;
#endif
                LastCellForCurrentSection = GetLastCellForSection(CurrentSection, LocalPageSize);

                CurrentCell = GetCellForSection(CurrentSection, Snapshot->CellIndex);
                continue;
                }
            return NULL;
            }
        CellID->CellID = (USHORT) Snapshot->CellIndex;
        Snapshot->CellIndex ++;
        if ((CurrentCell->Type == dctCallInfo) || (CurrentCell->Type == dctThreadInfo) 
            || (CurrentCell->Type == dctEndpointInfo) || (CurrentCell->Type == dctClientCallInfo))
            {
            CellID->SectionID = (USHORT)CurrentSection->SectionID;
            return (DebugCellUnion *)CurrentCell;
            }
        CurrentCell = (DebugCellGeneric *)((unsigned char *)CurrentCell + sizeof(DebugFreeCell));
        }

    return NULL;
}

void ResetRPCServerDebugInfo(IN CellEnumerationHandle Handle)
{
    SectionsSnapshot *LocalSnapshot = (SectionsSnapshot *)Handle;

    ASSERT(Handle != NULL);
    LocalSnapshot->CellIndex = 0;
    LocalSnapshot->CurrentOpenedSection = LocalSnapshot->FirstOpenedSection;
}

void CloseRPCServerDebugInfo(IN CellEnumerationHandle *pHandle)
{
    SectionsSnapshot *LocalSnapshot;
    OpenedDbgSection *DbgSection;
    LIST_ENTRY *CurrentListEntry;

    ASSERT(pHandle != NULL);
    LocalSnapshot = (SectionsSnapshot *)*pHandle;
    ASSERT(LocalSnapshot != NULL);
    ASSERT(LocalSnapshot->FirstOpenedSection != NULL);

    DbgSection = LocalSnapshot->FirstOpenedSection;

    do
        {
        // advance while we can
        CurrentListEntry = DbgSection->SectionsList.Flink;

        // free the section
        ASSERT(DbgSection->SectionCopy);
        VirtualFree(DbgSection->SectionCopy, 0, MEM_RELEASE);
        delete DbgSection;

        // calculate next record. Note that this will not AV even if 
        // CurrentListEntry is NULL - this is just offset calculation
        DbgSection = CONTAINING_RECORD(CurrentListEntry, OpenedDbgSection, SectionsList);
        }
    while (CurrentListEntry != NULL);

    delete LocalSnapshot;

    *pHandle = NULL;
}

typedef struct tagRPCSystemWideCellEnumeration
{
    ServerEnumerationHandle serverHandle;
    CellEnumerationHandle cellHandle;
} RPCSystemWideCellEnumeration;

RPC_STATUS OpenRPCSystemWideCellEnumeration(OUT RPCSystemWideCellEnumerationHandle *pHandle)
{
    RPCSystemWideCellEnumeration *cellEnum;
    RPC_STATUS Status;
    DebugCellUnion *NextCell;

    ASSERT(pHandle != NULL);
    *pHandle = NULL;
    cellEnum = new RPCSystemWideCellEnumeration;
    if (cellEnum == NULL)
        return RPC_S_OUT_OF_MEMORY;

    cellEnum->cellHandle = NULL;
    cellEnum->serverHandle = NULL;

    Status = StartServerEnumeration(&cellEnum->serverHandle);
    if (Status != RPC_S_OK)
        {
        delete cellEnum;
        return Status;
        }

    Status = OpenNextRPCServer(cellEnum->serverHandle, &cellEnum->cellHandle);

    // if we're done, we will get RPC_S_SERVER_INVALID_BOUND - ok to 
    // just return to caller
    if (Status != RPC_S_OK)
        {
        FinishServerEnumeration(&cellEnum->serverHandle);
        delete cellEnum;
        return Status;
        }

    *pHandle = (RPCSystemWideCellEnumerationHandle) cellEnum;
    return RPC_S_OK;
}

RPC_STATUS GetNextRPCSystemWideCell(IN RPCSystemWideCellEnumerationHandle handle, OUT DebugCellUnion **NextCell,
                                    OUT DebugCellID *CellID, OUT DWORD *ServerPID OPTIONAL)
{
    RPCSystemWideCellEnumeration *cellEnum = (RPCSystemWideCellEnumeration *)handle;
    RPC_STATUS Status;

    ASSERT(cellEnum != NULL);

    // loop skipping empty servers
    do
        {
        *NextCell = GetNextDebugCellInfo(cellEnum->cellHandle, CellID);

        // this server is done - move on to the next
        if (*NextCell == NULL)
            {
            CloseRPCServerDebugInfo(&cellEnum->cellHandle);
            Status = OpenNextRPCServer(cellEnum->serverHandle, &cellEnum->cellHandle);

            // if we're done with all servers, we will get RPC_S_SERVER_INVALID_BOUND - ok to 
            // just return to caller. Caller needs to call us back to finish enumeration
            if (Status != RPC_S_OK)
                {
                // remember that this failed so that we don't try to clean it up
                // when finishing the enumeration
                cellEnum->cellHandle = NULL;
                return Status;
                }
            }
        } 
    while(*NextCell == NULL);

    if (ServerPID && (*NextCell != NULL))
        {
        *ServerPID = GetCurrentServerPID(cellEnum->serverHandle);
        }

    return RPC_S_OK;
}

DebugCellUnion *GetRPCSystemWideCellFromCellID(IN RPCSystemWideCellEnumerationHandle handle, 
                                               IN DebugCellID CellID)
{
    RPCSystemWideCellEnumeration *cellEnum = (RPCSystemWideCellEnumeration *)handle;

    return GetCellByDebugCellID(cellEnum->cellHandle, CellID);
}

void FinishRPCSystemWideCellEnumeration(IN OUT RPCSystemWideCellEnumerationHandle *pHandle)
{
    RPCSystemWideCellEnumeration *cellEnum;

    ASSERT(pHandle != NULL);
    cellEnum = (RPCSystemWideCellEnumeration *)*pHandle;
    ASSERT(cellEnum != NULL);

    if (cellEnum->cellHandle)
        {
        CloseRPCServerDebugInfo(&cellEnum->cellHandle);
        }
    FinishServerEnumeration(&cellEnum->serverHandle);
    delete cellEnum;
    *pHandle = NULL;
}

RPC_STATUS ResetRPCSystemWideCellEnumeration(IN RPCSystemWideCellEnumerationHandle handle)
{
    RPCSystemWideCellEnumeration *cellEnum = (RPCSystemWideCellEnumeration *)handle;
    RPC_STATUS Status;

    ASSERT(cellEnum != NULL);

    if (cellEnum->cellHandle)
        {
        CloseRPCServerDebugInfo(&cellEnum->cellHandle);
        cellEnum->cellHandle = NULL;
        }

    ResetServerEnumeration(cellEnum->serverHandle);

    Status = OpenNextRPCServer(cellEnum->serverHandle, &cellEnum->cellHandle);
    if (Status != RPC_S_OK)
        {
        // remember that this failed so that we don't try to clean it up
        // when finishing the enumeration
        cellEnum->cellHandle = NULL;
        }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\eptypes.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    eptypes.h

Abstract:

    This file contains the internal data structure defn for the EP mapper.

Author:

    Bharat Shah  (barat) 17-2-92

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/


#ifndef __EPTYPES_H__
#define __EPTYPES_H__


//
// The various EP Mapper Data structures and how they relate to each other
//
//
// ----------------
// DATA STRUCTURES
// ----------------
//
// IFOBJNode        PSEPNode        EP_CLEANUP
//
// |---|            (---)           /////
// |   |            (   )           /   /
// |   |            (---)           /////
// |   |
// |   |
// |   |
// |---|
//
//
// ---------------------------------------------------------------
// Global list of IFOBJNode and it's relation to EP_CLEANUP Nodes
// ---------------------------------------------------------------
//
// a. Next member of IFOBJNode is denoted by   --->
// b. Prev member of IFOBJNode is denoted by   <---
// c. Each EP_CLEANUP is a linked list of IFOBJNodes belonging
//    to a process.
//
//
// IFObjList
//   |
//   |
//   |
//   V
// |---|    |---|    |---|    |---|    |---|    |---|    |---|    |---|
// |   |    |   |    |   |    |   |    |   |    |   |    |   |    |   |
// |   |<---|   |<---|   |<---|   |<---|   |<---|   |<---|   |<---|   |
// |   |    |   |    |   |    |   |    |   |    |   |    |   |    |   |
// |   |--->|   |--->|   |--->|   |--->|   |--->|   |--->|   |--->|   |---|
// |   |    |   |    |   |    |   |    |   |    |   |    |   |    |   |   |
// |---|    |---|    |---| |->|---|    |---|    |---|    |---| |->|---|   |
//   ^                     |                                   |         ---
//   |                     |                                   |          -
//   |                     |                                   |
//   |                     |                                   |
// /////                 /////                               /////
// /   /                 /   /                               /   /
// /////                 /////                               /////
//
//
//
// ----------------------------------------------------------
// Each IFOBJNOde has linked list of PSEPNodes related to it
// ----------------------------------------------------------
//
// |---|     (---)     (---)     (---)     (---)     (---)
// |   |---->(   )---->(   )---->(   )---->(   )---->(   )--|
// |   |     (---)     (---)     (---)     (---)     (---)  |
// |   |                                                    |
// |   |                                                   ---
// |   |                                                    -
// |---|
//
//
//
//

//
// Cleanup context
//

struct _IFOBJNode;

typedef struct _EP_CLEANUP
{
    unsigned long MagicVal;
    unsigned long cEntries;         // Number of entries in the list.
    struct _IFOBJNode * EntryList;  // Pointer to the begining of entries
                                    // for this process.
} EP_CLEANUP, *PEP_CLEANUP, **PPEP_CLEANUP;


typedef struct _IENTRY {
    struct _IENTRY * Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long  Id;
} IENTRY;

typedef IENTRY * PIENTRY;

typedef struct _PSEPNode {
    struct _PSEPNode * Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long PSEPid;
    char * Protseq;
    char * EP;
    twr_t * Tower;
} PSEPNode;

typedef PSEPNode * PPSEPNode;


typedef struct _IFOBJNode {
    struct _IFOBJNode * Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long IFOBJid;
    PSEPNode * PSEPlist;
    EP_CLEANUP * OwnerOfList;
    struct _IFOBJNode * Prev;
    UUID ObjUuid;
    UUID IFUuid;
    unsigned long IFVersion;
    char * Annotation;
} IFOBJNode;

typedef IFOBJNode * PIFOBJNode;

typedef struct _SAVEDCONTEXT {
    struct _SAVEDCONTEXT *Next;
    unsigned long Signature;
    unsigned long Cb;
    unsigned long CountPerBlock;
    unsigned long Type;
    void * List;
} SAVEDCONTEXT;

typedef SAVEDCONTEXT * PSAVEDCONTEXT;

typedef struct _SAVEDTOWER {
    struct _SAVEDTOWER * Next;
    unsigned long Signature;
    unsigned long Cb;
    twr_t * Tower;
} SAVEDTOWER;

typedef SAVEDTOWER * PSAVEDTOWER;


typedef struct _EP_T  {
        UUID ObjUuid;
        UUID IFUuid;
        unsigned long IFVersion;
} EP_T;

typedef EP_T * PEP_T;

typedef struct _I_EPENTRY {
   UUID Object;
   UUID Interface;
   unsigned long IFVersion;
   twr_t *Tower;
   char __RPC_FAR * Annotation;
} I_EPENTRY;

typedef struct _SAVED_EPT {
   struct _SAVED_EPT * Next;
   unsigned long Signature;
   unsigned long Cb;
   UUID Object;
   twr_t * Tower;
   char  * Annotation;
} SAVED_EPT;

typedef SAVED_EPT * PSAVED_EPT;

typedef unsigned long (* PFNPointer)(
                        void *,         // pNode
                        void *,         // ObjUuid
                        void *,         // IfUuid
                        unsigned long,  // IfVer
                        unsigned long,  // InqType
                        unsigned long   // VersOpt
                        );

typedef unsigned long (* PFNPointer2)(
                        void *,         // PSEPNode
                        void *,         // Protseq
                        void *,         // Endpoint
                        unsigned long   // Version
                        );

// Endpoint Mapper Table
typedef struct _ProtseqEndpointPair {
  char  __RPC_FAR * Protseq;
  char  __RPC_FAR * Endpoint;
  unsigned long      State;
} ProtseqEndpointPair;



#endif // __EPTYPES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\mqcommon.h ===
//----------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  Module Name:  mqcommon.h
//
//
//  Abstract:
//
//  This is the Message Queue (Falcon) datagram client dll.
//
//  Author:
//
//  Edward Reus (edwardr) 17-Jun-1996
//
//  Revision History:
//
//----------------------------------------------------------------


#ifndef MQCOMMON_H
#define MQCOMMON_H

#define UNICODE      // Use unicode API

// Use the following define to turn on verbose debug messages:
// #define MAJOR_DEBUG


//----------------------------------------------------------------
//  Constants:
//----------------------------------------------------------------

#define DG_MQ_TRANSPORT_VERSION    1    // Not used.
#define MAX_PATHNAME_LEN         256
#define MAX_FORMAT_LEN           128
#define MAX_COMPUTERNAME_LEN      32
#define MAX_VAR                   20
#define MAX_SEND_VAR              20
#define MAX_RECV_VAR              20
#define MAX_SID_SIZE             256    // A typical SID is 20-30 bytes...
#define MAX_USERNAME_SIZE        256
#define MAX_DOMAIN_SIZE          256
#define UUID_LEN                  40

#define TRANSPORTID             0x1D    // Not official yet...
#define TRANSPORTHOSTID         0x1E
#define PROTSEQ                "ncadg_mq"
#define ENDPOINT_MAPPER_EP     "EpMapper"

#define WS_SEPARATOR               TEXT("\\")
#define WS_PRIVATE_DOLLAR          TEXT("\\PRIVATE$\\")

// These constants are use for temporary queue management:
#define Q_SVC_PROTSEQ              TEXT("ncalrpc")
#define Q_SVC_ENDPOINT             TEXT("epmapper")

// These are the MQ Queue Type UUIDs for RPC:
#define SVR_QTYPE_UUID_STR         TEXT("bbd97de0-cb4f-11cf-8e62-00aa006b4f2f")
#define CLNT_QTYPE_UUID_STR        TEXT("8e482920-cead-11cf-8e68-00aa006b4f2f")
#define CLNT_ADMIN_QTYPE_UUID_STR  TEXT("c87ca5c0-ff67-11cf-8ebd-00aa006b4f2f")

// Packet sizes:
#define BASELINE_PDU_SIZE       65535
#define PREFERRED_PDU_SIZE      65535
#define MAX_PDU_SIZE            65535
#define MAX_PACKET_SIZE         65535
                             // was: 0x7fffffff
#define DEFAULT_BUFFER_SIZE         0

#define DEFAULT_PRIORITY            3


//----------------------------------------------------------------
//  Types:
//----------------------------------------------------------------

typedef struct _MQ_INFO
  {
    WCHAR       wsMachine[MAX_COMPUTERNAME_LEN];
    WCHAR       wsQName[MQ_MAX_Q_NAME_LEN];
    WCHAR       wsQPathName[MAX_PATHNAME_LEN];
    WCHAR       wsQFormat[MAX_FORMAT_LEN];
    WCHAR       wsAdminQFormat[MAX_FORMAT_LEN];
    UUID        uuidQType;
    QUEUEHANDLE hQueue;
    QUEUEHANDLE hAdminQueue;          // Sometimes used by the client.
    DWORD       dwBufferSize;
    DWORD       cThreads;             // Used by server.
    BOOL        fInitialized;
    // How to send this call message:
    BOOL        fAck;
    ULONG       ulDelivery;
    ULONG       ulPriority;
    ULONG       ulJournaling;
    ULONG       ulTimeToReachQueue;   // Seconds.
    ULONG       ulTimeToReceive;      // Seconds.
    BOOL        fAuthenticate;
    BOOL        fEncrypt;
  } MQ_INFO;


typedef struct _MQ_ADDRESS
  {
    WCHAR  wsMachine[MAX_COMPUTERNAME_LEN];
    WCHAR  wsQName[MQ_MAX_Q_NAME_LEN];
    WCHAR  wsQFormat[MAX_FORMAT_LEN];
    QUEUEHANDLE hQueue;
    BOOL   fConnectionFailed;
    BOOL   fAuthenticated;            // Server security tracking.
    ULONG  ulPrivacyLevel;            // Server security tracking.
    ULONG  ulAuthenticationLevel;     // Server security tracking.
    UCHAR  aSidBuffer[MAX_SID_SIZE];  // Server security tracking.
  } MQ_ADDRESS;

typedef struct _MQ_OPTIONS
  {
    BOOL   fAck;
    ULONG  ulDelivery;
    ULONG  ulPriority;
    ULONG  ulJournaling;
    ULONG  ulTimeToReachQueue;
    ULONG  ulTimeToReceive;
    BOOL   fAuthenticate;
    BOOL   fEncrypt;
  } MQ_OPTIONS;

//----------------------------------------------------------------
//  Prototypes:
//----------------------------------------------------------------

extern HRESULT CreateQueue( IN  UUID  *pQueueUuid,
                            IN  WCHAR *pwsPathName,
                            IN  WCHAR *pwsQueueLabel,
                            IN  ULONG  ulQueueFlags,
                            OUT WCHAR *pwsFormat,
                            IN OUT DWORD *pdwFormatSize );


extern BOOL    ConstructQueuePathName( IN  WCHAR *pwsMachineName,
                                       IN  WCHAR *pwsQueueName,
                                       OUT WCHAR *pwsPathName,
                                       IN OUT DWORD *pdwSize  );


extern BOOL    ConstructPrivateQueuePathName( IN  WCHAR *pwsMachineName,
                                              IN  WCHAR *pwsQueueName,
                                              OUT WCHAR *pwsPathName,
                                              IN OUT DWORD *pdwSize  );


extern HRESULT ClearQueue( QUEUEHANDLE hQueue );


extern BOOL    ParseQueuePathName(
                    IN  WCHAR *pwsPathName,
                    OUT WCHAR  wsMachineName[MAX_COMPUTERNAME_LEN],
                    OUT WCHAR  wsQueueName[MQ_MAX_Q_NAME_LEN]  );

#ifdef MAJOR_DEBUG

extern void    DbgPrintPacket( unsigned char *pPacket );

#endif

//
// The Svr... functions are defined in ..\falcons\mqsvr.c

extern HRESULT SvrSetupQueue( IN MQ_INFO *pEP,
                              IN WCHAR   *pwsSvrMachine,
                              IN WCHAR   *pwsEndpoint,
                              IN unsigned long ulEndpointFlags );


extern HRESULT SvrPeekQueue( IN  MQ_INFO *pInfo,
                             IN  DWORD    timeoutMsec,
                             OUT ULONG   *pdwBufferSize );

extern HRESULT SvrReceiveFromQueue( IN  MQ_INFO    *pInfo,
                                    IN  DWORD       timeoutMsec,
                                    OUT MQ_ADDRESS *pAddress,
                                    OUT UCHAR      *pBuffer,
                                    IN OUT DWORD   *pdwBufferSize );



extern HRESULT SvrSendToQueue( IN MQ_INFO    *pInfo,
                               IN MQ_ADDRESS *pAddress,
                               IN UCHAR      *pBuffer,
                               IN DWORD       dwBufferSize );


extern HRESULT SvrShutdownQueue( IN MQ_INFO *pInfo );


extern HRESULT SvrInitializeHandleMap();


extern HRESULT SvrCloseAllHandles();

//
// The Clnt... functions are defined in mqclnt.c

extern HRESULT ClntSetupQueue( MQ_INFO *pEP,
                               WCHAR   *pwsSvrMachine,
                               WCHAR   *pwsEndpoint    );


extern HRESULT ClntSetupAdminQueue( MQ_INFO *pEP );


extern HRESULT ClntReceiveFromQueue( IN  MQ_INFO    *pInfo,
                                     IN  DWORD       timeoutMsec,
                                     OUT MQ_ADDRESS *pAddress,
                                     OUT UCHAR      *pBuffer,
                                     IN OUT DWORD   *pdwBufferSize );


extern HRESULT ClntPeekQueue( IN  MQ_INFO *pInfo,
                              IN  DWORD    timeoutMsec,
                              OUT DWORD   *pdwBufferSize );


extern HRESULT ClntSendToQueue( IN MQ_INFO    *pInfo,
                                IN MQ_ADDRESS *pAddress,
                                IN UCHAR      *pBuffer,
                                IN DWORD       dwBufferSize );


extern HRESULT ClntShutdownQueue( IN MQ_INFO *pInfo );


extern RPC_STATUS MQ_MapStatusCode( IN HRESULT    hr,
                                    IN RPC_STATUS defStatus );


#if FALSE
NOTE: These functions are not currently being used...

extern HRESULT LocateQueueViaQType( IN     UUID  *pQueueUuid,
                                    OUT    WCHAR *pwsFormat,
                                    IN OUT DWORD *pdwFormatSize );


extern HRESULT LocateQueueViaQTypeAndMachine( IN     UUID  *pQueueUuid,
                                              IN     WCHAR *pwsMachine,
                                              OUT    WCHAR *pwsFormat,
                                              IN OUT DWORD *pdwFormatSize );


extern HRESULT LocateQueueViaQName( IN     WCHAR *pwsQueueName,
                                    OUT    WCHAR *pwsFormat,
                                    IN OUT DWORD *pdwFormatSize );


extern HRESULT LocateQueueViaQNameAndMachine( IN  WCHAR *pwsQName,
                                              IN  WCHAR *pwsMachine,
                                              OUT WCHAR *pwsFormat,
                                              IN OUT DWORD *pdwFormatSize );


extern BOOL    FormatNameDirect( IN  WCHAR *pwsMachineName,
                                 IN  WCHAR *pwsQueueName,
                                 OUT WCHAR *pwsFormatName,
                                 IN OUT DWORD *pdwSize );
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\local.h ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    local.h

Abstract:

    Header file for Server side EP

Author:

    Bharat Shah  2/22/92

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#ifndef __LOCAL_H__
#define __LOCAL_H__

//#define DBG_DETAIL

#define EP_TABLE_ENTRIES  12

#define CLEANUP_MAGIC_VALUE     0xDECAFBAD
#define PROCESS_MAGIC_VALUE     ((CLEANUP_MAGIC_VALUE)+1)


extern  HANDLE              hEpMapperHeap;
extern  CRITICAL_SECTION    EpCritSec;
extern  CRITICAL_SECTION    TableMutex;
extern  PIFOBJNode          IFObjList;
extern  unsigned long       cTotalEpEntries;
extern  unsigned long       GlobalIFOBJid;
extern  unsigned long       GlobalEPid;
extern  PSAVEDCONTEXT       GlobalContextList;
extern  UUID                NilUuid;
extern  ProtseqEndpointPair EpMapperTable[EP_TABLE_ENTRIES];



//
// Global thread locking functions
//

#ifdef NTENV
#define CheckInSem() \
    ASSERT(EpCritSec.OwningThread == ULongToPtr(GetCurrentThreadId()))
#else
#define CheckInSem()
#endif

#define  EnterSem()  EnterCriticalSection(&EpCritSec)
#define  LeaveSem()  LeaveCriticalSection(&EpCritSec)


//
// Allocation routines.
//


_inline void *
AllocMem(
    size_t Size
    )
{
    return (HeapAlloc(hEpMapperHeap, 0, Size));
}


_inline void
FreeMem(
    void * pvMem
    )
{
    HeapFree(hEpMapperHeap, 0, pvMem);
}




//
// Forward definitions
//

PIENTRY
Link(
    PIENTRY *ppHead,
    PIENTRY pNode
    );

PIENTRY
UnLink(
    PIENTRY *ppHead,
    PIENTRY pNode
    );

PIFOBJNode
FindIFOBJVer(
    PIFOBJNode *pList,
    I_EPENTRY *ep
    );

RPC_STATUS
IsNullUuid(
    UUID * Uuid
    );

RPC_STATUS
GetEntries(
    UUID *ObjUuid,
    UUID *IFUuid,
    ulong ver,
    char * pseq,
    ept_lookup_handle_t *map_lookup_handle,
    char * binding,
    ulong calltype,
    ulong maxrequested,
    ulong *returned,
    ulong InqType,
    ulong VersOpts,
    PFNPointer Match
    );

RPC_STATUS
PackDataIntoBuffer(
    char * * buffer,
    PIFOBJNode pNode, PPSEPNode pPSEP,
    ulong fType,
    BOOL fPatchTower,
    int PatchTowerAddress
    );

RPC_STATUS
ExactMatch(
    PIFOBJNode pNode,
    UUID * Obj,
    UUID *If,
    unsigned long Ver,
    unsigned long InqType,
    unsigned long Options
    );

RPC_STATUS
WildCardMatch(
    PIFOBJNode pNode,
    UUID * Obj,
    UUID * If,
    unsigned long Vers,
    unsigned long InqType,
    unsigned long Options
    );

RPC_STATUS
SearchIFObjNode(
    PIFOBJNode pNode,
    UUID * Obj,
    UUID * If,
    unsigned long Vers,
    unsigned long InqType,
    unsigned long Options
    );

RPC_STATUS
StartServer(
    );

VOID
LinkAtEnd(
    PIFOBJNode *Head,
    PIFOBJNode Node
    );

RPC_STATUS RPC_ENTRY
GetForwardEp(
    UUID *IfId,
    RPC_VERSION * IFVersion,
    UUID * Object,
    unsigned char* Protseq,
    void * * EpString
    );



//
// Link list manipulation rountines
//

RPC_STATUS
EnLinkOnIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode NewNode
    );

RPC_STATUS
UnLinkFromIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode DeleteMe
    );

#define EnLinkOnPSEPList(x,p)                   \
                                                \
            (PPSEPNode)                         \
            Link(                               \
                (PIENTRY *)(x),                 \
                (PIENTRY)(p)                    \
                )

#define EnLinkContext(p)                        \
                                                \
            (PSAVEDCONTEXT)                     \
            Link(                               \
                (PIENTRY *)(&GlobalContextList),\
                (PIENTRY)(p)                    \
                )

#define UnLinkContext(p)                        \
                                                \
            (PSAVEDCONTEXT)                     \
            UnLink(                             \
                (PIENTRY *)&GlobalContextList,  \
                (PIENTRY) (p)                   \
                )

#define UnLinkFromPSEPList(x,p)                 \
                                                \
            (PPSEPNode)                         \
            UnLink(                             \
                (PIENTRY *)(x),                 \
                (PIENTRY)(p)                    \
                )

#define MatchByIFOBJKey(x, p)                   \
                                                \
            (PIFOBJNode)                        \
            MatchByKey(                         \
                (PIENTRY)(x),                   \
                (ulong)(p)                      \
                )

#define MatchByPSEPKey(x, p)                    \
                                                \
            (PPSEPNode)                         \
            MatchByKey(                         \
                (PIENTRY)(x),                   \
                (ulong)(p)                      \
                )



#define MAXIFOBJID            (256L)
#define MAKEGLOBALIFOBJID(x)  ( ( ((x-1) % MAXIFOBJID) << 24 ) & 0xFF000000L )
#define MAKEGLOBALEPID(x,y)   ( ( ((x) &0xFF000000L) | ((y) & 0x00FFFFFFL) ) )

#define IFOBJSIGN             (0x49464F42L)
#define PSEPSIGN              (0x50534550L)
#define FREE                  (0xBADDC0DEL)


//
// Error Codes Here ??
//

#define  EP_LOOKUP                          0x00000001L
#define  EP_MAP                             0x00000002L

#define  RPC_C_EP_ALL_ELTS                  0
#define  RPC_C_EP_MATCH_BY_IF               1
#define  RPC_C_EP_MATCH_BY_OBJ              2
#define  RPC_C_EP_MATCH_BY_BOTH             3

#define  I_RPC_C_VERS_UPTO_AND_COMPATIBLE   6

#define VERSION(x,y)  ( ((0x0000FFFFL & x)<<16) | (y) )


//
//  States of listening..
//

#define NOTSTARTED        0
#define STARTINGTOLISTEN  1
#define STARTED           2




//
// IP Port Management stuff
//


// Each server process connected to the endpoint mapper
// keeps on an open context handle so that rpcss can
// clean up the database when a process dies.
// The PROCESS struct is the context handle.

typedef struct _IP_PORT
{
    struct _IP_PORT *pNext;
    USHORT Type;
    USHORT Port;
} IP_PORT;

typedef struct _PROCESS
{
    DWORD MagicVal;
    //
    // Zero if the process doesn't own any reserved IP ports.
    //
    IP_PORT *pPorts;

} PROCESS;

typedef struct _PORT_RANGE
{
    struct _PORT_RANGE *pNext;
    USHORT Max;  // Inclusive
    USHORT Min;  // Inclusive
} PORT_RANGE;


#ifdef DBG
void CountProcessContextList(EP_CLEANUP *pProcessContext, unsigned long nExpectedCount);
#define ASSERT_PROCESS_CONTEXT_LIST_COUNT(p, c) \
	CountProcessContextList(p, c)
#else
#define ASSERT_PROCESS_CONTEXT_LIST_COUNT(p, c)
#endif

#endif // __LOCAL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\epmap.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epmap.c

Abstract:

    This file contains the EP Mapper startup code and process wide globals.

Author:

    Bharat Shah  (barats) 17-2-92

Revision History:

    06-16-95    MarioGo     Much of the code replaced by ..\wrapper\start.c
                            Renamed from server.c
    Jan 2000    KamenM      Add debugging support

--*/

#include <sysinc.h>
#include <wincrypt.h>
#include <rpc.h>
#include <winsvc.h>
#include "epmp.h"
#include "eptypes.h"
#include "local.h"
#include <DbgComn.h>
#include <DbgIdl.h>
#include <DbgSvr.hxx>

#if DBG && !defined(DEBUGRPC)
#define DEBUGRPC
#endif


/*// Endpoint related functions

RPC_STATUS InitializeEndpointManager(VOID);
DWORD      StartEndpointMapper(VOID);
USHORT     GetProtseqIdAnsi(PSTR Protseq);
USHORT     GetProtseqId(PWSTR Protseq);
PWSTR      GetProtseq(USHORT ProtseqId);
PWSTR      GetEndpoint(USHORT ProtseqId);
RPC_STATUS UseProtseqIfNecessary(USHORT id);
RPC_STATUS DelayedUseProtseq(USHORT id);
VOID       CompleteDelayedUseProtseqs();
BOOL       IsLocal(USHORT ProtseqId);
*/


extern RPC_STATUS InitializeIpPortManager();



//
// Endpoint Mapper Globals
//

HANDLE           hEpMapperHeap;
CRITICAL_SECTION EpCritSec;
PIFOBJNode       IFObjList = NULL;
PSAVEDCONTEXT    GlobalContextList = NULL;
unsigned long    cTotalEpEntries = 0L;
unsigned long    GlobalIFOBJid = 0xFFL;
unsigned long    GlobalEPid    = 0x00FFFFFFL;
UUID             NilUuid = { 0L, 0, 0, {0, 0, 0, 0, 0, 0, 0, 0} };


DWORD
StartEndpointMapper(
    void
    )
/*++

Routine Description:

    Called during dcomss startup.  Should call Updatestatus()
    if something will take very long.

Arguments:

    None

Return Value:

    0 - success

    non-0 - will cause the service to fail.

--*/
{
    extern void RPC_ENTRY UpdateAddresses( PVOID arg );

    RPC_STATUS status = RPC_S_OK;
    BOOL fAuthInfoNotRegistered = FALSE;

    InitializeCriticalSectionAndSpinCount(&EpCritSec, PREALLOCATE_EVENT_MASK);

    hEpMapperHeap = GetProcessHeap();

    if (hEpMapperHeap == 0)
        {
        ASSERT(GetLastError() != 0);
        return(GetLastError());
        }

    // register snego & kerberos. During clean install, this code can
    // legally fail, as Rpcss is started before there are any
    // security providers. Therefore, we cannot fail Rpcss init if this
    // fails - we just don't register the debug interface, who is the
    // only user of this
    status = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);

    if (status != RPC_S_OK)
        {
        fAuthInfoNotRegistered = TRUE;
        }

    status = RpcServerRegisterAuthInfo(NULL, RPC_C_AUTHN_GSS_KERBEROS, NULL, NULL);

    if (status != RPC_S_OK)
        {
        fAuthInfoNotRegistered = TRUE;
        }

    status = RpcServerRegisterIf(epmp_ServerIfHandle,
                                 0,
                                 0);

    if (status != RPC_S_OK)
        {
        return(status);
        }

    status = RpcServerRegisterIf(localepmp_ServerIfHandle,
                                 0,
                                 0);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    if (fAuthInfoNotRegistered == FALSE)
        {
        status = RpcServerRegisterIfEx(DbgIdl_ServerIfHandle,
                                     0,
                                     0,
                                     0,
                                     RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                     DebugServerSecurityCallback);
        if (status != RPC_S_OK)
            {
            return(status);
            }
        }

    status = I_RpcServerRegisterForwardFunction( GetForwardEp );

#ifndef DOSWIN32RPC
    if (status == RPC_S_OK)
        {
        status = InitializeIpPortManager();
        ASSERT(status == RPC_S_OK);
        }
#endif

    status = I_RpcServerSetAddressChangeFn( UpdateAddresses );

    ASSERT( 0 == status );

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\util.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    util.c

Abstract:

    This module provides all the utility functions for the Server side of
    the end-point mapper.

Author:

    Bharat Shah

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <sysinc.h>
#include <rpc.h>
#include <rpcndr.h>
#include "epmp.h"
#include "eptypes.h"
#include "local.h"


//
// Link list manipulation rountines
//

#ifdef DBG
void CountProcessContextList(EP_CLEANUP *pProcessContext, unsigned long nExpectedCount)
{
    unsigned long nActualCount = 0;
    PIFOBJNode pNode = pProcessContext->EntryList;

    while (pNode && (pNode->OwnerOfList == pProcessContext))
        {
        pNode = pNode->Next;
        nActualCount ++;
        }

    if (nActualCount != nExpectedCount)
        {
        DbgPrint("Expected count was %d, while actual count was %d\n", nExpectedCount, 
            nActualCount);
        }
}
#endif

PIENTRY
Link(
    PIENTRY *Head,
    PIENTRY Node
    )
{
    if (Node == NULL)
        return (NULL);

    CheckInSem();

    Node->Next = *Head;

    return(*Head = Node);
}




VOID
LinkAtEnd(
    PIFOBJNode *Head,
    PIFOBJNode Node
    )
{
    register PIFOBJNode *ppNode;

    CheckInSem();

    for ( ppNode = Head; *ppNode; ppNode = &((*ppNode)->Next) );
        {
        ; // Empty body
        }

    *ppNode = Node;
}





PIENTRY
UnLink(
    PIENTRY *Head,
    PIENTRY Node
    )
{
    PIENTRY *ppNode;

    for (ppNode = Head; *ppNode && (*ppNode != Node);
         ppNode = &(*ppNode)->Next)
        {
        ; // Empty body
        }

    if (*ppNode)
        {
        *ppNode = Node->Next;
        return (Node);
        }

    return (0);
}




RPC_STATUS
EnLinkOnIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode NewNode
    )
/*++

Arguments:

    phContext - The context handle supplied by the process.

    NewNode - The node (EP entry) to be inserted into the EP Mapper database.

Routine Description:

    This routine adds a new entry into the Endpoint Mapper database (which is
    maintained as a linked-list). It also updates the list of entries for the
    process identified by the context handle ProcessCtxt.

Notes:

    a. This routine should always be called by holding a mutex.
    b. NewNode is already allocated by the caller.
    c. IFObjList may be created here.
    d. ProcessCtxt is assumed to be allocated sometime by the caler.

Return Values:

    RPC_S_OK - Always.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
#ifdef DBG_DETAIL
    PIFOBJNode pTemp, pLast;
#endif // DBG_DETAIL

    // Parameter validation.
    ASSERT(NewNode);
    ASSERT(ProcessCtxt);
    ASSERT(ProcessCtxt->MagicVal == CLEANUP_MAGIC_VALUE);
    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);

    CheckInSem();

    //
    // First, insert NewNode into this Process's list of entries.
    //
    NewNode->Next = ProcessCtxt->EntryList;

    if (ProcessCtxt->EntryList != NULL)
        {
        ASSERT(ProcessCtxt->cEntries > 0);
        ASSERT(cTotalEpEntries > 0);
        ASSERT(IFObjList != NULL);

        NewNode->Prev = ProcessCtxt->EntryList->Prev;

        // Next node's Prev pointer
        ProcessCtxt->EntryList->Prev = NewNode;

        if (NewNode->Prev)
            {
            ASSERT(cTotalEpEntries > 1);

            // Previous node's Next pointer
            NewNode->Prev->Next = NewNode;
            }
        }
    else
        {
        ASSERT(ProcessCtxt->cEntries == 0);

        NewNode->Prev = NULL;
        }

    //
    // Now, adjust the Global EP Mapper entries list head, if necessary
    //
    if (ProcessCtxt->EntryList != NULL)
        {
        if (ProcessCtxt->EntryList == IFObjList)
            {           
            IFObjList = NewNode;
            }
        }
    else
        {
        // First entry registered by this process
        if (IFObjList != NULL)
            {
            // Add the new ProcessCtxt at the head of IFObjList
            IFObjList->Prev = NewNode;
            NewNode->Next = IFObjList;
            }
        else
            {
            ASSERT(cTotalEpEntries == 0);
            }
        
        IFObjList = NewNode;
        }
        
    // Add new node at the head of Process list.
    ProcessCtxt->EntryList = NewNode;
    NewNode->OwnerOfList = ProcessCtxt;

    ProcessCtxt->cEntries++;
    cTotalEpEntries++;
#ifdef DBG_DETAIL
    DbgPrint("RPCSS: cTotalEpEntries++ [%p] (%d)\n", ProcessCtxt, cTotalEpEntries);
    DbgPrint("RPCSS: Dump of IFOBJList\n");
    pTemp = IFObjList;
    pLast = IFObjList;
    while (pTemp)
        {
        DbgPrint("RPCSS: \t\t[%p]\n", pTemp);
        pLast = pTemp;
        pTemp = pTemp->Next;    
        }
    DbgPrint("RPCSS: --------------------\n");
    while (pLast)
        {
        DbgPrint("RPCSS: \t\t\t[%p]\n", pLast);
        pLast = pLast->Prev;            
        }
#endif // DBG_DETAIL

    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);
    return (Status);
}




RPC_STATUS
UnLinkFromIFOBJList(
    PEP_CLEANUP ProcessCtxt,
    PIFOBJNode DeleteMe
    )
/*++

Arguments:

    phContext - The context handle supplied by the process.

    DeleteMe - The node (EP entry) to be deleted from the EP Mapper database.

Routine Description:

    This routine removes an existing entry from the Endpoint Mapper database
    (which is maintained as a linked-list). It also updates the list of entries
    for the process identified by the context handle ProcessCtxt.

Notes:

    a. This routine should always be called by holding a mutex.
    b. DeleteMe node has to be freed by the caller.
    c. IFOBJlist may become empty (NULLed out) here.
    d. ProcessCtxt may become empty here and if so, it should be freed
       by the caller.

Return Values:

    RPC_S_OK - If everyhing went well.

    RPC_S_ACCESS_DENIED - If something went wrong.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
#ifdef DBG_DETAIL
    PIFOBJNode pTemp, pLast;
#endif // DBG_DETAIL

    // Parameter validation.
    ASSERT(DeleteMe);
    ASSERT(ProcessCtxt);
    ASSERT(ProcessCtxt->MagicVal == CLEANUP_MAGIC_VALUE);


    CheckInSem();

    //
    // The context has been created already for this process. So, there
    // should be one or more entries registered by this process.
    //
    ASSERT(IFObjList);
    ASSERT(cTotalEpEntries > 0);
    ASSERT(ProcessCtxt->EntryList);
    ASSERT(ProcessCtxt->cEntries > 0);
    ASSERT(ProcessCtxt->EntryList->OwnerOfList == ProcessCtxt);
    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);

    // Trying to unregister someone else's entry?
    if (DeleteMe->OwnerOfList != ProcessCtxt)
        {
        ASSERT("Returning RPC_S_ACCESS_DENIED" &&
               (DeleteMe->OwnerOfList != ProcessCtxt));
        return (RPC_S_ACCESS_DENIED);
        }

    //
    // First, remove DeleteMe from this Process's List.
    //

    // See if it the first element of the process list.
    if (DeleteMe == ProcessCtxt->EntryList)
        {
        if (DeleteMe->Next)
            {
            // if we are nibbling the next segment, zero out the EntryList
            if (DeleteMe->Next->OwnerOfList != ProcessCtxt)
                {
                ProcessCtxt->EntryList = NULL;
                }
            else
                ProcessCtxt->EntryList = DeleteMe->Next;
            }
        else
            {
            ProcessCtxt->EntryList = NULL;
            }
        }

    ASSERT(  ((ProcessCtxt->EntryList != NULL) && (ProcessCtxt->cEntries > 1))
          || (ProcessCtxt->cEntries == 1)  );

    // Remove it.
    if (DeleteMe->Next != NULL)
        {
        // Next node's Prev pointer
        DeleteMe->Next->Prev = DeleteMe->Prev;
        }

    if (DeleteMe->Prev != NULL)
        {
        // Previous node's Next pointer
        DeleteMe->Prev->Next = DeleteMe->Next;
        }
    else
        {
        ASSERT(IFObjList == DeleteMe);
        }


    //
    // Next, adjust the Global EP Mapper entries list head, if necessary
    //
    if (IFObjList == DeleteMe)
        {
        // Can become NULL here.
        IFObjList = DeleteMe->Next;
        }


    // Remove node from all lists.
    DeleteMe->Prev = NULL;
    DeleteMe->Next = NULL;
    DeleteMe->OwnerOfList = NULL;

    ProcessCtxt->cEntries--;
    cTotalEpEntries--;
#ifdef DBG_DETAIL
    DbgPrint("RPCSS: cTotalEpEntries-- [%p] (%d)\n", ProcessCtxt, cTotalEpEntries);
    DbgPrint("RPCSS: Dump of IFOBJList\n");
    pTemp = IFObjList;
    pLast = IFObjList;
    while (pTemp)
        {
        DbgPrint("RPCSS: \t\t[%p]\n", pTemp);
        pLast = pTemp;
        pTemp = pTemp->Next;
        }   
    DbgPrint("RPCSS: --------------------\n");
    while (pLast)
        {
        DbgPrint("RPCSS: \t\t\t[%p]\n", pLast);
        pLast = pLast->Prev;            
        }
#endif // DBG_DETAIL

    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);
    return (Status);
}




//
// HACK Alert.
//
// Midl 1.00.xx didn't support full pointers.  So, clients from NT 3.1
// machines will use unique pointers.  This function detects and fixes
// the buffer if an older client contacts our new server.

// This HACK can be removed when supporting NT 3.1 era machines is no
// longer required.

void
FixupForUniquePointerClients(
    PRPC_MESSAGE pRpcMessage
    )
{
    unsigned long *pBuffer = (unsigned long *)pRpcMessage->Buffer;

    // Check the obj uuid parameter.

    if (pBuffer[0] != 0)
        {
        // If it is not zero, it should be 1.
        pBuffer[0] = 1;

        // check the map_tower, which moves over 1 + 4 longs for the obj uuid
        if (pBuffer[5] != 0)
            pBuffer[5] = 2;
        }
    else
        {
        // Null obj uuid, check the map_tower.

        if (pBuffer[1] != 0)
            pBuffer[1] = 1;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\mqmgr.cxx ===
//-------------------------------------------------------------------
// Copyright (C) Microsoft Corporation, 1991 - 1999
//
// mqmgr.c
//
// Abstract:
//
//   Functions to manage temporary Falcon message queues for RPC. The
//   RPC support of Falcon as a transport allows for temporary queues
//   which exist only as long as the process. These functions manage
//   these temporary queues.
//
// Author:
//
//   Edward Reus (edwardr)
//
// Revision History:
//
//-------------------------------------------------------------------


#include <sysinc.h>

#define FD_SETSIZE 1

#include <wtypes.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#include <rpctrans.hxx>
#include <stdlib.h>
#include <objidl.h>
#include <mq.h>
#include "mqmgr.h"

#define  MAX_FORMAT_LEN   128

//-------------------------------------------------------------------
//  Local Types:
//-------------------------------------------------------------------

typedef struct _MqTempQueue
   {
   struct _MqTempQueue *pNext;
   WCHAR         wsQFormat[MAX_FORMAT_LEN];
   } MqTempQueue;

typedef struct _MqTempQueueList
   {
   HANDLE       hToken;   // For impersonation of the client.
   MqTempQueue *pQueues;
   } MqTempQueueList;


typedef HRESULT (APIENTRY *MQ_DELETE_QUEUE_FN)( WCHAR *pwsQFormat );

#define MQRT_DLL_NAME      TEXT("MQRT.DLL")
#define MQ_DELETE_FN_NAME  "MQDeleteQueue"

//-------------------------------------------------------------------
//  Globals:
//-------------------------------------------------------------------

static HINSTANCE           g_hMqDll = 0;
static MQ_DELETE_QUEUE_FN  g_pMqDeleteQueue = 0;

//-------------------------------------------------------------------
//  MqGetContext()
//
//  Establishs a context handle to manage temporary queues. Once the
//  context handle is created, the RPC client and server processes
//  will automatically register temporary queues.
//-------------------------------------------------------------------
unsigned long MqGetContext( handle_t         hBind,
                            PCONTEXT_HANDLE *pphContext )
{
   RPC_STATUS  Status = RPC_S_OK;
   HANDLE      hToken = 0;
   HANDLE      hThread = 0;
   MqTempQueueList  *pqList;

   // First, check to see if the MQ runtime DLL has been loaded. If not,
   // then load it and resolve the entry for the function to delete queues.
   if (!g_hMqDll)
      {
      g_hMqDll = LoadLibrary(MQRT_DLL_NAME);
      if (g_hMqDll)
         {
         g_pMqDeleteQueue = (MQ_DELETE_QUEUE_FN)GetProcAddress(g_hMqDll,MQ_DELETE_FN_NAME);
         if (!g_pMqDeleteQueue)
            {
            Status = GetLastError();
            FreeLibrary(g_hMqDll);
            g_hMqDll = 0;
            return Status;
            }
         }
      else
         {
         // The LoadLibrary() call failed.
         Status = GetLastError();
         *pphContext = NULL;
         return Status;
         }
      }

   // Ok, create a context for this connection. Also, grab the 
   // client's security token for later use when deleting the 
   // queue.
   *pphContext = pqList = (MqTempQueueList*)I_RpcAllocate(sizeof(MqTempQueueList));
   if (!*pphContext)
      {
      Status = RPC_S_OUT_OF_MEMORY;
      }
   else
      {
      ZeroMemory( pqList, sizeof(MqTempQueueList) );

      Status = RpcImpersonateClient(hBind);
      if (RPC_S_OK == Status)
         {
         if (  (hThread=GetCurrentThread())
            && (OpenThreadToken(hThread,TOKEN_IMPERSONATE,FALSE,&hToken)) )
            {
            pqList->hToken = hToken;
            }
         else
            {
            Status = GetLastError();
            }

         if (hThread)
            {
            CloseHandle(hThread);
            }

         Status = RpcRevertToSelf();
         }
      else
         {
         // If the impersonation failed, then plow ahead anyway. We
         // can still keep the list of queues and "maybe" delete them.
         Status = RPC_S_OK;
         }
      }

   #ifdef DBG
   DbgPrint("MqGetContext(): hToken: 0x%x\n",hToken);
   #endif
   
   return Status;
}

//-------------------------------------------------------------------
//  MqRegisterQueue()
//
//  Register the specified queue as a temporary queue that will
//  need to be deleted by the context rundown routine when the 
//  client exits. The registration is actually done by the MQ RPC
//  client and server transport DLLs.
//-------------------------------------------------------------------
unsigned long MqRegisterQueue( PCONTEXT_HANDLE phContext,
                               wchar_t        *pwsQFormat    )
{
   RPC_STATUS       Status = RPC_S_OK;
   MqTempQueue     *pTempQueue;
   MqTempQueueList *pqList = (MqTempQueueList*)phContext;


   pTempQueue = (MqTempQueue*)I_RpcAllocate(sizeof(MqTempQueue));
   if (!pTempQueue)
      {
      return RPC_S_OUT_OF_MEMORY;
      }

   memset(pTempQueue,0,sizeof(MqTempQueue));

   ASSERT(pwsQFormat);
   ASSERT(wcslen(pwsQFormat) < MAX_FORMAT_LEN);

   wcscpy(pTempQueue->wsQFormat,pwsQFormat);

   // Ok, put the queue on the list to delete.
   pTempQueue->pNext = pqList->pQueues;
   pqList->pQueues = pTempQueue;

   return Status;
}

//-------------------------------------------------------------------
//  MqDeregisterQueue()
//
//  Remove the specified message queue from the list of queues to
//  be deleted by the context rundown routine. This would be done
//  if a queue (which is initially temporary) was turned into a 
//  permanent queue.
//-------------------------------------------------------------------
unsigned long MqDeregisterQueue( PCONTEXT_HANDLE phContext,
                                 wchar_t        *pwsQFormat )
{
   RPC_STATUS       Status = RPC_S_OK;
   MqTempQueueList *pqList = (MqTempQueueList*)phContext;
   MqTempQueue     *pTempQueue;
   MqTempQueue     *pTempToFree;

   if (!pqList)
      {
      return RPC_X_SS_IN_NULL_CONTEXT;
      }

   pTempQueue = pqList->pQueues;
   if (!lstrcmpiW(pTempQueue->wsQFormat,pwsQFormat))
      {
      pqList->pQueues = pTempQueue->pNext;
      I_RpcFree(pTempQueue);
      return RPC_S_OK;
      }

   while (pTempQueue->pNext)
      {
      if (!lstrcmpiW(pTempQueue->pNext->wsQFormat,pwsQFormat))
         {
         pTempToFree = pTempQueue->pNext;
         pTempQueue->pNext = pTempQueue->pNext->pNext;
         I_RpcFree(pTempToFree);
         break;
         }
      }

   return Status;
}

//-------------------------------------------------------------------
//  MqFreeContext()
//
//  Called to remove all of the queues registered for automatic
//  deletion and to close and free the context handle.
//-------------------------------------------------------------------
unsigned long MqFreeContext( PCONTEXT_HANDLE *pphContext,
                             long             fFreeContext )
{
   RPC_STATUS  Status = RPC_S_OK;
   HRESULT     hr;
   BOOL        fImpersonate = FALSE;
   MqTempQueueList *pqList = (MqTempQueueList*)*pphContext;
   MqTempQueue     *pTemp;
   MqTempQueue     *pToFree;

   // First, impersonate the client who registered these queues
   // to delete.
   if (pqList->hToken)
      {
      fImpersonate = SetThreadToken(NULL,pqList->hToken);
      #ifdef DBG
      if (!fImpersonate)
         {
         Status = GetLastError();
         }
      #endif
      }

   // Run through the list of queues deleting each one as
   // we go.
   pTemp = pqList->pQueues;
   while (pTemp)
      {
      pToFree = pTemp;
      pTemp = pTemp->pNext;

      hr = g_pMqDeleteQueue(pToFree->wsQFormat);
      #ifdef FALSE
      DbgPrint("Delete Queue: %S (hr: 0x%x)\n", pToFree->wsQFormat, hr );
      #endif
      I_RpcFree(pToFree);
      }

   // Stop the impersonation:
   if (fImpersonate)
      {
      if (!SetThreadToken(NULL,NULL))
         {
         Status = GetLastError();
         }
      }


   // Do we need to free up the context?
   if (pqList->hToken)
      {
      if (!CloseHandle(pqList->hToken))
         {
         Status = GetLastError();
         #ifdef DBG
         DbgPrint("MqFreeContext(): CloseHandle() Failed: Status: %d (0x%x)\n",Status,Status);
         #endif
         }
      }

   if (fFreeContext)
      {
      I_RpcFree(pqList);
      *pphContext = NULL;
      }
   else
      {
      pqList->hToken = 0;
      pqList->pQueues = NULL;
      }

   return Status;
}

//-------------------------------------------------------------------
//  PCONTEX_HANDLE_rundown()
//
//  This is the context rundown routine. It will delete all of the
//  Falcon message queues that are currently associated with the
//  specified context handle.
//-------------------------------------------------------------------
void __RPC_USER PCONTEXT_HANDLE_rundown( PCONTEXT_HANDLE phContext )
{
   RPC_STATUS  Status;

   Status = MqFreeContext(&phContext,FALSE);
}


//-------------------------------------------------------------------
//  StartMqManagement()
//
//  Called in dcomss\warpper\start.cxx by RPCSS to initialize the
//  MQ Management interface.
//-------------------------------------------------------------------
extern "C"
DWORD StartMqManagement()
{
   RPC_STATUS  Status;

   Status = RpcServerRegisterIf(MqMgr_ServerIfHandle,0,0);

   return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\dbgsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    DbgSvr.cxx

Abstract:

    The debugging support interfaces in RPCSS

Author:

    Kamen Moutafov    [KamenM]


Revision History:

    KamenM     Dec 99           Creation

--*/

#include <sysinc.h>

#include <wincrypt.h>
#include <wtypes.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#include <rpctrans.hxx>
#include <objidl.h>
#include <CellDef.hxx>
#include <DbgIdl.h>

START_C_EXTERN

RPC_STATUS RPC_ENTRY
DebugServerSecurityCallback (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    )
{
    RPC_STATUS Status, TempStatus;
    HANDLE TempHandle;
    PVOID SectionPointer;

    // Context is an SCALL
    Status = RpcImpersonateClient(Context);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    // try to open our own section - this is protected by ACL for admins & local system
    // only, so this should filter out unauthorized access
    Status = OpenDbgSection(&TempHandle, &SectionPointer, GetCurrentProcessId(), NULL);
    if (Status == RPC_S_OK)
        {
        CloseDbgSection(TempHandle, SectionPointer);
        }

    TempStatus = RpcRevertToSelfEx(Context);
    ASSERT(TempStatus == RPC_S_OK);
    return Status;
}

////////////////////////////////////////////////////////////////////
/// Local representation to wire representation translation routines
////////////////////////////////////////////////////////////////////

void TranslateLocalCallInfoToRemoteCallInfo(IN DebugCallInfo *LocalDebugInfo, 
                                            OUT RemoteDebugCallInfo *RemoteCallInfo)
{
    RemoteCallInfo->Type = LocalDebugInfo->Type;
    RemoteCallInfo->Status = LocalDebugInfo->Status;
    RemoteCallInfo->ProcNum = LocalDebugInfo->ProcNum;
    RemoteCallInfo->InterfaceUUIDStart = LocalDebugInfo->InterfaceUUIDStart;
    RemoteCallInfo->ServicingTID = LocalDebugInfo->ServicingTID;
    RemoteCallInfo->CallFlags = LocalDebugInfo->CallFlags;
    RemoteCallInfo->CallID = LocalDebugInfo->CallID;
    RemoteCallInfo->LastUpdateTime = LocalDebugInfo->LastUpdateTime;
    if (LocalDebugInfo->CallFlags & DBGCELL_LRPC_CALL)
        {
        RemoteCallInfo->ConnectionType = crtLrpcConnection;
        RemoteCallInfo->connInfo.Connection = LocalDebugInfo->Connection;
        }
    else
        {
        RemoteCallInfo->ConnectionType = crtOsfConnection;
        RemoteCallInfo->connInfo.Caller.PID = LocalDebugInfo->PID;
        RemoteCallInfo->connInfo.Caller.TID = LocalDebugInfo->TID;
        }
}

void TranslateLocalEndpointInfoToRemoteEndpointInfo(IN DebugEndpointInfo *LocalDebugInfo, 
                                                    OUT RemoteDebugEndpointInfo *RemoteEndpointInfo)
{
    RemoteEndpointInfo->Type = LocalDebugInfo->Type;
    RemoteEndpointInfo->ProtseqType = LocalDebugInfo->ProtseqType;
    RemoteEndpointInfo->Status = LocalDebugInfo->Status;

    // the endpoint name in the debug cell is not null terminated - process it specially
    RemoteEndpointInfo->EndpointNameLength = 0;
    RemoteEndpointInfo->EndpointName 
        = (unsigned char *)MIDL_user_allocate(DebugEndpointNameLength + 1);
    if (RemoteEndpointInfo->EndpointName != NULL)
        {
        memcpy(RemoteEndpointInfo->EndpointName, 
            LocalDebugInfo->EndpointName, DebugEndpointNameLength);
        RemoteEndpointInfo->EndpointName[DebugEndpointNameLength] = 0;
        RemoteEndpointInfo->EndpointNameLength 
            = strlen((const char *) RemoteEndpointInfo->EndpointName) + 1;
        }
}

void TranslateLocalThreadInfoToRemoteThreadInfo(IN DebugThreadInfo *LocalDebugInfo, 
                                                OUT RemoteDebugThreadInfo *RemoteThreadInfo)
{
    RemoteThreadInfo->Type = LocalDebugInfo->Type;
    RemoteThreadInfo->Status = LocalDebugInfo->Status;
    RemoteThreadInfo->LastUpdateTime = LocalDebugInfo->LastUpdateTime;
    RemoteThreadInfo->TID = LocalDebugInfo->TID;
    RemoteThreadInfo->Endpoint = LocalDebugInfo->Endpoint;
}

void TranslateLocalClientCallInfoToRemoteClientCallInfo(IN DebugClientCallInfo *LocalDebugInfo, 
                                                        OUT RemoteDebugClientCallInfo *RemoteClientCallInfo)
{
    RemoteClientCallInfo->Type = LocalDebugInfo->Type;
    RemoteClientCallInfo->ProcNum = LocalDebugInfo->ProcNum;
    RemoteClientCallInfo->ServicingThread = LocalDebugInfo->ServicingThread;
    RemoteClientCallInfo->IfStart = LocalDebugInfo->IfStart;
    RemoteClientCallInfo->CallID = LocalDebugInfo->CallID;
    RemoteClientCallInfo->CallTargetID = LocalDebugInfo->CallTargetID;

    // the endpoint in the debug cell is not null terminated - process it specially
    RemoteClientCallInfo->EndpointLength = 0;
    RemoteClientCallInfo->Endpoint 
        = (unsigned char *)MIDL_user_allocate(ClientCallEndpointLength + 1);
    if (RemoteClientCallInfo->Endpoint != NULL)
        {
        memcpy(RemoteClientCallInfo->Endpoint, 
            LocalDebugInfo->Endpoint, ClientCallEndpointLength);
        RemoteClientCallInfo->Endpoint[ClientCallEndpointLength] = 0;
        RemoteClientCallInfo->EndpointLength 
            = strlen((const char *) RemoteClientCallInfo->Endpoint) + 1;
        }
}

void TranslateLocalConnectionInfoToRemoteConnectionInfo(IN DebugConnectionInfo *LocalDebugInfo, 
                                                        OUT RemoteDebugConnectionInfo *RemoteConnectionInfo)
{
    RemoteConnectionInfo->Type = LocalDebugInfo->Type;
    RemoteConnectionInfo->Flags = LocalDebugInfo->Flags;
    RemoteConnectionInfo->LastTransmitFragmentSize 
        = LocalDebugInfo->LastTransmitFragmentSize;
    RemoteConnectionInfo->Endpoint = LocalDebugInfo->Endpoint;
    RemoteConnectionInfo->ConnectionID[0] 
        = HandleToUlong(LocalDebugInfo->ConnectionID[0]);
    RemoteConnectionInfo->ConnectionID[1] 
        = HandleToUlong(LocalDebugInfo->ConnectionID[1]);
    RemoteConnectionInfo->LastSendTime = LocalDebugInfo->LastSendTime;
    RemoteConnectionInfo->LastReceiveTime = LocalDebugInfo->LastReceiveTime;
}

void TranslateLocalCallTargetInfoToRemoteCallTargetInfo(IN DebugCallTargetInfo *LocalDebugInfo, 
                                                        OUT RemoteDebugCallTargetInfo *RemoteCallTargetInfo)
{
    RemoteCallTargetInfo->Type = LocalDebugInfo->Type;
    RemoteCallTargetInfo->ProtocolSequence = LocalDebugInfo->ProtocolSequence;
    RemoteCallTargetInfo->LastUpdateTime = LocalDebugInfo->LastUpdateTime;

    // the target server name in the debug cell is not null terminated - process it specially
    RemoteCallTargetInfo->TargetServerLength = 0;
    RemoteCallTargetInfo->TargetServer 
        = (unsigned char *)MIDL_user_allocate(TargetServerNameLength + 1);
    if (RemoteCallTargetInfo->TargetServer != NULL)
        {
        memcpy(RemoteCallTargetInfo->TargetServer, 
            LocalDebugInfo->TargetServer, TargetServerNameLength);
        RemoteCallTargetInfo->TargetServer[TargetServerNameLength] = 0;
        RemoteCallTargetInfo->TargetServerLength
            = strlen((const char *) RemoteCallTargetInfo->TargetServer) + 1;
        }
}

////////////////////////////////////////////////////////////////////
/// Remote get cell info routine
////////////////////////////////////////////////////////////////////

/* [fault_status][comm_status] */ error_status_t RemoteGetCellByDebugCellID( 
    /* [in] */ handle_t IDL_handle,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DebugCellID CellID,
    /* [in, out, unique] */ RemoteDebugCellUnion __RPC_FAR *__RPC_FAR *debugInfo)
{
    DebugCellUnion Container;
    RemoteDebugCellUnion *ActualDebugInfo;
    RPC_STATUS Status;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    ActualDebugInfo = (RemoteDebugCellUnion *) MIDL_user_allocate(sizeof(RemoteDebugCellUnion));

    if (ActualDebugInfo == NULL)
        return RPC_S_OUT_OF_MEMORY;

    Status = GetCellByDebugCellID(ProcessID, CellID, &Container);
    if (Status != RPC_S_OK)
        {
        MIDL_user_free(ActualDebugInfo);
        return Status;
        }

    ActualDebugInfo->UnionType = Container.callInfo.Type;
    if ((ActualDebugInfo->UnionType < dctFirstEntry) || (ActualDebugInfo->UnionType > dctLastEntry) 
        || (ActualDebugInfo->UnionType == dctInvalid) || (ActualDebugInfo->UnionType == dctFree)
        || (ActualDebugInfo->UnionType == dctUsedGeneric))
        {
        MIDL_user_free(ActualDebugInfo);
        return RPC_S_OBJECT_NOT_FOUND;
        }

    switch(ActualDebugInfo->UnionType)
        {
        case dctCallInfo:
            TranslateLocalCallInfoToRemoteCallInfo(&Container.callInfo, 
                &ActualDebugInfo->debugInfo.callInfo);
            break;

        case dctThreadInfo:
            TranslateLocalThreadInfoToRemoteThreadInfo(&Container.threadInfo,
                &ActualDebugInfo->debugInfo.threadInfo);
            break;

        case dctEndpointInfo:
            TranslateLocalEndpointInfoToRemoteEndpointInfo(&Container.endpointInfo, 
                &ActualDebugInfo->debugInfo.endpointInfo);
            break;

        case dctClientCallInfo:
            TranslateLocalClientCallInfoToRemoteClientCallInfo(&Container.clientCallInfo,
                &ActualDebugInfo->debugInfo.clientCallInfo);
            break;

        case dctConnectionInfo:
            TranslateLocalConnectionInfoToRemoteConnectionInfo(&Container.connectionInfo,
                &ActualDebugInfo->debugInfo.connectionInfo);
            break;

        case dctCallTargetInfo:
            TranslateLocalCallTargetInfoToRemoteCallTargetInfo(&Container.callTargetInfo,
                &ActualDebugInfo->debugInfo.callTargetInfo);
            break;

        default:
            ASSERT(0);

        }
    *debugInfo = ActualDebugInfo;
    return RPC_S_OK;
}

////////////////////////////////////////////////////////////////////
/// Remote call enumeration routines
////////////////////////////////////////////////////////////////////

typedef enum tagRemoteEnumerationHandleType
{
    rehtCallInfo,
    rehtEndpointInfo,
    rehtThreadInfo,
    rehtClientCallInfo
} RemoteEnumerationHandleType;

typedef struct tagRemoteCallInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    CallInfoEnumerationHandle h;
} RemoteCallInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugCallInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgCallEnumHandle __RPC_FAR *h,
    /* [in] */ DWORD CallID,
    /* [in] */ DWORD IfStart,
    /* [in] */ int ProcNum,
    /* [in] */ DWORD ProcessID)
{
    RemoteCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteCallInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtCallInfo;
    Status = OpenRPCDebugCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugCallInfo( 
    /* [in] */ DbgCallEnumHandle h,
    /* [unique][out][in] */ RemoteDebugCallInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugCallInfo *NextCall;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteCallInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtCallInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugCallInfo(rh->h, &NextCall, CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugCallInfo *) MIDL_user_allocate(sizeof(RemoteDebugCallInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalCallInfoToRemoteCallInfo(NextCall, *debugInfo);
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugCallInfoEnumeration( 
    /* [out][in] */ DbgCallEnumHandle __RPC_FAR *h)
{
    RemoteCallInfoEnumerationHandle *rh;

    rh = (RemoteCallInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtCallInfo)
        return ERROR_INVALID_HANDLE;

    DbgCallEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgCallEnumHandle_rundown(DbgCallEnumHandle h)
{
    RemoteCallInfoEnumerationHandle *rh;

    rh = (RemoteCallInfoEnumerationHandle *)h;

    FinishRPCDebugCallInfoEnumeration(&rh->h);
    delete rh;
}


////////////////////////////////////////////////////////////////////
/// Remote endpoint enumeration routines
////////////////////////////////////////////////////////////////////

typedef struct tagRemoteEndpointInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    EndpointInfoEnumerationHandle h;
} RemoteEndpointInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugEndpointInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgEndpointEnumHandle __RPC_FAR *h,
    /* [in] */ short EndpointSize,
    /* [size_is][in] */ unsigned char __RPC_FAR *Endpoint)
{
    RemoteEndpointInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteEndpointInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtEndpointInfo;
    Status = OpenRPCDebugEndpointInfoEnumeration((EndpointSize > 0) ? (char *)Endpoint : NULL, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugEndpointInfo( 
    /* [in] */ DbgEndpointEnumHandle h,
    /* [unique][out][in] */ RemoteDebugEndpointInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteEndpointInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugEndpointInfo *NextEndpoint;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteEndpointInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtEndpointInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugEndpointInfo(rh->h, &NextEndpoint, CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugEndpointInfo *) MIDL_user_allocate(sizeof(RemoteDebugEndpointInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalEndpointInfoToRemoteEndpointInfo(NextEndpoint, *debugInfo);
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugEndpointInfoEnumeration( 
    /* [out][in] */ DbgEndpointEnumHandle __RPC_FAR *h)
{
    RemoteEndpointInfoEnumerationHandle *rh;

    rh = (RemoteEndpointInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtEndpointInfo)
        return ERROR_INVALID_HANDLE;

    DbgEndpointEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgEndpointEnumHandle_rundown(DbgEndpointEnumHandle h)
{
    RemoteEndpointInfoEnumerationHandle *rh;

    rh = (RemoteEndpointInfoEnumerationHandle *)h;

    FinishRPCDebugEndpointInfoEnumeration(&rh->h);
    delete rh;
}


////////////////////////////////////////////////////////////////////
/// Remote thread enumeration routines
////////////////////////////////////////////////////////////////////

typedef struct tagRemoteThreadInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    ThreadInfoEnumerationHandle h;
} RemoteThreadInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugThreadInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgThreadEnumHandle __RPC_FAR *h,
    /* [in] */ DWORD ProcessID,
    /* [in] */ DWORD ThreadID)
{
    RemoteThreadInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteThreadInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtThreadInfo;
    Status = OpenRPCDebugThreadInfoEnumeration(ProcessID, ThreadID, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugThreadInfo( 
    /* [in] */ DbgThreadEnumHandle h,
    /* [unique][out][in] */ RemoteDebugThreadInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteThreadInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugThreadInfo *NextThread;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteThreadInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtThreadInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugThreadInfo(rh->h, &NextThread, CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugThreadInfo *) MIDL_user_allocate(sizeof(RemoteDebugThreadInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalThreadInfoToRemoteThreadInfo(NextThread, *debugInfo);
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugThreadInfoEnumeration( 
    /* [out][in] */ DbgThreadEnumHandle __RPC_FAR *h)
{
    RemoteThreadInfoEnumerationHandle *rh;

    rh = (RemoteThreadInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtThreadInfo)
        return ERROR_INVALID_HANDLE;

    DbgThreadEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgThreadEnumHandle_rundown(DbgThreadEnumHandle h)
{
    RemoteThreadInfoEnumerationHandle *rh;

    rh = (RemoteThreadInfoEnumerationHandle *)h;

    FinishRPCDebugThreadInfoEnumeration(&rh->h);
    delete rh;
}

////////////////////////////////////////////////////////////////////
/// Remote client call enumeration routines
////////////////////////////////////////////////////////////////////

typedef struct tagRemoteClientCallInfoEnumerationHandle
{
    RemoteEnumerationHandleType ThisHandleType;
    ClientCallInfoEnumerationHandle h;
} RemoteClientCallInfoEnumerationHandle;

error_status_t RemoteOpenRPCDebugClientCallInfoEnumeration( 
    /* [in] */ handle_t IDL_handle,
    /* [out] */ DbgClientCallEnumHandle __RPC_FAR *h,
    /* [in] */ DWORD CallID,
    /* [in] */ DWORD IfStart,
    /* [in] */ int ProcNum,
    /* [in] */ DWORD ProcessID)
{
    RemoteClientCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;

    *h = NULL;

    rh = new RemoteClientCallInfoEnumerationHandle;
    if (rh == NULL)
        return RPC_S_OUT_OF_MEMORY;

    rh->ThisHandleType = rehtClientCallInfo;
    Status = OpenRPCDebugClientCallInfoEnumeration(CallID, IfStart, ProcNum, ProcessID, &rh->h);
    if (Status != RPC_S_OK)
        {
        delete rh;
        return Status;
        }

    *h = rh;

    return RPC_S_OK;
}

error_status_t RemoteGetNextRPCDebugClientCallInfo( 
    /* [in] */ DbgClientCallEnumHandle h,
    /* [unique][out][in] */ RemoteDebugClientCallInfo __RPC_FAR *__RPC_FAR *debugInfo,
    /* [unique][out][in] */ RemoteDebugCallTargetInfo __RPC_FAR *__RPC_FAR *CallTargetDebugInfo,
    /* [out] */ DebugCellID __RPC_FAR *CellID,
    /* [out] */ DWORD __RPC_FAR *ProcessID)
{
    RemoteClientCallInfoEnumerationHandle *rh;
    RPC_STATUS Status;
    DebugClientCallInfo *NextClientCall;
    DebugCallTargetInfo *NextCallTarget;

    if (debugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (CallTargetDebugInfo == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    *debugInfo = NULL;
    *CallTargetDebugInfo = NULL;
    CellID->SectionID = 0;
    CellID->CellID = 0;
    
    rh = (RemoteClientCallInfoEnumerationHandle *)h;
    if (rh->ThisHandleType != rehtClientCallInfo)
        return ERROR_INVALID_HANDLE;

    Status = GetNextRPCDebugClientCallInfo(rh->h, &NextClientCall, &NextCallTarget, 
        CellID, ProcessID);
    if (Status == RPC_S_OK)
        {
        *debugInfo = (RemoteDebugClientCallInfo *) MIDL_user_allocate(sizeof(RemoteDebugClientCallInfo));
        if (*debugInfo != NULL)
            {
            TranslateLocalClientCallInfoToRemoteClientCallInfo(NextClientCall, *debugInfo);

            *CallTargetDebugInfo 
                = (RemoteDebugCallTargetInfo *)MIDL_user_allocate(sizeof(RemoteDebugCallTargetInfo));
            if (*CallTargetDebugInfo != NULL)
                {
                if ((NextCallTarget != NULL) && (NextCallTarget->Type != dctCallTargetInfo))
                    {
                    // inconsistent info - return NULL for call target
                    MIDL_user_free(*CallTargetDebugInfo);
                    *CallTargetDebugInfo = NULL;
                    NextCallTarget = NULL;
                    }
                else
                    {
                    TranslateLocalCallTargetInfoToRemoteCallTargetInfo(NextCallTarget, *CallTargetDebugInfo);
                    }
                }
            // else - don't care - this is a best effort. We will return what we
            // can. Client is prepared to handle NULL in the call target
            }
        else
            Status = RPC_S_OUT_OF_MEMORY;
        }
    return Status;
}

error_status_t RemoteFinishRPCDebugClientCallInfoEnumeration( 
    /* [out][in] */ DbgClientCallEnumHandle __RPC_FAR *h)
{
    RemoteClientCallInfoEnumerationHandle *rh;

    rh = (RemoteClientCallInfoEnumerationHandle *)*h;

    if (rh == NULL)
        RpcRaiseException(ERROR_INVALID_PARAMETER);

    if (rh->ThisHandleType != rehtClientCallInfo)
        return ERROR_INVALID_HANDLE;

    DbgClientCallEnumHandle_rundown(*h);

    *h = NULL;
    return RPC_S_OK;
}

void __RPC_USER DbgClientCallEnumHandle_rundown(DbgClientCallEnumHandle h)
{
    RemoteClientCallInfoEnumerationHandle *rh;

    rh = (RemoteClientCallInfoEnumerationHandle *)h;

    FinishRPCDebugClientCallInfoEnumeration(&rh->h);
    delete rh;
}

END_C_EXTERN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\epmap\worker.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    worker.c

Abstract:

    This file contains the real stuff for the EP Mapper.

Author:

    Bharat Shah  (barat) 17-2-92

Revision History:

    06-03-97    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <sysinc.h>
#include <wincrypt.h>
#include <rpc.h>
#include <rpcndr.h>
#include "epmp.h"
#include "eptypes.h"
#include "local.h"
#include "twrproto.h"
#include <winsock2.h>

#define StringCompareA lstrcmpiA
#define StringLengthA lstrlenA

#define EP_S_DUPLICATE_ENTRY                 0x16c9a0d8
RPC_IF_ID LocalNullUuid = {0};

UUID MgmtIf = {
              0xafa8bd80,
              0x7d8a,
              0x11c9,
              {0xbe, 0xf4, 0x08, 0x00, 0x2b, 0x10, 0x29, 0x89}
              };

const int IP_ADDR_OFFSET = 0x4b;

void
PatchTower(
    IN OUT twr_t *Tower,
    IN int address)
{
    int UNALIGNED *pIPAddr;

    pIPAddr = (int UNALIGNED *) (((char *) Tower) + IP_ADDR_OFFSET);

    //
    // Patch the tower
    //
    *pIPAddr = address;
}

//
// Forward definitions
//

USHORT
GetProtseqIdAnsi(
    PSTR Protseq
    );

RPC_STATUS
DelayedUseProtseq(
    USHORT id
    );

VOID
CompleteDelayedUseProtseqs(
    void
    );

void
DeletePSEP(
    PIFOBJNode Node,
    char * Protseq,
    char * Endpoint
    );

void
PurgeOldEntries(
    PIFOBJNode Node,
    PPSEPNode  List,
    BOOL       StrictMatch
    );

RPC_STATUS
MatchPSAndEP (
    PPSEPNode Node,
    void *Pseq,
    void * Endpoint,
    unsigned long Version
    );

PPSEPNode
FindPSEP (
    register PPSEPNode List,
    char * Pseq,
    char * Endpoint,
    unsigned long Version,
    PFNPointer2 Compare
    );

PIFOBJNode
FindIFOBJNode(
    register PIFOBJNode List,
    UUID * Obj,
    UUID * IF,
    unsigned long Version,
    unsigned long Inq,
    unsigned long VersOpts,
    PFNPointer Compare
    );





PIENTRY
MatchByKey(
    register PIENTRY pList,
    unsigned long key
    )
/*++

Routine Description:

    This routine Seqrches the Link-list of IF-OBJ nodes based on
    key supplied.

Arguments:

    List  - The Linked list [head] - to be searched

    key   - The Id

Return Value:

    Returns a pointer to the matching IFObj node in the list or returns NULL.

--*/
{
    CheckInSem();

     for (; pList && pList->Id < key; pList = pList->Next)
        {
        ;   // Empty body
        }

    return(pList);
}




RPC_STATUS RPC_ENTRY
GetForwardEp(
    UUID *IfId,
    RPC_VERSION * IFVersion,
    UUID *Object,
    unsigned char * Protseq,
    void * * EpString
    )
/*++

Routine Description:

    Server rutime has received a pkt destined for a dynamically
    declared endpoint. Epmapper must return the servers endpoint
    to enable the runtime to correctly forward the pkt.

Arguments:

    IF -  Server Interface UUID

    IFVersion - Version of the Interface

    Obj - UUID of the Object

    Protseq - Ptotocol sequence the interface is using.

    EpString - Place to store the endpoint structure.

Return Value:

    Returns a pointer to a string containing the server's endpoint.

    RPC_S_OUT_OF_MEMORY
    EPT_S_NOT_REGISTERED

---*/
{

    PIFOBJNode     pNode;
    PPSEPNode      pPSEPNode;
    unsigned short len;
    char *         String;
    PFNPointer     Match;
    unsigned long InqType;
    unsigned long Version = VERSION(IFVersion->MajorVersion,
                                    IFVersion->MinorVersion);

    if (memcmp((char *)IfId, (char *)&MgmtIf, sizeof(UUID)) == 0)
        {
        InqType =   RPC_C_EP_MATCH_BY_OBJ;
        Match   =   SearchIFObjNode;
        }
    else
        {
        InqType = 0;
        Match   = WildCardMatch;
        }

    *EpString = 0;

    EnterSem();

    pNode = IFObjList;

    if (pNode == 0)
        {
        LeaveSem();
        return(EPT_S_NOT_REGISTERED);
        }

    while (pNode != 0)
        {
        pNode = FindIFOBJNode(
                    pNode,
                    Object,
                    IfId,
                    Version,
                    InqType,
                    0,
                    Match
                    );

        if (pNode == 0)
            {
            LeaveSem();
            return(EPT_S_NOT_REGISTERED);
            }

        pPSEPNode = pNode->PSEPlist;

        pPSEPNode = FindPSEP(
                        pPSEPNode,
                        Protseq,
                        NULL,
                        0L,
                        MatchPSAndEP
                        );

        if (pPSEPNode == 0)
            {
            pNode = pNode->Next;
            if (pNode == 0)
                {
                LeaveSem();
                return(EPT_S_NOT_REGISTERED);
                }
            continue;
            }


        // We now have a PSEPNode. We just ought to return the first one!

        // Use I_RpcAllocate To Allocate because runtime will free this!
        String = I_RpcAllocate( len = (strlen(pPSEPNode->EP) + 1) );
        if (String == 0)
            {
            LeaveSem();
            return(RPC_S_OUT_OF_MEMORY);
            }

// Do we really need memset()?. memcpy set the bytes...
        memset(String, 0, len);
        memcpy(String, pPSEPNode->EP, len);

        *EpString = String;
        LeaveSem();

        return(RPC_S_OK);
        } // while loop

    // we never go through here.
    return(EPT_S_NOT_REGISTERED);
}




RPC_STATUS
SearchIFObjNode(
    PIFOBJNode pNode,
    UUID *Object,
    UUID *IfUuid,
    unsigned long Version,
    unsigned long InqType,
    unsigned long VersOption
    )
/*++

Routine Description:

    This routine Seqrches the Link-list of IF-OBJ nodes based on
    Obj, IFUuid, IFVersion, Inqtype [Ignore OBJ, IgnoreIF, etc],
    and VersOption [Identical Ver, Compatible Vers. etc]

Arguments:

    List - The Linked list head - to be searched

    Obj - UUID of the Object

    IF - Interface UUID

    Version - Version of the Interface

    InqType - Type of Inquiry  [Filter options based on IF/Obj/Both

    VersOpts - Filter options based on Version

Return Value:

    Returns a pointer to the matching IFObj node in the list or returns NULL.

--*/
{
    switch (InqType)
        {
        default:
        case RPC_C_EP_ALL_ELTS:
            return 0;

        case RPC_C_EP_MATCH_BY_BOTH:
            if (memcmp(
                    (char *)&pNode->ObjUuid,
                    (char *)Object,
                    sizeof(UUID))
                    )
                return(1);
                // Intentionally Fall through ..

        case RPC_C_EP_MATCH_BY_IF:
            return(!(
                        (
                        !memcmp(
                            (char *)&pNode->IFUuid,
                            (char *)IfUuid,
                            sizeof(UUID)
                            )
                        )
                    &&
                        (
                            (  (VersOption == RPC_C_VERS_UPTO)
                            && pNode->IFVersion <= Version)
                        ||  (  (VersOption == RPC_C_VERS_COMPATIBLE)
                            && ((pNode->IFVersion & 0xFFFF0000) ==
                                      (Version & 0xFFFF0000))
                            && (pNode->IFVersion >= Version)
                            )
                        ||  (  (VersOption == RPC_C_VERS_EXACT)
                            && (pNode->IFVersion == Version)
                            )
                        ||  (VersOption == RPC_C_VERS_ALL)
                        ||  (  (VersOption == RPC_C_VERS_MAJOR_ONLY)
                            && ((pNode->IFVersion & 0xFFFF0000L)
                                       == (Version & 0xFFFF0000L))
                            )
                        ||  (  (VersOption ==
                                         I_RPC_C_VERS_UPTO_AND_COMPATIBLE)
                            && ((pNode->IFVersion & 0xFFFF0000L)
                                       == (Version & 0xFFFF0000L))
                            && (pNode->IFVersion <= Version)
                            )
                        )
                    )
                  ); // return(

        case RPC_C_EP_MATCH_BY_OBJ:
            return(
                memcmp(
                    (char *)&pNode->ObjUuid,
                    (char *)Object,
                    sizeof(UUID)
                    )
                );
        } // switch

}




PIFOBJNode
FindIFOBJNode(
    register PIFOBJNode List,
    UUID * Obj,
    UUID * IF,
    unsigned long Version,
    unsigned long Inq,
    unsigned long VersOpts,
    PFNPointer Compare
    )
/*++

Routine Description:

    This routine Seqrches the Link-list of IF-OBJ nodes based on
    Obj and IF specified.

Arguments:

    List  - The Linked list head - to be searched

    Obj   - UUID of the Object

    IF    - Interface UUID

    Version - Version of the Interface

    Inq - Type of Inquiry [Filter based on IF/OB/Both]

    VersOpt - Filter based on version [<=, >=, == etc]

    Compare() - A pointer to function used for searching.
                WildCardMatch or ExactMatch.

Return Value:

    Returns a pointer to the matching IFObj node in the list or returns NULL.

--*/
{
    CheckInSem();

    for (; (List !=NULL) && (*Compare)(List, Obj, IF, Version, Inq, VersOpts);
        List = List->Next)
        {
        ;   // Empty body
        }

    return (List);
}




PPSEPNode
FindPSEP (
    register PPSEPNode List,
    char * Pseq,
    char * Endpoint,
    unsigned long Version,
    PFNPointer2 Compare
    )
/*++

Routine Description:

    This routine Seqrches the Link-list of PSEP nodes based on
    Protocol sequence and Endpoint specified.

Arguments:

    List  - The Linked list head - to be searched

    Pseq  - Protocol sequence string specified

    Endpoint - Endpoint string specified

    Version - Version of the Interface

    Compare() - A pointer to function used for searching.

Return Value:

    Returns a pointer to the matching PSEP node in the list or returns NULL.

--*/
{
    CheckInSem();

    for (; List && (*Compare)(List, Pseq, Endpoint, Version); List = List->Next)
        {
        ;   // Empty body
        }

    return (List);

    if (Version);   // May need this if we overload FindNode and collapse
                    // FindPSEP and FindIFOBJ
}


RPC_STATUS
ExactMatch(
    PIFOBJNode Node,
    UUID *Obj,
    UUID *IF,
    unsigned long Version,
    unsigned long InqType,
    unsigned long VersOptions
    )
/*++

Routine Description:

    This routine compares a Node in the IFOBJList to [Obj, IF, Version] triple
    and returns 0 if there is an exact match else returns 1

Arguments:

    Node  - An IFOBJ node

    Obj   - UUID of the Object

    IF    - Interface UUID

    Version - Version of the Interface

Return Value:

    Returns 0 if there is an exact match; 1 otherwise

--*/
{
    return(( memcmp(&Node->ObjUuid, Obj,sizeof(UUID))
          || memcmp(&Node->IFUuid, IF, sizeof(UUID))
          || (Node->IFVersion != Version)));
}




RPC_STATUS
WildCardMatch (
    PIFOBJNode Node,
    UUID *Obj,
    UUID *IF,
    unsigned long Version,
    unsigned long InqType,
    unsigned long VersOptions
    )
/*++

Routine Description:

    This routine compares a Node in the IFOBJList to [Obj, IF, Version] triple
    and returns 0 if there is an exact match or if registered IF-Obj node
    has a NULL Obj UUid and version of the registed IF_Obj is >= that
    supplied

Arguments:

    Node - An IFOBJ node

    Obj - UUID of the Object

    IF - Interface UUID

    Version - Version of the Interface

Return Value:

    Returns 0 if there is a wild card match ; 1 otherwise

--*/
{
    if (   (!memcmp(&Node->IFUuid, IF, sizeof(UUID)))
        && ((Node->IFVersion & 0xFFFF0000L) ==  (Version & 0xFFFF0000L))
        && (Node->IFVersion >= Version)
        && ((!memcmp(&Node->ObjUuid, Obj, sizeof(UUID))) ||
            (IsNullUuid(&Node->ObjUuid)) ) )
        {
        return(0);
        }

    return(1);
}



RPC_STATUS
MatchPSAndEP (
    PPSEPNode Node,
    void *Pseq,
    void * Endpoint,
    unsigned long Version
    )
/*++

Routine Description:

    This routine Matches A Node on PSEP list with given Protseq and Endpoint
    If Pseq is given pseqs are matched, if Endpoint is given Endpoints
    are matched, if neither is given returns true, if both are given
    both are matched.

Arguments:

    Node - A PSEP node on PSEP list.

    Pseq - Protocol Sequence string

    Endpoint - Endpoint string

Return Value:

    Returns 0 if Matched successfully, 1 otherwise.

--*/
{
    return (  (Pseq && RpcpStringCompareA(Node->Protseq, Pseq))
           || (Endpoint && RpcpStringCompareA(Node->EP, Endpoint)) );
}




void
PurgeOldEntries(
    PIFOBJNode Node,
    PPSEPNode List,
    BOOL StrictMatch
    )
{
    PPSEPNode Tmp, DeleteMe;
    char * Endpoint = 0;

    CheckInSem();

    Tmp = Node->PSEPlist;

    while (Tmp != 0)
        {
        if (StrictMatch == TRUE)
            Endpoint = Tmp->EP;

        if (DeleteMe = FindPSEP(List, Tmp->Protseq,  Endpoint, 0L, MatchPSAndEP))
            {
            DeleteMe = Tmp;
            Tmp = Tmp->Next;
            UnLinkFromPSEPList(&Node->PSEPlist, DeleteMe);
            DeleteMe->Signature = FREE;
            FreeMem(DeleteMe);
            }
        else
            {
            Tmp = Tmp->Next;
            }
        }
}




RPC_STATUS
IsNullUuid (
    UUID * Uuid
    )
/*++

Routine Description:

    This routine checks if a UUID is Nil

Arguments:

    Uuid - UUID to be tested

Return Value:

   Returns 1 if it is a Nil UUID
           0 otherwise.

--*/
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;

    if (   (Vector[0] == 0)
        && (Vector[1] == 0)
        && (Vector[2] == 0)
        && (Vector[3] == 0))
        return(1);

    return(0);
}



twr_p_t
NewTower(
    twr_p_t Tower
    )
/*++

Routine Description:

    This routine returns a New, Duplicated tower

Arguments:

    Tower - The tower that needs to be duplicated.

Return Value:

    Retunes a pointer to a new tower if successful else returns
    NULL

--*/
{
    unsigned short len;
    twr_p_t NewTower;

    len =  (unsigned short)(sizeof(Tower->tower_length) + Tower->tower_length);

    if ((NewTower = MIDL_user_allocate(len)) != NULL)
        {
        memcpy((char *)NewTower, (char *)Tower, len);
        }

    return(NewTower);
}


const unsigned long EPLookupHandleSignature = 0xFAFAFAFA;


PSAVEDCONTEXT
GetNewContext(
    unsigned long Type
    )
/*++

Routine Description

++*/
{
    PSAVEDCONTEXT Context;

    if ( ((Context = AllocMem(sizeof(SAVEDCONTEXT))) == 0) )
        return 0;

    memset(Context, 0, sizeof(SAVEDCONTEXT));

    Context->Cb = sizeof(SAVEDCONTEXT);
    Context->Type = Type;
    Context->Signature = EPLookupHandleSignature;
    EnLinkContext(Context);

    return(Context);
}

const unsigned int EPMapSignature = 0xCBBCCBBC;
const unsigned int EPLookupSignature = 0xABBAABBA;


RPC_STATUS
AddToSavedContext(
    PSAVEDCONTEXT Context,
    PIFOBJNode Node,
    PPSEPNode  Psep,
    unsigned long Calltype,
    BOOL fPatchTower,
    int PatchTowerAddress
    )
{
    void * NewNode;
    PSAVEDTOWER SavedTower;
    PSAVED_EPT SavedEndpoint;
    unsigned long Size;
    unsigned long TowerSize;

    ASSERT(Calltype == Context->Type);

    switch (Calltype)
        {
        case EP_MAP:
            Size = sizeof(SAVEDTOWER) ;
            if ((NewNode = AllocMem(Size)) == 0)
                return(RPC_S_OUT_OF_MEMORY);

            SavedTower = (PSAVEDTOWER) NewNode;
            memset(SavedTower, 0, Size);
            SavedTower->Cb          = Size;
            SavedTower->Signature   = EPMapSignature;
            SavedTower->Tower       = NewTower(Psep->Tower);

            if (SavedTower->Tower == 0)
                {
                FreeMem(NewNode);
                return(RPC_S_OUT_OF_MEMORY);
                }

            if (fPatchTower)
                {
                PatchTower(SavedTower->Tower, PatchTowerAddress);
                }
            break;

        case EP_LOOKUP:
            Size =  sizeof(SAVED_EPT) + strlen(Node->Annotation) + 1;

            if ((NewNode = AllocMem(Size)) == 0)
                return(RPC_S_OUT_OF_MEMORY);

            SavedEndpoint = (PSAVED_EPT) NewNode;
            memset(SavedEndpoint, 0, Size);
            SavedEndpoint->Cb           = Size;
            SavedEndpoint->Signature    = EPLookupSignature;
            SavedEndpoint->Tower        = NewTower(Psep->Tower);
            SavedEndpoint->Annotation   = (char *)NewNode +
                                                  sizeof(SAVED_EPT);
            memcpy( (char *) &SavedEndpoint->Object,
                               (char *)&Node->ObjUuid,
                               sizeof(UUID)
                               );
            strcpy(SavedEndpoint->Annotation, Node->Annotation);

            if (SavedEndpoint->Tower == 0)
                {
                FreeMem(NewNode);
                return(RPC_S_OUT_OF_MEMORY);
                }
            if (fPatchTower)
                {
                PatchTower(SavedEndpoint->Tower, PatchTowerAddress);
                }
            break;

        default:
            ASSERT(!"Unknown lookup type\n");
    	    return(RPC_S_INTERNAL_ERROR);
            break;

    }

    Link((PIENTRY *)(&Context->List), NewNode);

    return(RPC_S_OK);
}




RPC_STATUS
GetEntriesFromSavedContext(
    PSAVEDCONTEXT Context,
    char * Buffer,
    unsigned long Requested,
    unsigned long *Returned
    )
{

    PIENTRY SavedEntry = (PIENTRY)Context->List;
    PIENTRY TmpEntry;
    unsigned long Type = Context->Type;

    while ( (*Returned < Requested) && (SavedEntry != 0) )
        {
        switch (Type)
            {
            case EP_MAP:
                ((I_Tower *)Buffer)->Tower = ((PSAVEDTOWER)SavedEntry)->Tower;
                Buffer = Buffer + sizeof(I_Tower);
                break;

            case EP_LOOKUP:
                ((ept_entry_t *)Buffer)->tower = ((PSAVED_EPT)SavedEntry)->Tower;
                strcpy(((ept_entry_t *)Buffer)->annotation,
                       ((PSAVED_EPT)SavedEntry)->Annotation);
                memcpy(Buffer,(char *)&((PSAVED_EPT)SavedEntry)->Object,
                       sizeof(UUID));
                Buffer = Buffer + sizeof(ept_entry_t);
                break;

            default:
                ASSERT(!"Unknown Inquiry Type");
                break;
            }

        (*Returned)++;
        TmpEntry = SavedEntry;
        SavedEntry = SavedEntry->Next;
        UnLink((PIENTRY *)&Context->List, TmpEntry);
        FreeMem(TmpEntry);
        }

    return(RPC_S_OK);
}




RPC_STATUS
GetEntries(
    UUID *ObjUuid,
    UUID *IFUuid,
    unsigned long Version,
    char * Pseq,
    ept_lookup_handle_t *key,
    char * Buffer,
    unsigned long Calltype,
    unsigned long Requested,
    unsigned long *Returned,
    unsigned long InqType,
    unsigned long VersOptions,
    PFNPointer Match
    )
/*++

Routine Description:

    This is a generic routine for retreiving a series [as spec. by Requested]
    of Towers (in case of Map) or ept_entry_t's in case of Lookup.

Arguments:

    ObjUuid - Object Uuid

    IfUuid - Interface Uuid

    Version - InterfaceVersion [hi ushort = VerMajor, lo ushort VerMinor]

    Protseq - An ascii string specifying the protocol seq.

    key - A resume key - If NULL, search is started from the beginning
        if non-null, represents an encoding from where the epmapper
        supposed to start searching. It is an opaque value as far
        as the client is concerned.

    Buffer - A buffer of entries returned

    Calltype - A flag to indicate whether Ep_entries or string bindings
        are to be returned.

    Requested - Max no. of entries requested

    Returned - Actual no of entroes returned

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK

    EP_S_NOT_REGISTERED

--*/
{
    PIFOBJNode pNode=NULL, pList = IFObjList;
    unsigned long err=0, fResumeNodeFound=0;
    PPSEPNode pPSEPNode;
    char * buffer = Buffer;
    PSAVEDCONTEXT Context = (PSAVEDCONTEXT) *key;
    ept_lookup_handle_t LOOKUP_FINISHED = (ept_lookup_handle_t) LongToPtr(0xffffffff);
    int UNALIGNED *pIPAddr;
    BOOL fPatchTower;
    int PatchTowerAddress;
    SOCKADDR_STORAGE SockAddr;
    ULONG BufferSize;
    int FormatType;
    RPC_STATUS RpcStatus;

    *Returned = 0;

    EnterSem();

    if (*key)
        {
        if (*key == LOOKUP_FINISHED)
            {
            *key = 0;
            LeaveSem();
            return(EP_S_NOT_REGISTERED);
            }

        if (Context->Signature != EPLookupHandleSignature)
            {
            LeaveSem();
            return EP_S_CANT_PERFORM_OP;
            }

        err = GetEntriesFromSavedContext(Context, Buffer, Requested, Returned);
        if (Context->List == 0)
            {
            UnLink((PIENTRY *)&GlobalContextList, (PIENTRY)Context);
            FreeMem(Context);

            // Setting the Key To FFFFFFFFL is a hack for down level
            // Version 1.0 Ep Clients who never expected getting a key 0
            // and Success!
            if (Requested <= 1)
                *key = LOOKUP_FINISHED;
            else
                *key = 0L;

            LeaveSem();
            return(err);
            }

        LeaveSem();
        return(err);
        }

    *key = 0;
    while ((!err))
        {
        if ((pNode = FindIFOBJNode(
                        pList,
                        ObjUuid,
                        IFUuid,
                        Version,
                        InqType,
                        VersOptions,
                        Match)) == 0)
            {
            break;
            }

        pPSEPNode = pNode->PSEPlist;

        while (pPSEPNode != 0)
            {
            if ((pPSEPNode = FindPSEP(pPSEPNode, Pseq, NULL, 0L,
                              MatchPSAndEP)) == 0)
                break;

            fPatchTower = FALSE;
            if (StringCompareA(pPSEPNode->Protseq, "ncacn_ip_tcp") == 0
                || StringCompareA(pPSEPNode->Protseq, "ncadg_ip_udp") == 0
                || StringCompareA(pPSEPNode->Protseq, "ncacn_http") == 0)
                {
                pIPAddr = (int UNALIGNED *) ((char *) pPSEPNode->Tower + IP_ADDR_OFFSET);

                if (*pIPAddr == 0)
                    {
                    BufferSize = sizeof(SockAddr);

                    RpcStatus = I_RpcServerInqLocalConnAddress(NULL,
                        &SockAddr,
                        &BufferSize,
                        &FormatType);

                    if (RpcStatus == RPC_S_OK)
                        {
                        // IPv6 towers don't exist yet - they are not defined
                        // by DCE. Do patching for IPv4 only
                        if (FormatType == RPC_P_ADDR_FORMAT_TCP_IPV4)
                            {
                            PatchTowerAddress = ((SOCKADDR_IN *)&SockAddr)->sin_addr.S_un.S_addr;
                            fPatchTower = TRUE;
                            }
                        }

                    }
                }

            if (*Returned < Requested)
                {
                err = PackDataIntoBuffer(&buffer, pNode, pPSEPNode, Calltype, fPatchTower, PatchTowerAddress);
                if (err == RPC_S_OK)
                    {
                    (*Returned)++;
                    }
                else
                    {
                    ASSERT(err == RPC_S_OUT_OF_MEMORY);
                    break;
                    }
                }
            else
                {
                if (Context == 0)
                    {
                    *key = (ept_lookup_handle_t) (Context = GetNewContext(Calltype));
                    if (Context == 0)
                        {
                        err = RPC_S_OUT_OF_MEMORY;
                        break;
                        }
                    }
                AddToSavedContext(Context, pNode, pPSEPNode, Calltype, fPatchTower, PatchTowerAddress);
                }

            pPSEPNode = pPSEPNode->Next;
            } // while - over PSEPList

        pList = pNode->Next;
        } // while - over IFOBJList


    LeaveSem();

    if ((*Returned == 0) && Requested  && (!err))
        {
        err = EP_S_NOT_REGISTERED;
        }

    if ((*Returned <= Requested) &&  (Context == 0))
        {
        if (Requested <= 1)
            *key = LOOKUP_FINISHED;
        else
            *key = 0L;
        }

    return(err);
}




RPC_STATUS
PackDataIntoBuffer(
    char * * Buffer,
    PIFOBJNode Node,
    PPSEPNode PSEP,
    unsigned long Type,
    BOOL fPatchTower,
    int PatchTowerAddress
    )
/*++

Routine Description:

    This routine copies 1 entry [Either a Tower or ept_entry]
    in the Buffer, increments buffer appropriately.

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    Node - IFOBJNode

    PSEP - PSEPNode

    Type - Type of entry to be copied

    PatchTower - if TRUE, the newly created tower needs to be patched. If
        FALSE, the tower doesn't need to be patched

    PatchTowerAddress - an IPv4 representation of the address to be put
        in the tower. The IPv4 address must be in network byte order

Return Value:

    RPC_S_OK or RPC_S_* for error

--*/
{
    I_Tower * Twr;
    ept_entry_t *p;

    switch (Type)
        {
        case EP_MAP:
            Twr = (I_Tower *)(* Buffer);
            Twr->Tower = NewTower(PSEP->Tower);
            if (Twr->Tower == 0)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            if (fPatchTower)
                PatchTower(Twr->Tower, PatchTowerAddress);
            *Buffer += sizeof(I_Tower);
            break;

        case EP_LOOKUP:
            p = (ept_entry_t *)(*Buffer);
            p->tower = NewTower(PSEP->Tower);
            if (p->tower == 0)
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            if (fPatchTower)
                PatchTower(p->tower, PatchTowerAddress);
            memcpy( *Buffer, (char *)&Node->ObjUuid, sizeof(UUID) );
            strcpy(p->annotation, Node->Annotation);
            *Buffer += sizeof(ept_entry_t);
            break;

        default:
            ASSERT(!"Unknown type");
            break;
        }

    return(RPC_S_OK);
}




void
ept_cleanup_handle_t_rundown(
    ept_cleanup_handle_t hEpCleanup
    )
/*++

Routine Description:

    This routine cleans up the entries registered by the process
    associated with this context handle hEpCleanup.

Arguments:

    hEpCleanup - The context handle for which the rundown is
        being done.

Return Value:

    None.

--*/
{
    PIFOBJNode NodesListToDelete = NULL;
    PIFOBJNode pIterator, DeleteMe, pPreviousNode;
    PPSEPNode pTempPSEP, pDeletePSEP;
    PEP_CLEANUP ProcessCtxt = (PEP_CLEANUP) hEpCleanup;
#ifdef DBG_DETAIL
    PIFOBJNode pTemp, pLast;
#endif // DBG_DETAIL

    if (ProcessCtxt == NULL)
        {
        return;
        }

    EnterSem();

    ASSERT(IFObjList);
    ASSERT(cTotalEpEntries > 0);
    ASSERT(ProcessCtxt->EntryList);
    ASSERT(ProcessCtxt->cEntries > 0);
    ASSERT(ProcessCtxt->EntryList->OwnerOfList == ProcessCtxt);
    ASSERT_PROCESS_CONTEXT_LIST_COUNT(ProcessCtxt, ProcessCtxt->cEntries);

#ifdef DBG_DETAIL
    DbgPrint("RPCSS: Entered Cleanup Rundown for [%p] with (%d) entries\n",
             hEpCleanup, ProcessCtxt->cEntries);
    DbgPrint("RPCSS: Dump of IFOBJList\n");
    pTemp = IFObjList;
    pLast = IFObjList;
    while (pTemp)
        {
        DbgPrint("RPCSS: \t\t[%p]\n", pTemp);
        pLast = pTemp;
        pTemp = pTemp->Next;
        }
    DbgPrint("RPCSS: --------------------\n");
    while (pLast)
        {
        DbgPrint("RPCSS: \t\t\t[%p]\n", pLast);
        pLast = pLast->Prev;
        }
#endif // DBG_DETAIL

    // Save the previous Node.
    pPreviousNode = ProcessCtxt->EntryList->Prev;

    pIterator = ProcessCtxt->EntryList;
    while ((pIterator != NULL) && (pIterator->OwnerOfList == ProcessCtxt))
        {
        ProcessCtxt->cEntries--;
        cTotalEpEntries--;
#ifdef DBG_DETAIL
        DbgPrint("RPCSS: cTotalEpEntries-- [%p] (%d) - Cleanup\n", hEpCleanup, cTotalEpEntries);
#endif // DBG_DETAIL

        DeleteMe = pIterator;
        pIterator = pIterator->Next;

        // Add to a list that will be deleted later.
        DeleteMe->Next = NodesListToDelete;
        }

    ASSERT(ProcessCtxt->cEntries == 0);

    //
    // Adjust the links
    //
    if (pPreviousNode)
        {
        // Adjust forward link
        pPreviousNode->Next = pIterator;
        }
    else
        {
        ASSERT(ProcessCtxt->EntryList == IFObjList);
        }

    if (pIterator)
        {
        // Adjust backward link
        pIterator->Prev = pPreviousNode;
        }

    //
    // Empty the EP Mapper table, if necessary.
    //
    if (ProcessCtxt->EntryList == IFObjList)
        {
        if (pIterator)
            {
            ASSERT(cTotalEpEntries > 0);

            // New Head for Ep Mapper list
            IFObjList = pIterator;
            }
        else
            {
            ASSERT(cTotalEpEntries == 0);

            // Memory for this node is already freed in the while loop above.
            IFObjList = NULL;
            }
        }
    else
        {
        ASSERT(cTotalEpEntries > 0);
        }

    LeaveSem();

    //
    // Free entities outside the lock.
    //
    FreeMem(ProcessCtxt);

    while (NodesListToDelete != NULL)
        {
        DeleteMe = NodesListToDelete;
        NodesListToDelete = NodesListToDelete->Next;
        // Delete the PSEP list.
        pTempPSEP = DeleteMe->PSEPlist;
        while (pTempPSEP != NULL)
            {
            pDeletePSEP = pTempPSEP;
            pTempPSEP = pTempPSEP->Next;
            FreeMem(pDeletePSEP);
            }
        FreeMem(DeleteMe);
        }
}




void
ept_insert(
    handle_t h,
    unsigned32 NumEntries,
    ept_entry_t Entries[],
    unsigned long Replace,
    error_status  *Status
    )
/*++

Routine Description:

    This function is no longer supported by EpMapper. RPC Runtime does not
    call this function anymore. And, no one else should be...

--*/
{
    ASSERT(Status);

    *Status = EPT_S_CANT_PERFORM_OP;
}




void
ept_insert_ex(
    IN handle_t h,
    IN OUT ept_cleanup_handle_t *hEpCleanup,
    IN unsigned32 NumEntries,
    IN ept_entry_t Entries[],
    IN unsigned long Replace,
    OUT error_status  *Status
    )
/*++

Routine Description:

    This is the exposed rpc interface routine that adds a series of
    endpoints to the Endpoint Mapper database.

Arguments:

    h - An explicit binding handle to the EP.

    hEpCleanup - A context handle used to purge the Endpoint Mapper
        database of stale entries.

    NumEntries - Number of Entries to be added.

    Entries  - An array of ept_entry_t entries.

    Replace -  TRUE => Replace existing entries.
               FALSE=> Just add.

Return Value:

    RPC_S_OK - The endpoint was successfully deleted.

    RPC_S_OUT_OF_MEMORY - There is no memory to perform the op.

    EPT_S_CANT_PERFORM - Invalid entry.

--*/
{
    ept_entry_t * Ep;
    unsigned short i, j;
    unsigned int TransType = 0x0;
    unsigned long err = 0;
    unsigned long Version;
    unsigned char protseqid;
    char *Protseq, *Endpoint;
    RPC_IF_ID IfId;
    PPSEPNode List = 0;
    PPSEPNode pPSEPNode, TmpPsep, pTempPSEP, pDeletePSEP;
    unsigned long cb;
    twr_t * Tower;
    BOOL bIFNodeFound = FALSE;
    PIFOBJNode NodesListToDelete = NULL;
    PIFOBJNode Node, NewNode, DeleteMe = NULL;
    UUID * Object;
    char * Annotation;
    RPC_STATUS Err;
    SECURITY_DESCRIPTOR SecurityDescriptor, * PSecurityDesc;
    BOOL Bool;

    //
    // First, make sure the call is via LRPC.
    //
    err = I_RpcBindingInqTransportType(h, &TransType);
    ASSERT(err == RPC_S_OK);

    if (TransType != TRANSPORT_TYPE_LPC)
        {
        *Status = RPC_S_ACCESS_DENIED;
        return;
        }


    //
    // Create a temporary PSEP list from the Tower entries.
    //
    for (Ep = &Entries[0], i = 0; i < NumEntries; Ep++,i++)
        {
        err = TowerExplode(
                  Ep->tower,
                  &IfId,
                  NULL,
                  &Protseq,
                  &Endpoint,
                  0
                  );

        if (err == RPC_S_OUT_OF_MEMORY)
            break;

        if (err)
            {
            err = RPC_S_OK;
            continue;
            }

        Object = &Ep->object;
        Annotation = (char *)&Ep->annotation;
        Tower = Ep->tower;

        cb = sizeof(PSEPNode) +
             strlen(Protseq)  +
             strlen(Endpoint) +
             2 +                // for the 2 null terminators
             Tower->tower_length +
             sizeof(Tower->tower_length) +
             4;                 // We need to align tower on DWORD

        if ( (pPSEPNode = AllocMem(cb)) == NULL )
            {
            err = RPC_S_OUT_OF_MEMORY;
            break;
            }

        // Mark this protseq to start listening if needed.
        protseqid = (unsigned char) GetProtseqIdAnsi(Protseq);
        DelayedUseProtseq(protseqid);

        //
        // Add a node to the temporary PSEP list
        //
        memset(pPSEPNode, 0, cb);

        pPSEPNode->Signature            = PSEPSIGN;
        pPSEPNode->Cb                   = cb;

        //strcpy(pPSEPNode->Protseq= ((char *) (pPSEPNode+1)), Protseq);
        // Protseq
        pPSEPNode->Protseq = (char *) (pPSEPNode + 1); // What is the +1 for?
        strcpy(pPSEPNode->Protseq, Protseq);

        // Endpoint
        pPSEPNode->EP = pPSEPNode->Protseq + strlen(pPSEPNode->Protseq) + 1;
        strcpy(pPSEPNode->EP, Endpoint);

        // Tower. We add necessary pad so that Tower is aligned to a DWORD.
        pPSEPNode->Tower = (twr_t PAPI *)(pPSEPNode->EP +
                                          strlen(pPSEPNode->EP) + 1);
        (char PAPI*)(pPSEPNode->Tower) += 4 - ((ULONG_PTR)
                                               (pPSEPNode->Tower) & 3);
        memcpy((char PAPI *)pPSEPNode->Tower,
               Tower,
               Tower->tower_length + sizeof(Tower->tower_length)
               );

        // Finally, add.
        EnterSem();
        EnLinkOnPSEPList(&List, pPSEPNode);
        LeaveSem();

        I_RpcFree(Protseq);
        I_RpcFree(Endpoint);
        }

    if ((err == RPC_S_OUT_OF_MEMORY) || (List == 0))
        {
        *Status = err;
        return;
        }


    CompleteDelayedUseProtseqs();


    Version = VERSION(IfId.VersMajor, IfId.VersMinor);

    //
    // Find if a compatible Endpoint Mapper entry is already present.
    //

    if (*hEpCleanup != NULL)
        {
        //
        // The requesting process has previously registered entries
        // with the Endpoint Mapper.
        //

        ASSERT_PROCESS_CONTEXT_LIST_COUNT((PEP_CLEANUP)*hEpCleanup, ((PEP_CLEANUP)*hEpCleanup)->cEntries);
        ASSERT(((PEP_CLEANUP)*hEpCleanup)->MagicVal == CLEANUP_MAGIC_VALUE);
        ASSERT(((PEP_CLEANUP)*hEpCleanup)->cEntries != 0);

        if (   (((PEP_CLEANUP)*hEpCleanup)->MagicVal != CLEANUP_MAGIC_VALUE)
            || (((PEP_CLEANUP)*hEpCleanup)->cEntries == 0))
            {
            *Status = EPT_S_CANT_PERFORM_OP;
            return;
            }

        EnterSem();

        if (Replace == TRUE)    // Common case
            {
            //
            // If we find a compatible entry, we just replace its PSEP list
            // with the temporary list that we just created.
            //
            Node = ((PEP_CLEANUP)*hEpCleanup)->EntryList;

            while (Node != 0)
                {
                Node = FindIFOBJNode(
                            Node,
                            Object,
                            &IfId.Uuid,
                            Version,
                            RPC_C_EP_MATCH_BY_BOTH,
                            I_RPC_C_VERS_UPTO_AND_COMPATIBLE,
                            SearchIFObjNode
                            );

                if ((Node == 0) || (Node->OwnerOfList != *hEpCleanup))
                    break;

                // Matching Endpoint Mapper entry found.

                PurgeOldEntries(Node, List, FALSE);

                if (Node->IFVersion == Version)
                    {
                    bIFNodeFound = TRUE;

                    // Seek to the end of Tmp and then Link
                    TmpPsep = List;
                    while (TmpPsep->Next != 0)
                        TmpPsep = TmpPsep->Next;

                    TmpPsep->Next = Node->PSEPlist;
                    Node->PSEPlist  = List;
                    }

                if (Node->PSEPlist == 0)
                    {
                    DeleteMe = Node;
                    Node = Node->Next;
                    err = UnLinkFromIFOBJList((PEP_CLEANUP)*hEpCleanup, DeleteMe);
                    ASSERT(err == RPC_S_OK);

                    // Add to a list that will be deleted later...
                    DeleteMe->Next = NodesListToDelete;
                    NodesListToDelete = DeleteMe;

                    DeleteMe->Signature = FREE;
                    }
                else
                    {
                    Node = Node->Next;
                    }
                } // while loop
            }
        else    // (Replace != TRUE)
            {
            //
            // If we find an entry with an exact match, we append
            // the temporary PSEP list to the entry's PSEP list.
            //
            Node = ((PEP_CLEANUP)*hEpCleanup)->EntryList;

            NewNode = FindIFOBJNode(
                          Node,
                          Object,
                          &IfId.Uuid,
                          Version,
                          0,
                          0,
                          ExactMatch
                          );

            if (NewNode && (NewNode->OwnerOfList == *hEpCleanup))
                {
                bIFNodeFound = TRUE;

                PurgeOldEntries(NewNode, List, TRUE);

                // Seek to the end of Tmp and then Link
                TmpPsep = List;
                while (TmpPsep->Next != 0)
                    TmpPsep = TmpPsep->Next;

                TmpPsep->Next = NewNode->PSEPlist;
                NewNode->PSEPlist = List;
                }
            } // if (Replace == TRUE)

        LeaveSem();

        } // if (*hpCleanup != NULL)


    //
    // Free the list outside the lock.
    //
    while (NodesListToDelete != NULL)
        {
        DeleteMe = NodesListToDelete;
        NodesListToDelete = NodesListToDelete->Next;
        // Delete the PSEP list.
        pTempPSEP = DeleteMe->PSEPlist;
        while (pTempPSEP != NULL)
            {
            pDeletePSEP = pTempPSEP;
            pTempPSEP = pTempPSEP->Next;
            FreeMem(pDeletePSEP);
            }
        FreeMem(DeleteMe);
        }

    if (bIFNodeFound == FALSE)
        {
        //
        // One of the following is TRUE:
        // a. The process is registering with EP Mapper for the first time.
        // b. No compatible Ep entry was found.
        //

        //
        // Allocate a new EP Mapper entry.
        //
        cb = sizeof(IFOBJNode);
        cb += strlen(Annotation) + 1;
        if ((NewNode = AllocMem(cb)) == NULL)
            {
            *Status =  RPC_S_OUT_OF_MEMORY;
            return;
            }

        //
        // Fill-in the new entry
        //
        memset(NewNode, 0, cb);

        NewNode->Cb         = cb;
        NewNode->Signature  = IFOBJSIGN;
        NewNode->IFVersion  = Version;

        memcpy((char *)&NewNode->ObjUuid, (char *)Object, sizeof(UUID));
        memcpy((char *)&NewNode->IFUuid, (char *)&IfId.Uuid, sizeof(UUID));
        strcpy((NewNode->Annotation=(char *)(NewNode+1)), Annotation);

        if (IsNullUuid(Object))
            NewNode->IFOBJid = MAKEGLOBALIFOBJID(MAXIFOBJID);
        else
            NewNode->IFOBJid = MAKEGLOBALIFOBJID(GlobalIFOBJid--);

        //
        // Create a new context for this process, if necessary
        //
        if (*hEpCleanup == NULL)
            {
            *hEpCleanup = AllocMem(sizeof(EP_CLEANUP));
            if (*hEpCleanup == NULL)
                {
                LeaveSem();
                FreeMem(NewNode);
                *Status = RPC_S_OUT_OF_MEMORY;
                return;
                }

            memset(*hEpCleanup, 0x0, sizeof(EP_CLEANUP));

            ((PEP_CLEANUP)*hEpCleanup)->MagicVal = CLEANUP_MAGIC_VALUE;
            }

        //
        // Insert the new entry into the EP Mapper table.
        //
        EnterSem();

        err = EnLinkOnIFOBJList((PEP_CLEANUP)*hEpCleanup, NewNode);
        ASSERT(err == RPC_S_OK);

        NewNode->PSEPlist = List;

        LeaveSem();
        }

    *Status = err;
}




void
ept_delete(
    handle_t h,
    unsigned32 NumEntries,
    ept_entry_t Entries[],
    error_status *Status
    )
/*++

Routine Description:

    This function is no longer supported by EpMapper. RPC Runtime does not
    call this function anymore. And, no one else should be...

--*/
{
    ASSERT(Status);

    *Status = EPT_S_CANT_PERFORM_OP;
}




RPC_STATUS
ept_delete_ex_helper(
    IN ept_cleanup_handle_t hEpCleanup,
    IN UUID *Object,
    IN UUID *Interface,
    IN unsigned long  IFVersion,
    IN char PAPI * Protseq,
    IN char PAPI * Endpoint
    )
/*++

Routine Description:

    This routine deletes an Endpoint registered with the EP Mapper

Arguments:

    hEpCleanup - A context handle used to purge the Endpoint Mapper
        database of stale entries.

    Object - Object Uuid.

    Interface - If Uuid

    IFVersion - Version of the IF [Hi ushort=Major, Lo ushort=Minor]

    Protseq - Protocol Sequence

    Endpoint - Endpoint string

Notes:

    a. This routine has to be called by holding a mutex.

Return Value:

    RPC_S_OK - The endpoint was successfully deleted

    EPT_S_NOT_REGISTERED - No matching entries were found

--*/
{
    PIFOBJNode  pNode;
    PPSEPNode   pPSEPNode = NULL;
    unsigned long cb, err = 0;
    PEP_T p;
    PEP_CLEANUP ProcessCtx;

    if (!Protseq || !Endpoint)
        {
        return(EPT_S_NOT_REGISTERED);
        }

    CheckInSem();

    ProcessCtx = (PEP_CLEANUP)hEpCleanup;

    if (ProcessCtx->EntryList == NULL)
        return EPT_S_NOT_REGISTERED;

    pNode = FindIFOBJNode(
                ProcessCtx->EntryList,
                Object,
                Interface,
                IFVersion,
                0L,
                0L,
                ExactMatch
                );

    if ((pNode != NULL) && (pNode->PSEPlist != NULL))
        {
        pPSEPNode = FindPSEP(
                        pNode->PSEPlist,
                        Protseq,
                        Endpoint,
                        0L,
                        MatchPSAndEP
                        );
        }

    if (pPSEPNode != NULL)
        {
        UnLinkFromPSEPList(&pNode->PSEPlist, pPSEPNode);

        if (pNode->PSEPlist == NULL)
            {
            err = UnLinkFromIFOBJList((PEP_CLEANUP)hEpCleanup, pNode);
//            ASSERT(err == RPC_S_OK);

            if (err != RPC_S_OK)
                {
                // Restore the PSEPList
                EnLinkOnPSEPList(&pNode->PSEPlist, pPSEPNode);
                return err;
                }

            pNode->Signature = FREE;
            FreeMem(pNode);
            }

        pPSEPNode->Signature = FREE;
        FreeMem(pPSEPNode);
        }
    else
        {
        err = EPT_S_NOT_REGISTERED;
        }

    return(err);
}




void
ept_delete_ex(
    IN handle_t h,
    IN OUT ept_cleanup_handle_t *hEpCleanup,
    IN unsigned32 NumEntries,
    IN ept_entry_t Entries[],
    OUT error_status *Status
    )
/*++

Routine Description:

    This routine deletes the specified Endpoints

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    NumEntries - #of entries in the Bunffer that need to be deleted.

    Entries[] - Buffer of #NumEntries of ept_entry_t structures

Return Value:

    RPC_S_OK - The endpoint was successfully deleted

    EPT_S_NOT_REGISTERED - No matching entries were found

--*/
{
    ept_entry_t * Ep;
    unsigned short i;
    unsigned int TransType = 0x0;
    RPC_STATUS err;
    RPC_STATUS DeleteStatus;
    unsigned long Version;
    char *Protseq, *Endpoint;
    RPC_IF_ID IfId;
    RPC_TRANSFER_SYNTAX XferId;

    //
    // First, make sure the call is via LRPC.
    //
    err = I_RpcBindingInqTransportType(h, &TransType);
    ASSERT(err == RPC_S_OK);

    if (TransType != TRANSPORT_TYPE_LPC)
        {
        *Status = RPC_S_ACCESS_DENIED;
        return;
        }

    if ( !(  (*hEpCleanup)
          && (((PEP_CLEANUP)*hEpCleanup)->MagicVal == CLEANUP_MAGIC_VALUE)
          && (((PEP_CLEANUP)*hEpCleanup)->cEntries != 0)
          )
       )
        {
        //
        // Cannot ASSERT here. This is possible. (ep1-26, ep2-3)
        //

        //ASSERT(*hEpCleanup);
        //ASSERT(((PEP_CLEANUP)*hEpCleanup)->MagicVal == CLEANUP_MAGIC_VALUE);
        //ASSERT(((PEP_CLEANUP)*hEpCleanup)->cEntries != 0);

        *Status = EPT_S_CANT_PERFORM_OP;
        return;
        }

    *Status = EPT_S_NOT_REGISTERED;
    DeleteStatus = RPC_S_OK;

    for (Ep = &Entries[0], i = 0; i < NumEntries; Ep++,i++)
        {
        err = TowerExplode(
                  Ep->tower,
                  &IfId,
                  &XferId,
                  &Protseq,
                  &Endpoint,
                  0
                  );

        if (err == RPC_S_OUT_OF_MEMORY)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            break;
            }

        if (err)
            {
            continue;
            }

        Version = VERSION(IfId.VersMajor, IfId.VersMinor);

        EnterSem();

        //
        // NOTE:
        //
        // If even one call to ept_delete_ex_helper() fails, we want to return
        // failure from ept_delete_ex(). This is different from the past where
        // if one call succeeded, then the function returned success.
        //
        err = ept_delete_ex_helper(
                   *hEpCleanup,
                   &Ep->object,
                   &IfId.Uuid,
                   Version,
                   Protseq,
                   Endpoint
                   );

        if (err)
            {
            // Save the last failure status.
            DeleteStatus = err;
            }

        if (((PEP_CLEANUP)*hEpCleanup)->cEntries == 0)
            {
            //
            // No entry left in this process's list. Time to zero out this
            // process's context handle.
            //
            //ASSERT(((PEP_CLEANUP)*hEpCleanup)->EntryList == NULL);

            FreeMem(*hEpCleanup);
            *hEpCleanup = NULL;
            }

        LeaveSem();

        if (Protseq)
            I_RpcFree(Protseq);

        if (Endpoint)
            I_RpcFree(Endpoint);
        }

    if (err)
        {
        // RPC_S_OUT_OF_MEMORY OR the last call to
        // ept_delete_ex_helper() failed.
        *Status = err;
        }
    else
        {
        // RPC_S_OK OR one of the calls to ept_delete_ex_helper() (but
        // not the last one) failed.
        *Status = DeleteStatus;
        }
}




void
ept_lookup(
    handle_t hEpMapper,
    unsigned32 InquiryType,
    UUID   * Object,
    RPC_IF_ID * Ifid,
    unsigned32 VersOptions,
    ept_lookup_handle_t *LookupHandle,
    unsigned32 MaxRequested,
    unsigned32 *NumEntries,
    ept_entry_t Entries[],
    error_status *Status
    )
/*++

Routine Description:

    This routine returns upto MaxRequested, ept_entry(s) currently
    registered with the Endpoint mapper based on the
    Obj, Interface, Protocol sequence  and filters VersOptions and
    InqType

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    InquiryType - Search Filter [Seach based on IF, Obj or Both]

    Obj - Object Uuid. specified by the client

    ObjInterface - Interface Uuid spec. by the client.

    InId - The If Specification [IF Uuid+IfVersion]

    VersOpts- Search Filter based on Versions [Versins <, >, ==]

    MapHandle - A resume key - If NULL, search is started from the beginning
        if non-null, represents an encoding from where the epmapper is
        is supposed to start searching. It is an opaque value as far as the
        as far as the client is concerned.

    MaxRequested - Max number of entries requested by the client.

    Returned - The actual number of entries returned by the mapper.

    Entries  - Buffer of ept_entries returned.

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK - At least one matching entry is being returned.

    EP_S_NOT_REGISTERED - No matching entries were found

    EPT_S_CANT_PERFORM_OP - MaxRequested value exceed  ep_max_lookup_results

--*/

{
    unsigned long Version;

    if (Ifid == NULL)
        {
        Ifid = &LocalNullUuid;
        }

    if (Object == NULL)
        {
        Object = (UUID *) &LocalNullUuid;
        }

    switch (VersOptions)
        {
        case RPC_C_VERS_ALL:
                Version = 0;
                break;

        case RPC_C_VERS_COMPATIBLE:
        case RPC_C_VERS_EXACT:
        case RPC_C_VERS_UPTO:
                Version  = VERSION(Ifid->VersMajor, Ifid->VersMinor);
                break;

        case RPC_C_VERS_MAJOR_ONLY:
                Version = VERSION(Ifid->VersMajor, 0);
                break;

        default:
                break;
        }

    *Status = GetEntries(
                  Object,
                  &Ifid->Uuid,
                  Version,
                  NULL,
                  LookupHandle,
                  (char *)Entries,
                  EP_LOOKUP,
                  MaxRequested,
                  NumEntries,
                  InquiryType,
                  VersOptions,
                  SearchIFObjNode
                  );
}




void
ept_map(
    handle_t h,
    UUID *Obj OPTIONAL,
    twr_p_t MapTower,
    ept_lookup_handle_t *MapHandle,
    unsigned32 MaxTowers,
    unsigned32 *NumTowers,
    twr_p_t *ITowers,
    error_status *Status
    )
/*++

Routine Description:

    This routine returns a fully-resolved string binding, for a given
    Obj, Interface, and Protocol sequence if an appropriate entry is
    found. Else returns EP_S_NOT_REGISTERED.

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    Obj - Object Uuid. specified by the client

    ObjInterface - Interface Uuid spec. by the client.

    Interfacever - InterfaceVersion [hi ushort = VerMajor, lo ushort VerMinor]

    Protseq - An ascii string specifying the protocol seq.

    MapHandle - A resume key - If NULL, search is started from the beginning
        if non-null, represents an encoding from where the epmapper is
        supposed to start searching. It is an opaque value as far as the
        client is concerned.

    Binding - The fully resolved string binding returned if the call is
        successful.

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK

    EP_S_NOT_REGISTERED

--*/
{
    RPC_IF_ID Ifid;
    RPC_TRANSFER_SYNTAX Xferid;
    char *Protseq;
    unsigned long Version;
    char * String = 0;

    if (Obj == 0)
        {
        Obj = (UUID *) &LocalNullUuid;
        }

    *Status = TowerExplode(
                  MapTower,
                  &Ifid,
                  &Xferid,
                  &Protseq,
                  NULL,
                  0
                  );

    if (*Status)
		{
		*NumTowers = 0;
        return;
		}

    Version = VERSION(Ifid.VersMajor,Ifid.VersMinor);

    if (memcmp((char *)&Ifid.Uuid, (char *)&MgmtIf, sizeof(UUID)) == 0)
        {
        if ((Obj == 0) || IsNullUuid(Obj))
            {
            *NumTowers = 0;
            *Status = RPC_S_BINDING_INCOMPLETE;
            }
        else
            {
            *Status = GetEntries(
                          Obj,
                          &Ifid.Uuid,
                          Version,
                          Protseq,
                          MapHandle,
                          (char *)ITowers,
                          EP_MAP,
                          MaxTowers,
                          NumTowers,
                          RPC_C_EP_MATCH_BY_OBJ,
                          RPC_C_VERS_ALL,
                          SearchIFObjNode
                          );
            }
        }
    else
        {
        *Status = GetEntries(
                      Obj,
                      &Ifid.Uuid,
                      Version,
                      Protseq,
                      MapHandle,
                      (char *)ITowers,
                      EP_MAP,
                      MaxTowers,
                      NumTowers,
                      0L,
                      0L,
                      WildCardMatch
                      );
        }

    if (Protseq)
        I_RpcFree(Protseq);
}




void
ept_inq_object(
    handle_t BindingHandle,
    UUID *Object,
    error_status *status
    )
/*++

Routine Description:

    Not supported

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    Object _ No idea whose UUID this is.

Return Value:

    EPT_S_CANT_PERFORM_OP

--*/
{
    ASSERT(*status);

    *status = EPT_S_CANT_PERFORM_OP;
}



void
DeletePSEP(
     PIFOBJNode Node,
     char * Protseq,
     char * Endpoint
     )
{

    PSEPNode *Psep, *Tmp;

    if (Node == 0)
        return;

    Psep = Node->PSEPlist;

    while (Psep  != 0)
        {
        Psep = FindPSEP(
                   Psep,
                   Protseq,
                   Endpoint,
                   0L,
                   MatchPSAndEP
                   );

        if (Psep != 0)
            {
            Tmp = Psep;
            Psep = Psep->Next;
            UnLinkFromPSEPList(&Node->PSEPlist, Tmp);
            Tmp->Signature = FREE;
            FreeMem(Tmp);
            }
        }
}




void
ept_mgmt_delete(
    handle_t BindingHandle,
    boolean32 ObjectSpecd,
    UUID * Object,
    twr_p_t Tower,
    error_status *Error
    )
/*++

Routine Description:

    Not supported

Arguments:

    BindingHandle - An explicit binding handle to the EP.

    Object _ ObjUUid

    Tower - Tower specifying the Endpoints to be deleted.

Return Value:

    EPT_S_CANT_PERFORM_OP

--*/
{
    ASSERT(*Error);

    *Error = EP_S_CANT_PERFORM_OP;
}




void ept_lookup_handle_t_rundown (ept_lookup_handle_t h)
{

    PSAVEDCONTEXT Context = (PSAVEDCONTEXT) h;
    PIENTRY       Entry;
    unsigned long Type;
    PIENTRY       Tmp;
    twr_t         * Tower;


    ASSERT (Context != 0);

    if ( (PtrToUlong(Context)) == 0xFFFFFFFF)
        return;

    Type = Context->Type;

    EnterSem();

    Entry = (PIENTRY)Context->List;

    while (Entry != 0)
        {
        switch (Type)
            {
            case EP_MAP:
                Tower =  ((PSAVEDTOWER)Entry)->Tower;
                break;

            case EP_LOOKUP:
                Tower = ((PSAVED_EPT)Entry)->Tower;
                break;

            default:
                ASSERT(!"Unknown Inquiry Type");
                break;
            }

        MIDL_user_free(Tower);
        Tmp = Entry;
        Entry = Entry->Next;
        FreeMem(Tmp);
        }

    // Now free The Context
    UnLink((PIENTRY *)&GlobalContextList, (PIENTRY)Context);

    LeaveSem();

    FreeMem(Context);
}




void
ept_lookup_handle_free(
    handle_t h,
    ept_lookup_handle_t * ept_context_handle,
    error_status * status
    )
{
    if ( (ept_context_handle != 0) && (*ept_context_handle != 0))
        {
        ept_lookup_handle_t_rundown( *ept_context_handle );
        *ept_context_handle = 0;
        }

    *status = 0;
}



#define MAX(x,y) ((x) < (y)) ? (y) : (x)
#define MIN(x,y) ((x) > (y)) ? (y) : (x)

#ifdef DEBUGRPC
#define DEBUG_MIN(x,y) MIN((x),(y))
#else
#define DEBUG_MIN(x,y) MAX((x),(y))
#endif




error_status_t
OpenEndpointMapper(
    IN handle_t hServer,
    OUT HPROCESS *pProcessHandle
    )
{
    PROCESS *pProcess = MIDL_user_allocate(sizeof(PROCESS));

    if (!pProcess)
        {
        *pProcessHandle = 0;
        return(RPC_S_OUT_OF_MEMORY);
        }

    pProcess->MagicVal = PROCESS_MAGIC_VALUE;
    pProcess->pPorts = 0;
    *pProcessHandle = (PVOID)pProcess;

    return(RPC_S_OK);
}



//
// Port Management stuff
//



//
// Port Management Globals
//

const RPC_CHAR *PortConfigKey = RPC_CONST_STRING("Software\\Microsoft\\Rpc\\Internet");
const RPC_CHAR *DefaultPortType = RPC_CONST_STRING("UseInternetPorts");
const RPC_CHAR *ExplictPortType = RPC_CONST_STRING("PortsInternetAvailable");
const RPC_CHAR *PortRanges = RPC_CONST_STRING("Ports");

CRITICAL_SECTION PortLock;

BOOL fValidConfiguration = FALSE;
BOOL fPortRestrictions = FALSE;
PORT_TYPE SystemDefaultPortType = 0;

IP_PORT *pFreeInternetPorts = 0;
IP_PORT *pFreeIntranetPorts = 0;

PORT_RANGE *InternetPorts = 0;
PORT_RANGE *IntranetPorts = 0;



//
// Port management APIs
//


RPC_STATUS
InitializeIpPortManager(
    void
    )
{
    HKEY hkey;
    RPC_STATUS status;
    DWORD size, type, value;
    RPC_CHAR *pstr;
    PORT_RANGE *pSet;
    PORT_RANGE *pLast;
    PORT_RANGE *pCurrent;
    PORT_RANGE *pComplement;
    PORT_RANGE *pNew;

    LONG min, max;


    InitializeCriticalSectionAndSpinCount(&PortLock, PREALLOCATE_EVENT_MASK);

    status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           PortConfigKey,
                           0,
                           KEY_READ,
                           &hkey);

    if (status != RPC_S_OK)
        {
        if (status != ERROR_FILE_NOT_FOUND)
            {
#if DBG
            PrintToDebugger("RPCSS: Unable to open port config key: %d\n", status);
#endif
            }
        ASSERT(status == ERROR_FILE_NOT_FOUND);

        fValidConfiguration = TRUE;
        return(RPC_S_OK);
        }

    size = sizeof(value);
    status = RegQueryValueEx(hkey,
                              DefaultPortType,
                              0,
                              &type,
                              (PBYTE)&value,
                              &size);

    if (   status != RPC_S_OK
        || type != REG_SZ
        || (    *(RPC_CHAR *)&value != 'Y'
             && *(RPC_CHAR *)&value != 'y'
             && *(RPC_CHAR *)&value != 'N'
             && *(RPC_CHAR *)&value != 'n') )
        {
        RegCloseKey(hkey);
        ASSERT(fValidConfiguration == FALSE);
        return(RPC_S_OK);
        }

    if (   *(RPC_CHAR *)&value == 'Y'
        || *(RPC_CHAR *)&value == 'y')
        {
        SystemDefaultPortType = PORT_INTERNET;
        }
    else
        {
        SystemDefaultPortType = PORT_INTRANET;
        }

    size = sizeof(value);
    status = RegQueryValueEx(hkey,
                              ExplictPortType,
                              0,
                              &type,
                              (PBYTE)&value,
                              &size);

    if (   status != RPC_S_OK
        || type != REG_SZ
        || (    *(RPC_CHAR *)&value != 'Y'
             && *(RPC_CHAR *)&value != 'y'
             && *(RPC_CHAR *)&value != 'N'
             && *(RPC_CHAR *)&value != 'n') )
        {
        RegCloseKey(hkey);
        ASSERT(fValidConfiguration == FALSE);
        return(RPC_S_OK);
        }

    if (   *(RPC_CHAR *)&value == 'Y'
        || *(RPC_CHAR *)&value == 'y')
        {
        value = PORT_INTERNET;
        }
    else
        {
        value = PORT_INTRANET;
        }

    size = DEBUG_MIN(1, 100);

    do
        {
        ASSERT(size);
        pstr = alloca(size);
        ASSERT(pstr);

        status = RegQueryValueEx(hkey,
                                  PortRanges,
                                  0,
                                  &type,
                                  (PBYTE)pstr,
                                  &size);
        }
    while (status == ERROR_MORE_DATA);

    RegCloseKey(hkey);

    if (   status != RPC_S_OK
        || type != REG_MULTI_SZ)
        {
        ASSERT(fValidConfiguration == FALSE);
        return(RPC_S_OK);
        }

    //
    // The user is going to specify a range of ports in the registery
    // with a flag indicating if these ports are internet or intranet.
    //
    // ie, 500-550
    //     560
    //     559
    //     2000-2048
    //     2029-2049
    //
    // Note that order (in the REG_MULTI_SZ) and overlapping sets
    // are ok.  We must handle creating a port range list for this
    // array and for the complement BUT NOT INCLUDING <=1024 by default.
    //
    // completment set to above is:
    //
    //     1025-1999
    //     2050-32767
    //

    #define MIN_PORT 1025    // Only important for complement sets.
    #define MAX_PORT 65535

    pSet = 0;
    pLast = 0;

    while(*pstr)
        {
        RPC_CHAR *t;

#ifdef UNICODE
        min = wcstol(pstr, &t, 10);
#else
        min = strtol(pstr, &t, 10);
#endif

        if (min > MAX_PORT || min < 0)
            {
            status = RPC_S_INVALID_ARG;
            break;
            }

        if (   *t != 0
#ifdef UNICODE
            && *t != L'-')
#else
            && *t != '-')
#endif
            {
            status = RPC_S_INVALID_ARG;
            break;
            }

        if (*t == 0)
            {
            max = min;
            }
        else
            {
#ifdef UNICODE
            max = wcstol(t + 1, &t, 10);
#else
            min = strtol(t + 1, &t, 10);
#endif

            if (max > MAX_PORT || max < 0 || max < min)
                {
                status = RPC_S_INVALID_ARG;
                break;
                }
            }

        ASSERT(min <= max);

        // Ok, got some ports, allocate a structure for them..

        pNew = MIDL_user_allocate(sizeof(PORT_RANGE));
        if (0 == pNew)
            {
            status = RPC_S_OUT_OF_MEMORY;
            break;
            }

        pNew->pNext = 0;

        pNew->Min = (unsigned short) min;
        pNew->Max = (unsigned short) max;

        // We can to maintain the set of ranges in order.  As we insert
        // we'll fix any ranges which overlap.

        pCurrent = pSet;
        pLast = 0;

        for (;;)
            {
            if (0 == pSet)
                {
                pSet = pNew;
                break;
                }

            if (   pNew->Min <= (pCurrent->Max + 1)
                && pNew->Max >= (pCurrent->Min - 1) )
                {
                // The ranges overlap or touch.  We'll merge them now..

                pCurrent->Min = MIN(pNew->Min, pCurrent->Min);
                pCurrent->Max = MAX(pCurrent->Max, pNew->Max);

                MIDL_user_free(pNew);

                // Since the new larger range may overlap another existing
                // range we just insert the larger range as if it was new...
                pNew = pCurrent;

                // Take current out of the list.
                if (pLast)
                    {
                    pLast->pNext = pCurrent->pNext;
                    }

                if (pSet == pNew)
                    {
                    pSet = pSet->pNext;
                    }

                // Restart
                pCurrent = pSet;
                pLast = 0;
                continue;
                }

            if (pNew->Min < pCurrent->Min)
                {
                // Found the spot
                if (pLast)
                    {
                    pLast->pNext = pNew;
                    pNew->pNext = pCurrent;
                    }
                else
                    {
                    ASSERT(pCurrent == pSet);
                    pNew->pNext = pCurrent;
                    pSet = pNew;
                    }

                break;
                }

            // Continue the search
            pLast = pCurrent;
            pCurrent = pCurrent->pNext;

            if (0 == pCurrent)
                {
                // Reached the end of the list, insert it here.
                pLast->pNext = pNew;
                ASSERT(pNew->pNext == 0);
                break;
                }
            }

        ASSERT(pSet);

        // Advance to the next string of the final null.
        pstr = RpcpCharacter(pstr, 0) + 1;
        }

    if (pSet == 0)
        {
        status = RPC_S_INVALID_ARG;
        }

    if (value == PORT_INTERNET)
        {
        InternetPorts = pSet;
        }
    else
        {
        IntranetPorts = pSet;
        }

    if (status == RPC_S_OK)
        {
        // We've constructed the set of ports in the registry,
        // now we need to compute the complement set.

        pComplement = 0;
        pCurrent = 0;
        min = MIN_PORT;

        while(pSet)
            {
            if (min < pSet->Min)
                {
                max = pSet->Min - 1;
                ASSERT(max >= min);

                pNew = MIDL_user_allocate(sizeof(PORT_RANGE));
                if (0 == pNew)
                    {
                    status = RPC_S_OUT_OF_MEMORY;
                    break;
                    }

                pNew->pNext = 0;
                pNew->Min = (unsigned short) min;
                pNew->Max = (unsigned short) max;

                if (pComplement == 0)
                    {
                    pComplement = pCurrent = pNew;
                    }
                else
                    {
                    ASSERT(pCurrent);
                    pCurrent->pNext = pNew;
                    pCurrent = pNew;
                    }
                }

            min = MAX(MIN_PORT, pSet->Max + 1);

            pSet = pSet->pNext;
            }

        if (status == RPC_S_OK && min < MAX_PORT)
            {
            // Final port in orginal set less then max, allocate final
            // range for the set complement.
            pNew = MIDL_user_allocate(sizeof(PORT_RANGE));
            if (0 != pNew)
                {
                pNew->Min = (unsigned short) min;
                pNew->Max = MAX_PORT;
                pNew->pNext = 0;
                if (pCurrent)
                    {
                    pCurrent->pNext = pNew;
                    }
                else
                    {
                    ASSERT(min == MIN_PORT);
                    pComplement = pNew;
                    }
                }
            else
                {
                status = RPC_S_OUT_OF_MEMORY;
                }
            }

        // Even if we failed assign the pointer, it's either
        // null or needs to be freed.

        if (value == PORT_INTERNET)
            {
            ASSERT(IntranetPorts == 0);
            IntranetPorts = pComplement;
            }
        else
            {
            ASSERT(InternetPorts == 0);
            InternetPorts = pComplement;
            }
        }

    if (status != RPC_S_OK)
        {
        ASSERT(fValidConfiguration == FALSE);
        while(InternetPorts)
            {
            PORT_RANGE *pT = InternetPorts;
            InternetPorts = InternetPorts->pNext;
            MIDL_user_free(pT);
            }

        while(IntranetPorts)
            {
            PORT_RANGE *pT = IntranetPorts;
            IntranetPorts = IntranetPorts->pNext;
            MIDL_user_free(pT);
            }
        return(RPC_S_OK);
        }

    fValidConfiguration = TRUE;
    fPortRestrictions = TRUE;
    return(RPC_S_OK);
}




BOOL
AllocatePort(
    OUT IP_PORT **ppPort,
    IN OUT IP_PORT **ppPortFreeList,
    IN PORT_RANGE *pPortList
    )
/*++

Routine Description:

    Allocates a port object for a specific process.  It first tries
    to use any ports in the free list.  If there's nothing in the
    port this then it tries to find a free port in the PortList
    which is one of the sets computed during startup.

Arguments:

    ppPort - Will contain the allocated port object if successful.

    ppPortFreeList - Pointer to the head of the free list associated
        with this type of port.  Maybe modified during this call.

    pPortList - Port ranges associated with this type of port.

Return Value:

    TRUE - Port allocated
    FALSE - Port not allocated

--*/
{
    IP_PORT *pPort = 0;

    // First see if there is free port to reuse.

    if (*ppPortFreeList)
        {
        EnterCriticalSection(&PortLock);
        if (*ppPortFreeList)
            {
            pPort = *ppPortFreeList;
            *ppPortFreeList = pPort->pNext;
            pPort->pNext = 0;
            }
        LeaveCriticalSection(&PortLock);
        }

    if (pPort == 0)
        {
        // No port in the free list, try to allocate one
        // Assume we'll find a free port..

        pPort = MIDL_user_allocate(sizeof(IP_PORT));

        if (0 != pPort)
            {
            pPort->pNext = 0;

            EnterCriticalSection(&PortLock);

            while (   pPortList
                   && pPortList->Min > pPortList->Max)
                {
                pPortList = pPortList->pNext;
                }

            if (pPortList)
                {
                ASSERT(pPortList->Min <= pPortList->Max);

                pPort->Port = pPortList->Min;
                pPortList->Min++;

                // We could remove empty ranges from the list.
                }

            LeaveCriticalSection(&PortLock);

            if (0 == pPortList)
                {
                MIDL_user_free(pPort);
                pPort = 0;
                #ifdef DEBUGRPC
                DbgPrint("RPC: Out of reserved ports\n");
                #endif
                }
            }
        }

    // REVIEW: Post SUR we should look at adding events for
    // allocation and failure to allocate IP ports

    *ppPort = pPort;

    return(pPort != 0);
}




error_status_t
AllocateReservedIPPort(
    IN HPROCESS hProcess,
    IN PORT_TYPE PortType,
    OUT long *pAllocationStatus,
    OUT unsigned short *pAllocatedPort
    )
/*++

Routine Description:

    Remote manager for RPC runtime to call locally to allocate
    a local port.  The call and process parameters must be valid
    and called only locally.  Based on the PortType paramet a
    IP port maybe allocated for the calling process.  The
    allocationstatus contains the result of the port allocation
    step.

Arguments:

    hProcess - Valid process context handle allocated with
        a call to OpenEndpointMapper.
    PortType - One of
        PORT_INTERNET
        PORT_INTRANET
        PORT_DEFAULT
        Used to determine which port range to allocate from.
    pAllocationStatus -
        RPC_S_OK - successfully allocated a port.
        RPC_S_OUT_OF_RESOURES - no ports available.
    pAllocatePort - If allocation status is RPC_S_OK then
        this contains the value of the port allocated.
        If zero it means that there are no port restrictions
        and any port maybe used.

Return Value:

    RPC_S_OK
    RPC_S_INVALID_ARG - configuration error or PortType out of range.
    RPC_S_ACCESS_ DENIED - not called locally.

--*/
{
    PROCESS *pProcess = (PROCESS *)hProcess;
    IP_PORT *pPort;
    UINT type;
    BOOL b;

    *pAllocatedPort = 0;
    *pAllocationStatus = RPC_S_OK;

    ASSERT(pProcess);

    if (!fValidConfiguration)
        {
        return(RPC_S_INVALID_ARG);
        }

    if (   (I_RpcBindingInqTransportType(0, &type) != RPC_S_OK)
        || (type != TRANSPORT_TYPE_LPC)
        || (0 == pProcess)
        || (pProcess->MagicVal != PROCESS_MAGIC_VALUE ) )
        {
        return(RPC_S_ACCESS_DENIED);
        }

    if (PortType > PORT_DEFAULT || PortType < PORT_INTERNET)
        {
        return(RPC_S_INVALID_ARG);
        }

    if (fPortRestrictions == FALSE)
        {
        // No port restrictions on this machine, just use zero.
        // This is the common case.
        ASSERT(*pAllocatedPort == 0);
        ASSERT(*pAllocationStatus == 0);
        return(RPC_S_OK);
        }

    // Need to actually allocate a unique port for this process.

    if (PortType == PORT_DEFAULT)
        {
        // Allocate using default policy
        PortType = SystemDefaultPortType;
        }

    ASSERT(PortType == PORT_INTERNET || PortType == PORT_INTRANET);


    pPort = 0;

    if (PortType == PORT_INTERNET)
        {
        b = AllocatePort(&pPort,
                         &pFreeInternetPorts,
                         InternetPorts
                         );
        }
    else
        {
        b = AllocatePort(&pPort,
                         &pFreeIntranetPorts,
                         IntranetPorts);
        }

    if (!b)
        {
        ASSERT(pPort == 0);
        // REVIEW: Do we want a unique error code if no ports
        // are available?
        *pAllocationStatus = RPC_S_OUT_OF_RESOURCES;
        return(RPC_S_OK);
        }

    ASSERT(pPort);
    ASSERT(pPort->pNext == 0);

    pPort->Type = (unsigned short) PortType;

    pPort->pNext = pProcess->pPorts;
    pProcess->pPorts = pPort;

    *pAllocatedPort = pPort->Port;

    ASSERT(*pAllocationStatus == RPC_S_OK);

    return(RPC_S_OK);
}




void
HPROCESS_rundown(
    HPROCESS hProcess
    )
{
    PROCESS *pProcess = (PROCESS *)hProcess;
    IP_PORT *pCurrent;
    IP_PORT *pSave;

    ASSERT(pProcess);
    ASSERT(pProcess->MagicVal == PROCESS_MAGIC_VALUE);

    pCurrent = pProcess->pPorts;
    if (pCurrent)
        {
        EnterCriticalSection(&PortLock);

        do
            {
            pSave = pCurrent->pNext;

            if (pCurrent->Type == PORT_INTERNET)
                {
                pCurrent->pNext = pFreeInternetPorts;
                pFreeInternetPorts = pCurrent;
                }
            else
                {
                ASSERT(pCurrent->Type == PORT_INTRANET);
                pCurrent->pNext = pFreeIntranetPorts;
                pFreeIntranetPorts = pCurrent;
                }

            pCurrent = pSave;
            }
        while(pCurrent);

        LeaveCriticalSection(&PortLock);
        }

    MIDL_user_free(pProcess);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\exts\nttrans.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 2001

    Module Name:

        NtTrans.cxx

    Abstract:

        NTSD/KD extensions for debugging Windows NT transport interface
        data structures.

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     3/21/1997    Bits 'n pieces

        GrigoriK    Mar 2001     Added support for type info.

--*/

#undef _RPCRT4_

#define KDEXT_64BIT

#define private     public

#include "..\trans\Common\precomp.hxx"
#include "..\mtrt\precomp.hxx"
#include <stddef.h>
#include <wdbgexts.h>
#include <rpcexts.hxx>

VOID do_trans(ULONG64);
VOID do_protocols(ULONG64);
VOID do_overlap(ULONG64);
VOID do_addrvect(ULONG64);

MY_DECLARE_API(trans);
MY_DECLARE_API(overlap);
MY_DECLARE_API(addrvect);

const char *Protocols[] =
{
    "INVALID",
    "TCP/IP",
#ifdef SPX_ON
    "SPX",
#else
    "Invalid",
#endif
    "Named pipes",
#ifdef NETBIOS_ON
    "NetBEUI",
    "Netbios(TCP)",
    "Netbios(IPX)",
#else
    "Invalid",
    "Invalid",
    "Invalid",
#endif
#ifdef APPLETALK_ON
    "Appletalk DSP",
#else
    "Invalid",
#endif
    "Invalid",      // former "Vines SPP",
    "HTTP",
    "UDP/IP",
#ifdef IPX_ON
    "IPX",
#else
    "Invalid",
#endif
    "CDP",
#ifdef NCADG_MQ_ON
    "MSMQ",
#else
    "Invalid",
#endif
    "TCP/IPv6"
};
const INT cProtocols = sizeof(Protocols)/sizeof(char *);


VOID
do_trans(
    ULONG64 qwAddr
    )
{
    char const *pszProtocol;

    ULONG64 tmp1;
    ULONG tmp2;

    DWORD protocol;

    ULONG64 id;
    ULONG64 type;

    GET_MEMBER(qwAddr, BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, id, id);
    GET_MEMBER(qwAddr, BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, type, type);

    // Display protocol
    if ((ULONG)id <= 0 ||
        (ULONG)id >= cProtocols)
        {
        dprintf("Invalid protocol ID %d\n", id);
        return;
        }
    protocol = (ULONG)id;
    pszProtocol = Protocols[protocol];

    dprintf("Object (0x%p), protocol\t - %s\n", qwAddr, pszProtocol);

    switch(type & PROTO_MASK)
        {
        case CONNECTION:
            {

            if ((type & TYPE_MASK) == CLIENT)
                {
                dprintf("Client-side connection\t\t - (%p)\n", type);
                }
            else if (type & SERVER)
                {
                dprintf("Server-side connection\t\t - (%p)\n", type);
                }
            else
                {
                dprintf("Unknown type %d\n", type);
                break;
                }

            PRINT_ADDRESS_OF(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, Conn, tmp2);
            PRINT_MEMBER_BOOLEAN(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, fAborted, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, StartingReadIo, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, StartingWriteIo, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, iPostSize, tmp1);
            
            ULONG64 Read;
            GET_ADDRESS_OF(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, Read, Read, tmp2);

            do_overlap(Read);

            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, pReadBuffer, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, maxReadBuffer, tmp1);
            PRINT_MEMBER(qwAddr, BASE_CONNECTION, RPCRT4!BASE_CONNECTION, iLastRead, tmp1);

            ULONG64 pAddress;

            if (protocol == NMP)
                {
                GET_MEMBER(qwAddr, NMP_CONNECTION, RPCRT4!NMP_CONNECTION, pAddress, pAddress);
                dprintf("Associated address\t\t - 0x%I64x\n", pAddress);
                }
            else if (protocol == TCP)
                {
                GET_MEMBER(qwAddr, WS_CONNECTION, RPCRT4!WS_CONNECTION, pAddress, pAddress);
                dprintf("Associated address\t\t - 0x%I64x\n", pAddress);
                }
            else
                {
                GET_MEMBER(qwAddr, WS_CONNECTION, RPCRT4!WS_CONNECTION, saClientAddress, pAddress);

                dprintf("Winsock sockaddr (server)\t - 0x%I64x\n", pAddress);

#ifdef NETBIOS_ON
                if (    protocol == NBF
                     || protocol == NBT
                     || protocol == NBI)
                    {
                    ULONG64 SequenceNumber;
                    GET_MEMBER(qwAddr, NB_CONNECTION, RPCRT4!NB_CONNECTION, SequenceNumber, SequenceNumber);
                    // Netbios based connection has more state
                    dprintf("Netbios sequence number\t\t - %d\n", (ULONG)SequenceNumber);
                    }
                else
#endif
                    if ((type & TYPE_MASK) == CLIENT)
                    {
                    // Client-side non-netbios connections have more state
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, fCallStarted, tmp1);
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, fShutdownReceived, tmp1);
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, fReceivePending, tmp1);
                    PRINT_MEMBER(qwAddr, WS_CLIENT_CONNECTION, RPCRT4!WS_CLIENT_CONNECTION, dwLastCallTime, tmp1);
                    }
                }

            break;
            }

        case ADDRESS:
        case DATAGRAM|ADDRESS:
            {
            dprintf("Address type\t\t\t - (%p)", type);

            if (type & ~(PROTO_MASK | TYPE_MASK | IO_MASK))
                {
                dprintf(" unknown bits 0x%lx\n", type & ~(PROTO_MASK | TYPE_MASK | IO_MASK));
                }
            else
                {
                if (type & DATAGRAM)
                    dprintf(" d/g");
                else
                    dprintf(" c/o");

                if (type & SERVER)
                    dprintf(" server");
                else
                    dprintf(" client or bit not set");

                dprintf("\n");
                }

            ULONG64 Endpoint;
            GET_MEMBER(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, Endpoint, Endpoint);

            if (Endpoint)
                {
                dprintf("Endpoint\t\t\t - %ws\n", ReadProcessRpcChar(Endpoint));
                }
            else
                {
                dprintf("Endpoint\t\t\t - (null)\n");
                }

            ULONG64 pAddressVector;
            GET_MEMBER(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, pAddressVector, pAddressVector);

            if (pAddressVector)
                {
                do_addrvect(pAddressVector);
                }
            else
                {
                dprintf("No address vector\n");
                }

            ULONG64 SubmitListen;
            GET_MEMBER(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, SubmitListen, SubmitListen);

            dprintf("SubmitListen (pfn)\t\t - 0x%I64x %s\n", SubmitListen,
                                                     MapSymbol(SubmitListen));

            PRINT_MEMBER_WITH_LABEL(qwAddr, BASE_ADDRESS, RPCRT4!BASE_ADDRESS, pNext, "Next\t\t\t\t", tmp1);

            if (   
#ifdef IPX_ON
                   protocol != IPX &&
#endif
                   protocol != UDP &&
                   protocol != CDP)
                {
                GET_OFFSET_OF(CO_ADDRESS, RPCRT4!CO_ADDRESS, Listen, &tmp2);
                do_overlap(qwAddr+tmp2);

                ULONG64 NewConnection;
                GET_MEMBER(qwAddr, CO_ADDRESS, RPCRT4!CO_ADDRESS, NewConnection, NewConnection);

                dprintf("NewConnection (pfn)\t\t - 0x%I64x %s\n", NewConnection, MapSymbol(NewConnection));
                }

#ifdef NETBIOS_ON
            BOOL fNetbios = FALSE;
#endif

            switch(protocol)
                {
#ifdef NETBIOS_ON
                case NBI:
                case NBT:
                case NBF:
                    fNetbios = TRUE;
                    // Fall into winsock case
#endif

                case TCP:
#ifdef SPX_ON
                case SPX:
#endif

#ifdef APPLETALK_ON
                case DSP:
#endif
                    {
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, pFirstAddress, "Real address\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, pNextAddress, "Next address\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, ListenSocket, "Listen socket\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, ConnectionSocket, "Connect socket\t\t\t", tmp1);

#ifdef NETBIOS_ON
                    ULONG64 dwProtocolMultiplier;
                    GET_MEMBER(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, dwProtocolMultiplier, dwProtocolMultiplier);

                    if (dwProtocolMultiplier != 1
                        && !fNetbios)
                        {

                        dprintf("Invalid protocol multipler (%d) for winsock address\n", (ULONG)dwProtocolMultiplier);
                        }
                    else
                        {
                        dprintf("Multipler\t\t\t - %d\n", (ULONG)dwProtocolMultiplier);
                        }
#endif
                    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, WS_ADDRESS, RPCRT4!WS_ADDRESS, AcceptBuffer, "AcceptBuffer\t\t\t", tmp2);
                    break;
                    }

                case NMP:
                    {
                    PRINT_MEMBER_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, hConnectPipe, "Connect pipe\t\t\t", tmp1);
                    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, sparePipes, "Spare pipes\t\t\t", tmp2);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, SecurityDescriptor, "Security descriptor\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, NMP_ADDRESS, RPCRT4!NMP_ADDRESS, LocalEndpoint, "Local Endpoint\t\t\t", tmp1);
                    break;
                    }

                case UDP:
#ifdef IPX_ON
                case IPX:
#endif
                case CDP:
                    {
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, Socket, "The socket\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, cPendingIos, "Pending recvs\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, cMinimumIos, "Min recvs\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, cMaximumIos, "Max recvs\t\t\t", tmp1);
                    PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM_ENDPOINT, RPCRT4!WS_DATAGRAM_ENDPOINT, aDatagrams, "Array of datagrams\t\t", tmp1);
                    }
                default:
                    {
                    dprintf("ERROR: Invalid/unknown protocol\n");
                    }
                }

            break;
            }

        case DATAGRAM:
            {
            dprintf("Datagram\t\t\t - (%p)\n", type);

            PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, pEndpoint, "Pointer to owning address\t", tmp1);
            PRINT_MEMBER_BOOLEAN_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, Busy, "Busy\t\t\t\t", tmp1);
            PRINT_MEMBER_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, AddressPair, "AddrPair\t\t\t", tmp1);
            PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, WS_DATAGRAM, RPCRT4!WS_DATAGRAM, Packet, "Packet", tmp2);

            GET_OFFSET_OF(WS_DATAGRAM, RPCRT4!WS_DATAGRAM, Read, &tmp2)

            do_overlap(qwAddr + tmp2);

            break;
            }

        default:
            dprintf("Unknown type %d\n", type);
            break;
        }

    dprintf("\n");

    return;
}

char *strtok(char *String);

DECLARE_API( protocols )
{
    ULONG64 qwAddr;
    BOOL fArgNotSpecified = FALSE;
    ULONG64 ProtocolArrayAddress;

    LPSTR lpArgumentString = (LPSTR)args;

    if (0 == strtok(lpArgumentString))
        {
        lpArgumentString = "rpcrt4!TransportProtocolArray";
        fArgNotSpecified = TRUE;
        }

    qwAddr = GetExpression(lpArgumentString);
    if ( !qwAddr )
        {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
        }

    if (fArgNotSpecified)
        {
        if (ReadPtr(qwAddr, &ProtocolArrayAddress))
            {
            dprintf("couldn't read memory at address %I64x\n", qwAddr);
            return;
            }
        }
    else
        ProtocolArrayAddress = qwAddr;

    do_protocols(ProtocolArrayAddress);
}

const char *ProtocolStateNames[] = {"ProtocolNotLoaded", "ProtocolLoadedWithoutAddress" ,
                                    "ProtocolWasLoadedOrNeedsAct.", "ProtocolLoaded", 
                                    "ProtocolWasLoadedOrNAWithoutAddr",
                                    "ProtocolLoadedAndMonitored"};

VOID
do_protocols(
    ULONG64 qwAddr
    )
{
    ULONG64 pTransportProtocol;
    const char *pProtStateName;
    ULONG64 ListHead;
    ULONG64 ObjectEntry;
    ULONG64 pCurrentObject;
    int i;
    BOOL fFirstObject;
    BOOL b;

    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("     Protocol                          State   AddrChngSock  AddrChngOl\n");
    dprintf("-----------------------------------------------------------------------\n");

    pTransportProtocol = qwAddr;

    for (i = 1; i < MAX_PROTOCOLS; i++)
        {
        fFirstObject = TRUE;
        
        ULONG64 State;
        ULONG64 addressChangeSocket;
        ULONG64 addressChangeOverlapped;

        GET_MEMBER(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, State, State);
        GET_ADDRESS_OF(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, addressChangeSocket, addressChangeSocket, tmp2);
        GET_ADDRESS_OF(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, addressChangeOverlapped, addressChangeOverlapped, tmp2);

        if ((ULONG)State >= sizeof(ProtocolStateNames)/sizeof(ProtocolStateNames[0]))
            pProtStateName = "INVALID";
        else
            pProtStateName = ProtocolStateNames[(ULONG)State];

        dprintf("%13s%31s%15I64x%12I64x\n", Protocols[i], pProtStateName,
            addressChangeSocket, addressChangeOverlapped);

        GET_OFFSET_OF(TransportProtocol, RPCRT4!TransportProtocol, ObjectList, &tmp2);
        ListHead = pTransportProtocol;
        ListHead += tmp2;

        ULONG64 ObjectList;
        GET_ADDRESS_OF(pTransportProtocol, TransportProtocol, RPCRT4!TransportProtocol, ObjectList, ObjectList, tmp2);
        ULONG64 Flink;
        GET_MEMBER(ObjectList, _LIST_ENTRY, RPCRT4!_LIST_ENTRY, Flink, Flink);

        ObjectEntry = Flink;

        while (ObjectEntry != ListHead)
            {
            GET_OFFSET_OF(BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, ObjectList, &tmp2);
            pCurrentObject = ObjectEntry;
            pCurrentObject -= tmp2;

            if (fFirstObject)
                {
                dprintf("Object List:\n");
                fFirstObject = FALSE;
                }
            dprintf("%8lX\n", pCurrentObject);
            // move to the next element in the list
            GET_ADDRESS_OF(pCurrentObject, BASE_ASYNC_OBJECT, RPCRT4!BASE_ASYNC_OBJECT, ObjectList, ObjectList, tmp2);
            GET_MEMBER(ObjectList, _LIST_ENTRY, RPCRT4!_LIST_ENTRY, Flink, Flink);
            }

        pTransportProtocol += GET_TYPE_SIZE(TransportProtocol, RPCRT4!TransportProtocol);
        }
}

VOID
do_overlap(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, BASE_OVERLAPPED, RPCRT4!BASE_OVERLAPPED, pAsyncObject, "Overlapped\t\t\t", tmp2);

    ULONG64 ol;
    GET_ADDRESS_OF(qwAddr, BASE_OVERLAPPED, RPCRT4!BASE_OVERLAPPED, ol, ol, tmp2);

    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, Pointer, "Overlapped, containing object\t", tmp1);

    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, Internal, "ol.Internal (status)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, InternalHigh, "ol.InternalHigh\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(ol, _OVERLAPPED, RPCRT4!_OVERLAPPED, hEvent, "ol.hEvent\t\t\t", tmp1);

    return;
}

VOID
do_addrvect(
    ULONG64 qwAddr
    )
{
    DWORD count;
    BOOL b;
    ULONG64 p;

    GetData(qwAddr, &count, sizeof(count));

    dprintf("Address vector entries\t\t - %d\n", count);
    for (unsigned i = 0; i < count; i++)
        {
        ULONG64 tmp;
        tmp = qwAddr + (i + 1) * AddressSize;
        ReadPtr(tmp, &p);
        dprintf("NetworkAddress[%d]\t\t - (0x%I64x) %ws\n",
                i,
                p,
                ReadProcessRpcChar(p));
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\exts\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Mark Lucovsky (markl) 18-Sep-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

DLLBASE=0x1000000

MAJORCOMP=ntsd
MINORCOMP=ntsdexts

TARGETNAME=rpcexts
TARGETPATH=obj
TARGETTYPE=DYNLINK
TARGETLIBS=\
         $(SDK_LIB_PATH)\kernel32.lib

DLLDEF = ..\rpcdbg.def
MSC_WARNING_LEVEL=/W3 /WX

USE_NTDLL=1

INCLUDES=..\..\mtrt\;.;..;..\..\trans\Common;..\..\..\ndr20;   \
         ..\..\..\midl\inc;$(BASE_INC_PATH);..\..\rtifs\$(O);  \
		 $(PROJECT_ROOT)\inc\ndrshared

C_DEFINES=-DNTENV -DWIN32RPC -DNTWIN32RPC -DMSWMSG -D_RPCRT4_

SOURCES=..\rpcdbg.cxx     \
        ..\nttrans.cxx    \
        ..\rpcdbg.rc

RPCRUNTIME=..\..

LINKLIBS= \
         $(LINKLIBS) \
         $(PROJECT_ROOT)\lib\$(O)\RpcDbg.lib

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\exts\rpcdbg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 2001
//
//  File:       rpcdbg.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    rpcdbg.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  13-May-1996

Revision History:

     13-May-1996     jroberts           Created this module.

    Mazhar Mohammed (mazharm) 3-20-97 - changed it all for async RPC,
                                        added some cool stuff
                                        single dll for ntsd and kd

    KamenM                  Dec 99      Added debugging support and multiple
                                        ntsd-through-kd sessions support

    GrigoriK                Mar 2001    Added support for type info.

--*/

#define KDEXT_64BIT

#include <stddef.h>
#include <limits.h>

#define DG_LOGGING
#define private public
#define protected public
#include <sysinc.h>
#include <wincrypt.h>
#include <rpc.h>
#include <rpcndr.h>
#include <ndrp.h>
#include <wdbgexts.h>
#include <rpcdcep.h>
#include <rpcerrp.h>
#define SECURITY_WIN32
#include <rpcssp.h>
#include <authz.h>
#include <align.h>
#include <util.hxx>
#include <rpcuuid.hxx>
#include <interlck.hxx>
#include <mutex.hxx>
#include <CompFlag.hxx>
#include <sdict.hxx>
#include <sdict2.hxx>
#include <rpctrans.hxx>
#include <CellDef.hxx>
#include <CellHeap.hxx>
#include <EEInfo.h>
#include <EEInfo.hxx>
#include <SWMR.hxx>
#include <bcache.hxx>
#include <threads.hxx>
#include <queue.hxx>
#include <gc.hxx>
#include <handle.hxx>
#include <binding.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <secclnt.hxx>
#include <CompFlag.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <secsvr.hxx>
#include <hndlsvr.hxx>
#include <osfsvr.hxx>
#include <rpccfg.h>
#include <epmap.h>
#include <delaytab.hxx>
#include <memory.hxx>
#include <dgpkt.hxx>
#include <locks.hxx>
#include <dgclnt.hxx>
#include <delaytab.hxx>
#include <hashtabl.hxx>
#include <dgsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <lpcclnt.hxx>
#include <ntverp.h>

#include "rpcexts.hxx"

HANDLE ProcessHandle = 0;
BOOL fKD = 0;

// is debuggee a CHK build?
BOOL ChkTarget;

EXT_API_VERSION        ApiVersion = { VER_PRODUCTVERSION_W >> 8,
                                      VER_PRODUCTVERSION_W & 0xff,
                                      EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   bDebuggingChecked;

VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    KDDEBUGGER_DATA64 KdDebuggerData;

    ExtensionApis = *lpExtensionApis ;
    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
    ChkTarget = SavedMajorVersion == 0x0c ? TRUE : FALSE;

    KdDebuggerData.Header.OwnerTag = KDBG_TAG;
    KdDebuggerData.Header.Size = sizeof( KdDebuggerData );

    if (Ioctl( IG_GET_DEBUGGER_DATA, &KdDebuggerData, sizeof( KdDebuggerData ) ))
        {
        fKD = 1;
        }

    INIT_ADDRESS_SIZE;
}

// By default we use the type information in extensins.
// This flag can be reset with !rpcexts.typeinfo off which will
// disable the use of type information.  !typeinfo on will
// enable it.
BOOL fUseTypeInfo = TRUE;

int AddressSize = 0;

// If not set, the _NOSPEW macros will not print debugger spew.
// It is set to FALSE after the spew is printed by one of thise macros.
BOOL fSpew = TRUE;

char *
BoolString(
    BOOL Value
    )
{
    switch (Value)
        {
        case TRUE:  return "True";
        case FALSE: return "False";
        default:    return "?????";
        }
}

ULONG GetTypeSize(PUCHAR TypeName)
    {
    SYM_DUMP_PARAM Sym = {
        sizeof (SYM_DUMP_PARAM),
        TypeName, 
        DBG_DUMP_NO_PRINT, 0,
        NULL,
        NULL,
        NULL,
        NULL
    };

    return Ioctl(IG_GET_TYPE_SIZE, &Sym, Sym.size);
    }

ULONG64 GetVar(PCSTR VarName)
    {
    ULONG64 Var = 0;
    ULONG64 VarAddr = GetExpression(VarName);

    if (!VarAddr)
        {
        dprintf("Failure to get address of %s\n", VarName);
        return NULL;
        }

    ReadPtr(VarAddr, &Var);

    return Var;
    }

void do_dcebinding  (ULONG64 qwAddr);
void do_dgep        (ULONG64 qwAddr);
void do_dgsc        (ULONG64 qwAddr);
void do_dgsn        (ULONG64 qwAddr);
void do_osfbh       (ULONG64 qwAddr);
void do_osfca       (ULONG64 qwAddr);
void do_osfcconn    (ULONG64 qwAddr);
void do_osfccall    (ULONG64 qwAddr);
void do_osfaddr     (ULONG64 qwAddr);
void do_osfsconn    (ULONG64 qwAddr);
void do_osfscall    (ULONG64 qwAddr);
void do_osfsa       (ULONG64 qwAddr);
void do_rpcsvr      (ULONG64 qwAddr);
void do_lpcaddr     (ULONG64 qwAddr);
void do_lpcsa       (ULONG64 qwAddr);
void do_lpcscall    (ULONG64 qwAddr);
void do_lpcccall    (ULONG64 qwAddr);
void do_lpcbh       (ULONG64 qwAddr);
void do_lpcca       (ULONG64 qwAddr);
void do_rpcmem      (ULONG64 qwAddr, long lDisplay, long lVerbose);
void do_rpcmsg      (ULONG64 qwAddr);
void do_pasync      (ULONG64 qwAddr);
void do_authinfo    (ULONG64 qwAddr);
void do_error       (ULONG64 qwAddr);
void do_dict        (ULONG64 qwAddr);
void do_dict2       (ULONG64 qwAddr);
void do_queue       (ULONG64 qwAddr);
void do_stubmsg     (ULONG64 qwAddr);
void do_thread      (ULONG64 qwAddr);
void do_copacket    (ULONG64 qwAddr);
void do_obj         (ULONG64 qwAddr);
void do_transinfo   (ULONG64 qwAddr);
void do_lpcpacket   (ULONG64 qwAddr);
void do_IF          (ULONG64 qwAddr);
void do_assoctable  (ULONG64 qwAddr);
void do_eerecord    (ULONG64 qwAddr);
void do_eeinfo      (ULONG64 qwAddr);
void do_dgaddr      (ULONG64 qwAddr);
void do_dgca        (ULONG64 qwAddr);
void do_dgbh        (ULONG64 qwAddr);
void do_dgag        (ULONG64 qwAddr);
void do_dgcn        (ULONG64 qwAddr);
void do_typeinfo    (ULONG64 qwAddr);
void do_pipestate   (ULONG64 qwAddr);
void do_pipedesc    (ULONG64 qwAddr);
void do_pipearg     (ULONG64 qwAddr);
void do_pipemsg     (ULONG64 qwAddr);
void do_dgpe        (ULONG64 qwAddr);
void do_dgcc        (ULONG64 qwAddr);
void do_packet      (ULONG64 qwAddr);
void do_packet_header (ULONG64 qwAddr);
void do_trans       (ULONG64 qwAddr);
void do_dgpkt       (ULONG64 qwAddr);
void do_dgpkthdr    (ULONG64 qwAddr);
void do_asyncdcom   (ULONG64 qwAddr);
void do_asyncmsg    (ULONG64 qwAddr);
void do_asyncrpc    (ULONG64 qwAddr);
void do_listcalls   (ULONG64 qwAddr);

MY_DECLARE_API( assoctable )
MY_DECLARE_API( dgep )
MY_DECLARE_API( dgca )
MY_DECLARE_API( dgcn )
MY_DECLARE_API( dgsn )
MY_DECLARE_API( dgsc )
MY_DECLARE_API( osfbh )
MY_DECLARE_API( osfca )
MY_DECLARE_API( osfaddr )
MY_DECLARE_API( osfscall )
MY_DECLARE_API( osfsconn )
MY_DECLARE_API( dcebinding )
MY_DECLARE_API( osfccall )
MY_DECLARE_API( osfcconn )
MY_DECLARE_API( osfsa )
MY_DECLARE_API( rpcmsg )
MY_DECLARE_API( lpcaddr )
MY_DECLARE_API( lpcsa );
MY_DECLARE_API( lpcscall );
MY_DECLARE_API( lpcccall );
MY_DECLARE_API( lpcbh );
MY_DECLARE_API( lpcca );
MY_DECLARE_API( pasync);
MY_DECLARE_API( authinfo );
MY_DECLARE_API( error );
MY_DECLARE_API( dict );
MY_DECLARE_API( dict2 );
MY_DECLARE_API( queue );
MY_DECLARE_API( stubmsg );
MY_DECLARE_API( thread );
MY_DECLARE_API( copacket );
MY_DECLARE_API( obj );
MY_DECLARE_API( transinfo );
MY_DECLARE_API( lpcpacket );
MY_DECLARE_API( IF );
MY_DECLARE_API( eerecord );
MY_DECLARE_API( eeinfo );
MY_DECLARE_API( dgcc );
MY_DECLARE_API( dgpe );
MY_DECLARE_API( pipestate );
MY_DECLARE_API( pipedesc );
MY_DECLARE_API( pipearg );
MY_DECLARE_API( pipemsg );
MY_DECLARE_API( dgpkt );
MY_DECLARE_API( dgpkthdr );
MY_DECLARE_API( asyncdcom );
MY_DECLARE_API( asyncmsg );
MY_DECLARE_API( asyncrpc );

// define our own operators new and delete, so that we do not have to include the crt

void * __cdecl
::operator new(size_t dwBytes)
{
    void *p;
    p = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwBytes);
    return (p);
}


void __cdecl
::operator delete (void *p)
{
    HeapFree(GetProcessHeap(), 0, p);
}

BOOL
GetData(IN ULONG64 qwAddress, IN LPVOID ptr, IN ULONG size)
{
    BOOL b;
    ULONG BytesRead = 0;

    b = ReadMemory(qwAddress, ptr, size, &BytesRead );

    if (!b || BytesRead != size )
        {
        return FALSE;
        }
    return TRUE;
}

#define MAX_MESSAGE_BLOCK_SIZE 1024
#define BLOCK_SIZE 16

RPC_CHAR *
ReadProcessRpcChar(
    ULONG64 qwAddr
    )
{
    char block[BLOCK_SIZE];
    RPC_CHAR *RpcBlock  = (RPC_CHAR *)&block;
    char *string_block = new char[MAX_MESSAGE_BLOCK_SIZE];
    RPC_CHAR *RpcString = (RPC_CHAR *)string_block;
    int length = 0;
    int i = 0;
    BOOL b;
    BOOL end = FALSE;

    if (qwAddr == NULL) {
        return (NULL);
    }

    if (string_block == NULL)
        {
        dprintf("couldn't allocate %d memory\n", MAX_MESSAGE_BLOCK_SIZE);
        return (NULL);
        }

    for (length = 0; length < MAX_MESSAGE_BLOCK_SIZE/2; ) {
        b = GetData(qwAddr, &block, BLOCK_SIZE);
        if (b == FALSE) {
            dprintf("couldn't read address %I64xx\n", qwAddr);
            return (NULL);
        }
        for (i = 0; i < BLOCK_SIZE/2; i++) {
            if (RpcBlock[i] == L'\0') {
                end = TRUE;
            }
            RpcString[length] = RpcBlock[i];
            length++;
        }
        if (end == TRUE) {
            break;
        }
        qwAddr += BLOCK_SIZE;
    }
    return (RpcString);
}

long
myatol(char *string)
{
    int  i         = 0;
    BOOL minus     = FALSE;
    long number    = 0;
    long tmpnumber = 0 ;
    long chknum = LONG_MAX;

    if (string[0] == '-') {
        minus = TRUE;
        i++;
    }
    else
    if (string[0] == '+') {
        i++;
    }
    for (; string[i] != '\0'; i++) {
        if ((string[i] >= '0')&&(string[i] <= '9')) {
            tmpnumber = string[i] - '0';
            if (number != 0)
                {
                chknum = LONG_MAX/number;
                }
            if (chknum > 11) {
                number = number*10 + tmpnumber;
            }
        }
        else
            return 0;
    }
    if (minus == TRUE) {
        number = 0 - number;
    }
    return number;
}

PCHAR
MapSymbol(ULONG64 qwAddr)
{
    static CHAR Name[256];
    ULONG64 Displacement;

    GetSymbol(qwAddr, Name, &Displacement);

    if (strcmp(Name, "") != 0) {
        if (Displacement)
            strcat(Name, "+");

        PCHAR p = strchr(Name, '\0');

        if (Displacement)
          _ui64toa(Displacement, p, 16);

        return(Name);
    }
    else {
        return NULL;
    }
}

// checks if the uuid is null, prints the uuid
void
PrintUuidLocal(UUID *Uuid)
{
    unsigned long PAPI * Vector;

    Vector = (unsigned long PAPI *) Uuid;
    if (    (Vector[0] == 0)
         && (Vector[1] == 0)
         && (Vector[2] == 0)
         && (Vector[3] == 0))
    {
        dprintf("(Null Uuid)");
    }
    else
    {
        dprintf("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                Uuid->Data1, Uuid->Data2, Uuid->Data3, Uuid->Data4[0], Uuid->Data4[1],
                Uuid->Data4[2], Uuid->Data4[3], Uuid->Data4[4], Uuid->Data4[5],
                Uuid->Data4[6], Uuid->Data4[7] );
    }
    return;
}

// prints the uuid at a given address within the process
void
PrintUuid(ULONG64 Uuid)
{
    UUID UuidStore;

    GetData(Uuid, &UuidStore, sizeof(UUID));

    PrintUuidLocal(&UuidStore);
}

// Returns a string for the symbol that matches the value at
// address dwAddr, or "".
PCHAR SymbolAtAddress(ULONG64 Addr)
{
    CHAR Symbol[128];
    ULONG64 Displacement = 0;
    static CHAR Name[256];
    ULONG64 Val;

    ReadPtr(Addr, &Val);

    GetSymbol(Val, Symbol, &Displacement);

    if (strcmp(Symbol, "") != 0) {
        sprintf(Name, "%s+%x", Symbol, Displacement);
        return Name;
    }
    else
        return "";
}

// Returns a string for the symbol that matches the value at
// address dwAddr, without the offset, or "".
PCHAR SymbolAtAddressNoOffset(ULONG64 Addr)
{
    CHAR Symbol[128];
    ULONG64 Displacement = 0;
    static CHAR Name[256];
    ULONG64 Val;

    ReadPtr(Addr, &Val);

    GetSymbol(Val, Symbol, &Displacement);

    if (strcmp(Symbol, "") != 0) {
        sprintf(Name, "%s", Symbol);
        return Name;
    }
    else
        return "";
}

void
do_securitycontext (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    if (qwAddr == 0)
        {
        return;
        }

    do_authinfo(qwAddr);

    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, AuthContextId,
    "     AuthContextId           ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, Flags,
    "     Flags                   ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, ContextAttributes,
    "     ContextAttributes       ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, fFullyConstructed,
    "     fFullyConstructed       ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, DontForgetToDelete,
    "     DontForgetToDelete      ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, fDatagram,
    "     fDatagram               ", tmp1);

    ULONG64 SecurityContext;
    GET_ADDRESS_OF(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, SecurityContext, SecurityContext, tmp2);
    ULONG64 dwUpper, dwLower;
    GET_MEMBER(SecurityContext, _SecHandle, RPCRT4!_SecHandle, dwUpper, dwUpper);
    GET_MEMBER(SecurityContext, _SecHandle, RPCRT4!_SecHandle, dwLower, dwLower);
    dprintf(
    "     SecurityContext(0x%I64x, 0x%I64x) - 0x%I64x\n", dwUpper, dwLower, SecurityContext);

    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, MaxHeaderLength,
    "     MaxHeaderLength         ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, MaxSignatureLength,
    "     MaxSignatureLength      ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, cbBlockSize,
    "     cbBlockSize             ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, RpcSecurityInterface,
    "     RpcSecurityInterface    ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, SECURITY_CONTEXT, RPCRT4!SECURITY_CONTEXT, FailedContext,
    "     FailedContext           ", tmp1);
}

VOID
do_sizes(
    )
{
    PRINT_RPC_TYPE_SIZE(ASSOCIATION_HANDLE);
    dprintf("BIND_NAK_PICKLE_BUFFER_OFFSET - 0x%x\n", BIND_NAK_PICKLE_BUFFER_OFFSET);
    PRINT_RPC_TYPE_SIZE(BINDING_HANDLE);
    PRINT_RPC_TYPE_SIZE(BITSET);
    PRINT_RPC_TYPE_SIZE(CALL);
    PRINT_RPC_TYPE_SIZE(CCALL);
    PRINT_RPC_TYPE_SIZE(CLIENT_AUTH_INFO);
    PRINT_RPC_TYPE_SIZE(CLIENT_ID);
    PRINT_RPC_TYPE_SIZE(DCE_BINDING);
    PRINT_RPC_TYPE_SIZE(DCE_SECURITY_INFO);
    PRINT_RPC_TYPE_SIZE(EVENT);
    PRINT_RPC_TYPE_SIZE(GENERIC_OBJECT);
    PRINT_RPC_TYPE_SIZE(INTERLOCKED_INTEGER);
    PRINT_RPC_TYPE_SIZE(LOADABLE_TRANSPORT);
    PRINT_RPC_TYPE_SIZE(LRPC_ADDRESS);
    PRINT_RPC_TYPE_SIZE(LRPC_BIND_EXCHANGE);
    PRINT_RPC_TYPE_SIZE(LRPC_BINDING_HANDLE);
    PRINT_RPC_TYPE_SIZE(LRPC_CASSOCIATION);
    PRINT_RPC_TYPE_SIZE(LRPC_CCALL);
    PRINT_RPC_TYPE_SIZE(LRPC_MESSAGE);
    PRINT_RPC_TYPE_SIZE(LRPC_FAULT_MESSAGE);
    PRINT_RPC_TYPE_SIZE(LRPC_FAULT2_MESSAGE);
    PRINT_RPC_TYPE_SIZE(LRPC_RPC_HEADER);
    PRINT_RPC_TYPE_SIZE(LRPC_SASSOCIATION);
    PRINT_RPC_TYPE_SIZE(LRPC_SCALL);
    PRINT_RPC_TYPE_SIZE(LRPC_SERVER);
    dprintf("MAX_BIND_NAK - 0x%x\n", MAX_BIND_NAK);
    dprintf("MAXIMUM_FAULT_MESSAGE - 0x%x\n", MAXIMUM_FAULT_MESSAGE);
    dprintf("MAXIMUM_MESSAGE_BUFFER - 0x%x\n", MAXIMUM_MESSAGE_BUFFER);
    PRINT_RPC_TYPE_SIZE(MESSAGE_OBJECT);
    PRINT_RPC_TYPE_SIZE(MUTEX);
    PRINT_RPC_TYPE_SIZE(OSF_ADDRESS);
    PRINT_RPC_TYPE_SIZE(OSF_ASSOCIATION);
    PRINT_RPC_TYPE_SIZE(OSF_BINDING);
    PRINT_RPC_TYPE_SIZE(OSF_BINDING_HANDLE);
    PRINT_RPC_TYPE_SIZE(OSF_CASSOCIATION);
    PRINT_RPC_TYPE_SIZE(OSF_CCALL);
    PRINT_RPC_TYPE_SIZE(OSF_CCONNECTION);
    PRINT_RPC_TYPE_SIZE(OSF_SBINDING);
    PRINT_RPC_TYPE_SIZE(OSF_SCALL);
    PRINT_RPC_TYPE_SIZE(OSF_SCONNECTION);
    dprintf("PORT_MAXIMUM_MESSAGE_LENGTH - 0x%x\n", PORT_MAXIMUM_MESSAGE_LENGTH);
    PRINT_RPC_TYPE_SIZE(PORT_MESSAGE);
    PRINT_RPC_TYPE_SIZE(QUEUE);
    PRINT_RPC_TYPE_SIZE(RPC_ADDRESS);
    PRINT_RPC_TYPE_SIZE(RPC_APC_INFO);
    PRINT_RPC_TYPE_SIZE(RPC_CLIENT_INTERFACE);
    PRINT_RPC_TYPE_SIZE(RPC_CLIENT_PROCESS_IDENTIFIER);
    PRINT_RPC_TYPE_SIZE(rpcconn_alter_context);
    PRINT_RPC_TYPE_SIZE(rpcconn_alter_context_resp);
    PRINT_RPC_TYPE_SIZE(rpcconn_bind);
    PRINT_RPC_TYPE_SIZE(rpcconn_bind_ack);
    PRINT_RPC_TYPE_SIZE(rpcconn_common);
    PRINT_RPC_TYPE_SIZE(rpcconn_fault);
    PRINT_RPC_TYPE_SIZE(rpcconn_request);
    PRINT_RPC_TYPE_SIZE(rpcconn_response);
    PRINT_RPC_TYPE_SIZE(RPC_INTERFACE);
    PRINT_RPC_TYPE_SIZE(RPC_INTERFACE_MANAGER);
#if DBG
    PRINT_RPC_TYPE_SIZE(RPC_MEMORY_BLOCK);
#endif
    PRINT_RPC_TYPE_SIZE(RPC_MESSAGE);
    PRINT_RPC_TYPE_SIZE(RPC_SERVER);
    PRINT_RPC_TYPE_SIZE(RPC_SERVER_INTERFACE);
    PRINT_RPC_TYPE_SIZE(RPC_SYNTAX_IDENTIFIER);
    PRINT_RPC_TYPE_SIZE(RPC_UUID);
    PRINT_RPC_TYPE_SIZE(SCALL);
    PRINT_RPC_TYPE_SIZE(SECURITY_CONTEXT);
    PRINT_RPC_TYPE_SIZE(sec_trailer);
    PRINT_RPC_TYPE_SIZE(SIMPLE_DICT);
    PRINT_RPC_TYPE_SIZE(SIMPLE_DICT2);
    PRINT_RPC_TYPE_SIZE(THREAD);
    PRINT_RPC_TYPE_SIZE(TRANS_INFO);
}

DECLARE_API( sizes )
{
   do_sizes();
}

char *
GetError (DWORD dwError)
{
    DWORD   dwFlag = FORMAT_MESSAGE_FROM_SYSTEM;
    static CHAR   szErrorMessage[1024];
    static HANDLE  hSource = NULL;

    if ((dwError >= 2100) && (dwError < 6000))
    {
        if (hSource == NULL)
            {
            hSource = LoadLibrary("netmsg.dll");
            }

        if (hSource == NULL)
        {
            sprintf (szErrorMessage,
                      "Unable to load netmsg.dll. Error %d occured.\n",
                      dwError);
            return(szErrorMessage);
        }

        dwFlag = FORMAT_MESSAGE_FROM_HMODULE;
    }

    if (!FormatMessage (dwFlag,
                        hSource,
                        dwError,
                        0,
                        szErrorMessage,
                        1024,
                        NULL))
       {
        sprintf (szErrorMessage,
                  "An unknown error occured: 0x%x \n",
                  dwError);
       }

    return(szErrorMessage);
}

VOID
do_error (
    ULONG64 Error
    )
{
    dprintf("%x: %s\n", (unsigned long)Error, GetError((unsigned long) Error));
}

VOID
do_IF (
    ULONG64 rpcif
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;
    dprintf("RPC_INTERFACE at 0x%I64x\n\n", rpcif);

    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Server, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NullManagerEpv, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NullManagerFlag, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, ManagerCount, tmp0);
    GET_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NullManagerActiveCallCount, tmp0, tmp2);
    PRINT_MEMBER_WITH_LABEL(tmp0, INTERLOCKED_INTEGER, RPCRT4!INTERLOCKED_INTEGER, Integer, "NullManagerActiveCallCount", tmp1);
    GET_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, AutoListenCallCount, tmp0, tmp2);
    PRINT_MEMBER_WITH_LABEL(tmp0, INTERLOCKED_INTEGER, RPCRT4!INTERLOCKED_INTEGER, Integer, "AutoListenCallCount", tmp1);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Flags, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, MaxCalls, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, CallbackFn, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, PipeInterfaceFlag, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, fReplace, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, fBindingsExported, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, UuidVector, tmp0);
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, SequenceNumber, tmp0);
#if DBG
    PRINT_MEMBER(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Strict, tmp0);
#endif
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, RpcInterfaceInformation, tmp2);
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, InterfaceManagerDictionary, tmp2);
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, Annotation, tmp2);
    PRINT_ADDRESS_OF(rpcif, RPC_INTERFACE, RPCRT4!RPC_INTERFACE, NsEntries, tmp2);
}

VOID
do_obj (
    ULONG64 qwAddr
    )
{
    BOOL b;

    ULONG64 MagicValue;
    ULONG64 ObjectType;

    ReadPtr(qwAddr+AddressSize, &MagicValue);
    ReadPtr(qwAddr+AddressSize+4, &ObjectType);

    if ((ULONG)MagicValue != MAGICLONG)
        {
        dprintf("Bad or deleted object at %p\n", qwAddr);
        }

    switch (((ULONG)ObjectType) & (~OBJECT_DELETED))
        {
        case DG_CALLBACK_TYPE:
            dprintf("this is a DG_CLIENT_CALLBACK object\n");
            break;
        case DG_CCALL_TYPE:
            {
            dprintf("Dumping DG_CCALL...\n");
            do_dgcc(qwAddr);
            break;
            }
        case DG_SCALL_TYPE:
            {
            dprintf("Dumping DG_SCALL...\n");
            do_dgsc(qwAddr);
            break;
            }
        case DG_BINDING_HANDLE_TYPE:
            {
            dprintf("dumping DG_BINDING_HANDLE...\n");
            do_dgbh(qwAddr);
            break;
            }
        case DG_CCONNECTION_TYPE:
            {
            dprintf("Dumping DG_CCONNECTION...\n");
            do_dgcn(qwAddr);
            break;
            }
        case DG_SCONNECTION_TYPE:
            {
            dprintf("Dumping DG_SCONNECTION...\n");
            do_dgsn(qwAddr);
            break;
            }
        case DG_ADDRESS_TYPE:
            {
            dprintf("dumping DG_ADDRESS\n");
            do_dgaddr(qwAddr);
            break;
            }
        case DG_CASSOCIATION_TYPE:
            {
            dprintf("a DG_CASSOCIATION\n");
            do_dgca(qwAddr);
            break;
            }
        case DG_SASSOCIATION_TYPE:
            {
            dprintf("a datagram ASSOCIATION_GROUP\n");
            do_dgag(qwAddr);
            break;
            }
        case OSF_BINDING_HANDLE_TYPE:
            dprintf("Dumping OSF_BINDING_HANDLE...\n");
            do_osfbh(qwAddr);
            break;
        case OSF_CCALL_TYPE:
            dprintf("Dumping OSF_CCALL...\n");
            do_osfccall(qwAddr);
            break;
        case OSF_SCALL_TYPE:
            dprintf("Dumping OSF_SCALL...\n");
            do_osfscall(qwAddr);
            break;
        case OSF_CCONNECTION_TYPE:
            dprintf("Dumping OSF_CCONNECTION...\n");
            do_osfcconn(qwAddr);
            break;
        case OSF_SCONNECTION_TYPE:
            dprintf("Dumping OSF_SCONNECTION...\n");
            do_osfsconn(qwAddr);
            break;
        case OSF_CASSOCIATION_TYPE:
            dprintf("Dumping OSF_CASSOCIATION...\n");
            do_osfca(qwAddr);
            break;
        case OSF_ASSOCIATION_TYPE:
            dprintf("Dumping OSF_ASSOCIATION...\n");
            do_osfsa(qwAddr);
            break;
        case OSF_ADDRESS_TYPE:
            dprintf("Dumping OSF_ADDRESS...\n");
            do_osfaddr(qwAddr);
            break;
        case LRPC_CCALL_TYPE:
            dprintf("Dumping LRPC_CCALL ...\n");
            do_lpcccall(qwAddr);
            break;
        case LRPC_SCALL_TYPE:
            dprintf("Dumping LRPC_SCALL ...\n");
            do_lpcscall(qwAddr);
            break;
        case LRPC_CASSOCIATION_TYPE:
            dprintf("Dumping LRPC_CASSOCIATION...\n");
            do_lpcca(qwAddr);
            break;
        case LRPC_SASSOCIATION_TYPE:
            dprintf("Dumping LRPC_SASSOCIATION...\n");
            do_lpcsa(qwAddr);
            break;
        case LRPC_BINDING_HANDLE_TYPE:
            dprintf("Dumping LRPC_BINDING_HANDLE...\n");
            do_lpcbh(qwAddr);
            break;
        case LRPC_ADDRESS_TYPE:
            dprintf("Dumping LRPC_ADDRESS...\n");
            do_lpcaddr(qwAddr);
            break;
        default:
            dprintf("The RPC object type is 0x%lx and I don't recognize it.\n", (ObjectType) & ~(OBJECT_DELETED));
        }
}

void
do_secinfo (
    )
{
    ULONG64 SecurityPackages;
    ULONG64 List;
    ULONG64 ProviderList;
    int NumberOfPackages;
    int LoadedProviders;
    int AvailableProviders;
    int i, Index;
    BOOL b;
    ULONG64 qwAddr;
    ULONG tmp;

    LoadedProviders = (int) GetVar("RPCRT4!LoadedProviders");

    dprintf("LoadedProviders = %d\n", LoadedProviders);

    AvailableProviders = (int) GetVar("RPCRT4!AvailableProviders");

    dprintf("AvailableProviders = %d\n", AvailableProviders);

    ProviderList = GetVar("RPCRT4!ProviderList");

    dprintf("ProviderList = 0x%I64x\n", ProviderList);

    List = ProviderList;

    for (i = 0; i < LoadedProviders; i ++)
        {
        ULONG64 Count;
        ULONG64 SecurityPackages;

        GET_MEMBER(List, SECURITY_PROVIDER_INFO, RPCRT4!SECURITY_PROVIDER_INFO, Count, Count);

        NumberOfPackages = (int)Count;

        GET_MEMBER(List, SECURITY_PROVIDER_INFO, RPCRT4!SECURITY_PROVIDER_INFO, SecurityPackages, SecurityPackages);

        dprintf("Provider: %d\n", i);
        for (Index = 0;Index < NumberOfPackages;Index++)
            {
            ULONG64 SecurityPackageInfo = SecurityPackages + Index * AddressSize;
            ULONG64 wRPCID;
            ULONG64 PackageInfoAddr;

            GET_ADDRESS_OF(SecurityPackageInfo, SECURITY_PACKAGE_INFO, RPCRT4!SECURITY_PACKAGE_INFO, PackageInfo, PackageInfoAddr, tmp);
            GET_MEMBER(PackageInfoAddr, _SecPkgInfoA, RPCRT4!_SecPkgInfoA, wRPCID, wRPCID);

            dprintf("PackageId :%d\n", (ULONG) wRPCID);
            }
        dprintf("\n");
        List+=GET_TYPE_SIZE(SECURITY_PROVIDER_INFO, RPCRT4!SECURITY_PROVIDER_INFO);
        } //For over all packages in one provider(dll)
}

DECLARE_API( secinfo )
{
   do_secinfo();
}

VOID
do_authinfo(
    ULONG64 authInfo
    )
{
    RPC_CHAR *ServerPrincipalName;
    ULONG64 tmp1;
    ULONG tmp2;

    if (authInfo == 0)
        {
        return;
        }

    ULONG64 ServerPrincipalNameAddr;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, ServerPrincipalName, ServerPrincipalNameAddr);

    ServerPrincipalName = ReadProcessRpcChar(ServerPrincipalNameAddr);

    dprintf("     ServerPrincipalName      - %ws (Address: 0x%I64x)\n", ServerPrincipalName, ServerPrincipalNameAddr);

    ULONG64 AuthenticationLevel;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthenticationLevel, AuthenticationLevel);

    switch ((ULONG)AuthenticationLevel) {
        case RPC_C_AUTHN_LEVEL_DEFAULT:
            dprintf("     AuthenticationLevel      - default\n");
            break;
        case RPC_C_AUTHN_LEVEL_NONE:
            dprintf("     AuthenticationLevel      - none\n");
            break;
        case RPC_C_AUTHN_LEVEL_CONNECT:
            dprintf("     AuthenticationLevel      - connect\n");
            break;
        case RPC_C_AUTHN_LEVEL_CALL:
            dprintf("     AuthenticationLevel      - call\n");
            break;
        case RPC_C_AUTHN_LEVEL_PKT:
            dprintf("     AuthenticationLevel      - pkt\n");
            break;
        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
            dprintf("     AuthenticationLevel      - pkt integrity\n");
            break;
        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
            dprintf("     AuthenticationLevel      - pkt privacy\n");
            break;
        default:
            dprintf("     AuthenticationLevel      - %ul\n", (ULONG)AuthenticationLevel);
            break;
    }

    ULONG64 AuthenticationService;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthenticationService, AuthenticationService);

    switch ((ULONG)AuthenticationService) {
        case RPC_C_AUTHN_NONE:
            dprintf("     AuthenticationService    - none\n");
            break;
        case RPC_C_AUTHN_DCE_PRIVATE:
            dprintf("     AuthenticationService    - DCE private\n");
            break;
        case RPC_C_AUTHN_DCE_PUBLIC:
            dprintf("     AuthenticationService    - DCE public\n");
            break;
        case RPC_C_AUTHN_DEC_PUBLIC:
            dprintf("     AuthenticationService    - DEC public\n");
            break;
        case RPC_C_AUTHN_WINNT:
            dprintf("     AuthenticationService    - WINNT\n");
            break;
        case RPC_C_AUTHN_DEFAULT:
            dprintf("     AuthenticationService    - default\n");
            break;
        default:
            dprintf("     AuthenticationService    - %ul\n", (ULONG)AuthenticationService);
            break;
    }

    ULONG64 AuthIdentity;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthIdentity, AuthIdentity);

    dprintf("     AuthIdentity             - %08x\n", (ULONG)AuthIdentity);

    ULONG64 AuthorizationService;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, AuthorizationService, AuthorizationService);

    switch ((ULONG)AuthorizationService) {
        case RPC_C_AUTHZ_NONE:
            dprintf("     AuthorizationService     - none\n");
            break;
        case RPC_C_AUTHZ_NAME:
            dprintf("     AuthorizationService     - name\n");
            break;
        case RPC_C_AUTHZ_DCE:
            dprintf("     AuthorizationService     - DCE\n");
            break;
        default:
            dprintf("     AuthorizationService     - %ul\n", (ULONG)AuthorizationService);
            break;
    }

    ULONG64 IdentityTracking;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, IdentityTracking, IdentityTracking);

    switch ((ULONG)IdentityTracking)
        {
        case RPC_C_QOS_IDENTITY_STATIC:
            dprintf("     IdentityTracking         - Static\n");
            break;
        case RPC_C_QOS_IDENTITY_DYNAMIC:
            dprintf("     IdentityTracking         - Dynamic\n");
            break;
        default:
            dprintf("     IdentityTracking         - %08x\n", (ULONG)IdentityTracking);
            break;
        }

    ULONG64 ImpersonationType;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, ImpersonationType, ImpersonationType);

    switch ((ULONG)ImpersonationType)
        {
        case RPC_C_IMP_LEVEL_ANONYMOUS:
            dprintf("     ImpersonationType        - Anonymous\n");
            break;
        case RPC_C_IMP_LEVEL_IDENTIFY:
            dprintf("     ImpersonationType        - Identify\n");
            break;
        case RPC_C_IMP_LEVEL_IMPERSONATE:
            dprintf("     ImpersonationType        - Impersonate\n");
            break;
        case RPC_C_IMP_LEVEL_DELEGATE:
            dprintf("     ImpersonationType        - Delegate\n");
            break;
        default:
            dprintf("     ImpersonationType        - %08x\n", (ULONG)ImpersonationType);
            break;
        }

    ULONG64 Capabilities;
    GET_MEMBER(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, Capabilities, Capabilities);

    switch ((ULONG)Capabilities)
        {
        case RPC_C_QOS_CAPABILITIES_DEFAULT:
            dprintf("     Capabilities             - Default\n");
            break;
        case RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH:
            dprintf("     Capabilities             - Mutual Auth\n");
            break;
        default:
            dprintf("     Capabilities             - %08x\n", (ULONG)Capabilities);
            break;
        }

    ULONG64 ModifiedId, LowPart, HighPart;
    GET_ADDRESS_OF(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, ModifiedId, ModifiedId, tmp2);
    GET_MEMBER(ModifiedId, _LUID, RPCRT4!_LUID, LowPart, LowPart);
    GET_MEMBER(ModifiedId, _LUID, RPCRT4!_LUID, HighPart, HighPart);
    dprintf("     ModifiedId               - %08x, %08x\n", (ULONG)LowPart, (ULONG)HighPart);

    PRINT_MEMBER_WITH_LABEL(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, DefaultLogonId, "     DefaultLogonId          ", tmp1);
    PRINT_MEMBER_WITH_LABEL(authInfo, CLIENT_AUTH_INFO, RPCRT4!CLIENT_AUTH_INFO, Credentials, "     Credentials             ", tmp1);

    if (ServerPrincipalName) {
        delete[] ServerPrincipalName;
    }
}

void do_dict (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 cDictSize;
    ULONG64 cDictSlots;
    GET_MEMBER(qwAddr, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSize, cDictSize);
    GET_MEMBER(qwAddr, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSlots, cDictSlots);

    if ((ULONG)cDictSize > (ULONG)cDictSlots)
        {
        dprintf("Bad dictionary\t\t- %I64p\n", qwAddr);
        return;
        }

    ULONG64 DictSlots;
    GET_MEMBER(qwAddr, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, DictSlots, DictSlots);

    dprintf("\n");
    dprintf("Printing %d items in dictionary: %I64p with %d slots\n\n", (ULONG)cDictSize, qwAddr, (ULONG)cDictSlots);

    int i;

    for (i = 0; i < MIN((int)cDictSize, MAX_ITEMS_IN_DICTIONARY); i++)
        {
        ULONG64 DictSlot;
        ReadPtr(DictSlots + i * AddressSize, &DictSlot);
        dprintf ("(%d): 0x%I64x\n", i, DictSlot);
        dprintf("\n");
        }
}

void do_dict2 (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 DictKeys;
    ULONG64 DictItems;
    GET_MEMBER(qwAddr, SIMPLE_DICT2, RPCRT4!SIMPLE_DICT2, DictKeys, DictKeys);
    GET_MEMBER(qwAddr, SIMPLE_DICT2, RPCRT4!SIMPLE_DICT2, DictItems, DictItems);

    ULONG64 cDictSlots;
    GET_MEMBER(qwAddr, SIMPLE_DICT2, RPCRT4!SIMPLE_DICT2, cDictSlots, cDictSlots);

    dprintf("\n");

    dprintf("Printing dictionary at %I64p with %d slots\n\n", qwAddr, (ULONG) cDictSlots);

    int i;

    for (i = 0; i < MIN((int)cDictSlots, MAX_ITEMS_IN_DICTIONARY); i++)
        {
        ULONG64 DictKey;
        ReadPtr(DictKeys + i * AddressSize, &DictKey);

        if (DictKey != 0)
            {
            ULONG64 DictItem;
            ReadPtr(DictItems + i * AddressSize, &DictItem);

            dprintf ("(Key: 0x%I64p): 0x%I64p\n", DictKey, DictItem);
            dprintf("\n");
            }
        }
}

void
do_queue (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    int i;

    ULONG64 EndOfQueue;
    ULONG64 QueueSlots;
    GET_MEMBER(qwAddr, QUEUE, RPCRT4!QUEUE, EndOfQueue, EndOfQueue);
    GET_MEMBER(qwAddr, QUEUE, RPCRT4!QUEUE, QueueSlots, QueueSlots);

    dprintf("\n");
    dprintf("Printing %d items in queue at %I64p\n", (ULONG)EndOfQueue, qwAddr);

    dprintf("TAIL:\n");
    for (i = 0; i < (int)EndOfQueue; i++)
        {
        ULONG64 QueueSlot;
        ReadPtr(QueueSlots + i * AddressSize, &QueueSlot);
        ULONG64 Buffer;
        GET_MEMBER(QueueSlot, QUEUE_ITEM, RPCRT4!QUEUE_ITEM, Buffer, Buffer);

        dprintf ("(%d): %I64p\n", i, Buffer);
        dprintf("\n");
        }
    dprintf("HEAD:\n");
}


void do_thread (
    ULONG64 Addr
    )
{
    ULONG64 RpcThread;
    ULONG64 tmp;
    ULONG offset;

    GET_MEMBER(Addr, TEB, TEB, ReservedForNtRpc, RpcThread);

    dprintf("RPC TLS at 0x%I64x\n\n", RpcThread);

    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, HandleToThread, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, SavedProcedure, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, SavedParameter, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, ActiveCall, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, Context, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, CancelTimeout, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, SecurityContext, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, ExtendedStatus, tmp);
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, ThreadEEInfo, tmp);

    GET_OFFSET_OF(THREAD, RPCRT4!THREAD, ThreadEvent, &offset);
    dprintf("ThreadEvent at - 0x%I64x\n", RpcThread + offset);
 
    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, Flags, tmp);

    GET_OFFSET_OF(THREAD, RPCRT4!THREAD, BufferCache, &offset);
    dprintf("buffer cache array at - 0x%I64x\n", RpcThread + offset);

    PRINT_MEMBER(RpcThread, THREAD, RPCRT4!THREAD, fAsync, tmp);
    
    dprintf("\n");
}

char *osf_ptype[]  =
{
    "rpc_request",
    "bad packet",
    "rpc_response",
    "rpc_fault",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "bad packet",
    "rpc_bind",
    "rpc_bind_ack",
    "rpc_bind_nak",
    "rpc_alter_context",
    "rpc_alter_context_resp",
    "rpc_auth_3",
    "rpc_shutdown",
    "rpc_cancel",
    "rpc_orphaned"
};

void do_copacket (
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 StubData;

    //
    // Dump the common header first
    //
    dprintf("\n");

    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, rpc_vers, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, rpc_vers_minor, tmp1);

    ULONG64 PTYPE;
    GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, PTYPE, PTYPE);
    dprintf ("PTYPE - 0x%x, %s\n",
             (ULONG)PTYPE, osf_ptype[(ULONG)PTYPE]);

    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, pfc_flags, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, drep, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, frag_length, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, auth_length, tmp1);
    PRINT_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, call_id, tmp1);

    //
    // Dump the packet specific stuff
    //
    switch ((ULONG)PTYPE)
        {
        case rpc_request:

            PRINT_MEMBER(qwAddr, rpcconn_request, RPCRT4!rpcconn_request, alloc_hint, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_request, RPCRT4!rpcconn_request, p_cont_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_request, RPCRT4!rpcconn_request, opnum, tmp1);

            ULONG64 pfc_flags;
            GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, pfc_flags, pfc_flags);

            if ((ULONG)pfc_flags & PFC_OBJECT_UUID)
                {
                dprintf("UUID -\n");
                ULONG64 UUID = qwAddr;
                UUID += GET_TYPE_SIZE(rpcconn_common, RPCRT4!rpcconn_common);
                PrintUuid(UUID);
                dprintf("\n");

                StubData = qwAddr;
                StubData += GET_TYPE_SIZE(rpcconn_request, RPCRT4!rpcconn_request);
                StubData += GET_TYPE_SIZE(UUID, RPCRT4!UUID);
                dprintf ("Stub Data - 0x%I64x\n", StubData);
                }
            else
                {
                StubData = qwAddr;
                StubData += GET_TYPE_SIZE(rpcconn_request, RPCRT4!rpcconn_request);
                dprintf ("Stub Data - 0x%I64x\n", StubData);
                }
            break;

        case rpc_response:
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, alloc_hint, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, p_cont_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, alert_count, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_response, RPCRT4!rpcconn_response, reserved, tmp1);

            StubData = qwAddr;
            StubData += GET_TYPE_SIZE(rpcconn_response, RPCRT4!rpcconn_response);

            dprintf ("Stub Data - 0x%I64x\n", StubData);
            break;

        case rpc_fault:
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, alloc_hint, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, p_cont_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, alert_count, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, reserved, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, status, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_fault, RPCRT4!rpcconn_fault, reserved2, tmp1);
            break;

        case rpc_bind:
        case rpc_alter_context:
            PRINT_MEMBER(qwAddr, rpcconn_bind, RPCRT4!rpcconn_bind, max_xmit_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind, RPCRT4!rpcconn_bind, max_recv_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind, RPCRT4!rpcconn_bind, assoc_group_id, tmp1);
            break;

        case rpc_bind_ack:
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, max_xmit_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, max_recv_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, assoc_group_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_ack, RPCRT4!rpcconn_bind_ack, sec_addr_length, tmp1);
            break;

        case rpc_bind_nak:
            PRINT_MEMBER(qwAddr, rpcconn_bind_nak, RPCRT4!rpcconn_bind_nak, provider_reject_reason, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_bind_nak, RPCRT4!rpcconn_bind_nak, versions, tmp1);
            break;

        case rpc_alter_context_resp:
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, max_xmit_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, max_recv_frag, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, assoc_group_id, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, sec_addr_length, tmp1);
            PRINT_MEMBER(qwAddr, rpcconn_alter_context_resp, RPCRT4!rpcconn_alter_context_resp, pad, tmp1);
            break;

        case rpc_auth_3:
        case rpc_shutdown:
        case rpc_cancel:
        case rpc_orphaned:
            break;

        default:
            dprintf ("Bad Packet\n");
            break;
        }

    //
    // Dump the security trailer
    //
    ULONG64 auth_length;
    ULONG64 frag_length;
    GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, auth_length, auth_length);
    GET_MEMBER(qwAddr, rpcconn_common, RPCRT4!rpcconn_common, frag_length, frag_length);

    if ((ULONG)auth_length)
        {
        ULONG64 SecurityTrailer = qwAddr;
        SecurityTrailer += frag_length-auth_length-GET_TYPE_SIZE(sec_trailer, RPCRT4!sec_trailer);
        dprintf("\nSecurity trailer: 0x%I64x\n", SecurityTrailer);

        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_type, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_level, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_pad_length, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_reserved, tmp1);
        PRINT_MEMBER(SecurityTrailer, sec_trailer, RPCRT4!sec_trailer, auth_context_id, tmp1);
        dprintf ("trailer - 0x%I64x\n", SecurityTrailer+1);
        }
}

char *lpc_ptype[]  =
{
"LRPC_MSG_BIND",
"LRPC_MSG_REQUEST",
"LRPC_MSG_RESPONSE",
"LRPC_MSG_CALLBACK",
"LRPC_MSG_FAULT",
"LRPC_MSG_CLOSE",
"LRPC_MSG_ACK",
"LRPC_BIND_ACK",
"LRPC_MSG_COPY",
"LRPC_MSG_PUSH",
"LRPC_MSG_CANCEL",
"LRPC_MSG_BIND_BACK",
"LRPC_ASYNC_REQUEST",
"LRPC_PARTIAL_REQUEST",
"LRPC_CLIENT_SEND_MORE",
"LRPC_SERVER_SEND_MORE",
"LRPC_MSG_FAULT2"
};

VOID
do_lpcpacket(
    ULONG64 qwAddr
    )
{
    if (fUseTypeInfo) {
        ULONG64 LpcHeader;
        ULONG64 RpcHeader;
        ULONG64 Buffer;
        ULONG64 tmp1;
        ULONG tmp2;

        GET_ADDRESS_OF(qwAddr, LRPC_RPC_MESSAGE, RPCRT4!LRPC_RPC_MESSAGE, LpcHeader, LpcHeader, tmp2);
        GET_ADDRESS_OF(qwAddr, LRPC_RPC_MESSAGE, RPCRT4!LRPC_RPC_MESSAGE, RpcHeader, RpcHeader, tmp2);

        dprintf("\n");

        //
        // dump the LPC header
        //
        PRINT_ADDRESS_OF_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, u1, "&u1\t\t\t", tmp2);
        PRINT_ADDRESS_OF_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, u2, "&u2\t\t\t", tmp2);
        PRINT_ADDRESS_OF_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, ClientId, "&CLIENT_ID\t\t", tmp2);
        PRINT_MEMBER_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, MessageId, "MessageId\t\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(LpcHeader, _PORT_MESSAGE, RPCRT4!_PORT_MESSAGE, CallbackId, "CallbackId\t\t", tmp1);

        //
        // dump the LRPC header
        //
        ULONG64 MessageType;
        GET_MEMBER(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, MessageType, MessageType);
        dprintf("MessageType\t\t - %s\n", lpc_ptype[(long)MessageType]);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, PresentContext, "PresentationContext\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, Flags, "Flags\t\t\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, ProcedureNumber, "ProcedureNumber\t\t", tmp1);
        PRINT_MEMBER_WITH_LABEL(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, CallId, "CallId\t\t\t", tmp1);

        ULONG64 ObjectUuid;
        GET_ADDRESS_OF(RpcHeader, _LRPC_RPC_HEADER, RPCRT4!_LRPC_RPC_HEADER, ObjectUuid, ObjectUuid, tmp2);
        dprintf("ObjectUuid\t\t - ");
        PrintUuid(ObjectUuid);

        dprintf("\n\n");
    }
    else {
        BOOL b;
        char block[sizeof(LRPC_RPC_MESSAGE)];
        LRPC_RPC_MESSAGE *m = (LRPC_RPC_MESSAGE *)&block;

        b = GetData(qwAddr, &block, sizeof(LRPC_RPC_MESSAGE));
        if ( !b ) {
          dprintf("couldn't read address %p\n", qwAddr);
          return;
        }

        dprintf("\n");
        //
        // dump the LPC header
        //
        dprintf("DataLength\t\t- 0x%x\n", (long) m->LpcHeader.u1.s1.DataLength);
        dprintf("TotalLength\t\t- 0x%x\n", (long) m->LpcHeader.u1.s1.TotalLength);
        dprintf("Type\t\t\t- 0x%x\n", (long) m->LpcHeader.u2.s2.Type);
        dprintf("DataInfoOffset\t\t- 0x%x\n", (long) m->LpcHeader.u2.s2.DataInfoOffset);
        dprintf("CLIENT_ID: \t\t- Process(0x%x), Thread(0x%x)\n",
                m->LpcHeader.ClientId.UniqueProcess, m->LpcHeader.ClientId.UniqueThread);
        dprintf("MessageId\t\t- 0x%x\n", m->LpcHeader.MessageId);
        dprintf("CallbackId\t\t- 0x%x\n", m->LpcHeader.CallbackId);

        //
        // dump the LRPC header
        //
        dprintf("MessageType\t\t- %s\n", lpc_ptype[(long) m->RpcHeader.MessageType]);
        dprintf("PresentationContext\t- 0x%x\n", (long) m->RpcHeader.PresentContext);
        dprintf("Flags\t\t\t- 0x%x\n", (unsigned long) m->RpcHeader.Flags);
        dprintf("ProcedureNumber\t\t- 0x%x\n", (long) m->RpcHeader.ProcedureNumber);
        dprintf("CallId\t\t\t- 0x%x\n", (long) m->RpcHeader.CallId);
        dprintf("ObjectUuid\t\t- ");
        PrintUuidLocal((UUID *) &(m->RpcHeader.ObjectUuid));

        dprintf("\nStubData\t\t- 0x%x\n", m+1);
        dprintf("\n");
    }
}

VOID
do_bh(
    ULONG64 qwAddr
    )
{
    RPC_CHAR *EntryName;

    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 EntryNameAddr;
    ULONG64 ObjectUuidAddr;

    GET_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, EntryName, EntryNameAddr);
    GET_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, ObjectUuid, ObjectUuidAddr);

    EntryName = ReadProcessRpcChar(EntryNameAddr);

    dprintf("\n");

    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, Timeout, tmp1);

    dprintf("ObjectUuid\t\t- ");
    PrintUuid(ObjectUuidAddr); dprintf("\n");

    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, NullObjectUuidFlag, tmp1);
    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, EntryNameSyntax, tmp1);

    dprintf("EntryName\t\t- %ws (Address: 0x%x)\n", EntryName ? EntryName : L"(null)", EntryNameAddr);

    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, EpLookupHandle, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, BindingMutex, "&BindingMutex(MUTEX)", tmp2);
    PRINT_MEMBER(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, pvTransportOptions, tmp1);
    PRINT_ADDRESS_OF(qwAddr, BINDING_HANDLE, RPCRT4!BINDING_HANDLE, ClientAuthInfo, tmp2);

    do_authinfo(qwAddr+tmp2);
}

VOID
do_osfbh(
    ULONG64 qwAddr
    )
{
    BOOL b;
 
    ULONG64 tmp1;
    ULONG tmp2;

    do_bh(qwAddr);

    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, Association, tmp1);
    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, DceBinding, tmp1);

    do_dcebinding(tmp1);

    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, TransInfo, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, RecursiveCalls, "&RecursiveCalls(OSF_ACTIVE_ENTRY_DICT)", tmp2);
    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_BINDING_HANDLE, RPCRT4!OSF_BINDING_HANDLE, pToken, tmp1);

    dprintf("\n");
}

VOID
do_osfca(
    ULONG64 qwAddr
    )
{
    BOOL b;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, DceBinding, "DceBinding(DCE_BINDING)", tmp1);
    do_dcebinding(tmp1);

    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, BindHandleCount, tmp1);
    PRINT_ADDRESS_OF(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, Bindings, tmp2);
    PRINT_ADDRESS_OF(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, ActiveConnections, tmp2);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, AssocGroupId, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, TransInfo, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, SecondaryEndpoint, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, Key, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, OpenConnectionCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, CallIdCounter, tmp1);
    PRINT_ADDRESS_OF(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, AssociationMutex, tmp2);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, AssociationValid, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, FailureCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, fMultiplex, tmp1);
    PRINT_MEMBER(qwAddr, OSF_CASSOCIATION, RPCRT4!OSF_CASSOCIATION, SavedDrep, tmp1);

    dprintf("\n");
}

VOID
do_dcebinding(
    ULONG64 qwAddr
    )
{
    RPC_STATUS RpcStatus;
    BOOL b;

    ULONG tmp2;

    ULONG64 RpcProtocolSequenceAddr;
    ULONG64 NetworkAddressAddr;
    ULONG64 EndpointAddr;
    ULONG64 OptionsAddr;
    ULONG64 ObjectUuidAddr;

    RPC_CHAR *RpcProtocolSequence;
    RPC_CHAR *NetworkAddress;
    RPC_CHAR *Endpoint;
    RPC_CHAR *Options;

    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, RpcProtocolSequence, RpcProtocolSequenceAddr);
    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, NetworkAddress, NetworkAddressAddr);
    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, Endpoint, EndpointAddr);
    GET_MEMBER(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, Options, OptionsAddr);
    GET_ADDRESS_OF(qwAddr, DCE_BINDING, RPCRT4!DCE_BINDING, ObjectUuid, ObjectUuidAddr, tmp2);

    RpcProtocolSequence = ReadProcessRpcChar( RpcProtocolSequenceAddr);
    NetworkAddress      = ReadProcessRpcChar( NetworkAddressAddr);
    Endpoint            = ReadProcessRpcChar( EndpointAddr);
    Options             = ReadProcessRpcChar( OptionsAddr);

    dprintf("\tObjectUuid:\t");
    PrintUuid(ObjectUuidAddr); dprintf("\n");
    dprintf("\tprotseq: \t\"%ws\"\t(Address: %p)\n", RpcProtocolSequence, RpcProtocolSequenceAddr);
    dprintf("\tNetworkAddress:\t\"%ws\"\t(Address: %p)\n", NetworkAddress, NetworkAddressAddr);
    dprintf("\tEndpoint:\t\"%ws\" \t(Address: %p)\n", Endpoint, EndpointAddr);
    dprintf("\tOptions:\t\"%ws\" \t(Address: %p)\n", Options, OptionsAddr);
    dprintf("\n");
}

VOID
do_osfcconn(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, Association, "pAssociation(OSF_CASSOCIATION)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CurrentCall, "CurrentCall (OSF_CCALL)\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ConnectionKey, "ConnectionKey\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, State, "State\t\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, MaxFrag, "MaxFrag\t\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ThreadId, "ThreadId\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CachedCCall, "CachedCCall\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CachedCCallAvailable, "CachedCCallAvailable\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, MaxSavedHeaderSize, "MaxSavedHeaderSize\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, SavedHeaderSize, "SavedHeaderSize\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, SavedHeader, "SavedHeader\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, AdditionalLegNeeded, "AdditionalLegNeeded\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, LastTimeUsed, "LastTimeUsed\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, TokenLength, "TokenLength\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, AdditionalSpaceForSecurity, "AdditionalSpaceForSecurity\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, fIdle, "fIdle\t\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, fExclusive, "fExclusive\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, fConnectionAborted, "fConnectionAborted\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, RefCount, "RefCount\t\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, Bindings, "&Bindings(BITSET)\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, CallQueue, "&CallQueue\t\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ConnMutex, "&ConnMutex\t\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ActiveCalls, "&ActiveCalls\t\t\t\t", tmp2);

    ULONG64 ClientSecurityContext;
    GET_ADDRESS_OF(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ClientSecurityContext, ClientSecurityContext, tmp2);
    dprintf("&ClientSecurityContext(CSECURITY_CONTEXT)- 0x%I64x\n", ClientSecurityContext);
    do_securitycontext(ClientSecurityContext);


    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ClientInfo, "ClientInfo (RPC_CONNECTION_TRANSPORT)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ComTimeout, "ComTimeout\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, u, "ConnSendContext\t\t\t\t", tmp1);


    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, DceSecurityInfo, "&DceSecurityInfo(DCE_SECURITY_INFO)\t", tmp2);

    ULONG64 DceSecurityInfo;
    GET_ADDRESS_OF(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, DceSecurityInfo, DceSecurityInfo, tmp2);
    PRINT_MEMBER_WITH_LABEL(DceSecurityInfo, _DCE_SECURITY_INFO, RPCRT4!_DCE_SECURITY_INFO, SendSequenceNumber, "     SendSequenceNumber\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(DceSecurityInfo, _DCE_SECURITY_INFO, RPCRT4!_DCE_SECURITY_INFO, ReceiveSequenceNumber, "     ReceiveSequenceNumber\t", tmp1);

    ULONG64 AssociationUuid;
    GET_ADDRESS_OF(DceSecurityInfo, _DCE_SECURITY_INFO, RPCRT4!_DCE_SECURITY_INFO, AssociationUuid, AssociationUuid, tmp2);
    dprintf("     AssociationUuid\t\t - ");
    PrintUuid(AssociationUuid);
    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, BufferToFree, "BufferToFree\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION, ConnectionReady, "ConnectionReady\t\t\t", tmp1);

    dprintf("\n");

    ULONG64 TransConnection = qwAddr;
    TransConnection += GET_TYPE_SIZE(OSF_CCONNECTION, RPCRT4!OSF_CCONNECTION);

    dprintf("TransConnection\t\t\t - 0x%I64x\n", TransConnection);

    do_trans(TransConnection);
}

struct CallStateMap {
    OSF_CCALL_STATE State;
    char *StateString;
};

struct CallStateMap CCall_States[] =
{
    NeedOpenAndBind, "NeedOpenAndBind",
    NeedAlterContext, "NeedAlterContext",
    WaitingForAlterContext, "WaitingForAlterContext",
    SendingFirstBuffer, "SendingFirstBuffer",
    SendingMoreData, "SendingMoreData",
    WaitingForReply, "WaitingForReply",
    InCallbackRequest, "InCallbackRequest",
    InCallbackReply, "InCallbackReply",
    Receiving, "Receiving",
    Aborted, "Aborted",
    Complete, "Complete",
};

char *
GetCallState (
    OSF_CCALL_STATE State
    )
{
    int i;

    for (i = 0; i < sizeof(CCall_States)/sizeof(CallStateMap); i++)
        {
        if (State == CCall_States[i].State)
            {
            return CCall_States[i].StateString;
            }
        }

    return "Unknown State";
}

VOID
do_osfccall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, AsyncStatus, "AsyncStatus\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CachedAPCInfo, "pCachedAPCInfo\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, pAsync, "pAsync\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallingThread, "CallingThread\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, NotificationIssued, "NotificationIssued\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, Connection, "Connection\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, BindingHandle, "BindingHandle\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, Bindings, "Binding\t\t\t", tmp1);

    ULONG64 CurrentState;
    GET_MEMBER(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentState, CurrentState);
    dprintf("CurrentState\t\t - 0x%x, %s\n",
            (ULONG)CurrentState, GetCallState((OSF_CCALL_STATE)CurrentState));

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentBuffer, "CurrentBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentOffset, "CurrentOffset\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CurrentBufferLength, "CurrentBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallId, "CallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, RcvBufferLength, "RcvBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, FirstSend, "FirstSend\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, DispatchTableCallback, "DispatchTableCallback\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, MaximumFragmentLength, "MaximumFragmentLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, MaxSecuritySize, "MaxSecuritySize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, MaxDataLength, "MaxDataLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, ReservedForSecurity, "ReservedForSecurity\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SecBufferLength, "SecBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, HeaderSize, "HeaderSize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SavedHeaderSize, "SavedHeaderSize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SavedHeader, "SavedHeader\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, LastBuffer, "LastBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, ProcNum, "ProcNum\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, SyncEvent, "SyncEvent\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, ActualBufferLength, "ActualBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, NeededLength, "NeededLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallSendContext, "CallSendContext\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, RefCount, "RefCount\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, RecursiveCallsKey, "RecursiveCallsKeyF\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallStack, "CallStack\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, fCallCancelled, "fCallCancelled\t\t", tmp1);

    ULONG64 CancelState;
    GET_MEMBER(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CancelState, CancelState);

    switch ((ULONG)CancelState)
        {
        case CANCEL_NOTREGISTERED:
            dprintf("fEnableCancels\t\t - CANCEL_NOTREGISTERED\n");
            break;

        case CANCEL_INFINITE:
            dprintf("fEnableCancels\t\t - CANCEL_INFINITE\n");
            break;

        case CANCEL_NOTINFINITE:
            dprintf("fEnableCancels\t\t - CANCEL_NOTINFINITE\n");
            break;
        }

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, CallMutex, "&CallMutex\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, BufferQueue, "&BufferQueue\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, InReply, "InReply\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, fChoked, "fChoked\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_CCALL, RPCRT4!OSF_CCALL, fPeerChoked, "fPeerChoked\t\t", tmp1);

    dprintf("\n");
}

VOID
do_rpcaddr(
    ULONG64 qwAddr
    )
{
    RPC_CHAR *Endpoint;
    RPC_CHAR *RpcProtocolSequence;

    ULONG64 EndpointAddr;
    ULONG64 RpcProtocolSequenceAddr;

    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    GET_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, Endpoint, EndpointAddr);
    GET_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, RpcProtocolSequence, RpcProtocolSequenceAddr);

    Endpoint            = ReadProcessRpcChar(EndpointAddr);
    RpcProtocolSequence = ReadProcessRpcChar(RpcProtocolSequenceAddr);

    if ((Endpoint == NULL) || (RpcProtocolSequence == NULL))
        return;

    dprintf("Endpoint - \"%ws\"\n", Endpoint);
    dprintf("RpcProtocolSequence - \"%ws\"\n", RpcProtocolSequence);

    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, StaticEndpointFlag, tmp1);
    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, pNetworkAddressVector, tmp1);
    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, ActiveCallCount, tmp1);

    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, EndpointFlags, tmp1);
    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, NICFlags, tmp1);

    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, Server, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, AddressMutex, "AddressMutex at", tmp2);
    PRINT_MEMBER(qwAddr, RPC_ADDRESS, RPCRT4!RPC_ADDRESS, DictKey, tmp1);

    delete Endpoint;
    delete RpcProtocolSequence;
}

VOID
do_osfaddr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 TransAddr = qwAddr;

    do_rpcaddr(qwAddr);

    dprintf("\n");

    PRINT_ADDRESS_OF(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, Associations, tmp2);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, SetupAddressOccurred, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, TransInfo, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, ServerInfo, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, ServerListeningFlag, tmp1);

    TransAddr += GET_TYPE_SIZE(OSF_ADDRESS, RPCRT4!OSF_ADDRESS);

    dprintf("\n");

    dprintf("TransAddr 0x%I64x\n", TransAddr);

    do_trans(TransAddr);
}

VOID
do_osfsconn(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    ULONG64 AuthInfo;
    GET_ADDRESS_OF(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AuthInfo, AuthInfo, tmp2);
    dprintf("&AuthInfo(CLIENT_AUTH_INFO)\t - 0x%p\n", AuthInfo);
    do_authinfo(AuthInfo );

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, Association, "Association(OSF_ASSOCIATION)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, Address, "Address(OSF_ADDRESS)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, MaxFrag, "MaxFrag\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, DataRep, "DataRep\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AuthContextId, "AuthContextId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SecurityContextAltered, "SecurityContextAltered\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, RpcSecurityBeingUsed, "RpcSecurityBeingUsed\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CurrentSecurityContext, "pCurrentSecurityContext(SSECURITY_CONTEXT)", tmp1);

    do_authinfo(tmp1);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SecurityContextDict, "&SecurityContextDict(SSECURITY_CONTEXT_DICT)", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AdditionalSpaceForSecurity, "AdditionalSpaceForSecurity\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SavedHeaderSize, "SavedHeaderSize\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, SavedHeader, "pSavedHeader(VOID)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CurrentCallId, "CurrentCallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CachedSCallAvailable, "CachedSCallAvailable\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, AuthContinueNeeded, "AuthContinueNeeded\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, InitSecurityInfo, "&InitSecurityInfo\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CallDict, "&CallDict\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, Bindings, "&Bindings(OSF_SBINDING_DICT)\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, ConnMutex, "&ConnMutex\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, CachedSCall, "CachedSCall\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, ServerInfo, "ServerInfo\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, ConnectionClosedFlag, "ConnectionClosedFlag\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, DceSecurityInfo, "&DceSecurityInfo\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, fExclusive, "fExclusive\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, fDontFlush, "fDontFlush\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION, fFirstCall, "fFirstCall\t\t\t", tmp1);

    dprintf("\n");

    ULONG64 TransConnection = qwAddr;
    TransConnection += GET_TYPE_SIZE(OSF_SCONNECTION, RPCRT4!OSF_SCONNECTION);

    dprintf("TransConnection\t\t\t - 0x%I64x\n", TransConnection);

    do_trans(TransConnection);
}

char *SCall_States[] =
{
    "NewRequest",
    "CallCancelled",
    "CallAborted",
    "CallCompleted",
    "ReceivedCallback",
    "ReceivedCallbackReply",
    "ReceivedFault"
};

VOID
do_osfscall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, AsyncStatus, "AsyncStatus\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CachedAPCInfo, "pCachedAPCInfo\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, pAsync, "pAsync\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallingThread, "CallingThread\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, NotificationIssued, "NotificationIssued\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentBinding, "CurrentBinding\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, Connection, "Connection\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, Address, "Address\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallId, "CallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallStack, "CallStack\t\t", tmp1);

    ULONG64 ObjectUuid;
    GET_ADDRESS_OF(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ObjectUuid, ObjectUuid, tmp2);
    dprintf("ObjectUuid\t\t - ");
    PrintUuid(ObjectUuid); dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ObjectUuidSpecified, "ObjectUuidSpecified\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentBuffer, "CurrentBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentBufferLength, "CurrentBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentOffset, "CurrentOffset\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstFrag, "FirstFrag\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstSend, "FirstSend\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fPipeCall, "fPipeCall\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fCallDispatched, "fCallDispatched\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, DispatchBuffer, "DispatchBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, LastBuffer, "LastBuffer\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SendContext, "SendContext\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, DispatchBufferOffset, "DispatchBufferOffset\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ProcNum, "ProcNum\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, AllocHint, "AllocHint\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SavedHeaderSize, "SavedHeaderSize\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SavedHeader, "SavedHeader\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, RcvBufferLength, "RcvBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, NeededLength, "NeededLength\t\t", tmp1);

    ULONG64 CurrentState;
    GET_MEMBER(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CurrentState, CurrentState);
    dprintf("CurrentState\t\t - 0x%x, %s\n", (ULONG)CurrentState, SCall_States[(ULONG)CurrentState]);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallMutex, "&CallMutex\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, SyncEvent, "&SyncEvent\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, BufferQueue, "&BufferQueue\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, Thread, "Thread\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CallOrphaned, "CallOrphaned\t\t", tmp1);

    ULONG64 RefCount;
    GET_MEMBER(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, RefCount, RefCount);
    dprintf("RefCount\t\t - 0x%x\n", (ULONG)RefCount);

    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, MaxSecuritySize, "MaxSecuritySize\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstCallRpcMessage, "&FirstCallRpcMessage\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, FirstCallRuntimeInfo, "&FirstCallRuntimeInfo\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, MaximumFragmentLength, "MaximumFragmentLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, ActualBufferLength, "ActualBufferLength\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fChoked, "fChoked\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fPeerChoked, "fPeerChoked\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, DispatchFlags, "DispatchFlags\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fSecurityFailure, "fSecurityFailure\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, CancelPending, "CancelPending\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_SCALL, RPCRT4!OSF_SCALL, fChoked, "fChoked\t\t\t", tmp1);

    dprintf("\n");
}

VOID
do_osfsa(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, CtxCollection, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, AssociationID, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, ConnectionCount, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, AssociationGroupId, tmp1);
    PRINT_MEMBER(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, AssociationDictKey, tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, Address, "pAddress(OSF_ADDRESS)", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, OSF_ASSOCIATION, RPCRT4!OSF_ASSOCIATION, ClientProcess, "&ClientProcess(RPC_CLIENT_PROCESS_IDENTIFIER)", tmp2);

    dprintf("\n");
}


DECLARE_API( rpcsvr )
{
    ULONG64 qwAddr;
    BOOL fArgSpecified = FALSE;
    ULONG64 ServerAddress;

    LPSTR lpArgumentString = (LPSTR)args;

    if (0 == strtok(lpArgumentString))
        {
        lpArgumentString = "rpcrt4!GlobalRpcServer";
        fArgSpecified = TRUE;
        }

    qwAddr = GetExpression(lpArgumentString);

    if ( !qwAddr )
        {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
        }

    if (fArgSpecified)
        {
        if (ReadPtr(qwAddr, &ServerAddress))
            {
            dprintf("couldn't read memory at address 0x%I64x\n", qwAddr);
            return;
            }
        }
    else
        ServerAddress = qwAddr;

    do_rpcsvr(ServerAddress);
}


VOID
do_rpcsvr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, pRpcForwardFunction, "pRpcForwardFunction(RPC_FORWARD_FUNCTION)", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, RpcInterfaceDictionary, "&RpcInterfaceDictionary(RPC_SIMPLE_DICT)", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ServerMutex, "&ServerMutex(MUTEX)", tmp2);

    GET_ADDRESS_OF(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, AvailableCallCount, tmp1, tmp2);
    PRINT_MEMBER_WITH_LABEL(tmp1, INTERLOCKED_INTEGER, RPCRT4!INTERLOCKED_INTEGER, Integer, "AvailableCallCount", tmp0);

    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ServerListeningFlag, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, RpcAddressDictionary, "&RpcAddressDictionary(RPC_SIMPLE_DICT)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ListeningThreadFlag, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, StopListeningEvent, "&StopListeningEvent(EVENT)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, MaximumConcurrentCalls, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, MinimumCallThreads, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, IncomingRpcCount, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, OutgoingRpcCount, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ReceivedPacketCount, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, SentPacketCount, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, AuthenticationDictionary, "&AuthenticationDictionary(RPC_SIMPLE_DICT)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, WaitingThreadFlag, tmp1);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ThreadCache, tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, ThreadCacheMutex, "&ThreadCacheMutex(MUTEX)", tmp2);
    PRINT_MEMBER(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, fAccountForMaxCalls, tmp1);

    dprintf("\n");
}

struct SizeTable {
    int Size;
    int Count;
};

struct SizeTable *Stats = NULL;
int MaxSize = 1048*10;
int CurrentSize = 0;

void
AddToStats (
    int Size
    )
{
    int i;

    for (i = 0; i < CurrentSize; i++)
        {
        if (Stats[i].Size == Size)
            {
            Stats[i].Count++;
            return;
            }
        }

    Stats[CurrentSize].Size = Size;
    Stats[CurrentSize].Count = 1;
    CurrentSize++;
}

int __cdecl compare( const void *arg1, const void *arg2 )
{
   return  ((struct SizeTable *) arg2)->Count - ((struct SizeTable *) arg1)->Count;
}

void
PrintStats (
    )
{
    int i;
    int Total = 0;

    qsort(&Stats[0], CurrentSize, sizeof(SizeTable), compare);

    dprintf("\n\nSummary:\n");
    for (i = 0; i < CurrentSize; i++)
        {
        dprintf("Size: %08x Count: %d\n",
                Stats[i].Size,
                Stats[i].Count
                );
        Total += Stats[i].Count;
        }

    dprintf("Total Count: %d\n", Total);
}

VOID
do_rpcmem(
    ULONG64 qwAddr,
    long Count,
    long Verbose,
    BOOL Summary,
    long Size
    )
{
    BOOL b;
    BOOL forwards = TRUE;
    BOOL doAll    = FALSE;
    DWORD t;

    ULONG64 tmp1;
    ULONG tmp2;

    unsigned Data[16];

    unsigned char RearGuardBlock[4];

#if DBG
    if (Count < 0) {
        forwards = FALSE;
    }
    else
    if (Count == 0) {
        doAll = TRUE;
    }

    if (Stats == NULL)
        {
        Stats = (struct SizeTable *) RpcpFarAllocate(MaxSize * sizeof(struct SizeTable));
        if (Stats == NULL)
            {
            return;
            }
        }

    RpcpMemorySet(Stats, 0, MaxSize);

    dprintf("\n");

    do
        {
        if ((CheckControlC)())
            {
            return;
            }

        ULONG64 size;
        GET_MEMBER(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, size, size);

        AddToStats((int)size);

        if ((Size == 0 || Size == (long) size) && !Summary)
            {
            ULONG64 rearguard;
            GET_ADDRESS_OF(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, rearguard, rearguard, tmp2);

            dprintf("-------- size (%08x) block: 0x%I64x contains: %s",
                (ULONG)size,
                qwAddr,
                SymbolAtAddressNoOffset(rearguard)
                );

            if (Verbose)
                {
                b = GetData(rearguard,
                        Data,
                        min((ULONG)size, sizeof(Data)));
                if ( !b )
                    {
                    dprintf("can't read block data at 0x%I64x\n", rearguard);
                    return;
                    }

                for (t = 0; t < min(((ULONG)size)/4, sizeof(Data)/4); t++)
                    {
                    if (t % 4 == 0)
                        {
                        dprintf("\n%I64p  ",
                                rearguard + t*4);
                        }
                    dprintf("%I64p ", Data[t]);
                    }
                }
            dprintf("\n");

            }

        ULONG64 frontguardAddr;
        ULONG64 rearguardAddr;
        GET_ADDRESS_OF(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, frontguard, frontguardAddr, tmp2);
        GET_ADDRESS_OF(qwAddr+size, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, rearguard, rearguardAddr, tmp2);
        unsigned char frontguardVal[4];
        unsigned char rearguardVal[4];
        GetData(frontguardAddr, frontguardVal, sizeof(frontguardVal));
        GetData(rearguardAddr, rearguardVal, sizeof(rearguardVal));

        if ( (frontguardVal[0] != RPC_GUARD) ||
             (frontguardVal[1] != RPC_GUARD) ||
             (frontguardVal[2] != RPC_GUARD) ||
             (frontguardVal[3] != RPC_GUARD) )
            {
            dprintf("     RPC: BAD FRONTGUARD %x-%x-%x-%x\n", frontguardVal[0], frontguardVal[1], frontguardVal[2], frontguardVal[3]);
            }

        if ( (rearguardVal[0] != RPC_GUARD) ||
             (rearguardVal[1] != RPC_GUARD) ||
             (rearguardVal[2] != RPC_GUARD) ||
             (rearguardVal[3] != RPC_GUARD) )
            {
            dprintf("     RPC: BAD REARGUARD %x-%x-%x-%x\n", rearguardVal[0], rearguardVal[1], rearguardVal[2], rearguardVal[3]);
            }

        ULONG64 next;
        ULONG64 previous;
        GET_MEMBER(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, next, next);
        GET_MEMBER(qwAddr, RPC_MEMORY_BLOCK, RPCRT4!RPC_MEMORY_BLOCK, previous, previous);

        if (forwards == TRUE)
            {
            qwAddr =  next;
            Count--;
            }
        else
            {
            qwAddr =  previous;
            Count++;
            }

        }
    while (qwAddr && (Count || doAll) );

    PrintStats();

#endif
    dprintf("\n");
}

VOID
do_rpcmsg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, Handle, "Handle(RPC_BINDING_HANDLE)            ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, DataRepresentation, "DataRepresentation                    ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, Buffer, "pBuffer(void)                         ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, BufferLength, "BufferLength                          ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ProcNum, "ProcNum                               ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, TransferSyntax, "TransferSyntax(RPC_SYNTAX_IDENTIFIER) ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, RpcInterfaceInformation, "pRpcInterfaceInformation(void)        ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ReservedForRuntime, "pReservedForRuntime(void)             ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ManagerEpv, "pManagerEpv(RPC_MGR_EPV)              ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, ImportContext, "pImportContext(void)                  ", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_MESSAGE, RPCRT4!RPC_MESSAGE, RpcFlags, "RpcFlags                              ", tmp1);

    dprintf("\n");
}

VOID
do_transinfo(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;
    ULONG64 LoadableTrans;

    GET_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, LoadableTrans, LoadableTrans);

    dprintf("\n");

    PRINT_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, pTransportInterface, tmp1);
    PRINT_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, LoadableTrans, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, ThreadsStarted, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, NumThreads, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, ProcessCallsFunc, tmp1);
    PRINT_MEMBER(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, LoadedDll, tmp1);
    PRINT_ADDRESS_OF(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, ProtseqDict, tmp2);
    PRINT_ADDRESS_OF(LoadableTrans, LOADABLE_TRANSPORT, RPCRT4!LOADABLE_TRANSPORT, DllName, tmp2);
    PRINT_MEMBER(qwAddr, TRANS_INFO, RPCRT4!TRANS_INFO, RpcProtocolSequence, tmp1);

    dprintf("\n");
}

DECLARE_API( help )
{
    LPSTR lpArgumentString = (LPSTR)args;

    if (lpArgumentString[0] == '\0') {
        dprintf( "\n");
        dprintf( "rpcdbg help:\n\n");
        dprintf( "\n");
        dprintf( "!obj      <address>  - Dumps an RPC object \n");
        dprintf( "\n");
        dprintf( "!sizes - Prints sizes of the data structures\n");
        dprintf( "!error - Translates and error value into the error message\n");
        dprintf( "!symbol    (<address>|<symbol name>) - Returns symbol name/address\n");
        dprintf( "!rpcheap [-a <address>][-d <num display>] - Dumps RPC_MEMORY_BLOCK linked list\n");
        dprintf( "\n");
        dprintf( "!pasync     <address>  - Dumps RPC_ASYNC_STATE\n");
        dprintf( "!rpcmsg     <address>  - Dumps RPC_MESSAGE\n");
        dprintf( "!stubmsg    <address>  - Dumps MIDL_STUB_MESSAGE\n");
        dprintf( "!authinfo    <address> - Dumps CLIENT_AUTH_INFO\n");
        dprintf( "!rpcsvr    <address>   - Dumps RPC_SERVER \n");
        dprintf( "!secinfo               - Dumps security provider/package info\n");
        dprintf( "!dict      <address>   - Dumps SDICT \n");
        dprintf( "!dict2     <address>   - Dumps SDICT2 \n");
        dprintf( "!queue     <address>   - Dumps QUEUE \n");
        dprintf( "!thread     <teb>      - Dumps THREAD \n");
        dprintf( "!copacket  <address>   - Dumps CO packet \n");
        dprintf( "!lpcpacket  <address>   - Dumps LRPC packet \n");
        dprintf( "!transinfo  <address>   - Dumps TRANS_INFO \n");
        dprintf( "\n");
        dprintf( "!scan       [options]  - Dumps the event log, add '-?' for help\n");
        dprintf( "!dgcc       <address>  - Dumps DG_CCALL \n");
        dprintf( "!dgsc       <address>  - Dumps DG_SCALL \n");
        dprintf( "!dgpe       <address>  - Dumps DG_PACKET_ENGINE\n");
        dprintf( "!dgpkt      <address>  - Dumps DG_PACKET \n");
        dprintf( "!dgpkthdr   <address>  - Dumps dg packet header (NCA_PACKET_HEADER)\n");
        dprintf( "!dgep       <address>  - Dumps DG_ENDPOINT \n");
        dprintf( "\n");
        dprintf( "!asyncmsg   <address>  - Dumps NDR_ASYNC_MESSAGE\n");
        dprintf( "!asyncrpc   <address>  - Dumps RPC_ASYNC_STATE\n");
        dprintf( "!asyncdcom  <address>  - Dumps CAsyncManager\n");
        dprintf( "\n");
        dprintf( "!pipemsg    <address>  - Dumps NDR_PIPE_MESSAGE\n");
        dprintf( "!pipedesc   <address>  - Dumps NDR_PIPE_DESC\n");
        dprintf( "!pipestate  <address>  - Dumps NDR_PIPE_STATE\n");
        dprintf( "\n");
        dprintf( "!trans      <address>  - Dumps most NT RPC transport objects\n");
        dprintf( "!overlap    <address>  - Dumps object associated with OVERLAPPED pointer\n");
        dprintf( "!wsaddr     <address>  - Dumps sockaddr structure\n");
        dprintf( "!protocols  <address>  - Dumps PnP protocols map & related objects\n");
        dprintf( "\n");
       dprintf( "!rpcsleep   <interval> - Pauses the extension\n");
        dprintf( "!rpctime               - Displays current system time\n");
        dprintf( "!getcallinfo [options] - Searches the system for call info, add '-?' for help\n");
        dprintf( "!getendpointinfo [options] - Searches the system for endpoint info, add '-?' for help\n");
        dprintf( "!getdbgcell  <processID> <cellID1>.<cellID2> - Gets info for the specified cell\n");
        dprintf( "!getthreadinfo [options] - Searches the system for thread info, add '-?' for help\n");
        dprintf( "!getclientcallinfo [options] - Searches the system for client call info, add '-?' for help\n");
        dprintf( "!checkrpcsym - Checks whether RPC symbols are correct\n");
        dprintf( "!rpcreadstack - Reads an RPC client side stack and retrieves the call info\n");
        dprintf( "!rpcverbosestack - toggles the state of the verbose spew when reading the stack\n");
        dprintf( "!eerecord - prints an extended error info record\n");
        dprintf( "!eeinfo - prints the extended error info chain\n");
        dprintf( "!typeinfo - turns on/off the use of type information\n");
        dprintf( "!stackmatch start_addr [depth] matches stack symbols and target addresses\n");
        dprintf( "!listcalls <address>  - Dumps addresses, associations, and calls active within the RPC_SERVER at address\n\n");
    }
}

void do_symbol(ULONG64 qwAddr)
{
    CHAR Symbol[128];
    ULONG64 Displacement = 0;

    GetSymbol(qwAddr, Symbol, &Displacement);

    dprintf("%I64x %s+%I64x\n", qwAddr, Symbol, Displacement);
}

DECLARE_API( symbol )
{
    ULONG64 qwAddr;
    LPSTR lpArgumentString = (LPSTR)args;

    qwAddr = GetExpression(lpArgumentString);
    if ( !qwAddr )
        {
        return;
        }
    do_symbol(qwAddr);
}

#define MAX_ARGS 4

DECLARE_API( rpcheap )
{
    ULONG64  qwAddr      = 0;
    ULONG64  dwTmpAddr   = 0;
    long   lDisplay    = 0;
    long   lVerbose    = 1;
    BOOL Summary = 0;
    char   **argv      = new char*[MAX_ARGS];
    int    argc        = 0;
    int    i;
    long lSize = 0;

    CurrentSize = 0;

    LPSTR lpArgumentString = (LPSTR)args;

    //#ifdef DEBUGRPC
    for (i = 0; ; ) {
        while (lpArgumentString[i] == ' ') {
            lpArgumentString[i] = '\0';
            i++;
        }
        if (lpArgumentString[i] == '\0') {
            break;
        }
        argv[argc] = &(lpArgumentString[i]);
        argc++;
        if (argc > MAX_ARGS) {
            dprintf("\nToo many arguments. Extra args ignored.\n\n");
            break;
        }
        while ((lpArgumentString[i] != ' ')&&
               (lpArgumentString[i] != '\0')) {
              i++;
        }
    }
    for (i = 0; i < argc; i++) {
        if ((*argv[i] == '-') || (*argv[i] == '/') || (*argv[i] == '+')) {
            switch (*(argv[i]+1)) {
                case 'A':
                case 'a':
                    qwAddr = GetExpression(argv[++i]);
                    if (!qwAddr) {
                        dprintf("Error: Failure to get address of RPC memory list\n");
                        return;
                    }
                    break;
                case 'D':
                case 'd':
                    lDisplay = (long)myatol(argv[++i]);
                    break;
                case 's':
                    Summary = 1;
                    break;

                case 'z':
                    lSize = (long) GetExpression(argv[++i]);
                    break;

                case 'q':
                case 'Q':
                    lVerbose = FALSE;
                    break;
                case '?':
                default:
                    dprintf("rpcheap \n");
                    dprintf("     -a <address> (default:starts at head of linked list)\n");
                    dprintf("     -d <number of mem blks to display> (default: to end)\n");
                    break;
            }
        }
        else {
            dprintf("rpcheap \n");
            dprintf("     -a <address> (default:starts at head of linked list)\n");
            dprintf("     -d <number of mem blks to display> (default: to end)\n");
        }
    }

    if (!qwAddr) {
        dwTmpAddr = GetExpression("rpcrt4!AllocatedBlocks");
        ReadPtr(dwTmpAddr, &qwAddr);
        dprintf("Address of AllocatedBlocks - 0x%I64x\n", dwTmpAddr);
        dprintf("Contents of AllocatedBlocks - 0x%I64x\n", qwAddr);
    }
    do_rpcmem(qwAddr, lDisplay, lVerbose, Summary, lSize);
    //#else  // DEBUGRPC
    //dprintf("This extension command is not supported on a free build!\n");
    //#endif // DEBUGRPC
    if (argv) {
        delete[] argv;
    }
    return;
}

VOID
do_lpcaddr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_rpcaddr( qwAddr );

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, LpcAddressPort, "LpcAddressPort(HANDLE)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, CallThreadCount, "CallThreadCount\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, MinimumCallThreads, "MinimumCallThreads\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, AssociationDictionary, "&Associations(LRPC_ASSOCIATION_DICT)", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, AssociationCount, "AssociationCount\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, ServerListeningFlag, "ServerListeningFlag\t\t", tmp1);

    dprintf("\n");
    }


VOID
do_lpcsa(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, AssociationReferenceCount, "AssociationReferenceCount\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, DictionaryKey, "DictionaryKey\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, LpcServerPort, "LpcServerPort(HANDLE)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, LpcReplyPort, "LpcReplyPort\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Address, "Address\t\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Bindings, "&Bindings(LRPC_SBINDING_DICT)\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Aborted, "Aborted\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Deleted, "Deleted\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, SequenceNumber, "SequenceNumber\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, CachedSCall, "CachedSCall\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, CachedSCallAvailable, "CachedSCallAvailable\t\t", tmp1);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, Buffers, "&Buffers(LRPC_CLIENT_BUFFER_DICT)", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, AssociationMutex, "&AssociationMutex\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, FreeSCallQueue, "&FreeSCallQueue\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, ClientThreadDict, "&ClientThreadDict\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, SContextDict, "&SContextDict\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SASSOCIATION, RPCRT4!LRPC_SASSOCIATION, SCallDict, "&SCallDict\t\t\t", tmp2);

    dprintf("\n");
}

VOID
do_lpcscall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, AsyncStatus, "AsyncStatus\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CachedAPCInfo, "pCachedAPCInfo\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, pAsync, "pAsync\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CallingThread, "CallingThread\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, NotificationIssued, "NotificationIssued\t\t", tmp1);

    ULONG64 AuthInfo;
    GET_ADDRESS_OF(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, AuthInfo, AuthInfo, tmp2);
    dprintf("&ClientAuthInfo\t\t\t - 0x%I64x\n", AuthInfo);
    do_authinfo(AuthInfo );

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ActiveContextHandles, "&ActiveContextHandles(ServerContextHandle_DICT)\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, DispatchBuffer, "DispatchBuffer\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Association, "pAssociation(LRPC_ASSOCIATION)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, LrpcRequestMessage, "pLrpcMessage(LRPC_MESSAGE)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, LrpcReplyMessage, "pLrpcReplyMessage(LRPC_MESSAGE)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, SBinding, "pSBinding(LRPC_SBINDING)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ObjectUuidFlag, "ObjectUuidFlag\t\t\t", tmp1);


    ULONG64 ObjectUuid;
    GET_ADDRESS_OF(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ObjectUuid, ObjectUuid, tmp2);
    dprintf("ObjectUuid\t\t\t - ");
    PrintUuid(ObjectUuid); dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CallId, "CallId\t\t\t\t", tmp1);

    ULONG64 ClientId;
    GET_ADDRESS_OF(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ClientId, ClientId, tmp2);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueProcess, "ClientId.UniqueProcess(CLIENT_ID.HANDLE)", tmp1);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueThread, "ClientId.UniqueThread (CLIENT_ID.HANDLE)", tmp1);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, MessageId, "MessageId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, PushedResponse, "pPushedResponse(VOID)\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CurrentBufferLength, "CurrentBuffferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, BufferComplete, "BufferComplete\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Flags, "Flags\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, FirstSend, "FirstSend\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, PipeSendCalled, "PipeSendCalled\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Deleted, "Deleted\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, ReceiveEvent, "ReceiveEvent\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CallMutex, "CallMutex\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, RcvBufferLength, "RcvBufferLength\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, AsyncReply, "AsyncReply\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, NextSCall, "NextSCall\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, NeededLength, "NeededLength\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, fSyncDispatch, "fSyncDispatch\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, Choked, "Choked\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, CancelPending, "CancelPending\t\t\t", tmp1);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, RefCount, "RefCount\t\t\t", tmp1);

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, BufferQueue, "&BufferQueue\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_SCALL, RPCRT4!LRPC_SCALL, SContext, "SContext\t\t\t", tmp1);

    dprintf("\n");
}

VOID
do_lpcbh(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG tmp1;

    do_bh(qwAddr);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, CurrentAssociation, "pCurrentAssociation(LRPC_CASSOCIATION)", tmp0);
    PRINT_ADDRESS_OF(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, SecAssociation, tmp1);
    PRINT_MEMBER(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, DceBinding, tmp0);

    GET_ADDRESS_OF(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, DceBinding, tmp0, tmp1);
    do_dcebinding(tmp0);

    PRINT_MEMBER(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, BindingReferenceCount, tmp0);
    PRINT_ADDRESS_OF(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, RecursiveCalls, tmp1);
    PRINT_MEMBER(qwAddr, LRPC_BINDING_HANDLE, RPCRT4!LRPC_BINDING_HANDLE, AuthInfoInitialized, tmp0);
}

VOID
do_lpcca(
    ULONG64 qwAddr
    )
{
    dprintf("\n");

    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 DceBinding;
    GET_MEMBER(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, DceBinding, DceBinding);
    dprintf("pDceBinding(DCE_BINDING)\t- 0x%I64x\n", DceBinding);
    do_dcebinding(DceBinding);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, AssociationDictKey, "AssociationDictKey\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, Bindings, "&Bindings(LRPC_BINDING_DICT)\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, FreeCCalls, "&FreeCCalls\t\t\t", tmp2);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, ActiveCCalls, "&ActiveCCalls\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, LpcClientPort, "LpcClientPort\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, LpcReceivePort, "LpcReceivePort\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, AssociationMutex, "&AssociationMutex(MUTEX)\t", tmp2);

    ULONG64 AssocAuthInfo;
    GET_ADDRESS_OF(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, AssocAuthInfo, AssocAuthInfo, tmp2);
    do_authinfo(AssocAuthInfo);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, BackConnectionCreated, "BackConnectionCreated\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, CachedCCall, "pCachedCCall(LRPC_CCALL)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, CachedCCallFlag, "CachedCCallFlag\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, CallIdCounter, "CallIdCounter\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, SequenceNumber, "SequenceNumber\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, SecurityContextDict, "&SecurityContextDict\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, LastSecContextTrimmingTimestamp, "Timestamp\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CASSOCIATION, RPCRT4!LRPC_CASSOCIATION, BindingHandleReferenceCount, "BindingHAndleReferenceCount\t", tmp1);

    dprintf("\n");
}

VOID
do_lpcccall(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, AsyncStatus, "AsyncStatus\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CachedAPCInfo, "pCachedAPCInfo\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CachedAPCInfoAvailable, "CachedAPCInfoAvailable\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, pAsync, "pAsync\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallingThread, "CallingThread\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, NotificationIssued, "NotificationIssued\t\t", tmp1);

    ULONG64 AuthInfo; 
    GET_ADDRESS_OF(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, AuthInfo, AuthInfo, tmp2);
    dprintf("AuthInfo\t\t\t- 0x%I64x\n", AuthInfo);
    do_authinfo(AuthInfo);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CurrentBindingHandle, "pCurrentBindingHandle(LRPC_BINDING_HANDLE)", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Association, "pAssociation(LRPC_CASSOCIATION)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, LrpcMessage, "pLrpcMessage(LRPC_MESSAGE)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RpcReplyMessage, "RpcReplyMessage\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, LpcReplyMessage, "LpcReplyMessage\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RcvBufferLength, "RcvBufferLength\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Choked, "Choked\t\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RecursiveCallsKey, "RecursiveCallsKey\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, FreeCallKey, "FreeCallKey\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallId, "CallId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, MessageId, "MessageId\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallbackId, "CallbackId\t\t\t", tmp1);

    ULONG64 ClientId;
    GET_ADDRESS_OF(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, ClientId, ClientId, tmp2);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueProcess, "ClientId.UniqueProcess(CLIENT_ID.HANDLE)", tmp1);
    PRINT_MEMBER_WITH_LABEL(ClientId, CLIENT_ID, RPCRT4!CLIENT_ID, UniqueThread, "ClientId.UniqueThread (CLIENT_ID.HANDLE)", tmp1);

    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, DataInfoOffset, "DataInfoOffset\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallAbortedFlag, "CallAbortedFlag\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Thread, "Thread(THREAD_IDENTIFIER)\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, Binding, "Binding(LRPC_BINDING)", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, RecursionCount, "RecursionCount\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, SyncEvent, "SyncEvent\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, MsgFlags, "MsgFlags\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallMutex, "CallMutex\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CallStack, "CallStack\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CachedLrpcMessage, "CachedLrpcMessage\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, FirstFrag, "FirstFrag\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CurrentBufferLength, "CurrentBufferLength\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, NeededLength, "NeededLength\t\t\t", tmp1);
    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, BufferQueue, "BufferQueue\t\t\t", tmp2);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, fSendComplete, "fSendcomplete\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, CurrentSecurityContext, "CurrentSecurityContext\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, LRPC_CCALL, RPCRT4!LRPC_CCALL, EEInfo, "Extended Error Info\t\t", tmp1);

    dprintf("\n");
}


VOID
do_pasync(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Size, "Size\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Signature, "Signature\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Lock, "Lock\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Flags, "Flags\t\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, StubInfo, "StubInfo\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, UserInfo, "UserInfo\t\t", tmp1);
    PRINT_MEMBER_WITH_LABEL(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, RuntimeInfo, "RuntimeInfo\t\t", tmp1);

    ULONG64 Event;
    GET_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Event, Event);
    dprintf("Event\t\t\t - ");
    switch ((ULONG)Event)
        {
        case RpcCallComplete:
            dprintf("RpcCallComplete\n");
            break;
        case RpcSendComplete:
            dprintf("RpcSendComplete\n");
            break;
        case RpcReceiveComplete:
            dprintf("RpcReceiveComplete\n");
            break;
        default:
            dprintf("(unknown) 0x%I64x\n", Event);
            break;
        }

    ULONG64 NotificationType;
    GET_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, NotificationType, NotificationType);
    dprintf("NotificationType\t - ");

    BOOL b;
    char block[sizeof(RPC_ASYNC_STATE)];
    PRPC_ASYNC_STATE pa = (PRPC_ASYNC_STATE)&block;

    if (!fUseTypeInfo) {
        b = GetData(qwAddr, &block, sizeof(RPC_ASYNC_STATE));
        if ( !b ) {
            dprintf("can't read %p\n", qwAddr);
            return;
        }
    }

    switch ((ULONG)NotificationType)
        {
        case RpcNotificationTypeNone:
            dprintf("RpcNotificationTypeNone\n");
            break;

        case RpcNotificationTypeEvent:
            dprintf("RpcNotificationTypeEvent\n");

            if (!fUseTypeInfo)
                dprintf("\thEvent\t\t - 0x%p\n", pa->u.hEvent);
            break;

        case RpcNotificationTypeApc:
            dprintf("RpcNotificationTypeApc\n");

            if (!fUseTypeInfo) {
                dprintf("\tNotificationRoutine\t - 0x%p\n", pa->u.APC.NotificationRoutine);
                dprintf("\thThread\t\t\t - 0x%p\n", pa->u.APC.hThread);
            }
            break;

        case RpcNotificationTypeIoc:
            dprintf("RpcNotificationTypeIoc\n");

            if (!fUseTypeInfo) {
                dprintf("\thIOPort\t\t\t - 0x%p\n", pa->u.IOC.hIOPort);
                dprintf("\tdwNumberOfBytesTransferred - 0x%x\n",
                        pa->u.IOC.dwNumberOfBytesTransferred);
                dprintf("\tdwCompletionKey\t\t - 0x%p\n", pa->u.IOC.dwCompletionKey);
                dprintf("\tlpOverlapped\t\t - 0x%x\n", pa->u.IOC.lpOverlapped);
            }
            break;

        case RpcNotificationTypeHwnd:
            dprintf("RpcNotificationTypeHwnd\n");

            if (!fUseTypeInfo) {
                dprintf("\thWnd\t\t - 0x%p\n", pa->u.HWND.hWnd);
                dprintf("\tMsg\t\t - 0x%x\n", pa->u.HWND.Msg);
            }
            break;

        case RpcNotificationTypeCallback:
            dprintf("RpcNotificationTypeCallback\n");

            if (!fUseTypeInfo) {
                dprintf("NotificationRoutine\t - 0x%p\n", pa->u.NotificationRoutine);
            }
            break;

        default:
            dprintf("Bad notification type\n");
        }

    dprintf("\n");
}

char *
ReceiveStates[] =
{
    "START",
    "COPY_PIPE_ELEM",
    "RETURN_PARTIAL",
    "READ_PARTIAL"
};

void
do_stubmsg(
    ULONG64 msg
    )
{
    ULONG64 tmp0;

    dprintf("MIDL_STUB_MESSAGE at 0x%I64x\n\n", msg);

    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, Buffer, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferStart, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferEnd, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferMark, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, MemorySize, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, Memory, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, BufferLength, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pAllocAllNodesContext, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, RpcMsg, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, SavedHandle, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, StubDesc, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, IsClient, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, ReuseBuffer, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, IgnoreEmbeddedPointers, tmp0);
    PRINT_MEMBER_BOOLEAN(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, fBufferValid, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, MaxCount, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, ActualCount, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, Offset, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, StackTop, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pPresentedType, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pTransmitType, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pRpcChannelBuffer, tmp0);
    PRINT_MEMBER(msg, MIDL_STUB_MESSAGE, RPCRT4!MIDL_STUB_MESSAGE, pAsyncMsg, tmp0);
}

VOID
do_dgaddr(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG tmp1;

    dprintf("DG_ADDRESS at 0x%I64x\n\n", qwAddr);

    do_rpcaddr(qwAddr);

    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, TransInfo, tmp0);
    PRINT_MEMBER_SYMBOL(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, TransInfo, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, ActiveCallCount, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, CachedConnections, tmp0);

    dprintf("\nendpoint data:\n");

    GET_ADDRESS_OF(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, Endpoint, tmp0, tmp1);
    do_dgep(tmp0);

    dprintf("\nobsolete data:\n");

    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, TotalThreadsThisEndpoint, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, ThreadsReceivingThisEndpoint, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, MinimumCallThreads, tmp0);
    PRINT_MEMBER(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, MaximumConcurrentCalls, tmp0);
    PRINT_ADDRESS_OF(qwAddr, DG_ADDRESS, RPCRT4!DG_ADDRESS, ScavengerTimer, tmp1);
}

VOID
do_dgbh(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_bh(qwAddr);

    dprintf("DCE_BINDING:\n");
    ULONG64 pDceBinding;
    GET_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, pDceBinding, pDceBinding);
    do_dcebinding(pDceBinding);

    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, EndpointFlags, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, Association, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, ReferenceCount, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, fDynamicEndpoint, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, fContextHandle, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, TransportObject, tmp1);
    PRINT_MEMBER(qwAddr, DG_BINDING_HANDLE, RPCRT4!DG_BINDING_HANDLE, TransportInterface, tmp1);
}

VOID
do_dgpe(
    ULONG64 qwAddr
    )
{
    DG_PACKET_ENGINE *dgpe;
    char block[sizeof(DG_PACKET_ENGINE)];
    dgpe = (DG_PACKET_ENGINE *) block;

    ULONG64 tmp1;
    ULONG tmp;

    if (!fUseTypeInfo) {
        GetData(qwAddr, &block, sizeof(DG_PACKET_ENGINE));
    }

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SequenceNumber, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, PacketType,tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ActivityHint, tmp1);

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, TimeoutCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, CurrentPduSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, MaxFragmentSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SecurityTrailerSize, tmp1);

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, pSavedPacket, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SourceEndpoint, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, RemoteAddress, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, BaseConnection, tmp1);

    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, pReceivedPackets, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ReceiveFragmentBase, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, LastReceiveBuffer, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, pLastConsecutivePacket, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, LastReceiveBufferLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, ConsecutiveDataBytes, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, fReceivedAllFragments, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, Buffer, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowBase, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FinalSendFrag, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, BufferLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowBits, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FackSerialNumber, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, BufferFlags,tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, fRetransmitted, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FirstUnsentOffset, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendBurstLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, QueuedBufferHead, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, FirstUnsentFragment, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, QueuedBufferTail, tmp1);
    PRINT_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, RingBufferBase, tmp1);

    if (!fUseTypeInfo) {
        dprintf("  Frag  Offset    Length  Serial # |  Frag  Offset    Length  Serial #\n"
            "  ----  --------  ------  -------- |  ----  --------  ------  --------\n"
            );
    }

    ULONG64 RingBufferBase;
    ULONG64 SendWindowBase;
    GET_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, RingBufferBase, RingBufferBase);
    GET_MEMBER(qwAddr, DG_PACKET_ENGINE, RPCRT4!DG_PACKET_ENGINE, SendWindowBase, SendWindowBase);

    unsigned short i;
    for (i=1; i <= MAX_WINDOW_SIZE/2; ++i)
        {
        unsigned Index1 = (i + (ULONG)RingBufferBase) % MAX_WINDOW_SIZE;
        unsigned Frag1 = (ULONG)SendWindowBase+i;

        if (Frag1 >= MAX_WINDOW_SIZE)
            {
            Frag1 -= MAX_WINDOW_SIZE;
            }

        if (!fUseTypeInfo) {
            dprintf("  %4x: %8lx  %5hx     %4hx   |",
                    Frag1,
                    dgpe->FragmentRingBuffer[Index1].Offset,
                    dgpe->FragmentRingBuffer[Index1].Length,
                    dgpe->FragmentRingBuffer[Index1].SerialNumber
                    );
        }

        unsigned Index2 = (i+MAX_WINDOW_SIZE/2 + (ULONG)RingBufferBase) % MAX_WINDOW_SIZE;
        unsigned Frag2 = (ULONG)SendWindowBase+i+MAX_WINDOW_SIZE/2;

        if (Frag2 >= MAX_WINDOW_SIZE)
            {
            Frag2 -= MAX_WINDOW_SIZE;
            }

        if (!fUseTypeInfo) {
            dprintf("  %4x: %8lx  %5hx     %4hx   \n",
                    Frag2,
                    dgpe->FragmentRingBuffer[Index2].Offset,
                    dgpe->FragmentRingBuffer[Index2].Length,
                    dgpe->FragmentRingBuffer[Index2].SerialNumber
                    );
        }
    }
    dprintf("\n");
}

char *
ClientState(
    DG_CCALL::DG_CLIENT_STATE State
    )
{
    switch (State)
        {
        case DG_CCALL::CallInit:          return "init";
        case DG_CCALL::CallQuiescent:     return "quiescent";
        case DG_CCALL::CallSend:          return "sending";
        case DG_CCALL::CallSendReceive:   return "sendreceive";
        case DG_CCALL::CallReceive:       return "receiving";
        case DG_CCALL::CallCancellingSend:return "cancel send";
        case DG_CCALL::CallComplete:      return "complete";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", State);
            return scratch;
            }
        }
}

char *
ServerState(
    DG_SCALL::CALL_STATE State
    )
{
    switch (State)
        {
        case DG_SCALL::CallInit:            return "init";
        case DG_SCALL::CallBeforeDispatch:  return "receiving";
        case DG_SCALL::CallDispatched:      return "dispatched";
        case DG_SCALL::CallAfterDispatch:   return "after stub";
        case DG_SCALL::CallSendingResponse: return "sending";
        case DG_SCALL::CallComplete:        return "complete";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", State);
            return scratch;
            }
        }
}

char *
PipeOp(
    PENDING_OPERATION Op
    )
{
    switch (Op)
        {
        case PWT_NONE:          return "none";
        case PWT_RECEIVE:       return "receive";
        case PWT_SEND:          return "send";
        case PWT_SEND_RECEIVE:  return "send/recv";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", Op);
            return scratch;
            }
        }
}

VOID
do_dgcc(
    ULONG64 dgcc
    )
{
    ULONG64 State, PreviousState;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    GET_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, State, State);
    GET_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, PreviousState, PreviousState);

    dprintf("state %-14s  prev  %-14s\n\n",
            ClientState((DG_CCALL::DG_CLIENT_STATE)State),
            ClientState((DG_CCALL::DG_CLIENT_STATE)PreviousState));

    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, TimeStamp, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, TimeoutLimit, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, LastReceiveTime, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, AsyncStatus, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, CancelTime, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, EEInfo, tmp1);

    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, ReceiveTimeout, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, WorkingCount, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, UnansweredRequestCount, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, PipeReceiveSize, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, Previous, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, Next, tmp1);
    PRINT_MEMBER(dgcc, DG_CCALL, RPCRT4!DG_CCALL, pAsync, tmp1);

    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, StaticArgsSent, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, DelayedSendPending, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, AllArgsSent, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, LastSendTimedOut, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, CancelComplete, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, ForceAck, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, CancelPending, tmp1);
    PRINT_MEMBER_BOOLEAN(dgcc, DG_CCALL, RPCRT4!DG_CCALL, AutoReconnectOk, tmp1);

    dprintf("\n");

    ULONG64 ActivityHint;
    GET_ADDRESS_OF(dgcc, DG_CCALL, RPCRT4!DG_CCALL, ActivityHint, ActivityHint, tmp2);

    do_dgpe(ActivityHint-AddressSize);
}

VOID
do_dgep(
        ULONG64 ep
        )
{
    ULONG64 tmp0;
    ULONG tmp1;
    ULONG64 Stats;

    PRINT_MEMBER_BOOLEAN(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, Async, tmp0);
    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, TimeStamp, tmp0);
    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, Next, tmp0);
    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, NumberOfCalls, tmp0);

    PRINT_MEMBER(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, TransportInterface, tmp0);
    PRINT_MEMBER_SYMBOL(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, TransportInterface, tmp0);

    GET_ADDRESS_OF(ep, DG_ENDPOINT, RPCRT4!DG_ENDPOINT, Stats, Stats, tmp1);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, PreferredPduSize, tmp0);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, MaxPduSize, tmp0);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, MaxPacketSize, tmp0);
    PRINT_MEMBER(Stats, DG_ENDPOINT_STATS, RPCRT4!DG_ENDPOINT_STATS, ReceiveBufferSize, tmp0);
}

VOID
do_dgccn(
         ULONG64 qwAddr
         )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\nbase:\n");

    ULONG64 ActivityNode;
    GET_ADDRESS_OF(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, ActivityNode, ActivityNode, tmp2);

    ULONG64 Uuid;
    ULONG64 pPrev, pNext;
    GET_ADDRESS_OF(ActivityNode, UUID_HASH_TABLE_NODE, RPCRT4!UUID_HASH_TABLE_NODE, Uuid, Uuid, tmp2);
    GET_MEMBER(ActivityNode, UUID_HASH_TABLE_NODE, RPCRT4!UUID_HASH_TABLE_NODE, pPrev, pPrev);
    GET_MEMBER(ActivityNode, UUID_HASH_TABLE_NODE, RPCRT4!UUID_HASH_TABLE_NODE, pNext, pNext);

    dprintf("  activity ID "); PrintUuid(Uuid);
    dprintf("  next %I64x prev %I64x\n", pNext, pPrev );

    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, TimeStamp, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, TransportInterface, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, ActiveSecurityContext, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, TransportInterface, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, LowestActiveSequence, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, LowestUnusedSequence, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, CurrentPduSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_COMMON_CONNECTION, RPCRT4!DG_COMMON_CONNECTION, RemoteWindowSize, tmp1);
}

VOID
do_dgcn(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_dgccn(qwAddr);

    dprintf("\nclient:\n");

    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ActiveCallHead, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CurrentCall, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ActiveCallTail, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CachedCalls, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CachedCallCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ThreadId, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, BindingHandle, tmp1);

    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, ServerResponded, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, CallbackCompleted, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fServerSupportsAsync, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fSecurePacketReceived, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fBusy, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, InConnectionTable, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AckPending, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AckOrphaned, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, PossiblyRunDown, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fAutoReconnect,tmp1);

    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, Association, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AssociationKey, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, AuthInfo, tmp2);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, SecurityContextId, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, TimeStamp, tmp1);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, LastScavengeTime, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, DelayedAckTimer, tmp2);
    PRINT_MEMBER(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, Next, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, fError, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CCONNECTION, RPCRT4!DG_CCONNECTION, Mutex, tmp2);
}

char *
CallbackState(
    DG_SCONNECTION::CALLBACK_STATE State
    )
{
    switch (State)
        {
        case DG_SCONNECTION::NoCallbackAttempted:    return "NoCallbackAttempted";
        case DG_SCONNECTION::SetupInProgress:        return "SetupInProgress";
        case DG_SCONNECTION::MsConvWayAuthInProgress:return "MsConvWayAuthInProgress";
        case DG_SCONNECTION::  ConvWayAuthInProgress:return "  ConvWayAuthInProgress";
        case DG_SCONNECTION::MsConvWay2InProgress:   return "MsConvWay2InProgress";
        case DG_SCONNECTION::  ConvWay2InProgress:   return "  ConvWay2InProgress";
        case DG_SCONNECTION::  ConvWayInProgress:    return "  ConvWayInProgress";
        case DG_SCONNECTION::CallbackSucceeded:      return "CallbackSucceeded";
        case DG_SCONNECTION::CallbackFailed:         return "CallbackFailed";
        default:
            {
            static char scratch[40];

            sprintf(scratch, "0x%lx", State);
            return scratch;
            }
        }
}


VOID
do_dgsn(
        ULONG64 qwAddr
        )
{
    ULONG64 tmp1;
    ULONG tmp2;

    do_dgccn(qwAddr);

    dprintf("\nserver:\n");

    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, ActiveCalls, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, CurrentCall, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, CachedCalls, tmp1);

    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, pAddress, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, LastInterface, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, pAssocGroup, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, Next, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, ActivityHint, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, AuthInfo, tmp2);
    PRINT_MEMBER(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, MaxKeySeq, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, SecurityContextDict, tmp2);
    PRINT_ADDRESS_OF(qwAddr, DG_SCONNECTION, RPCRT4!DG_SCONNECTION, Callback, tmp2);

    if (!fUseTypeInfo) {

        uchar buff[sizeof(DG_SCONNECTION)];
        GetData(qwAddr, buff, sizeof(DG_SCONNECTION));
        DG_SCONNECTION * cn = (DG_SCONNECTION *) buff;

        dprintf(                                            "\n"
            "  status        %-8lx  binding     %p   datarep   %-8lx   \n"
            "  scall         %p  client seq  %-8lx   \n"
            "\n"
            "  token buffer  %p  token len    %-8lx  async state offset %x  \n"
            "  response buf  %p  response len %-8lx  ThirdLegNeeded    %s\n"
            "  sec cxt       %p  credentials  %p  ksno              %-8lx \n"
            "  data index    %-8lx \n",

            cn->Callback.Status,            cn->Callback.Binding,           cn->Callback.DataRep,
            cn->Callback.Call,              cn->Callback.ClientSequence,

            cn->Callback.TokenBuffer,       cn->Callback.TokenLength,       offsetof(DG_SCONNECTION, Callback.AsyncState),
            cn->Callback.ResponseBuffer,    cn->Callback.ResponseLength,    BoolString(cn->Callback.ThirdLegNeeded),
            cn->Callback.SecurityContext,   cn->Callback.Credentials,       cn->Callback.KeySequence,
            cn->Callback.DataIndex
            );
    }
}

VOID
do_dgca(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ReferenceCount, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, BindingHandleReferences, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, InternalTableIndex, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, LastScavengeTime, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, CurrentPduSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, RemoteWindowSize, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, TransportInterface, tmp1);

    dprintf("\n");

    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ServerAddress, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ServerBootTime, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ServerDataRep, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, AssociationFlag, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, fServerSupportsAsync, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, fLoneBindingHandle, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, fErrorFlag, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, LastReceiveTime, tmp1);

    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, Mutex, tmp2);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ResolvedEndpoint, tmp1);
    PRINT_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, KeepAliveHandle, tmp1);
    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, ActiveConnections, tmp2);
    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, InactiveConnections, tmp2);
    PRINT_ADDRESS_OF(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, InterfaceAndObjectDict, tmp2);

    ULONG64 pDceBinding;
    GET_MEMBER(qwAddr, DG_CASSOCIATION, RPCRT4!DG_CASSOCIATION, pDceBinding, pDceBinding);
    dprintf("DCE_BINDING:\n");
    do_dcebinding(pDceBinding);
}

VOID
do_dgsc(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    ULONG64 State;
    GET_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, State, State);
    dprintf("state - %-14s\n", ServerState((DG_SCALL::CALL_STATE)State));

    ULONG64 PreviousState;
    GET_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PreviousState, PreviousState);
    dprintf("prev state - %-14s\n", ServerState((DG_SCALL::CALL_STATE)State));

    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, TimeStamp, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, DispatchBuffer, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, AsyncStatus, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, pAsync, tmp1);

    ULONG64 PipeWaitType;
    GET_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PipeWaitType, PipeWaitType);
    dprintf("pipe op - %-10s\n", PipeOp((PENDING_OPERATION)PipeWaitType));

    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PipeWaitLength, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, PipeThreadId, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, Previous, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, Next, tmp1);

    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, CallInProgress, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, CallWasForwarded, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, KnowClientAddress, tmp1);
    PRINT_MEMBER_BOOLEAN(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, TerminateWhenConvenient, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, AuthorizationService, tmp1);
    PRINT_MEMBER(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, Privileges, tmp1);

    dprintf("\n");

    ULONG64 ActivityHint;
    GET_ADDRESS_OF(qwAddr, DG_SCALL, RPCRT4!DG_SCALL, ActivityHint, ActivityHint, tmp2);

    do_dgpe(ActivityHint-AddressSize);
}


VOID
do_dgag(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;
    ULONG64 Node;
    GET_ADDRESS_OF(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, Node, Node, tmp2);
    ULONG64 Uuid;
    GET_ADDRESS_OF(Node, UUID_HASH_TABLE_NODE, UUID_HASH_TABLE_NODE, Uuid, Uuid, tmp2);

    dprintf("\n"
            "    CAG UUID:   ");   PrintUuid(Uuid);

    ULONG64 ReferenceCount;
    ULONG64 CurrentPduSize;
    ULONG64 RemoteWindowSize;
    ULONG64 AssociationID;
    ULONG64 CtxCollection;
    ULONG64 MutexAddr;
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, ReferenceCount, ReferenceCount);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, CurrentPduSize, CurrentPduSize);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, RemoteWindowSize, RemoteWindowSize);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, AssociationID, AssociationID);
    GET_MEMBER(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, CtxCollection, CtxCollection);
    GET_ADDRESS_OF(qwAddr, ASSOCIATION_GROUP, RPCRT4!ASSOCIATION_GROUP, Mutex, MutexAddr, tmp2);

    dprintf("                  \n"
            "    refs:       %8.8x             mutex at  %p    \n"
            "    pdu length: %8.8x             assoc ID: %x    \n"
            "    send window %8.8x             CtxColl : %I64p    \n",
            (ULONG)ReferenceCount,             MutexAddr,
            (ULONG)CurrentPduSize,             (ULONG)AssociationID,
            (ULONG)RemoteWindowSize,           CtxCollection);
}

// Do some arm twisting to include pipendr.h and asyncndr.

#define _NEWINTRP_
typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;
#include "..\..\ndr20\pipendr.h"

typedef void            IAsyncManager;
#define MAX_CONTEXT_HNDL_NUMBER     8
#include "..\..\ndr20\mulsyntx.h"
#include "..\..\ndr20\asyncndr.h"


char *
PipeState(
    int State
    )
{
    static char buf[40];

    if (State <= 3)
        {
        return ReceiveStates[State];
        }

    sprintf(buf, "0x%x", State);

    return buf;
}

char *
PipeFlags(
    unsigned short Flags
    )
{
    static char buf[80];

    buf[0] = 0;

    if (Flags & NDR_IN_PIPE)
        {
        strcat(buf, "I ");
        }

    if (Flags & NDR_OUT_PIPE)
        {
        strcat(buf, "O ");
        }

    if (Flags & NDR_LAST_IN_PIPE)
        {
        strcat(buf, "LI ");
        }

    if (Flags & NDR_LAST_OUT_PIPE)
        {
        strcat(buf, "LO ");
        }

    if (Flags & NDR_OUT_ALLOCED)
        {
        strcat(buf, "ALLOC ");
        }

    if (Flags & 0xffe0)
        {
        char Excess[10];
        sprintf(Excess, "%hx ", Flags & 0xffe0);
        strcat(buf, Excess);
        }

    return buf;
}

char *
PipeStatusStrings[] =
{
    "QUIET",
    "IN",
    "OUT",
    "DRAIN"
};

char *
PipeStatus(
    unsigned short Status
    )
{
    static char buf[40];

    if (Status <= 3)
        {
        return PipeStatusStrings[Status];
        }

    sprintf(buf, "0x%x", Status);

    return buf;
}

void
do_pipestate(
    ULONG64 qwAddr
    )
{
    ULONG64 ElemsInChunk;
    ULONG64 ElemAlign;
    ULONG64 ElemWireSize;
    ULONG64 ElemMemSize;
    ULONG64 PartialBufferSize;
    ULONG64 PartialElem;
    ULONG64 PartialElemSize;
    ULONG64 PartialOffset;
    ULONG64 CurrentState;
    ULONG64 EndOfPipe;

    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemsInChunk, ElemsInChunk);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemAlign, ElemAlign);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemWireSize, ElemWireSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, ElemMemSize, ElemMemSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialBufferSize, PartialBufferSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialElem, PartialElem);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialElemSize, PartialElemSize);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialOffset, PartialOffset);
    GET_MEMBER(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, CurrentState, CurrentState);

    ULONG tmp2;
    GET_ADDRESS_OF(qwAddr, NDR_PIPE_STATE, RPCRT4!NDR_PIPE_STATE, PartialOffset, EndOfPipe, tmp2);
    EndOfPipe += 4;

    dprintf("\n");
    dprintf(" elems in chunk %8lx   partial buf size  %8lx   state %s\n",
             (ULONG)ElemsInChunk,    (ULONG)PartialBufferSize, PipeState((ULONG)CurrentState) );
    dprintf(" elem align     %8lx   partial element   %8lx   end of pipe bits %I64x\n",
             (ULONG)ElemAlign,       (ULONG)PartialElem,     EndOfPipe );
    dprintf(" elem wire size %8lx   partial elem size %8lx   \n",
             (ULONG)ElemWireSize,    (ULONG)PartialElemSize  );
    dprintf(" elem mem  size %8lx   partial offset    %8lx   \n",
             (ULONG)ElemMemSize,     (ULONG)PartialOffset    );
}

void
do_pipedesc(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, CurrentPipe, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, InPipes, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, OutPipes, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, TotalPipes, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, Flags, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, PipeVersion, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, pPipeMsg, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, DispatchBuffer, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, ChainingBuffer, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, DispatchBufferLength, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, ChainingBufferSize, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LastPartialBuffer, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, BufferSave, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LastPartialSize, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LengthSave, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, LeftoverSize, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, RuntimeState, tmp1);
    PRINT_ADDRESS_OF(qwAddr, NDR_PIPE_DESC, RPCRT4!NDR_PIPE_DESC, Leftover, tmp2);

    do_pipestate(tmp1);
}

void
do_pipearg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pfnPull, tmp1);
    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pfnPush, tmp1);
    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pfnAlloc, tmp1);
    PRINT_MEMBER(qwAddr, GENERIC_PIPE_TYPE, RPCRT4!GENERIC_PIPE_TYPE, pState, tmp1);
}

void
do_pipemsg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, Signature, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, PipeId, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, pPipeObject, tmp1);
    ULONG64 pPipeObject = tmp1;

    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, pStubMsg, tmp1);
    PRINT_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, pTypeFormat, tmp1);

    ULONG64 PipeStatusVal;
    ULONG64 PipeFlagsVal;
    GET_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, PipeStatus, PipeStatusVal);
    GET_MEMBER(qwAddr, NDR_PIPE_MESSAGE, RPCRT4!NDR_PIPE_MESSAGE, PipeFlags, PipeFlagsVal);
    dprintf("pipe status %5s\n", PipeStatus((unsigned short)PipeStatusVal));
    dprintf("pipe flags  %s\n", PipeFlags((unsigned short)PipeStatusVal));

    do_pipearg(pPipeObject );
}

void
async_flags(
    NDR_ASYNC_CALL_FLAGS flags
    )
{
    dprintf("   flags %4x: ", *(unsigned short *)&flags );
    if ( flags.ValidCallPending )
        dprintf(" call pending, " );
    if ( flags.ErrorPending )
        dprintf(" err pending, " );
    if ( flags.BadStubData )
        dprintf(" BSD, " );
    if ( flags.RuntimeCleanedUp )
        dprintf(" rt cleaned, " );
    if ( flags.HandlelessObjCall )
        dprintf(" autocomplete, " );
    if ( flags.Unused )
        dprintf(" Unused %4x ", flags.Unused );
    dprintf("-\n" );

}

char * AsyncPhaseString[5] =
    {
    "zero",
    "prep : initialized",
    "set :  (cl) after get buffer and ( cl | srv) register call",
    "call : cl after marshaling, calling send",
    "error : exception taken"
    };

void
async_stub_phase(
    unsigned short phase
    )
{
    dprintf("   phase %4x: ", phase );
    if ( 0 <= phase  &&  phase < 5 )
        dprintf(" %s\n", AsyncPhaseString[ phase ] );
    else
        dprintf(" unknown??\n" );
}

typedef struct _NDR_ASYNC_OBJ_HANDLE
{
    void *              pIAMvtble;
    void *              pICMvtble;
    NDR_ASYNC_MESSAGE * _pAsyncMsg;
    unsigned long       _Lock;
    unsigned long       _Signature;
    GUID                _iid;
    void *              _InnerUnknown;
    unsigned long       _iRef;
    void *              _pParent;
    void *              _pControl;
    void *              _pSyncInner;
    unsigned long       _fAutoComplete;
} NDR_ASYNC_OBJ_HANDLE;


void
do_asyncdcom(
    ULONG64 qwAddr
    )
{
    if (fUseTypeInfo) {
      dprintf("Can't dump NDR_ASYNC_OBJ_HANDLE when using type info\n");
    }
    else {
        BOOL b;
        char block[sizeof(NDR_ASYNC_OBJ_HANDLE)];

        b = GetData(qwAddr, &block, sizeof(block));
        if ( !b ) {
          dprintf("can't read %p\n", qwAddr);
          return;
        }

        NDR_ASYNC_OBJ_HANDLE * msg = (NDR_ASYNC_OBJ_HANDLE *) block;

        dprintf("\n");
        dprintf(" pIAMvtble %p  pICMvtble %p   asyncmsg %p  lock     %8lx\n",
                msg->pIAMvtble, msg->pICMvtble,  msg->_pAsyncMsg, msg->_Lock );
        dprintf(" innerpUnk %p  iref      %8lx   pParent  %p  pControl %p\n",
                msg->_InnerUnknown,msg->_iRef,   msg->_pParent,msg->_pControl );
        dprintf(" Signature %8lx  iid       ", msg->_Signature ); PrintUuidLocal( & msg->_iid );dprintf("\n");
        dprintf(" innerSync %p  autocompl %d\n",
                msg->_pSyncInner,msg->_fAutoComplete );
    }
}

void
do_asyncrpc(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Size, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Signature, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Lock, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, Flags, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, StubInfo, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, UserInfo, tmp1); 
    PRINT_MEMBER(qwAddr, RPC_ASYNC_STATE, RPCRT4!RPC_ASYNC_STATE, RuntimeInfo, tmp1); 
}

void
do_asyncmsg(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, Signature, tmp1);
    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, Version, tmp1);
    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, AsyncHandle, tmp1);
    PRINT_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, ProcContext, tmp1);

    ULONG64 Flags;
    GET_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, Flags, Flags);
    async_flags( *((NDR_ASYNC_CALL_FLAGS*)&Flags) );

    ULONG64 StubPhase;
    GET_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, StubPhase, StubPhase);
    async_stub_phase( (unsigned short) StubPhase );

    ULONG64 StubMsg;
    GET_MEMBER(qwAddr, NDR_ASYNC_MESSAGE, RPCRT4!NDR_ASYNC_MESSAGE, StubMsg, StubMsg);
    do_stubmsg( StubMsg );
}

//
// Datagram stuff
//

char * PacketFlagStrings[8] =
{
    "forwarded ",
    "lastfrag ",
    "frag ",
    "nofack ",
    "maybe ",
    "idem ",
    "broadcast ",
    "flags-0x80 "
};

char * PacketFlag2Strings[8] =
{
    "fragmented ",
    "cancel-pending ",
    "flags2-0x04 ",
    "flags2-0x08 ",
    "flags2-0x10 ",
    "flags2-0x20 ",
    "flags2-0x40 ",
    "flags2-0x80 "
};

char *
PrintPacketFlags(
    unsigned char PacketFlags1,
    unsigned char PacketFlags2
    )
{
    static char buf[160];
    unsigned char Flags;
    unsigned i;

    buf[0] = 0;

    Flags = PacketFlags1;
    for (i=0; i < 8; i++)
        {
        if (Flags & 1)
            {
            strcat(buf, PacketFlagStrings[i]);
            }

        Flags >>= 1;
        }

    Flags = PacketFlags2;
    for (i=0; i < 8; i++)
        {
        if (Flags & 1)
            {
            strcat(buf, PacketFlag2Strings[i]);
            }

        Flags >>= 1;
        }

    return buf;
}

char * PacketTypes[] =
{
    "REQ ",
    "PING",
    "RESP",
    "FLT ",
    "WORK",
    "NOCA",
    "REJ ",
    "ACK ",
    "QUIT",
    "FACK",
    "QACK"
};

char *
PrintPacketType(
    unsigned char PacketType
    )
{
    static char buf[40];

    if (PacketType < sizeof(PacketTypes)/sizeof(PacketTypes[0]))
        {
        return PacketTypes[PacketType];
        }

    sprintf(buf, "illegal packet type %x ", PacketType);

    return buf;
}

VOID
do_dgpkt(
    ULONG64 p
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, MaxDataLength, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, TimeReceived, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, DataLength, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, pNext, tmp1);
    PRINT_MEMBER(p, DG_PACKET, RPCRT4!DG_PACKET, pPrevious, tmp1);

    ULONG64 Header;
    GET_ADDRESS_OF(p, DG_PACKET, RPCRT4!DG_PACKET, Header, Header, tmp2);

    do_dgpkthdr(Header);
}

VOID
do_dgpkthdr(
    ULONG64 h
    )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketType, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, RpcVersion, tmp1);

    ULONG64 PacketFlags;
    ULONG64 PacketFlags2;
    GET_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketFlags, PacketFlags);
    GET_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketFlags2, PacketFlags2);
    dprintf("flags: %s\n", PrintPacketFlags((unsigned char)PacketFlags, (unsigned char)PacketFlags2));

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, FragmentNumber, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, PacketBodyLen, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, SerialLo, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, DataRep, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ServerBootTime, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, AuthProto, tmp1);

    dprintf("  activity  ");
    ULONG64 ActivityId;
    GET_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ActivityId, ActivityId, tmp2);
    PrintUuid(ActivityId);
    dprintf("\n");

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ActivityHint, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, SequenceNumber, tmp1);

    dprintf("  interface ");
    ULONG64 InterfaceId;
    GET_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, InterfaceId, InterfaceId, tmp2);
    PrintUuid(InterfaceId);
    dprintf("\n");

    ULONG64 InterfaceVersion;
    GET_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, InterfaceVersion, InterfaceVersion, tmp2);
    PRINT_MEMBER(h, _RPC_VERSION, RPCRT4!_RPC_VERSION, MajorVersion, tmp1);
    PRINT_MEMBER(h, _RPC_VERSION, RPCRT4!_RPC_VERSION, MinorVersion, tmp1);

    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, InterfaceHint, tmp1);
    PRINT_MEMBER(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, OperationNumber, tmp1);

    PRINT_ADDRESS_OF(h, _NCA_PACKET_HEADER, RPCRT4!_NCA_PACKET_HEADER, ObjectId, tmp2);

    dprintf("\n");
}

void
do_assoctable(
      ULONG64 qwAddr
      )
{
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("DG_ASSOCIATION_TABLE at 0x%I64x:\n", qwAddr);

    ULONG64 CasUuid;
    ULONG64 fCasUuidReady;
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, CasUuid, CasUuid);
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, fCasUuidReady, fCasUuidReady);

    dprintf("  CAS: ");  PrintUuid( CasUuid );
    dprintf(", %svalid\n", (ULONG)fCasUuidReady ? "" : "not ");

    dprintf("\n");

    PRINT_ADDRESS_OF_WITH_LABEL(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, Mutex, "&Mutex (CSharedLock)", tmp2);

    ULONG64 Associations;
    ULONG64 AssociationsLength;
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, Associations, Associations);
    GET_MEMBER(qwAddr, DG_ASSOCIATION_TABLE, RPCRT4!DG_ASSOCIATION_TABLE, AssociationsLength, AssociationsLength); 
    dprintf("association array at 0x%I64x, %x elements\n", Associations, AssociationsLength);
}


char *
strtok(
    char *String
    )
{
    char * Word;
    static char * End;

    if (String)
        {
        Word = String;
        }
    else if (!End)
        {
        return 0;
        }
    else
        {
        Word = End+1;
        }

    while (*Word == ' ' || *Word == '\t')
        {
        ++Word;
        }

    if (!*Word)
        {
        End = 0;
        return 0;
        }

    End = Word;
    while (*End && *End != ' ' && *End != '\t')
        {
        ++End;
        }

    if (!*End)
        {
        End = 0;
        }
    else
        {
        *End = 0;
        }

    return Word;
}

BOOL
IsMember(
         char Item,
         char * List
         )
{
    BOOL Mask = FALSE;
    if (List[0] == '~')
        {
        Mask = TRUE;
        }

    while (*List)
        {
        if (Item == *List)
            {
            return TRUE ^ Mask;
            }
        ++List;
        }

    return FALSE ^ Mask;
}

BOOL
FetchEvent(
    IN ULONG_PTR RpcEvents,
    IN unsigned Index,
    IN struct RPC_EVENT * Entry
    )
{
    return GetData(RpcEvents + Index * sizeof(struct RPC_EVENT), Entry, sizeof(struct RPC_EVENT));
}

BOOL
FetchEventAddress(
    IN ULONG64 RpcEvents,
    IN int Index,
    IN PULONG64 EntryAddress
    )
{
    static ULONG EntrySize = 0;

    if (EntrySize == 0) {
        EntrySize = GetTypeSize("RPCRT4!RPC_EVENT");
        if (EntrySize == 0) {
            return FALSE;
        }
    }

    *EntryAddress = RpcEvents + Index * EntrySize;

    return TRUE;
}

BOOL
DoesEntryMatch(
    IN struct RPC_EVENT * Entry,
    IN char * Subjects,
    IN char * verbs,
    IN DWORD thread,
    IN ULONG_PTR addr,
    IN ULONG_PTR obj_addr
    )
{
    if (!Entry->Subject)
        {
        return FALSE;
        }

    if (Subjects && !IsMember(Entry->Subject, Subjects))
        {
        return FALSE;
        }

    if (verbs && !IsMember(Entry->Verb, verbs))
        {
        return FALSE;
        }

    if (thread && Entry->Thread != (unsigned short) thread)
        {
        return FALSE;
        }

    if (addr && Entry->SubjectPointer != (void *) addr)
        {
        return FALSE;
        }

    if (obj_addr && Entry->ObjectPointer != (void *) obj_addr)
        {
        return FALSE;
        }

    return TRUE;
}

BOOL
DoesEntryAddressMatch(
    IN ULONG64 Entry,
    IN char * Subjects,
    IN char * verbs,
    IN DWORD thread,
    IN ULONG64 addr,
    IN ULONG64 obj_addr
    )
{
    ULONG64 tmp;
    char item;

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Subject, tmp);

    if (!tmp)
        {
        return FALSE;
        }

    if (Subjects && !IsMember((char)tmp, Subjects))
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Verb, tmp);

    if (verbs && !IsMember((char)tmp, verbs))
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Thread, tmp);

    if (thread && tmp != (unsigned short) thread)
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, SubjectPointer, tmp);

    if (addr && tmp != addr)
        {
        return FALSE;
        }

    GET_MEMBER_NORET_NOSPEW(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, ObjectPointer, tmp);

    if (obj_addr && tmp != obj_addr)
        {
        return FALSE;
        }

    return TRUE;
}

char * DgPacketTypes[] =
{
    "REQ",
    "PING",
    "RESP",
    "FAULT",

    "WORKING",
    "NOCALL",
    "REJECT",
    "ACK",

    "QUIT",
    "FACK",
    "QUACK",
    "BIND",
    "BIND-ACK",

    "BIND_NAK",
    "ALTER-CXT",
    "ALTER-RESP",
    "AUTH-3",
    "SHUTDOWN",

    "CANCEL",
    "ORPHAN"
};

char * ScallStates[] =
{
    "Init",
    "BeforeDispatch",
    "Dispatched",
    "DispatchedWithCompleteData",
    "AfterDispatch",
    "SendingResponse",
    "Complete"
};

char * CcallStates[] =
{
    "Init",
    "Quiescent",
    "Send",
    "SendReceive",
    "Receive",
    "CancellingSend",
    "Complete"
};

char * HandleTypeStrings[] =
{
    "wmsg_cas     ",
    "wmsg_handle  ",
    "dg_ccall     ",
    "dg_scall     ",
    "dg_binding   ",
    "osf_ccall    ",
    "osf_scall    ",
    "osf_cconn    ",
    "osf_sconn    ",
    "osf_cassoc   ",
    "osf_assoc    ",
    "osf_address  ",
    "lrpc_ccall   ",
    "lrpc_scall   ",
    "lrpc_cassoc  ",
    "lrpc_sassoc  ",
    "lrpc_binding ",
    "svr_binding  ",
    "dg_cconn     ",
    "dg_sconn     ",
    "osf_binding  ",
    "dg_callback  ",
    "dg_address   ",
    "lrpc_address ",
    "dg_assoc     "
};

char *
GetHandleType(
    void * Value
    )
{
    int i;

    for (i=0; i < sizeof(HandleTypeStrings)/sizeof(char *); ++i)
        {
        if ((1UL << i) == PtrToUlong(Value))
            {
            return HandleTypeStrings[i];
            }
        }

    static char scratch[40];

    sprintf(scratch, "refobj %p", Value);
    return scratch;
}

char *
GetHandleTypeAddr(
    ULONG64 Pointer
    )
{
    int i;
    ULONG64 Value;

    for (i=0; i < sizeof(HandleTypeStrings)/sizeof(char *); ++i)
        {
        ReadPtr(Pointer, &Value);

        if ((1UL << i) == Pointer)
            {
            return HandleTypeStrings[i];
            }
        }

    static char scratch[40];

    sprintf(scratch, "refobj %.6x", Pointer);
    return scratch;
}

int
PrintEntry(
    IN struct RPC_EVENT * Entry,
    IN ULONG index,
    IN BOOL ShowStack
    )
{
    char * Subject;
    char * Verb;
    BOOL Printed = FALSE;

    switch (Entry->Subject)
        {
        case SU_HANDLE   : Subject = "binding     "; break;
        case SU_CCONN    : Subject = "cconn       "; break;
        case SU_SCONN    : Subject = "sconn       "; break;
        case SU_CASSOC   : Subject = "cassoc      "; break;
        case SU_SASSOC   : Subject = "sassoc      "; break;
        case SU_CCALL    : Subject = "ccall       "; break;
        case SU_SCALL    : Subject = "scall       "; break;
        case SU_PACKET   : Subject = "packet      "; break;
        case SU_CENDPOINT: Subject = "endpnt      "; break;
        case SU_ENGINE   : Subject = " call       "; break;
        case SU_ASSOC    : Subject = " assoc      "; break;
        case SU_MUTEX    : Subject = "mutex       "; break;
        case SU_STABLE   : Subject = "sc tabl     "; break;
        case SU_BCACHE   : Subject = "bcache      "; break;
        case SU_HEAP     : Subject = "heap        "; break;
        case SU_THREAD   : Subject = "thread      "; break;
        case SU_EVENT    : Subject = "event       "; break;
        case SU_TRANS_CONN:Subject = "trans conn  "; break;
        case SU_ADDRESS  : Subject = "address     "; break;
        case SU_EXCEPT   : Subject = "exception   "; break;
        case SU_REFOBJ   :
            {
            Subject = GetHandleType(Entry->ObjectPointer);
            break;
            }
        case SU_CTXHANDLE: Subject = "ctx handle  "; break;
        default:
            {
            static char string[4];
            Subject = string;

            Subject[0] = '\"';
            Subject[1] = Entry->Subject;
            Subject[2] = '\"';
            Subject[3] = '\0';
            break;
            }
        }

    dprintf("%5x: %06.6d.%03.3d/%-4x  %s %p ", index, Entry->Time /1000, Entry->Time % 1000, Entry->Thread, Subject, Entry->SubjectPointer);

    Verb = "(extension bug)";

    switch (Entry->Verb)
        {
        case EV_CREATE    : Verb = "create   "; break;
        case EV_DELETE    : Verb = "delete   "; break;
        case EV_START     : Verb = "active   "; break;
        case EV_STOP      : Verb = "inactive "; break;
        case EV_INC       : Verb = "ref++    "; break;
        case EV_DEC       : Verb = "ref--    "; break;
        case EV_ACK       : Verb = "ack sent "; break;
        case EV_NOTIFY    : Verb = "notify   "; break;
        case EV_APC       : Verb = "APC fired"; break;
        case EV_RESOLVED  : Verb = "resolved "; break;
        case EV_REMOVED   : Verb = "removed  "; break;
        case EV_CLEANUP   : Verb = "cleanup  "; break;
        case EV_SEC_INIT1   : Verb = "init SC 1"; break;
        case EV_SEC_INIT3   : Verb = "init SC 3"; break;
        case EV_SEC_ACCEPT1 : Verb = "accptSC 1"; break;
        case EV_SEC_ACCEPT3 : Verb = "accptSC 3"; break;
        case EV_STATUS:
            {
            if (Entry->Subject != SU_EXCEPT)
                {
                if (Entry->ObjectPointer)
                    {
                    dprintf("status %lx, location %d", Entry->Data, Entry->ObjectPointer);
                    }
                else
                    {
                    dprintf("status %lx", Entry->Data);
                    }
                Printed = TRUE;
                break;
                }
            else
                {
                dprintf("exception info: %lx, %lx, %lx", Entry->SubjectPointer, Entry->ObjectPointer, Entry->Data);
                Printed = TRUE;
                break;
                }
            }
        case EV_DISASSOC  : Verb = "disassoc "; break;
        case EV_STATE:
            {
            char * state = "----";

            if (Entry->Subject == SU_CCALL)
                {
                if (Entry->Data < DG_CCALL::CallInit     ||
                    Entry->Data > DG_CCALL::CallComplete )
                    {
                    dprintf("unknown state 0x%x", Entry->Data);
                    Printed = TRUE;
                    }
                else
                    {
                    state = CcallStates[Entry->Data - DG_CCALL::CallInit];
                    }
                }
            else
                {
                if (Entry->Data < DG_SCALL::CallInit     ||
                    Entry->Data > DG_SCALL::CallComplete )
                    {
                    dprintf("unknown state 0x%x", Entry->Data);
                    Printed = TRUE;
                    }
                else
                    {
                    state = ScallStates[Entry->Data - DG_SCALL::CallInit];
                    }
                }

            if (!Printed)
                {
                dprintf("state %s", state);
                Printed = TRUE;
                }

            break;
            }
        case EV_POP       : Verb = "pop      "; break;
        case EV_PUSH      : Verb = "push     "; break;
        case EV_PKT_IN:
            {
            unsigned short frag  = (unsigned short) (Entry->Data);
            unsigned short ptype = (unsigned short) (Entry->Data >> 16);
            char * ptypestring;

            if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                {
                dprintf("recv pkt unknown type 0x%hx", ptype);
                Printed = TRUE;
                }
            else
                {
                ptypestring = DgPacketTypes[ptype];
                }

            if (!Printed)
                {
                if (Entry->ObjectPointer)
                    {
                    dprintf("recv pkt %s frag %hx, location %d", ptypestring, frag, Entry->ObjectPointer);
                    }
                else
                    {
                    dprintf("recv pkt %s frag/len %hx", ptypestring, frag);
                    }
                Printed = TRUE;
                }
            break;
            }

        case EV_BUFFER_IN : Verb = "buf    in"; break;
        case EV_BUFFER_OUT: Verb = "buf   out"; break;
        case EV_TRANSFER:   Verb = "xfer call"; break;
        case EV_DROP:       Verb = "dropped  "; break;
        case EV_DELAY:      Verb = "delayed  "; break;
        case EV_CALLBACK:   Verb = "callback "; break;

        default:
            {
            static char string[4];
            Verb = string;

            Verb[0] = '\"';
            Verb[1] = Entry->Verb;
            Verb[2] = '\"';
            Verb[3] = '\0';
            break;
            }
        case 'p':
            {
            if (Entry->Subject == SU_STABLE)
                {
                Verb = "prune    ";
                }
            else
                {
                DWORD buf[2];
                buf[0] = (DWORD) Entry->Data;
                buf[1] = 0;

                dprintf("proc %s  %p", (char *) buf, Entry->ObjectPointer);

                Printed = TRUE;
                }
            break;
            }
        case EV_PKT_OUT:
            {
            unsigned short frag  = (unsigned short) (Entry->Data);
            unsigned short ptype = (unsigned short) (Entry->Data >> 16);
            char * ptypestring;

            if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                {
                ptypestring = "???";
                }
            else
                {
                ptypestring = DgPacketTypes[ptype];
                }

            dprintf("sent pkt %s frag/len %hx", ptypestring, frag);
            Printed = TRUE;
            break;
            }
        }

    if (!Printed)
        {
        dprintf("%s  %p %p", Verb, Entry->ObjectPointer, Entry->Data);
        }

    dprintf("\n");

    int LinesPrinted = 1;

    if (ShowStack && Entry->EventStackTrace[0])
        {
        int i;

        for (i = 0; Entry->EventStackTrace[i] && i < STACKTRACE_DEPTH; i++)
            {
            dprintf("        ");
            do_symbol((ULONG_PTR) Entry->EventStackTrace[i]);
            ++LinesPrinted;
            }
        }

    return LinesPrinted;
}

int
PrintEntryAddress(
    IN ULONG64 Entry,
    IN int index,
    IN BOOL ShowStack
    )
{
    char * Subject;
    char * Verb;
    BOOL Printed = FALSE;

    ULONG tmp;

    ULONG64 Time = 0;
    ULONG64 Thread = 0;
    ULONG64 SubjectPointer = 0;
    ULONG64 ObjectPointer = 0;
    ULONG64 SubjectData = 0;
    ULONG64 VerbData = 0;
    ULONG64 Data = 0;
    ULONG64 EventStackTraceAddress =0 ;
    ULONG64 EventStackTrace_0 = 0;

    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Time, Time);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Thread, Thread);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, SubjectPointer, SubjectPointer);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Subject, SubjectData);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, ObjectPointer, ObjectPointer);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Verb, VerbData);
    GET_MEMBER_NORET(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, Data, Data);
    GET_ADDRESS_OF(Entry, RPC_EVENT, RPCRT4!RPC_EVENT, EventStackTrace, EventStackTraceAddress, tmp);
    ReadPtr(EventStackTraceAddress, &EventStackTrace_0);

    switch ((char)SubjectData)
        {
        case SU_HANDLE   : Subject = "binding      "; break;
        case SU_CCONN    : Subject = "cconn        "; break;
        case SU_SCONN    : Subject = "sconn        "; break;
        case SU_CASSOC   : Subject = "cassoc       "; break;
        case SU_SASSOC   : Subject = "sassoc       "; break;
        case SU_CCALL    : Subject = "ccall        "; break;
        case SU_SCALL    : Subject = "scall        "; break;
        case SU_PACKET   : Subject = "packet       "; break;
        case SU_CENDPOINT: Subject = "endpnt       "; break;
        case SU_ENGINE   : Subject = " call        "; break;
        case SU_ASSOC    : Subject = " assoc       "; break;
        case SU_MUTEX    : Subject = "mutex        "; break;
        case SU_STABLE   : Subject = "sc tabl      "; break;
        case SU_BCACHE   : Subject = "bcache       "; break;
        case SU_HEAP     : Subject = "heap         "; break;
        case SU_THREAD   : Subject = "thread       "; break;
        case SU_EVENT    : Subject = "event        "; break;
        case SU_TRANS_CONN:Subject = "trans conn   "; break;
        case SU_ADDRESS  : Subject = "address      "; break;
        case SU_EXCEPT   : Subject = "exception    "; break;
        case SU_REFOBJ   :
            {
            Subject = GetHandleTypeAddr(ObjectPointer);
            break;
            }
        case SU_CTXHANDLE: Subject = "ctx handle   "; break;
        case SU_EEINFO   : Subject = "EEInfo       "; break;

        default:
            {
            static char string[4];
            Subject = string;
            Subject[0] = '\"';
            Subject[1] = (char)SubjectData;
            Subject[2] = '\"';
            Subject[3] = '\0';

            break;
            }
        }

    dprintf("%5x: %06.6d.%03.3d/%-4x %s %I64p ", index, (ULONG)Time / 1000, (ULONG)Time % 1000, (ULONG)Thread, Subject, SubjectPointer);

    if (SubjectData != SU_EEINFO)
        {
        Verb = "(extension bug)";

        switch ((char)VerbData)
            {
            case EV_CREATE    : Verb = "create   "; break;
            case EV_DELETE    : Verb = "delete   "; break;
            case EV_START     : Verb = "active   "; break;
            case EV_STOP      : Verb = "inactive "; break;
            case EV_INC       : Verb = "ref++    "; break;
            case EV_DEC       : Verb = "ref--    "; break;
            case EV_ACK       : Verb = "ack sent "; break;
            case EV_NOTIFY    : Verb = "notify   "; break;
            case EV_APC       : Verb = "APC fired"; break;
            case EV_RESOLVED  : Verb = "resolved "; break;
            case EV_REMOVED   : Verb = "removed  "; break;
            case EV_CLEANUP   : Verb = "cleanup  "; break;
            case EV_SEC_INIT1   : Verb = "init SC 1"; break;
            case EV_SEC_INIT3   : Verb = "init SC 3"; break;
            case EV_SEC_ACCEPT1 : Verb = "accptSC 1"; break;
            case EV_SEC_ACCEPT3 : Verb = "accptSC 3"; break;
            case EV_STATUS:
                {
                if ((ULONG)SubjectData != SU_EXCEPT)
                    {
                    if (VerbData)
                        {
                        dprintf("status %lx, location %d", (ULONG)Data, (ULONG)ObjectPointer);
                        }
                    else
                        {
                        dprintf("status %lx", (ULONG)Data);
                        }
                    Printed = TRUE;
                    break;
                    }
                else
                    {
                    dprintf("exception info: %lx, %lx, %lx", (ULONG)SubjectPointer, (ULONG)ObjectPointer, (ULONG)Data);
                    Printed = TRUE;
                    break;
                    }
                }
            case EV_DISASSOC  : Verb = "disassoc "; break;
            case EV_STATE:
                {
                char * state = "----";

                if ((ULONG)SubjectData == SU_CCALL)
                    {
                    if (Data < GetExpression("rpcrt4!DG_CCALL__CallInit") ||
                        Data > GetExpression("rpcrt4!DG_CCALL__CallComplete"))
                        {
                        dprintf("unknown state 0x%x", Data);
                        Printed = TRUE;
                        }
                    else
                        {
                        state = CcallStates[Data - GetExpression("rpcrt4!DG_CCALL__CallInit")];
                        }
                    }
                else
                    {
                    if (Data < GetExpression("RPCRT4!DG_SCALL__CallInit") ||
                        Data > GetExpression("RPCRT4!DG_SCALL__CallComplete"))
                        {
                        dprintf("unknown state 0x%x", Data);
                        Printed = TRUE;
                        }
                    else
                        {
                        state = ScallStates[Data - GetExpression("RPCRT4!DG_SCALL__CallInit")];
                        }
                    }

                if (!Printed)
                    {
                    dprintf("state %s", state);
                    Printed = TRUE;
                    }

                break;
                }
            case EV_POP       : Verb = "pop      "; break;
            case EV_PUSH      : Verb = "push     "; break;
            case EV_PKT_IN:
                {
                unsigned short frag  = (unsigned short) (Data);
                unsigned short ptype = (unsigned short) (Data >> 16);
                char * ptypestring;

                if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                    {
                    dprintf("recv pkt unknown type 0x%hx", ptype);
                    Printed = TRUE;
                    }
                else
                    {
                    ptypestring = DgPacketTypes[ptype];
                    }

                if (!Printed)
                    {
                    if (ObjectPointer)
                        {
                        dprintf("recv pkt %s frag %hx, location %d", ptypestring, frag, (ULONG)ObjectPointer);
                        }
                    else
                        {
                        dprintf("recv pkt %s frag/len %hx", ptypestring, frag);
                        }
                    Printed = TRUE;
                    }
                break;
                }

            case EV_BUFFER_IN : Verb = "buf    in"; break;
            case EV_BUFFER_OUT: Verb = "buf   out"; break;
            case EV_TRANSFER:   Verb = "xfer call"; break;
            case EV_DROP:       Verb = "dropped  "; break;
            case EV_DELAY:      Verb = "delayed  "; break;
            case EV_CALLBACK:   Verb = "callback "; break;

            default:
                {
                static char string[10];
                Verb = string;
                Verb[0] = '\"';
                Verb[1] = (char)VerbData;
                Verb[2] = '\"';
                Verb[3] = '\0';

                break;
                }

            case 'p':
                {
                if (SubjectData == SU_STABLE)
                    {
                    Verb = "prune    ";
                    }
                else
                    {
                    DWORD buf[2];
                    buf[0] = (DWORD) Data;
                    buf[1] = 0;

                    dprintf("proc %s  %I64x", (char *) buf, ObjectPointer);

                    Printed = TRUE;
                    }
                break;
                }

            case EV_PKT_OUT:
                {
                unsigned short frag  = (unsigned short) (Data);
                unsigned short ptype = (unsigned short) ((Data >> 16) & 0xFF);
                unsigned short opnum = (unsigned short) (Data >> 24);
                ULONG CallId = (ULONG)ObjectPointer;
                char * ptypestring;

                if (ptype >= sizeof(DgPacketTypes)/sizeof(DgPacketTypes[0]))
                    {
                    ptypestring = "???";
                    }
                else
                    {
                    ptypestring = DgPacketTypes[ptype];
                    }

                if (opnum)
                    {
                    dprintf("sent p %s fr/len %hx op# %d cid %d", ptypestring, frag, opnum, CallId);
                    }
                else
                    {
                    dprintf("sent p %s fr/len %hx cid %d", ptypestring, frag, CallId);
                    }
                Printed = TRUE;
                break;
                }
            }
        }
    else
        {
        // this is an eeinfo record
        dprintf("GC %d St %d DL %d P#1 %d", (ULONG)VerbData, (ULONG)SubjectPointer, (ULONG)ObjectPointer, (ULONG)Data);
        Printed = TRUE;
        }

    if (!Printed)
        {
        dprintf("%s  %I64p %I64p", Verb, ObjectPointer, Data);
        }

    dprintf("\n");

    int LinesPrinted = 1;

    if (ShowStack && EventStackTrace_0)
        {
        int i = 0;
        ULONG64 StackEntry = 0;

        do {
            ReadPtr(EventStackTraceAddress + i * AddressSize, &StackEntry);

            dprintf("        ");
            do_symbol(StackEntry);
            ++LinesPrinted;
            ++i;
            }
        while (StackEntry && i < STACKTRACE_DEPTH);
        }

    return LinesPrinted;
}

void scan_usage()
{
    dprintf("options:\n"
            "\n"
            "    -sXYZ          print entries with subject character == X or Y or Z\n"
            "    -vXYZ          print entries with verb    character == X or Y or Z\n"
            "    -s~XYZ         print entries with subject character != X or Y or Z\n"
            "    -v~XYZ         print entries with verb    character != X or Y or Z\n"
            "    -t NNNN        print entries for thread NNNN            \n"
            "    -a NNNN        print entries for subject at address NNNN \n"
            "    -o NNNN        print entries for  object at address NNNN \n"
            "    -k or -k+      show stack traces if available\n"
            "    -k-            don't show stack traces (default)\n"
            "    -b NNNN1 NNNN2 NNNN3  \n"
            "                   (if symbols are broken) RpcEvents is at NNNN1"
            "                   and NextEvent is NNNN2\n"
            "                   and event array length is NNNN3\n"
            "    -NNNN          print the NNNN entries ending with NextEvent (or specified base)\n"
            "    +NNNN          print the NNNN entries starting with NextEvent (or specified base)\n"
            "    NNNN           the base index is NNNN"
            "    -f filename    reads a binary version of the log and displays it as text\n"
            "\n"
            "e.g. '!scan -40 -sN' would print the last 40 DG_SCONNECTION events\n"
            "     '!scan +30 200' would print 30 entries starting at index 200\n"
            );
}

char VerbsToDisplay[40];
char SubjectsToDisplay[40];

DECLARE_API( scan )
{
    char * Subject = 0;
    char * verb = 0;
    ULONG64 addr = 0;
    ULONG64 obj_addr = 0;
    DWORD thread = 0;

    static ULONG64 RpcEvents = 0;
    static LONG EventArrayLength = 0;

    static LONG NextEvent = 0;

    int   RequestCount = 30;
    int   NextEventToPrint = 0;
    BOOL  ForwardSearch = FALSE;
    BOOL  ShowStackTraces = FALSE;

    BOOL Wrapped = FALSE;
    int BaseIndex = -1;
    int MatchCount = 0;
    int index;
    int i;

    BOOL fFileInput = FALSE;
    HANDLE hFile;

    struct RPC_EVENT Entry;

    ULONG64 EntryAddress;
    ULONG64 tmp;

    //
    // Interpret options.
    //
    char * arg;

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        if (arg[0] == '-')
            {
            ++arg;

            switch (arg[0])
                {
                case 's':
                    {
                    if (!arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    if (strlen(arg+1) >= sizeof(SubjectsToDisplay))
                        {
                        dprintf("-s: too many subject types proposed\n");
                        return;
                        }

                    strcpy(SubjectsToDisplay, arg+1);
                    Subject = SubjectsToDisplay;
                    if (Subject[0] == '*')
                        {
                        Subject = 0;
                        }
                    break;
                    }

                case 'v':
                    {
                    if (!arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    if (strlen(arg+1) >= sizeof(VerbsToDisplay))
                        {
                        dprintf("-v: too many verbs proposed\n");
                        return;
                        }

                    strcpy(VerbsToDisplay, arg+1);
                    verb = VerbsToDisplay;
                    if (verb[0] == '*')
                        {
                        verb = 0;
                        }
                    break;
                    }

                case 'a':
                    {
                    if (arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-a: no object address specified\n");
                        return;
                        }

                    addr = GetExpression(arg);

                    if (!addr)
                        {
                        dprintf("-a: can't evaluate %s\n", arg);
                        return;
                        }

                    break;
                    }

                case 'o':
                    {
                    if (arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-o: no object address specified\n");
                        return;
                        }

                    obj_addr = GetExpression(arg);

                    if (!obj_addr)
                        {
                        dprintf("-o: can't evaluate %s\n", arg);
                        return;
                        }

                    break;
                    }

                case 't':
                    {
                    if (arg[1])
                        {
                        scan_usage();
                        return;
                        }

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-t: no thread ID specified\n");
                        return;
                        }

                    thread = (DWORD) GetExpression(arg);

                    if (!thread)
                        {
                        dprintf("-t: can't evaluate %s\n", arg);
                        return;
                        }
                    break;
                    }

                case 'b':
                    {
                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-b: no base address specified\n");
                        return;
                        }

                    RpcEvents = GetExpression(arg);

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-b: no NextEvent specified\n");
                        return;
                        }

                    NextEvent = (LONG) GetExpression(arg);

                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-b: no event array length specified\n");
                        return;
                        }

                    EventArrayLength = (long) GetExpression(arg);

                    break;
                    }

                case 'k':
                    {
                    if (arg[1] == '+' ||
                        arg[1] == '\0')
                        {
                        ShowStackTraces = TRUE;
                        }
                    else if (arg[1] == '-')
                        {
                        ShowStackTraces = FALSE;
                        }
                    else
                        {
                        dprintf("-k:  use '-k' or '-k+' for stack traces, '-k-' for none\n");
                        return;
                        }
                    break;
                    }

                case 'f':
                    {
                    arg = strtok(0);

                    if (!arg)
                        {
                        dprintf("-f: no file name specified\n");
                        return;
                        }

                    hFile = CreateFileA(arg, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL, NULL);
                    if (hFile == INVALID_HANDLE_VALUE)
                        {
                        dprintf("-f: Couldn't open file name %s - error %d\n", arg, GetLastError());
                        return;
                        }

                    fFileInput = TRUE;
                    }
                    break;

                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    {
                    ForwardSearch = FALSE;
                    RequestCount = myatol(arg);

                    if (!RequestCount)
                        {
                        dprintf("-%s: zero lines specified\n", arg);
                        return;
                        }
                    break;
                    }

                default:
                    {
                    dprintf("unknown option %s\n", arg);
                    scan_usage();
                    return;
                    }
                }
            }
        else if (arg[0] == '+')
            {
            ++arg;
            RequestCount = myatol(arg);

            if (!RequestCount)
                {
                dprintf("+%s: zero lines specified\n", arg);
                return;
                }

            MatchCount = RequestCount;
            ForwardSearch = TRUE;
            }
        else
            {
            BaseIndex = (int) GetExpression(arg);
            }
        }

    if (fFileInput)
        {
        BOOL Result;
        DWORD NumberOfBytesRead;
        index = 1;

        while (1)
            {
            Result = ReadFile(hFile, &Entry, sizeof(Entry), &NumberOfBytesRead, NULL);
            if (!Result)
                {
                dprintf("-f: Error reading file: %d\n", GetLastError());
                break;
                }

            if (NumberOfBytesRead < sizeof(Entry))
                {
                dprintf("-f: EOF reached\n");
                break;
                }

            PrintEntry(&Entry, index, ShowStackTraces);

            index ++;

            if ((CheckControlC)())
                {
                CloseHandle(hFile);
                return;
                }
            }

        CloseHandle(hFile);
        return;
        }

    ULONG64 NextEventAddress = GetExpression("rpcrt4!NextEvent");
    ULONG64 EventLengthAddress = GetExpression("rpcrt4!EventArrayLength");

    //
    // Find the current event.
    //
    if (!RpcEvents)
        {
        RpcEvents = GetExpression("rpcrt4!RpcEvents");

        if (!RpcEvents || !NextEventAddress)
            {
            dprintf("I can't find rpcrt4!RpcEvents or rpcrt4!NextEvent; use -b\n");
            return;
            }

        if (!ReadMemory(NextEventAddress, &NextEvent, sizeof(DWORD), 0))
            {
            dprintf("I can't read NextEvent from 0x%I64x\n", NextEventAddress);
            return;
            }

        if (EventLengthAddress)
            {
            if (!ReadMemory(EventLengthAddress, &EventArrayLength, sizeof(DWORD), 0))
                {
                dprintf("I can't read EventArrayLength from 0x%I64x\n", EventLengthAddress);
                return;
                }

            if (!ReadMemory(RpcEvents, &tmp, sizeof(ULONG64), 0))
                {
                dprintf("I can't read rpcrt4!RpcEvents at 0x%I64x\n", RpcEvents);
                return;
                }

            RpcEvents = tmp;
            }
        else
            {
            dprintf("rpcrt4!EventArrayLength isn't defined; probably an older build\n");

            EventArrayLength = 4096;
            }

        dprintf("RpcEvents at 0x%I64x; array has %u entries; NextEvent = %lx, %s\n",
                RpcEvents, EventArrayLength, NextEvent, Wrapped ? "wrapped around" : "");
        }

    if (FALSE == FetchEventAddress(RpcEvents, 0, &EntryAddress))
        {
        dprintf("I can't read memory at 0x%I64x \n", RpcEvents);
        return;
        }
    
    GET_MEMBER(EntryAddress, RPC_EVENT, RPCRT4!RPC_EVENT, Subject, tmp);
    if (tmp)
        {
        Wrapped = TRUE;
        }

    if (thread || Subject || verb || addr || obj_addr)
        {
        dprintf("filter: ");
        }
    else
        {
        dprintf("no filter");
        }

    if (thread)
        {
        dprintf("thread %x ", thread);
        }
    if (Subject)
        {
        dprintf("subjects '%s' ", Subject);
        }
    if (verb)
        {
        dprintf("verbs '%s' ", verb);
        }
    if (addr)
        {
        dprintf("address %x ", addr);
        }
    if (obj_addr)
        {
        dprintf("direct-object address 0x%I64x ", obj_addr);
        }

    dprintf(", base index = %x\n", BaseIndex);

    // Allow one set of debug spew to be printed if some data can't 
    // be properly read or fields extracted.
    fSpew = TRUE;

    //
    // Scan backwards until we have enough matching events.
    //
    if (NextEvent > EventArrayLength)
        {
        NextEvent %= EventArrayLength;
        }

    if (ForwardSearch)
        {
        if (BaseIndex == -1)
            {
            BaseIndex = NextEventToPrint;
            }

        if (!Wrapped && BaseIndex + MatchCount > NextEvent+1)
            {
            MatchCount = NextEvent+1 - BaseIndex;
            }
        }
    else
        {
        if (BaseIndex == -1)
            {
            BaseIndex = NextEvent;
            }

        LONG Point = BaseIndex;

        for (index = Point; index >= 0 && MatchCount < RequestCount; --index )
            {
            if (FALSE == FetchEventAddress(RpcEvents, index, &EntryAddress))
                {
                dprintf("I can't read memory at index %x\n", index);
                return;
                }

            if (DoesEntryAddressMatch(EntryAddress, Subject, verb, thread, addr, obj_addr))
                {
                ++MatchCount;
                BaseIndex = index;
                }
            }

        if (Wrapped && MatchCount < RequestCount)
            {
            for (index = EventArrayLength-1; index > Point && MatchCount < RequestCount; --index )
                {
                ULONG64 EntryAddress;

                if (FALSE == FetchEventAddress(RpcEvents, index, &EntryAddress))
                    {
                    dprintf("I can't read memory at index %d\n", index);
                    return;
                    }

                if (DoesEntryAddressMatch(EntryAddress, Subject, verb, thread, addr, obj_addr))
                    {
                    ++MatchCount;
                    BaseIndex = index;
                    }
                }
            }
        }

    //
    // Print matching events.
    //
    index = BaseIndex;

    do
        {
        if (FALSE == FetchEventAddress(RpcEvents, index, &EntryAddress))
            {
            dprintf("I can't read memory at index %x\n", index);
            return;
            }

        if (DoesEntryAddressMatch(EntryAddress, Subject, verb, thread, addr, obj_addr))
            {
            PrintEntryAddress(EntryAddress, index, ShowStackTraces);
            --MatchCount;
            }

        ++index;
        index = index % EventArrayLength;

        if ((CheckControlC)())
            {
            return;
            }
        }
    while (MatchCount && index != BaseIndex);

    NextEventToPrint = index;
}

DECLARE_API( rpcsleep )
{
    int nInterval;
    LPSTR lpArgumentString = (LPSTR)args;

    nInterval=atoi(lpArgumentString);

    if (nInterval == 0)
        {
        dprintf("Invalid wait interval %s\n", lpArgumentString);
        return;
        }

    Sleep(nInterval);
}

DECLARE_API( rpctime )
{
    DWORD dwCurrentTime;

    if (fKD)
        {
        dprintf("Cannot dump time in kd\n");
        return;
        }

    dwCurrentTime = GetTickCount();
    dprintf("Current time is: %06.6d.%03.3d (0x%06.6x.%03.3x)\n", dwCurrentTime / 1000, dwCurrentTime % 1000,
        dwCurrentTime / 1000, dwCurrentTime % 1000);
}

DECLARE_API( version )
{
#if    DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    if (fKD)
        {
        dprintf(
                "%s RPC Extension dll for Build %d debugging %s kernel for Build %d\n",
                kind,
                VER_PRODUCTBUILD,
                SavedMajorVersion == 0x0c ? "Checked" : "Free",
                SavedMinorVersion
                );
        }
    else
        {
        dprintf(
                "%s RPC Extension dll for Build %d\n",
                kind,
                VER_PRODUCTBUILD
                );
        }
}

DECLARE_API( bcache )
{
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 StateArray = 0;

    // For process cache
    ULONG64 Cache;
    ULONG64 CacheAddress;

    BOOL b, fGuardPageMode = FALSE;

    //
    // Interpret options.
    //
    char * arg1;
    char * arg2;

    LPSTR lpArgumentString = (LPSTR)args;

    arg1 = strtok(lpArgumentString);
    arg2 = strtok(0);

    if (arg2)
        {
        dprintf("usage:  \n"
                "        !bcache <TEB-address>  for a thread's cache\n"
                "        !bcache                for the process cache\n"
                "\n");
        return;
        }

    if (arg1)
        {
        ULONG64 RpcThread;

        ULONG64 pTeb = GetExpression(arg1);

        GET_MEMBER(pTeb, TEB, TEB, ReservedForNtRpc, RpcThread);

        GET_ADDRESS_OF(RpcThread, THREAD, RPCRT4!THREAD, BufferCache, StateArray, tmp2);
        }
    else
        {
        ULONG64 CachePointerAddress = GetExpression("rpcrt4!gBufferCache");

        if (!CachePointerAddress)
            {
            dprintf("can't find rpcrt4!gBufferCache\n");
            return;
            }

        b = GetData(CachePointerAddress, &CacheAddress, sizeof(PVOID));
        if ( !b )
            {
            dprintf("couldn't read process buffer cache pointer at %x\n", CacheAddress);
            return;
            }

        dprintf("process-wide buffer cache:\n");

        ULONG64 GuardPageMode = GetExpression("rpcrt4!fGuardPageMode");

        if(GuardPageMode)
            b = GetData(GuardPageMode, &fGuardPageMode, sizeof(fGuardPageMode));

        if (!b)
            {
            dprintf("couldn't read guard page mode flag at address %p\n", GuardPageMode);
            return;
            }

        if (fGuardPageMode)
            {
            dprintf("---> GUARD PAGE mode enabled!\n");
            }

        GET_ADDRESS_OF(CacheAddress, BCACHE, RPCRT4!BCACHE, _bcGlobalState, StateArray, tmp2);
        }

    //
    // Load the size hints.
    //
    ULONG64 HintAddress;

    HintAddress = GetExpression("rpcrt4!pHints");

    ReadPtr(HintAddress, &HintAddress);

    //
    // Dump the buffer states.
    //
    int i;
    ULONG64 State = StateArray;
    ULONG64 Hint = HintAddress;
    ULONG64 cBlocks;
    ULONG64 pList;
    ULONG64 cSize;

    for (i=0; i < 4; ++i)
        {
        GET_MEMBER(State, BCACHE_STATE, RPCRT4!BCACHE_STATE, cBlocks, cBlocks);
        GET_MEMBER(State, BCACHE_STATE, RPCRT4!BCACHE_STATE, pList, pList);
        GET_MEMBER(Hint, BUFFER_CACHE_HINTS, RPCRT4!BUFFER_CACHE_HINTS, cSize, cSize);

        dprintf("   count %5u    head %I64x     size %5x\n",
                (ULONG)cBlocks,
                pList,
                (ULONG)cSize);

        State += GET_TYPE_SIZE(BCACHE_STATE, RPCRT4!BCACHE_STATE);
        Hint += GET_TYPE_SIZE(BUFFER_CACHE_HINTS, RPCRT4!BUFFER_CACHE_HINTS);
        }

    if (!arg1)
        {
        ULONG64  _bcGlobalStats;
        GET_ADDRESS_OF(CacheAddress, BCACHE, RPCRT4!BCACHE, _bcGlobalStats, _bcGlobalStats, tmp2);

        // Dump out the bcache cache stats
        dprintf("\nGlobal Stats:\n     cap   hits misses\n");
        for (i = 0; i < ((fGuardPageMode) ? 2 : 4); i++)
            {
            ULONG64 cBufferCacheCap;
            ULONG64 cAllocationHits;
            ULONG64 cAllocationMisses;
            GET_MEMBER(_bcGlobalStats, BCACHE_STATS, RPCRT4!BCACHE_STATS, cBufferCacheCap, cBufferCacheCap);
            GET_MEMBER(_bcGlobalStats, BCACHE_STATS, RPCRT4!BCACHE_STATS, cAllocationHits, cAllocationHits);
            GET_MEMBER(_bcGlobalStats, BCACHE_STATS, RPCRT4!BCACHE_STATS, cAllocationMisses, cAllocationMisses);

            dprintf("   %5d  %5d  %5d\n",
                    cBufferCacheCap,
                    cAllocationHits,
                    cAllocationMisses);

            _bcGlobalStats += GET_TYPE_SIZE(BCACHE_STATS, RPCRT4!BCACHE_STATS);
            }
        }
}


VOID
CheckVersion(
    VOID
    )
{
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

void PrintGetCallInfoUsage(void)
{
    dprintf("Usage: \n\tgetcallinfo [CallID|0 [IfStart|0 [ProcNum|FFFF [ProcessID|0]]]]\n");
}

DECLARE_API( getcallinfo )
{
    ULONG CallID = 0;
    ULONG IfStart = 0;
    USHORT ProcNum = RPCDBG_NO_PROCNUM_SPECIFIED;
    ULONG ProcessID = 0;
    int ArgumentNo = 0;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or CallID
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetCallInfoUsage();
                    return;
                    }
                else
                    {
                    CallID = (ULONG)GetExpression(arg);
                    }
                break;

            case 1:
                IfStart = (ULONG)GetExpression(arg);
                break;

            case 2:
                ProcNum = (unsigned short) GetExpression(arg);
                break;

            case 3:
                ProcessID = (ULONG)GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetCallInfoUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintCallInfo(CallID, IfStart, ProcNum, ProcessID, dprintf);
}

void PrintGetDbgCellUsage(void)
{
    dprintf("Usage: \n\tgetdbgcell ProcessID CellID1.CellID2\n");
}

DECLARE_API( getdbgcell )
{
    ULONG ProcessID = 0;
    int ArgumentNo = 0;
    DebugCellID CellID;
    char *DotSeparator;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or ProcessID
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetCallInfoUsage();
                    return;
                    }
                else
                    {
                    ProcessID = (ULONG)GetExpression(arg);
                    }
                break;

            case 1:
                DotSeparator = strchr(arg, '.');
                if (DotSeparator == NULL)
                    {
                    PrintGetCallInfoUsage();
                    return;
                    }
                *DotSeparator = 0;
                DotSeparator ++;
                CellID.SectionID = (USHORT)GetExpression(arg);
                CellID.CellID = (USHORT)GetExpression(DotSeparator);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetDbgCellUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintDbgCellInfo(ProcessID, CellID, dprintf);
}

void PrintGetEndpointInfoUsage(void)
{
    dprintf("Usage: \n\tgetendpointinfo [EndpointName]\n");
}

DECLARE_API( getendpointinfo )
{
    int ArgumentNo = 0;
    char *EndpointName = NULL;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or EndpointName
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetEndpointInfoUsage();
                    return;
                    }
                else
                    {
                    EndpointName = arg;
                    }
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetCallInfoUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintEndpointInfo(EndpointName, dprintf);
}

void PrintGetThreadInfoUsage(void)
{
    dprintf("Usage: \n\tgetthreadinfo ProcessID [ThreadID]\n");
}

DECLARE_API( getthreadinfo )
{
    DWORD ProcessID = 0;
    DWORD ThreadID = 0;

    int ArgumentNo = 0;
    BOOL fFirstTime = TRUE;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or EndpointName
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetThreadInfoUsage();
                    return;
                    }
                else
                    {
                    ProcessID = (DWORD)GetExpression(arg);
                    }
                fFirstTime = FALSE;
                break;

            case 1:
                ThreadID = (DWORD)GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetThreadInfoUsage();

            }
        ArgumentNo ++;
        }

    if (fFirstTime)
        {
        dprintf("You must specify at least a process id\n");
        PrintGetThreadInfoUsage();
        return;
        }

    GetAndPrintThreadInfo(ProcessID, ThreadID, dprintf);
}

void PrintGetClientCallInfoUsage(void)
{
    dprintf("Usage: \n\tgetclientcallinfo [CallID|0 [IfStart|0 [ProcNum|FFFF [ProcessID|0]]]]\n");
}

DECLARE_API( getclientcallinfo )
{
    ULONG CallID = 0;
    ULONG IfStart = 0;
    USHORT ProcNum = RPCDBG_NO_PROCNUM_SPECIFIED;
    ULONG ProcessID = 0;
    int ArgumentNo = 0;

    //
    // Interpret options.
    //
    char * arg;

    if (fKD != 0)
        {
        dprintf("This extension command does not work under kd\n");
        return;
        }

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                // either help or CallID
                if ((arg[0] == '?') || ((arg[0] == '-') && (arg[1] == '?')))
                    {
                    PrintGetClientCallInfoUsage();
                    return;
                    }
                else
                    {
                    CallID = (ULONG)GetExpression(arg);
                    }
                break;

            case 1:
                IfStart = (ULONG)GetExpression(arg);
                break;

            case 2:
                ProcNum = (USHORT)GetExpression(arg);
                break;

            case 3:
                ProcessID = (ULONG)GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintGetCallInfoUsage();

            }
        ArgumentNo ++;
        }

    GetAndPrintClientCallInfo(CallID, IfStart, ProcNum, ProcessID, dprintf);
}


DECLARE_API( checkrpcsym )
{
    PVOID FunctionPtr;
    DWORD Data;
    BOOL b;
    BOOL fUnsure = FALSE;
    const int ExpectedDataSize = 3;
    const DWORD ExpectedData[3] = {0x55, 0x8B, 0xEC};
    const int FunctionNamesSize = 2;
    const char *FunctionNames[2] = {"RPCRT4!WS_NewConnection", "RPCRT4!OSF_ADDRESS__NewConnection"};
    int i, FunctionNo;

    for (FunctionNo = 0; FunctionNo < FunctionNamesSize; FunctionNo ++)
        {
        FunctionPtr = (PVOID)GetExpression(FunctionNames[FunctionNo]);
        if (FunctionPtr == NULL)
            {
            dprintf("Cannot find address of %s - RPC symbols are wrong\n",
                FunctionNames[FunctionNo]);
            return;
            }

        b = GetData(HandleToUlong(FunctionPtr), &Data, sizeof(DWORD));
        if (!b)
            {
            // under UM debugger this is bad symbols
            if (fKD == 0)
                {
                dprintf("Cannot access address %x - RPC symbols are wrong\n", FunctionPtr);
                return;
                }
            // in kd this is possible even with valid symbols
            fUnsure = TRUE;
            }
        else
            {
            for (i = 0; i < ExpectedDataSize; i ++)
                {
                if ((Data & 0xFF) != ExpectedData[i])
                    {
                    dprintf("Function %s does not have expected "
                        "contents () - non-X86 architecture or RPC symbols are wrong\n",
                        FunctionNames[FunctionNo], Data & 0xFF, ExpectedData[i]);
                    return;
                    }
                Data >>= 8;
                }
            }
        }

    if (fUnsure)
        {
        dprintf("The correctness of RPC symbols could not be determined conclusively\n");
        }
    else
        {
        dprintf("RPC symbols are correct\n");
        }
}

typedef struct tagCallStackPatternMatch
{
    const char *FunctionBase;
    int ValueOffset;    // 0 if the value is not relative to this symbols, or
                        // any positive/negative if the value is relative to
                        // this symbol
} CallStackPatternMatch;

typedef struct tagStackGroupPattern
{
    CallStackPatternMatch *StackPattern;
    int NumberOfEntries;
} StackGroupPattern;

CallStackPatternMatch WS_CallStack1[] = {{"kernel32!WaitForSingleObjectEx", 0},
                                         {"rpcrt4!UTIL_WaitForSyncIO", 0},
                                         {"rpcrt4!WS_SyncRecv", 0},
                                         {"rpcrt4!WS_SyncRecv", 0},
                                         {"rpcrt4!OSF_CCONNECTION__TransSendReceive", 0},
                                         {"rpcrt4!OSF_CCONNECTION__SendFragment", 0},
                                         {"rpcrt4!OSF_CCALL__SendNextFragment", 0},
                                         {"rpcrt4!OSF_CCALL__FastSendReceive", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceiveHelper", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceive", 0},
                                         {"rpcrt4!I_RpcSendReceive", 0},
                                         {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

CallStackPatternMatch WS_CallStack2[] = {{"kernel32!WaitForSingleObjectEx", 0},
                                         {"rpcrt4!UTIL_WaitForSyncIO", 0},
                                         {"rpcrt4!UTIL_GetOverlappedResultEx", 0},
                                         {"rpcrt4!WS_SyncRecv", 0},
                                         {"rpcrt4!OSF_CCONNECTION__TransSendReceive", 0},
                                         {"rpcrt4!OSF_CCONNECTION__SendFragment", 0},
                                         {"rpcrt4!OSF_CCALL__SendNextFragment", 0},
                                         {"rpcrt4!OSF_CCALL__FastSendReceive", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceiveHelper", 0},
                                         {"rpcrt4!OSF_CCALL__SendReceive", 0},
                                         {"rpcrt4!I_RpcSendReceive", 0},
                                         {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

CallStackPatternMatch NMP_CallStack1[] = {{"kernel32!WaitForSingleObjectEx", 0},
                                          {"rpcrt4!UTIL_WaitForSyncIO", 0},
                                          {"rpcrt4!UTIL_GetOverlappedResultEx", 0},
                                          {"rpcrt4!NMP_SyncSendRecv", 0},
                                          {"rpcrt4!OSF_CCONNECTION__TransSendReceive", 0},
                                          {"rpcrt4!OSF_CCONNECTION__SendFragment", 0},
                                          {"rpcrt4!OSF_CCALL__SendNextFragment", 0},
                                          {"rpcrt4!OSF_CCALL__FastSendReceive", 0},
                                          {"rpcrt4!OSF_CCALL__SendReceiveHelper", 0},
                                          {"rpcrt4!OSF_CCALL__SendReceive", 0},
                                          {"rpcrt4!I_RpcSendReceive", 0},
                                          {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

CallStackPatternMatch LRPC_CallStack1[] = {{"rpcrt4!LRPC_CCALL__SendReceive", 0},
                                           {"rpcrt4!I_RpcSendReceive", 0},
                                           {"rpcrt4!NdrSendReceive", sizeof(PVOID)}};

const int NumberOfWsCallStacks = 2;
StackGroupPattern WS_CallStacks[] = {{WS_CallStack1, 12}, {WS_CallStack2, 12}};

const int NumberOfNmpCallStacks = 1;
StackGroupPattern NMP_CallStacks[] = {{NMP_CallStack1, 12}};

const int NumberOfLrpcCallStacks = 1;
StackGroupPattern LRPC_CallStacks[] = {{LRPC_CallStack1, 3}};

ULONG_PTR Buffer[40];
ULONG_PTR *LastPos = NULL;
int BufferPos = 0;

BOOL VerboseStack = FALSE;

BOOL GetStackValue(ULONG_PTR *CurrentPos, ULONG_PTR *Value)
{
    BOOL Result;

    // if we keep fetching the same data, and we still have data in the
    // buffer, keep going
    if (((CurrentPos - 1) == LastPos) && ((BufferPos + 1) < (sizeof(Buffer) / sizeof(Buffer[0]))))
        {
        LastPos = CurrentPos;
        BufferPos ++;
        *Value = Buffer[BufferPos];
        return TRUE;
        }

    // either we started a new search, or we exhausted the fetched data -
    // fetch new data
    Result = GetData((ULONG_PTR)CurrentPos, Buffer, sizeof(Buffer));
    // there may be not be enough readable data for the whole buffer -
    // switch to slow mode and fetch them one by one
    if (Result == FALSE)
        {
        Result = GetData((ULONG_PTR)CurrentPos, Value, sizeof(ULONG_PTR));
        if (Result == FALSE)
            return FALSE;
        else
            return TRUE;
        }

    // data were successfully fetched to the buffer
    LastPos = CurrentPos;
    BufferPos = 0;
    *Value = Buffer[0];
    return TRUE;
}


BOOL MatchStack(IN PVOID StackStart, IN StackGroupPattern *StackGroup,
                IN int NumberOfElementsInGroup, OUT ULONG_PTR *Value)
{
    int i;
    BOOL Result;
    ULONG_PTR CurrentPos;
    ULONG_PTR CurrentValue;
    ULONG_PTR Displacement;
    int StackPatternPos; // the next stack entry to match
    ULONG_PTR FinalValue = 0;
    int ValueOffset;
    CHAR CurrentName[256];

    for (i = 0; i < NumberOfElementsInGroup; i ++)
        {
        CurrentPos = (ULONG_PTR)StackStart;
        StackPatternPos = 0;
        while (TRUE)
            {
            Result = GetStackValue((ULONG_PTR *)CurrentPos, &CurrentValue);
            if (Result == FALSE)
                goto NextStack;

            GetSymbol((ULONG64)CurrentValue, CurrentName, (PULONG64)&Displacement);
            if (RpcpStringCompareA((const char *)CurrentName, StackGroup[i].StackPattern[StackPatternPos].FunctionBase) == 0)
                {
                if (VerboseStack)
                    {
                    dprintf("Stack: %d: Match with '%s'\n", i, CurrentName);
                    }
                ValueOffset = StackGroup[i].StackPattern[StackPatternPos].ValueOffset;
                if (ValueOffset != 0)
                    {
                    Result = GetData(CurrentPos + ValueOffset, &FinalValue,
                        sizeof(ULONG_PTR));
                    if (Result == FALSE)
                        goto NextStack;
                    }
                StackPatternPos ++;
                if (StackPatternPos >= StackGroup[i].NumberOfEntries)
                    {
                    // full stack match - return success
                    ASSERT(FinalValue != 0);
                    *Value = FinalValue;
                    return TRUE;
                    }
                }

            CurrentPos += sizeof(ULONG_PTR);
            }
NextStack:
        ;
        }
    return FALSE;
}

BOOL GetDataFromRpcMessage(IN ULONG_PTR RpcMessage, OUT ULONG_PTR *CallObject,
                           OUT DWORD *IfStart, OUT USHORT *ProcNum)
{
    BOOL Result;
    union
        {
        RPC_MESSAGE RpcMessage;
        RPC_CLIENT_INTERFACE Interface;
        } MemLoc;
    ULONG_PTR Interface;

    Result = GetData(RpcMessage, (PVOID) &MemLoc.RpcMessage, sizeof(MemLoc.RpcMessage));
    if (Result == FALSE)
        return FALSE;
    *CallObject = (ULONG_PTR)MemLoc.RpcMessage.Handle;
    *ProcNum = (USHORT)MemLoc.RpcMessage.ProcNum;
    Interface = (ULONG_PTR)MemLoc.RpcMessage.RpcInterfaceInformation;
    Result = GetData(Interface, &MemLoc.Interface, sizeof(MemLoc.Interface));
    if (Result == FALSE)
        return FALSE;
    *IfStart = MemLoc.Interface.InterfaceId.SyntaxGUID.Data1;
    return TRUE;
}

BOOL PrintDceBinding(ULONG_PTR DceBindingPointer)
{
    NO_CONSTRUCTOR_TYPE(DCE_BINDING, DceBinding);
    RPC_CHAR *RpcProtocolSequence;
    RPC_CHAR *NetworkAddress;
    RPC_CHAR *Endpoint;
    BOOL Result;

    Result = GetData(DceBindingPointer, DceBinding, sizeof(DCE_BINDING));
    if (Result == FALSE)
        return FALSE;

    RpcProtocolSequence = ReadProcessRpcChar((ULONG64)DceBinding->RpcProtocolSequence);
    NetworkAddress      = ReadProcessRpcChar((ULONG64)DceBinding->NetworkAddress);
    Endpoint            = ReadProcessRpcChar((ULONG64)DceBinding->Endpoint);

    if ((RpcProtocolSequence == NULL) && (NetworkAddress == NULL)
        && (Endpoint == NULL))
        {
        return FALSE;
        }

    dprintf("\tProtocol Sequence: \t\"%ws\"\t(Address: %p)\n", RpcProtocolSequence, DceBinding->RpcProtocolSequence);
    dprintf("\tNetworkAddress:\t\t\"%ws\"\t(Address: %p)\n", NetworkAddress, DceBinding->NetworkAddress);
    dprintf("\tEndpoint:\t\t\"%ws\" \t(Address: %p)\n", Endpoint, DceBinding->Endpoint);

    delete RpcProtocolSequence;
    delete NetworkAddress;
    delete Endpoint;

    return TRUE;
}

BOOL PrintOsfCallInfoFromRpcMessage(ULONG_PTR RpcMessage)
{
    ULONG_PTR CallObject;
    BOOL Result;
    NO_CONSTRUCTOR_TYPE(OSF_CCALL, OsfCCall);
    DWORD CallID;
    DWORD IfStart;
    USHORT ProcNum;
    ULONG_PTR ConnPointer;
    ULONG_PTR AssocPointer;
    ULONG_PTR DceBindingPointer;

    Result = GetDataFromRpcMessage(RpcMessage, &CallObject, &IfStart, &ProcNum);
    if (Result == FALSE)
        return FALSE;

    Result = GetData(CallObject, OsfCCall, sizeof(OSF_CCALL));
    if (Result == FALSE)
        return FALSE;

    CallID = OsfCCall->CallId;
    dprintf("CallID: %d\n", CallID);
    dprintf("IfStart: %x\n", IfStart);
    dprintf("ProcNum: %d\n", (int)ProcNum);

    ConnPointer = (ULONG_PTR)OsfCCall->Connection;
    // get the association pointer
    Result = GetData(ConnPointer + FIELD_OFFSET(OSF_CCONNECTION, Association), &AssocPointer,
        sizeof(ULONG_PTR));
    if (Result == FALSE)
        return FALSE;

    // get the dcebinding pointer
    Result = GetData(AssocPointer + FIELD_OFFSET(OSF_CASSOCIATION, DceBinding), &DceBindingPointer,
        sizeof(ULONG_PTR));
    if (Result == FALSE)
        return FALSE;

    // print the DCE binding info
    PrintDceBinding(DceBindingPointer);

    return TRUE;
}

BOOL PrintLrpcCallInfoFromRpcMessage(ULONG_PTR RpcMessage)
{
    ULONG_PTR CallObject;
    BOOL Result;
    NO_CONSTRUCTOR_TYPE(LRPC_CCALL, LrpcCCall);
    DWORD CallID;
    DWORD IfStart;
    USHORT ProcNum;
    ULONG_PTR AssocPointer;
    ULONG_PTR DceBindingPointer;

    Result = GetDataFromRpcMessage(RpcMessage, &CallObject, &IfStart, &ProcNum);
    if (Result == FALSE)
        return FALSE;

    Result = GetData(CallObject, LrpcCCall, sizeof(LRPC_CCALL));
    if (Result == FALSE)
        return FALSE;

    CallID = LrpcCCall->CallId;
    dprintf("CallID: %d\n", CallID);
    dprintf("IfStart: %x\n", IfStart);
    dprintf("ProcNum: %d\n", (int)ProcNum);

    AssocPointer = (ULONG_PTR)LrpcCCall->Association;

    // get the dcebinding pointer
    Result = GetData(AssocPointer + FIELD_OFFSET(LRPC_CASSOCIATION, DceBinding), &DceBindingPointer,
        sizeof(ULONG_PTR));
    if (Result == FALSE)
        return FALSE;

    // print the DCE binding info
    PrintDceBinding(DceBindingPointer);

    return TRUE;
}

DECLARE_API (rpcreadstack)
{
    PVOID StackStart;
    BOOL Result;
    ULONG_PTR Value;

    LPSTR lpArgumentString = (LPSTR)args;

    StackStart = (PVOID)GetExpression(lpArgumentString);

    // try to match the stack against the different types we support
    // first, try Winsock
    if (VerboseStack)
        {
        dprintf("Matching Winsock stacks\n");
        }
    Result = MatchStack(StackStart, WS_CallStacks, NumberOfWsCallStacks, &Value);
    if (Result == TRUE)
        {
        // call the Winsock stack analysis function
        PrintOsfCallInfoFromRpcMessage(Value);
        return;
        }

    // next, try Named pipes
    if (VerboseStack)
        {
        dprintf("Matching named pipe stacks\n");
        }
    Result = MatchStack(StackStart, NMP_CallStacks, NumberOfNmpCallStacks, &Value);
    if (Result == TRUE)
        {
        // call the named pipe stack analysis function
        PrintOsfCallInfoFromRpcMessage(Value);
        return;
        }

    // next, try LRPC
    if (VerboseStack)
        {
        dprintf("Matching LRPC stacks\n");
        }
    Result = MatchStack(StackStart, LRPC_CallStacks, NumberOfLrpcCallStacks, &Value);
    if (Result == TRUE)
        {
        // call the Lrpc stack analysis function
        PrintLrpcCallInfoFromRpcMessage(Value);
        return;
        }

    dprintf("Not found!\n");
}

DECLARE_API (rpcverbosestack)
{
    VerboseStack = !VerboseStack;
    if (VerboseStack)
        {
        dprintf("Switched to ON\n");
        }
    else
        {
        dprintf("Switched to OFF\n");
        }
}

VOID
do_eerecord(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    unsigned char Buf[sizeof(ExtendedErrorInfo) + sizeof(ExtendedErrorParam) * (MaxNumberOfEEInfoParams - 1)];
    ULONG64 EEInfoAddr;
    BOOL Result;
    int EEInfoSize;
    RPC_CHAR *ComputerNameStr;
    SYSTEMTIME SystemTime;
    int i;

    ULONG64 nLen;
    ULONG64 TimeStamp;
    ULONG64 ComputerName;
    ULONG64 Params;
    ULONG64 ParamType;
    ULONG64 ParamAddr;

    ULONG64 UnicodeStringAddr;
    ULONG64 AnsiStringAddr;
    ULONG64 BlobAddr;
    ULONG64 nLength;
    ULONG64 pString;
  
    char *AnsiBuf;
    RPC_CHAR *UnicodeBuf;

    dprintf("eerecord at 0x%I64x:\n", qwAddr);

    GET_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, nLen, nLen);
    GET_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, TimeStamp, TimeStamp);
    GET_ADDRESS_OF(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Params, Params, tmp2);

    GET_ADDRESS_OF(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, ComputerName, ComputerName, tmp2);
    GET_MEMBER(ComputerName, EEComputerName, RPCRT4!EEComputerName, Type, tmp1);
    if ((ULONG)tmp1 == eecnpPresent)
        {
        GET_ADDRESS_OF(ComputerName, EEComputerName, RPCRT4!EEComputerName, Name, tmp1, tmp2);
        GET_MEMBER(tmp1, EEUString, RPCRT4!EEUString, pString, tmp0);
        ComputerNameStr = ReadProcessRpcChar(tmp0);
        if (ComputerNameStr != NULL)
            {
            dprintf("Computer Name: %S\n", ComputerNameStr);
            delete ComputerNameStr;
            }
        }
    else
        {
        dprintf("Computer Name: (null)\n");
        }

    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, ProcessID, tmp0);
    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Status, tmp0);

    // BUG
    dprintf ("TimeStamp=%I64x\n", TimeStamp);
    Result = FileTimeToSystemTime((FILETIME *)&TimeStamp, &SystemTime);

    if (Result)
        {
        dprintf("System Time is: %d/%d/%d %d:%d:%d:%d\n",
            SystemTime.wMonth,
            SystemTime.wDay,
            SystemTime.wYear,
            SystemTime.wHour,
            SystemTime.wMinute,
            SystemTime.wSecond,
            SystemTime.wMilliseconds);
        }
    else
        {
        dprintf("Couldn't extract system time. Error is %d\n", GetLastError());
        }

    PRINT_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, GeneratingComponent, tmp0);
    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Status, tmp0);
    PRINT_MEMBER_DECIMAL_AND_HEX(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, DetectionLocation, tmp0);
    GET_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Flags, tmp0);
    dprintf("Flags: %S %S\n",
        tmp0 & EEInfoPreviousRecordsMissing ? "Previous Record Missing" : "",
        tmp0 & EEInfoNextRecordsMissing ? "Next Record Missing" : "");

    dprintf("nLen = %d\n", (int)nLen);

    ParamAddr = Params;

    for (i = 0; i < (int)nLen; i++)
        {
        dprintf("Parameter %d:", i);

        GET_MEMBER(ParamAddr, tagParam, RPCRT4!tagParam, Type, ParamType);

        switch((ULONG)ParamType)
            {
            case eeptiAnsiString:

                dprintf("(Ansi string) : ");

                GET_ADDRESS_OF(ParamAddr, tagParam, RPCRT4!tagParam, AnsiString, AnsiStringAddr, tmp2);
                GET_MEMBER(AnsiStringAddr, tagEEAString, RPCRT4!tagEEAString, nLength, nLength);
                GET_MEMBER(AnsiStringAddr, tagEEAString, RPCRT4!tagEEAString, pString, pString);

                // we know the length - use GetData
                AnsiBuf = new char [(unsigned)nLength];
                if (AnsiBuf != NULL)
                    {
                    Result = GetData(pString,
                        AnsiBuf,
                        (ULONG)nLength);
                    if (Result)
                        {
                        dprintf("%s\n", AnsiBuf);
                        }
                    // else
                    // error info has already been printed - nothing to do
                    delete AnsiBuf;
                    }
                break;

            case eeptiUnicodeString:
  
                dprintf("(Unicode string) : ");

                GET_ADDRESS_OF(ParamAddr, tagParam, RPCRT4!tagParam, UnicodeString, UnicodeStringAddr, tmp2);
                GET_MEMBER(UnicodeStringAddr, tagEEAString, RPCRT4!tagEEAString, nLength, nLength);
                GET_MEMBER(UnicodeStringAddr, tagEEAString, RPCRT4!tagEEAString, pString, pString);

                // we know the length - use GetData
                UnicodeBuf = new RPC_CHAR [(unsigned)nLength];
                if (UnicodeBuf != NULL)
                    {
                    Result = GetData(pString,
                        UnicodeBuf,
                        (ULONG)(nLength * sizeof(RPC_CHAR)));
                    if (Result)
                        {
                        dprintf("%S\n", UnicodeBuf);
                        }
                    // else
                    // error info has already been printed - nothing to do
                    delete UnicodeBuf;
                    }
                break;

            case eeptiLongVal:
                PRINT_MEMBER_DECIMAL_AND_HEX(ParamAddr, tagParam, RPCRT4!tagParam, LVal, tmp0);
                break;

            case eeptiShortVal:
                PRINT_MEMBER_DECIMAL_AND_HEX(ParamAddr, tagParam, RPCRT4!tagParam, IVal, tmp0);
                break;

            case eeptiPointerVal:
                PRINT_MEMBER_DECIMAL_AND_HEX(ParamAddr, tagParam, RPCRT4!tagParam, PVal, tmp0);
                break;

            case eeptiNone:
                dprintf("(Truncated value)\n");
                break;

            case eeptiBinary:
                dprintf("(Binary value:)\n");
                GET_ADDRESS_OF(ParamAddr, tagParam, RPCRT4!tagParam, Blob, BlobAddr, tmp2);
                PRINT_MEMBER_DECIMAL_AND_HEX(BlobAddr, tagBinaryEEInfo, RPCRT4!tagBinaryEEInfo, nSize, tmp0);
                PRINT_MEMBER_DECIMAL_AND_HEX(BlobAddr, tagBinaryEEInfo, RPCRT4!tagBinaryEEInfo, pBlob, tmp0);
                break;

            default:
                dprintf("Invalid type: %d\n", (ULONG)ParamType);
            }

        ParamAddr += GET_TYPE_SIZE(tagParam, RPCRT4!tagParam);
        }
}

VOID
do_eeinfo(
    ULONG64 qwAddr
    )
{
    ULONG64 PrevNextElement = qwAddr;
    ULONG64 NextElement = qwAddr;
    ULONG64 FirstElement = qwAddr;
    BOOL Result;

    do
        {
        do_eerecord(NextElement);

        PrevNextElement = NextElement; 
        GET_MEMBER(qwAddr, ExtendedErrorInfo, RPCRT4!ExtendedErrorInfo, Next, NextElement);
 
        // prevent loops
        if (NextElement == FirstElement)
            {
            dprintf("Loop detected - exitting ...\n");
            return;
            }
        dprintf("------------------------\n");
        }
    while(NextElement != 0 && PrevNextElement != NextElement);
}

VOID PrintTypeinfoUsage(VOID) {
    dprintf("Wrong arguments to !rpcexts.typeinfo\n");
    dprintf("Please use !rpcexts.typeinfo on|off\n");
}

DECLARE_API (typeinfo)
{
    LPSTR lpArgumentString = (LPSTR)args;

    if (strcmp(lpArgumentString, "on") == 0)
        fUseTypeInfo = TRUE;
    else if (strcmp(lpArgumentString, "off") == 0)
        fUseTypeInfo = FALSE;
    else if (strcmp(lpArgumentString, "") == 0)
        {
        if (fUseTypeInfo == TRUE)
            dprintf ("typeinfo use is on\n");
        else
            dprintf ("typeinfo use is off\n");
        }
    else
        PrintTypeinfoUsage();

    return;
}


VOID PrintStackMatchUsage(VOID) {
    dprintf("Wrong arguments to !rpcexts.stackmatch");
    dprintf("Please use !rpcexts.stackmatch start_addr [depth]\n");
}


DECLARE_API( stackmatch )
{
    static ULONG64 Start;
    static ULONG Depth = 0x80;

    CHAR Symbol[128];
    ULONG64 Displacement = 0;

    //
    // Interpret options.
    //
    ULONG ProcessID = 0;
    int ArgumentNo = 0;
    DebugCellID CellID;
    char *DotSeparator;

    //
    // Interpret options.
    //
    char * arg;

    LPSTR lpArgumentString = (LPSTR)args;

    for (arg=strtok(lpArgumentString); arg; arg = strtok(0))
        {
        switch(ArgumentNo)
            {
            case 0:
                Start = GetExpression(arg);
                break;

            case 1:
                Depth = (ULONG) GetExpression(arg);
                break;

            default:
                dprintf("Too many arguments\n");
                PrintStackMatchUsage();

            }
        ArgumentNo ++;
        }

    for (ULONG64 Addr=Start; Addr<=Start+Depth; Addr+=AddressSize) {
        ULONG64 Val;
        ReadPtr(Addr, &Val);
        dprintf("%I64p  %I64p", Addr, Val);

        GetSymbol(Val, Symbol, &Displacement);
        if (strcmp(Symbol, "") != 0)
            dprintf(" %s+%x", Symbol, Displacement);
        else {
            ULONG64 Obj;
            ReadPtr(Val, &Obj);

            if (Obj) {
                dprintf(" -> %I64p", Obj);
                GetSymbol(Obj, Symbol, &Displacement);
                if (strcmp(Symbol, "") != 0)
                    dprintf(" %s+%x", Symbol, Displacement);
            }
        }

        dprintf("\n");
    }

    Start = Addr;
}

DECLARE_API( listcalls )
{
    ULONG64 qwAddr;
    BOOL fArgSpecified = FALSE;
    ULONG64 ServerAddress;

    LPSTR lpArgumentString = (LPSTR)args;

    if (0 == strtok(lpArgumentString))
        {
        lpArgumentString = "rpcrt4!GlobalRpcServer";
        fArgSpecified = TRUE;
        }

    qwAddr = GetExpression(lpArgumentString);

    if ( !qwAddr )
        {
        dprintf("Error: can't evaluate '%s'\n", lpArgumentString);
        return;
        }

    if (fArgSpecified)
        {
        if (ReadPtr(qwAddr, &ServerAddress))
            {
            dprintf("couldn't read memory at address 0x%I64x\n", qwAddr);
            return;
            }
        }
    else
        ServerAddress = qwAddr;

    do_listcalls(ServerAddress);
}

VOID LoopThroughDict(ULONG64 Dict, PCHAR offset) {
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    ULONG64 cDictSize;
    ULONG64 cDictSlots;
    ULONG64 DictSlots;
    int j;
    ULONG64 DictSlot;

    GET_MEMBER(Dict, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSize, cDictSize);
    GET_MEMBER(Dict, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, cDictSlots, cDictSlots);

    if ((ULONG)cDictSize > (ULONG)cDictSlots)
        {
        dprintf("Bad dictionary\t\t- %I64p\n", Dict);
        return;
        }

    GET_MEMBER(Dict, SIMPLE_DICT, RPCRT4!SIMPLE_DICT, DictSlots, DictSlots);

    dprintf("%sPrinting %d items in dictionary: %I64p with %d slots\n\n", offset, (ULONG)cDictSize, Dict, (ULONG)cDictSlots);

    // Loop throught the associations.
    for (j = 0; j < MIN((int)cDictSize, MAX_ITEMS_IN_DICTIONARY); j++)
        {
        ReadPtr(DictSlots + j * AddressSize, &DictSlot);
        dprintf ("%s(%d): 0x%I64x - ", offset, j, DictSlot);

        ULONG64 MagicValue;
        ULONG64 ObjectType;
        ULONG64 Dict;

        ReadPtr(DictSlot+AddressSize, &MagicValue);
        ReadPtr(DictSlot+AddressSize+4, &ObjectType);

        if ((ULONG)MagicValue != MAGICLONG)
            {
            dprintf("Bad or deleted object at %p\n", DictSlot);
            }

        switch (((ULONG)ObjectType) & (~OBJECT_DELETED))
            {
            case DG_ADDRESS_TYPE:
                dprintf("DG_ADDRESS\n");
                break;

            case OSF_ADDRESS_TYPE:
                dprintf("OSF_ADDRESS\n");

                GET_ADDRESS_OF(DictSlot, OSF_ADDRESS, RPCRT4!OSF_ADDRESS, Associations, Dict, tmp2);

                LoopThroughDict(Dict, "\t\t");

                break;

            case LRPC_ADDRESS_TYPE:
                dprintf("LRPC_ADDRESS\n");

                GET_ADDRESS_OF(DictSlot, LRPC_ADDRESS, RPCRT4!LRPC_ADDRESS, AssociationDictionary, Dict, tmp2);

                LoopThroughDict(Dict, "\t\t");

                break;

            case OSF_ASSOCIATION_TYPE:
                dprintf("OSF_ASSOCIATION_TYPE\n");

                break;

            case LRPC_SASSOCIATION_TYPE:
                dprintf("LRPC_SASSOCIATION_TYPE\n");

                break;

            default:
                dprintf("The RPC object type is 0x%lx and I don't recognize it.\n", (ObjectType) & ~(OBJECT_DELETED));
            }    
        }
}

VOID
do_listcalls(
    ULONG64 qwAddr
    )
{
    ULONG64 tmp0;
    ULONG64 tmp1;
    ULONG tmp2;

    dprintf("\n");

    dprintf("RPC_SERVER at 0x%I64x\n", qwAddr);

    ULONG64 RpcAddressDictionary;
    GET_ADDRESS_OF(qwAddr, RPC_SERVER, RPCRT4!RPC_SERVER, RpcAddressDictionary, RpcAddressDictionary, tmp2);
    dprintf("&RpcAddressDictionary(RPC_SIMPLE_DICT) - 0x%I64x\n", RpcAddressDictionary);

    LoopThroughDict(RpcAddressDictionary, "\t");

    dprintf("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\astub.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    asyncstub.h

Abstract:

    This is the generated header file

--*/


void
Foo (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int sizein,
    /* [in] */ int *bufferin,
    /* [in, out] */ int *sizeout,
    /* [out] */ int **bufferout
    ) ;

//
// Begin, Generated header file
// declare the pipe structure
typedef struct {
    void *state ;
    RPC_STATUS (*PipeReceive) (
                               PRPC_ASYNC_STATE pAsync,
                               int *buffer,
                               int requested_count,
                               int *actual_count) ;
    RPC_STATUS (*PipeSend) (
                            PRPC_ASYNC_STATE pAsync,
                            void *context,
                            int *buffer,
                            int num_elements) ;
    } async_intpipe ;

void
FooPipe (
    PRPC_ASYNC_STATE pAsync,
    RPC_BINDING_HANDLE hBinding,
    /* [in] */ int checksum_in,
    /* [in] */ async_intpipe *inpipe,
    /* [out] */ async_intpipe *outpipe,
    /* [out] */ int *checksum_out) ;


#define APP_ERROR          0xBABE000L
#define SYNC_EXCEPT      APP_ERROR+1
#define ASYNC_EXCEPT    APP_ERROR+2

#define UUID_TEST_CANCEL     10
#define UUID_SLEEP_1000      11
#define UUID_EXTENDED_ERROR  12
#define UUID_ASYNC_EXCEPTION 13
#define UUID_SYNC_EXCEPTION  14
#define UUID_SLEEP_2000      15
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\align.h ===
/*++

Copyright (C) Microsoft Corporation, 1995 - 1999

Module Name:

    Align.h

Abstract:

    Defines a macro for aligning an integer value or pointer
    to 0 mod 2^n for any n.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     12-22-95    Bits 'n pieces
    MarioGo     02-19-96    Made type safe for C++.

--*/

#ifndef _ALIGN_H
#define _ALIGN_H

#ifdef __cplusplus

//
// The C++ interface looks like
//
//  val = Align(val, 8)  // returns val aligned to 0 mod 8
//  val = Align16(val);  // returns val aligned to 0 mod 16
//
//  Boths forms on the interface are equally efficient.
//
//  Returns the argument aligned up to the nearest "0 mod factor" boundary.  Has
//  no affect on values which are already aligned to 0 mod factor.  The argument
//  maybe any integer or void pointer type.
//
//

#define DECL_ALIGN_N(type) inline type Align( type value, int poft)       \
    {                                                                     \
    return (type)( ((unsigned long)(value) + ((poft)-1)) & ~(poft - 1) );     \
    }

#define DECL_ALIGN(poft, type) inline type Align##poft ( type value )     \
    {                                                                     \
    return Align(value, poft);                                            \
    }

#define DECL_PAD_N(type) inline unsigned int Pad( type value, int poft )  \
    {                                                                     \
    return (-(long)value) & (poft - 1);                                   \
    }

#define DECL_PAD(poft, type) inline unsigned int Pad##poft (type value)   \
    {                                                                     \
    return Pad(value, poft);                                              \
    }

// same padding, but on pointer type size of argument
#define DECL_ALIGN_PTR_N(type) inline type AlignPtr( type value, int poft)       \
    {                                                                     \
    return (type)( ((ULONG_PTR)(value) + ((poft)-1)) & ~(poft - 1) );     \
    }

#define DECL_ALIGN_PTR(poft, type) inline type AlignPtr##poft ( type value )     \
    {                                                                     \
    return AlignPtr(value, poft);                                            \
    }

#define DECL_PAD_PTR_N(type) inline unsigned int PadPtr( type value, int poft )  \
    {                                                                     \
    return (unsigned int)((-(LONG_PTR)value) & (poft - 1));                       \
    }

#define DECL_PAD_PTR(poft, type) inline unsigned int PadPtr##poft (type value)   \
    {                                                                     \
    return PadPtr(value, poft);                                              \
    }

#define DECL_ALL_ALIGN(type)     \
    DECL_ALIGN_N(type)           \
    DECL_ALIGN(2, type)          \
    DECL_ALIGN(4, type)          \
    DECL_ALIGN(8, type)          \
    DECL_ALIGN(16, type)         \
    DECL_ALIGN(32, type)

#define DECL_ALL_PAD(type)       \
    DECL_PAD_N(type)             \
    DECL_PAD(2, type)            \
    DECL_PAD(4, type)            \
    DECL_PAD(8, type)            \
    DECL_PAD(16, type)           \
    DECL_PAD(32, type)

#define DECL_ALL_ALIGN_PTR(type)     \
    DECL_ALIGN_PTR_N(type)           \
    DECL_ALIGN_PTR(2, type)          \
    DECL_ALIGN_PTR(4, type)          \
    DECL_ALIGN_PTR(8, type)          \
    DECL_ALIGN_PTR(16, type)         \
    DECL_ALIGN_PTR(32, type)

#define DECL_ALL_PAD_PTR(type)       \
    DECL_PAD_PTR_N(type)             \
    DECL_PAD_PTR(2, type)            \
    DECL_PAD_PTR(4, type)            \
    DECL_PAD_PTR(8, type)            \
    DECL_PAD_PTR(16, type)           \
    DECL_PAD_PTR(32, type)

#define DECL_ALL_ALIGN_AND_PAD(type) \
    DECL_ALL_PAD(type)               \
    DECL_ALL_ALIGN(type)

#define DECL_ALL_ALIGN_AND_PAD_PTR(type) \
    DECL_ALL_PAD_PTR(type)               \
    DECL_ALL_ALIGN_PTR(type)

DECL_ALL_ALIGN_AND_PAD(short)
DECL_ALL_ALIGN_AND_PAD(unsigned short)
DECL_ALL_ALIGN_AND_PAD(long)
DECL_ALL_ALIGN_AND_PAD(unsigned long)
DECL_ALL_ALIGN_AND_PAD(int)
DECL_ALL_ALIGN_AND_PAD(unsigned int)
DECL_ALL_ALIGN_AND_PAD_PTR(void __RPC_FAR *)

#ifdef _WIN64
DECL_ALL_ALIGN_AND_PAD(unsigned __int64)
#endif

inline BOOL IsBufferAligned(PVOID p)
{
#if defined(_WIN64)
    return (((ULONG_PTR)p % 16) == 0);
#else
    return (((ULONG_PTR)p % 8) == 0);
#endif    
}

inline BOOL IsBufferSizeAligned(size_t s)
{
#if defined(_WIN64)
    return ((s % 16) == 0);
#else
    return ((s % 8) == 0);
#endif    
}

inline unsigned int PadToNaturalBoundary (unsigned int Value)
{
#if defined(_WIN64)
    return Pad16(Value);
#else
    return Pad8(Value);
#endif    
}

inline PVOID AlignOnNaturalBoundary (PVOID Value)
{
#if defined(_WIN64)
    return AlignPtr16(Value);
#else
    return AlignPtr8(Value);
#endif    
}

// required for global constant expressions
#define ConstPadN(p, poft) ( (-(long)p) & (poft - 1) )

#if defined(_WIN64)
#define RPCRT_DEFAULT_STRUCT_ALIGNMENT  8
#else
#define RPCRT_DEFAULT_STRUCT_ALIGNMENT  4
#endif

#define SIZE_OF_OBJECT_AND_PADDING(ObjectType) \
    (sizeof(ObjectType) + ConstPadN(sizeof(ObjectType), RPCRT_DEFAULT_STRUCT_ALIGNMENT))

#else

// C interface.

#define AlignN(p, poft) ( ((unsigned long)(p) + ((poft)-1)) & ~(poft - 1) )
#define PadN(p, poft) ( (-(long)p) & (poft - 1) )

#ifdef DOS
#define AlignPtrN(value, poft) (void __far *)AlignN(value, poft)
#define AlignNearPtrN(value, poft) (void __near *)AlignN(value, poft)
#else
#define AlignPtrN(value, poft) (void *)AlignN(value, poft)
#define AlignNearPtrN(value, poft) (void *)AlignN(value, poft)
#endif

// For aligning integer values

#define Align2(p) AlignN((p), 2)
#define Align4(p) AlignN((p), 4)
#define Align8(p) AlignN((p), 8)
#define Align16(p) AlignN((p), 16)
#define Align32(p) AlignN((p), 32)

// For aligning pointers

#define AlignPtr2(p) AlignPtrN((p), 2)
#define AlignPtr4(p) AlignPtrN((p), 4)
#define AlignPtr8(p) AlignPtrN((p), 8)
#define AlignPtr16(p) AlignPtrN((p), 16)
#define AlignPtr32(p) AlignPtrN((p), 32)

// For near pointers
#define AlignNearPtr2(p) AlignNearPtrN((p), 2)
#define AlignNearPtr4(p) AlignNearPtrN((p), 4)
#define AlignNearPtr8(p) AlignNearPtrN((p), 8)
#define AlignNearPtr16(p) AlignNearPtrN((p), 16)
#define AlignNearPtr32(p) AlignNearPtrN((p), 32)

// For everything
#define Pad2(p) PadN((p), 2)
#define Pad4(p) PadN((p), 4)
#define Pad8(p) PadN((p), 8)
#define Pad16(p) PadN((p), 16)
#define Pad32(p) PadN((p), 32)

#endif // __cplusplus

#endif // _ALIGN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\async.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       async.cxx
//
//--------------------------------------------------------------------------

#include <precomp.hxx>


RPC_STATUS RPC_ENTRY
RpcAsyncRegisterInfo (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++

Routine Description:

 Obsolete function - just an entry point.

Return Value:

--*/

{
#if !defined(_M_IA64)
    return RPC_S_OK ;
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}


RPC_STATUS RPC_ENTRY
RpcAsyncCancelCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN BOOL fAbort 
    )
/*++
Function Name:RpcAsyncCancelCall

Parameters:

Description:

Returns:

--*/
{
    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) pAsync->RuntimeInfo;

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (MObject)
        {
        if (MObject->InvalidHandle(CALL_TYPE))
            {
            return (RPC_S_INVALID_BINDING);
            }

        return ((CALL *) MObject)->CancelAsyncCall(fAbort);
        }

    return (RPC_S_INVALID_BINDING);
}
    


RPC_STATUS RPC_ENTRY
RpcAsyncGetCallStatus (
    IN PRPC_ASYNC_STATE pAsync
    )
/*++ 

Routine Description:

 description

Arguments:

 pAsync -

Return Value:

 RPC_S_OK - Function succeeded
 RPC_S_OUT_OF_MEMORY - we ran out of memory

--*/
{
    MESSAGE_OBJECT *MObject = (MESSAGE_OBJECT *) pAsync->RuntimeInfo;

    if (MObject)
        {
        if (MObject->InvalidHandle(CALL_TYPE))
            {
            return (RPC_S_INVALID_BINDING);
            }

        return ((CALL *) MObject)->GetCallStatus() ;
        }

    return RPC_S_INVALID_BINDING;
}


VOID APIENTRY
I_RpcAPCRoutine (
    IN RPC_APC_INFO *pAPCInfo
    )
{
    PRPC_ASYNC_STATE pAsync = pAPCInfo->pAsync;
    void *Context = pAPCInfo->Context;
    RPC_ASYNC_EVENT Event = pAPCInfo->Event;
    PFN_RPCNOTIFICATION_ROUTINE pRoutine = 
                pAPCInfo->pAsync->u.APC.NotificationRoutine;

    ((CALL *) pAPCInfo->hCall)->FreeAPCInfo(pAPCInfo) ;
    
    (*pRoutine) (pAsync, Context, Event) ;

    //
    // We cannot do anything after the call to the user's API routine. The
    // may be gone 
    //
}


///////////////////////////////////////////////////////
//                    Routines owned by NDR                      //
///////////////////////////////////////////////////////
//
//
//  RpcAsyncAbortCall
//  RpcAsyncCompleteCall
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\bitset.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       bitset.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : bitset.cxx

Title : Bit vector implementation of a set.

History :

mikemon    ??-??-??    Beginning of recorded history.
mikemon    11-13-90    Commented the source.

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <bitset.hxx>

int
BITSET::Insert (
    IN int Key
    )
{
    unsigned int * pNewBits;
    int cCount;

    //
    // Check if the Key will fit into the current bit vector.
    //

    if ((int) ((Key/(sizeof(int)*8))+1) > cBits)
        {
        //
        // We need more space in the bit vector, so allocate enough space 
        // to hold the bit for the specified key, copy the old bit vector into the 
        // new bit vector, and then free the old one.
        //

        pNewBits = new unsigned int [Key/(sizeof(int)*8)+1];
        if (pNewBits == (unsigned int *) 0)
            return(1);

        for (cCount = 0; cCount < cBits; cCount++)
            pNewBits[cCount] = pBits[cCount];

        cBits = Key/(sizeof(int)*8) + 1;

        for ( ; cCount < cBits; cCount++)
            pNewBits[cCount] = 0;

        if (pBits != &InitialStorage)
            delete pBits;
        pBits = pNewBits;
        }

    //
    // Turn on the appropriate bit, by ORing it in.
    //
    pBits[Key/(sizeof(int)*8)] |= (1 << (Key % (sizeof(int)*8)));
    return(0);
}

void
BITSET::Delete (
    IN int Key
    )
{
    if ((int) (Key/(sizeof(int)*8)) > cBits-1)
        return;

    //
    // Turn off the appropriate bit, by ANDing in the complement.
    //
    pBits[Key/(sizeof(int)*8)] &= ~(1 << (Key % (sizeof(int)*8)));
}

int
BITSET::MemberP (
    IN int Key
    )
{
    if ((int) (Key/(sizeof(int)*8)) > cBits-1)
        return(0);

    //
    // Test for the appropriate bit
    //
    return(((pBits[Key/(sizeof(int)*8)]
            & (1 << (Key % (sizeof(int)*8)))) ? 1 : 0));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\bcache.cxx ===
/*++

    Copyright (C) Microsoft Corporation, 1997 - 1999

    Module Name:

        bcache.cxx

    Abstract:

        RPC's buffer cache implementation

    Author:

        Mario Goertzel    [MarioGo]

    Revision History:

        MarioGo     9/7/1997    Bits 'n pieces
        KamenM      5/15/2001   Rewrite the paged bcache implementation

--*/

#include <precomp.hxx>

////////////////////////////////////////////////////////////
// (Internal) Perf counters
//#define BUFFER_CACHE_STATS

#ifdef BUFFER_CACHE_STATS
LONG cAllocs = 0;
LONG cFrees = 0;
LONG cAllocsMissed = 0;
LONG cFreesBack = 0;

#define INC_STAT(x) InterlockedIncrement(&x)

#else
#define INC_STAT(x)
#endif

////////////////////////////////////////////////////////////

typedef BCACHE_STATE *PBCTLS;

////////////////////////////////////////////////////////////
// Default (non-Guard Page mode) hints

CONST BUFFER_CACHE_HINTS gCacheHints[4] =
{
    // 64 bits and WOW6432 use larger message size
#if defined(_WIN64) || defined(USE_LPC6432)
    {1, 4, 512},      // LRPC message size and small calls
#else
    {1, 4, 256},      // LRPC message size and small calls
#endif
    {1, 3, 1024},     // Default CO receive size
    {1, 3, 4096+44},  // Default UDP receive size
    {1, 3, 5840}      // Maximum CO fragment size
};

// Guard page mode hints.  Note that the sizes are updated during
// init to the real page size.

BUFFER_CACHE_HINTS gPagedBCacheHints[4] =
{
    {1, 4, 4096 - sizeof(BUFFER_HEAD)},     // Forced to 1 page - header during init
    {1, 3, 8192 - sizeof(BUFFER_HEAD)},     // Forced to 2 pages - header during init
    {0, 0, 0},        // Not used
    {0, 0, 0}         // Not used
};

BUFFER_CACHE_HINTS *pHints = (BUFFER_CACHE_HINTS *)gCacheHints;
BOOL fPagedBCacheMode = FALSE;
BCACHE *gBufferCache;

static const RPC_CHAR *PAGED_BCACHE_KEY = RPC_CONST_STRING("Software\\Microsoft\\Rpc\\PagedBuffers");

const size_t PagedBCacheSectionSize = 64 * 1024;    // 64K

#if DBG
#define ASSERT_VALID_PAGED_BCACHE   (VerifyPagedBCacheState())
#else   // DBG
#define ASSERT_VALID_PAGED_BCACHE
#endif  // DBG

// uncomment this for full verification. Note that it generates many first
// time AVs in the debugger (benign but annoying)
//#define FULL_PAGED_BCACHE_VERIFY


BCACHE::BCACHE( OUT RPC_STATUS &status)
    // The default process heap lock spin count. This lock is held only
    // for a very short time while pushing/poping into a singly linked list.

    // PERF: move to a user-mode slist implementation if available.
    : _csBufferCacheLock(&status, TRUE, 4000)
{
    // Determine guard page mode (or not)

    HKEY h = 0;
    DWORD statusT = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                                  (PWSTR)PAGED_BCACHE_KEY,
                                  0,
                                  KEY_READ,
                                  &h);

    if (statusT != ERROR_FILE_NOT_FOUND)
        {
        // paged bcache mode!

        fPagedBCacheMode = TRUE;
        gPagedBCacheHints[0].cSize = gPageSize - sizeof(BUFFER_HEAD);
        gPagedBCacheHints[1].cSize = 2 * gPageSize - sizeof(BUFFER_HEAD);
        pHints = gPagedBCacheHints;
        RpcpInitializeListHead(&Sections);

        if (h)
            {
            RegCloseKey(h);
            }
        }

    // Compute the per cache size default buffer cache cap.
    // This only matters for the default mode.
    UINT cCapBytes = 20 * 1024;  // Start at 20KB for UP workstations.
                              
    if (gfServerPlatform) cCapBytes *= 2;            // *2 for servers
    if (gNumberOfProcessors > 1) cCapBytes *= 2;    // *2 for MP boxes

    for (int i = 0; i < 4; i++)
        {
        _bcGlobalState[i].cBlocks= 0;
        _bcGlobalState[i].pList = 0;

        if (fPagedBCacheMode)
            {
            _bcGlobalStats[i].cBufferCacheCap = 0;
            _bcGlobalStats[i].cAllocationHits = 0;
            _bcGlobalStats[i].cAllocationMisses = 0;
            }
        else
            {
            _bcGlobalStats[i].cBufferCacheCap = cCapBytes / pHints[i].cSize;

            // We keeps stats on process wide cache hits and misses from the
            // cache.  We initially give credit for 2x allocations required
            // to load the cache.  Any adjustments to the cap, up only, occur
            // in ::FreeHelper.

            _bcGlobalStats[i].cAllocationHits = _bcGlobalStats[i].cBufferCacheCap * 2*8;
            _bcGlobalStats[i].cAllocationMisses = 0;
            }
        }

    return;
}

BCACHE::~BCACHE()
{
    // There is only one and it lives forever.
    ASSERT(0);
}

PVOID
BCACHE::Allocate(CONST size_t cSize)
{
    PBUFFER pBuffer;
    int index;

    INC_STAT(cAllocs);

    // Find the right bucket, if any.  Binary search.

    if (cSize <= pHints[1].cSize)
        {
        if (cSize <= pHints[0].cSize)
            {
            index = 0;
            }
        else
            {
            index = 1;
            }
        }
    else
        {
        if (cSize <= pHints[2].cSize)
            {
            index = 2;
            }
        else
            {
            if (cSize <= pHints[3].cSize)
                {
                index = 3;
                }
            else
                {
                return(AllocHelper(cSize, 
                    -1,     // Index
                    0       // per thread cache
                    ));
                }
            }
        }

    // Try the per-thread cache, this is the 90% case
    THREAD *pThread = RpcpGetThreadPointer();
    ASSERT(pThread);
    PBCTLS pbctls = pThread->BufferCache;

    if (pbctls[index].pList)
        {
        // we shouldn't have anything in the thread cache in paged bcache mode
        ASSERT(fPagedBCacheMode == FALSE);
        ASSERT(pbctls[index].cBlocks);

        pBuffer = pbctls[index].pList;
        pbctls[index].pList = pBuffer->pNext;
        pbctls[index].cBlocks--;

        pBuffer->index = index + 1;

        LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);

        return((PVOID)(pBuffer + 1));
        }

    // This is the 10% case

    INC_STAT(cAllocsMissed);

    return(AllocHelper(cSize, index, pbctls));

}

PVOID
BCACHE::AllocHelper(
    IN size_t cSize,
    IN INT index,
    PBCTLS pbctls
    )
/*++

Routine Description:

    Called by BCACHE:Alloc on either large buffers (index == -1)
    or when the per-thread cache is empty.

Arguments:

    cSize - Size of the block to allocate.
    index - The bucket index for this size of block
    pbctls - The per-thread cache, NULL iff index == -1.

Return Value:

    0 - out of memory
    non-zero - A pointer to a block at least 'cSize' bytes long. The returned
    pointer is to the user portion of the block.

--*/
{
    PBUFFER pBuffer = NULL;
    LIST_ENTRY *CurrentListEntry;
    PAGED_BCACHE_SECTION_MANAGER *CurrentSection;
    ULONG SegmentIndex;
    BOOL fFoundUncommittedSegment;
    ULONG TargetSegmentSize;
    PVOID SegmentStartAddress;
    PVOID pTemp;
    BOOL Result;

    // Large buffers are a special case
    if (index == -1)
        {
        pBuffer = AllocBigBlock(cSize);

        if (pBuffer)
            {
            LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);
            return((PVOID(pBuffer + 1)));
            }

        LogEvent(SU_BCACHE, EV_BUFFER_FAIL, 0, 0, index, 1);
        return(0);
        }

    // in paged bcache mode directly try to allocate. We favor
    // full release over speed in order to catch the offenders
    // who touch memory after releasing it.
    if (fPagedBCacheMode)
        {
        ASSERT_VALID_PAGED_BCACHE;

        // Guard page mode, take care of allocations.

        ASSERT(index == 0 || index == 1);

        // First, try to get an existing section to commit something more
        fFoundUncommittedSegment = FALSE;
        TargetSegmentSize = gPageSize * (index + 1);

        _csBufferCacheLock.Request();
        CurrentListEntry = Sections.Flink;
        while (CurrentListEntry != &Sections)
            {
            CurrentSection = CONTAINING_RECORD(CurrentListEntry, 
                PAGED_BCACHE_SECTION_MANAGER,
                SectionList);

            // if the section is with the same segment size as the one we need
            // and it has free segments, use it
            if (
                (CurrentSection->SegmentSize == TargetSegmentSize)
                &&
                (CurrentSection->NumberOfUsedSegments < CurrentSection->NumberOfSegments)
               )
                {
                break;
                }

            CurrentListEntry = CurrentListEntry->Flink;
            }

        if (CurrentListEntry != &Sections)
            {
            // we found something. Grab a segment, mark it as busy and attempt
            // to commit it outside the critical section
            for (SegmentIndex = 0; SegmentIndex < CurrentSection->NumberOfSegments; SegmentIndex ++)
                {
                if (CurrentSection->SegmentBusy[SegmentIndex] == FALSE)
                    break;
                }

            // we must have found something here. Otherwise the counters are off
            ASSERT(SegmentIndex < CurrentSection->NumberOfSegments);

            CurrentSection->SegmentBusy[SegmentIndex] = TRUE;
            CurrentSection->NumberOfUsedSegments ++;
            fFoundUncommittedSegment = TRUE;
            }

        _csBufferCacheLock.Clear();

        if (fFoundUncommittedSegment)
            {
            SegmentStartAddress = (PBYTE)CurrentSection->VirtualMemorySection 
                + (CurrentSection->SegmentSize + gPageSize) * SegmentIndex;

            pBuffer = (PBUFFER)CommitSegment(SegmentStartAddress,
                CurrentSection->SegmentSize
                );

            if (pBuffer == NULL)
                {
                _csBufferCacheLock.Request();
                CurrentSection->SegmentBusy[SegmentIndex] = FALSE;
                CurrentSection->NumberOfUsedSegments --;
                _csBufferCacheLock.Clear();

                LogEvent(SU_BCACHE, EV_BUFFER_FAIL, 0, 0, index, 1);

                ASSERT_VALID_PAGED_BCACHE;

                return NULL;
                }

            pBuffer = (PBUFFER)PutBufferAtEndOfAllocation(
                pBuffer,    // Allocation
                CurrentSection->SegmentSize,    // AllocationSize
                cSize + sizeof(BUFFER_HEAD)     // BufferSize
                );

            pBuffer->SectionManager = CurrentSection;
            pBuffer->index = index + 1;

            ASSERT_VALID_PAGED_BCACHE;

            LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);

            ASSERT(IsBufferAligned(pBuffer));

            return (PVOID)(pBuffer + 1);
            }

        // we didn't find any section with uncommitted segments. Try to create
        // new sections.
        pBuffer = AllocPagedBCacheSection(index + 1, cSize);

        if (!pBuffer)
            {
            LogEvent(SU_BCACHE, EV_BUFFER_FAIL, 0, 0, index, 1);

            return(0);
            }

        LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);

        ASSERT(IsBufferAligned(pBuffer));

        return (PVOID)(pBuffer + 1);
        }

    // non guard page case
    // Try to allocate a process cached buffer

    // loop to avoid taking the mutex in the empty list case.
    // This allows us to opportunistically take it in the
    // non-empty list case only.
    do
        {
        if (0 == _bcGlobalState[index].pList)
            {
            // Looks like there are no global buffer available, allocate
            // a new buffer.
            ASSERT(IsBufferSizeAligned(sizeof(BUFFER_HEAD)));
            cSize = pHints[index].cSize + sizeof(BUFFER_HEAD);

            pBuffer = (PBUFFER) new BYTE[cSize];

            if (!pBuffer)
                {
                LogEvent(SU_BCACHE, EV_BUFFER_FAIL, 0, 0, index, 1);
                return(0);
                }

            _bcGlobalStats[index].cAllocationMisses++;

            break;
            }

        _csBufferCacheLock.Request();

        if (_bcGlobalState[index].pList)
            {
            ASSERT(_bcGlobalState[index].cBlocks);

            pBuffer = _bcGlobalState[index].pList;
            _bcGlobalState[index].cBlocks--;
            _bcGlobalStats[index].cAllocationHits++;

            ASSERT(pbctls[index].pList == NULL);
            ASSERT(pbctls[index].cBlocks == 0);

            PBUFFER pkeep = pBuffer;
            UINT cBlocksMoved = 0;

            while (pkeep->pNext && cBlocksMoved < pHints[index].cLowWatermark)
                {
                pkeep = pkeep->pNext;
                cBlocksMoved++;
                }

            pbctls[index].cBlocks = cBlocksMoved;
            _bcGlobalState[index].cBlocks -= cBlocksMoved;
            _bcGlobalStats[index].cAllocationHits += cBlocksMoved;

            // Now we have the head of the list to move to this
            // thread (pBuffer->pNext) and the tail (pkeep).

            // Block counts in the global state and thread state have
            // already been updated.

            pbctls[index].pList = pBuffer->pNext;

            ASSERT(pkeep->pNext || _bcGlobalState[index].cBlocks == 0);
            _bcGlobalState[index].pList = pkeep->pNext;

            // Break the link (if any) between the new per thread list
            // and the blocks which will remain in the process list.
            pkeep->pNext = NULL;
            }

        _csBufferCacheLock.Clear();

        }
    while (NULL == pBuffer );

    ASSERT(pBuffer);

    ASSERT(IsBufferAligned(pBuffer));

    pBuffer->index = index + 1;

    LogEvent(SU_BCACHE, EV_BUFFER_OUT, pBuffer, 0, index, 1, 2);
    return((PVOID(pBuffer + 1)));
}

VOID
BCACHE::Free(PVOID p)
/*++

Routine Description:

    The fast (common) free path.  For large blocks it just deletes them.  For
    small blocks that are inserted into the thread cache.  If the thread
    cache is too large it calls FreeHelper().

Arguments:

    p - The pointer to free.

Return Value:

    None

--*/
{
    PBUFFER pBuffer = ((PBUFFER )p - 1);
    INT index;

    ASSERT(((pBuffer->index >= 1) && (pBuffer->index <= 4)) || (pBuffer->index == -1));

    index = pBuffer->index - 1;

    LogEvent(SU_BCACHE, EV_BUFFER_IN, pBuffer, 0, index, 1, 2);

    INC_STAT(cFrees);

    if (index >= 0)
        {
        if (fPagedBCacheMode)
            {
            ASSERT_VALID_PAGED_BCACHE;

            FreeBuffers((PBUFFER)pBuffer, index, 1);

            ASSERT_VALID_PAGED_BCACHE;

            return;
            }

        // Free to thread cache

        THREAD *pThread = RpcpGetThreadPointer();

        if (NULL == pThread)
            {
            // No thread cache available - free to process cache.
            FreeBuffers(pBuffer, index, 1);
            return;
            }

        PBCTLS pbctls = pThread->BufferCache;

        pBuffer->pNext = pbctls[index].pList;
        pbctls[index].pList = pBuffer;
        pbctls[index].cBlocks++;

        if (pbctls[index].cBlocks >= pHints[index].cHighWatermark)
            {
            // 10% case - Too many blocks in the thread cache, free to process cache

            FreeHelper(p, index, pbctls);
            }
        }
    else
        {
        FreeBigBlock(pBuffer);
        }

    return;
}

VOID
BCACHE::FreeHelper(PVOID p, INT index, PBCTLS pbctls)
/*++

Routine Description:

    Called only by Free().  Separate code to avoid unneeds saves/
    restores in the Free() function.  Called when too many
    blocks are in a thread cache bucket.

Arguments:

    p - The pointer being freed, used if pbctls is NULL
    index - The bucket index of this block
    pbctls - A pointer to the thread cache structure.  If
        NULL the this thread has no cache (yet) p should
        be directly freed.

Return Value:

    None

--*/
{
    ASSERT(pbctls[index].cBlocks == pHints[index].cHighWatermark);

    INC_STAT(cFreesBack);

    // First, build the list to free from the TLS cache

    // Note: We free the buffers at the *end* of the per thread cache.  This helps
    // keep a set of buffers near this thread and (with luck) associated processor.

    PBUFFER ptail = pbctls[index].pList;

    // pbctls[index].pList contains the new keep list. (aka pBuffer)
    // ptail is the pointer to the *end* of the keep list.
    // ptail->pNext will be the head of the list to free.

    // One element already in keep list.
    ASSERT(pHints[index].cLowWatermark >= 1);

    for (unsigned i = 1; i < pHints[index].cLowWatermark; i++)
        {
        ptail = ptail->pNext; // Move up in the free list
        ASSERT(ptail);
        }

    // Save the list to free and break the link between keep list and free list.
    PBUFFER pfree = ptail->pNext;
    ptail->pNext = NULL;

    // Thread cache now contains on low watermark elements.
    pbctls[index].cBlocks = pHints[index].cLowWatermark;

    // Now we need to free the extra buffers to the process cache
    FreeBuffers(pfree, index, pHints[index].cHighWatermark - pHints[index].cLowWatermark);
    
    return;
}

VOID
BCACHE::FreeBuffers(PBUFFER pBuffers, INT index, UINT cBuffers)
/*++

Routine Description:

    Frees a set of buffers to the global (process) cache.  Maybe called when a 
    thread has exceeded the number of buffers is wants to cache or when a 
    thread doesn't have a thread cache but we still need to free a buffer.

Arguments:

    pBuffers - A linked list of buffers which need to be freed.
               
    cBuffers - A count of the buffers to be freed.

Return Value:

    None

--*/
{
    PBUFFER pfree = pBuffers;
    ULONG SegmentIndex;
    BOOL Result;
    PAGED_BCACHE_SECTION_MANAGER *CurrentSection;
    PVOID Allocation;

    // Special case for the freeing without a TLS blob.  We're freeing just
    // one buffer but it's next pointer may not be NULL.  

    if (cBuffers == 1)
        {
        pfree->pNext = 0;
        }
    
    // Find the end of the to free list

    PBUFFER ptail = pfree;
    while(ptail->pNext)
        {
        ptail = ptail->pNext;
        }

    // In guard page mode we switch to the alternate buffer manager
    // objects and uncommit the pages when moving to the global cache.

    if (fPagedBCacheMode)
        {
        Allocation = ConvertBufferToAllocation(pfree,
            TRUE        // IsBufferInitialized
            );

        SegmentIndex = GetSegmentIndexFromBuffer(pfree, Allocation);
        CurrentSection = pfree->SectionManager;

        ASSERT(CurrentSection->SegmentBusy[SegmentIndex] == TRUE);
        ASSERT(CurrentSection->NumberOfUsedSegments > 0);

        pfree = (PBUFFER)Allocation;

        // decommit the buffer and the guard page
        Result = VirtualFree(
            pfree,
            CurrentSection->SegmentSize + gPageSize,
            MEM_DECOMMIT
            );

        ASSERT(Result);

        _csBufferCacheLock.Request();
        CurrentSection->SegmentBusy[SegmentIndex] = FALSE;
        CurrentSection->NumberOfUsedSegments --;

        if (CurrentSection->NumberOfUsedSegments == 0)
            {
            RpcpfRemoveEntryList(&CurrentSection->SectionList);
            _csBufferCacheLock.Clear();
            
            // free the whole section and the manager
            Result = VirtualFree(CurrentSection->VirtualMemorySection,
                0,
                MEM_RELEASE
                );

            ASSERT(Result);

            delete CurrentSection;
            }
        else
            {
            _csBufferCacheLock.Clear();
            }

        return;
        }

    // We have a set of cBuffers buffers starting with pfree and ending with
    // ptail that need to move into the process wide cache now.

    _csBufferCacheLock.Request();

    // If we have too many free buffers we'll throw away these extra buffers.

    if (_bcGlobalState[index].cBlocks >= _bcGlobalStats[index].cBufferCacheCap)
        {
        // It looks like we have too many buffers.  We can either increase the buffer
        // cache cap or really free the buffers.

        if (_bcGlobalStats[index].cAllocationHits > _bcGlobalStats[index].cAllocationMisses * 8)
            {
            // Cache hit rate looks good, we're going to really free the buffers.
            // Don't hold the lock while actually freeing to the heap.

            _csBufferCacheLock.Clear();

            PBUFFER psave;

            while(pfree)
                {
                psave = pfree->pNext;
            
                delete pfree;
                pfree = psave;
                }

            return;
            }

        // Hit rate looks BAD.  Time to bump up the buffer cache cap.

        UINT cNewCap = _bcGlobalStats[index].cBufferCacheCap;

        cNewCap = min(cNewCap + 32, cNewCap * 2);
                      
        _bcGlobalStats[index].cBufferCacheCap = cNewCap;

        // Start keeping new stats, start with a balanced ratio of hits to misses.
        // We'll get at least (cBlocks + cfree) more hits before the next new miss.

        _bcGlobalStats[index].cAllocationHits = 8 * cNewCap;
        _bcGlobalStats[index].cAllocationMisses = 0;

        // Drop into regular free path, we're going to keep these buffers.
        }

    _csBufferCacheLock.VerifyOwned();

    ptail->pNext = _bcGlobalState[index].pList;
    _bcGlobalState[index].pList = pfree;
    _bcGlobalState[index].cBlocks += cBuffers;

    _csBufferCacheLock.Clear();
    return;
}

void
BCACHE::ThreadDetach(THREAD *pThread)
/*++

Routine Description:

    Called when a thread dies.  Moves any cached buffes into
    the process wide cache.

Arguments:

    pThread - The thread object of the thread which is dying.

Return Value:

    None

--*/
{
    PBCTLS pbctls = pThread->BufferCache;
    INT index;

    // Guard page mode only has no thread cache.
    if (fPagedBCacheMode)
        {
        ASSERT(pbctls[0].pList == 0);
        ASSERT(pbctls[1].pList == 0);
        ASSERT(pbctls[2].pList == 0);
        ASSERT(pbctls[3].pList == 0);
        }

    for (index = 0; index < 4; index++)
        {

        if (pbctls[index].pList)
            {
            ASSERT(pbctls[index].cBlocks);            

            FreeBuffers(pbctls[index].pList, index, pbctls[index].cBlocks);

            pbctls[index].pList = 0;
            pbctls[index].cBlocks = 0;
            }

        ASSERT(pbctls[index].pList == 0);
        ASSERT(pbctls[index].cBlocks == 0);
        }
}


PBUFFER
BCACHE::AllocBigBlock(
    IN size_t cBytes
    )
/*++

Routine Description:

    Allocates all buffers which are bigger then a cached block size.

    In guard page mode allocates buffers which are guaranteed to have a read-only
    page following them.  This allows for safe unmarshaling of NDR
    data when combinded with /robust on midl.

Notes:

    Designed with 4Kb and 8Kb pages in mind.  Assumes address space
    is allocated 64Kb at a time.

Arguments:

    cBytes - The size of allocation needed.

Return Value:

    null - out of Vm
    non-null - a pointer to a buffer of cBytes rounded up to page size.

--*/
{
    PBUFFER p;
    size_t BytesToAllocate;
    size_t BytesToAllocateAndGuardPage;
    PVOID pT;

    ASSERT(IsBufferSizeAligned(sizeof(BUFFER_HEAD)));

    BytesToAllocate = cBytes + sizeof(BUFFER_HEAD);

    if (!fPagedBCacheMode)
        {
        p = (PBUFFER) new BYTE[BytesToAllocate];

        if (p)
            {
            p->index = -1;
            p->size = BytesToAllocate;
            }
        return (p);
        }

    // Round up to multiple of pages

    BytesToAllocate = (BytesToAllocate + (gPageSize - 1)) & ~((size_t)gPageSize - 1);

    // Add one for the guard

    BytesToAllocateAndGuardPage = BytesToAllocate + gPageSize;

    p = (PBUFFER) VirtualAlloc(0,
                               BytesToAllocateAndGuardPage,
                               MEM_RESERVE,
                               PAGE_READWRITE);

    if (p)
        {
        pT = CommitSegment(p, BytesToAllocate);
        if (pT == 0)
            {
            // Failed to commit, release the address space.
            VirtualFree(p,
                        BytesToAllocateAndGuardPage,
                        MEM_RELEASE);
            p = NULL;
            }
        else
            {
            p = (PBUFFER)PutBufferAtEndOfAllocation(
                p,                                      // Allocation
                BytesToAllocate,                        // AllocationSize
                cBytes + sizeof(BUFFER_HEAD)            // BufferSize
                );

            p->index = -1;
            p->size = BytesToAllocate;
            }
        }

    return(p);
}

VOID
BCACHE::FreeBigBlock(
    IN PBUFFER pBuffer
    )
/*++

Routine Description:

    Frees a buffer allocated by PageAlloc

Arguments:

    ptr - The buffer to free

Return Value:

    None

--*/
{
    if (!fPagedBCacheMode)
        {
        delete pBuffer;
        return;
        }

    // Guard page mode, large alloc
    pBuffer = (PBUFFER)ConvertBufferToAllocation(pBuffer,
        TRUE    // IsBufferInitialized
        );

    BOOL f = VirtualFree(pBuffer,
                         0,
                         MEM_RELEASE
                         );
    #if DBG
    if (!f)
        {
        DbgPrint("RPCRT4: VirtualFree failed %d\n", GetLastError());
        }
    #endif
}


PBUFFER
BCACHE::AllocPagedBCacheSection (
    IN UINT Size,
    IN ULONG OriginalSize
    )
/*++

Routine Description:

    Allocates a set of 1 or 2 page PBUFFER objects to refill the global cache.  
    The virtual memory for the associated buffers is reserved but not 
    committed here.

Arguments:

    size - 1 : allocate one page cache blocks
           2 : allocate two page cache blocks

    OriginalSize - the size the consumer originally asked for. We need this in
        order to put the buffer at the end of the allocation. This does not include
        the BUFFER_HEAD

Return Value:

    NULL or the new PBUFFER objects (linked list, one alloc)

--*/
{
    UINT Pages = PagedBCacheSectionSize / gPageSize;
    UINT SegmentSize = gPageSize * Size;
    UINT Blocks;
    PBUFFER pBuffer;
    PVOID pReadOnlyPage;
    PAGED_BCACHE_SECTION_MANAGER *SectionManager;
    BOOL Result;

    ASSERT(Size == 1 || Size == 2);

    Blocks = Pages / (Size + 1);  // size is pages, +1 for read only (guard) page

    SectionManager = (PAGED_BCACHE_SECTION_MANAGER *) 
        new BYTE[sizeof(PAGED_BCACHE_SECTION_MANAGER) + (Blocks - 1)];
    if (SectionManager == NULL)
        return NULL;

    // reserve the address space
    pBuffer = (PBUFFER)VirtualAlloc(0,
           PagedBCacheSectionSize,
           MEM_RESERVE,
           PAGE_READWRITE);

    if (!pBuffer)
        {
        delete SectionManager;
        return NULL;
        }

    // we commit the first buffer only
    pBuffer = (PBUFFER)CommitSegment(pBuffer, SegmentSize);
    if (pBuffer == NULL)
        {
        delete SectionManager;

        Result = VirtualFree(pBuffer,
            0,
            MEM_RELEASE);

        // This must succeed
        ASSERT(Result);
        return NULL;
        }

    SectionManager->NumberOfSegments = Blocks;
    SectionManager->NumberOfUsedSegments = 1;
    SectionManager->SegmentSize = SegmentSize;
    SectionManager->VirtualMemorySection = pBuffer;
    SectionManager->SegmentBusy[0] = TRUE;
    RpcpMemorySet(&SectionManager->SegmentBusy[1], 0, Blocks);

    _csBufferCacheLock.Request();
    RpcpfInsertTailList(&Sections, &SectionManager->SectionList);

    pBuffer = (PBUFFER)PutBufferAtEndOfAllocation(
        pBuffer,                                // Allocation
        SegmentSize,                            // AllocationSize
        OriginalSize + sizeof(BUFFER_HEAD)      // BufferSize
        );

    pBuffer->SectionManager = SectionManager;
    pBuffer->index = Size;

    ASSERT_VALID_PAGED_BCACHE;

    _csBufferCacheLock.Clear();

    return(pBuffer);
}

ULONG
BCACHE::GetSegmentIndexFromBuffer (
    IN PBUFFER pBuffer,
    IN PVOID Allocation
    )
/*++

Routine Description:

    Calculates the segment index for the given
    buffer.

Arguments:

    pBuffer - the buffer whose index we want to get

    Allocation - the beginning of the allocation containing the given buffer

Return Value:

    The segment index of the buffer

--*/
{
    PAGED_BCACHE_SECTION_MANAGER *CurrentSection;
    ULONG AddressDifference;
    ULONG SegmentIndex;

    CurrentSection = pBuffer->SectionManager;

    AddressDifference = (ULONG)((PBYTE)Allocation - (PBYTE)CurrentSection->VirtualMemorySection);

    SegmentIndex = AddressDifference / (CurrentSection->SegmentSize + gPageSize);

    // the division must have no remainder
    ASSERT(SegmentIndex * (CurrentSection->SegmentSize + gPageSize) == AddressDifference);

    return SegmentIndex;
}

#if DBG
void
BCACHE::VerifyPagedBCacheState (
    void
    )
/*++

Routine Description:

    Verifies the state of the paged bcache. If the state is not consistent,
    is ASSERTs. Note that this can tremendously slow down a machine.

Arguments:


Return Value:


--*/
{
    LIST_ENTRY *CurrentListEntry;
    PAGED_BCACHE_SECTION_MANAGER *CurrentSection;

    _csBufferCacheLock.Request();
    CurrentListEntry = Sections.Flink;
    while (CurrentListEntry != &Sections)
        {
        CurrentSection = CONTAINING_RECORD(CurrentListEntry, 
            PAGED_BCACHE_SECTION_MANAGER,
            SectionList);

        VerifySectionState(CurrentSection);

        CurrentListEntry = CurrentListEntry->Flink;
        }
    _csBufferCacheLock.Clear();
}

void
BCACHE::VerifySectionState (
    IN PAGED_BCACHE_SECTION_MANAGER *Section
    )
/*++

Routine Description:

    Verifies the state of the paged bcache. If the state is not consistent,
    is ASSERTs. Note that this can tremendously slow down a machine.

Arguments:

    Section - the section whose state we want to verify

Return Value:


--*/
{
    ULONG EstimatedNumberOfSegments;
    ULONG i;
    ULONG CountedBusySegments;
    PVOID CurrentSegment;

    _csBufferCacheLock.VerifyOwned();

    // we take advantage of some rounding here. It is possible that the section
    // has unused space at the end (e.g. if 2 page (8K segments) + 1 guard page
    // = 12K. 64K has 5 of those, and one page is left. Using integer division
    // below should lose the extra page and still make a valid calculation
    EstimatedNumberOfSegments = PagedBCacheSectionSize / (Section->SegmentSize + gPageSize);

    ASSERT(EstimatedNumberOfSegments == Section->NumberOfSegments);
    ASSERT(Section->NumberOfUsedSegments <= Section->NumberOfSegments);

    CountedBusySegments = 0;
    CurrentSegment = Section->VirtualMemorySection;
    for (i = 0; i < Section->NumberOfSegments; i ++)
        {
        if (Section->SegmentBusy[i])
            {
            CountedBusySegments ++;
            // verify the segment
            VerifySegmentState(CurrentSegment,
                TRUE,   // IsSegmentBusy
                Section->SegmentSize,
                Section
                );
            }
        else
            {
            // verify the segment
            VerifySegmentState(CurrentSegment,
                FALSE,   // IsSegmentBusy
                Section->SegmentSize,
                Section
                );
            }
        CurrentSegment = (PBYTE)CurrentSegment + Section->SegmentSize + gPageSize;
        }

    ASSERT(CountedBusySegments == Section->NumberOfUsedSegments);
}

void
BCACHE::VerifySegmentState (
    IN PVOID Segment,
    IN BOOL IsSegmentBusy,
    IN ULONG SegmentSize,
    IN PAGED_BCACHE_SECTION_MANAGER *OwningSection
    )
/*++

Routine Description:

    Verifies the state of the paged bcache. If the state is not consistent,
    is ASSERTs. Note that this can tremendously slow down a machine.

Arguments:

    Segment - the segment whose state we want to verify

    IsSegmentBusy - if non-zero, we'll verify that the passed segment is properly
        allocated. If zero, we will verify it is no committed

    SegmentSize - the size of the segment in bytes. This doesn't include the
        guard page.

    OwningSection - the section manager that owns the section and the segment

Return Value:


Note:

    The buffer index must be in its external value (i.e. + 1)

--*/
{
    PBYTE CurrentPage;

    _csBufferCacheLock.VerifyOwned();
    if (IsSegmentBusy)
        {
        // probe the segment and the guard page

#if defined(FULL_PAGED_BCACHE_VERIFY)
        // we don't use this always, as it can result in false positives
        // The buffer is decommitted without holding the mutex

        // first, the segment must be good for writing
        ASSERT(IsBadWritePtr(Segment, SegmentSize) == FALSE);
        // second, the guard page must be bad for writing
        ASSERT(IsBadWritePtr((PBYTE)Segment + SegmentSize, gPageSize));
        // third, the guard page must be good for reading
        ASSERT(IsBadReadPtr((PBYTE)Segment + SegmentSize, gPageSize) == FALSE);

        // make sure the segment agrees it belongs to the same section manager
        ASSERT(((PBUFFER)Segment)->SectionManager == OwningSection);

        // can give false positives if on. The index is not manipulated inside
        // the mutex
        // finally, the buffer header contents must be consistent with the segment
        // size
        ASSERT((((PBUFFER)Segment)->index) * gPageSize == SegmentSize);
#endif  // FULL_PAGED_BCACHE_VERIFY
        }
    else
        {
#if defined(FULL_PAGED_BCACHE_VERIFY)
        // since IsBadReadPtr bails out on first failure, we must probe each
        // page individually to make sure it is uncommitted
        CurrentPage = (PBYTE)Segment;
        while (CurrentPage <= (PBYTE)Segment + SegmentSize)
            {
            ASSERT(IsBadReadPtr(CurrentPage, gPageSize));
            CurrentPage += gPageSize;
            }
#endif  // FULL_PAGED_BCACHE_VERIFY
        }
}

#endif  // DBG

PVOID
BCACHE::PutBufferAtEndOfAllocation (
    IN PVOID Allocation,
    IN ULONG AllocationSize,
    IN ULONG BufferSize
    )
/*++

Routine Description:

    Given an allocation, a size and a buffer of a given size, it chooses
        an address for the buffer such that the buffer is 8 bytes aligned
        and it is as close as possible to the end of the allocation

Arguments:

    Allocation - the allocation with which we try to position the buffer.

    AllocationSize - the total size of the allocation

    BufferSize - the size of the buffer we're trying to a position

Return Value:

    The new address for the buffer within the allocation.

--*/
{
    ULONG BufferOffset;
    PVOID Buffer;

    ASSERT(AllocationSize >= BufferSize);

    BufferOffset = AllocationSize - BufferSize;

    // in our allocator, we should never have more than a page
    // extra
    ASSERT(BufferOffset < gPageSize);

#if defined(_WIN64)
    // zero out four bits at the end. This 16 byte aligns the buffer
    BufferOffset &= ~(ULONG)15;
#else   // _WIN64
    // zero out three bits at the end. This 8 byte aligns the buffer
    BufferOffset &= ~(ULONG)7;
#endif  // _WIN64

    Buffer = (PVOID)((PBYTE)Allocation + BufferOffset);

    // make sure that the reverse calculation will yield the same result
    ASSERT(ConvertBufferToAllocation((PBUFFER)Buffer, FALSE) == Allocation);

    return Buffer;
}

PVOID
BCACHE::ConvertBufferToAllocation (
    IN PBUFFER Buffer,
    IN BOOL IsBufferInitialized
    )
/*++

Routine Description:

    Given a buffer, finds the allocation that contains it. Since we know
    that all of our allocations are page aligned, and the allocation is
    never a page or more larger than the buffer, we can simply page align
    the buffer and return that.

Arguments:

    Buffer - the buffer for which we are trying to find the containing
        allocation.

    IsBufferInitialized - non-zero if the Buffer has valid index and
        SectionManager. 0 otherwise.

Return Value:

    The containing allocation

--*/
{
    PVOID LastSectionSegment;
    PAGED_BCACHE_SECTION_MANAGER *Section;
    PVOID Allocation;
    
    if (IsBufferInitialized)
        {
        ASSERT((Buffer->index == 0)
            || (Buffer->index == 1)
            || (Buffer->index == -1));
        }

    Allocation = (PVOID)((ULONG_PTR)Buffer & ~(ULONG_PTR)(gPageSize - 1));

    if (IsBufferInitialized && (Buffer->index != -1))
        {
        Section = Buffer->SectionManager;

        LastSectionSegment = (PBYTE)Section->VirtualMemorySection 
            + Section->NumberOfSegments * (Section->SegmentSize + gPageSize);

        ASSERT(Allocation >= Section->VirtualMemorySection);
        ASSERT(Allocation <= LastSectionSegment);
        }

    return Allocation;
}

const ULONG GuardPageFillPattern = 0xf;

PVOID
BCACHE::CommitSegment (
    IN PVOID SegmentStart,
    IN ULONG SegmentSize
    )
/*++

Routine Description:

    Commits a segment (usable part and guard page).

Arguments:

    SegmentStart - the start of the segment.

    SegmentSize - the size of the segment to be committed. This
        does not include the guard page.

Return Value:

    The pointer to the segment start if it succeeds or NULL if
        it fails.

--*/
{
    PVOID pTemp;
    BOOL Result;
    ULONG Ignored;

    pTemp = VirtualAlloc(
        SegmentStart,
        SegmentSize + gPageSize,
        MEM_COMMIT,
        PAGE_READWRITE
        );

    if (pTemp)
        {
        // initialize the guard page with non-zero data
        RtlFillMemoryUlong((PBYTE)SegmentStart + SegmentSize, gPageSize, GuardPageFillPattern);

        // revert protections on the guard page to read only
        Result = VirtualProtect((PBYTE)SegmentStart + SegmentSize,
            gPageSize,
            PAGE_READONLY,
            &Ignored);

        if (Result == FALSE)
            {
            Result = VirtualFree(SegmentStart,
                SegmentSize + gPageSize,
                MEM_DECOMMIT
                );

            // this must succeed
            ASSERT(Result);

            return NULL;
            }
        }

    return pTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\binding.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    binding.cxx

Abstract:

    The implementation of the DCE binding class is contained in this
    file.

Author:

    Michael Montague (mikemon) 04-Nov-1991

Revision History:
    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

--*/

#include <precomp.hxx>
#include <epmap.h>
#include <hndlsvr.hxx>
#include <sdict2.hxx>
#include <dispatch.h>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <osfsvr.hxx>
#include <rpctrans.hxx>


UUID   MgmtIf = { 0xafa8bd80,0x7d8a,0x11c9,
                    {0xbe,0xf4,0x08,0x00,0x2b,0x10,0x29,0x89} };
UUID   NullUuid = { 0L, 0, 0, {0,0,0,0,0,0,0,0} };


int
IsMgmtIfUuid(
   UUID PAPI * IfId
   )
{

  if (RpcpMemoryCompare(IfId, &MgmtIf, sizeof(UUID)) == 0)
      {
      return 1;
      }

  return 0;
}


RPC_CHAR *
DuplicateString (
    IN RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    When this routine is called, it will duplicate the string into a fresh
    string and return it.

Arguments, either:

    String - Supplies the string to be duplicated.
    Ansi String - Supplies the string to be duplicated.

Return Value:

    The duplicated string is returned.  If insufficient memory is available
    to allocate a fresh string, zero will be returned.

--*/
{
    RPC_CHAR * FreshString, * FreshStringScan;
    RPC_CHAR PAPI * StringScan;
    unsigned int Length;

    ASSERT(String);

    Length = 1;
    StringScan = String;
    while (*StringScan++ != 0)
        Length += 1;

    FreshString = new RPC_CHAR[Length];
    if (FreshString == 0)
        return(0);

    for (FreshStringScan = FreshString, StringScan = String;
            *StringScan != 0; FreshStringScan++, StringScan++)
        {
        *FreshStringScan = *StringScan;
        }
    *FreshStringScan = *StringScan;

    return(FreshString);
}


DCE_BINDING::DCE_BINDING (
    IN RPC_CHAR PAPI * ObjectUuid OPTIONAL,
    IN RPC_CHAR PAPI * RpcProtocolSequence OPTIONAL,
    IN RPC_CHAR PAPI * NetworkAddress OPTIONAL,
    IN RPC_CHAR PAPI * Endpoint OPTIONAL,
    IN RPC_CHAR PAPI * Options OPTIONAL,
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    The constructor creates a DCE_BINDING object based on the pieces of
    the string binding specified.

Arguments:

    ObjectUuid - Optionally supplies the object uuid component of the
        binding.

    RpcProtocolSequence - Optionally supplies the rpc protocol sequence
        component of the binding.

    NetworkAddress - Optionally supplies the network address component
        of the binding.

    Endpoint - Optionally supplies the endpoint component of the binding.

    Options - Optionally supplies the network options component of the
        binding.

    Status - Returns the status of the operation.  This argument will
        be set to one of the following values.

        RPC_S_OK - The operation completed successfully.

        RPC_S_INVALID_STRING_UUID - The specified object uuid does
            not contain the valid string representation of a uuid.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to
            complete the operation.

--*/
{
    ALLOCATE_THIS(DCE_BINDING);

    *Status = RPC_S_OK;

    if (   ARGUMENT_PRESENT(ObjectUuid)
        && (ObjectUuid[0] != 0))
        {
        if (this->ObjectUuid.ConvertFromString(ObjectUuid))
            {
            *Status = RPC_S_INVALID_STRING_UUID;
            this->ObjectUuid.SetToNullUuid();
            }
        }
    else
        this->ObjectUuid.SetToNullUuid();

    if (ARGUMENT_PRESENT(RpcProtocolSequence))
        {
        this->RpcProtocolSequence = DuplicateString(RpcProtocolSequence);
        if (this->RpcProtocolSequence == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        this->RpcProtocolSequence = 0;

    if (ARGUMENT_PRESENT(NetworkAddress))
        {
        this->NetworkAddress = DuplicateString(NetworkAddress);
        if (this->NetworkAddress == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        this->NetworkAddress = 0;

    if (ARGUMENT_PRESENT(Endpoint))
        {
        this->Endpoint = DuplicateString(Endpoint);
        if (this->Endpoint == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        this->Endpoint = 0;

    if (ARGUMENT_PRESENT(Options))
        {
        this->Options = DuplicateString(Options);
        if (this->Options == 0)
            *Status = RPC_S_OUT_OF_MEMORY;
        }
    else
        {
        this->Options = 0;
        }
}


/*static*/ RPC_CHAR PAPI *
StringCharSearchWithEscape (
    IN RPC_CHAR PAPI * String,
    IN unsigned int Character
    )
/*++

Routine Description:

    This routine is the same as the library routine, strchr, except that
    the backslash character ('\') is treated as an escape character.

Arguments:

    String - Supplies the string in which to search for the character.

    Character - Supplies the character to search for in the string.

Return Value:

    A pointer to the first occurance of Character in String is returned.
    If Character does not exist in String, then 0 is returned.

--*/
{
#ifdef DBCS_ENABLED
    ASSERT(IsDBCSLeadByte((RPC_CHAR)Character) == FALSE);
    ASSERT(IsDBCSLeadByte(RPC_CONST_CHAR('\\')) == FALSE);

    while(*String != (RPC_CHAR)Character)
        {
        if (*String == 0)
            return(0);

        if (*String == RPC_CONST_CHAR('\\'))
            {
            String = (RPC_CHAR *)CharNext((LPCSTR)String);
            }
        String = (RPC_CHAR *)CharNext((LPCSTR)String);
        }
    return(String);
#else
    while (*String != (RPC_CHAR) Character)
        {
        if (*String == RPC_CONST_CHAR('\\'))
            String++;
        if (*String == 0)
            return(0);
        String++;
        }
    return(String);
#endif
}


/*static*/ void
StringCopyWithEscape (
    OUT RPC_CHAR PAPI * Destination,
    IN RPC_CHAR PAPI * Source
    )
/*++

Routine Description:

    This routine is the same as the library routine, strcpy, except that
    the backslash character ('\') is treated as an escape character.  When
    a character is escaped, the backslash character is not copied to the
    Destination.

Arguments:

    Destination - Returns a duplicate of the string specified in Source,
        but with out escaped characters escaped.

    Source - Specifies the string to be copied.

Return Value:

    None.

--*/
{
    BOOL fLastQuote = FALSE;

#ifdef DBCS_ENABLED
    ASSERT(IsDBCSLeadByte('\\') == FALSE);
#endif


    while ((*Destination = *Source) != 0)
        {
#ifdef DBCS_ENABLED
        if (IsDBCSLeadByte(*Source))
            {
            // Copy the whole DBCS character; don't look for
            // escapes within the character.
            Destination++;
            Source++;
            *Destination = *Source;
            if (*Source == 0)
                {
                ASSERT(0);  // Bad string, NULL following a lead byte.
                return;
                }
            Destination++;
            Source++;
            }
        else
#endif
            {
            if (   *Source != RPC_CONST_CHAR('\\')
                || fLastQuote == TRUE)
                {
                Destination++;
                fLastQuote = FALSE;
                }
            else
                {
                fLastQuote = TRUE;
                }
            Source++;
            }
        }
}


/*static*/ RPC_STATUS
ParseAndCopyEndpointField (
    OUT RPC_CHAR ** Endpoint,
    IN RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    This routine parses and then copies the endpoint field in String.  A
    copy of the field is made into a newly allocated string and returned
    in Endpoint.  String is assumed to contain only the endpoint field;
    the terminating ',' or ']' are not included.

Arguments:

    Endpoint - Returns a copy of the endpoint field in a newly allocated
        string.

    String - Supplies the endpoint field to be parsed and copied.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - There is no memory available to make a copy
        of the string.

    RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint field is syntactically
        incorrect.  This error code will be returned if the endpoint field
        does not match the following pattern.

        [ <Endpoint> | "endpoint=" <Endpoint> ]

--*/
{
    // Search will be used to scan along the string to find the end of
    // the endpoint field and the '='.

    RPC_CHAR PAPI * Search;

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR('='));
    if (Search == 0)
        {
        // This means that we have the <Endpoint> pattern, so we just
        // copy the endpoint field.

        Search = StringCharSearchWithEscape(String,0);
        *Endpoint = new RPC_CHAR[size_t(Search - String + 1)];
        if (*Endpoint == 0)
            return(RPC_S_OUT_OF_MEMORY);
        StringCopyWithEscape(*Endpoint,String);
        return(RPC_S_OK);
        }

    // Otherwise, we have the "endpoint=" pattern.  First we need to check
    // that the string before the '=' is in fact "endpoint".

    *Search = 0;
    if ( RpcpStringCompare(String, RPC_CONST_STRING("endpoint")) != 0 )
        {
        *Search = RPC_CONST_CHAR('=');
        return(RPC_S_INVALID_ENDPOINT_FORMAT);
        }
    *Search = RPC_CONST_CHAR('=');
    String = Search + 1;

    // Now we just need to allocate a new string and copy the endpoint into
    // it.

    Search = StringCharSearchWithEscape(String,0);
    *Endpoint = new RPC_CHAR[size_t(Search - String + 1)];
    if (*Endpoint == 0)
        return(RPC_S_OUT_OF_MEMORY);

    StringCopyWithEscape(*Endpoint,String);
    return(RPC_S_OK);
}


RPC_CHAR *
AllocateEmptyString (
    void
    )
/*++

Routine Description:

    This routine allocates and returns an empty string ("").

Return Value:

    A newly allocated empty string will be returned.

--*/
{
    RPC_CHAR * String;

    String = new RPC_CHAR[1];
    if (String != 0)
        *String = 0;
    return(String);
}


DCE_BINDING::DCE_BINDING (
    IN RPC_CHAR PAPI * StringBinding,
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This constructor creates a DCE_BINDING object from a string binding,
    which requires that the string binding be parsed into seperate
    strings and validated.

Arguments:

    StringBinding - Supplies the string being to be parsed.

    Status - Returns the status of the operation.  This parameter will
        take on the following values:

        RPC_S_OK - The operation completed successfully.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to
            allocate space for the fields of the string binding.

        RPC_S_INVALID_STRING_BINDING - The string binding is
            syntactically invalid.

        RPC_S_INVALID_ENDPOINT_FORMAT - The endpoint specified in
            the string binding is syntactically incorrect.

        RPC_S_INVALID_STRING_UUID - The specified object uuid does not
            contain the valid string representation of a uuid.

--*/
{
    // String will point to the beginning of the field we are trying to
    // parse.

    RPC_CHAR PAPI * String;

    // Search will be used to scan along the string to find the end of
    // the field we are trying to parse.

    RPC_CHAR PAPI * Search;

    // This will contain the string representation of the object uuid.

    RPC_CHAR PAPI * ObjectUuidString;

    ALLOCATE_THIS(DCE_BINDING);

    // A string binding consists of an optional object uuid, an RPC protocol
    // sequence, a network address, an optional endpoint, and zero or more
    // option fields.
    //
    // [ <Object UUID> "@" ] <RPC Protocol Sequence> ":" <Network Address>
    // [ "[" ( <Endpoint> | "endpoint=" <Endpoint> | ) [","]
    //     [ "," <Option Name> "=" <Option Value>
    //         ( <Option Name> "=" <Option Value> )* ] "]" ]
    //
    // If an object UUID is specified, then it will be followed by '@'.
    // Likewise, if an endpoint and/or option(s) are specified, they will
    // be in square brackets.  Finally, one or more options are specified,
    // then ',' must seperate the optional endpoint from the options.  The
    // backslash character '\' is treated as an escape character in all
    // string binding fields.

    // To begin with, we need to set all of the string pointers to zero.
    // This is necessary so that when we do memory cleanup for error
    // recovery, we know which pointers we allocated a string for.

    ObjectUuidString = 0;
    RpcProtocolSequence = 0;
    NetworkAddress = 0;
    Endpoint = 0;
    Options = 0;

    String = StringBinding;


    // To begin with, we need to parse off the object UUID from the string
    // if it exists.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR('@'));
    if (Search == 0)
        {
        // The string binding does not contain an object UUID.

        ObjectUuid.SetToNullUuid();
        }
    else
        {
        // There is an object UUID in the string.

        // We need to add one for the terminating zero in the
        // string.

        ObjectUuidString = (RPC_CHAR PAPI *) RpcpFarAllocate(
                sizeof(RPC_CHAR)*size_t(Search - String + 1));

        if (ObjectUuidString == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }

        // Now copy the string.

        *Search = 0;
        StringCopyWithEscape(ObjectUuidString,String);
        *Search = RPC_CONST_CHAR('@');

        // Finally, update String so that we are ready to parse the next
        // field.

        String = Search + 1;

        // Now convert the string representation of the object uuid
        // into an actual uuid.

        if (ObjectUuid.ConvertFromString(ObjectUuidString))
        {
            *Status = RPC_S_INVALID_STRING_UUID;
            goto FreeMemoryAndReturn;
        }

        RpcpFarFree(ObjectUuidString);
        ObjectUuidString = 0;
        }

    // The RPC protocol sequence field comes next; it is terminated by
    // ':'.  Both the RPC protocol sequence field and the ':' are required.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(':'));
    if (Search == 0)
        {
        // This is an error, because the RPC protocol sequence field is
        // required.  We may need to free the string we allocated for
        // the object UUID field.

        *Status = RPC_S_INVALID_STRING_BINDING;
        goto FreeMemoryAndReturn;
        }
    else
        {
        // The same comments which applied to copying the object UUID
        // apply here as well.

        RpcProtocolSequence = new RPC_CHAR[size_t(Search - String + 1)];
        if (RpcProtocolSequence == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }

        *Search = 0;
        StringCopyWithEscape(RpcProtocolSequence,String);
        *Search = RPC_CONST_CHAR(':');

        // Finally, update String so that we are ready to parse the next
        // field.

        String = Search + 1;
        }

    // Next comes the network address field which is required.  It is
    // terminated by zero or '['.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR('['));
    if (Search == 0)
        {
        // This means that the network address is the last field, so we
        // just copy it, and set the remaining fields to be empty strings.

        Search = StringCharSearchWithEscape(String,0);
        NetworkAddress = new RPC_CHAR[size_t(Search - String + 1)];
        if (NetworkAddress == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }
        StringCopyWithEscape(NetworkAddress,String);

        Endpoint = AllocateEmptyString();
        if (Endpoint == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }

        Options = 0;

        *Status = RPC_S_OK;
        return;
        }

    // Otherwise, if we reach here, there is an endpoint and/or options
    // left to parse.  But before we parse them, lets copy the network
    // address field.

    NetworkAddress = new RPC_CHAR [size_t(Search - String + 1)];
    if (NetworkAddress == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        goto FreeMemoryAndReturn;
        }
    *Search = 0;
    StringCopyWithEscape(NetworkAddress,String);
    *Search = RPC_CONST_CHAR('[');

    String = Search + 1;

    // Now we are ready to parse off the endpoint and/or options.
    // To begin with, we check to see if there is a comma.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(','));
    if (Search == 0)
        {
        // There is only one token in the string binding.  See
        // if its an endpoint, if not, it must be an option.
        // Before we copy the endpoint field, we need to check
        // for the closing square bracket.

        Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(']'));
        if (Search == 0)
            {
            // This is an error; the string binding is invalid.  We need to
            // clean everything up, and return an error.

            *Status = RPC_S_INVALID_ENDPOINT_FORMAT;
            goto FreeMemoryAndReturn;
            }

        *Search = 0;
        *Status = ParseAndCopyEndpointField(&Endpoint,String);
        *Search = RPC_CONST_CHAR(']');

        // If the parse succeeded, allocate an empty option.
        if (*Status == RPC_S_OK)
            {
            Options = 0;
            }

        // If the endpoint parse failed with RPC_S_INVALID_ENDPOINT_FORMAT,
        // the token must be an option.
        else if (*Status == RPC_S_INVALID_ENDPOINT_FORMAT)
            {
                Endpoint = AllocateEmptyString();
                if (Endpoint == 0)
                    {
                    *Status = RPC_S_OUT_OF_MEMORY;
                    goto FreeMemoryAndReturn;
                    }

                Options = new RPC_CHAR [size_t(Search - String + 1)];
                if (Options == 0)
                    {
                    *Status = RPC_S_OUT_OF_MEMORY;
                    goto FreeMemoryAndReturn;
                    }

                *Search = 0;
                StringCopyWithEscape(Options,String);
                *Search = RPC_CONST_CHAR(']');

            }

        // Something bad must have happened, clean up.
        else
            goto FreeMemoryAndReturn;

        *Status = RPC_S_OK;
        return;
        }

    // When we reach here, we know that there are options.   We have
    // to see if there is an endpoint.  If there is, copy it and then
    // copy the options.  If there isn't, allocate a null endpoint and
    // copy the options.

    *Search = 0;
    *Status = ParseAndCopyEndpointField(&Endpoint,String);
    *Search = RPC_CONST_CHAR(',');

    // If there was an endpoint, skip that part of the string.
    // Otherwise treat it as an option.
    if (*Status == RPC_S_OK)
        String = Search + 1;
    else if (*Status != RPC_S_INVALID_ENDPOINT_FORMAT)
        goto FreeMemoryAndReturn;

    // There was no endpoint, so allocate an empty string.
    else
        {
        Endpoint = AllocateEmptyString();
        if (Endpoint == 0)
            {
            *Status = RPC_S_OUT_OF_MEMORY;
            goto FreeMemoryAndReturn;
            }
        }

    // Even if the caller did not specify the NetworkOptions argument,
    // we still want to validate the rest of the string binding.

    Search = StringCharSearchWithEscape(String,RPC_CONST_CHAR(']'));
    if (Search == 0)
        {
        // This is an error; the string binding is invalid.  We need
        // to clean everything up, and return an error.

        *Status = RPC_S_INVALID_STRING_BINDING;
        goto FreeMemoryAndReturn;
        }

    // Go ahead and copy the network options field if we reach here.

    Options = new RPC_CHAR [size_t(Search - String + 1)];
    if (Options == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        goto FreeMemoryAndReturn;
        }

    *Search = 0;
    StringCopyWithEscape(Options,String);
    *Search = RPC_CONST_CHAR(']');

    // Everything worked out fine; we just fall through the memory
    // cleanup code and return.

    *Status = RPC_S_OK;

    // If an error occured up above, we will have set status to the
    // appropriate error code, and jumped here.  We may also arrive
    // here if an error did not occur, hence the check for an error status
    // before we clean up the memory.

FreeMemoryAndReturn:

    if (*Status != RPC_S_OK)
        {
        if (ObjectUuidString != 0)
            RpcpFarFree(ObjectUuidString);

        delete RpcProtocolSequence;
        delete NetworkAddress;
        delete Endpoint;
        delete Options;

        ObjectUuidString    = 0;
        RpcProtocolSequence = 0;
        NetworkAddress      = 0;
        Endpoint            = 0;
        Options             = 0;
        }
}


DCE_BINDING::~DCE_BINDING (
    )
/*++

Routine Description:

    We cleaning things up here when a DCE_BINDING is getting deleted.
    This consists of freeing the strings pointed to by the fields of
    the class.

--*/
{
    delete RpcProtocolSequence;
    delete NetworkAddress;
    delete Endpoint;
    delete Options;
}


/*static*/ int
StringLengthWithEscape (
    IN RPC_CHAR PAPI * String
    )
/*++

Routine Description:

    This routine is the same as the library routine, strlen, except that
    for that following characters, '@', ':', '\', '[', and ',', are
    counted as two characters (to save space for a \) rather than one.

Arguments:

    String - Supplies a string whose length will be determined.

Return Value:

    The length of the string will be returned including enough space to
    escape certain characters.

--*/
{
    // We use length to keep track of how long the string is so far.

    int Length;

    Length = 0;
    while (*String != 0)
        {
#ifdef DBCS_ENABLED
        if (IsDBCSLeadByte(*String))
            {
            String += 2;
            Length += 2;
            }
        else
#endif
            {
            if (   (*String == RPC_CONST_CHAR('@'))
                || (*String == RPC_CONST_CHAR(':'))
                || (*String == RPC_CONST_CHAR('\\'))
                || (*String == RPC_CONST_CHAR('['))
                || (*String == RPC_CONST_CHAR(']'))
                || (*String == RPC_CONST_CHAR(',')))
                Length += 2;
            else
                Length += 1;
            String += 1;
            }
        }
    return(Length);
}

/*static*/ RPC_CHAR PAPI *
StringCopyEscapeCharacters (
    OUT RPC_CHAR PAPI * Destination,
    IN RPC_CHAR PAPI * Source
    )
/*++

Routine Description:

    Source is copied into destination.  When coping into destination, the
    following characters are escaped by prefixing them with a '\': '@',
    ':', '\', '[', ']', and ','.

Arguments:

    Destination - Returns a copy of Source.

    Source - Supplies a string to be copied into destination.

Return Value:

    A pointer to the terminating zero in Destination is returned.

--*/
{
    while ((*Destination = *Source) != 0)
        {
#ifdef DBCS_ENABLED
        if (IsDBCSLeadByte(*Source))
            {
            Destination++;
            Source++;
            *Destination = *Source;
            }
        else
#endif
            {
            if (   (*Source == RPC_CONST_CHAR('@'))
                || (*Source == RPC_CONST_CHAR(':'))
                || (*Source == RPC_CONST_CHAR('\\'))
                || (*Source == RPC_CONST_CHAR('['))
                || (*Source == RPC_CONST_CHAR(']'))
                || (*Source == RPC_CONST_CHAR(',')))
                {
                *Destination++ = RPC_CONST_CHAR('\\');
                *Destination = *Source;
                }
            }
        Destination++;
        Source++;
        }
    *Destination = 0;
    return(Destination);
}


RPC_CHAR PAPI *
DCE_BINDING::StringBindingCompose (
    IN RPC_UUID PAPI * Uuid OPTIONAL,
    IN BOOL fStatic
    )
/*++

Routine Description:

    This method creates a string binding from a DCE_BINDING by combining
    the components of a string binding.

Arguments:

    Uuid - Optionally supplies a uuid to use in composing the string
        binding rather than the object uuid contained in the DCE_BINDING.

Return Value:

    String Binding - A newly allocated and created (from the components)
        is returned.

    0 - Insufficient memory is available to allocate the string binding.

--*/
{
    // We will use the following automatic variable to calculate the
    // required length of the string.

    int Length;

    // Copy is used to copy the fields of the string binding into the
    // string binding.

    RPC_CHAR PAPI * Copy;

    // StringBinding will contain the string binding we are supposed
    // to be creating here.

    RPC_CHAR PAPI * StringBinding;

    // This routine is written as follows.  First we need to calculate
    // the amount of space required to hold the string binding.  This
    // is not quite straight forward as it seems: we need to escape
    // '@', ':', '\', '[', ']', and ',' characters in the string binding
    // we create.  After allocating the string, we copy each piece in,
    // escaping characters as necessary.

    // Go through and figure out how much space each field of the string
    // binding will take up.

    if (!ARGUMENT_PRESENT(Uuid))
        Uuid = &ObjectUuid;

    if (Uuid->IsNullUuid() == 0)
        {
        // The extra plus one is to save space for the '@' which seperates
        // the object UUID field from the RPC protocol sequence field.  The
        // length of the string representation of a uuid is always 36
        // characters.

        Length = 36 + 1;
        }
    else
        {
        Length = 0;
        }

    if (RpcProtocolSequence != 0)
        {
        Length += StringLengthWithEscape(RpcProtocolSequence);
        }

    // We need to save space for the ':' seperating the RPC protocol
    // sequence field from the network address field.

    Length += 1;

    if (NetworkAddress != 0)
        Length += StringLengthWithEscape(NetworkAddress);

    if (   (Endpoint != 0)
        && (Endpoint[0] != 0))
        {
        // The plus two is to save space for the '[' and ']' surrounding
        // the endpoint and options fields.

        Length += StringLengthWithEscape(Endpoint) + 2;

        if (   (Options != 0)
            && (Options[0] != 0))
            {
            // The extra plus one is for the ',' which goes before the
            // options field.

            Length += StringLengthWithEscape(Options) + 1;
            }
        }
    else
        {
        if (   (Options != 0)
            && (Options[0] != 0))
            {
            // We need to add three to the length to save space for the
            // '[' and ']' which will go around the options, and the ','
            // which goes before the options.

            Length += StringLengthWithEscape(Options) + 3;
            }
        }

    // Finally, include space for the terminating zero in the string.

    Length += 1;

    // Now we allocate space for the string binding and copy all of the
    // pieces into it.

    StringBinding = (RPC_CHAR PAPI *)
            RpcpFarAllocate(Length * sizeof(RPC_CHAR));
    if (StringBinding == 0)
        return(0);

    if (Uuid->IsNullUuid() == 0)
        {
        Copy = Uuid->ConvertToString(StringBinding);
        *Copy++ = RPC_CONST_CHAR('@');
        }
    else
        {
        Copy = StringBinding;
        }

    if (RpcProtocolSequence != 0)
        {
        Copy = StringCopyEscapeCharacters(Copy, RpcProtocolSequence);
        }

    *Copy++ = RPC_CONST_CHAR(':');

    if (NetworkAddress != 0)
        {
        Copy = StringCopyEscapeCharacters(Copy, NetworkAddress);
        }

    if ( (fStatic == 0)
        &&  (Endpoint != 0)
        && (Endpoint[0] != 0))
        {
        *Copy++ = RPC_CONST_CHAR('[');
        Copy = StringCopyEscapeCharacters(Copy, Endpoint);

        if (   (Options != 0)
            && (Options[0] != 0))
            {
            *Copy++ = RPC_CONST_CHAR(',');
            Copy = StringCopyEscapeCharacters(Copy, Options);
            }

        *Copy++ = RPC_CONST_CHAR(']');
        }
    else
        {
        if (   (Options != 0)
            && (Options[0] != 0))
            {
            *Copy++ = RPC_CONST_CHAR('[');
            *Copy++ = RPC_CONST_CHAR(',');
            Copy = StringCopyEscapeCharacters(Copy, Options);
            *Copy++ = RPC_CONST_CHAR(']');
            }
        }

    // And do not forget to terminate the string.

    *Copy = 0;

    return(StringBinding);
}


RPC_CHAR PAPI *
DCE_BINDING::ObjectUuidCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the object UUID
    component of the DCE_BINDING.  The string representation is
    suitable for using as the object UUID component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the object UUID is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (ObjectUuid.IsNullUuid() != 0)
        return(AllocateEmptyStringPAPI());

    // The string representation of a uuid is always 36 characters long
    // (and the extra character is for the terminating zero).

    String = (RPC_CHAR PAPI *) RpcpFarAllocate(37 * sizeof(RPC_CHAR));
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    else
        {
        ObjectUuid.ConvertToString(String);
        String[36] = 0;
        }

    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::RpcProtocolSequenceCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the RPC protocol sequence
    component of the DCE_BINDING.  The string representation is
    suitable for using as the RPC protocol sequence component of a
    string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the RPC protocol sequence is returned
    in a freshly allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (RpcProtocolSequence == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(RpcProtocolSequence);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::NetworkAddressCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the network address
    component of the DCE_BINDING.  The string representation is
    suitable for using as the network address component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the network address is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (NetworkAddress == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(NetworkAddress);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::EndpointCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the endpoint
    component of the DCE_BINDING.  The string representation is
    suitable for using as the endpoint component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the endpoint is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (Endpoint == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(Endpoint);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


RPC_CHAR PAPI *
DCE_BINDING::OptionsCompose (
    OUT RPC_STATUS PAPI * Status
    )
/*++

Routine Description:

    This method returns a string representation of the options
    component of the DCE_BINDING.  The string representation is
    suitable for using as the options component of a string binding.

Arguments:

    Status - Returns the status of the operation if there is insufficient
        memory to allocate for the string to be returned.

Return Value:

    The string representation of the options is returned in a freshly
    allocated string.

--*/
{
    RPC_CHAR PAPI * String;

    if (Options == 0)
        return(AllocateEmptyStringPAPI());

    String = DuplicateStringPAPI(Options);
    if (String == 0)
        *Status = RPC_S_OUT_OF_MEMORY;
    return(String);
}


BINDING_HANDLE *
DCE_BINDING::CreateBindingHandle (
    OUT RPC_STATUS *Status
    )
/*++
Routine Description:

    We will create a binding handle specific to the rpc protocol sequence
    specified by the DCE_BINDING object.  The object uuid will be
    passed on to the created binding handle.  Ownership of this
    passes to this routine.  If an error occurs, it will be deleted.

Arguments:
    The created binding handle will be returned, or zero if an error
    occured.

Return Value:
    RPC_S_OK - We had no trouble allocating the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory was available to
    complete the operation.

    RPC_S_INVALID_RPC_PROTSEQ - The rpc protocol sequence is
    syntactically invalid.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The requested rpc protocol sequence
    is not supported.
--*/
{
    TRANS_INFO *ClientTransInfo ;
    BINDING_HANDLE *BindingHandle ;

    if ( RpcpMemoryCompare(
                        RpcProtocolSequence,
                        RPC_CONST_STRING("ncalrpc"),
                        8 * sizeof(RPC_CHAR)) == 0 )
        {
        BindingHandle = LrpcCreateBindingHandle();

        if (BindingHandle == 0)
            {
            delete this;
            *Status =  RPC_S_OUT_OF_MEMORY;

            return 0;
            }
        }

    else if ( RpcpMemoryCompare(
                        RpcProtocolSequence,
                        RPC_CONST_STRING("ncadg_"),
                        6*sizeof(RPC_CHAR)) == 0)
        {
        BindingHandle = DgCreateBindingHandle();
        if (BindingHandle == 0)
            {
            delete this;
            *Status =  RPC_S_OUT_OF_MEMORY;

            return 0;
            }

        *Status = OsfMapRpcProtocolSequence(0,
                                                 RpcProtocolSequence,
                                                 &ClientTransInfo);

        if (*Status != RPC_S_OK)
            {
            delete BindingHandle;
            delete this;

            return 0;
            }
        }

    else if ( RpcpMemoryCompare(
                    RPC_CONST_STRING("ncacn_"),
                    RpcProtocolSequence,
                    6 * sizeof(RPC_CHAR)) == 0 )
        {
        BindingHandle = OsfCreateBindingHandle();
        if (BindingHandle == 0)
            {
            delete this;
            *Status =  RPC_S_OUT_OF_MEMORY;

            return 0;
            }

        *Status = OsfMapRpcProtocolSequence(0,
                                            RpcProtocolSequence,
                                            &ClientTransInfo) ;
        if (*Status != RPC_S_OK)
            {
            delete BindingHandle;
            delete this;

            return 0;
            }
        }
    else
        {
        delete this;
        *Status =  RPC_S_INVALID_RPC_PROTSEQ;

        return 0;
        }

    BindingHandle->SetObjectUuid(&ObjectUuid);
    *Status = BindingHandle->PrepareBindingHandle(ClientTransInfo, this);
    if (*Status != RPC_S_OK)
        {
        delete BindingHandle;
        delete this;

        return 0;
        }
    *Status = RPC_S_OK;
    return BindingHandle;
}


void
DCE_BINDING::AddEndpoint(
    IN RPC_CHAR *Endpoint
    )
/*++

Routine Description:

    This routine can be used to update the endpoint stored in the DCE_BINDING.
    If the DCE_BINDING already has an endpoint it is deleted.

Arguments:

    Endpoint - The new endpoint to store in this DCE_BINDING.  Ownership
               passes to this DCE_BINDING.

Return Value:

    n/a

--*/
{
    if (this->Endpoint)
        delete this->Endpoint;

    this->Endpoint = Endpoint;
}


RPC_STATUS
DCE_BINDING::ResolveEndpointIfNecessary (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_UUID * ObjectUuid,
    IN OUT void PAPI * PAPI * EpLookupHandle,
    IN BOOL UseEpMapperEp,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo OPTIONAL
    )
/*++

Routine Description:

    This routine will determine the endpoint if it is not specified.
    The arguments specifies interface information necessary to resolve
    the endpoint, as well as the object uuid.

Arguments:

    RpcInterfaceInformation - Supplies the interface information necessary
        to resolve the endpoint.

    ObjectUuid - Supplies the object uuid in the binding.

    EpLookupHandle - Supplies the current value of the endpoint mapper
        lookup handle for a binding, and returns the new value.

    ConnTimeout - the connection timeout

    CallTimeout - the call timeout

    AuthInfo - optional authentication info to be used when resolving the endpoint

Return Value:

    RPC_S_OK - The endpoint is fully resolved.

    RPC_S_NO_ENDPOINT_FOUND - The endpoint can not be resolved.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

    EPT_S_NOT_REGISTERED  - There are no more endpoints to be found
        for the specified combination of interface, network address,
        and lookup handle.

    EPT_S_CANT_PERFORM_OP - The operation failed due to misc. error e.g.
        unable to bind to the EpMapper.

--*/
{
    unsigned int Index;
    RPC_STATUS RpcStatus;
    UNICODE_STRING UnicodeString;

    if (   (Endpoint == 0)
        || (Endpoint[0] == 0) )
        {

        // This binding does not have an endpoint, so we must perform
        // binding resolution to obtain an endpoint.  First we look
        // in the interface information to see if an endpoint corresponding
        // to the rpc protocol sequence for this binding is there.

        for (Index = 0;
                Index < RpcInterfaceInformation->RpcProtseqEndpointCount;
                Index++)
            {
            RpcStatus = AnsiToUnicodeString(
                    RpcInterfaceInformation->RpcProtseqEndpoint[
                            Index].RpcProtocolSequence, &UnicodeString);

            if (RpcStatus != RPC_S_OK)
                return(RpcStatus);

            if ( RpcpStringCompare(RpcProtocolSequence,
                    UnicodeString.Buffer) == 0 )
                {
                RtlFreeUnicodeString(&UnicodeString);

                if (Endpoint != 0)
                    {
                    delete Endpoint;
                    Endpoint = 0;
                    }

                RpcStatus = AnsiToUnicodeString(
                        RpcInterfaceInformation->RpcProtseqEndpoint[
                                Index].Endpoint, &UnicodeString);

                if (RpcStatus != RPC_S_OK)
                    return(RpcStatus);

                Endpoint = DuplicateString(UnicodeString.Buffer);

                RtlFreeUnicodeString(&UnicodeString);

                if (Endpoint == 0)
                    return(RPC_S_OUT_OF_MEMORY);

                return(RPC_S_OK);
                }
            RtlFreeUnicodeString(&UnicodeString);
            }

        //The endpoint has not been supplied so resolve the endpoint.

        //CLH 2/17/94 If datagram and forward is required (that is
        //RpcEpResolveBinding has not been called), then simply put
        //the endpoint mapper's endpoint into this binding handles endpoint.
        //The endpoint mapper on the destination node will resolve the
        //endpoint and its runtime will forward the pkt.

        if (Endpoint != 0)
            {
            delete Endpoint;
            Endpoint = 0;
            }

        //
        // We cannot allow management interfaces to be resolved if they dont contain
        // an object uuid.
        //
        if (  (IsMgmtIfUuid ((UUID PAPI * )
                  &RpcInterfaceInformation->InterfaceId.SyntaxGUID))
              &&( (ObjectUuid == 0) ||
                  (RpcpMemoryCompare(ObjectUuid, &NullUuid, sizeof(UUID)) == 0) ) )
           {
           return(RPC_S_BINDING_INCOMPLETE);
           }

        if ( (RpcpMemoryCompare(RpcProtocolSequence,
                    RPC_CONST_STRING("ncadg_"), 6*sizeof(RPC_CHAR)) == 0)
              && (UseEpMapperEp != 0) )
          {
          RpcStatus = EpGetEpmapperEndpoint(
                        ((RPC_CHAR * PAPI *) &Endpoint),
                        RpcProtocolSequence);
          return((RpcStatus == RPC_S_OK) ?
                  RPC_P_EPMAPPER_EP : RpcStatus);
          }
        else
          {

          // Otherwise, we need to contact the endpoint mapper to
          // resolve the endpoint.

          return (EpResolveEndpoint((UUID PAPI *) ObjectUuid,
            &RpcInterfaceInformation->InterfaceId,
            &RpcInterfaceInformation->TransferSyntax,
            RpcProtocolSequence, 
            NetworkAddress, 
            Options, 
            EpLookupHandle, 
            ConnTimeout,
            CallTimeout,
            AuthInfo,
            (RPC_CHAR * PAPI *) &Endpoint));
          }
        }
    return(RPC_S_OK);
}


DCE_BINDING::Compare (
    IN DCE_BINDING * DceBinding,
    OUT BOOL *fOnlyEndpointDiffers
    )
/*++

Routine Description:

    This method compares two DCE_BINDING objects for equality.

Arguments:

    DceBinding - Supplies a DCE_BINDING object to compare with this.
    fOnlyEndpointDiffers - this output variable will be set to TRUE
        if the result is non-zero and only the endpoint is different.
        It will be set to FALSE if the result is non-zero, and there
        is more than the endpoint different. If this function returns
        0, the fOnlyEndpointDiffers argument is undefined.

Return Value:

    Zero will be returned if the specified DCE_BINDING object is the
    same as this.  Otherwise, non-zero will be returned.

--*/
{
    int Result;

    Result = CompareWithoutSecurityOptions(DceBinding,
        fOnlyEndpointDiffers);
    if (Result != 0)
        return Result;

    if (Options != 0)
        {
        if (DceBinding->Options != 0)
            {
            Result = RpcpStringCompare(DceBinding->Options, Options);
            }
        else
            Result = 1;
        }
    else
        {
        if (DceBinding->Options != 0)
            Result = 1;
        // else - Result has already been set from above
        //    Result = 0;
        }

    if (Result)
        {
        // if we didn't bail out after CompareWithoutSecurityOptions,
        // everything but the security options must have been the same
        // If Result is non-zero, only the security optinos have been
        // different. This means that it is not only the endpoint that
        // is different.
        *fOnlyEndpointDiffers = FALSE;
        }

    return(Result);
}

DCE_BINDING::CompareWithoutSecurityOptions (
    IN DCE_BINDING * DceBinding,
    OUT BOOL *fOnlyEndpointDiffers
    )
/*++

Routine Description:

    This method compares two DCE_BINDING objects for equality without
    comparing the security options.

Arguments:

    DceBinding - Supplies a DCE_BINDING object to compare with this.
    fOnlyEndpointDiffers - this output variable will be set to TRUE
        if the result is non-zero and only the endpoint is different.
        It will be set to FALSE if the result is non-zero, and there
        is more than the endpoint different. If this function returns
        0, the fOnlyEndpointDiffers argument is undefined.

Return Value:

    Zero will be returned if the specified DCE_BINDING object is the
    same as this.  Otherwise, non-zero will be returned.

--*/
{
    int Result;

    *fOnlyEndpointDiffers = FALSE;

    Result = RpcpMemoryCompare(&(DceBinding->ObjectUuid), &ObjectUuid, sizeof(UUID));
    if (Result != 0)
        return(Result);

    if (RpcProtocolSequence != 0)
        {
        if (DceBinding->RpcProtocolSequence != 0)
            {
            Result = RpcpStringCompare(DceBinding->RpcProtocolSequence,
                    RpcProtocolSequence);
            if (Result != 0)
                return(Result);
            }
        else
            return(1);
        }
    else
        {
        if (DceBinding->RpcProtocolSequence != 0)
            return(1);
        }

    if (NetworkAddress != 0)
        {
        if (DceBinding->NetworkAddress != 0)
            {
            Result = RpcpStringCompare(DceBinding->NetworkAddress,
                    NetworkAddress);
            if (Result != 0)
                return(Result);
            }
        else
            return(1);
        }
    else
        {
        if (DceBinding->NetworkAddress != 0)
            return(1);
        }

    *fOnlyEndpointDiffers = TRUE;

    if (Endpoint != 0)
        {
        if (DceBinding->Endpoint != 0)
            {
            Result = RpcpStringCompare(DceBinding->Endpoint, Endpoint);
            if (Result != 0)
                return(Result);
            }
        else
            return(1);
        }
    else
        {
        if (DceBinding->Endpoint != 0)
            return(1);
        }

    return(0);
}

DCE_BINDING *
DCE_BINDING::DuplicateDceBinding (
    )
/*++

Routine Description:

    We duplicate this DCE binding in this method.

Return Value:

    A duplicate DCE_BINDING to this DCE_BINDING will be returned, if
    everthing works correctly.  Otherwise, zero will be returned
    indicating an out of memory error.

--*/
{
    DCE_BINDING * DceBinding;
    RPC_STATUS Status = RPC_S_OK;
    RPC_CHAR ObjectUuidString[37];

    ObjectUuid.ConvertToString(ObjectUuidString);
    ObjectUuidString[36] = 0;

    DceBinding = new DCE_BINDING(ObjectUuidString,RpcProtocolSequence,
            NetworkAddress,Endpoint,Options,&Status);
    if (Status != RPC_S_OK)
        {
        ASSERT(Status == RPC_S_OUT_OF_MEMORY);
        delete DceBinding;
        return(0);
        }

    return(DceBinding);
}


void
DCE_BINDING::MakePartiallyBound (
    )
/*++

Routine Description:

    We need to make the binding into a partially bound one by setting the
    endpoint to zero.  This is really easy to do.

--*/
{
    if (Endpoint != 0)
        {
        delete Endpoint;
        Endpoint = 0;
        }
}

BOOL
DCE_BINDING::MaybeMakePartiallyBound (
    IN PRPC_CLIENT_INTERFACE RpcInterfaceInformation,
    IN RPC_UUID * MyObjectUuid
    )
/*++
Function Name:MaybeMakePartiallyBound

Parameters:

Description:
    If the interface can uniquely identify an RPC server on a machine, the
    binding is made partially bound. Otherwise, it is not.

Returns:


--*/
/*++

Routine Description:

--*/
{
    if ((IsMgmtIfUuid ((UUID PAPI * )
        &RpcInterfaceInformation->InterfaceId.SyntaxGUID))
        &&((MyObjectUuid == 0) ||
        (RpcpMemoryCompare(MyObjectUuid, &NullUuid, sizeof(UUID)) == 0)))
        {
        return FALSE;
        }

    MakePartiallyBound();
    return TRUE;
}

RPC_STATUS
IsRpcProtocolSequenceSupported (
    IN RPC_CHAR PAPI * RpcProtocolSequence
    )
/*++

Routine Description:

    This routine determines if the specified rpc protocol sequence is
    supported.  It will optionally return the parts of the rpc protocol
    sequence (rpc protocol specifier, and address + interface specifiers).

Arguments:

    RpcProtocolSequence - Supplies an rpc protocol sequence to check.

    RpcProtocolPart - Optionally returns the rpc protocol part of the
        rpc protocol sequence.

    AddressAndInterfacePart - Optionally returns the address and interface
        parts of the rpc protocol sequence.

Return Value:

    RPC_S_OK - The specified rpc protocol sequence is supported.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to check
        the rpc protocol sequence.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence is not
        supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

--*/
{
    RPC_STATUS Status;
    TRANS_INFO *ClientTransInfo ;
    size_t ProtSeqLength;

    ProtSeqLength = RpcpStringLength(RpcProtocolSequence);
    if ( (ProtSeqLength >= 7) 
            && 
         (RpcpMemoryCompare(RpcProtocolSequence, RPC_CONST_STRING("ncalrpc"),
                8 * sizeof(RPC_CHAR)) == 0) )
        {
        return(RPC_S_OK);
        }

    else if ( (ProtSeqLength >= 6) 
                && ((RpcpMemoryCompare(RPC_CONST_STRING("ncacn_"),
                        RpcProtocolSequence, 6 * sizeof(RPC_CHAR)) == 0 )
                    ||  ( RpcpMemoryCompare(RPC_CONST_STRING("ncadg_"), RpcProtocolSequence,
                            6 * sizeof(RPC_CHAR)) == 0 )) )

        {
        RPC_PROTSEQ_VECTOR *ProtseqVector;
        unsigned int i;

        Status = RpcNetworkInqProtseqs(&ProtseqVector);
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        Status = RPC_S_PROTSEQ_NOT_SUPPORTED;

        for (i = 0; i < ProtseqVector->Count; i++)
            {
            if (RpcpStringCompare(RpcProtocolSequence, ProtseqVector->Protseq[i]) == 0)
                {
                Status = RPC_S_OK;
                break;
                }
            }

        RpcProtseqVectorFree(&ProtseqVector);

        return(Status);
        }
    else if ( (ProtSeqLength >= 6) 
                && 
              (RpcpMemoryCompare(RpcProtocolSequence, RPC_CONST_STRING("mswmsg"),
                7 * sizeof(RPC_CHAR)) == 0) )
        {
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }

    return(RPC_S_INVALID_RPC_PROTSEQ);
}


LOADABLE_TRANSPORT::LOADABLE_TRANSPORT (
    IN RPC_TRANSPORT_INTERFACE  pTransportInterface,
    IN RPC_CHAR * DllName,
    IN RPC_CHAR PAPI * ProtocolSequence,
    IN DLL *LoadableTransportDll,
    IN FuncGetHandleForThread GetHandleForThread,
    IN FuncReleaseHandleForThread ReleaseHandleForThread,
    OUT RPC_STATUS *Status,
    OUT TRANS_INFO * PAPI *TransInfo
    ) :  nThreadsAtCompletionPort(0),
         ThreadsDoingLongWait(0)
/*++

Routine Description:

    To construct the object, all we have got to do is to copy the
    arguments into the object.

Arguments:

    DllName - Supplies the name of the dll from which this transport
        interface was loaded.

--*/
{
        
    RpcpStringCopy(this->DllName, DllName) ;
    LoadedDll = LoadableTransportDll;

    *TransInfo = new TRANS_INFO(pTransportInterface,
                                ProtocolSequence,
                                this) ;
    if (*TransInfo == 0)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        return ;
        }

    if (ProtseqDict.Insert(*TransInfo) == -1)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        return ;
        }

    ThreadsStarted = 0;
    nActivityValue = 0;
    nOptimalNumberOfThreads = gNumberOfProcessors + 1;
    ProcessCallsFunc = pTransportInterface->ProcessCalls;

    this->GetHandleForThread = GetHandleForThread;
    this->ReleaseHandleForThread = ReleaseHandleForThread;

#ifndef NO_PLUG_AND_PLAY
    PnpListen = pTransportInterface->PnpListen;
#endif

    *Status = RPC_S_OK;
    NumThreads = 0;
}


TRANS_INFO *
LOADABLE_TRANSPORT::MapProtocol (
    IN RPC_CHAR * DllName,
    IN RPC_CHAR PAPI * ProtocolSequence
    )
/*++

Routine Description:

    This method is used to search the dictionary.  It compares a
    LOADABLE_TRANSPORT with a transport interface to see if
    they match.

Arguments:

    DllName - Supplies the name of the dll from which this loadable
        transport interface was loaded.

Return Value:

--*/
{
    TRANS_INFO *Protseq ;
    TRANSPORT_LOAD TransportLoad;
    RPC_TRANSPORT_INTERFACE  pTransport;
    DictionaryCursor cursor;

    if (RpcpStringCompare(DllName, this->DllName) != 0)
        {
        return 0;
        }

    ProtseqDict.Reset(cursor) ;
    while ((Protseq = ProtseqDict.Next(cursor)) != 0)
        {
        if (Protseq->MatchProtseq(ProtocolSequence))
            {
            return Protseq ;
            }
        }

    if (GetTransportEntryPoints(LoadedDll, &TransportLoad,
            &GetHandleForThread,
            &ReleaseHandleForThread) == 0)
        return 0;

    pTransport = (*TransportLoad) (ProtocolSequence);

    if (pTransport == 0)
        {
        return 0 ;
        }

    Protseq = new TRANS_INFO(
                                pTransport,
                                ProtocolSequence,
                                this) ;
    if (Protseq == 0)
        {
        return 0;
        }

    if (ProtseqDict.Insert(Protseq) == -1)
        {
        delete Protseq ;
        return 0;
        }

    return Protseq ;
}


TRANS_INFO *
LOADABLE_TRANSPORT::MatchId (
    IN unsigned short Id
    )
{
    TRANS_INFO *Protseq ;
    DictionaryCursor cursor;

    ProtseqDict.Reset(cursor) ;
    while ((Protseq = ProtseqDict.Next(cursor)) != 0)
        {
        if (Protseq->MatchId(Id))
            {
            return Protseq ;
            }
        }

    return 0;
}

LOADABLE_TRANSPORT_DICT * LoadedLoadableTransports;

BOOL GetTransportEntryPoints(IN DLL *LoadableTransportDll, OUT TRANSPORT_LOAD *TransportLoad,
                             OUT FuncGetHandleForThread *GetHandleForThread,
                             OUT FuncReleaseHandleForThread *ReleaseHandleForThread
                             )
/*++
Function Name:GetTransportEntryPoints

Parameters: IN LoadableTransportDll - the DLL on which to obtain the entry points
            OUT TRANSPORT_LOAD *TransportLoad - the TransportLoad function for this DLL. 0 iff the 
                function fails
            OUT FuncGetHandleForThread *GetHandleForThread - the GetHandleForThread function for this DLL
            OUT FuncReleaseHandleForThread *ReleaseHandleForThread - the ReleaseHandleForThread
                function for this DLL

Description: Gets the entry points from this transport DLL

Returns: TRUE if successful, FALSE otherwise

--*/
{
    *TransportLoad = (TRANSPORT_LOAD) LoadableTransportDll->GetEntryPoint("TransportLoad");

    *GetHandleForThread = 
        (FuncGetHandleForThread) LoadableTransportDll->GetEntryPoint("GetCompletionPortHandleForThread");
    *ReleaseHandleForThread = 
        (FuncReleaseHandleForThread) LoadableTransportDll->GetEntryPoint("ReleaseCompletionPortHandleForThread");

    if ((*TransportLoad == 0)
        || (*GetHandleForThread == 0) 
        || (*ReleaseHandleForThread == 0)
        )
        {
        *TransportLoad = 0;
        return FALSE;
        }

    return TRUE;
}

RPC_STATUS
LoadableTransportInfo (
    IN RPC_CHAR * DllName,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    OUT TRANS_INFO * PAPI *pTransInfo
    )
/*++

Routine Description:

    We need to return the client information for the loadable transport
    specified by the argument, DllName.  This may mean that we need
    to load the transport support dll.

Argument:

    DllName - Supplies the name of the dll which we need to try and
        load to get the appropriate loadable transport interface.

    RpcProtocolSequence - Supplies the protocol sequence for which
        we are trying to find the appropriate loadable transport
        interface.

    Status - Returns the specific error code for failure to find/load
        a loadable transport.

Return Value:

    0 - If the specified transport interface can not be loaded for any
        reason: does not exist, out of memory, version mismatch, etc.

    Otherwise, a pointer to the client information for the requested
        transport interface (loadable transport support) will be returned.

--*/
{
    RPC_TRANSPORT_INTERFACE pTransportInterface;
    LOADABLE_TRANSPORT * LoadableTransport;
    TRANSPORT_LOAD TransportLoad;
    FuncGetHandleForThread GetHandleForThread;
    FuncReleaseHandleForThread ReleaseHandleForThread;
    DLL * LoadableTransportDll;
    RPC_STATUS Status = RPC_S_OK;
    DictionaryCursor cursor;

    ASSERT(Status == 0);

    // we can support only up to 4 loadable transports (though today we
    // use only 1 and we don't allow third parties to write their own). 
    // This allows us to avoid taking a mutex when browsing the 
    // LoadedLoadableTransports dictionary, as we never remove
    // transport from it
    ASSERT(LoadedLoadableTransports->Size() <= INITIALDICTSLOTS);

    //
    // To begin with, check to see if the transport is already loaded.
    // If so, all we have got to do is to return a pointer to it.
    //
    RequestGlobalMutex();
    LoadedLoadableTransports->Reset(cursor);
    while ((LoadableTransport
            = LoadedLoadableTransports->Next(cursor)) != 0)
        {
        *pTransInfo = LoadableTransport->MapProtocol (
                                                DllName,
                                                RpcProtocolSequence) ;
        if (*pTransInfo != 0)
            {
            ClearGlobalMutex();

            return RPC_S_OK;
            }
        }

    //
    // If we reach here, that means that we need to try and load the
    // specified loadable transport DLL.
    //
    LoadableTransportDll = new DLL(DllName, &Status);

    if (LoadableTransportDll == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    if (Status != RPC_S_OK)
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        VALIDATE(Status)
            {
            RPC_S_OUT_OF_MEMORY,
            RPC_S_INVALID_ARG
            } END_VALIDATE;

         if ( Status != RPC_S_OUT_OF_MEMORY )
            {
            ASSERT( Status == RPC_S_INVALID_ARG );
            Status = RPC_S_PROTSEQ_NOT_SUPPORTED;
            }

        return Status;
        }

    if (GetTransportEntryPoints(LoadableTransportDll, &TransportLoad, &GetHandleForThread, 
        &ReleaseHandleForThread) == 0)
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    pTransportInterface = (*TransportLoad)(RpcProtocolSequence);

    if ( pTransportInterface == 0 )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    if ( pTransportInterface->TransInterfaceVersion
        > RPC_TRANSPORT_INTERFACE_VERSION )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_PROTSEQ_NOT_SUPPORTED;
        }

    //
    // When we reach here, we have successfully loaded and initialized
    // the loadable transport DLL.  Now we need to create the client
    // loadable transport and stick it in the dictionary.
    //
    LoadableTransport = new LOADABLE_TRANSPORT(
                                                     pTransportInterface,
                                                     DllName,
                                                     RpcProtocolSequence,
                                                     LoadableTransportDll,
                                                     GetHandleForThread,
                                                     ReleaseHandleForThread,
                                                     &Status,
                                                     pTransInfo);

    if ( LoadableTransport == 0 )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;

        return RPC_S_OUT_OF_MEMORY;
        }

    if ( Status != RPC_S_OK
        || LoadedLoadableTransports->Insert(LoadableTransport) == -1 )
        {
        ClearGlobalMutex();
        delete LoadableTransportDll;
        delete LoadableTransport;

        return RPC_S_OUT_OF_MEMORY;
        }

    ClearGlobalMutex();

    return RPC_S_OK;
}

TRANS_INFO PAPI *
GetLoadedClientTransportInfoFromId(
    IN unsigned short Id
    )
/*++

Routine Description:

    We need to return the client information for the loadable transport
    specified by the argument, TransportId. We look into the DICT and see
    if the transport is loaded- it it isnt, tough- we will return an error.
    -this is because we need Protseq and dllname to load a transport and
    all we have is a transport ID.

Argument:

    Id - Transport Id. This is actually the opcode used to encode endpoint
         in a DCE tower. For a listing see DCE spec Chapter 11&12.

    Status - Returns the error/success code.

Return Value:

    0 - If the specified transport interface can not be loaded for any
        reason: does not exist, out of memory.

    Otherwise, a pointer to the client information for the requested
        transport interface (loadable transport support) will be returned.

--*/
{
    TRANS_INFO PAPI *TransInfo ;
    LOADABLE_TRANSPORT * LoadableTransport;
    DictionaryCursor cursor;

    // To begin with, check to see if the transport is already loaded.
    // If so, all we have got to do is to return a pointer to it.

    RequestGlobalMutex();
    LoadedLoadableTransports->Reset(cursor);
    while ((LoadableTransport
            = LoadedLoadableTransports->Next(cursor)) != 0)
        {
        TransInfo = LoadableTransport->MatchId(Id);
        if (TransInfo != 0)
           {
            ClearGlobalMutex();

            return(TransInfo);
           }
        }

    // If we reached here, that means that we are in trouble
    // We assumed that all relevant loadable transports will be
    // loaded for us.... but we are wrong!

    ClearGlobalMutex();
    return(0);
}



int
InitializeLoadableTransportClient (
    )
/*++

Routine Description:

    This routine will be called at DLL load time.  We do all necessary
    initializations here for this file.

Return Value:

    Zero will be returned if initialization completes successfully;
    otherwise, non-zero will be returned.

--*/
{

    LoadedLoadableTransports = new LOADABLE_TRANSPORT_DICT;
    if (LoadedLoadableTransports == 0)
        return(1);
    return(0);
}



inline
BOOL
ProcessIOEventsWrapper(
    IN LOADABLE_TRANSPORT PAPI *Transport
    )
/*++
Function Name:ProcessIOEventsWrapper

Parameters:

Description:

Returns:
    TRUE - thread should exit.

--*/
{
    Transport->ProcessIOEvents();
    return(TRUE);
}



RPC_STATUS
LOADABLE_TRANSPORT::StartServerIfNecessary (
    )
/*++
Function Name:StartServerIfNecessary

Parameters:

Description:

Returns:

--*/
{
    int i;
    RPC_STATUS Status ;
    int MinimumThreads = GlobalRpcServer->MinimumCallThreads ;

    if (    ThreadsStarted != 0
        ||  InterlockedIncrement(&ThreadsStarted) != 1)
        {
        return RPC_S_OK ;
        }

    Status = InitializeServerSideCellHeapIfNecessary();
    if (Status != RPC_S_OK)
        {
        ThreadsStarted = 0;
        return Status;
        }

    for (i = 0; i < MinimumThreads; i++)
        {
        InterlockedIncrement(&NumThreads);
        Status = GlobalRpcServer->CreateThread (
                             (THREAD_PROC) &ProcessIOEventsWrapper, this) ;
        if (Status != RPC_S_OK)
            {
            NumThreads = 0;
            ThreadsStarted = 0;
            return Status ;
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
LOADABLE_TRANSPORT::CreateThread (void)
/*++
Function Name:CreateThread

Parameters:

Description:

Returns:

--*/
{
    RPC_STATUS Status;

    if (NumThreads < 1)
        {
        Status = GlobalRpcServer->CreateThread (
                          (THREAD_PROC) &ProcessIOEventsWrapper, this) ;
        if (Status != RPC_S_OK)
            {
            return Status;
            }

        InterlockedIncrement(&NumThreads);
        }

    return RPC_S_OK;
}

inline
RPC_STATUS
LOADABLE_TRANSPORT::ProcessCalls (
    IN  INT Timeout,
    OUT RPC_TRANSPORT_EVENT *pEvent,
    OUT RPC_STATUS *pEventStatus,
    OUT PVOID *ppEventContext,
    OUT UINT *pBufferLength,
    OUT BUFFER *pBuffer,
    OUT PVOID *ppSourceContext)
/*++
Function Name:ProcessCalls

Parameters:

Description:

Returns:

--*/
{
    return (*ProcessCallsFunc) (
                            Timeout,
                            pEvent,
                            pEventStatus,
                            ppEventContext,
                            pBufferLength,
                            pBuffer,
                            ppSourceContext) ;
}

const ULONG MAX_THREAD_TIMEOUT = 660*1000;      // 11 minutes

void ProcessNewAddressEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                            IN RPC_TRANSPORT_EVENT Event,
                            IN RPC_STATUS EventStatus,
                            IN PVOID pEventContext,
                            IN UINT BufferLength,
                            IN BUFFER Buffer,
                            IN PVOID pSourceContext)
{
    LISTEN_FOR_PNP_NOTIFICATIONS PnpFunc;

    RpcpPurgeEEInfo();

    GlobalRpcServer->CreateOrUpdateAddresses();

#ifndef NO_PLUG_AND_PLAY
    PnpFunc = pLoadableTransport->PnpListen;
    (*PnpFunc)();
#endif
}

void ProcessConnectionServerReceivedEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                          IN RPC_TRANSPORT_EVENT Event,
                                          IN RPC_STATUS EventStatus,    // operation status
                                          IN PVOID pEventContext,   // trans conenction
                                          IN UINT BufferLength,     // buffer length
                                          IN BUFFER Buffer,         // buffer
                                          IN PVOID pSourceContext)
{
    OSF_SCONNECTION *SConnection = InqTransSConnection(pEventContext);
    
    ASSERT(SConnection->InvalidHandle(OSF_SCONNECTION_TYPE) == 0);

    RpcpPurgeEEInfo();

    SConnection->ProcessReceiveComplete(EventStatus,
                                        Buffer,
                                        BufferLength);
}

void ProcessConnectionServerSendEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                      IN RPC_TRANSPORT_EVENT Event,
                                      IN RPC_STATUS EventStatus,
                                      IN PVOID pEventContext,
                                      IN UINT BufferLength,
                                      IN BUFFER Buffer,
                                      IN PVOID pSourceContext   // send context
                                      )
{
    OSF_SCALL *SCall = InqTransSCall(pSourceContext);
    
    ASSERT(SCall->InvalidHandle(OSF_SCALL_TYPE) == 0);
    
    ASSERT(EventStatus != RPC_S_OK
           || ((rpcconn_common *) Buffer)->frag_length == BufferLength);

    RpcpPurgeEEInfo();

    SCall->ProcessSendComplete(EventStatus, Buffer);
}

void ProcessConnectionClientSendEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                      IN RPC_TRANSPORT_EVENT Event,
                                      IN RPC_STATUS EventStatus,    // Operation status
                                      IN PVOID pEventContext,
                                      IN UINT BufferLength,
                                      IN BUFFER Buffer,             // Buffer
                                      IN PVOID pSourceContext       // send context
                                      )
{
    REFERENCED_OBJECT *pObj;

    pObj = (REFERENCED_OBJECT *) *((PVOID *)
                     ((char *) pSourceContext - sizeof(void *)));
    ASSERT(pObj->InvalidHandle(OSF_CCALL_TYPE | OSF_CCONNECTION_TYPE) == 0);
    
    RpcpPurgeEEInfo();

    pObj->ProcessSendComplete(EventStatus, Buffer);
}

void ProcessConnectionClientReceiveEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                         IN RPC_TRANSPORT_EVENT Event,
                                         IN RPC_STATUS EventStatus, // operation status
                                         IN PVOID pEventContext,    // trans connection
                                         IN UINT BufferLength,      // buffer length
                                         IN BUFFER Buffer,          // buffer
                                         IN PVOID pSourceContext)
{
    OSF_CCONNECTION *CConnection = InqTransCConnection(pEventContext);

    ASSERT(CConnection->InvalidHandle(OSF_CCONNECTION_TYPE) == 0);
    ASSERT(CConnection->IsExclusive() == FALSE);

    RpcpPurgeEEInfo();

    CConnection->ProcessReceiveComplete(
                                EventStatus,
                                Buffer,
                                BufferLength);
    CConnection->RemoveReference();
}

void ProcessDatagramServerReceiveEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                       IN RPC_TRANSPORT_EVENT Event,
                                       IN RPC_STATUS EventStatus,
                                       IN PVOID pEventContext,
                                       IN UINT BufferLength,
                                       IN BUFFER Buffer,
                                       IN PVOID pSourceContext)
{
    ProcessDgServerPacket( EventStatus, 
        pEventContext, 
        Buffer, 
        BufferLength, 
        (DatagramTransportPair *)pSourceContext );
}

void ProcessDatagramClientReceiveEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                                       IN RPC_TRANSPORT_EVENT Event,
                                       IN RPC_STATUS EventStatus,
                                       IN PVOID pEventContext,
                                       IN UINT BufferLength,
                                       IN BUFFER Buffer,
                                       IN PVOID pSourceContext)
{
    ProcessDgClientPacket( EventStatus, 
        pEventContext, 
        Buffer, 
        BufferLength, 
        (DatagramTransportPair *)pSourceContext );
}

void ProcessRuntimePostedEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                               IN RPC_TRANSPORT_EVENT Event,
                               IN RPC_STATUS EventStatus,
                               IN PVOID pEventContext,
                               IN UINT BufferLength,
                               IN BUFFER Buffer,
                               IN PVOID pSourceContext)
{
    BOOL IsServer;
    BOOL SendToRuntime;
    RPC_STATUS RpcStatus;

    RpcpPurgeEEInfo();

    switch (BufferLength)
        {
        case CO_EVENT_BIND_TO_SERVER:

            extern void OsfBindToServer( PVOID Context );

            OsfBindToServer( pEventContext );
            break;

        case DG_EVENT_CALLBACK_COMPLETE:

            class DG_SCONNECTION;
            extern void ConvCallCompletedWrapper( PVOID Connection );

            ConvCallCompletedWrapper(pEventContext);
            break;

        case CO_EVENT_TICKLE_THREAD:
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Tickled\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
            // no-op
            break;

        case IN_PROXY_IIS_DIRECT_RECV:
            HTTP2IISDirectReceive(pEventContext);
            break;

        case HTTP2_DIRECT_RECEIVE:

            // For now we will not inject corruption prior to HTTP2DirectReceive.
            // We will need to query ((HTTP2EndpointReceiver *)pEventContext)->IsServer
            // to tell which kind of buffer this really is before injecting corruption.

            EventStatus = HTTP2DirectReceive(pEventContext,
                (BYTE **)&Buffer,
                (ULONG *)&BufferLength,
                &pEventContext,
                &IsServer
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                if (IsServer == FALSE)
                    {
                    ProcessConnectionClientReceiveEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                else
                    {
                    ProcessConnectionServerReceivedEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                }
            break;

        case HTTP2_WINHTTP_DIRECT_RECV:

            EventStatus = HTTP2WinHttpDirectReceive(pEventContext,
                (BYTE **)&Buffer,
                (ULONG *)&BufferLength,
                &pEventContext
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                ProcessConnectionClientReceiveEvent(pLoadableTransport,
                    Event,
                    EventStatus,
                    pEventContext,
                    BufferLength,
                    Buffer,
                    pSourceContext);
                }
            break;

        case HTTP2_WINHTTP_DIRECT_SEND:
            EventStatus = HTTP2WinHttpDirectSend(pEventContext,
                (BYTE **)&Buffer,
                &pSourceContext
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                ProcessConnectionClientSendEvent(pLoadableTransport,
                    Event,
                    EventStatus,
                    pEventContext,
                    BufferLength,
                    Buffer,
                    pSourceContext);
                }
            break;

        case PLUG_CHANNEL_DIRECT_SEND:
            RpcStatus = HTTP2PlugChannelDirectSend(pEventContext);
            ASSERT(RpcStatus == RPC_S_OK);
            break;

        case CHANNEL_DATA_ORIGINATOR_DIRECT_SEND:
            EventStatus = HTTP2ChannelDataOriginatorDirectSend(pEventContext,
                &IsServer,
                &pSourceContext,
                &Buffer,
                &BufferLength
                );

            if (EventStatus != RPC_P_PACKET_CONSUMED) 
                {
                if (IsServer == FALSE)
                    {
                    ProcessConnectionClientSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                else
                    {
                    ProcessConnectionServerSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                }
            break;

        case HTTP2_FLOW_CONTROL_DIRECT_SEND:
            EventStatus = HTTP2FlowControlChannelDirectSend(pEventContext,
                &IsServer,
                &SendToRuntime,
                &pSourceContext,
                &Buffer,
                &BufferLength
                );

            if ((EventStatus != RPC_P_PACKET_CONSUMED) && (SendToRuntime != FALSE)) 
                {
                if (IsServer == FALSE)
                    {
                    ProcessConnectionClientSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                else
                    {
                    ProcessConnectionServerSendEvent(pLoadableTransport,
                        Event,
                        EventStatus,
                        pEventContext,
                        BufferLength,
                        Buffer,
                        pSourceContext);
                    }
                }
            break;

        case HTTP2_RESCHEDULE_TIMER:
            HTTP2TimerReschedule(pEventContext);
            break;

        case HTTP2_ABORT_CONNECTION:
            HTTP2AbortConnection(pEventContext);
            break;

        case HTTP2_RECYCLE_CHANNEL:
            HTTP2RecycleChannel(pEventContext);
            break;

        default:
            ASSERT( 0 );
        }
}

void ProcessInvalidIOEvent(LOADABLE_TRANSPORT *pLoadableTransport, 
                           IN RPC_TRANSPORT_EVENT Event,
                           IN RPC_STATUS EventStatus,
                           IN PVOID pEventContext,
                           IN UINT BufferLength,
                           IN BUFFER Buffer,
                           IN PVOID pSourceContext)
{
    ASSERT(0);
}

void ProcessComplexTSend(LOADABLE_TRANSPORT *pLoadableTransport, 
                                       IN RPC_TRANSPORT_EVENT Event,
                                       IN RPC_STATUS EventStatus,   // status of the operation
                                       IN PVOID pEventContext,
                                       IN UINT BufferLength,
                                       IN BUFFER Buffer,
                                       IN PVOID pSourceContext      // send context
                                       )
{
    EventStatus = HTTP2ProcessComplexTSend(pSourceContext,
        EventStatus,
        &Buffer
        );

    if (EventStatus != RPC_P_PACKET_CONSUMED)
        {
        if ((Event & TYPE_MASK) == CLIENT)
            {
            ProcessConnectionClientSendEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext
                );
            }
        else
            {
            ProcessConnectionServerSendEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext
                );
            }
        }
}

void ProcessComplexTReceive(LOADABLE_TRANSPORT *pLoadableTransport, 
                            IN RPC_TRANSPORT_EVENT Event,
                            IN RPC_STATUS EventStatus,   // status of the operation
                            IN PVOID pEventContext,      // connection
                            IN UINT BufferLength,
                            IN BUFFER Buffer,
                            IN PVOID pSourceContext     // bytes received
                            )
{
    ULONG Bytes = PtrToUlong(pSourceContext);

    EventStatus = HTTP2ProcessComplexTReceive(&pEventContext,
        EventStatus,
        Bytes,
        &Buffer,
        &BufferLength
        );

    if ((EventStatus != RPC_P_PACKET_CONSUMED) 
        && (EventStatus != RPC_P_PARTIAL_RECEIVE))
        {
        if ((Event & TYPE_MASK) == CLIENT)
            {
            ProcessConnectionClientReceiveEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext);
            }
        else
            {
            ProcessConnectionServerReceivedEvent(pLoadableTransport,
                Event,
                EventStatus,
                pEventContext,
                BufferLength,
                Buffer,
                pSourceContext);
            }
        }
}

// note that this array must have correspondence to the constants in rpctrans.hxx
ProcessIOEventFunc *IOEventDispatchTable[LastRuntimeConstant + 1] = 
    {
    // 0 is CONNECTION | CLIENT | SEND
    ProcessConnectionClientSendEvent,
    // 1 is DATAGRAM | CLIENT | SEND
    ProcessInvalidIOEvent,
    // 2 is invalid
    ProcessInvalidIOEvent,
    // 3 is invalid
    ProcessInvalidIOEvent,
    // 4 is CONNECTION | SERVER | SEND
    ProcessConnectionServerSendEvent,
    // 5 is DATAGRAM | SERVER | SEND
    ProcessInvalidIOEvent,
    // 6 is invalid
    ProcessInvalidIOEvent,
    // 7 is invalid
    ProcessInvalidIOEvent,
    // 8 is CONNECTION | CLIENT | RECEIVE
    ProcessConnectionClientReceiveEvent,
    // 9 is DATAGRAM | CLIENT | RECEIVE
    ProcessDatagramClientReceiveEvent,
    // 10 is invalid
    ProcessInvalidIOEvent,
    // 11 is invalid
    ProcessInvalidIOEvent,
    // 12 is CONNECTION | SERVER | RECEIVE
    ProcessConnectionServerReceivedEvent,
    // 13 is DATAGRAM | SERVER | RECEIVE
    ProcessDatagramServerReceiveEvent,
    // 14 is invalid
    ProcessInvalidIOEvent,
    // 15 is invalid
    ProcessInvalidIOEvent,
    // 16 is COMPLEX_T | CONNECTION | SEND | CLIENT
    ProcessComplexTSend,
    // 17 is RuntimePosted
    ProcessRuntimePostedEvent,
    // 18 is NewAddress
    ProcessNewAddressEvent,
    // 19 is invalid
    ProcessInvalidIOEvent,
    // 20 is COMPLEX_T | CONNECTION | SEND | SERVER
    ProcessComplexTSend,
    // 21 is invalid
    ProcessInvalidIOEvent,
    // 22 is invalid
    ProcessInvalidIOEvent,
    // 23 is invalid
    ProcessInvalidIOEvent,
    // 24 is COMPLEX_T | CONNECTION | RECEIVE | CLIENT
    ProcessComplexTReceive,
    // 25 is invalid
    ProcessInvalidIOEvent,
    // 26 is invalid
    ProcessInvalidIOEvent,
    // 27 is invalid
    ProcessInvalidIOEvent,
    // 28 is COMPLEX_T | CONNECTION | RECEIVE | SERVER
    ProcessComplexTReceive
    };

const ULONG UndefinedLocalThreadTimeout = 0;

void LOADABLE_TRANSPORT::ProcessIOEvents (
    )
/*++
Function Name:ProcessIOEvents

Parameters:

Description:

Returns:
    TRUE - the thread should not be cached
    FALSE - the thread should be cached

--*/
{
    RPC_STATUS Status ;
    RPC_TRANSPORT_EVENT Event ;
    RPC_STATUS EventStatus ;
    PVOID EventContext ;
    BUFFER Buffer ;
    UINT BufferLength ;
    PVOID pSourceContext = 0;
    int Timeout = gThreadTimeout;
    unsigned int nLocalActivityValue = 0;
    int nOldActivityValue = nActivityValue;
    HANDLE hCompletionPortHandleForThread = GetHandleForThread();
    THREAD *CurrentThread;
    DebugThreadInfo *ThreadDebugCell;
    BOOL fThreadIsDoingLongWait = FALSE;
    ULONG LocalNumThreads;
    ULONG LocalThreadsDoingLongWait;
    long LocalMaxThreadTimeout;
#if defined (RPC_GC_AUDIT)
    long Temp;
#endif
    long ThreadActivationDelay;

    if (IocThreadStarted == 0)
        {
        IocThreadStarted = 1;
        }

    nThreadsAtCompletionPort.Increment();

    if ((gProrateStart > 0) && ((DWORD)nThreadsAtCompletionPort.GetInteger() > gProrateStart))
        {
        ThreadActivationDelay = nThreadsAtCompletionPort.GetInteger() - gProrateStart;
        if (ThreadActivationDelay > 0)
            {
            ThreadActivationDelay *= gProrateFactor;

            if ((DWORD)ThreadActivationDelay > gProrateMax)
                ThreadActivationDelay = gProrateMax;

            Sleep(ThreadActivationDelay);
            }
        }

    CurrentThread = RpcpGetThreadPointer();
    ASSERT(CurrentThread);
    ThreadDebugCell = CurrentThread->DebugCell;
    if (ThreadDebugCell)
        {
        ThreadDebugCell->Status = dtsIdle;
        ThreadDebugCell->LastUpdateTime = NtGetTickCount();
        ThreadDebugCell->Endpoint.CellID = 0;
        ThreadDebugCell->Endpoint.SectionID = 0;
        }

    while (1)
        {

        EventContext = hCompletionPortHandleForThread;
        Status = ProcessCalls (Timeout, 
                               &Event,
                               &EventStatus,
                               &EventContext,
                               &BufferLength,
                               &Buffer,
                               &pSourceContext);


        if (Status == RPC_S_OK)
            {
            InterlockedDecrement(&NumThreads);

            if (fThreadIsDoingLongWait)
                {
                fThreadIsDoingLongWait = FALSE;
#if defined (RPC_GC_AUDIT)
                Temp = ThreadsDoingLongWait.Decrement();
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: is coming back from long wait %d\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), Temp);
#else
                ThreadsDoingLongWait.Decrement();
#endif
                }

            Timeout = gThreadTimeout;

            if (ThreadDebugCell)
                {
                ThreadDebugCell->Status = dtsProcessing;
                ThreadDebugCell->LastUpdateTime = NtGetTickCount();
                }

            // capture the current activity state
            nOldActivityValue = nActivityValue;

            // indicate to the next thread that there's activity
            nLocalActivityValue ++;
            if ((nLocalActivityValue & 0xFF) == 0)
                nActivityValue ++;

            // make sure that the io event is within the bounds of the dispatch table
            ASSERT(Event < sizeof(IOEventDispatchTable) / sizeof(IOEventDispatchTable[0]));

            (*IOEventDispatchTable[Event])(this,
                                           Event,
                                           EventStatus,
                                           EventContext,
                                           BufferLength,
                                           Buffer,
                                           pSourceContext);

            InterlockedIncrement(&NumThreads);

            if (ThreadDebugCell)
                {
                ThreadDebugCell->Status = dtsIdle;
                ThreadDebugCell->LastUpdateTime = NtGetTickCount();
                }

            }
        else
            {
            BOOL fKeepThread = FALSE;

            // N.B. If a thread times out waiting for an Irp, we should
            // let it go, unless any one of the following conditions
            // exist:
            //  - it is the last listening thread on the port
            //  - there is an Irp pending on it
            //  - the port is busy, and we are at or below the optimal
            //    number of threads for this number of processors

            // N.B. The NumThreads and ThreadsDoingLongWait are not
            // changed atomically with respect to each other. This
            // opens a race condition, but the race is benign, if the
            // simple rule below is kept.
            // Whenever we change both NumThreads and 
            // ThreadsDoingLongWait, we must do so in a way that errs
            // to less threads doing short wait, rather than more
            // threads doing short wait. Thus we may scare somebody
            // into not doing a long wait, but that's better rather
            // than letting somebody do a long wait, and toasting the
            // garbage collection. For overview of the garbage
            // collection mechanism, see the header in GC.cxx
            ASSERT(Status == RPC_P_TIMEOUT);
            LocalNumThreads = InterlockedDecrement(&NumThreads);

            PerformGarbageCollection();

            if (!fThreadIsDoingLongWait)
                {
                // we will be conservative, and we will presume we will be
                // doing a long wait. If we're not, we'll decrement it later
                fThreadIsDoingLongWait = TRUE;
                LocalThreadsDoingLongWait = ThreadsDoingLongWait.Increment();
                }
            else
                {
                // we were already doing a long wait - just grab the current
                // value
                LocalThreadsDoingLongWait = ThreadsDoingLongWait.GetInteger();
                }

            // if there are no threads on short wait, and either one-time garbage
            // collection was requested (GarbageCollectionRequested), or items
            // with periodic garbage collection are requested 
            // (PeriodicGarbageCollectItems > 0), we can't go on a long wait
            if ((LocalNumThreads <= LocalThreadsDoingLongWait)
                && (GarbageCollectionRequested || (PeriodicGarbageCollectItems > 0)))
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: garbage collection requested - doing short wait %d, %d, %d, %d\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), LocalNumThreads,
                    LocalThreadsDoingLongWait, GarbageCollectionRequested, PeriodicGarbageCollectItems);
#endif
                // if garbage collection was requested, and there are
                // no threads doing a short wait, we can't do a long 
                // wait - indicate to the code below that gThreadTimeout
                // is the maximum allowed thread timeout and decrement
                // the number of threads doing a long wait (we incremented
                // it above - this decrement restores it)
                ASSERT (fThreadIsDoingLongWait);

                ThreadsDoingLongWait.Decrement();
                fThreadIsDoingLongWait = FALSE;

                LocalMaxThreadTimeout = gThreadTimeout;
                }
            else
                {
                // signal the code below that there is no restriction on
                // the timeout applied, and it is free to choose its
                // timeout
                LocalMaxThreadTimeout = UndefinedLocalThreadTimeout;
                }

            if (LocalNumThreads == 0)
                {
                fKeepThread = TRUE;

                if (LocalMaxThreadTimeout == UndefinedLocalThreadTimeout)
                    {
#if defined (RPC_GC_AUDIT)
                    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Max thread timeout\n",
                        GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                    ASSERT(fThreadIsDoingLongWait);

                    Timeout = INFINITE;
                    }
                else
                    {
                    ASSERT(fThreadIsDoingLongWait == FALSE);
                    Timeout = LocalMaxThreadTimeout;
                    }
                }
#ifdef RPC_OLD_IO_PROTECTION
            else if (ThreadSelf()->InqProtectCount() > 1)
#else
            // the simplest form of timing out threads introduces the following problem
            // On an MP box, if we have N processors executing N threads, we need to keep
            // an extra thread to listen for new requests. However, periodically, it will
            // timeout, die, and then get recreated by one of the executing threads which
            // picks a new call. This wastes cycles. If, on the other hand, on an MP box
            // we keep N+1 threads around, we hurt scalability in the ASP case.
            // We solve this problem by introducing the concept of a busy port. A port is
            // busy if it has served within one timeout period approximately 2048 or more
            // calls. If a port falls into the busy category, we don't let go the N+1th
            // thread on an MP box. If the port has activity, but not enough to get into
            // the busy category, we timeout the extra thread. 2048 is an arbitrary number
            // where we switch trading memory for speed. nOptimalNumberOfThreads is
            // the number of processors + 1 for this implementation.
            // since nLocalActivityValue is updated once per 256 requests (to avoid sloshing)
            // having a difference of 8 is approximately 2048 requests. There is wide
            // margin of error, as it is possible for threads to be anywhere in the 256
            // range and still count as nothing, but that's ok.
            else if ((nThreadsAtCompletionPort.GetInteger() <= nOptimalNumberOfThreads)
                        && ((nOldActivityValue + 8) < nActivityValue))
#endif
                {
                fKeepThread = TRUE;
                Timeout *= 2;

                if (LocalMaxThreadTimeout == UndefinedLocalThreadTimeout)
                    LocalMaxThreadTimeout = MAX_THREAD_TIMEOUT;

                // if by doubling we have exceeded the max timeout,
                // drop back to it
                if (Timeout > LocalMaxThreadTimeout)
                    {
                    Timeout = LocalMaxThreadTimeout;
                    }
                // else
                //    {
                //    We could have checked whether Timeout still falls into
                //    the short wait category after doubling, but we know
                //    that short wait is gThreadTimeout, and after doubling
                //    it will be bigger. Therefore, we don't need to do this
                //    check
                //    }

                if ((ULONG)Timeout > gThreadTimeout)
                    {
                    if (!fThreadIsDoingLongWait)
                        {
#if defined (RPC_GC_AUDIT)
                        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Doing long wait: %d\n",
                            GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), Timeout);
#endif
                        fThreadIsDoingLongWait = TRUE;
                        ThreadsDoingLongWait.Increment();
                        }
                    }
                }
            else
                {
                ASSERT(fKeepThread == FALSE);
                }

            nOldActivityValue = nActivityValue;

            if (fKeepThread)
                {
                InterlockedIncrement(&NumThreads);
                if (ThreadDebugCell)
                    {
                    RelocateCellIfPossible((void **) &ThreadDebugCell, &CurrentThread->DebugCellTag);
                    CurrentThread->DebugCell = ThreadDebugCell;
                    }
                }
            else
                {
                if (fThreadIsDoingLongWait)
                    {
                    ThreadsDoingLongWait.Decrement();
                    }
                else
                    {
                    // the only way this thread can be here is if
                    // all other threads are on long wait
                    ASSERT(LocalNumThreads <= LocalThreadsDoingLongWait);

                    // in this case, make a best effort to tickle one
                    // of the threads on a long wait. We ignore the result.
                    // This is ok, because it will only delay the gc until
                    // on of the long wait threads comes back.
                    TickleIocThread();
                    }
                break;
                }
            }
        }

    nThreadsAtCompletionPort.Decrement();

    if (ThreadDebugCell)
        {
        ThreadDebugCell->Status = dtsAllocated;
        ThreadDebugCell->LastUpdateTime = NtGetTickCount();
        }

    ReleaseHandleForThread(hCompletionPortHandleForThread);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dcecclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcecclnt.cxx

Abstract:

    This file just defines RPC_CLIENT_SIDE_ONLY and then includes
    rpccmmn.cxx to get the client parts of the common routines.
    
Author:

    Michael Montague (mikemon) 04-Nov-1991

Revision History:

--*/

#include <precomp.hxx>
#define RPC_CLIENT_SIDE_ONLY
#include <dcecmmn.cxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dbgcomn.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    DbgComn.h

Abstract:

    Some definitions included from too many places,
    including some pure C files.

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#ifndef __DBGCOMN_HXX__
#define __DBGCOMN_HXX__

#define RpcSectionPrefix  (L"\\RPC Control\\DSEC")
#define RpcSectionPrefixSize 17
// 3*8 is the max hex representation of three DWORDS
#define RpcSectionNameMaxSize   (RpcSectionPrefixSize + 3*8)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\bufapi.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    bufapi.cxx

Abstract:

    The two APIs used to allocate and free buffers used to make remote
    procedure calls reside in this file.  These APIs are used by both
    the client and server in caller and callee stubs.

Author:

    Michael Montague (mikemon) 07-Nov-1991

Revision History:

    Connie Hoppe     (connieh) 26-Jul-1993  I_RpcGetBuffer
    Kamen Moutafov   (kamenm)  Jan 2000 - Multiple transfer syntax support

--*/

#include <precomp.hxx>

inline RPC_STATUS CheckHandleValidity (IN OUT RPC_MESSAGE __RPC_FAR * Message)
{
    if (((GENERIC_OBJECT *) (Message->Handle))->InvalidHandle(
                                            CALL_TYPE | BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);
    else
        return RPC_S_OK;
}

RPC_STATUS 
EnterBufApiPartial (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    )
{
    THREAD *Thread;
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    // for WIN64, these are never set
#if !defined(_WIN64)
    // this is used to workaround a MIDL 1.0 bug
    // which didn't initialize the RpcFlags. MIDL 2.0 initializes the
    // flags correctly, and in addition sets this bit in the ProcNum
    // to indicate the flags are set correctly.
    if (Message->ProcNum & RPC_FLAGS_VALID_BIT)
        {
#endif
        // Flags are valid, clear the bit.
        Message->ProcNum &= ~(RPC_FLAGS_VALID_BIT);
#if !defined(_WIN64)
        }
    else
        {
        // Flags are invalid, set to zero.
        Message->RpcFlags = 0;
        }
#endif

    return RPC_S_OK;
}

RPC_STATUS 
EnterBufApiFull (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    )
{
    RPC_STATUS Status;

    Status = EnterBufApiPartial(Message);
    if (Status == RPC_S_OK)
        Status = CheckHandleValidity (Message);
    return Status;
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
I_RpcNegotiateTransferSyntax (
    IN OUT RPC_MESSAGE __RPC_FAR * Message
    )
/*++

Routine Description:

    NDR calls this routine to get the transfer syntax to be used in marshalling.
    Stubs that are multiple transfer syntax aware (starting with the 64 bit release
    of Win2000) will set the RPCFLG_HAS_MULTI_SYNTAXES in RPC_CLIENT_INTERFACE
    to indicate they have properly initialized the InterpreterInfo field. Legacy
    stubs will not have this flag initialized, and will call I_RpcGetBuffer[WithObject]
    directly. The runtime has to be prepared to deal with this. Stubs that
    support only NDR2.0 are free to behave as legacy stubs.

Arguments:

    Message - Supplies the information necessary to allocate the buffer,
        and returns the allocated buffer. This function assumes that
        the handle passed in Message->Handle is a binding handle. It also
        assumes Message->TransferSyntax is valid.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_STATUS Status;
    MESSAGE_OBJECT *MessageObject;

    // validate and transorm some input parameters
    Status = EnterBufApiFull(Message);

    MessageObject = (MESSAGE_OBJECT *)Message->Handle;

    if (Status != RPC_S_OK)
        return Status;

    return MessageObject->NegotiateTransferSyntax(Message);
}


RPC_STATUS RPC_ENTRY
I_RpcGetBufferWithObject (
    IN OUT PRPC_MESSAGE Message,
    IN UUID * ObjectUuid
    )
/*++

Routine Description:

    In this API, we do all of the rpc protocol module independent work of
    allocating a buffer to be used in making a remote procedure call.  This
    consists of validating the handle, and then calling the rpc protocol
    module to do the real work.


Arguments:

    Message - Supplies the information necessary to allocate the buffer,
        and returns the allocated buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_STATUS Status;
    RPC_CLIENT_INTERFACE *ClientInterface;
    BOOL fObjectIsSCall;
    MESSAGE_OBJECT *MessageObject;

    Status = CheckHandleValidity (Message);
    if (Status)
        return Status;

    MessageObject = (MESSAGE_OBJECT *)Message->Handle;
    fObjectIsSCall = MessageObject->Type(SCALL_TYPE);

    // in all fairness, this could very well be a server interface, but
    // they have the same layout, and the Flags field is in the same place,
    // so we can test the Flags field as if this is a client interface
    ClientInterface = (RPC_CLIENT_INTERFACE *)Message->RpcInterfaceInformation;

    // check whether this is a client stub that supports multiple transfer 
    // syntaxes if yes, it should have called I_RpcNegotiateTransferSyntax 
    // by now
    if (!fObjectIsSCall && DoesInterfaceSupportMultipleTransferSyntaxes(ClientInterface))
        {
        // if this interface supports multiple transfer syntaxes
        // the stub should have called already I_RpcNegotiateTransferSyntax
        // and this cannot be an OSF_BINDING_HANDLE
        ASSERT(!MessageObject->Type(OSF_BINDING_HANDLE_TYPE));
        ASSERT(!MessageObject->Type(LRPC_BINDING_HANDLE_TYPE));

        if (ObjectUuid && ((RPC_UUID *) ObjectUuid)->IsNullUuid())
            {
            ObjectUuid = 0;
            }

        Status = MessageObject->GetBuffer(Message, ObjectUuid);
        }
    else
        {

        // if not, this is either a legacy stub, a new stub that supports
        // one transfer syntax only, or a server side call

        // validate the input parameters
        Status = EnterBufApiPartial(Message);
        if (Status != RPC_S_OK)
            return Status;

        if (!fObjectIsSCall)
            {
            // this applies only on the client side
            Status = MessageObject->NegotiateTransferSyntax(Message);
            if (Status != RPC_S_OK)
                return Status;
            MessageObject = (MESSAGE_OBJECT *)Message->Handle;

            if (ObjectUuid && ((RPC_UUID *) ObjectUuid)->IsNullUuid())
                {
                ObjectUuid = 0;
                }
            }

        // by now this should not be a binding handle object
        ASSERT(!MessageObject->Type(OSF_BINDING_HANDLE_TYPE));
        ASSERT(!MessageObject->Type(LRPC_BINDING_HANDLE_TYPE));
        Status = MessageObject->GetBuffer(Message, ObjectUuid);
        }

#ifdef DEBUGRPC
    if ( Status == RPC_S_OK )
        {
        // Ensure that the buffer is aligned
        ASSERT( (((ULONG_PTR) Message->Buffer) % 8) == 0);

        // Uncomment this to check for 16 byte alignment on 64 bit
        // ASSERT( IsBufferAligned(Message->Buffer) );
        }
#endif // DEBUGRPC

    return(Status);
}

RPC_STATUS RPC_ENTRY
I_RpcGetBuffer (
    IN OUT PRPC_MESSAGE Message
    )
{
    return I_RpcGetBufferWithObject (Message, 0);
}


RPC_STATUS RPC_ENTRY
I_RpcFreeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    The stubs free buffers using the API.  The buffer must have been
    obtained from I_RpcGetBuffer or I_RpcSendReceive, or as an argument
    to a callee stub.

Arguments:

    Message - Supplies the buffer to be freed and handle information
        about who owns the buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    ASSERT( ((GENERIC_OBJECT *) Message->Handle)->InvalidHandle(CALL_TYPE) == 0 );

    ((MESSAGE_OBJECT *) (Message->Handle))->FreeBuffer(Message);

    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
I_RpcFreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Free the buffer that was either implicitly or explicitly allocated for use
    in conjunction with pipes

Arguments:

    Message - Supplies the buffer to be freed and handle information
        about who owns the buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    ASSERT( ((GENERIC_OBJECT *) Message->Handle)->InvalidHandle(CALL_TYPE) == 0 );

    ((MESSAGE_OBJECT *) (Message->Handle))->FreePipeBuffer(Message);

    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
I_RpcReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

    Realloc a buffer, this is API is used in conjunction with pipes

Arguments:

    Message - Supplies the buffer to be freed and handle information
        about who owns the buffer.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/

{
    AssertRpcInitialized();

    ASSERT(!RpcpCheckHeap());

    ASSERT( ((GENERIC_OBJECT *) Message->Handle)->InvalidHandle(CALL_TYPE) == 0 );

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    RpcpPurgeEEInfo();

    return ((MESSAGE_OBJECT *) (Message->Handle))->ReallocPipeBuffer(Message, NewSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dcecmisc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcecmisc.cxx


Abstract:

    This module contains the code implementing miscellaneous DCE RPC
    runtime APIs.  In particular, this includes the following APIs:
    RpcIfInqId, RpcNetworkIsProtseqValid, RpcMgmtInqComTimeout,
    RpcMgmtSetComTimeout, RpcMgmtSetCancelTimeout, and DceErrorInqText.

Author:

    Michael Montague (mikemon) 11-Nov-1991

Revision History:

--*/

#include <precomp.hxx>

#if !defined(_M_IA64)
unsigned long RecvWindow = 0;
unsigned long SendWindow = 0;
#endif

RPC_STATUS RPC_ENTRY
RpcIfInqId (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_IF_ID PAPI * RpcIfId
    )
/*++

Routine Description:

    The routine is used by an application to obtain the interface
    identification part of an interface specification.  This is a really
    simple API since the RpcIfHandle points to the interface information,
    so all we have got to do is cast RpcIfHandle and copy some stuff.

Arguments:

    RpcIfHandle - Supplies a handle to the interface specification.

    RpcIfId - Returns the interface identification part of the interface
        specification.

Return Value:

    RPC_S_OK - The operation completed successfully.

--*/
{
    RPC_CLIENT_INTERFACE PAPI * RpcInterfaceInformation;

    InitializeIfNecessary();

    RpcInterfaceInformation = (RPC_CLIENT_INTERFACE PAPI *) RpcIfHandle;
    RpcpMemoryCopy(&(RpcIfId->Uuid),
            &(RpcInterfaceInformation->InterfaceId.SyntaxGUID),sizeof(UUID));
    RpcIfId->VersMajor =
            RpcInterfaceInformation->InterfaceId.SyntaxVersion.MajorVersion;
    RpcIfId->VersMinor =
            RpcInterfaceInformation->InterfaceId.SyntaxVersion.MinorVersion;
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcNetworkIsProtseqValid (
    IN unsigned short PAPI * Protseq
    )
/*++

Routine Description:

    An application program will use this API to determine if an rpc
    protocol sequence is supported by the current system.

Arguments:

    Protseq - Supplies an rpc protocol sequence to be check to see if
        it is supported.

Return Value:

    RPC_S_OK - The specified rpc protocol sequence is support.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        invalid.

--*/
{
    InitializeIfNecessary();

    return(IsRpcProtocolSequenceSupported(Protseq));
}


RPC_STATUS RPC_ENTRY
RpcMgmtInqComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int PAPI * Timeout
    )
/*++

Routine Description:

    This routine is used to obtain the communications timeout from a
    binding handle.

Arguments:

    Binding - Supplies a binding handle from which to inquire the
        communication timeout.

    Timeout - Returns the communications timeout in the binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The specified binding is not a client side
        binding handle.
--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    *Timeout = BindingHandle->InqComTimeout();
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtSetComTimeout (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned int Timeout
    )
/*++

Routine Description:

    An application will use this routine to set the communications
    timeout for a binding handle.  The timeout value specifies the
    relative amount of time that should be spent to establish a binding
    to the server before giving up.

Arguments:

    Binding - Supplies the binding handle for which the communications
        timeout value will be set.

    Timeout - Supplies the communications timeout value to set in the
        binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The specified binding is not a client side
        binding handle.

    RPC_S_INVALID_TIMEOUT - The specified timeout value is invalid.

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->SetComTimeout(Timeout));
}


RPC_STATUS RPC_ENTRY
I_RpcIfInqTransferSyntaxes (
    IN RPC_IF_HANDLE RpcIfHandle,
    OUT RPC_TRANSFER_SYNTAX PAPI * TransferSyntaxes,
    IN unsigned int TransferSyntaxSize,
    OUT unsigned int PAPI * TransferSyntaxCount
    )
/*++

Routine Description:

    This routine will be used to obtain the transfer syntaxes support
    by an interface.  A description of the interface is supplied via
    the interface handle.

Arguments:

    RpcIfHandle - Supplies a reference to the interface from which we
        want to inquire the transfer syntaxes.

    TransferSyntaxes - Returns a copy of the transfer syntaxes support
        by the interface.

    TransferSyntaxSize - Supplies the number of RPC_TRANSFER_SYNTAX records
        which can fit in the transfer syntaxes buffer.

    TransferSyntaxCount - Returns the number of transfer syntaxes supported
        by the interface.  This value will always be returned, whether or
        not an error occurs.

Return Value:

    RPC_S_OK - We copied the transfer syntaxes into the buffer successfully.

    RPC_S_BUFFER_TOO_SMALL - The supplies transfer syntaxes buffer is too
        small; the transfer syntax count parameter will return the minimum
        size required.

--*/
{
    RPC_CLIENT_INTERFACE PAPI * RpcInterfaceInformation;

    *TransferSyntaxCount = 1;
    if (TransferSyntaxSize < 1)
        return(RPC_S_BUFFER_TOO_SMALL);

    RpcInterfaceInformation = (RPC_CLIENT_INTERFACE PAPI *) RpcIfHandle;
    RpcpMemoryCopy(&(TransferSyntaxes->Uuid),
            &(RpcInterfaceInformation->TransferSyntax.SyntaxGUID),
            sizeof(UUID));
    TransferSyntaxes->VersMajor =
        RpcInterfaceInformation->TransferSyntax.SyntaxVersion.MajorVersion;
    TransferSyntaxes->VersMinor =
        RpcInterfaceInformation->TransferSyntax.SyntaxVersion.MinorVersion;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtEnableIdleCleanup (
    void
    )
/*++

Routine Description:

    An application will use this routine to enable cleanup of idle resources.
    For the connection oriented protocol module, a connection must be idle
    for five minutes before it is cleaned up.

Return Value:

    RPC_S_OK - Cleanup of idle resources has been enabled.

    RPC_S_OUT_OF_THREADS - Insufficient threads are available to be able
        to perform this operation.

    RPC_S_OUT_OF_RESOURCES - Insufficient resources are available to be
        able to perform this operation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to be able to
        perform this operation.

--*/
{
    InitializeIfNecessary();

    return(EnableIdleConnectionCleanup());
}


RPC_STATUS RPC_ENTRY
DceErrorInqTextA (
    IN RPC_STATUS RpcStatus,
    OUT unsigned char __RPC_FAR * ErrorText
    )
/*++

Routine Description:

    The supplied status code is converted into a text message if possible.

Arguments:

    RpcStatus - Supplies the status code to convert.

    ErrorText - Returns a character string containing the text message
        for the status code.

Return Value:

    RPC_S_OK - The supplied status codes has successfully been converted
        into a text message.

    RPC_S_INVALID_ARG - The supplied value is not a valid status code.

--*/
{
    if ( FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS
            | FORMAT_MESSAGE_FROM_SYSTEM, 0, RpcStatus, 0, (char *)ErrorText,
            DCE_C_ERROR_STRING_LEN, 0) == 0 )
        {
          if ( FormatMessageA( FORMAT_MESSAGE_IGNORE_INSERTS |
                   FORMAT_MESSAGE_FROM_SYSTEM, 0, RPC_S_NOT_RPC_ERROR,
                   0, (char *)ErrorText, DCE_C_ERROR_STRING_LEN,  0 ) == 0 )
              {
              *ErrorText = '\0';
              return(RPC_S_INVALID_ARG);
              }
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
DceErrorInqTextW (
    IN RPC_STATUS RpcStatus,
    OUT unsigned short __RPC_FAR * ErrorText
    )
/*++

Routine Description:

    The supplied status code is converted into a text message if possible.

Arguments:

    RpcStatus - Supplies the status code to convert.

    ErrorText - Returns a character string containing the text message
        for the status code.

Return Value:

    RPC_S_OK - The supplied status codes has successfully been converted
        into a text message.

    RPC_S_INVALID_ARG - The supplied value is not a valid status code.

--*/
{
    if ( FormatMessageW(FORMAT_MESSAGE_IGNORE_INSERTS
            | FORMAT_MESSAGE_FROM_SYSTEM, 0, RpcStatus, 0, ErrorText,
            DCE_C_ERROR_STRING_LEN * sizeof(RPC_CHAR), 0) == 0 )
        {
          if ( FormatMessageW( FORMAT_MESSAGE_IGNORE_INSERTS |
                FORMAT_MESSAGE_FROM_SYSTEM, 0, RPC_S_NOT_RPC_ERROR, 0,
                ErrorText, DCE_C_ERROR_STRING_LEN * sizeof(RPC_CHAR),0 ) == 0 )
              {
              *ErrorText = 0;
              return(RPC_S_INVALID_ARG);
              }
        }

    return(RPC_S_OK);
}


#if !defined(_M_IA64)
RPC_STATUS RPC_ENTRY
I_RpcConnectionInqSockBuffSize(
  OUT unsigned long __RPC_FAR * RecvBuffSize,
  OUT unsigned long __RPC_FAR * SendBuffSize
  )
{
    RequestGlobalMutex();

    *RecvBuffSize = RecvWindow;
    *SendBuffSize = SendWindow;

    ClearGlobalMutex();
    return (RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
I_RpcConnectionSetSockBuffSize(
   IN unsigned long RecvBuffSize,
   IN unsigned long SendBuffSize
   )
{
    if (RecvBuffSize > 0xFFFF)
        {
        RecvBuffSize = 0xFFFF;
        }
    if (SendBuffSize > 0xFFFF)
        {
        SendBuffSize = 0xFFFF;
        }
    RequestGlobalMutex();
    RecvWindow =  RecvBuffSize;
    SendWindow = SendBuffSize;
    ClearGlobalMutex();

    return (RPC_S_OK);
}


void RPC_ENTRY
I_RpcConnectionInqSockBuffSize2(
    OUT unsigned long __RPC_FAR * RecvWindowSize
    )
{
    *RecvWindowSize = RecvWindow;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\clntapip.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1991 - 1999
//
//  File:       clntapip.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File : clntapip.cxx

Description :

This file contains the private entry points into the client (and
server) runtime.

History :

mikemon    02-02-91    Created.

-------------------------------------------------------------------- */

#include <precomp.hxx>

#ifdef DOS
THREAD ThreadStatic;
#endif

void PAPI * RPC_ENTRY
I_RpcAllocate (
    IN unsigned int size
    )
{
#ifdef RPC_DELAYED_INITIALIZATION

    if ( RpcHasBeenInitialized == 0 )
        {
        if ( PerformRpcInitialization() != RPC_S_OK )
            {
            return(0);
            }
        }

#endif // RPC_DELAYED_INITIALIZATION

    return(RpcpFarAllocate(size));
}

void RPC_ENTRY
I_RpcFree (
    IN void PAPI * obj
    )
{
    RpcpFarFree(obj);
}

void PAPI * RPC_ENTRY
I_RpcBCacheAllocate (
    IN unsigned int size
    )
{
    if (!ThreadSelf())
        return NULL;
    return(RpcAllocateBuffer(size));
}

void RPC_ENTRY
I_RpcBCacheFree (
    IN void PAPI * obj
    )
{
    RpcFreeBuffer(obj);
}

RPC_STATUS 
I_RpcSetNDRSlot(
    IN void *NewSlot
    )
{
    return RpcpSetNDRSlot(NewSlot);
}

void *
I_RpcGetNDRSlot(
    void
    )
{
    return RpcpGetNDRSlot();
}

void RPC_ENTRY
I_RpcPauseExecution (
    IN unsigned long milliseconds
    )
{
    PauseExecution(milliseconds);
}

const ULONG FatalExceptions[] = 
    {
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW
    };

const int FATAL_EXCEPTIONS_ARRAY_SIZE = sizeof(FatalExceptions) / sizeof(FatalExceptions[0]);

int 
RPC_ENTRY
I_RpcExceptionFilter (
    unsigned long ExceptionCode
    )
{
    int i;

    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i ++)
        {
        if (ExceptionCode == FatalExceptions[i])
            return EXCEPTION_CONTINUE_SEARCH;
        }

    return EXCEPTION_EXECUTE_HANDLER;
}

#ifdef STATS
DWORD g_dwStat1 = 0;
DWORD g_dwStat2 = 0;
DWORD g_dwStat3 = 0;
DWORD g_dwStat4 = 0;

void RPC_ENTRY I_RpcGetStats(DWORD *pdwStat1, DWORD *pdwStat2, DWORD *pdwStat3, DWORD *pdwStat4)
{
	GetStats(pdwStat1, pdwStat2, pdwStat3, pdwStat4);
}
#endif

extern "C"
{
void RPC_ENTRY
I_RpcTimeReset(
    void
    )
/*++

Routine Description:

    This routine is no longer used, however, because it is exported by the
    dll, we need to leave the entry point.

--*/
{

}

void RPC_ENTRY
I_RpcTimeCharge(
    unsigned int Ignore
    )
/*++

Routine Description:

    This routine is no longer used, however, because it is exported by the
    dll, we need to leave the entry point.

--*/
{
    UNUSED(Ignore);
}

unsigned long * RPC_ENTRY
I_RpcTimeGet(
    char __RPC_FAR * Ignore
    )
/*++

Routine Description:

    This routine is no longer used, however, because it is exported by the
    dll, we need to leave the entry point.

--*/
{
    UNUSED(Ignore);

    return(0);
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\cellheap.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    CellHeap.cxx

Abstract:

    The functions for the cell heap. Implements a heap
    of cells, each one of equal size with high locality
    of reference.

Author:

    Kamen Moutafov (kamenm)   Dec 99 - Feb 2000

Revision History:

--*/

#include <precomp.hxx>
#include <CellHeap.hxx>
#include <MutexWrp.hxx>

// explicit placement new operator
inline
PVOID __cdecl
operator new(
        size_t size,
        PVOID pPlacement
        )
{
        return pPlacement;
}

const int NumberOfSectionNameRetries = 301;

CellHeap *g_pCellHeap = NULL;
BOOL g_fServerSideCellHeapInitialized = FALSE;
CellSection *pCachedCellSection = NULL;

MUTEX *CellHeap::EffectiveCellHeapMutex = NULL;

#define MAJOR_CELLHEAP_DEBUG

#if DBG
int CellHeap::NumberOfCellsPerFirstPageInSection = 0;
int CellHeap::NumberOfCellsPerPageInSection = 0;
#endif

CellSection *CellSection::AllocateCellSection(OUT RPC_STATUS *Status, 
    IN BOOL fFirstSection, IN SECURITY_DESCRIPTOR *pSecDescriptor, 
    IN CellHeap *pCellHeap)
{
    HANDLE hFileMapping;
    PVOID SectionPointer;
    BOOL bRes;
    int SectionSize = NumberOfPagesPerSection * gPageSize;
    RPC_CHAR SectionName[RpcSectionNameMaxSize];     // 3*8 is the max hex representation
                        // of three DWORDS 
    DWORD RandomNumber[2];
    RPC_CHAR *SectionNamePointer;
    int i;
    CellSection *pCellSection;
    UNICODE_STRING SectionNameString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess;
    LARGE_INTEGER SectionSizeParam;
    NTSTATUS NtStatus;
    DWORD ProcessID = GetCurrentProcessId();

    for (i = 0; i < NumberOfSectionNameRetries; i ++)
        {
        // we'll try creating a named object until the last try, when
        // we're content with creating any object
        if (i == (NumberOfSectionNameRetries - 1))
            {
            SectionNamePointer = NULL;
            }
        else
            {
            // the first section is named with the prefix and PID only,
            // which makes the other stuff unnecessary
            if (!fFirstSection)
                {
                // generate the random numbers
                *Status = GenerateRandomNumber((unsigned char *)RandomNumber, 8);
                if (*Status != RPC_S_OK)
                    return NULL;

                GenerateSectionName(SectionName, sizeof(SectionName), ProcessID, RandomNumber);
                }
            else
                {
                GenerateSectionName(SectionName, sizeof(SectionName), ProcessID, NULL);

                // ensure there are no retries for the first section
                i = NumberOfSectionNameRetries - 2;
                }

            SectionNamePointer = SectionName;
            }

        DesiredAccess = STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_READ | SECTION_MAP_WRITE;
        RtlInitUnicodeString(&SectionNameString, SectionNamePointer);
        InitializeObjectAttributes(&ObjectAttributes,
            &SectionNameString,
            OBJ_CASE_INSENSITIVE,
            0,
            pSecDescriptor);
        SectionSizeParam.LowPart = SectionSize;
        SectionSizeParam.HighPart = 0;

        NtStatus = NtCreateSection(&hFileMapping, DesiredAccess, &ObjectAttributes, &SectionSizeParam,
            PAGE_READWRITE, SEC_RESERVE, NULL);
        if (!NT_SUCCESS(NtStatus))
            {
            if (NtStatus == STATUS_NO_MEMORY)
                *Status = RPC_S_OUT_OF_MEMORY;
            else if ((NtStatus == STATUS_INSUFFICIENT_RESOURCES) || (NtStatus == STATUS_QUOTA_EXCEEDED))
                *Status = RPC_S_OUT_OF_RESOURCES;
            else if ((NtStatus == STATUS_OBJECT_PATH_INVALID)
                || (NtStatus == STATUS_OBJECT_PATH_NOT_FOUND)
                || (NtStatus == STATUS_OBJECT_NAME_INVALID)
                || (NtStatus == STATUS_OBJECT_NAME_COLLISION))
                {
                *Status = RPC_S_INTERNAL_ERROR;
                }
            else if (NtStatus == STATUS_OBJECT_TYPE_MISMATCH)
                {
                // somebody is attacking us, or there is a collision - try again
                continue;
                }
            else
                {
                ASSERT(0);
                *Status = RPC_S_OUT_OF_MEMORY;
                }
            return NULL;
            }
        else if (NtStatus == STATUS_OBJECT_NAME_EXISTS)
            {
            CloseHandle(hFileMapping);
            hFileMapping = NULL;
            }
        else
            {
            ASSERT(hFileMapping != NULL);
            break;
            }

        // name conflict - keep trying
        }

    SectionPointer = MapViewOfFileEx(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, SectionSize, NULL);
    if (SectionPointer == NULL)
        {
        *Status = GetLastError();
        CloseHandle(hFileMapping);
        return NULL;
        }

    if (VirtualAlloc(SectionPointer, 1, MEM_COMMIT, PAGE_READWRITE) == NULL)
        {
        *Status = GetLastError();
        CloseDbgSection(hFileMapping, SectionPointer);
        return NULL;
        }

    *Status = RPC_S_OK;

    // explicit placement - can't fail with NULL return value
    pCellSection = new (SectionPointer) CellSection(Status, hFileMapping, pCellHeap, RandomNumber);
    if (*Status != RPC_S_OK)
        {
        return NULL;
        }

    return pCellSection;
}

#if DBG
void CellSection::AssertValid(CellHeap *pCellHeap)
{
    int i;
    DWORD Ignored;
    BOOL fAccessTestSucceeded;
    int LocalCountOfUsedCells;
    int NumberOfCellsInSection;
    DebugFreeCell *pCurrentCell;

    pCellHeap->CellHeapMutex.VerifyOwned();
    ASSERT(Signature == 0xdada);
    ASSERT(LastCommittedPage >= 1);
    ASSERT(LastCommittedPage <= NumberOfPagesPerSection);

    // check that the pages claimed committed are indeed committed
    for (i = 0; i < LastCommittedPage; i ++)
        {
        fAccessTestSucceeded = TRUE;

        __try
            {
            Ignored = *(DWORD *)(((unsigned char *)this) + gPageSize * i);
            }
        __except (EXCEPTION_EXECUTE_HANDLER)
            {
            fAccessTestSucceeded = FALSE;
            }

        ASSERT(fAccessTestSucceeded == TRUE);
        }

    if (SectionID == -1)
        {
        ASSERT(pCachedCellSection == this);
        }
    else
        {
        ASSERT(pCellHeap->CellHeapSections.Find(SectionID) == this);
        ASSERT(pCachedCellSection != this);
        }

#ifdef MAJOR_CELLHEAP_DEBUG
    NumberOfCellsInSection = pCellHeap->GetSectionCapacity(this);
    pCurrentCell = (DebugFreeCell *)(this + 1);
    LocalCountOfUsedCells = 0;
    // count that the number of used cells is indeed what the header says it is
    for (i = 0; i < NumberOfCellsInSection; i ++)
        {
        if (pCurrentCell->Type != dctFree)
            LocalCountOfUsedCells ++;
        ASSERT(pCurrentCell->Type >= dctFirstEntry);
        ASSERT(pCurrentCell->Type <= dctLastEntry);
        pCurrentCell ++;
        }

    ASSERT(LocalCountOfUsedCells == NumberOfUsedCells);
#endif

    // if this is the cached section, make sure all cells are free
    if (SectionID == -1)
        {
        ASSERT(NumberOfUsedCells == 0);
        }

    // the NextSectionId is checked by the CellHeap validate function
    ASSERT(hFileMapping != NULL);

    // the sections list chain and the free cell chain are 
    // verified by the CellHeap::AssertValid
}
#endif

CellSection::CellSection(IN OUT RPC_STATUS *Status, IN OUT HANDLE hNewFileMapping, 
                         IN CellHeap *pCellHeap, IN DWORD *pRandomNumbers)
{
#if defined(_WIN64)
    ASSERT(sizeof(CellSection) == 64);
#else
    ASSERT(sizeof(CellSection) == 32);
#endif

    // initialize variables to well known values
    Signature = 0xdada;
    LastCommittedPage = 1;
    SectionID = -1;
    NumberOfUsedCells = 0;
    NextSectionId[0] = 0;
    NextSectionId[1] = 0;
    hFileMapping = hNewFileMapping;
    pFirstFreeCell = (DebugFreeCell *)(this + 1);
    InitializeListHead(&SectionListEntry);
#if defined(_WIN64)
    Reserved[0] = 0;
    Reserved[1] = 0;
    Reserved[2] = 0;
    Reserved[3] = 0;
#endif

    if (*Status != RPC_S_OK)
        return;

    InitializeNewPage(this);

    *Status = pCellHeap->SectionCreatedNotify(this, pRandomNumbers, NULL, NULL);

    if (*Status != RPC_S_OK)
        {
        // unmap this - don't touch any data member afterwards!
        CloseDbgSection(hNewFileMapping, this);
        }
    else
        {
#if DBG
        pCellHeap->CellHeapMutex.Request();
        ASSERT_VALID1(this, pCellHeap);
        pCellHeap->CellHeapMutex.Clear();
#endif
        }

}

void CellSection::Free(void)
{
    HANDLE hLocalFileMapping = hFileMapping;

    ASSERT(hLocalFileMapping);

    // unmaps this - don't touch data members after this!
    CloseDbgSection(hLocalFileMapping, this);
}

RPC_STATUS CellSection::ExtendSection(IN CellHeap *pCellHeap)
{
    PVOID NewCommitPointer;

    ASSERT(LastCommittedPage < NumberOfPagesPerSection);
    pCellHeap->CellHeapMutex.VerifyOwned();

    NewCommitPointer = (unsigned char *)this + gPageSize * LastCommittedPage;
    if (VirtualAlloc(NewCommitPointer, 1, MEM_COMMIT, PAGE_READWRITE) == NULL)
        return RPC_S_OUT_OF_MEMORY;

    LastCommittedPage ++;

    InitializeNewPage(NewCommitPointer);

    // the pFirstFreeCell should be NULL - otherwise we shouldn't be
    // extending the section
    ASSERT(pFirstFreeCell == NULL);

    pCellHeap->InsertNewPageSegmentInChain((DebugFreeCell *)NewCommitPointer, 
        (DebugFreeCell *)((unsigned char *)NewCommitPointer + gPageSize - sizeof(DebugFreeCell)));
    pFirstFreeCell = (DebugFreeCell *)NewCommitPointer;

    return RPC_S_OK;
}

void CellSection::InitializeNewPage(PVOID NewPage)
{
    DebugFreeCell *pCurrentFreeCell, *pPrevFreeCell;
    PVOID EndAddress;

    // initialize the cells within the heap and chain them for quick insertion
    // if this is the first page in the section, skip the section header
    if (NewPage == this)
        pCurrentFreeCell = (DebugFreeCell *)(this + 1);
    else
        pCurrentFreeCell = (DebugFreeCell *)NewPage;

    pCurrentFreeCell->FreeCellsChain.Blink = NULL;
    EndAddress = (unsigned char *)NewPage + gPageSize;
    pPrevFreeCell = NULL;
    while (pCurrentFreeCell < (DebugFreeCell *)EndAddress)
        {
        pCurrentFreeCell->TypeHeader = 0;
        pCurrentFreeCell->Type = dctFree;
        pCurrentFreeCell->pOwnerSection = this;
        if (pPrevFreeCell)
            {
            pCurrentFreeCell->FreeCellsChain.Blink = &(pPrevFreeCell->FreeCellsChain);
            pPrevFreeCell->FreeCellsChain.Flink = &(pCurrentFreeCell->FreeCellsChain);
            }
        pPrevFreeCell = pCurrentFreeCell;
        pCurrentFreeCell ++;
        }
    pPrevFreeCell->FreeCellsChain.Flink = NULL;
}

CellHeap::CellHeap(IN OUT RPC_STATUS *Status)
{
    // initialize data members to well known values
    InitializeListHead(&FreeCellsList);
    InitializeListHead(&SectionsList);
    SecurityDescriptor = NULL;
#if DBG
    NumberOfCellsPerFirstPageInSection = (gPageSize - sizeof(CellSection)) / sizeof(DebugFreeCell);
    NumberOfCellsPerPageInSection = (gPageSize / sizeof(DebugFreeCell));
#endif

    if (*Status != RPC_S_OK)
        return;

    EffectiveCellHeapMutex = new MUTEX(Status, TRUE, 8000);
    if (EffectiveCellHeapMutex == NULL)
        {
        *Status = RPC_S_OUT_OF_MEMORY;
        return;
        }

    if (*Status != RPC_S_OK)
        {
        delete EffectiveCellHeapMutex;
        return;
        }

    *Status = CreateSecurityDescriptor();
    if (*Status != RPC_S_OK)
        return;
}

CellHeap::~CellHeap(void)
{
    PACL pdacl;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    BOOL bRes;
    CellSection *pCurrentSection, *pNextSection;

    if (SecurityDescriptor != NULL)
        {
        bRes = GetSecurityDescriptorDacl(SecurityDescriptor, &DaclPresent, 
            &pdacl, &DaclDefaulted);
        ASSERT(bRes);
        ASSERT(DaclPresent);
        ASSERT(DaclDefaulted == FALSE);
        ASSERT(pdacl);
        delete pdacl;
        delete SecurityDescriptor;
        }

    // nuke all sections in the list
    pCurrentSection = (CellSection *) SectionsList.Flink;
    while (pCurrentSection != (CellSection *)&SectionsList)
        {
        CellHeapSections.Delete(pCurrentSection->SectionID);
        pNextSection = (CellSection *) pCurrentSection->SectionListEntry.Flink;
        pCurrentSection->Free();
        pCurrentSection = pNextSection;
        }
}

DebugFreeCell *CellHeap::AllocateCell(OUT CellTag *pCellTag)
{
    DebugFreeCell *pCurrentCell, *pNextCell, *pLastCell;
    LIST_ENTRY *pCurrentEntry;
    CellSection *pCurrentSection;
    RPC_STATUS Status;
    int RetryCount;

    // get the mutex
    CellHeapMutex.Request();

    ASSERT_VALID(this);

    // is there something on the list?
    if (IsListEmpty(&FreeCellsList))
        {
        // no, need to extend the cell heap

        // first, try to extend some section, if there is space for it
        // the list must not be empty
        ASSERT(!IsListEmpty(&SectionsList));

        // this operation is fast, so we can do it inside the mutex and
        // gain simpler code
        pCurrentEntry = SectionsList.Flink;
        while (pCurrentEntry != &SectionsList)
            {
            pCurrentSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
            if (pCurrentSection->LastCommittedPage < NumberOfPagesPerSection)
                {
                // try to extend the section
                Status = pCurrentSection->ExtendSection(this);
                if (Status == RPC_S_OK)
                    goto PopFreeDebugCell;

                ASSERT_VALID(this);
                // we're truly out of memory
                CellHeapMutex.Clear();
                return NULL;
                }
            pCurrentEntry = pCurrentEntry->Flink;
            }

        // if we are here, all sections are full - try the cached section
        if (pCachedCellSection)
            {
            pLastCell = CONTAINING_RECORD(pCachedCellSection->pFirstFreeCell->FreeCellsChain.Blink,
                DebugFreeCell, FreeCellsChain);
            pCachedCellSection->pFirstFreeCell->FreeCellsChain.Blink = NULL;
            Status = SectionCreatedNotify(pCachedCellSection, pCachedCellSection->NextSectionId,
                pCachedCellSection->pFirstFreeCell, pLastCell);
            if (Status != RPC_S_OK)
                {
                ASSERT_VALID(this);
                CellHeapMutex.Clear();
                return NULL;
                }

            // terminate the name chain for the just inserted cached section
            pCachedCellSection->NextSectionId[0] = 0;
            pCachedCellSection->NextSectionId[1] = 0;
            pCachedCellSection = NULL;
            goto PopFreeDebugCell;
            }

        ASSERT_VALID(this);
        // This is going to be slow -
        // release the mutex and we will claim it later, when we're done
        CellHeapMutex.Clear();

        RetryCount = 0;
        while (TRUE)
            {
            // try to allocate a new section
            Status = AllocateCellSection(FALSE);
            if (Status == RPC_S_OK)
                {
                CellHeapMutex.Request();
                ASSERT_VALID(this);
                if (!IsListEmpty(&FreeCellsList))
                    goto PopFreeDebugCell;
                // it is possible, though very unlikely that all allocated
                // cells have been used by the other threads. Retry a limited
                // number of times
                CellHeapMutex.Clear();
                RetryCount ++;
                ASSERT(RetryCount < 3);
                }
            else
                return NULL;
            }
        }
    else
        {
PopFreeDebugCell:
        CellHeapMutex.VerifyOwned();
        // pop off the list
        pCurrentEntry = RemoveHeadList(&FreeCellsList);
        pCurrentCell = (DebugFreeCell *) CONTAINING_RECORD(pCurrentEntry, DebugFreeCell, FreeCellsChain);
        // if there are more entries in the list ...
        if (!IsListEmpty(&FreeCellsList))
            {
            pNextCell = (DebugFreeCell *) CONTAINING_RECORD(FreeCellsList.Flink, DebugFreeCell, FreeCellsChain);
            // ... and the next cell is from this section ...
            if (pCurrentCell->pOwnerSection == pNextCell->pOwnerSection)
                {
                // ... mark the next free cell as the first free cell for that section
                pCurrentCell->pOwnerSection->pFirstFreeCell = pNextCell;
                }
            else
                {
                // ... the current section has no more free cells
                pCurrentCell->pOwnerSection->pFirstFreeCell = NULL;
                ASSERT(pCurrentCell->pOwnerSection->NumberOfUsedCells + 1
                    == GetSectionCapacity(pCurrentCell->pOwnerSection));
                }
            }
        else
            {
            // ... the current section has no more free cells
            pCurrentCell->pOwnerSection->pFirstFreeCell = NULL;
            ASSERT(pCurrentCell->pOwnerSection->NumberOfUsedCells + 1 
                == GetSectionCapacity(pCurrentCell->pOwnerSection));
            }
        pCurrentCell->pOwnerSection->NumberOfUsedCells ++;
        }

    pCurrentCell->Type = dctUsedGeneric;

    ASSERT_VALID(this);

    CellHeapMutex.Clear();

    *pCellTag = pCurrentCell->pOwnerSection->SectionID;
    return pCurrentCell;
}

void CellHeap::FreeCell(IN void *cell, IN OUT CellTag *pCellTag)
{
    CellSection *pSection;
    DebugFreeCell *pFreeCell;
    LIST_ENTRY *pCurrentEntry;
    CellSection *pCurrentSection;
    CellSection *pCachedSection;
    CellSection *pPrevSection, *pNextSection;
    BOOL fFreeCurrentSection;
    DebugFreeCell *pFirstCell, *pLastCell;
    DWORD SectionNumbers[2];

    // guard against double frees
    ASSERT(*pCellTag != -1);

    CellHeapMutex.Request();

    ASSERT_VALID(this);

    pSection = CellHeapSections.Find(*pCellTag);
    // make sure the cell is indeed from that section
    ASSERT((unsigned char *)cell >= (unsigned char *)pSection);
    ASSERT((unsigned char *)cell < ((unsigned char *)pSection) + gPageSize * pSection->LastCommittedPage);
    ASSERT(pSection->NumberOfUsedCells > 0);
    pFreeCell = (DebugFreeCell *) cell;

    // push on the list for the section the cell is from
    if (pSection->pFirstFreeCell)
        {
        InsertHeadList(pSection->pFirstFreeCell->FreeCellsChain.Blink, &pFreeCell->FreeCellsChain);
        // the pSection->pFirstFreeCell will be updated below
        }
    else
        {
        // find the place in the free list this goes to
        // the way we do this is walk the rest of the sections list 
        // and try to insert it before the first section we find
        // if we don't find anything, we insert it in the list tail
        pCurrentEntry = pSection->SectionListEntry.Flink;
        while (pCurrentEntry != &SectionsList)
            {
            pCurrentSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
            if (pCurrentSection->pFirstFreeCell)
                {
                // we have found our place - use it
                InsertHeadList(pCurrentSection->pFirstFreeCell->FreeCellsChain.Blink, &pFreeCell->FreeCellsChain);
                // the pSection->pFirstFreeCell will be updated below
                break;
                }
            pCurrentEntry = pCurrentEntry->Flink;
            }

        // did we pass through everything?
        if (pCurrentEntry == &SectionsList)
            {
            // if yes, just insert in the tail
            InsertTailList(&FreeCellsList, &pFreeCell->FreeCellsChain);
            // the pSection->pFirstFreeCell will be updated below
            }
        }
    pSection->pFirstFreeCell = pFreeCell;
    pSection->NumberOfUsedCells --;
    pFreeCell->Type = dctFree;
    pFreeCell->pOwnerSection = pSection;

    if ((pSection->NumberOfUsedCells == 0) && (pSection != pFirstSection))
        {
        // unlink this section's segment from the cell free list
        pFirstCell = pFreeCell;

        // find the next section that has something on
        // the free list
        pCurrentEntry = pSection->SectionListEntry.Flink;
        while (pCurrentEntry != &SectionsList)
            {
            pCurrentSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
            if (pCurrentSection->pFirstFreeCell)
                {
                pLastCell = CONTAINING_RECORD(pCurrentSection->pFirstFreeCell->FreeCellsChain.Blink, DebugFreeCell, FreeCellsChain);
                ASSERT(pLastCell->pOwnerSection == pSection);
                break;
                }
            pCurrentEntry = pCurrentEntry->Flink;
            }

        // if we didn't find anything, we're the last segment on the free list
        if (pCurrentEntry == &SectionsList)
            {
            pLastCell = CONTAINING_RECORD(FreeCellsList.Blink, DebugFreeCell, FreeCellsChain);
            pFirstCell->FreeCellsChain.Blink->Flink = &FreeCellsList;
            FreeCellsList.Blink = pFirstCell->FreeCellsChain.Blink;
            }
        else
            {
            pFirstCell->FreeCellsChain.Blink->Flink = pLastCell->FreeCellsChain.Flink;
            pLastCell->FreeCellsChain.Flink->Blink = pFirstCell->FreeCellsChain.Blink;
            }

        // chain the cells within the segment
        pFirstCell->FreeCellsChain.Blink = &pLastCell->FreeCellsChain;
        pLastCell->FreeCellsChain.Flink = NULL;

        // remove the section from the dictionary
        CellHeapSections.Delete(pSection->SectionID);
        pSection->SectionID = -1;

        // restore the name chain
        ASSERT(pSection->SectionListEntry.Blink != &SectionsList);
        pPrevSection 
            = CONTAINING_RECORD(pSection->SectionListEntry.Blink, CellSection, SectionListEntry);
        SectionNumbers[0] = pPrevSection->NextSectionId[0];
        SectionNumbers[1] = pPrevSection->NextSectionId[1];
        pPrevSection->NextSectionId[0] = pSection->NextSectionId[0];
        pPrevSection->NextSectionId[1] = pSection->NextSectionId[1];
        pSection->NextSectionId[0] = SectionNumbers[0];
        pSection->NextSectionId[1] = SectionNumbers[1];

        // unlink the chain from the sections list
        RemoveEntryList(&pSection->SectionListEntry);

        fFreeCurrentSection = TRUE;
        }
    else
        {
        fFreeCurrentSection = FALSE;
        }

    if (pSection->NumberOfUsedCells <= 100)
        {
        // the low water mark has been reached - dispose of the cached section
        pCachedSection = pCachedCellSection;

        // if we are freeing the current section, put it as the cached section
        // instead
        if (fFreeCurrentSection)
            {
            pCachedCellSection = pSection;
            }

        if (pCachedSection != NULL)
            {
            if (!fFreeCurrentSection)
                {
                pCachedCellSection = NULL;
                }

            // the first section should not go away
            ASSERT(pCachedSection != pFirstSection);

            ASSERT_VALID(this);
            // do the unmapping outside the mutex since it's slow
            CellHeapMutex.Clear();
            pCachedSection->Free();
            goto FreeCellCleanup;
            }
        }

    ASSERT_VALID(this);

    CellHeapMutex.Clear();

FreeCellCleanup:
    *pCellTag = -1;
}

void CellHeap::RelocateCellIfPossible(IN OUT void **ppCell, IN OUT CellTag *pCellTag)
{
    DebugFreeCell *pNewCell;
    CellTag NewCellTag;

    // if we are not on the first section and there are free cells
    // on the first section ...
    if ((*pCellTag != 0) && pFirstSection->pFirstFreeCell)
        {
        CellHeapMutex.Request();
        if (pFirstSection->pFirstFreeCell == NULL)
            {
            // somebody beat us to it
            CellHeapMutex.Clear();
            return;
            }

        pNewCell = AllocateCell(&NewCellTag);
        // this should succeed - we are doing it in a mutex, and we checked
        // that there are free elements
        ASSERT(pNewCell);
        // we can release the mutex now
        CellHeapMutex.Clear();

        memcpy(pNewCell, *ppCell, sizeof(DebugFreeCell));
        FreeCell(*ppCell, pCellTag);
        *pCellTag = NewCellTag;
        *ppCell = pNewCell;
        }
}

RPC_STATUS CellHeap::SectionCreatedNotify(IN CellSection *pCellSection, IN DWORD *pRandomNumbers,
    IN DebugFreeCell *pFirstCell OPTIONAL, IN DebugFreeCell *pLastCell OPTIONAL)
{
    int Key;
    CellSection *pLastSection;
    PVOID pLastSectionListEntry;
    LIST_ENTRY *EX_Blink;

    CellHeapMutex.Request();
    Key = CellHeapSections.Insert(pCellSection);
    if (Key == -1)
        {
        CellHeapMutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    pCellSection->SectionID = (short) Key;
    pLastSectionListEntry = SectionsList.Blink;
    // if there is last section, chain the names
    if (pLastSectionListEntry != &SectionsList)
        {
        pLastSection = (CellSection *)(CONTAINING_RECORD(pLastSectionListEntry, CellSection, SectionListEntry));
        ASSERT(pLastSection->NextSectionId[0] == 0);
        ASSERT(pLastSection->NextSectionId[1] == 0);
        pLastSection->NextSectionId[0] = pRandomNumbers[0];
        pLastSection->NextSectionId[1] = pRandomNumbers[1];
        }
    InsertTailList(&SectionsList, &(pCellSection->SectionListEntry));

    if (pFirstCell == NULL)
        {
        ASSERT(pLastCell == NULL);
        pFirstCell = (DebugFreeCell *)(pCellSection + 1);
        pLastCell = (DebugFreeCell *)((unsigned char *)pCellSection + gPageSize - sizeof(DebugFreeCell));
        }

    // chain the cells in the section to the free list
    InsertNewPageSegmentInChain(pFirstCell, pLastCell);

    CellHeapMutex.Clear();
    return RPC_S_OK;
}

RPC_STATUS CellHeap::InitializeServerSideCellHeap(void)
{
    RPC_STATUS Status = RPC_S_OK;

    CellHeapMutex.Request();
    if (g_fServerSideCellHeapInitialized)
        {
        CellHeapMutex.Clear();
        return RPC_S_OK;
        }
    // there is no race free way to create a first section - do
    // it in the mutex
    Status = AllocateCellSection(
        TRUE    // First Section
        );

    if (Status == RPC_S_OK)
        {
        g_fServerSideCellHeapInitialized = TRUE;
        }
    CellHeapMutex.Clear();
    return Status;
}

#if DBG
void CellHeap::AssertValid(void)
{
    CellSection *pSection, *pPrevSection, *pNextSection;
    CellSection *pPrevSection2;
    DebugFreeCell *pCurrentCell = NULL;
    LIST_ENTRY *pCurrentEntry, *pPrevEntry;
    LIST_ENTRY *pPrevFreeEntry;
    RPC_STATUS Status;
    HANDLE hSection;
    PVOID pMappedSection;
    int SectionsInDictionary;
    int LocalSectionFreeCellsCount;

    CellHeapMutex.VerifyOwned();

    ASSERT(IsValidSecurityDescriptor(SecurityDescriptor));

    // there must be at least one section
    ASSERT(!IsListEmpty(&SectionsList));

    pCurrentEntry = SectionsList.Flink;
    pSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);
    ASSERT(pSection == pFirstSection);

    SectionsInDictionary = CellHeapSections.Size();

    pPrevSection = NULL;
    pPrevEntry = &SectionsList;
    pPrevFreeEntry = &FreeCellsList;
    while (pCurrentEntry != &SectionsList)
        {
        pSection = CONTAINING_RECORD(pCurrentEntry, CellSection, SectionListEntry);

        ASSERT(pCurrentEntry->Blink == pPrevEntry);
        if (pPrevSection)
            {
            // make sure opening the next section from the previous section
            // yields this section
            Status = OpenSection(&hSection, &pMappedSection, pPrevSection->NextSectionId);
            // it is possible for this operation to fail
            // handle just the success case
            if (Status == RPC_S_OK)
                {
                pNextSection = (CellSection *)pMappedSection;
                ASSERT(pNextSection->SectionID == pSection->SectionID);
                CloseDbgSection(hSection, pNextSection);
                }
            }
        pSection->AssertValid(this);

        SectionsInDictionary --;

        // walk the free list pointers and make sure the free list is correct
        // we do this only if this section has something in the list
        if (pSection->pFirstFreeCell)
            {
            // there is previous section to verify only if we're not at the beginning
            if (pPrevFreeEntry != &FreeCellsList)
                {
                pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
                pPrevSection2 = pCurrentCell->pOwnerSection;

                LocalSectionFreeCellsCount = 1;
                }
            else
                {
                pPrevSection2 = NULL;
                }

            // there must be at least one element difference
            // between the previous and this - that is, two
            // sections cannot point to the same cell as their 
            // first free cell
            pPrevFreeEntry = pPrevFreeEntry->Flink;
            while (pPrevFreeEntry != &pSection->pFirstFreeCell->FreeCellsChain)
                {
                // make sure we don't wrap around
                ASSERT (pPrevFreeEntry != &FreeCellsList);
                pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
                if (pPrevSection2)
                    {
                    // make sure all cells from the segment belong to the same section
                    ASSERT(pCurrentCell->pOwnerSection == pPrevSection2);
                    LocalSectionFreeCellsCount ++;
                    }
                ASSERT(pPrevFreeEntry->Flink->Blink == pPrevFreeEntry);
                pPrevFreeEntry = pPrevFreeEntry->Flink;
                }
            if (pPrevSection2)
                {
                ASSERT(LocalSectionFreeCellsCount 
                    == GetSectionCapacity(pPrevSection2) - pPrevSection2->NumberOfUsedCells)
                }
            }

        pPrevSection = pSection;
        pPrevEntry = pCurrentEntry;
        pCurrentEntry = pCurrentEntry->Flink;
        }

    // we have iterated through all the sections
    // check the free list for the last section
    // but don't do it if none of the sections had free cells
    if (pPrevFreeEntry != &FreeCellsList)
        {
        pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
        pPrevSection2 = pCurrentCell->pOwnerSection;

        LocalSectionFreeCellsCount = 1;

        // there must be at least one element difference
        // between the previous and this - that is, two
        // sections cannot point to the same cell as their 
        // first free cell
        pPrevFreeEntry = pPrevFreeEntry->Flink;
        while (pPrevFreeEntry != &FreeCellsList)
            {
            pCurrentCell = CONTAINING_RECORD(pPrevFreeEntry, DebugFreeCell, FreeCellsChain);
            // make sure all cells from the segment belong to the same section
            ASSERT(pCurrentCell->pOwnerSection == pPrevSection2);
            LocalSectionFreeCellsCount ++;
            ASSERT(pPrevFreeEntry->Flink->Blink == pPrevFreeEntry);
            pPrevFreeEntry = pPrevFreeEntry->Flink;
            }
        ASSERT(LocalSectionFreeCellsCount 
            == GetSectionCapacity(pPrevSection2) - pPrevSection2->NumberOfUsedCells)
        }

    // do some final checks
    // we have wrapped around to the beginning of the list
    ASSERT(pPrevFreeEntry == &FreeCellsList);

    // all of the sections in the list must have been in the dictionary also
    ASSERT(SectionsInDictionary == 0);

    // the names list must be properly terminated
    ASSERT(pSection->NextSectionId[0] == 0);
    ASSERT(pSection->NextSectionId[1] == 0);

    // verify the cached section (if any)
    if (pCachedCellSection)
        {
        pCachedCellSection->AssertValid(this);
        Status = OpenSection(&hSection, &pMappedSection, pCachedCellSection->NextSectionId);
        if (Status == RPC_S_OK)
            {
            pNextSection = (CellSection *)pMappedSection;
            ASSERT(pCachedCellSection->NextSectionId[0] == pNextSection->NextSectionId[0]);
            ASSERT(pCachedCellSection->NextSectionId[1] == pNextSection->NextSectionId[1]);
            CloseDbgSection(hSection, pMappedSection);
            }
        // walk the free list for the cached section and make sure
        // it is linked properly
        ASSERT(pCachedCellSection->pFirstFreeCell);
        pCurrentEntry = &pCachedCellSection->pFirstFreeCell->FreeCellsChain;
        while(pCurrentEntry->Flink != NULL)
            {
            pCurrentEntry = pCurrentEntry->Flink;
            }
        // pCurrentEntry should be the last cell here
        ASSERT(pCachedCellSection->pFirstFreeCell->FreeCellsChain.Blink == pCurrentEntry);
        }
}
#endif

// trick the compiler into statically initializing SID with two SubAuthorities
typedef struct _RPC_SID2 {
   UCHAR Revision;
   UCHAR SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   ULONG SubAuthority[2];
} RPC_SID2;

RPC_STATUS CellHeap::CreateSecurityDescriptor(void)
{
    const SID LocalSystem = { 1, 1, SECURITY_NT_AUTHORITY, SECURITY_LOCAL_SYSTEM_RID};
    const RPC_SID2 Admin1 = { 1, 2, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS};
//    const RPC_SID2 Admin2 = { 1, 2, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_GROUP_RID_ADMINS};
//    const RPC_SID2 Admin3 = { 1, 2, SECURITY_NT_AUTHORITY, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_USER_RID_ADMIN};
    DWORD size = 4 * sizeof(ACCESS_ALLOWED_ACE) + sizeof(LocalSystem) + sizeof(Admin1) ;
        // + sizeof(Admin2) + sizeof(Admin3);
    BOOL bRes;
    
    SecurityDescriptor = new SECURITY_DESCRIPTOR;
    if (SecurityDescriptor == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    PACL pdacl = (PACL) new unsigned char[size + sizeof(ACL)];
    ULONG ldacl = size + sizeof(ACL);

    if (pdacl == NULL)
        {
        delete SecurityDescriptor;
        SecurityDescriptor = NULL;
        return RPC_S_OUT_OF_MEMORY;
        }

    ASSERT(RtlValidSid((PSID)&LocalSystem));
    ASSERT(RtlValidSid((PSID)&Admin1));
//    ASSERT(RtlValidSid((PSID)&Admin2));
//    ASSERT(RtlValidSid((PSID)&Admin3));

    InitializeSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);

    InitializeAcl(pdacl, ldacl, ACL_REVISION);

    // this should not fail unless we messed up with the parameters
    // somewhere
    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&LocalSystem);
    ASSERT(bRes);

    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&Admin1);
    ASSERT(bRes);

    /*
    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&Admin2);
    ASSERT(bRes);

    bRes = AddAccessAllowedAce(pdacl, ACL_REVISION,
                             FILE_MAP_READ,
                             (PVOID)&Admin3);
    ASSERT(bRes);
    */

    bRes = SetSecurityDescriptorDacl(SecurityDescriptor, TRUE, pdacl, FALSE);
    ASSERT(bRes);

    ASSERT(IsValidSecurityDescriptor(SecurityDescriptor));

    return RPC_S_OK;
}

void CellHeap::InsertNewPageSegmentInChain(DebugFreeCell *pFirstCell, DebugFreeCell *pLastCell)
{
    LIST_ENTRY *EX_Blink;

    CellHeapMutex.VerifyOwned();

    // chain the cells in the section to the free list
    ASSERT(pFirstCell->FreeCellsChain.Blink == NULL);
    ASSERT(pLastCell->FreeCellsChain.Flink == NULL);

    // create the links from the list to the new segment
    EX_Blink = FreeCellsList.Blink;
    FreeCellsList.Blink = &(pLastCell->FreeCellsChain);
    EX_Blink->Flink = &(pFirstCell->FreeCellsChain);

    // create the links from the new segment to the list
    pFirstCell->FreeCellsChain.Blink = EX_Blink;
    pLastCell->FreeCellsChain.Flink = &FreeCellsList;
}

RPC_STATUS CellHeap::AllocateCellSection(BOOL fFirstSection)
{
    RPC_STATUS Status;

    CellSection::AllocateCellSection(&Status, fFirstSection, SecurityDescriptor, this);

    if (fFirstSection && (Status == RPC_S_OK))
        {
        pFirstSection = CONTAINING_RECORD(SectionsList.Flink, CellSection, SectionListEntry);
        }

    return Status;
}

#if DBG
RPC_STATUS CellHeap::OpenSection(OUT HANDLE *pHandle, OUT PVOID *pSection, IN DWORD *pSectionNumbers)
{
    return OpenDbgSection(pHandle, pSection, GetCurrentProcessId(), pSectionNumbers);
}
#endif

RPC_STATUS InitializeCellHeap(void)
{
    RPC_STATUS Status = RPC_S_OK;
    g_pCellHeap = new CellHeap(&Status);
    if (g_pCellHeap == NULL)
        Status = RPC_S_OUT_OF_MEMORY;
    else if (Status != RPC_S_OK)
        {
        delete g_pCellHeap;
        g_pCellHeap = NULL;
        }

    return Status;
}

C_ASSERT(sizeof(DebugCallInfo) <= 32);
C_ASSERT(sizeof(DebugConnectionInfo) <= 32);
C_ASSERT(sizeof(DebugThreadInfo) <= 32);
C_ASSERT(sizeof(DebugEndpointInfo) <= 32);
C_ASSERT(sizeof(DebugClientCallInfo) <= 32);
C_ASSERT(sizeof(DebugCallTargetInfo) <= 32);
C_ASSERT(sizeof(DebugFreeCell) <= 32);
C_ASSERT(sizeof(DebugCellUnion) <= 32);

// uncomment this for cell heap unit tests
// #define CELL_HEAP_UNIT_TESTS

// cell heap unit tests
#ifdef CELL_HEAP_UNIT_TESTS
typedef struct tagCellTestSectionState
{
    int CommitedPages;
    int UsedCellsInSection;
} CellTestSectionState;

typedef struct tagCellTestBase
{
    int NumberOfSections;
    BOOL fCachedSectionPresent;
    int LastCommand;
    DWORD LastCommandParams[2];
    CellTestSectionState sectionsState[1];
} CellTestBase;

class TestCellAllocation
{
public:
    int NumberOfCells;
    DebugFreeCell **ppCellArray;
    CellTag *pTagsArray;
    void Free(void);
};

void TestCellAllocation::Free(void)
{
    int i;
    for (i = 0; i < NumberOfCells; i ++)
        {
        FreeCell(&(*ppCellArray[i]), &(pTagsArray[i]));
        }

    delete ppCellArray;
    delete pTagsArray;
}

typedef DebugFreeCell *DebugFreeCellPtr;

NEW_SDICT(TestCellAllocation);

class TestState
{
public:
    TestCellAllocation_DICT Allocations;
    void Free(int Allocation)
    {
        TestCellAllocation *pAllocation;

        pAllocation = Allocations.Find(Allocation);
        ASSERT(pAllocation != NULL);

        pAllocation->Free();
        Allocations.Delete(Allocation);
        delete pAllocation;
    }

    void Allocate(int NumberOfCells)
    {
        int i;
        TestCellAllocation *pTestAllocation;

        pTestAllocation = new TestCellAllocation;
        ASSERT(pTestAllocation);

        pTestAllocation->NumberOfCells = NumberOfCells;
        pTestAllocation->ppCellArray = new DebugFreeCellPtr[NumberOfCells];
        ASSERT(pTestAllocation->ppCellArray);
        pTestAllocation->pTagsArray = new CellTag[NumberOfCells];
        ASSERT(pTestAllocation->pTagsArray);

        for (i = 0; i < NumberOfCells; i ++)
            {
            pTestAllocation->ppCellArray[i] = AllocateCell(&pTestAllocation->pTagsArray[i]);
            ASSERT(pTestAllocation->ppCellArray[i] != NULL);
            }
        i = Allocations.Insert(pTestAllocation);
        ASSERT(i != -1);
    }
};

typedef enum tagCellHeapTestActions
{
    chtaFree,
    chtaAllocate,
    chtaFreeAll
} CellHeapTestActions;
#endif

void RPC_ENTRY I_RpcDoCellUnitTest(IN OUT void *p)
{
#ifdef CELL_HEAP_UNIT_TESTS
    const int NumberOfIterations = 383 * 3;
    const int NumberOfCellsPerSection = 383;
    DebugFreeCell *Cells[NumberOfIterations];
    CellTag Tags[NumberOfIterations];
    int i, j;
    CellTestBase *pTestBase = *(CellTestBase **)p;
    static TestState *pTestState = NULL;
    DWORD RandomNumbers[2];
    int NumberOfItemsToAllocate;
    int ItemToFree;
    RPC_STATUS RpcStatus;
    CellHeapTestActions ActionChosen;
    TestCellAllocation *pCurrentAllocation;
    int DictCursor;
    BOOL fFound;
    CellSection *pCellSection;
    DWORD LastCommandParams[2];
    ULONG Command;
//    ServerEnumerationHandle *hServers = (HANDLE *)p;

//    StartServerEnumeration(hServers);
    CellEnumerationHandle h;


    Command = (ULONG)pTestBase;
    if ((Command < 0xFFFF) && (Command != 0))
        {
        RpcStatus = OpenRPCServerDebugInfo(Command, &h);
        if (RpcStatus == RPC_S_OK)
            {
            CloseRPCServerDebugInfo(&h);
            }
        else
            {
            ASSERT(0);
            }
        return;
        }

    // Cell heap unit tests
    // if there are old test results, delete them
    if (pTestBase)
        delete pTestBase;

    if (pTestState == NULL)
        {
        pTestState = new TestState;
        }

    RpcStatus = GenerateRandomNumber((unsigned char *)RandomNumbers, 8);
    ASSERT(RpcStatus == RPC_S_OK);

    // is there something to free?
    if (pTestState->Allocations.Size() == 0)
        {
        ActionChosen = chtaAllocate;
        NumberOfItemsToAllocate = RandomNumbers[1] % 5 + 1;
        }
    else
        {
        // we can do it both ways - check the random number to figure out which
        if ((RandomNumbers[0] % 2777) == 0)
            {
            // once in a great while, free everything
            ActionChosen = chtaFreeAll;
            }
        else if ((RandomNumbers[0] % 100) > 48)
            {
            // allocations have a slight edge
            ActionChosen = chtaAllocate;
            NumberOfItemsToAllocate = RandomNumbers[1] % 5 + 1;
            }
        else
            {
            ActionChosen = chtaFree;
            ItemToFree = RandomNumbers[1] % pTestState->Allocations.Size();
            }
        }

    switch (ActionChosen)
        {
        case chtaFreeAll:
            pTestState->Allocations.Reset(DictCursor);
            while ((pCurrentAllocation = pTestState->Allocations.Next(DictCursor)) != NULL)
                {
                pTestState->Free(DictCursor - 1);
                }
            break;

        case chtaAllocate:
            pTestState->Allocate(NumberOfItemsToAllocate);
            LastCommandParams[0] = NumberOfItemsToAllocate;
            break;

        case chtaFree:
            i = 0;
            fFound = FALSE;
            pTestState->Allocations.Reset(DictCursor);
            while ((pCurrentAllocation = pTestState->Allocations.Next(DictCursor)) != NULL)
                {
                if (ItemToFree == i)
                    {
                    LastCommandParams[0] = pCurrentAllocation->NumberOfCells;
                    LastCommandParams[1] = DictCursor - 1;
                    pTestState->Free(DictCursor - 1);
                    fFound = TRUE;
                    break;
                    }
                i ++;
                }
            ASSERT(fFound == TRUE);
            break;
        }

    // build the state
    pTestBase = (CellTestBase *) new unsigned char [sizeof(CellTestBase) 
        + sizeof(CellTestSectionState) * (g_pCellHeap->CellHeapSections.Size() - 1)];
    ASSERT(pTestBase);
    pTestBase->LastCommand = ActionChosen;
    pTestBase->LastCommandParams[0] = LastCommandParams[0];
    pTestBase->LastCommandParams[1] = LastCommandParams[1];

    pTestBase->NumberOfSections = g_pCellHeap->CellHeapSections.Size();
    pTestBase->fCachedSectionPresent = (pCachedCellSection != NULL);
    i = 0;
    g_pCellHeap->CellHeapSections.Reset(DictCursor);
    while ((pCellSection = g_pCellHeap->CellHeapSections.Next(DictCursor)) != NULL)
        {
        pTestBase->sectionsState[i].CommitedPages = pCellSection->LastCommittedPage;
        pTestBase->sectionsState[i].UsedCellsInSection = pCellSection->NumberOfUsedCells;
        i ++;
        }
    *(CellTestBase **)p = pTestBase;

    /*
    for (j = 0; j < 2; j ++)
        {
        // do the allocations
        for (i = 0; i < NumberOfCellsPerSection; i ++)
            {
            Cells[i] = AllocateCell(&Tags[i]);
            }
        for (i = NumberOfCellsPerSection; i < NumberOfCellsPerSection * 2; i ++)
            {
            Cells[i] = AllocateCell(&Tags[i]);
            }
        for (i = NumberOfCellsPerSection * 2; i < NumberOfCellsPerSection * 3; i ++)
            {
            Cells[i] = AllocateCell(&Tags[i]);
            }

        // do the freeing
        for (i = NumberOfCellsPerSection; i < NumberOfCellsPerSection * 2; i ++)
            {
            FreeCell(Cells[i], &Tags[i]);
            }
        for (i = 0; i < NumberOfCellsPerSection; i ++)
            {
            FreeCell(Cells[i], &Tags[i]);
            }
        for (i = NumberOfCellsPerSection * 2; i < NumberOfCellsPerSection * 3; i ++)
            {
            FreeCell(Cells[i], &Tags[i]);
            }
        }
        */
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dcecmmn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcecmmn.cxx

Abstract:

    This module contains the code implementing the Binding Object DCE RPC
    runtime APIs which are common to both the client and server runtimes.
    Two different versions of each of the common APIs live in this file;
    one contains the code for both the client and server runtimes, the
    other contains the code for just the client runtime.  The files
    dcecsvr.cxx (client and server) and dcecclnt.cxx (client) include
    this file.  The client side only, dcecclnt.cxx, will define
    RPC_CLIENT_SIDE_ONLY.

Author:

    Michael Montague (mikemon) 04-Nov-1991

Revision History:

--*/

// This file is always included into file which include precomp.hxx

#include <precomp.hxx>
#include <rpcdce.h>
#ifndef RPC_CLIENT_SIDE_ONLY
#include <rpccfg.h>
#endif
#ifndef RPC_CLIENT_SIDE_ONLY
#include <hndlsvr.hxx>
#endif // RPC_CLIENT_SIDE_ONLY


RPC_STATUS RPC_ENTRY
RpcBindingInqObject (
    IN RPC_BINDING_HANDLE Binding,
    OUT UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    RpcBindingInqObject returns the object UUID from the binding handle.

Arguments:

    Binding - Supplies a binding handle from which the object UUID will
        be returned.

    ObjectUuid - Returns the object UUID contained in the binding handle.

Return Value:

    The status of the operation is returned.

--*/
{
    BINDING_HANDLE *BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;

#ifdef RPC_CLIENT_SIDE_ONLY

    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    BindingHandle->InquireObjectUuid((RPC_UUID PAPI *) ObjectUuid);

#else // ! RPC_CLIENT_SIDE_ONLY

    if ( BindingHandle == 0 )
        {
        BindingHandle = (BINDING_HANDLE *) RpcpGetThreadContext();
        if ( BindingHandle == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE | SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (BindingHandle->Type(BINDING_HANDLE_TYPE))
        BindingHandle->InquireObjectUuid((RPC_UUID PAPI *) ObjectUuid);
    else
        ((SCALL *) BindingHandle)->InquireObjectUuid(
                (RPC_UUID PAPI *) ObjectUuid);

#endif // RPC_CLIENT_SIDE_ONLY

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcBindingToStringBinding (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    RpcBindingToStringBinding returns a string representation of a binding
    handle.

Arguments:

    Binding - Supplies a binding handle for which the string representation
        will be returned.

    StringBinding - Returns the string representation of the binding handle.

Return Value:

    The status of the operation will be returned.
--*/
{
#ifdef RPC_CLIENT_SIDE_ONLY

    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->ToStringBinding(StringBinding));

#else // RPC_CLIENT_SIDE_ONLY

    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (((GENERIC_OBJECT *) Binding)->InvalidHandle(BINDING_HANDLE_TYPE
            | SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (((GENERIC_OBJECT *) Binding)->Type(BINDING_HANDLE_TYPE))
        return(((BINDING_HANDLE *) Binding)->ToStringBinding(
                        StringBinding));
    else
        return(((SCALL *) Binding)->ToStringBinding(StringBinding));

#endif // RPC_CLIENT_SIDE_ONLY
}


RPC_STATUS RPC_ENTRY
I_RpcBindingToStaticStringBindingW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * StringBinding
    )
/*++

Routine Description:

    RpcBindingToStringBinding returns a string representation of a binding
    handle.

Arguments:

    Binding - Supplies a binding handle for which the string representation
        will be returned.

    StringBinding - Returns the string representation of the binding handle.

Return Value:

    The status of the operation will be returned.
--*/
{
    RPC_STATUS Status;

    InitializeIfNecessary();

    if (((GENERIC_OBJECT *) Binding)->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    if (((GENERIC_OBJECT *) Binding)->InvalidHandle(SVR_BINDING_HANDLE_TYPE))
        {
        return (((BINDING_HANDLE *) Binding)->ToStringBinding(StringBinding));
        }

    return (((SVR_BINDING_HANDLE *) Binding)->ToStaticStringBinding(StringBinding));
}


RPC_STATUS RPC_ENTRY
RpcMgmtInqDefaultProtectLevel(
    IN  unsigned long AuthnSvc,
    OUT unsigned long PAPI *AuthnLevel
    )
/*++

Routine Description:

    Returns the default protect level for the specified authentication service.
    For Nt 3.5, all packaged except the DECs krb package must support
    connect level as their default.

Arguments:

   AuthnSvc - Specified Authentication Service

   AuthnLevel - Default protection level supported.


Return Value:

    RPC_S_OK - We successfully determined whether or not the client is
        local.

--*/

{

   RPC_CHAR DllName[255+1];
#ifndef RPC_CLIENT_SIDE_ONLY
   RPC_CHAR *Dll = &DllName[0];
#endif
   unsigned long Count;
   RPC_STATUS Status;

   InitializeIfNecessary();

#ifndef RPC_CLIENT_SIDE_ONLY
   Status = RpcGetSecurityProviderInfo(
                     AuthnSvc,
                     &Dll,
                     &Count);

   if (Status != RPC_S_OK)
      {

      ASSERT(Status == RPC_S_UNKNOWN_AUTHN_SERVICE);
      return (Status);

      }
#endif

   //Authn Service is installed

   if (AuthnSvc == RPC_C_AUTHN_DCE_PRIVATE)
      {
      *AuthnLevel = RPC_C_PROTECT_LEVEL_PKT_INTEGRITY;
      }
   else
      {
      *AuthnLevel = RPC_C_PROTECT_LEVEL_CONNECT;
      }

   return (RPC_S_OK);

}



RPC_STATUS RPC_ENTRY
RpcBindingSetOption( IN RPC_BINDING_HANDLE hBinding,
                     IN unsigned long      option,
                     IN ULONG_PTR          optionValue )
/*++

Routine Description:

  An RPC client calls this routine to set transport specific
  options for a binding handle.

Arguments:

  hBinding    - The binding handle in question. This must be of
                type BINDING_HANDLE_TYPE.
  option      - Which transport specific option to set.
  optionValue - The new value for the transport option.

Return Value: RPC_S_OK
              RPC_S_INVALID_BINDING
              RPC_S_CANNOT_SUPPORT
--*/
{
    RPC_STATUS Status;

    InitializeIfNecessary();

    if ((option == RPC_C_OPT_DONT_LINGER) && (optionValue == FALSE))
        return RPC_S_INVALID_ARG;

    if ( ((GENERIC_OBJECT*)hBinding)->InvalidHandle(BINDING_HANDLE_TYPE) )
        {
        Status = RpcSsGetContextBinding(hBinding, &hBinding);
        if (Status != RPC_S_OK)
            return RPC_S_INVALID_BINDING;

        return RpcBindingSetOption(hBinding, option, optionValue);
        }
    else
        return ((BINDING_HANDLE*)hBinding)->SetTransportOption(
                                           option,
                                           optionValue );
}



RPC_STATUS RPC_ENTRY
RpcBindingInqOption( IN  RPC_BINDING_HANDLE hBinding,
                     IN  unsigned long      option,
                     OUT ULONG_PTR         *pOptionValue )
/*++

Routine Description:

  An RPC client calls this routine to get the value of a
  transport specific option for a binding handle.

Arguments:

  hBinding    - The binding handle in question. This must be of
                type BINDING_HANDLE_TYPE.
  option      - Which transport specific option to set.
  pOptionValue- The current value for the transport option is
                returned here.

Return Value: RPC_S_OK
              RPC_S_INVALID_BINDING
              RPC_S_CANNOT_SUPPORT
--*/
{
    InitializeIfNecessary();

    if ( ((GENERIC_OBJECT*)hBinding)->InvalidHandle(BINDING_HANDLE_TYPE) )
        return RPC_S_INVALID_BINDING;
    else
        {
        if (option > RPC_C_OPT_MAX_OPTIONS)
            {
            return RPC_S_INVALID_ARG;
            }

        return ((BINDING_HANDLE*)hBinding)->InqTransportOption(
                                           option,
                                           pOptionValue );
        }
}



RPC_STATUS RPC_ENTRY
I_RpcBindingInqConnId (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **ConnId,
    OUT BOOL *pfFirstCall
    )
/*++

Routine Description:

    Used to get the connection id corresponding to the binding handle.

Arguments:

    Binding - Supplies the binding handle from which we wish to obtain
        the connection id.

    ConnId - If the call suceeds, *ConnId will contain the connection Id
    pfFirstCall - If the call succeeds,
                    *pfFirstCall - 1 - This is the first time
                                    - 0 - This is not the first time

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - When the argument is not a binding handle.

--*/

{
    BINDING_HANDLE * BindingHandle;

    BindingHandle = (BINDING_HANDLE *) Binding;

    if (BindingHandle->InvalidHandle(SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return ((SCALL *) Binding)->InqConnection(ConnId, pfFirstCall);
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqTransportType(
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned int __RPC_FAR * Type
    )
/*++

Routine Description:

    Determines what kind of transport this binding handle uses.

Arguments:

    Binding - Supplies the binding handle from which we wish to obtain
        the information.


    Type - Points to the type of binding if the functions succeeds.
           One of:
           TRANSPORT_TYPE_CN
           TRANSPORT_TYPE_DG
           TRANSPORT_TYPE_LPC
           TRANSPORT_TYPE_WMSG

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - When the argument is not a binding handle.

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;

#ifndef RPC_CLIENT_SIDE_ONLY
    if ( BindingHandle == 0 )
        {
        BindingHandle = (BINDING_HANDLE *) RpcpGetThreadContext();
        if ( BindingHandle == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }
#endif

    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE|SCALL_TYPE))
        return(RPC_S_INVALID_BINDING);

#ifndef RPC_CLIENT_SIDE_ONLY
    if (BindingHandle->Type(SCALL_TYPE))
        {
        return(((SCALL *)BindingHandle)->InqTransportType(Type));
        }
    else
#endif
    return(BindingHandle->InquireTransportType(Type));
}


//
// Map of RPC (local system) error codes to well known NCA error codes
// so that the receiver can correctly convert these well known errors
// into system specific errors.
//
const long RpcToNcaMap[] =
    {
    RPC_S_UNKNOWN_IF,           NCA_STATUS_UNK_IF,
    RPC_S_NOT_LISTENING,        NCA_STATUS_SERVER_TOO_BUSY,
    RPC_S_SERVER_TOO_BUSY,      NCA_STATUS_SERVER_TOO_BUSY,
    RPC_S_PROTOCOL_ERROR,       NCA_STATUS_PROTO_ERROR,
    RPC_S_PROCNUM_OUT_OF_RANGE, NCA_STATUS_OP_RNG_ERROR,
    RPC_S_UNSUPPORTED_TYPE,     NCA_STATUS_UNSUPPORTED_TYPE,
    RPC_X_SS_CONTEXT_MISMATCH,  NCA_STATUS_CONTEXT_MISMATCH,
    RPC_X_INVALID_BOUND,        NCA_STATUS_INVALID_BOUND,
    RPC_X_SS_HANDLES_MISMATCH,  NCA_STATUS_CONTEXT_MISMATCH,
    RPC_S_INVALID_TAG,          NCA_STATUS_INVALID_TAG,
    RPC_S_OUT_OF_MEMORY,        NCA_STATUS_REMOTE_OUT_OF_MEMORY,
    RPC_S_CALL_FAILED_DNE,      NCA_STATUS_CALL_DNE,
    RPC_S_CALL_FAILED,          NCA_STATUS_FAULT_UNSPEC,
    RPC_S_CALL_CANCELLED,       NCA_STATUS_FAULT_CANCEL,
    RPC_S_COMM_FAILURE,         NCA_STATUS_COMM_FAILURE,
    RPC_X_PIPE_EMPTY,           NCA_STATUS_FAULT_PIPE_EMPTY,
    RPC_X_PIPE_CLOSED,          NCA_STATUS_FAULT_PIPE_CLOSED,
    RPC_X_WRONG_PIPE_ORDER,     NCA_STATUS_FAULT_PIPE_ORDER,
    RPC_X_PIPE_DISCIPLINE_ERROR,NCA_STATUS_FAULT_PIPE_DISCIPLINE,

    // Currently not used
    // NCA_STATUS_BAD_ACTID
    // NCA_STATUS_WHO_ARE_YOU_FAILED
    // NCA_STATUS_WRONG_BOOT_TIME
    // NCA_STATUS_YOU_CRASHED

    STATUS_INTEGER_DIVIDE_BY_ZERO,  NCA_STATUS_ZERO_DIVIDE,
    STATUS_FLOAT_DIVIDE_BY_ZERO,    NCA_STATUS_FP_DIV_ZERO,
    STATUS_FLOAT_UNDERFLOW,         NCA_STATUS_FP_UNDERFLOW,
    STATUS_FLOAT_OVERFLOW,          NCA_STATUS_FP_OVERFLOW,
    STATUS_FLOAT_INVALID_OPERATION, NCA_STATUS_FP_ERROR,
    STATUS_INTEGER_OVERFLOW,        NCA_STATUS_OVERFLOW,
        // Note: these exceptions are not caught by our code.
        // STATUS_ACCESS_VIOLATION,        NCA_STATUS_ADDRESS_ERROR,
        // STATUS_PRIVILEGED_INSTRUCTION,  NCA_STATUS_ILLEGAL_INSTRUCTION,
        // STATUS_ILLEGAL_INSTRUCTION,     NCA_STATUS_ILLEGAL_INSTRUCTION,

    };


//
// Map of NCA error codes to RPC (local system) error codes.  These
// errors usually arrive in fault packets and may have come from an
// NT, Mac or OSF machine.
//
const long NcaToRpcMap[] =
    {
    NCA_STATUS_COMM_FAILURE,            RPC_S_COMM_FAILURE,
    NCA_STATUS_OP_RNG_ERROR,            RPC_S_PROCNUM_OUT_OF_RANGE,
    NCA_STATUS_UNK_IF,                  RPC_S_UNKNOWN_IF,
    NCA_STATUS_PROTO_ERROR,             RPC_S_PROTOCOL_ERROR,
    NCA_STATUS_OUT_ARGS_TOO_BIG,        RPC_S_SERVER_OUT_OF_MEMORY,
    NCA_STATUS_REMOTE_OUT_OF_MEMORY,    RPC_S_SERVER_OUT_OF_MEMORY,
    NCA_STATUS_SERVER_TOO_BUSY,         RPC_S_SERVER_TOO_BUSY,
    NCA_STATUS_UNSUPPORTED_TYPE,        RPC_S_UNSUPPORTED_TYPE,
    NCA_STATUS_ILLEGAL_INSTRUCTION,     RPC_S_ADDRESS_ERROR,
    NCA_STATUS_ADDRESS_ERROR,           RPC_S_ADDRESS_ERROR,
    NCA_STATUS_OVERFLOW,                RPC_S_ADDRESS_ERROR,
    NCA_STATUS_ZERO_DIVIDE,             RPC_S_ZERO_DIVIDE,
    NCA_STATUS_FP_DIV_ZERO,             RPC_S_FP_DIV_ZERO,
    NCA_STATUS_FP_UNDERFLOW,            RPC_S_FP_UNDERFLOW,
    NCA_STATUS_FP_OVERFLOW,             RPC_S_FP_OVERFLOW,
    NCA_STATUS_FP_ERROR,                RPC_S_FP_OVERFLOW,
    NCA_STATUS_INVALID_TAG,             RPC_S_INVALID_TAG,
    NCA_STATUS_INVALID_BOUND,           RPC_S_INVALID_BOUND,
    NCA_STATUS_CONTEXT_MISMATCH,        RPC_X_SS_CONTEXT_MISMATCH,
    NCA_STATUS_FAULT_CANCEL,            RPC_S_CALL_CANCELLED,
    NCA_STATUS_WHO_ARE_YOU_FAILED,      RPC_S_CALL_FAILED,
    NCA_STATUS_YOU_CRASHED,             RPC_S_CALL_FAILED,
    NCA_STATUS_FAULT_UNSPEC,            RPC_S_CALL_FAILED,
    NCA_STATUS_VERSION_MISMATCH,        RPC_S_PROTOCOL_ERROR,
    NCA_STATUS_INVALID_PRES_CXT_ID,     RPC_S_PROTOCOL_ERROR,
    NCA_STATUS_FAULT_PIPE_EMPTY,        RPC_X_PIPE_EMPTY,
    NCA_STATUS_FAULT_PIPE_CLOSED,       RPC_X_PIPE_CLOSED,
    NCA_STATUS_FAULT_PIPE_ORDER,        RPC_X_WRONG_PIPE_ORDER,
    NCA_STATUS_FAULT_PIPE_MEMORY,       RPC_S_OUT_OF_MEMORY,
    NCA_STATUS_FAULT_PIPE_DISCIPLINE,   RPC_X_PIPE_DISCIPLINE_ERROR,
    NCA_STATUS_FAULT_PIPE_COMM_ERROR,   RPC_S_COMM_FAILURE,
    NCA_STATUS_INVALID_CHECKSUM,        RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_INVALID_CRC,             RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_UNSPEC_REJECT,           RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_BAD_ACTID,               RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_CALL_DNE,                RPC_S_CALL_FAILED_DNE,
    NCA_STATUS_UNSUPPORTED_AUTHN_LEVEL, RPC_S_UNSUPPORTED_AUTHN_LEVEL,

    // Catch all for OSF interop
    0, RPC_S_CALL_FAILED
    };

long
MapStatusCode(
    IN long StatusToMap,
    IN const long aErrorMap[],
    IN unsigned MapSize
    )
/*++

Routine Description:

    Maps a status value from one type of error to another.

Arguments:

    StatusToMap - The status code to map
    aErrorMap - An array of status codes of the format <original error><mapped error>
    MapSize - The number of <original error>'s in the array.

Return Value:

    If a mapping is found it will be returned, otherwise the original error is returned.

--*/
{
    for (unsigned i = 0; i < MapSize; i++)
        {
        if (aErrorMap[i * 2] == StatusToMap)
            return(aErrorMap[i * 2 + 1]);
        }
    return(StatusToMap);
}

unsigned long
MapToNcaStatusCode (
    IN RPC_STATUS RpcStatus
    )
/*++

Routine Description:

    This routine maps a local RPC status code to an NCA status code to
    be sent across the wire.

Arguments:

    RpcStatus - Supplies the RPC status code to be mapped into an NCA
        status code.

Return Value:

    The NCA status code will be returned.  If the RPC status code could
    not be mapped, it will be returned unchanged.

--*/
{
    return((unsigned long) MapStatusCode(
                                         RpcStatus,
                                         RpcToNcaMap,
                                         sizeof(RpcToNcaMap)/(2*sizeof(long))
                                        )
           );
}

RPC_STATUS
MapFromNcaStatusCode (
    IN unsigned long NcaStatus
    )
/*++

Routine Description:

    This routine is used to map an NCA status code (typically one received
    off of the wire) into a local RPC status code.  If the NCA status code
    can not be mapped, it will be returned unchanged.

Arguments:

    NcaStatus - Supplies the NCA status code to be mapped into an RPC status
        code.

Return Value:

    An RPC status code will be returned.

--*/
{
    return((RPC_STATUS) MapStatusCode(NcaStatus,
                                      NcaToRpcMap,
                                      sizeof(NcaToRpcMap)/(2*sizeof(long))
                                     )
           );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dcebind.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcebind.cxx

Abstract:

    This module contains the code implementing the Binding Object DCE RPC
    runtime APIs.  APIs which are used only by server applications do not
    live here.

Author:

    Michael Montague (mikemon) 25-Sep-1991

Revision History:

--*/

#include <precomp.hxx>
#include <rpccfg.h>
#include <CharConv.hxx>


RPC_STATUS RPC_ENTRY
RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE PAPI * DestinationBinding
    )
/*++

Routine Description:

    This routine copies binding information and creates a new binding
    handle.

Arguments:

    SourceBinding - Supplies the binding to be duplicated.

    DestinationBinding - Returns a new binding which is a duplicate of
        SourceBinding.

Return Value:

    The status for the operation is returned.

--*/
{
    MESSAGE_OBJECT * Binding;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread == NULL)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    Binding = (MESSAGE_OBJECT *) SourceBinding;
    if (Binding->InvalidHandle(BINDING_HANDLE_TYPE))
        {
        return NDRCCopyContextHandle(SourceBinding, DestinationBinding);
        }

    return(Binding->BindingCopy((BINDING_HANDLE *PAPI *) DestinationBinding, 0));
}


RPC_STATUS RPC_ENTRY
I_RpcBindingCopy (
    IN RPC_BINDING_HANDLE SourceBinding,
    OUT RPC_BINDING_HANDLE PAPI * DestinationBinding
    )
/*++

Routine Description:

    This routine copies binding information and creates a new binding
    handle.  In addition, context is being maintained by the server over
    this binding handle.

Arguments:

    SourceBinding - Supplies the binding to be duplicated.

    DestinationBinding - Returns a new binding which is a duplicate of
        SourceBinding.

Return Value:

    The status for the operation is returned.

--*/
{
    MESSAGE_OBJECT * Binding;

    InitializeIfNecessary();

    Binding = (MESSAGE_OBJECT *) SourceBinding;
    if (Binding->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(Binding->BindingCopy((BINDING_HANDLE * PAPI *) DestinationBinding, 1));
}


RPC_STATUS RPC_ENTRY
RpcBindingFree (
    IN OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description :

    RpcBindingFree releases binding handle resources.

Arguments:

    Binding - Supplies the binding handle to be freed, and returns zero.

Return Value:

    The status of the operation is returned.

--*/
{
    BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status;

    // if we're shutting down, don't bother
    // Since our other threads have been nuked, data structures may
    // be in half modified state. Therefore it is unsafe to proceed
    // with freeing the binding handle during shutdown
    if (RtlDllShutdownInProgress())
        {
        *Binding = 0;
        return RPC_S_OK;
        }

    InitializeIfNecessary();

    // here it will be more efficient if we succeed, but other code will manage fine
    // even if we don't, so we don't really care about return value
    ThreadSelf();

    ASSERT(!RpcpCheckHeap());

    BindingHandle = (BINDING_HANDLE *) *Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    Status = BindingHandle->BindingFree();
    *Binding = 0;

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcBindingReset (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine sets the endpoint in the supplied binding handle to
    zero.  This makes the binding handle a partiallly bound binding
    handle.  NOTE: this routine will fail if the binding handle has
    already been used to make remote procedure calls.  Based on how
    this routine will be used (to iterate through the entries in the
    endpoint mapper database), this should not be a problem.

Arguments:

    Binding - Supplies the binding handle for which the endpoint will
        be set to zero, hence making it a partially bound binding handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The supplied argument is not a valid binding.

    RPC_S_WRONG_KIND_OF_BINDING - Either the supplied binding is not a
        client binding handle or it is a client binding handle which has
        already been used to make remote procedure calls.

--*/
{
    BINDING_HANDLE * BindingHandle;
    THREAD *Thread;

    Thread = ThreadSelf();
    if (Thread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->BindingReset());
}


RPC_STATUS RPC_ENTRY
RpcBindingFromStringBinding (
    IN unsigned short PAPI * StringBinding,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description:

    This routine returns a binding handle from a string representation
    of a binding handle.

Arguments:

    StringBinding - Supplies the string representation of a binding handle.

    Binding - Returns a binding handle constructed from the string
        representation.

Return Value:

    The status of the operation is returned.

--*/
{
    DCE_BINDING * DceBinding;
    RPC_STATUS Status;
    BINDING_HANDLE * BindingHandle;
    RPC_CHAR __RPC_FAR * CopiedStringBinding;
    THREAD *Thread;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    *Binding = 0;

    CopiedStringBinding = (RPC_CHAR *)
              _alloca( (RpcpStringLength(StringBinding)+1)*(sizeof(RPC_CHAR)) );
    if (CopiedStringBinding == 0)
        {
        return (RPC_S_OUT_OF_MEMORY);
        }
    RpcpStringCopy(CopiedStringBinding, StringBinding);

    DceBinding = new DCE_BINDING(CopiedStringBinding, &Status);
    if (DceBinding == 0)
        Status = RPC_S_OUT_OF_MEMORY;

    if (Status == RPC_S_OK)
        {
        BindingHandle = DceBinding->CreateBindingHandle(&Status);
        if (Status == RPC_S_OK)
            *Binding = BindingHandle;
        //
        // DceBinding gets deleted by the callee, if the above call fails
        //
        }
    else
        {
        delete DceBinding;
        }

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcBindingSetObject (
    IN RPC_BINDING_HANDLE Binding,
    IN UUID PAPI * ObjectUuid
    )
/*++

Routine Description:

    This routine sets the object UUID value in a binding handle.

Arguments:

    Binding - Supplies the binding handle for which the object UUID is
        to be set.

    ObjectUuid - Supplies the UUID value to put into the binding handle.

Return Values:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    BindingHandle->SetObjectUuid((RPC_UUID PAPI *) ObjectUuid);

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcBindingVectorFree (
    IN OUT RPC_BINDING_VECTOR PAPI * PAPI * BindingVector
    )
/*++

Routine Description:

    This routine frees the binding handles contained in the vector, and
    the vector itself.

Arguments:

    BindingVector - Supplies a vector of binding handles which will be
        freed.  On return, the pointer to the binding vector will be
        set to zero.

Return Value:

    The status of the operation will be returned.

--*/
{
    unsigned int Index, Count;
    RPC_BINDING_VECTOR PAPI * Vector;
    RPC_STATUS Status;

    InitializeIfNecessary();

    for (Index = 0, Vector = *BindingVector,
            Count = (unsigned int) Vector->Count;
            Index < Count; Index++)
        if (Vector->BindingH[Index] != 0)
            {
            Status = RpcBindingFree(&(Vector->BindingH[Index]));
            if (Status != RPC_S_OK)
                return(Status);
            }
    RpcpFarFree(*BindingVector);
    *BindingVector = 0;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcEpResolveBinding (
    IN RPC_BINDING_HANDLE Binding,
    IN RPC_IF_HANDLE IfSpec
    )
/*++

Routine Description:

    This routine is used to resolve a partially-bound binding handle
    into a fully-bound binding handle.  A partially-bound binding
    handle is one in which the endpoint is not specified.  To make
    the binding handle fully-bound, we need to determine the endpoint.

Arguments:

    Binding - Supplies a partially-bound binding handle to resolve into
        a fully bound one.  Specifying a fully-bound binding handle to
        this routine is not an error; it has no effect on the binding
        handle.

    IfSpec - Supplies a handle to the description of the interface for
        which we wish to resolve the endpoint.  This information will
        be used to find the correct server on the machine specified by
        the network address in the binding handle.

Return Value:

    RPC_S_OK - The binding handle is now fully-bound.

    RPC_S_NO_ENDPOINT_FOUND - We were unable to resolve the endpoint
        for this particular combination of binding handle (network address)
        and interface.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to resolve
        the endpoint.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->ResolveBinding((PRPC_CLIENT_INTERFACE) IfSpec));
}

RPC_STATUS RPC_ENTRY
RpcNsBindingInqEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT unsigned short PAPI * PAPI * EntryName
    )
/*++

Routine Description:

Arguments:

Return Value:

    RPC_S_OK - The entry name for the binding handle has been successfully
        inquired and returned.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
#if !defined(NO_LOCATOR_CODE)
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->InquireEntryName(EntryNameSyntax, EntryName));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}

RPC_STATUS RPC_ENTRY
THUNK_FN(I_RpcNsBindingSetEntryName) (
    IN RPC_BINDING_HANDLE,
    IN unsigned long,
    IN unsigned char *
    )
{
    return RPC_S_CANNOT_SUPPORT;
}


RPC_STATUS RPC_ENTRY
I_RpcNsBindingSetEntryName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    IN unsigned short PAPI * EntryName
    )
/*++

Routine Description:

    This routine is a private entry point for use by name service support
    dlls; it allows them to set the entry name in a binding handle
    before returning it from import or lookup.  If an entry name already
    exists in the binding handle, we just go ahead and overwrite the
    old one with new one.

Arguments:

    Binding - Supplies the binding handle for which we want to set the
        entry name.

    EntryNameSyntax - Supplies the syntax used by the entry name.  We need
        to save this information for when the entry name is inquired.

    EntryName - Supplies the entry name for this binding handle.

Return Value:

    RPC_S_OK - The entry name has been successfully set for the binding
        handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding argument does specify a
        binding handle, but it is not a client binding handle (ie. one
        owned by the client side rpc runtime).

--*/
{
#if !defined(NO_LOCATOR_CODE)
    BINDING_HANDLE * BindingHandle;

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(BindingHandle->SetEntryName(EntryNameSyntax, EntryName));
#else
    return RPC_S_CANNOT_SUPPORT;
#endif
}

RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
/*++

Routine Description:

    This routine is used to return the authentication and authorization for
    a binding handle.  You should also see RpcBindingSetAuthInfoW.

Arguments:

    Binding - Supplies the binding handle for which we wish to query the
        authentication and authorization information.

    ServerPrincName - Optionally returns the server principal name set for
        the binding handle.

    AuthnLevel - Optionally returns the authentication level set for the
        binding handle.

    AuthnSvc - Optionally returns the authentication service set for the
        binding handle.

    AuthIdentity - Optionally returns a handle to the security context
        being used for authentication and authorization.

    AuthzSvc -  Optionally returns the authorization service set for the
        binding handle.

Return Value:

    RPC_S_OK - We successfully returned the information requested.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_BINDING_HAS_NO_AUTH - RpcBindingInqAuthInfo has not yet been
        called on the binding handle, so there is not authentication or
        authorization to be returned.

--*/
{
    BINDING_HANDLE * BindingObject;
    CLIENT_AUTH_INFO * ClientAuthInfo;

    InitializeIfNecessary();

    return( RpcBindingInqAuthInfoEx(
                  Binding,
                  ServerPrincName,
                  AuthnLevel,
                  AuthnSvc,
                  AuthIdentity,
                  AuthzSvc,
                  0,
                  0
                  ) );

}


RPC_STATUS RPC_ENTRY
RpcBindingInqAuthInfoEx (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long RpcSecurityQosVersion,
    OUT RPC_SECURITY_QOS * SecurityQos
    )
/*++

Routine Description:

    This routine is used to return the authentication and authorization for
    a binding handle.  You should also see RpcBindingSetAuthInfoW.

Arguments:

    Binding - Supplies the binding handle for which we wish to query the
        authentication and authorization information.

    ServerPrincName - Optionally returns the server principal name set for
        the binding handle.

    AuthnLevel - Optionally returns the authentication level set for the
        binding handle.

    AuthnSvc - Optionally returns the authentication service set for the
        binding handle.

    AuthIdentity - Optionally returns a handle to the security context
        being used for authentication and authorization.

    AuthzSvc -  Optionally returns the authorization service set for the
        binding handle.

    RpcSecurityQosVersion - Indicates a version for RPC_SECURITY_QOS structure,
        that optionally can be inquired. If SecurityQOS passes in is 0, this
        is ignored.

    SecurityQOS - is the version of the Security Quality Of Service


Return Value:

    RPC_S_OK - We successfully returned the information requested.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_BINDING_HAS_NO_AUTH - RpcBindingInqAuthInfo has not yet been
        called on the binding handle, so there is not authentication or
        authorization to be returned.

--*/
{
    BINDING_HANDLE * BindingObject;
    CLIENT_AUTH_INFO * ClientAuthInfo;

    InitializeIfNecessary();

    BindingObject = (BINDING_HANDLE *) Binding;
    if ( BindingObject->InvalidHandle(BINDING_HANDLE_TYPE) )
        {
        return(RPC_S_INVALID_BINDING);
        }

    ClientAuthInfo = BindingObject->InquireAuthInformation();
    if ( ClientAuthInfo == 0
         || ClientAuthInfo->AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE)
        {
        return(RPC_S_BINDING_HAS_NO_AUTH);
        }

    if (ARGUMENT_PRESENT(AuthnLevel))
        {
        *AuthnLevel = ClientAuthInfo->AuthenticationLevel;
        }
    if (ARGUMENT_PRESENT(AuthnSvc))
        {
        *AuthnSvc = ClientAuthInfo->AuthenticationService;
        }
    if (ARGUMENT_PRESENT(AuthIdentity))
        {
        *AuthIdentity = ClientAuthInfo->AuthIdentity;
        }
    if (ARGUMENT_PRESENT(AuthzSvc))
        {
        *AuthzSvc = ClientAuthInfo->AuthorizationService;
        }
    if (ARGUMENT_PRESENT(ServerPrincName))
        {
        if ( ClientAuthInfo->ServerPrincipalName == 0 )
            {
            *ServerPrincName = 0;
            }
        else
            {
            *ServerPrincName = DuplicateStringPAPI(
                    ClientAuthInfo->ServerPrincipalName);
            if ( *ServerPrincName == 0 )
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            }
        }
    if (ARGUMENT_PRESENT(SecurityQos))
        {
        if (RpcSecurityQosVersion != RPC_C_SECURITY_QOS_VERSION)
            {
            if (ARGUMENT_PRESENT(ServerPrincName))
                delete *ServerPrincName;
            return (RPC_S_INVALID_ARG);
            }
        SecurityQos->Version = RPC_C_SECURITY_QOS_VERSION;
        SecurityQos->Capabilities = ClientAuthInfo->Capabilities;
        SecurityQos->ImpersonationType = ClientAuthInfo->ImpersonationType;
        SecurityQos->IdentityTracking  = ClientAuthInfo->IdentityTracking;
        }
    return(RPC_S_OK);
}



RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfo (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    )
/*++

Routine Description:

    A client application will use this routine to specify the authentication
    and authorization information in a binding handle, so that the binding
    handle can be used to make authenticated remote procedure calls.  If
    the this routine is not used, then all remote procedure calls on the
    binding handle will be unauthenticated.

Arguments:

    Binding - Supplies binding handle for which we want to set authentication
        and authorization information.

    ServerPrincName - Supplies the expected principal name of the server
        referenced by the binding handle (that is supplied as the binding
        argument).  This information is necessary for some security services
        to be able to authenticate with the server.

    AuthnLevel - Supplies a value indicating the amount (or level) of
        authentication to be performed on remote procedure calls using
        the binding handle.  If we do not support the requested level,
        we will upgrade to the next highest supported level.

        RPC_C_AUTHN_LEVEL_DEFAULT - Indicates that the default level for
            authentication service being used should be used.

        RPC_C_AUTHN_LEVEL_NONE - Do not perform any authentication.

        RPC_C_AUTHN_LEVEL_CONNECT - Authentication will be performed only
            when the client first talks to the server.

        RPC_C_AUTHN_LEVEL_CALL - For connection based protocols, we will
            use RPC_C_AUTHN_LEVEL_PKT instead; for datagram based protocols,
            authentication will be performed at the beginning of each
            remote procedure call.

        RPC_C_AUTHN_LEVEL_PKT - All data will be authenticated to insure that
            the data it is received from the expected client.

        RPC_C_AUTHN_LEVEL_PKT_INTEGRITY - In addition, to authenticating that
            the data is from the expected client, we will verify that none
            of it has been modified.

        RPC_C_AUTHN_LEVEL_PKT_PRIVACY - Finally, this includes all of the
            support in packet integrity, as well as encrypting all remote
            procedure call data.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentify - Optionally supplies authentication and authorization
        credentials to use; if this argument is not specified, the security
        context for the current address space will be used.

    AuthzSvc - Supplies the authorization service being used by the
        server.  The client must know this so that the correct authorization
        information can be sent to the server.

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
        been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
        not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
        by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
        not supported.

--*/

{
   return (  RpcBindingSetAuthInfoEx(
                Binding,
                ServerPrincName,
                AuthnLevel,
                AuthnSvc,
                AuthIdentity,
                AuthzSvc,
                0 ) );
}


RPC_STATUS RPC_ENTRY
RpcBindingSetAuthInfoEx (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned short PAPI * ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc,
    IN RPC_SECURITY_QOS *SecurityQOS
    )
/*++

Routine Description:

    A client application will use this routine to specify the authentication
    and authorization information in a binding handle, so that the binding
    handle can be used to make authenticated remote procedure calls.  If
    the this routine is not used, then all remote procedure calls on the
    binding handle will be unauthenticated.

Arguments:

    Binding - Supplies binding handle for which we want to set authentication
        and authorization information.

    ServerPrincName - Supplies the expected principal name of the server
        referenced by the binding handle (that is supplied as the binding
        argument).  This information is necessary for some security services
        to be able to authenticate with the server.

    AuthnLevel - Supplies a value indicating the amount (or level) of
        authentication to be performed on remote procedure calls using
        the binding handle.  If we do not support the requested level,
        we will upgrade to the next highest supported level.

        RPC_C_AUTHN_LEVEL_DEFAULT - Indicates that the default level for
            authentication service being used should be used.

        RPC_C_AUTHN_LEVEL_NONE - Do not perform any authentication.

        RPC_C_AUTHN_LEVEL_CONNECT - Authentication will be performed only
            when the client first talks to the server.

        RPC_C_AUTHN_LEVEL_CALL - For connection based protocols, we will
            use RPC_C_AUTHN_LEVEL_PKT instead; for datagram based protocols,
            authentication will be performed at the beginning of each
            remote procedure call.

        RPC_C_AUTHN_LEVEL_PKT - All data will be authenticated to insure that
            the data it is received from the expected client.

        RPC_C_AUTHN_LEVEL_PKT_INTEGRITY - In addition, to authenticating that
            the data is from the expected client, we will verify that none
            of it has been modified.

        RPC_C_AUTHN_LEVEL_PKT_PRIVACY - Finally, this includes all of the
            support in packet integrity, as well as encrypting all remote
            procedure call data.

    AuthnSvc - Supplies the authentication service to use.

    AuthIdentify - Optionally supplies authentication and authorization
        credentials to use; if this argument is not specified, the security
        context for the current address space will be used.

    AuthzSvc - Supplies the authorization service being used by the
        server.  The client must know this so that the correct authorization
        information can be sent to the server.

    SecurityQOS - a security QOS stucture. Currently accepting RPC_C_SECURITY_QOS_VERSION_2
        and RPC_C_SECURITY_QOS_VERSION_1

Return Value:

    RPC_S_OK - The supplied authentication and authorization information has
        been set in the binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_INVALID_BINDING - The value supplied as the binding argument is
        not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - A binding handle on the client side must
        be specified as the binding argument.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

    RPC_S_UNKNOWN_AUTHN_LEVEL - The specified authentication level is
        not supported.

    RPC_S_INVALID_AUTH_IDENTITY - The specified security context (supplied
        by the auth identity argument) is invalid.

    RPC_S_UNKNOWN_AUTHZ_SERVICE - The specified authorization service is
        not supported.

--*/
{
    BINDING_HANDLE * BindingObject;
    RPC_STATUS Status;
    RPC_CHAR __RPC_FAR * ServerName;
    unsigned long ImpersonationType;
    unsigned long IdentityTracking;
    unsigned long Capabilities;
    void *AdditionalCredentials;
    ULONG AdditionalTransportCredentialsType;
    THREAD *Thread;
    RPC_HTTP_TRANSPORT_CREDENTIALS_W *HttpCredentials;
    unsigned int i;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    BindingObject = (BINDING_HANDLE *) Binding;

    if ((SecurityQOS != 0) &&
        (SecurityQOS->Version != RPC_C_SECURITY_QOS_VERSION_1) &&
        (SecurityQOS->Version != RPC_C_SECURITY_QOS_VERSION_2) )
        {
        return(RPC_S_INVALID_ARG);
        }

    if ( BindingObject->InvalidHandle(BINDING_HANDLE_TYPE) )
        {
        return(RPC_S_INVALID_BINDING);
        }

    //
    // For no authentication, bail out now.
    //

    if (AuthnSvc == RPC_C_AUTHN_NONE)
        {
        if ((AuthnLevel != RPC_C_AUTHN_LEVEL_NONE) &&
            (AuthnLevel != RPC_C_AUTHN_LEVEL_DEFAULT))
            {
            return(RPC_S_UNKNOWN_AUTHN_LEVEL);
            }
        //
        // Clear the authentication info..
        //

        Status = BindingObject->SetAuthInformation(
                                      0,
                                      RPC_C_AUTHN_LEVEL_NONE,
                                      AuthnSvc,
                                      0,
                                      0
                                      );
        return(Status);
        }

    if (AuthnSvc == RPC_C_AUTHN_DEFAULT)
        {
        RpcpGetDefaultSecurityProviderInfo();
        AuthnSvc = DefaultProviderId;
        }

    if (AuthnSvc == RPC_C_AUTHN_GSS_SCHANNEL)
        {
        if (AuthnLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
            AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
            }
        }

    if (SecurityQOS != 0)
        {
        IdentityTracking = SecurityQOS->IdentityTracking;
        ImpersonationType= SecurityQOS->ImpersonationType;
        Capabilities     = SecurityQOS->Capabilities;

        if (SecurityQOS->Version == RPC_C_SECURITY_QOS_VERSION_1)
            {
            AdditionalTransportCredentialsType = 0;
            AdditionalCredentials = NULL;
            }
        else
            {
            AdditionalTransportCredentialsType = ((RPC_SECURITY_QOS_V2 *)SecurityQOS)->AdditionalSecurityInfoType;
            AdditionalCredentials = ((RPC_SECURITY_QOS_V2 *)SecurityQOS)->u.HttpCredentials;

            if (AdditionalTransportCredentialsType != RPC_C_AUTHN_INFO_TYPE_HTTP)
                {
                if (AdditionalTransportCredentialsType != 0)
                    return(RPC_S_INVALID_ARG);

                if (AdditionalCredentials != NULL)
                    return(RPC_S_INVALID_ARG);
                }
            else if (AdditionalCredentials == NULL)
                return(RPC_S_INVALID_ARG);
            else
                {
                HttpCredentials = (RPC_HTTP_TRANSPORT_CREDENTIALS_W *)AdditionalCredentials;

                if (HttpCredentials->TransportCredentials)
                    {
                    if (HttpCredentials->TransportCredentials->User)
                        {
                        if (RpcpStringLength(HttpCredentials->TransportCredentials->User) 
                            != HttpCredentials->TransportCredentials->UserLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->UserLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Domain)
                        {
                        if (RpcpStringLength(HttpCredentials->TransportCredentials->Domain) 
                            != HttpCredentials->TransportCredentials->DomainLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->DomainLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Password)
                        {
                        if (RpcpStringLength(HttpCredentials->TransportCredentials->Password) 
                            != HttpCredentials->TransportCredentials->PasswordLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->PasswordLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Flags != SEC_WINNT_AUTH_IDENTITY_UNICODE)
                        return(RPC_S_INVALID_ARG);
                    }

                // if you don't want to authenticate against anyone, you can't authenticate
                if (HttpCredentials->AuthenticationTarget == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->NumberOfAuthnSchemes == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->AuthnSchemes == NULL)
                    return(RPC_S_INVALID_ARG);

                // check whether Negotiate, Passport or Digest are in the list of auth scehemes. If yes,
                // reject the call since we don't support them yet.
                for (i = 0; i < HttpCredentials->NumberOfAuthnSchemes; i ++)
                    {
                    if (HttpCredentials->AuthnSchemes[i] == RPC_C_HTTP_AUTHN_SCHEME_PASSPORT)
                        return RPC_S_CANNOT_SUPPORT;
                    if (HttpCredentials->AuthnSchemes[i] == RPC_C_HTTP_AUTHN_SCHEME_NEGOTIATE)
                        return RPC_S_CANNOT_SUPPORT;
                    if (HttpCredentials->AuthnSchemes[i] == RPC_C_HTTP_AUTHN_SCHEME_DIGEST)
                        return RPC_S_CANNOT_SUPPORT;
                    }
                }
            }
        }
    else
        {
        IdentityTracking   = RPC_C_QOS_IDENTITY_STATIC;
        ImpersonationType  = RPC_C_IMP_LEVEL_IMPERSONATE;
        Capabilities       = RPC_C_QOS_CAPABILITIES_DEFAULT;
        AdditionalTransportCredentialsType = 0;
        AdditionalCredentials = NULL;
        }

    Status = BindingObject->SetAuthInformation(
                                      ServerPrincName,
                                      AuthnLevel,
                                      AuthnSvc,
                                      AuthIdentity,
                                      AuthzSvc,
                                      0,
                                      ImpersonationType,
                                      IdentityTracking,
                                      Capabilities,
                                      TRUE,  // Acquire new credentials
                                      AdditionalTransportCredentialsType,
                                      AdditionalCredentials
                                      );

   return (Status);
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqSecurityContext (
    IN RPC_BINDING_HANDLE Binding,
    OUT void **SecurityContextHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

    The status for the operation is returned.

--*/
{
    CALL * Call;

    InitializeIfNecessary();

    Call = (CALL *) Binding;

    if (Call->InvalidHandle(CALL_TYPE))
        return(RPC_S_INVALID_BINDING);

    return(Call->InqSecurityContext(SecurityContextHandle));
}

RPC_STATUS RPC_ENTRY
I_RpcTurnOnEEInfoPropagation (
    void
    )
/*++

Routine Description:
    Turns on extended error info propagation for this process.

Arguments:


Return Value:

    RPC_S_OK.

--*/
{
    g_fSendEEInfo = TRUE;

    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dcethunk.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dceansi.cxx


Abstract:

    This file contains the ansi (as opposed to unicode) versions of the
    runtime APIs.  All of these APIs simply do conversions between ansi
    and unicode, and then call a unicode version of the API to do the
    work.

Author:

    Michael Montague (mikemon) 18-Dec-1991

Revision History:

--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <CharConv.hxx>


RPC_STATUS
AnsiToUnicodeString (
    IN unsigned char * String,
    OUT UNICODE_STRING * UnicodeString
    )
/*++

Routine Description:

    This helper routine is used to convert an ansi string into a unicode
    string.

Arguments:

    String - Supplies the ansi string (actually a zero terminated string)
        to convert into a unicode string.

    UnicodeString - Returns the unicode string.  This string will have
        to be freed using RtlFreeUnicodeString by the caller.

Return Value:

    RPC_S_OK - The ansi string was successfully converted into a unicode
        string.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available for the unicode
        string.

--*/
{
    NTSTATUS NtStatus;
    ANSI_STRING AnsiString;

    RtlInitAnsiString(&AnsiString,(PSZ) String);
    NtStatus = RtlAnsiStringToUnicodeString(UnicodeString,&AnsiString,TRUE);
    if (!NT_SUCCESS(NtStatus))
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}

unsigned char *
UnicodeToAnsiString (
    IN RPC_CHAR * WideCharString,
    OUT RPC_STATUS * RpcStatus
    )
/*++

Routine Description:

    This routine will convert a unicode string into an ansi string,
    including allocating memory for the ansi string.

Arguments:

    WideCharString - Supplies the unicode string to be converted into
        an ansi string.

    RpcStatus - Returns the status of the operation; this will be one
        of the following values.

        RPC_S_OK - The unicode string has successfully been converted
            into an ansi string.

        RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
            the ansi string.

Return Value:

    A pointer to the ansi string will be returned.

--*/
{
    NTSTATUS NtStatus;
    UNICODE_STRING UnicodeString;
    ANSI_STRING AnsiString;
    unsigned char * NewString;

    RtlInitUnicodeString(&UnicodeString,WideCharString);
    NtStatus = RtlUnicodeStringToAnsiString(&AnsiString,&UnicodeString,TRUE);
    if (!NT_SUCCESS(NtStatus))
        {
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    NewString = new unsigned char[AnsiString.Length + 1];
    if (NewString == 0)
        {
        RtlFreeAnsiString(&AnsiString);
        *RpcStatus = RPC_S_OUT_OF_MEMORY;
        return(0);
        }

    memcpy(NewString,AnsiString.Buffer,AnsiString.Length + 1);
    RtlFreeAnsiString(&AnsiString);
    *RpcStatus = RPC_S_OK;
    return(NewString);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingFromStringBinding) (
    IN THUNK_CHAR *StringBinding,
    OUT RPC_BINDING_HANDLE PAPI * Binding
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcBindingFromStringBindingW.

Return Value:

    RPC_S_OUT_OF_MEMORY - This value will be returned if there is
        insufficient memory available to allocate the unicode string.

--*/
{
        USES_CONVERSION;
        RPC_STATUS RpcStatus;
        CHeapInThunk thunkStringBinding;

        ATTEMPT_HEAP_IN_THUNK(thunkStringBinding, StringBinding);

    RpcStatus = RpcBindingFromStringBinding(thunkStringBinding, Binding);

    return(RpcStatus);
}



RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingToStringBinding) (
    IN RPC_BINDING_HANDLE Binding,
    OUT THUNK_CHAR **StringBinding
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcBindingToStringBindingW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not
        have enough memory to convert the unicode string binding
        into an ansi string binding.

--*/
{
    RPC_STATUS RpcStatus;
    COutDelThunk thunkStringBinding;
    USES_CONVERSION;

    RpcStatus = RpcBindingToStringBinding(Binding, thunkStringBinding);
    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    ATTEMPT_OUT_THUNK(thunkStringBinding, StringBinding);

    return(RpcStatus);
}

/*

static RPC_STATUS
AnsiToUnicodeStringOptional (
    IN unsigned char * String OPTIONAL,
    OUT UNICODE_STRING * UnicodeString
    )
++

Routine Description:

    This routine is just the same as AnsiToUnicodeString, except that the
    ansi string is optional.  If no string is specified, then the buffer
    of the unicode string is set to zero.

Arguments:

    String - Optionally supplies an ansi string to convert to a unicode
        string.

    UnicodeString - Returns the converted unicode string.

Return Value:

    RPC_S_OK - The ansi string was successfully converted into a unicode
        string.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available for the unicode
        string.
--
{
    if (ARGUMENT_PRESENT(String))
        return(AnsiToUnicodeString(String,UnicodeString));
    UnicodeString->Buffer = 0;
    return(RPC_S_OK);
}
*/


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcStringBindingCompose) (
    IN THUNK_CHAR *ObjUuid OPTIONAL,
    IN THUNK_CHAR *Protseq OPTIONAL,
    IN THUNK_CHAR *NetworkAddr OPTIONAL,
    IN THUNK_CHAR *Endpoint OPTIONAL,
    IN THUNK_CHAR *Options OPTIONAL,
    OUT THUNK_CHAR **StringBinding OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcStringBindingComposeW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If insufficient memory is available to
        convert unicode string into ansi strings (and back again),
        we will return this value.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedObjUuid;
    CStackInThunk thunkedProtseq;
    CHeapInThunk thunkedNetworkAddr;
    CHeapInThunk thunkedEndpoint;
    CHeapInThunk thunkedOptions;
    COutDelThunk thunkedStringBinding;
    RPC_STATUS RpcStatus;

    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedObjUuid, ObjUuid);
    ATTEMPT_STACK_IN_THUNK_OPTIONAL(thunkedProtseq, Protseq);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedNetworkAddr, NetworkAddr);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedEndpoint, Endpoint);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedOptions, Options);

    RpcStatus = RpcStringBindingCompose(thunkedObjUuid, thunkedProtseq,
            thunkedNetworkAddr, thunkedEndpoint, thunkedOptions,
            thunkedStringBinding);

    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    if (ARGUMENT_PRESENT(StringBinding))
        {
        ATTEMPT_OUT_THUNK(thunkedStringBinding, StringBinding);
        }
    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcStringBindingParse) (
    IN THUNK_CHAR * StringBinding,
    OUT THUNK_CHAR **ObjUuid OPTIONAL,
    OUT THUNK_CHAR **Protseq OPTIONAL,
    OUT THUNK_CHAR **NetworkAddr OPTIONAL,
    OUT THUNK_CHAR **Endpoint OPTIONAL,
    OUT THUNK_CHAR **NetworkOptions OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcStringBindingParseW.

Return Value:

    RPC_S_OUT_OF_MEMORY - This will be returned if insufficient memory
        is available to convert the strings to and from unicode.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedStringBinding;
    COutDelThunk thunkedObjUuid;
    COutDelThunk thunkedProtseq;
    COutDelThunk thunkedNetworkAddr;
    COutDelThunk thunkedEndpoint;
    COutDelThunk thunkedNetworkOptions;
    RPC_STATUS RpcStatus;

    ATTEMPT_HEAP_IN_THUNK(thunkedStringBinding, StringBinding);

    RpcStatus = RpcStringBindingParse(thunkedStringBinding,
            thunkedObjUuid, thunkedProtseq, thunkedNetworkAddr,
            thunkedEndpoint, thunkedNetworkOptions);

    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    if (ARGUMENT_PRESENT(Protseq))
        *Protseq = 0;

    if (ARGUMENT_PRESENT(NetworkAddr))
        *NetworkAddr = 0;

    if (ARGUMENT_PRESENT(Endpoint))
        *Endpoint = 0;

    if (ARGUMENT_PRESENT(NetworkOptions))
        *NetworkOptions = 0;

    if (ARGUMENT_PRESENT(ObjUuid))
        {
        RpcStatus = thunkedObjUuid.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *ObjUuid = thunkedObjUuid;
        }

    if (ARGUMENT_PRESENT(Protseq))
        {
        RpcStatus = thunkedProtseq.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *Protseq = thunkedProtseq;
        }

    if (ARGUMENT_PRESENT(NetworkAddr))
        {
        RpcStatus = thunkedNetworkAddr.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *NetworkAddr = thunkedNetworkAddr;
        }

    if (ARGUMENT_PRESENT(Endpoint))
        {
        RpcStatus = thunkedEndpoint.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *Endpoint = thunkedEndpoint;
        }

    if (ARGUMENT_PRESENT(NetworkOptions))
        {
        RpcStatus = thunkedNetworkOptions.Convert();
        if (RpcStatus != RPC_S_OK)
            goto DeleteStringsAndReturn;
        *NetworkOptions = thunkedNetworkOptions;
        }


DeleteStringsAndReturn:

    if (RpcStatus != RPC_S_OK)
        {
        if (ARGUMENT_PRESENT(Protseq))
            {
            delete *Protseq;
            *Protseq = 0;
            }

        if (ARGUMENT_PRESENT(NetworkAddr))
            {
            delete *NetworkAddr;
            *NetworkAddr = 0;
            }

        if (ARGUMENT_PRESENT(Endpoint))
            {
            delete *Endpoint;
            *Endpoint = 0;
            }

        if (ARGUMENT_PRESENT(NetworkOptions))
            {
            delete *NetworkOptions;
            *NetworkOptions = 0;
            }
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcNetworkIsProtseqValid) (
    IN THUNK_CHAR *Protseq
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcNetworkIsProtseqValidW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we run out of
        memory trying to allocate space for the string.

--*/
{
    USES_CONVERSION;
    CStackInThunk thunkedProtseq;
    RPC_STATUS RpcStatus;

    ATTEMPT_STACK_IN_THUNK(thunkedProtseq, Protseq);

    RpcStatus = RpcNetworkIsProtseqValid(thunkedProtseq);

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcNetworkInqProtseqs) (
#ifdef UNICODE
    OUT RPC_PROTSEQ_VECTORA PAPI * PAPI * ProtseqVector
#else
    OUT RPC_PROTSEQ_VECTORW PAPI * PAPI * ProtseqVector
#endif
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcNetworkInqProtseqsW.

Return Value:

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to convert
        the rpc protocol sequences from unicode into ansi.

--*/
{
    RPC_STATUS RpcStatus;
    RPC_CHAR *pString;
    unsigned int Index, Count;

    RpcStatus = RpcNetworkInqProtseqs(
        (RPC_PROTSEQ_VECTOR **) ProtseqVector);
    if (RpcStatus != RPC_S_OK)
        return(RpcStatus);

    for (Index = 0, Count = (*ProtseqVector)->Count; Index < Count; Index++)
        {
        pString = (RPC_CHAR *) (*ProtseqVector)->Protseq[Index];
#ifdef UNICODE
        RpcStatus = W2AAttachHelper(pString, (char **) &((*ProtseqVector)->Protseq[Index]));
#else
        RpcStatus = A2WAttachHelper((char *) pString, &((*ProtseqVector)->Protseq[Index]));
#endif
        delete pString;
        if (RpcStatus != RPC_S_OK)
            {
#ifdef UNICODE
            RpcProtseqVectorFreeA(ProtseqVector);
#else
            RpcProtseqVectorFreeW(ProtseqVector);
#endif
            return(RpcStatus);
            }
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcProtseqVectorFree) (
#ifdef UNICODE
    IN OUT RPC_PROTSEQ_VECTORA PAPI * PAPI * ProtseqVector
#else
    IN OUT RPC_PROTSEQ_VECTORW PAPI * PAPI * ProtseqVector
#endif
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcProtseqVectorFreeW.

--*/
{
    return(RpcProtseqVectorFree((RPC_PROTSEQ_VECTOR **) ProtseqVector));
}


RPC_STATUS RPC_ENTRY
THUNK_FN(I_RpcServerUseProtseq2) (
    IN THUNK_CHAR * NetworkAddress,
    IN THUNK_CHAR * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN void * pPolicy
    )
{
    USES_CONVERSION;
    CStackInThunk thunkProtseq;
    CHeapInThunk thunkNetworkAddress;
    RPC_STATUS RpcStatus;
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;

    ATTEMPT_STACK_IN_THUNK(thunkProtseq, Protseq);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkNetworkAddress, NetworkAddress);

    RpcStatus = I_RpcServerUseProtseq2(thunkNetworkAddress, thunkProtseq, MaxCalls,
        SecurityDescriptor, (void *) Policy);

    return(RpcStatus);
}



RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqEx) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    return THUNK_FN(I_RpcServerUseProtseq2) (NULL, Protseq, MaxCalls, SecurityDescriptor, (void *) Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseq) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return THUNK_FN(I_RpcServerUseProtseq2) (NULL, Protseq, MaxCalls, SecurityDescriptor, (void *) &Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(I_RpcServerUseProtseqEp2) (
    IN THUNK_CHAR * NetworkAddress,
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN THUNK_CHAR *Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN void * pPolicy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqEpW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    USES_CONVERSION;
    CStackInThunk thunkedProtseq;
    CHeapInThunk thunkedEndpoint;
    CHeapInThunk thunkedNetworkAddress;
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;

    ATTEMPT_STACK_IN_THUNK(thunkedProtseq, Protseq);
    ATTEMPT_HEAP_IN_THUNK(thunkedEndpoint, Endpoint);
    ATTEMPT_HEAP_IN_THUNK_OPTIONAL(thunkedNetworkAddress, NetworkAddress);

    return (I_RpcServerUseProtseqEp2(thunkedNetworkAddress, thunkedProtseq, MaxCalls,
        thunkedEndpoint, SecurityDescriptor,
        (void *) Policy));
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqEpEx) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN THUNK_CHAR *Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqEpW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    return THUNK_FN(I_RpcServerUseProtseqEp2) (NULL, Protseq, MaxCalls, Endpoint,
                    SecurityDescriptor, (void *) Policy) ;
}




RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqEp) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN THUNK_CHAR *Endpoint,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return THUNK_FN(I_RpcServerUseProtseqEp2) (NULL, Protseq, MaxCalls, Endpoint,
                    SecurityDescriptor, (void *) &Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqIfEx) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This is the ansi thunk to RpcServerUseProtseqIfW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we do not have enough memory to convert
        the ansi strings into unicode strings, this value will be returned.

--*/
{
    USES_CONVERSION;
    CStackInThunk thunkedProtseq;

    ATTEMPT_STACK_IN_THUNK(thunkedProtseq, Protseq);

    return (RpcServerUseProtseqIfEx(thunkedProtseq, MaxCalls,
                        IfSpec, SecurityDescriptor, Policy));
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerUseProtseqIf) (
    IN THUNK_CHAR *Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return THUNK_FN(RpcServerUseProtseqIfEx) ( Protseq, MaxCalls, IfSpec,
                SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcNsBindingInqEntryName) (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long EntryNameSyntax,
    OUT THUNK_CHAR **EntryName
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcNsBindingInqEntryNameW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not
        have enough memory to convert the unicode entry name into
        an ansi entry name.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedEntryName;

    RpcStatus = RpcNsBindingInqEntryName(Binding, EntryNameSyntax,
            thunkedEntryName);

    if ( RpcStatus == RPC_S_NO_ENTRY_NAME )
        {
        ATTEMPT_OUT_THUNK(thunkedEntryName, EntryName);
        return(RPC_S_NO_ENTRY_NAME);
        }

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    ATTEMPT_OUT_THUNK(thunkedEntryName, EntryName);
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(UuidToString) (
    IN UUID PAPI * Uuid,
    OUT THUNK_CHAR **StringUuid
    )
/*++

Routine Description:

    This routine converts a UUID into its string representation.

Arguments:

    Uuid - Supplies the UUID to be converted into string representation.

    StringUuid - Returns the string representation of the UUID.  The
        runtime will allocate the string.  The caller is responsible for
        freeing the string using RpcStringFree.

Return Value:

    RPC_S_OK - We successfully converted the UUID into its string
        representation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a string.

--*/
{
    // The string representation of a UUID is always 36 character long,
    // and we need one more for the terminating zero.

    RPC_CHAR String[37];
    RPC_STATUS RpcStatus;

    InitializeIfNecessary();

    ((RPC_UUID PAPI *) Uuid)->ConvertToString(String);
    String[36] = 0;
#ifdef UNICODE
    return W2AAttachHelper(String, (char **)StringUuid);
#else
    return A2WAttachHelper((char *)String, StringUuid);
#endif
}


RPC_STATUS RPC_ENTRY
THUNK_FN(UuidFromString) (
    IN THUNK_CHAR *StringUuid OPTIONAL,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    We convert a UUID from its string representation into the binary
    representation.

Arguments:

    StringUuid - Optionally supplies the string representation of the UUID;
        if this argument is not supplied, then the NIL UUID is returned.

    Uuid - Returns the binary representation of the UUID.

Return Value:

    RPC_S_OK - The string representation was successfully converted into
        the binary representation.

    RPC_S_INVALID_STRING_UUID - The supplied string UUID is not correct.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to convert the
        ansi string into a unicode string.

--*/
{
    RPC_UUID RpcUuid;
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    CHeapInThunk thunkedStringUuid;

    if ( StringUuid == 0 )
        {
        ((RPC_UUID PAPI *) Uuid)->SetToNullUuid();
        return(RPC_S_OK);
        }

    ATTEMPT_HEAP_IN_THUNK(thunkedStringUuid, StringUuid);

    if (RpcUuid.ConvertFromString(thunkedStringUuid) != 0)
        {
        return(RPC_S_INVALID_STRING_UUID);
        }
    ((RPC_UUID PAPI *) Uuid)->CopyUuid(&RpcUuid);
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerRegisterAuthInfo) (
    IN THUNK_CHAR *ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn OPTIONAL,
    IN void PAPI * Arg OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk to RpcServerRegisterAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not have
        enough memory to convert the ansi server principal name into
        a unicode string.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedServerPrincName;
    RPC_STATUS RpcStatus;

    ATTEMPT_HEAP_IN_THUNK(thunkedServerPrincName, ServerPrincName);

    RpcStatus = RpcServerRegisterAuthInfo(thunkedServerPrincName, AuthnSvc,
            GetKeyFn, Arg);

    return(RpcStatus);
}

RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthClient) (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT THUNK_CHAR **PrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
{
    return THUNK_FN(RpcBindingInqAuthClientEx)( ClientBinding,
                                       Privs,
                                       PrincName,
                                       AuthnLevel,
                                       AuthnSvc,
                                       AuthzSvc,
                                       0
                                       );
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthClientEx) (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT THUNK_CHAR **ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long        Flags
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingInqAuthClientW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RpcStatus = RpcBindingInqAuthClientEx(ClientBinding,
                                          Privs,
                                          (ARGUMENT_PRESENT(ServerPrincName) ? (RPC_CHAR **)thunkedServerPrincName : 0),
                                          AuthnLevel,
                                          AuthnSvc,
                                          AuthzSvc,
                                          Flags);

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    if (ARGUMENT_PRESENT(ServerPrincName))
        {
        ATTEMPT_OUT_THUNK_OPTIONAL(thunkedServerPrincName, ServerPrincName);
        }
    return(RpcStatus);
}

RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerInqCallAttributes) (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcServerInqCallAttributes.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.
    The API can in addition return all errors returned by the Unicode
        version.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;
    RPC_CALL_ATTRIBUTES_V1_W *CallAttributesW;
    RPC_CALL_ATTRIBUTES_V1_A *CallAttributesA;
    unsigned char *OldClientPrincipalNameBuffer;
    RPC_CHAR *NewClientPrincipalNameBuffer = NULL;
    ULONG OldClientPrincipalNameBufferLength;
    ULONG NewClientPrincipalNameBufferLength;
    unsigned char *OldServerPrincipalNameBuffer;
    RPC_CHAR *NewServerPrincipalNameBuffer = NULL;
    ULONG OldServerPrincipalNameBufferLength;
    ULONG NewServerPrincipalNameBufferLength;

    // we use the same structure to pass to the unicode API, but
    // we save some data members
    CallAttributesW = 
        (RPC_CALL_ATTRIBUTES_V1_W *)RpcCallAttributes;
    CallAttributesA = 
        (RPC_CALL_ATTRIBUTES_V1_A *)RpcCallAttributes;

    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        OldClientPrincipalNameBuffer = CallAttributesA->ClientPrincipalName;
        OldClientPrincipalNameBufferLength = CallAttributesA->ClientPrincipalNameBufferLength;
        if (OldClientPrincipalNameBufferLength != 0)
            {
            NewClientPrincipalNameBuffer = new RPC_CHAR[OldClientPrincipalNameBufferLength];
            if (NewClientPrincipalNameBuffer == NULL)
                {
                return RPC_S_OUT_OF_MEMORY;
                }
            }
        else
            {
            // here CallAttributesW->ClientPrincipalName must be NULL. If it's
            // not, the unicode function will return error. Delegate the check to it
            NewClientPrincipalNameBuffer = CallAttributesW->ClientPrincipalName;
            }
        }

    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        OldServerPrincipalNameBuffer = CallAttributesA->ServerPrincipalName;
        OldServerPrincipalNameBufferLength = CallAttributesA->ServerPrincipalNameBufferLength;
        if (OldServerPrincipalNameBufferLength != 0)
            {
            NewServerPrincipalNameBuffer = new RPC_CHAR[OldServerPrincipalNameBufferLength];
            if (NewServerPrincipalNameBuffer == NULL)
                {
                if ((CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME) 
                    && (OldClientPrincipalNameBufferLength != 0))
                    {
                    ASSERT(NewClientPrincipalNameBuffer != NULL);
                    delete NewClientPrincipalNameBuffer;
                    }
                return RPC_S_OUT_OF_MEMORY;
                }
            }
        else
            {
            // here CallAttributesW->ServerPrincipalName must be NULL. If it's
            // not, the unicode function will return error. Delegate the check to it
            NewServerPrincipalNameBuffer = CallAttributesW->ServerPrincipalName;
            }
        }

    // by now all buffers are allocated, so we don't have failure paths b/n
    // here and the API call
    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        CallAttributesW->ServerPrincipalName = NewServerPrincipalNameBuffer;
        CallAttributesW->ServerPrincipalNameBufferLength *= 2;
        }

    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        CallAttributesW->ClientPrincipalName = NewClientPrincipalNameBuffer;
        CallAttributesW->ClientPrincipalNameBufferLength *= 2;
        }

    RpcStatus = RpcServerInqCallAttributes(ClientBinding,
                                          RpcCallAttributes
                                          );

    // restore user's values to the structure regardless of failure
    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        NewClientPrincipalNameBufferLength = CallAttributesA->ClientPrincipalNameBufferLength;
        CallAttributesA->ClientPrincipalNameBufferLength = OldClientPrincipalNameBufferLength;
        CallAttributesA->ClientPrincipalName = OldClientPrincipalNameBuffer;
        };

    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        NewServerPrincipalNameBufferLength = CallAttributesA->ServerPrincipalNameBufferLength;
        CallAttributesA->ServerPrincipalNameBufferLength = OldServerPrincipalNameBufferLength;
        CallAttributesA->ServerPrincipalName = OldServerPrincipalNameBuffer;
        };

    if ((RpcStatus != RPC_S_OK)
        && (RpcStatus != ERROR_MORE_DATA))
        {
        if ((CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME) 
            && (OldClientPrincipalNameBufferLength != 0))
            {
            ASSERT(NewClientPrincipalNameBuffer != NULL);
            delete NewClientPrincipalNameBuffer;
            }

        if ((CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME) 
            && (OldServerPrincipalNameBufferLength != 0))
            {
            ASSERT(NewServerPrincipalNameBuffer != NULL);
            delete NewServerPrincipalNameBuffer;
            }

        return(RpcStatus);
        }

    ASSERT((RpcStatus == RPC_S_OK)
        || (RpcStatus == ERROR_MORE_DATA));

    if (CallAttributesW->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        CallAttributesW->ServerPrincipalNameBufferLength = NewServerPrincipalNameBufferLength >> 1;
        // if we returned non-zero, and there was enough space in the string to start with, we must
        // have returned a string as well
        if ((CallAttributesW->ServerPrincipalNameBufferLength > 0)
            && (CallAttributesW->ServerPrincipalNameBufferLength <= OldServerPrincipalNameBufferLength))
            {
            RtlUnicodeToMultiByteN((char *)CallAttributesA->ServerPrincipalName, 
                CallAttributesA->ServerPrincipalNameBufferLength, 
                NULL, 
                NewServerPrincipalNameBuffer, 
                NewServerPrincipalNameBufferLength);
            }
        }

    if (CallAttributesW->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        CallAttributesW->ClientPrincipalNameBufferLength = NewClientPrincipalNameBufferLength >> 1;
        // if we returned non-zero, and there was enough space in the string to start with, we must
        // have returned a string as well
        if ((CallAttributesW->ClientPrincipalNameBufferLength > 0)
            && (CallAttributesW->ClientPrincipalNameBufferLength <= OldClientPrincipalNameBufferLength))
            {
            RtlUnicodeToMultiByteN((char *)CallAttributesA->ClientPrincipalName, 
                CallAttributesA->ClientPrincipalNameBufferLength, 
                NULL, 
                NewClientPrincipalNameBuffer, 
                NewClientPrincipalNameBufferLength);
            }
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthInfo) (
    IN RPC_BINDING_HANDLE Binding,
    OUT THUNK_CHAR **ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingInqAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.

--*/
{
    RPC_STATUS RpcStatus;

    return( THUNK_FN(RpcBindingInqAuthInfoEx) (
                     Binding,
                     ServerPrincName,
                     AuthnLevel,
                     AuthnSvc,
                     AuthIdentity,
                     AuthzSvc,
                     0,
                     0
                     ) );

}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingInqAuthInfoEx) (
    IN RPC_BINDING_HANDLE Binding,
    OUT THUNK_CHAR **ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT RPC_AUTH_IDENTITY_HANDLE PAPI * AuthIdentity, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long RpcSecurityQosVersion,
    OUT RPC_SECURITY_QOS * SecurityQOS
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingInqAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - If we can not allocate space to convert the
        unicode server principal name into unicode, we will return this
        value.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RpcStatus = RpcBindingInqAuthInfoEx(
            Binding,
            (ARGUMENT_PRESENT(ServerPrincName) ? (RPC_CHAR **)thunkedServerPrincName : 0),
            AuthnLevel,
            AuthnSvc,
            AuthIdentity,
            AuthzSvc,
            RpcSecurityQosVersion,
            SecurityQOS
            );

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    if (ARGUMENT_PRESENT(ServerPrincName))
        {
        ATTEMPT_OUT_THUNK(thunkedServerPrincName, ServerPrincName);
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingSetAuthInfo)(
    IN RPC_BINDING_HANDLE Binding,
    IN THUNK_CHAR *ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc
    )
{


    return ( THUNK_FN(RpcBindingSetAuthInfoEx)(
                          Binding,
                          ServerPrincName,
                          AuthnLevel,
                          AuthnSvc,
                          AuthIdentity,
                          AuthzSvc,
                          0
                          ) );

}



RPC_STATUS RPC_ENTRY
THUNK_FN(RpcBindingSetAuthInfoEx) (
    IN RPC_BINDING_HANDLE Binding,
    IN THUNK_CHAR *ServerPrincName,
    IN unsigned long AuthnLevel,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_IDENTITY_HANDLE AuthIdentity, OPTIONAL
    IN unsigned long AuthzSvc,
    IN RPC_SECURITY_QOS * SecurityQOS
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcBindingSetAuthInfoW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not have
        enough memory to convert the ansi server principal name into
        a unicode string.

--*/
{
    USES_CONVERSION;
    CHeapInThunk thunkedServerPrincName;
    RPC_STATUS RpcStatus;
    RPC_HTTP_TRANSPORT_CREDENTIALS_A *HttpCredentials;
    ULONG AdditionalTransportCredentialsType;
    RPC_SECURITY_QOS_V2_W SecurityQOS2;
    RPC_SECURITY_QOS_V2_W *SecurityQOSToUse;

    ATTEMPT_HEAP_IN_THUNK(thunkedServerPrincName, ServerPrincName);

    if (SecurityQOS)
        {
        if (SecurityQOS->Version == RPC_C_SECURITY_QOS_VERSION_1)
            {
            RpcpMemoryCopy(&SecurityQOS2, SecurityQOS, sizeof(RPC_SECURITY_QOS));
            SecurityQOS2.AdditionalSecurityInfoType = 0;
            SecurityQOS2.u.HttpCredentials = NULL;
            }
        else
            {
            RpcpMemoryCopy(&SecurityQOS2, SecurityQOS, sizeof(RPC_SECURITY_QOS_V2_A));
            AdditionalTransportCredentialsType = ((RPC_SECURITY_QOS_V2 *)SecurityQOS)->AdditionalSecurityInfoType;
            HttpCredentials = ((RPC_SECURITY_QOS_V2_A *)SecurityQOS)->u.HttpCredentials;

            if (AdditionalTransportCredentialsType != RPC_C_AUTHN_INFO_TYPE_HTTP)
                {
                if (AdditionalTransportCredentialsType != 0)
                    return(RPC_S_INVALID_ARG);

                if (HttpCredentials != NULL)
                    return(RPC_S_INVALID_ARG);
                }
            else if (HttpCredentials == NULL)
                return(RPC_S_INVALID_ARG);
            else
                {
                if (HttpCredentials->TransportCredentials)
                    {
                    if (HttpCredentials->TransportCredentials->User)
                        {
                        if (RpcpStringLengthA((const char *)HttpCredentials->TransportCredentials->User) 
                            != HttpCredentials->TransportCredentials->UserLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->UserLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Domain)
                        {
                        if (RpcpStringLengthA((const char *)HttpCredentials->TransportCredentials->Domain) 
                            != HttpCredentials->TransportCredentials->DomainLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->DomainLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Password)
                        {
                        if (RpcpStringLengthA((const char *)HttpCredentials->TransportCredentials->Password) 
                            != HttpCredentials->TransportCredentials->PasswordLength)
                            {
                            return(RPC_S_INVALID_ARG);
                            }
                        }
                    else if (HttpCredentials->TransportCredentials->PasswordLength)
                        return(RPC_S_INVALID_ARG);

                    if (HttpCredentials->TransportCredentials->Flags != SEC_WINNT_AUTH_IDENTITY_ANSI)
                        return(RPC_S_INVALID_ARG);
                    }

                // if you don't want to authenticate against anyone, you can't authenticate
                if (HttpCredentials->AuthenticationTarget == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->NumberOfAuthnSchemes == 0)
                    return(RPC_S_INVALID_ARG);

                // if you don't support any method of authentication, you can't authenticate
                if (HttpCredentials->AuthnSchemes == NULL)
                    return(RPC_S_INVALID_ARG);

                SecurityQOS2.u.HttpCredentials = ConvertToUnicodeHttpTransportCredentials (
                    HttpCredentials);

                if (SecurityQOS2.u.HttpCredentials == NULL)
                    return RPC_S_OUT_OF_MEMORY;
                }
            }
        SecurityQOSToUse = &SecurityQOS2;
        }
    else
        {
        SecurityQOSToUse = NULL;
        }

    RpcStatus = RpcBindingSetAuthInfoEx(Binding, thunkedServerPrincName,
            AuthnLevel, AuthnSvc, AuthIdentity, AuthzSvc, (RPC_SECURITY_QOS *)SecurityQOSToUse);

    if (SecurityQOSToUse && (SecurityQOS2.AdditionalSecurityInfoType == RPC_C_AUTHN_INFO_TYPE_HTTP))
        {
        // free the converted credentials
        WipeOutAuthIdentity(SecurityQOS2.u.HttpCredentials->TransportCredentials);
        FreeHttpTransportCredentials(SecurityQOS2.u.HttpCredentials);
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcMgmtInqServerPrincName) (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT THUNK_CHAR **ServerPrincName
    )
/*++

Routine Description:

    This routine is the ansi thunk for RpcMgmtInqServerPrincNameW.

Return Value:

    RPC_S_OUT_OF_MEMORY - We will return this value if we do not have
        enough memory to convert the unicode server principal name into
        an ansi string.

--*/
{
    RPC_STATUS RpcStatus;
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RpcStatus = RpcMgmtInqServerPrincName(Binding, AuthnSvc, thunkedServerPrincName);
    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    ATTEMPT_OUT_THUNK(thunkedServerPrincName, ServerPrincName);
    return(RPC_S_OK);
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
THUNK_FN(RpcCertGeneratePrincipalName)(
                      PCCERT_CONTEXT Context,
                      DWORD         Flags,
                      OUT THUNK_CHAR  **pBuffer
                      )
{
    USES_CONVERSION;
    COutDelThunk thunkedServerPrincName;

    RPC_STATUS Status = RpcCertGeneratePrincipalName( Context,
                                                    Flags,
                                                    thunkedServerPrincName
                                                    );
    if (Status != RPC_S_OK)
        {
        return Status;
        }


    ATTEMPT_OUT_THUNK(thunkedServerPrincName, pBuffer);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dcestrng.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcestrng.cxx

Abstract:

    This module contains the code for the String Object DCE RPC runtime
    APIs, as well as the APIs which compose and parse string bindings.

Author:

    Michael Montague (mikemon) 25-Sep-1991

Revision History:

--*/

#include <precomp.hxx>


RPC_STATUS RPC_ENTRY
RpcStringBindingCompose (
    IN unsigned short PAPI * ObjUuid OPTIONAL,
    IN unsigned short PAPI * Protseq OPTIONAL,
    IN unsigned short PAPI * NetworkAddr OPTIONAL,
    IN unsigned short PAPI * Endpoint OPTIONAL,
    IN unsigned short PAPI * Options OPTIONAL,
    OUT unsigned short PAPI * PAPI * StringBinding OPTIONAL
    )
/*++

Routine Description:

    This routine combines the components of a string binding into a
    string binding.  Empty fields in the string binding can be specified
    by passing a NULL argument value or by providing an empty string ("").

Arguments:

    ObjUuid - Optionally supplies a string representation of an object UUID.

    Protseq - Optionally supplies a string representation of a protocol
        sequence.

    NetworkAddr - Optionally supplies a string representation of a
        network address.

    Endpoint - Optionally supplies a string representation of an endpoint.

    Options - Optionally supplies a string representation of network options.

    StringBinding - Optionally returns the string binding composed from the
        pieces specified by the other parameters.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insuffient memory is available to allocate space
        for the string binding.

--*/
{
    DCE_BINDING * DceBinding;
    RPC_STATUS Status;

    InitializeIfNecessary();

    // If the caller did not want us to return the string binding, then
    // do not even bother to compose one.
    if (!ARGUMENT_PRESENT(StringBinding))
        {
        return (RPC_S_OK);
        }

    DceBinding = new DCE_BINDING(ObjUuid, Protseq, NetworkAddr, Endpoint,
            Options, &Status);

    if (DceBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);


    if (Status != RPC_S_OK)
        {
        delete DceBinding;
        return(Status);
        }

    *StringBinding = DceBinding->StringBindingCompose(0);

    delete DceBinding;

    if (*StringBinding == 0)
        return(RPC_S_OUT_OF_MEMORY);
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcStringBindingParse (
    IN unsigned short PAPI * StringBinding,
    OUT unsigned short PAPI * PAPI * ObjUuid OPTIONAL,
    OUT unsigned short PAPI * PAPI * Protseq OPTIONAL,
    OUT unsigned short PAPI * PAPI * NetworkAddr OPTIONAL,
    OUT unsigned short PAPI * PAPI * Endpoint OPTIONAL,
    OUT unsigned short PAPI * PAPI * NetworkOptions OPTIONAL
    )
/*++

Routine Description:

    RpcStringBindingParse returns as seperate strings the object UUID
    part and address parts of a string binding.

Arguments:

    StringBinding - Supplies a string binding to parsed into its component
        parts.

    ObjUuid - Optionally returns the object UUID part of the string binding.

    Protseq - Optionally returns the protocol sequence part of the string
        binding.

    NetworkAddr - Optionally returns the network address part of the string
        binding.

    Endpoint - Optionally returns the endpoint part of the string binding.

    NetworkOptions - Optionally returns the network options part of the
        string binding.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficent memory is available to allocate
        space for the fields of the string binding.

    RPC_S_INVALID_STRING_BINDING - The string binding is syntactically
        invalid.

    RPC_S_INVALID_ARG - The string binding is not specified
        (ie. ARGUMENT_PRESENT(StringBinding) is false).

--*/
{
    RPC_STATUS Status;
    DCE_BINDING * DceBinding;
    RPC_CHAR __RPC_FAR * CopiedStringBinding;

    InitializeIfNecessary();

    if (!ARGUMENT_PRESENT(StringBinding))
        return(RPC_S_INVALID_ARG);

    CopiedStringBinding = (RPC_CHAR *)
              _alloca( (RpcpStringLength(StringBinding)+1)*(sizeof(RPC_CHAR)) );
    if (CopiedStringBinding == 0)
        {
        return (RPC_S_OUT_OF_MEMORY);
        }
    RpcpStringCopy(CopiedStringBinding, StringBinding);

    DceBinding = new DCE_BINDING(CopiedStringBinding,&Status);

    if ( DceBinding == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    if ( Status != RPC_S_OK )
        {
        delete DceBinding;
        return(Status);
        }

    if ( ARGUMENT_PRESENT(ObjUuid) )
        {
        *ObjUuid = DceBinding->ObjectUuidCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(Protseq) && (Status == RPC_S_OK))
        {
        *Protseq = DceBinding->RpcProtocolSequenceCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(NetworkAddr) && (Status == RPC_S_OK))
        {
        *NetworkAddr = DceBinding->NetworkAddressCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(Endpoint) && (Status == RPC_S_OK))
        {
        *Endpoint = DceBinding->EndpointCompose(&Status);
        }

    if ( ARGUMENT_PRESENT(NetworkOptions) && (Status == RPC_S_OK))
        {
        *NetworkOptions = DceBinding->OptionsCompose(&Status);
        }

    delete DceBinding;

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcStringFreeW (
    IN OUT unsigned short PAPI * PAPI * String
    )
/*++

Routine Description:

    This routine frees a character string allocated by the runtime.

Arguments:

    String - Supplies the address of the pointer to the character string
        to free, and returns zero.

Return Values:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_ARG - The String argument does not contain the address
        of a pointer to a character string.

--*/
{
    InitializeIfNecessary();

    if (String == 0)
        return(RPC_S_INVALID_ARG);

    RpcpFarFree(*String);
    *String = 0;
    return(RPC_S_OK);
}

RPC_STATUS RPC_ENTRY
RpcStringFreeA (
    IN OUT unsigned char PAPI * PAPI * String
    )
/*++

Routine Description:

    This routine frees a character string allocated by the runtime.

Arguments:

    String - Supplies the address of the pointer to the character string
        to free, and returns zero.

Return Values:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_ARG - The String argument does not contain the address
        of a pointer to a character string.

--*/
{
	return RpcStringFreeW((WCHAR **)String);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dcesvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    dcesvr.cxx

Abstract:

    This routine implements the server side DCE runtime APIs.  The
    routines in this file are used by server applications only.

Author:

    Michael Montague (mikemon) 13-Nov-1991

Revision History:

--*/

#include <precomp.hxx>
#include <wincrypt.h>
#include <rpcssl.h>
#include <rpcobj.hxx>
#include <rpcasync.h>
#include <hndlsvr.hxx>
#include <mgmt.h>
#include <rpccfg.h>
#include <CharConv.hxx>

long GroupIdCounter;

RPC_INTERFACE * GlobalManagementInterface;


RPC_STATUS RPC_ENTRY
RpcNetworkInqProtseqs (
    OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector
    )
/*++

Routine Description:

    A server application will call this routine to obtain a list of the
    rpc protocol sequences supported by this system configuration.

Arguments:

    ProtseqVector - Returns a vector of the rpc protocol sequences
        supported by this system configuration.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to inquire
        the rpc protocol sequences supported by this system configuration.

--*/
{
    InitializeIfNecessary();

    return(RpcConfigInquireProtocolSequences(FALSE, ProtseqVector));
}


RPC_STATUS RPC_ENTRY
RpcObjectInqType (
    IN UUID PAPI * ObjUuid,
    OUT UUID PAPI * TypeUuid OPTIONAL
    )
/*++

Routine Description:

    A server application will use this routine to obtain the type uuid
    for an object.  This routine can also be used to determine whether
    a given object is register with the runtime or not.  This is done
    by not specifying the optional type uuid argument.

Arguments:

    ObjUuid - Supplies the object uuid for which we want look up the
        type uuid.

    TypeUuid - Optionally returns the type uuid of the specified object
        uuid.

Return Value:

    RPC_S_OK - The operation completed successfully; the object uuid
        is registered with the runtime or the object inquiry function
        knows the object uuid.

    RPC_S_OBJECT_NOT_FOUND - The specified object uuid has not been
        registered with the runtime and the object inquiry function
        does not know about the object uuid.

--*/
{
    RPC_UUID OptionalTypeUuid;

    InitializeIfNecessary();

    if (ARGUMENT_PRESENT(TypeUuid))
        {
        return(ObjectInqType(
                (RPC_UUID PAPI *) ObjUuid, (RPC_UUID PAPI *) TypeUuid));
        }

    return(ObjectInqType(
            (RPC_UUID PAPI *) ObjUuid, &OptionalTypeUuid));
}


RPC_STATUS RPC_ENTRY
RpcObjectSetInqFn (
    IN RPC_OBJECT_INQ_FN PAPI * InquiryFn
    )
/*++

Routine Description:

    A function to be used to determine an object's type is specified
    using this routine.

Arguments:

    InquiryFn - Supplies a pointer to a function which will automatically
        be called when an inquiry is made for the type of object which
        has not yet been registered with the runtime.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    InitializeIfNecessary();

    return(ObjectSetInqFn(InquiryFn));
}


RPC_STATUS RPC_ENTRY
RpcObjectSetType (
    IN UUID PAPI * ObjUuid,
    IN UUID PAPI * TypeUuid OPTIONAL
    )
/*++

Routine Description:

    An application will call this routine to register an object and its
    type with the runtime.

Arguments:

    ObjUuid - Supplies the object uuid to be registered with the runtime.

    TypeUuid - Supplies the type of the object being registered.  The type
        is registered with the object.

Return Value:

    RPC_S_OK - The object uuid (and type uuid with it) were successfully
        registered with the runtime.

    RPC_S_ALREADY_REGISTERED - The object uuid specified has already
        been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - There is insufficient memory available to
        register the object with the runtime.

    RPC_S_INVALID_OBJECT - The object uuid specified is the nil uuid.

--*/
{
    InitializeIfNecessary();

    return(ObjectSetType(
            (RPC_UUID PAPI *) ObjUuid, (RPC_UUID PAPI *) TypeUuid));
}


RPC_STATUS RPC_ENTRY
RpcProtseqVectorFree (
    IN OUT RPC_PROTSEQ_VECTOR PAPI * PAPI * ProtseqVector
    )
/*++

Routine Description:

    The protocol sequence vector obtained by calling RpcNetworkInqProtseqs
    is freed using this routine.  Each of the protocol sequences (they
    are represented as strings) and the vector itself are all freed.

Arguments:

    ProtseqVector - Supplies the rpc protocol sequence vector to be freed,
        and returns zero in place of the pointer to the vector.

Return Value:

    RPC_S_OK - This routine always completes successfully.

--*/
{
    unsigned int Index, Count;

    InitializeIfNecessary();

    if ( *ProtseqVector == 0 )
        {
        return(RPC_S_OK);
        }

    for (Index = 0, Count = (*ProtseqVector)->Count; Index < Count; Index++)
        {
        delete((*ProtseqVector)->Protseq[Index]);
        }

    delete(*ProtseqVector);
    *ProtseqVector = 0;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerInqBindings (
    OUT RPC_BINDING_VECTOR PAPI * PAPI * BindingVector
    )
/*++

Routine Description:

    A server application will call this routine to obtain a vector of
    binding handles.  Each protocol sequence registered with the rpc
    server will be used to create one binding handle.

Arguments:

    BindingVector - Returns the vector of binding handles.

Return Value:

    RPC_S_OK - At least one rpc protocol sequence has been registered
        with the rpc server, and the operation completed successfully.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_NO_BINDINGS - No rpc protocol sequences have been successfully
        registered with the rpc server.

--*/
{
    InitializeIfNecessary();
    *BindingVector = 0L;

    return(GlobalRpcServer->InquireBindings(BindingVector));
}


RPC_STATUS RPC_ENTRY
RpcServerInqIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid, OPTIONAL
    OUT RPC_MGR_EPV PAPI * PAPI * MgrEpv
    )
/*++

Routine Description:

    A server application will call this routine to obtain the manager
    entry point vector for a given interface and a given type uuid.

Arguments:

    IfSpec - Supplies a description of the interface.

    MgrTypeUuid - Optionally supplies the type uuid of the manager
        entry point vector we want returned.  If no manager type uuid
        is specified, then the null uuid is assumed.

    MgrEpv - Returns the manager entry point vector.

Return Value:

    RPC_S_OK - The manager entry point vector has successfully been
        returned.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->InquireManagerEpv(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv));
}


RPC_STATUS RPC_ENTRY
RpcServerListen (
    IN unsigned int MinimumCallThreads,
    IN unsigned int MaxCalls,
    IN unsigned int DontWait
    )
/*++

Routine Description:

    This routine gets called to start the rpc server listening for remote
    procedure calls.  We do not return until RpcMgmtStopServerListening
    is called and all active remote procedure calls complete, or a fatal
    error occurs in the runtime.

Arguments:

    MinimumCallThreads - Supplies the minimum number of threads which
        should be around to service remote procedure calls.  A higher
        value for this number will give more responsive service at the
        cost of more threads.

    MaxCalls - Supplies the maximum number of concurrent calls the rpc
        server is willing to accept.  This number must be greater than
        or equal to the largest MaxCalls value specified to the
        RpcServerUse* routines.

    DontWait - Supplies a flag indicating whether or not to wait until
        RpcMgmtStopServerListening has been called and all calls have
        completed.  A non-zero value indicates not to wait.

Return Value:

    RPC_S_OK - Everything worked as expected.  All active remote procedure
        calls have completed.  It is now safe to exit this process.

    RPC_S_ALREADY_LISTENING - Another thread has already called
        RpcServerListen and has not yet returned.

    RPC_S_NO_PROTSEQS_REGISTERED - No protocol sequences have been
        registered with the rpc server.  As a consequence it is
        impossible for the rpc server to receive any remote procedure
        calls, hence, the error code.

    RPC_S_MAX_CALLS_TOO_SMALL - The supplied value for MaxCalls is smaller
        than the the supplied value for MinimumCallThreads, or the zero
        was supplied for MaxCalls.

--*/
{
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(GlobalRpcServer->ServerListen(MinimumCallThreads, MaxCalls,
                    DontWait));
}


RPC_STATUS RPC_ENTRY
RpcServerRegisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid OPTIONAL,
    IN RPC_MGR_EPV PAPI * MgrEpv OPTIONAL
    )
/*++

Routine Description:

    This routine is used by server application to register a manager
    entry point vector and optionally an interface.  If the interface
    has not been registered, then it will be registered.  If it has
    already been registered, the manager entry point vector will be
    added to it under the specified type uuid.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid for the specified
        manager entry point vector.  If no type uuid is supplied, then
        the null uuid will be used as the type uuid.

    MgrEpv - Optionally supplies a manager entry point vector corresponding
        to the type uuid.  If a manager entry point vector is not supplied,
        then the manager entry point vector in the interface will be
        used.

Return Value:

    RPC_S_OK - The specified rpc interface has been successfully
        registered with the rpc server.  It is now ready to accept
        remote procedure calls.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to register
        the rpc interface with the rpc server.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the supplied rpc interface and
        manager type UUID.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->RegisterInterface(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv, 0,
                    MAX_IF_CALLS, gMaxRpcSize, 0));
}


RPC_STATUS RPC_ENTRY
RpcServerRegisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid,
    IN RPC_MGR_EPV PAPI * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
/*++

Routine Description:

    This routine is used by server application to register a manager
    entry point vector and  an interface.  If the interface
    has not been registered, then it will be registered.  If it has
    already been registered, the manager entry point vector will be
    added to it under the specified type uuid. If the IF_AUTOLISTEN flag
    has been specified, then the registered interface will be treated as an
    auto-listen interface.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid for the specified
        manager entry point vector.  If no type uuid is supplied, then
        the null uuid will be used as the type uuid.

    MgrEpv - Optionally supplies a manager entry point vector corresponding
        to the type uuid.  If a manager entry point vector is not supplied,
        then the manager entry point vector in the interface will be
        used.

    Flags -
        RPC_IF_OLE - the interface is an OLE interface. Calls need to be dispatched
                      to procnum 0
        RPC_IF_AUTOLISTEN - the interface is an auto-listen inteface, calls may be
                      dispatched on this inteface as soon as it is registered.

    MaxCalls -
        Maximum number of calls that can be simulaneously dispatched on this interface

Return Value:

    RPC_S_OK - The specified rpc interface has been successfully
        registered with the rpc server.  It is now ready to accept
        remote procedure calls.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to register
        the rpc interface with the rpc server.

    RPC_S_TYPE_ALREADY_REGISTERED - A manager entry point vector has
        already been registered for the supplied rpc interface and
        manager type UUID.

--*/
{
    InitializeIfNecessary();

    if (Flags & RPC_IF_OLE)
        {
        Flags |= RPC_IF_AUTOLISTEN ;
        }

    return(GlobalRpcServer->RegisterInterface(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv, Flags,
                    MaxCalls, gMaxRpcSize, IfCallbackFn));
}


RPC_STATUS RPC_ENTRY
RpcServerRegisterIf2 (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid,
    IN RPC_MGR_EPV PAPI * MgrEpv,
    IN unsigned int Flags,
    IN unsigned int MaxCalls,
    IN unsigned int MaxRpcSize,
    IN RPC_IF_CALLBACK_FN PAPI *IfCallbackFn
    )
{
    InitializeIfNecessary();

    if (Flags & RPC_IF_OLE)
        {
        Flags |= RPC_IF_AUTOLISTEN ;
        }

    return(GlobalRpcServer->RegisterInterface(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, MgrEpv, Flags,
                    MaxCalls, MaxRpcSize, IfCallbackFn));
}


RPC_STATUS RPC_ENTRY
RpcServerUnregisterIf (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid, OPTIONAL
    IN unsigned int WaitForCallsToComplete
    )
/*++

Routine Description:

    A server application will use this routine to unregister an interface
    with the rpc server.  Depending on what is specified for the manager
    type uuid one or all of the manager entry point vectors will be removed
    from the interface.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid of the manager entry
        point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    WaitForCallsToComplete - Supplies a flag indicating whether or not
        this routine should wait for all calls to complete using the
        interface and manager being unregistered.  A non-zero value
        indicates to wait.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the specified interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->UnregisterIf(
                    (RPC_SERVER_INTERFACE PAPI *) IfSpec,
                    (RPC_UUID PAPI *) MgrTypeUuid, WaitForCallsToComplete));
}

RPC_STATUS RPC_ENTRY
RpcServerUnregisterIfEx (
    IN RPC_IF_HANDLE IfSpec,
    IN UUID PAPI * MgrTypeUuid, OPTIONAL
    IN int RundownContextHandles
    )
/*++

Routine Description:

    Does the same as RpcServerUnregisterIf and in addition to that
    will cleanup all context handles registered by this interface
    provided that the interface is using strict_context_handles. If
    the interface does not use strict context handles, this API will
    return ERROR_INVALID_HANDLE, but the interface will be
    unregistered. Unlike RpcServerUnregisterIf, this API requires the
    IfSpec argument.

Arguments:

    IfSpec - Supplies a description of the interface.  This is actually
        a pointer to an opaque data structure which the runtime knows
        how to interpret.

    MgrTypeUuid - Optionally supplies the type uuid of the manager entry
        point vector to be removed.  If this argument is not supplied,
        then all manager entry point vectors for this interface will
        be removed.

    RundownContextHandles - if TRUE, the context handles belonging to
        this interface will be rundown. If FALSE, only the runtime
        portion of the context handle will be cleaned up, and the
        server portion of the context handle will be left alone.

Return Value:

    RPC_S_OK - The manager entry point vector(s) are(were) successfully
        removed from the specified interface.

    RPC_S_UNKNOWN_MGR_TYPE - The specified type uuid is not registered
        with the interface.

    RPC_S_UNKNOWN_IF - The specified interface is not registered with
        the rpc server.

--*/
{
    RPC_STATUS RpcStatus;
    DestroyContextHandleCallbackContext CallbackContext;

    InitializeIfNecessary();

    if (!ARGUMENT_PRESENT(IfSpec))
        return ERROR_INVALID_PARAMETER;

    RpcStatus = RpcServerUnregisterIf(IfSpec,
        MgrTypeUuid,
        TRUE    // WaitForCallsToComplete
        );

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    CallbackContext.RpcInterfaceInformation = (RPC_SERVER_INTERFACE *) IfSpec;
    CallbackContext.RundownContextHandles = RundownContextHandles;
    RpcStatus = GlobalRpcServer->EnumerateAndCallEachAddress(
        RPC_SERVER::actDestroyContextHandle,
        &CallbackContext);

    return RpcStatus;
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsEx (
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    A server application will use this routine to add all rpc protocol
    sequences supported by the current operating environment to the
    rpc server.  An endpoint will be dynamically selected for each rpc
    protocol sequence.  We will inquire the supported rpc protocol
    sequences, and then let the RPC_SERVER class take care of adding
    each one for us.

Arguments:

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - All supported rpc protocol sequences have been added to
        the rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add all of
        the supported rpc protocol sequences to the rpc server.

    RPC_S_NO_PROTSEQS - The current system configuration does not
        support any rpc protocol sequences.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    RPC_PROTSEQ_VECTOR * RpcProtseqVector;
    RPC_STATUS Status;
    unsigned int Index, ValidProtocolSequences = 0;
    THREAD *Thread;

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    Status = RpcConfigInquireProtocolSequences(TRUE, &RpcProtseqVector);
    if (Status != RPC_S_OK)
        {
        return(Status);
        }

    Policy->EndpointFlags |= RPC_C_DONT_FAIL;

    for (Index = 0; Index < RpcProtseqVector->Count; Index++)
        {
        //
        // Don't include nb protocols, ncadg_mq and ncacn_http
        // in RpcServerUseAllProtseqs().
        //
        if ( (RpcpStringNCompare(RPC_CONST_STRING("ncacn_nb_"),
                                 RpcProtseqVector->Protseq[Index],
                                 9) == 0)
           ||(RpcpStringNCompare(RPC_CONST_STRING("ncadg_mq"),
                                 RpcProtseqVector->Protseq[Index],
                                 8) == 0)
#if !defined(APPLETALK_ON)
           ||(RpcpStringNCompare(RPC_CONST_STRING("ncacn_at_dsp"),
                                 RpcProtseqVector->Protseq[Index],
                                 12) == 0)
#endif
           ||(RpcpStringNCompare(RPC_CONST_STRING("ncacn_http"),
                                 RpcProtseqVector->Protseq[Index],
                                 10) == 0) )
            {
            continue;
            }

        Status = GlobalRpcServer->UseRpcProtocolSequence(NULL,
                RpcProtseqVector->Protseq[Index], MaxCalls, 0,
                SecurityDescriptor, Policy->EndpointFlags, Policy->NICFlags);
        if ( Status == RPC_S_OK )
            {
            ValidProtocolSequences += 1;
            }
        else if (   ( Status == RPC_S_OUT_OF_MEMORY )
                 || ( Status == RPC_S_INVALID_SECURITY_DESC )
                 || ( Status == RPC_S_OUT_OF_RESOURCES ) )
            {
            RpcProtseqVectorFree(&RpcProtseqVector);
            return(Status);
            }
        }

    RpcProtseqVectorFree(&RpcProtseqVector);

    if ( ValidProtocolSequences == 0 )
        {
        return(Status);
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqs (
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseAllProtseqsEx (MaxCalls, SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsIfEx (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    A server application will use this routine to add all protocol
    sequences and endpoints specified in the header of an IDL file.
    This information (from the IDL file) is specified by the interface
    specification argument.

Arguments:

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    IfSpec - Supplies the interface specification from which we
        should extract the rpc protocol sequence and end point
        information to be used.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - All of the support rpc protocol sequences (and their
        associated endpoints) have been added to the rpc server.

    RPC_S_NO_PROTSEQS - None of the specified rpc protocol sequences
        are supported by the rpc server, or no rpc protocol sequences
        were specified.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_DUPLICATE_ENDPOINT - One of the supplied endpoints has already
        been added to this rpc server.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    RPC_SERVER_INTERFACE PAPI * RpcServerInfo;
    unsigned int SupportedProtseqCount = 0;
    unsigned int Index;
    RPC_STATUS Status;

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    RpcServerInfo = (RPC_SERVER_INTERFACE PAPI *) IfSpec;

    if (RpcServerInfo->RpcProtseqEndpointCount == 0)
        {
        return(RPC_S_NO_PROTSEQS);
        }

    Policy->EndpointFlags |= RPC_C_DONT_FAIL;

    for (Index = 0; Index < RpcServerInfo->RpcProtseqEndpointCount;
            Index++)
        {
        Status = RpcServerUseProtseqEpExA(
                RpcServerInfo->RpcProtseqEndpoint[Index].RpcProtocolSequence,
                MaxCalls, RpcServerInfo->RpcProtseqEndpoint[Index].Endpoint,
                SecurityDescriptor, Policy);
        if ( Status == RPC_S_OK )
            {
            SupportedProtseqCount += 1;
            }
        else if (   ( Status == RPC_S_OUT_OF_MEMORY )
                 || ( Status == RPC_S_INVALID_SECURITY_DESC )
                 || ( Status == RPC_S_OUT_OF_RESOURCES ) )
            {
            return(Status);
            }
        }

    if ( SupportedProtseqCount == 0 )
        {
        if ( Status == RPC_S_PROTSEQ_NOT_SUPPORTED )
            {
            return(RPC_S_NO_PROTSEQS);
            }
        return(Status);
        }

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerUseAllProtseqsIf (
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseAllProtseqsIfEx ( MaxCalls, IfSpec, SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
I_RpcServerUseProtseq2 (
    IN unsigned short PAPI *NetworkAddress,
    IN unsigned short PAPI *Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI *SecurityDescriptor,
    IN void *pPolicy
    )
{
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    return(GlobalRpcServer->UseRpcProtocolSequence(NetworkAddress, Protseq, MaxCalls, 0,
                    SecurityDescriptor, Policy->EndpointFlags, Policy->NICFlags));
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEx (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This routine is used by a server application to add an rpc protocol
    sequence to the rpc server.  An endpoint will be dynamically selected
    for this rpc protocol sequence.  What we do is to let the RPC_SERVER
    class take care of most of the work.

Arguments:

    Protseq - Supplies the rpc protocol sequence we wish to add.  An
        rpc protocol sequence contains two pieces of information we
        are interested in: the rpc protocol (connection, datagram, or
        shared memory) and the transport interface requested.

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence has been added to
        the rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    return I_RpcServerUseProtseq2(NULL, Protseq, MaxCalls, SecurityDescriptor, Policy);
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseq (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN void PAPI * SecurityDescriptor OPTIONAL
    )
{
    RPC_POLICY Policy ;
    THREAD *Thread;

    InitializeIfNecessary();

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    return RpcServerUseProtseqEx(Protseq, MaxCalls, SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
I_RpcServerUseProtseqEp2 (
    IN unsigned short PAPI * NetworkAddress,
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_CHAR PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN void *pPolicy
    )
{
    PRPC_POLICY Policy = (PRPC_POLICY) pPolicy;

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }

    return(GlobalRpcServer->UseRpcProtocolSequence(NetworkAddress, Protseq, MaxCalls,
                    Endpoint, SecurityDescriptor,
                    Policy->EndpointFlags, Policy->NICFlags));
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEpEx (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN unsigned short PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    This routine is used by a server application to add an rpc protocol
    sequence and an endpoint to the rpc server.  What we do is to let
    the RPC_SERVER class take care of most of the work.

Arguments:

    Protseq - Supplies the rpc protocol sequence we wish to add.  An
        rpc protocol sequence contains two pieces of information we
        are interested in: the rpc protocol (connection, datagram, or
        shared memory) and the transport interface requested.

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    Endpoint - Supplies the endpoint to use for this rpc protocol
        sequence.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence has been added to
        the rpc server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The specified rpc protocol sequence
        is not supported (but it appears to be valid).

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_INVALID_ENDPOINT_FORMAT -

    RPC_S_DUPLICATE_ENDPOINT - The supplied endpoint has already been
        added to this rpc server.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    return I_RpcServerUseProtseqEp2 (NULL, Protseq, MaxCalls, Endpoint,
                                     SecurityDescriptor, (void *) Policy);
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqEp (
    IN RPC_CHAR PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_CHAR PAPI * Endpoint,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseProtseqEpEx(Protseq, MaxCalls, Endpoint,
                SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIfEx (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor,
    IN PRPC_POLICY Policy
    )
/*++

Routine Description:

    A server application will use this routine to one of the protocol
    sequences (and its associated endpoint) specified in the header of
    an IDL file.  This information (from the IDL file) is specified by
    the interface specification argument.

Arguments:

    Protseq - Supplies the rpc protocol sequence to be added to
        the rpc server.  The list of rpc protocol sequence -- endpoint
        pairs in the interface specification will be searched to find
        the corresponding endpoint.

    MaxCalls - Supplies a lower bound for the number of concurrent
        remote procedure calls the server must be able to handle.

    IfSpec - Supplies the interface specification from which we
        should extract the rpc protocol sequence and end point
        information to be used.

    SecurityDescriptor - Optionally supplies a security descriptor to
        place on the rpc protocol sequence (address) we are adding to
        the rpc server.

Return Value:

    RPC_S_OK - The requested rpc protocol sequence (and its associated
        endpoint) has been added to the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The supplied rpc protocol sequence
        is not supported by the rpc server.

    RPC_S_PROTSEQ_NOT_SUPPORTED - The supplied rpc protocol sequence is not
        in the list of rpc protocol sequences in the interface specification.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to add the
        requested rpc protocol sequence to the rpc server.

    RPC_S_INVALID_RPC_PROTSEQ - The specified rpc protocol sequence is
        syntactically invalid.

    RPC_S_INVALID_SECURITY_DESC - The supplied security descriptor is
        invalid.

--*/
{
    RPC_SERVER_INTERFACE PAPI * RpcServerInfo;
    unsigned int Index, EndpointsRegistered = 0;
    RPC_STATUS RpcStatus;
#ifdef UNICODE
    UNICODE_STRING UnicodeString;
#endif // UNICODE

    InitializeIfNecessary();

    if (Policy->Length < sizeof(RPC_POLICY))
        {
        return RPC_S_INVALID_BOUND ;
        }


    RpcServerInfo = (RPC_SERVER_INTERFACE PAPI *) IfSpec;

    for (Index = 0; Index < RpcServerInfo->RpcProtseqEndpointCount;
            Index++)
        {
#ifdef UNICODE
        RpcStatus = AnsiToUnicodeString(
                RpcServerInfo->RpcProtseqEndpoint[Index].RpcProtocolSequence,
                &UnicodeString);
        if (RpcStatus != RPC_S_OK)
            return(RpcStatus);
        if ( RpcpStringCompare(Protseq, UnicodeString.Buffer) == 0 )
#else // UNICODE
        if ( RpcpStringCompare(Protseq,
                RpcServerInfo->RpcProtseqEndpoint[Index].RpcProtocolSequence)
                == 0 )
#endif // UNICODE
            {
#ifdef UNICODE
            RtlFreeUnicodeString(&UnicodeString);
#endif
            RpcStatus = RpcServerUseProtseqEpExA(
                    RpcServerInfo->RpcProtseqEndpoint[ Index].RpcProtocolSequence,
                    MaxCalls, RpcServerInfo->RpcProtseqEndpoint[Index].Endpoint,
                    SecurityDescriptor, Policy);
            if ( RpcStatus != RPC_S_OK )
                {
                return(RpcStatus);
                }
            EndpointsRegistered += 1;
            }
#ifdef UNICODE
        else
            {
            RtlFreeUnicodeString(&UnicodeString);
            }
#endif // UNICODE
        }

    if ( EndpointsRegistered == 0 )
        {
        return(RPC_S_PROTSEQ_NOT_SUPPORTED);
        }
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcServerUseProtseqIf (
    IN unsigned short PAPI * Protseq,
    IN unsigned int MaxCalls,
    IN RPC_IF_HANDLE IfSpec,
    IN void PAPI * SecurityDescriptor
    )
{
    RPC_POLICY Policy ;

    Policy.Length = sizeof(RPC_POLICY) ;
    Policy.EndpointFlags = 0;
    Policy.NICFlags = 0;

    return RpcServerUseProtseqIfEx (Protseq, MaxCalls, IfSpec,
                SecurityDescriptor, &Policy) ;
}


RPC_STATUS RPC_ENTRY
RpcMgmtStatsVectorFree (
    IN OUT RPC_STATS_VECTOR ** StatsVector
    )
/*++

Routine Description:

    This routine is used to free the statistics vector obtained from
    RpcMgmtInqStats.

Arguments:

    StatsVector - Supplies the statistics vector to be freed; on return,
        the pointer this pointer points to will be set to zero.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_INVALID_ARG - The specified statistics vectors does not contain
        the address of a statistics vector.

--*/
{
    InitializeIfNecessary();

    if (StatsVector == 0)
        return(RPC_S_INVALID_ARG);

    RpcpFarFree(*StatsVector);
    *StatsVector = 0;
    return(RPC_S_OK);
}



#define MAX_STATISTICS 4

RPC_STATUS RPC_ENTRY
RpcMgmtInqStats (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_STATS_VECTOR ** Statistics
    )
/*++

Routine Description:

    This routine is used to inquire statistics about the server.  In
    particular, the statistics consist of the number of remote procedure
    calls received by this server, the number of remote procedure calls
    initiated by this server (callbacks), the number of network packets
    received, and the number of network packets sent.

Arguments:

    Binding -  Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local application is queried.

    Statistics - Returns the statistics vector for this server.

Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the
        statistics for this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

--*/
{
    unsigned long Status = 0;
    unsigned long Count = MAX_STATISTICS;
    unsigned long StatsVector[MAX_STATISTICS];

    InitializeIfNecessary();

    if (Binding == 0)
        {
        *Statistics = (RPC_STATS_VECTOR *) RpcpFarAllocate(sizeof(RPC_STATS_VECTOR)
                      + 3 * sizeof(unsigned long));
        if (*Statistics == 0)
            return(RPC_S_OUT_OF_MEMORY);

        (*Statistics)->Count = 4;
        GlobalRpcServer->InquireStatistics(*Statistics);

        return(RPC_S_OK);
        }

    _rpc_mgmt_inq_stats(Binding, &Count, StatsVector, &Status);

    if ( Status == RPC_S_OK )
        {
        *Statistics = (RPC_STATS_VECTOR __RPC_FAR *) RpcpFarAllocate(
                sizeof(RPC_STATS_VECTOR) + sizeof(unsigned long)
                * (MAX_STATISTICS - 1));
        if ( *Statistics == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        for ((*Statistics)->Count = 0; (*Statistics)->Count < Count
                    && (*Statistics)->Count < MAX_STATISTICS;
                    (*Statistics)->Count++)
            {
            (*Statistics)->Stats[(*Statistics)->Count] =
                    StatsVector[(*Statistics)->Count];
            }
        }

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcMgmtIsServerListening (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    An application will use this routine to determine whether or not
    the server is listening.

Arguments:

    Binding - Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local application is queried.

Return Value:

    RPC_S_OK - The server is listening.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

    RPC_S_NOT_LISTENING - The server is not listening.

--*/
{
    unsigned long Result;
    unsigned long Status = 0;

    InitializeIfNecessary();

    if (Binding == 0)
        {
        if (GlobalRpcServer->IsServerListening() == 0)
            return(RPC_S_NOT_LISTENING);
        return(RPC_S_OK);
        }

    Result = _rpc_mgmt_is_server_listening(Binding, &Status);

    if (Status == RPC_S_OK)
        {
        return((Result == 1) ? RPC_S_OK : RPC_S_NOT_LISTENING);
        }
     if ( (Status == RPC_S_SERVER_UNAVAILABLE)
        || (Status == RPC_S_SERVER_TOO_BUSY) )
        {
        return (RPC_S_NOT_LISTENING);
        }

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcMgmtStopServerListening (
    IN RPC_BINDING_HANDLE Binding
    )
/*++

Routine Description:

    This routine is used by an application to stop the rpc server from
    accepting any more remote procedure calls.  Currently active remote
    procedure calls are allowed to complete.

Arguments:

    Binding - Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local server is stopped.

Return Value:

    RPC_S_OK - The server has been successfully notified that it should
        stop listening for remote procedure calls.  No new remote procedure
        calls will be accepted after this routine returns.  RpcServerListen
        will return after all active calls have completed.

    RPC_S_NOT_LISTENING - A thread has not called RpcServerListen (and
        not returned) yet.

--*/
{
    RPC_STATUS Status;

    InitializeIfNecessary();

    if (Binding == 0)
        {
        return(GlobalRpcServer->StopServerListening());
        }

    _rpc_mgmt_stop_server_listening(Binding, (unsigned long *)&Status);

    return(Status);

}


RPC_STATUS RPC_ENTRY
RpcMgmtWaitServerListen (
    void
    )
/*++

Routine Description:

    This routine performs the wait that RpcServerListen normally performs
    when the DontWait flag is not set.  An application must call this
    routine only after RpcServerListen has been called with the DontWait
    flag set.  We do not return until RpcMgmtStopServerListening is called
    and all active remote procedure calls complete, or a fatal error occurs
    in the runtime.

Return Value:

    RPC_S_OK - Everything worked as expected.  All active remote procedure
        calls have completed.  It is now safe to exit this process.

    RPC_S_ALREADY_LISTENING - Another thread has already called
        RpcMgmtWaitServerListen and has not yet returned.

    RPC_S_NOT_LISTENING - RpcServerListen has not yet been called.

--*/
{
    InitializeIfNecessary();

    return(GlobalRpcServer->WaitServerListen());
}

RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpointA (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned char PAPI * PAPI * DynamicEndpoint
    )
{
#ifdef UNICODE
    return (RPC_S_CANNOT_SUPPORT);
#else
    USES_CONVERSION;
    CNlDelUnicodeAnsi thunkedDynamicEndpoint;
    RPC_STATUS RpcStatus;

    RpcStatus = I_RpcBindingInqDynamicEndpointW(Binding, thunkedDynamicEndpoint);
    if (RpcStatus == RPC_S_OK)
        {
        ATTEMPT_CONVERT_W2A_OPTIONAL(thunkedDynamicEndpoint, DynamicEndpoint);
        }
    return RpcStatus;
#endif
}


RPC_STATUS RPC_ENTRY
I_RpcBindingInqDynamicEndpointW (
    IN RPC_BINDING_HANDLE Binding,
    OUT unsigned short PAPI * PAPI * DynamicEndpoint
    )
/*++

Routine Description:

    This routine is used to inquire the dynamic endpoint from a binding
    handle.  The only binding handles which will have dynamic endpoints
    are those which are create from rpc addresses which have dynamic
    endpoints.  This routine will be used for one purpose and one purpose
    only: RpcEpRegister and RpcEpRegisterNoReplace need to know which
    binding handles have dynamic endpoints; only binding handles with
    dynamic endpoints get placed into the endpoint mapper database.

Arguments:

    Binding - Supplies the binding handle from which we wish to obtain
        the dynamic endpoint.

    DynamicEndpoint - Returns a pointer to a string containing the dynamic
        endpoint for this binding handle if it has one; otherwise, it
        will be zero.  If a string is return, it must be freed using
        RpcStringFree.

Return Value:

    RPC_S_OK - The operation completed successfully.  This does not
        indicate whether or not the binding handle has a dynamic endpoint.
        To determine that, you must check whether *DynamicEndpoint is
        equal to zero.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to duplicate
        the dynamic endpoint.

    RPC_S_INVALID_BINDING - The binding argument does not specify a binding
        handle.

--*/
{
    BINDING_HANDLE * BindingHandle;
#ifndef UNICODE
    USES_CONVERSION;
    COutDelThunk thunkedDynamicEndpoint;
    RPC_STATUS RpcStatus;
#endif

    InitializeIfNecessary();

    BindingHandle = (BINDING_HANDLE *) Binding;
    if (BindingHandle->InvalidHandle(BINDING_HANDLE_TYPE))
        return(RPC_S_INVALID_BINDING);

#ifdef UNICODE
    return (BindingHandle->InquireDynamicEndpoint(DynamicEndpoint));
#else
    RpcStatus = BindingHandle->InquireDynamicEndpoint(thunkedDynamicEndpoint);
    if (RpcStatus == RPC_S_OK)
        {
        ATTEMPT_OUT_THUNK_OPTIONAL(thunkedDynamicEndpoint, DynamicEndpoint);
        }
    return RpcStatus;
#endif

}


RPC_STATUS RPC_ENTRY
RpcServerRegisterAuthInfo (
    IN unsigned short PAPI * ServerPrincName,
    IN unsigned long AuthnSvc,
    IN RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn, OPTIONAL
    IN void PAPI * Arg OPTIONAL
    )
/*++

Routine Description:

    A server application will use this routine to indicate to the runtime
    what authentication service to use for authenticating remote procedure
    calls.  This routine should be called once for each pair of authentication
    service and principal name which the server wishes to use for
    authentication.  In order for an client to be able to talk with an
    authenticated server, the authentication service specified by the client
    must be one of the ones registered by the server.  Attempting to
    register the same authentication service and principal name will not
    result in an error.

Arguments:

    ServerPrincName - Supplies the principal name for the server.

    AuthnSvc - Supplies an authentication service to use when the server
        receives a remote procedure call.

    GetKeyFn - Optionally supplies a routine to be used when the runtime
        needs an encryption key.

    Arg - Optionally supplies an argument to be passed to the routine used
        to get keys each time it is called.

Return Value:

    RPC_S_OK - The authentication service and server principal name have
        been registered with the runtime.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

    RPC_S_UNKNOWN_AUTHN_SERVICE - The specified authentication service is
        not supported.

--*/
{
    THREAD *Thread;
    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(GlobalRpcServer->RegisterAuthInformation(ServerPrincName,
                    AuthnSvc, GetKeyFn, Arg));
}


RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClient (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT unsigned short PAPI * PAPI * PrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc OPTIONAL
    )
{
    return RpcBindingInqAuthClientEx( ClientBinding,
                                       Privs,
                                       PrincName,
                                       AuthnLevel,
                                       AuthnSvc,
                                       AuthzSvc,
                                       0
                                       );
}


RPC_STATUS RPC_ENTRY
RpcBindingInqAuthClientEx (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    OUT RPC_AUTHZ_HANDLE PAPI * Privs,
    OUT unsigned short PAPI * PAPI * ServerPrincName, OPTIONAL
    OUT unsigned long PAPI * AuthnLevel, OPTIONAL
    OUT unsigned long PAPI * AuthnSvc, OPTIONAL
    OUT unsigned long PAPI * AuthzSvc, OPTIONAL
    IN  unsigned long        Flags
    )
/*++

Routine Description:

    A server application will use this routine to obtain the authorization
    information about a client making an authenticated remote procedure
    call.

Arguments:

    ClientBinding - Optionally supplies a binding handle on the server
        side which indicates for which remote procedure call we wish to
        obtain authorization information.  If no binding handle is supplied,
        then it is taken to be the remote procedure call currently being
        handled by this server thread.

    Privs - Returns a handle to the privileges information for the client
        thread which made the remote procedure call.

    ServerPrincName - Optionally returns the server principal name specified
        by the client application.

    AuthnLevel - Optionally returns the authentication level requested
        by the client application.

    AuthnSvc - Optionally returns the authentication service requested by
        the client application.

    AuthzSvc - Optionally returns the authorization service requested by
        the client application.

Return Value:

    RPC_S_OK - We successfully obtained the requested authentication and
        authorization information.

    RPC_S_INVALID_BINDING - The supplied binding handle (as the binding
        argument) is not a valid binding handle.

    RPC_S_WRONG_KIND_OF_BINDING - The binding handle is not a binding handle
        on the server side.

    RPC_S_BINDING_HAS_NO_AUTH - The remote procedure call is not
        authenticated.

    RPC_S_NO_CALL_ACTIVE - No binding handle was supplied and there is no
        call active for this server thread.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete the
        operation.

--*/
{
    SCALL * SCall;

    InitializeIfNecessary();

    if (ARGUMENT_PRESENT(ClientBinding))
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            {
            return(RPC_S_INVALID_BINDING);
            }
        }
    else
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    return SCall->InquireAuthClient(Privs,
                    ServerPrincName,
                    AuthnLevel,
                    AuthnSvc,
                    AuthzSvc,
                    Flags
                    );
}

RPCRTAPI
RPC_STATUS
RPC_ENTRY
RpcServerInqCallAttributesW (
    IN RPC_BINDING_HANDLE ClientBinding, OPTIONAL
    IN OUT void *RpcCallAttributes
    )
/*++

Routine Description:

    A server application will use this routine to obtain the security context
    attributes for the calling client.

Arguments:

    ClientBinding - Optionally supplies a binding handle on the server
        side which indicates for which remote procedure call we wish to
        obtain authorization information.  If no binding handle is supplied,
        then it is taken to be the remote procedure call currently being
        handled by this server thread.

    RpcCallAttributes - a pointer to 
        RPC_CALL_ATTRIBUTES_V1_W structure. The Version
        member must be initialized.

Return Value:

    RPC_S_OK for success of RPC_S_* /Win32 error code for error. EEInfo is
        supplied. If the function fails, the contents of 
        RpcCallAttributes is undefined.
--*/
{
    SCALL * SCall;
    RPC_CALL_ATTRIBUTES_V1 *CallAttributes;

    CallAttributes = 
        (RPC_CALL_ATTRIBUTES_V1 *)RpcCallAttributes;

    if (CallAttributes->Version != 1)
        return ERROR_INVALID_PARAMETER;

    if (CallAttributes->Flags & RPC_QUERY_SERVER_PRINCIPAL_NAME)
        {
        if ((CallAttributes->ServerPrincipalName == NULL) &&
            (CallAttributes->ServerPrincipalNameBufferLength != 0))
            {
            return ERROR_INVALID_PARAMETER;
            }
        }

    if (CallAttributes->Flags & RPC_QUERY_CLIENT_PRINCIPAL_NAME)
        {
        if ((CallAttributes->ClientPrincipalName == NULL) &&
            (CallAttributes->ClientPrincipalNameBufferLength != 0))
            {
            return ERROR_INVALID_PARAMETER;
            }
        }

    InitializeIfNecessary();

    if (ARGUMENT_PRESENT(ClientBinding))
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            {
            return(RPC_S_INVALID_BINDING);
            }
        }
    else
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    return SCall->InquireCallAttributes(CallAttributes);
}

RPC_STATUS RPC_ENTRY
RpcImpersonateClient (
    IN RPC_BINDING_HANDLE ClientBinding OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Values:

--*/
{
    SCALL * SCall;
    THREAD *Thread;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if ( ClientBinding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if (SCall == 0)
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);
        }

    return(SCall->ImpersonateClient());
}

// the handle to the authz.dll. Protected by the global mutex. Once initialized,
// never uninitialized
HMODULE AuthzDllHandle = NULL;

// pointer to the AuthzInitializeContextFromToken function from authz.dll. Once
// initialized, never uninitialized
AuthzInitializeContextFromTokenFnType AuthzInitializeContextFromTokenFn = NULL;

// pointer to the AuthzInitializeContextFromSid function from authz.dll. Once 
// initialized, never uninitialized
AuthzInitializeContextFromSidFnType AuthzInitializeContextFromSidFn = NULL;

// pointer to the AuthzInitializeContextFromContext function from authz.dll. Once 
// initialized, never uninitialized
AuthzInitializeContextFromAuthzContextFnType AuthzInitializeContextFromAuthzContextFn = NULL;

// pointer to the AuthzInitializeContextFromToken function from authz.dll. Once
// initialized, never uninitialized
AuthzFreeContextFnType AuthzFreeContextFn = NULL;

// the dummy resource manager with NULL callbacks for everything. Protected
// by the global mutex. Once initialized, never uninitialized
AUTHZ_RESOURCE_MANAGER_HANDLE DummyResourceManager = NULL;

typedef struct tagProcLoadArgs
{
    char *ProcName;
    PVOID *ProcRoutine;
} ProcLoadArgs;

const ProcLoadArgs AuthzProcs[4] = {
    {"AuthzInitializeContextFromToken", (PVOID *)&AuthzInitializeContextFromTokenFn},
    {"AuthzInitializeContextFromAuthzContext", (PVOID *)&AuthzInitializeContextFromAuthzContextFn},
    {"AuthzInitializeContextFromSid", (PVOID *)&AuthzInitializeContextFromSidFn},
    {"AuthzFreeContext", (PVOID *) &AuthzFreeContextFn}
    };

RPC_STATUS
InitializeAuthzSupportIfNecessary (
    void
    )
/*++

Routine Description:
    Perform initialization required for Authz functions to work. Everybody
    should call that before they use any Authz functionality.

Arguments:

Return Values:
    RPC_S_OK for success and RPC_S_* for the rest

--*/
{
    RPC_STATUS Status;
    int i;

    if (AuthzDllHandle)
        return RPC_S_OK;

    GlobalMutexRequest();

    if (AuthzDllHandle)
        {
        GlobalMutexClear();
        return RPC_S_OK;
        }

    AuthzDllHandle = LoadLibrary(L"Authz.dll");
    if (AuthzDllHandle)
        {
        Status = RPC_S_OK;
        for (i = 0; i < (sizeof(AuthzProcs) / sizeof(AuthzProcs[0])); i ++)
            {
            *(AuthzProcs[i].ProcRoutine) = GetProcAddress(AuthzDllHandle,
                AuthzProcs[i].ProcName);

            if (*(AuthzProcs[i].ProcRoutine) == NULL)
                {
                Status = GetLastError();
                RpcpErrorAddRecord(EEInfoGCRuntime,
                    Status,
                    EEInfoDLInitializeAuthzSupportIfNecessary20,
                    AuthzProcs[i].ProcName);
                FreeLibrary(AuthzDllHandle);
                AuthzDllHandle = NULL;
                break;
                }
            }
        }
    else
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCRuntime,
            Status,
            EEInfoDLInitializeAuthzSupportIfNecessary10,
            L"Authz.dll");
        }

    GlobalMutexClear();

    return Status;
}

typedef AUTHZAPI
BOOL
(WINAPI *AuthzInitializeResourceManagerFnType) (
    IN DWORD AuthzFlags,
    IN PFN_AUTHZ_DYNAMIC_ACCESS_CHECK pfnAccessCheck OPTIONAL,
    IN PFN_AUTHZ_COMPUTE_DYNAMIC_GROUPS pfnComputeDynamicGroups OPTIONAL,
    IN PFN_AUTHZ_FREE_DYNAMIC_GROUPS pfnFreeDynamicGroups OPTIONAL,
    IN PCWSTR szResourceManagerName,
    OUT PAUTHZ_RESOURCE_MANAGER_HANDLE pAuthzResourceManager
    );

RPC_STATUS
CreateDummyResourceManagerIfNecessary (
    void
    )
/*++

Routine Description:
    Perform initialization of the dummy resource manager. Any function that
    uses the dummy resource manager must call this function beforehand.
    This function must be called after InitializeAuthzSupportIfNecessary

Arguments:

Return Values:
    RPC_S_OK for success and RPC_S_* for the rest

--*/
{
    AuthzInitializeResourceManagerFnType AuthzInitializeResourceManagerFn;
    RPC_STATUS Status;
    BOOL Result;

    // this function must be called after InitializeAuthzSupportIfNecessary
    ASSERT(AuthzDllHandle);

    if (DummyResourceManager)
        return RPC_S_OK;

    GlobalMutexRequest();

    if (DummyResourceManager)
        {
        GlobalMutexClear();
        return RPC_S_OK;
        }

    AuthzInitializeResourceManagerFn
        = (AuthzInitializeResourceManagerFnType) GetProcAddress(AuthzDllHandle,
        "AuthzInitializeResourceManager");

    if (AuthzInitializeResourceManagerFn == NULL)
        {
        Status = GetLastError();
        RpcpErrorAddRecord(EEInfoGCRuntime,
            Status,
            EEInfoDLCreateDummyResourceManagerIfNecessary10,
            "AuthzInitializeResourceManager");
        }
    else
        {
        Result = AuthzInitializeResourceManagerFn(
            0,      // Flags
            NULL,   // pfnAccessCheck
            NULL,   // pfnComputeDynamicGroups
            NULL,   // pfnFreeDynamicGroups
            L"",    // Name
            &DummyResourceManager);

        if (Result == FALSE)
            {
            Status = GetLastError();
            RpcpErrorAddRecord(EEInfoGCAuthz,
                Status,
                EEInfoDLCreateDummyResourceManagerIfNecessary20);
            }
        else
            Status = RPC_S_OK;
        }

    GlobalMutexClear();

    return Status;
}

RPC_STATUS RPC_ENTRY
RpcGetAuthorizationContextForClient (
    IN RPC_BINDING_HANDLE ClientBinding OPTIONAL,
    IN BOOL ImpersonateOnReturn,
    IN PVOID Reserved1,
    IN PLARGE_INTEGER pExpirationTime OPTIONAL,
    IN LUID Reserved2,
    IN DWORD Reserved3,
    IN PVOID Reserved4,
    OUT PVOID *pAuthzClientContext
    )
/*++

Routine Description:
    Gets an authorization context for the client that can be used
    with Authz functions. The resulting context is owned by the caller
    and must be freed by it.

Arguments:
    ImpersonateOnReturn - if TRUE, when we return, we should be impersonating.
    If the function fails, we're not impersonating
    Reserved1 - the resource manager to use (passed to Authz). Must be
    NULL for now
    pExpirationTime - the expiration time to use (passed to Authz)
    Reserved2 - the LUID (passed to Authz). Must be 0 for now.
    Resevred3 - Flags (passed to Authz). Must be 0 for now.
    Reserved4 - DynamicGroupArgs parameter required by Authz (passed to Authz)
    pAuthzClientContext - the authorization context, returned on success.
    Undefined on failure.

Return Values:
    RPC_S_OK for success, ERROR_INVALID_PARAMETER for non-null values for
    the Reserved parameters and RPC_S_* / Win32 errors for the rest

--*/
{
    SCALL * SCall;
    THREAD *Thread;
    RPC_STATUS Status;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if ((Reserved1 != NULL)
        || (Reserved2.HighPart != 0)
        || (Reserved2.LowPart != 0)
        || (Reserved3 != 0)
        || (Reserved4 != NULL))
        {
        return ERROR_INVALID_PARAMETER;
        }

    Status = InitializeAuthzSupportIfNecessary();
    if (Status != RPC_S_OK)
        return Status;

    Status = CreateDummyResourceManagerIfNecessary();
    if (Status != RPC_S_OK)
        return Status;

    if ( ClientBinding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if (SCall == 0)
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);
        }

    return(SCall->GetAuthorizationContext(ImpersonateOnReturn,
        DummyResourceManager,
        pExpirationTime,
        Reserved2,
        Reserved3,
        Reserved4,
        (PAUTHZ_CLIENT_CONTEXT_HANDLE)pAuthzClientContext));
}

RPC_STATUS RPC_ENTRY
RpcFreeAuthorizationContext (
    IN OUT PVOID *pAuthzClientContext
    )
/*++

Routine Description:
    Frees an authorization context obtained through
    RpcGetAuthorizationContextForClient

Arguments:
    pAuthzClientContext - a pointer to the authorization context to
    be freed. The function will zero-out the freed authorization context
    to prevent accidental re-use in the success case. The authorization
    context won't be touched in case of failure.

Return Values:
    RPC_S_OK for success, Win32 errors for the rest

--*/
{
    BOOL Result;

    Result = AuthzFreeContextFn((AUTHZ_CLIENT_CONTEXT_HANDLE)(*pAuthzClientContext));
    if (Result == FALSE)
        {
        return GetLastError();
        }
    else
        {
        *pAuthzClientContext = NULL;
        return RPC_S_OK;
        }
}


RPC_STATUS RPC_ENTRY
RpcRevertToSelfEx (
    IN RPC_BINDING_HANDLE ClientBinding OPTIONAL
    )
/*++

Routine Description:

Return Value:

--*/
{
    SCALL * SCall ;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    if ( ClientBinding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) ClientBinding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);

        }

    return(SCall->RevertToSelf());
}


RPC_STATUS RPC_ENTRY
RpcRevertToSelf (
    )
/*++

Routine Description:

Return Value:

--*/
{

    return(RpcRevertToSelfEx((RPC_BINDING_HANDLE) 0));

}


RPC_STATUS RPC_ENTRY
RpcMgmtSetServerStackSize (
    IN unsigned long ThreadStackSize
    )
/*++

Routine Description:

    An application will use this routine to specify the stack size for
    each of the threads created by the server to handle remote procedure
    calls.

Arguments:

    ThreadStackSize - Supplies the thread stack size in bytes.

Return Value:

    RPC_S_OK - Everybody is happy with the stack size.

    RPC_S_INVALID_ARG - The stack size is either too small, or too large.

--*/
{
    InitializeIfNecessary();

    return(SetThreadStackSize(ThreadStackSize));
}


RPC_STATUS RPC_ENTRY
I_RpcBindingIsClientLocal (
    IN RPC_BINDING_HANDLE BindingHandle OPTIONAL,
    OUT unsigned int PAPI * ClientLocalFlag
    )
/*++

Routine Description:

    This routine exists for one reason: so that the security system can
    tell if a client is local or remote.  The client must be using named
    pipes to talk to the server.

Arguments:

    BindingHandle - Optionally supplies a client binding handle specifing
        which client we want to know if it is local or remote.  If this
        parameter is not supplied, then we will determine local/remote for
        the client which made call currently being handled by this server
        thread.

    ClientLocalFlag - Returns an indication of whether or not the client is
        local (ie. on the same machine as the server).  This field will be
        set to a non-zero value to indicate that the client is local;
        otherwise, the client is remote.

Return Value:

    RPC_S_OK - We successfully determined whether or not the client is
        local.

    RPC_S_NO_CALL_ACTIVE - There is no call active for this server thread.

    RPC_S_CANNOT_SUPPORT - Only the connection oriented protocol over named
        pipes can support this operation.  If the client is using something
        else, other than the connection oriented protocol, this will be
        returned.

    RPC_S_INVALID_BINDING - The binding argument does not supply a client
        binding handle.

--*/
{
    SCALL *SCall;

    InitializeIfNecessary();

    if ( BindingHandle == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }
    else
        {
        SCall = (SCALL *) BindingHandle;
        if ( SCall->InvalidHandle(SCALL_TYPE) )
            {
            return(RPC_S_INVALID_BINDING);
            }
        }

    return(SCall->IsClientLocal(ClientLocalFlag));
}


RPC_STATUS RPC_ENTRY
RpcMgmtInqIfIds (
    IN RPC_BINDING_HANDLE Binding,
    OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    )
/*++

Routine Description:

    This routine is used to obtain a vector of the interface identifiers of
    the interfaces supported by a server.

Arguments:

    Binding - Optionally supplies a binding handle to the server.  If this
        argument is not supplied, the local application is queried.

    IfIdVector - Returns a vector of the interfaces supported by the server.

Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the interfaces
        supported by this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

--*/
{
    RPC_STATUS Status;

    InitializeIfNecessary();

    if ( Binding == 0 )
        {
        return(GlobalRpcServer->InquireInterfaceIds(IfIdVector));
        }

    *IfIdVector = 0;
    _rpc_mgmt_inq_if_ids(Binding, (rpc_if_id_vector_p_t *) IfIdVector,
                        (unsigned long *) &Status);

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcIfIdVectorFree (
    IN OUT RPC_IF_ID_VECTOR __RPC_FAR * __RPC_FAR * IfIdVector
    )
/*++

Routine Description:

    This routine is used to free an interface id vector.

Arguments:

    IfIdVector - Supplies the interface id vector to be freed; on return
        this will be set to zero.

Return Value:

    RPC_S_OK - This will always be returned.

--*/
{
    unsigned int Count;

    InitializeIfNecessary();

    if (!*IfIdVector)
        {
        return(RPC_S_OK);
        }

    for (Count = 0; Count < (*IfIdVector)->Count; Count++)
        {
        if ( (*IfIdVector)->IfId[Count] != 0 )
            {
            RpcpFarFree((*IfIdVector)->IfId[Count]);
            }
        }
    RpcpFarFree(*IfIdVector);
    *IfIdVector = 0;
    return(RPC_S_OK);
}



// StringToUnicodeString lives in epmgmt.c
//
extern "C" RPC_CHAR *StringToWideCharString(unsigned char *, RPC_STATUS *);

#define SERVER_PRINC_NAME_SIZE 256

RPC_STATUS RPC_ENTRY
RpcMgmtInqServerPrincName (
    IN RPC_BINDING_HANDLE Binding,
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * ServerPrincName
    )
/*++

Routine Description:


Arguments:

    Binding - Supplies

    AuthnSvc - Supplies

    ServerPrincName - Returns


Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the interfaces
        supported by this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

    RPC_S_INVALID_BINDING - The supplied binding is not zero.

--*/
{
    RPC_STATUS Status;
    unsigned char *AnsiPrincName;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    if ( Binding == 0 )
        {
        return(GlobalRpcServer->InquirePrincipalName(AuthnSvc, ServerPrincName));
        }

    AnsiPrincName = new unsigned char[SERVER_PRINC_NAME_SIZE + 1];
    if (AnsiPrincName == 0)
        return(RPC_S_OUT_OF_MEMORY);

    _rpc_mgmt_inq_princ_name(Binding, AuthnSvc, SERVER_PRINC_NAME_SIZE,
                AnsiPrincName, (unsigned long *)&Status);

    *ServerPrincName = 0;

    if ( Status == RPC_S_OK )
        {

        Status = A2WAttachHelper((char *)AnsiPrincName, ServerPrincName);

        if (Status != RPC_S_OK)
            {
            delete AnsiPrincName;
            ASSERT(Status == RPC_S_OUT_OF_MEMORY);
            return(RPC_S_OUT_OF_MEMORY);
            }
        }

    delete AnsiPrincName;

    return(Status);
}


RPC_STATUS RPC_ENTRY
RpcServerInqDefaultPrincName (
    IN unsigned long AuthnSvc,
    OUT unsigned short __RPC_FAR * __RPC_FAR * PrincName
    )
/*++

Routine Description:


Arguments:

    PrincName - Returns


Return Value:

    RPC_S_OK - Everything worked just fine, and you now know the interfaces
        supported by this server.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete
        the operation.

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    SECURITY_CREDENTIALS *pCredentials;
    SEC_CHAR * DefaultPrincName = NULL;
    RPC_CHAR *CopyPrincName;

    InitializeIfNecessary();

    Status = FindServerCredentials(
                NULL,
                NULL,
                AuthnSvc,
                0,
                NULL,
                &pCredentials
                );

    if (Status != RPC_S_OK) {
        return (Status);
    }

    Status = pCredentials->InquireDefaultPrincName(&DefaultPrincName);
    if (Status != RPC_S_OK) {
        return (Status);
    }

    ASSERT(DefaultPrincName);

    CopyPrincName = DuplicateString((RPC_CHAR *)DefaultPrincName);
    if (CopyPrincName == 0)
        return(RPC_S_OUT_OF_MEMORY);

    *PrincName = CopyPrincName;

    return (RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
THUNK_FN(RpcServerInqDefaultPrincName) (
    IN unsigned long AuthnSvc,
    OUT THUNK_CHAR **PrincName
    )
{
    RPC_STATUS  RpcStatus;
        USES_CONVERSION;
        COutDelThunk thunkedPrincName;

    RpcStatus = RpcServerInqDefaultPrincName(AuthnSvc,
                                              thunkedPrincName);

    if (RpcStatus != RPC_S_OK)
                {
        return(RpcStatus);
                }

        ATTEMPT_OUT_THUNK(thunkedPrincName, PrincName);

    return (RpcStatus);
}


RPC_STATUS RPC_ENTRY
RpcBindingServerFromClient (
    IN RPC_BINDING_HANDLE ClientBinding,
    OUT RPC_BINDING_HANDLE __RPC_FAR * ServerBinding
    )
/*++

Routine Description:

    This routine is used by a server application to convert a client binding
    handle (server side binding handle) into a partially bound server binding
    handle (client side binding handle).

Arguments:

    ClientBinding - Supplies a client binding.

    ServerBinding - Returns a partially bound server binding handle which
        can be used to get back to the client.

Return Values:

    RPC_S_OK - The client binding handle has been successfully converted into
        a server binding handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_CANNOT_SUPPORT - The requested operation can not be supported.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_WRONG_KIND_OF_BINDING - The supplied client binding is not a
        client binding.

--*/
{
    GENERIC_OBJECT * SCall;
    THREAD *Thread;

    InitializeIfNecessary();

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;
    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if (ARGUMENT_PRESENT(ClientBinding))
        {
        SCall = (GENERIC_OBJECT *) ClientBinding;
        if (SCall->InvalidHandle(CALL_TYPE | BINDING_HANDLE_TYPE))
            {
            *ServerBinding = 0;
            return(RPC_S_INVALID_BINDING);
            }

        if (SCall->InvalidHandle(SCALL_TYPE))
            {
            *ServerBinding = 0;
            return(RPC_S_WRONG_KIND_OF_BINDING);
            }
        }
    else
        {
        SCall = (GENERIC_OBJECT *) RpcpGetThreadContext();
        if ( SCall == 0 )
            {
            *ServerBinding = 0;
            return(RPC_S_NO_CALL_ACTIVE);
            }
        }

    return(((SCALL *) SCall)->ConvertToServerBinding(ServerBinding));
}


RPC_STATUS RPC_ENTRY
I_RpcServerRegisterForwardFunction(
    IN RPC_FORWARD_FUNCTION __RPC_FAR * pForwardFunction
    )

/*++

Routine Description:
    Allows Epmapper to register a function with the runtime
    to allow the runtime to determine the 'forwarding' endpoint
    (that is the local endpoint the server must forward the
    currently received packet to).

Return Value:

--*/
{

    InitializeIfNecessary();

    GlobalRpcServer->RegisterRpcForwardFunction(pForwardFunction);

    return RPC_S_OK;
}

RPC_ADDRESS_CHANGE_FN * gAddressChangeFn = 0;

RPC_ADDRESS_CHANGE_FN * RPC_ENTRY
I_RpcServerInqAddressChangeFn()
{
    return gAddressChangeFn;
}

RPC_STATUS RPC_ENTRY
I_RpcServerSetAddressChangeFn(
    IN RPC_ADDRESS_CHANGE_FN * pAddressChangeFn
    )
{
    gAddressChangeFn = pAddressChangeFn;
    return RPC_S_OK;
}

RPC_STATUS
RPC_ENTRY
I_RpcServerInqLocalConnAddress (
    IN RPC_BINDING_HANDLE Binding,
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Binding - Supplies a valid server binding (SCALL).

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported are RPC_P_ADDR_FORMAT_TCP_IPV4 and
        RPC_P_ADDR_FORMAT_TCP_IPV6. Undefined on failure.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    SCALL *SCall;
    THREAD *Thread;
    RPC_STATUS Status;

    InitializeIfNecessary();

    ASSERT(!RpcpCheckHeap());

    Thread = ThreadSelf();
    if (!Thread)
        return RPC_S_OUT_OF_MEMORY;

    RpcpPurgeEEInfoFromThreadIfNecessary(Thread);

    if ( Binding == 0 )
        {
        SCall = (SCALL *) RpcpGetThreadContext();
        if (SCall == 0)
            return(RPC_S_NO_CALL_ACTIVE);
        }
    else
        {
        SCall = (SCALL *) Binding;
        if (SCall->InvalidHandle(SCALL_TYPE))
            return(RPC_S_INVALID_BINDING);
        }

    return InqLocalConnAddress(
        SCall,
        Buffer,
        BufferSize,
        AddressFormat);
}

RPC_STATUS RPC_ENTRY
I_RpcServerUnregisterEndpoint (
    IN RPC_CHAR * Protseq,
    IN RPC_CHAR * Endpoint
    )
{
    InitializeIfNecessary();

    return GlobalRpcServer->UnregisterEndpoint(Protseq, Endpoint);
}


int
InitializeRpcServer (
    )
/*++

Routine Description:

    This routine will be called once at DLL initialization time.  We
    have got to create and initialize the server.  This will get it
    all ready to hang protocol sequences (addresses) and interfaces
    from.

Return Value:

    Zero will be returned if everything is initialized correctly;
    otherwise, non-zero will be returned.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    GlobalRpcServer = new RPC_SERVER(&RpcStatus);
    if (   ( GlobalRpcServer == 0 )
        || ( RpcStatus != RPC_S_OK ) )
        {
        return(1);
        }

    GroupIdCounter = GetTickCount();

    // If we can't create the global management interface
    // don't worry about it; it probably won't be used anyway.
    // When it is used, it should be checked for NULL.

    GlobalManagementInterface = new RPC_INTERFACE(
        (RPC_SERVER_INTERFACE *)mgmt_ServerIfHandle,
        GlobalRpcServer, 0, MAX_IF_CALLS, gMaxRpcSize, 0, &RpcStatus);

    if (GlobalManagementInterface)
        {
        GlobalManagementInterface->RegisterTypeManager(0,
            ((RPC_SERVER_INTERFACE *)mgmt_ServerIfHandle)->DefaultManagerEpv);
        }

    return(RpcStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dceuuid.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dceuuid.cxx

Abstract:

    This module contains the entry points for routines dealing with
    UUIDs.  In particular, UuidCreate lives here.

Author:

    Michael Montague (mikemon) 16-Jan-1992

Revision History:

    Dave Steckler (davidst) 31-Mar-1992
        If NT, remote call to UuidGetValues.

    Mario Goertzel (mariogo) 1-May-1994
        Added the rest of the DCE UUID APIs

    Mario Goertzel (mariogo) 18-May-1994
        Changed algorithm and implementation.  No longer based on RPC.
        Platform specific functions in uuidsup.cxx (win32) and
        dos\uuid16 (dos/win16).

--*/


#include <precomp.hxx>
#include <uuidsup.hxx>
#include <rc4.h>
#include <randlib.h>
#include <crypt.h>

// Contain a cached block of uuids to reduce the
// average cost of creating a uuid.

UUID_CACHED_VALUES_STRUCT  UuidCachedValues;

#define CACHE_VALID      1
#define CACHE_LOCAL_ONLY 2  // -> CACHE_VALID
static unsigned char UuidCacheValid = CACHE_LOCAL_ONLY;


RPC_STATUS RPC_ENTRY
I_UuidCreate(
    OUT UUID PAPI * Uuid
    )
/*++
    Historically this function was used for cheap sometimes unique
    uuid's for context handles and such.  Now it's just a wrapper
    for UuidCreate.
--*/
{
    RPC_STATUS Status = UuidCreateSequential (Uuid);
    if (Status == RPC_S_UUID_LOCAL_ONLY)
        return(RPC_S_OK);

    return(Status);
}


#define RC4_REKEY_PARAM (500000)
extern void *g_rc4SafeCtx;

RPC_STATUS GenerateRandomNumber(unsigned char *Buffer, int BufferSize)
{
    unsigned int KeyEntry;
    unsigned int KeyBytesUsed = 0;

    rc4_safe_select(g_rc4SafeCtx, &KeyEntry, &KeyBytesUsed);

    if (KeyBytesUsed >= RC4_REKEY_PARAM)
        {
        BYTE newSeed[256];

        if (!RtlGenRandom (newSeed, sizeof(newSeed)))
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        rc4_safe_key(g_rc4SafeCtx, KeyEntry, sizeof(newSeed), newSeed);
        }

    // the rc4_safe fucntion is thread safe
    rc4_safe(g_rc4SafeCtx, KeyEntry, BufferSize, Buffer);

    return RPC_S_OK;
}


RPC_STATUS RPC_ENTRY
UuidCreate (
    OUT UUID PAPI * Uuid
    )
{
    RPC_STATUS RpcStatus;
    RPC_UUID_GENERATE PAPI * RpcUuid = (RPC_UUID_GENERATE PAPI *) Uuid;

    RpcStatus = GenerateRandomNumber((unsigned char *)Uuid, 16);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    // Overwriting some bits of the uuid
    RpcUuid->TimeHiAndVersion =
        (RpcUuid->TimeHiAndVersion & RPC_UUID_TIME_HIGH_MASK) | RPC_RAND_UUID_VERSION;
    RpcUuid->ClockSeqHiAndReserved =
        (RpcUuid->ClockSeqHiAndReserved & RPC_UUID_CLOCK_SEQ_HI_MASK) | RPC_UUID_RESERVED;

    return RPC_S_OK;
}

#define MAX_CACHED_UUID_TIME 10000  // 10 seconds


RPC_STATUS RPC_ENTRY
UuidCreateSequential (
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    This routine will create a new UUID (or GUID) which is unique in
    time and space.  We will try to guarantee that the UUID (or GUID)
    we generate is unique in time and space.  This means that this
    routine may fail if we can not generate one which we can guarantee
    is unique in time and space.

Arguments:

    Uuid - Returns the generated UUID (or GUID).

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_UUID_NO_ADDRESS - We were unable to obtain the ethernet or
        token ring address for this machine.

    RPC_S_UUID_LOCAL_ONLY - On NT & Chicago if we can't get a
        network address.  This is a warning to the user, the
        UUID is still valid, it just may not be unique on other machines.

    RPC_S_OUT_OF_MEMORY - Returned as needed.
--*/
{
    RPC_UUID_GENERATE PAPI * RpcUuid = (RPC_UUID_GENERATE PAPI *) Uuid;
    RPC_STATUS Status = RPC_S_OK;
    static DWORD LastTickCount = 0;

    InitializeIfNecessary();

    if (GetTickCount()-LastTickCount > MAX_CACHED_UUID_TIME)
        {
        UuidCachedValues.AllocatedCount = 0;
        LastTickCount = GetTickCount();
        }

    ULARGE_INTEGER Time;
    long Delta;

    for(;;)
        {
        Time.QuadPart = UuidCachedValues.Time.QuadPart;

        // Copy the static info into the UUID.  We can't do this later
        // because the clock sequence could be updated by another thread.

        *(unsigned long *)&RpcUuid->ClockSeqHiAndReserved =
            *(unsigned long *)&UuidCachedValues.ClockSeqHiAndReserved;
        *(unsigned long *)&RpcUuid->NodeId[2] =
            *(unsigned long *)&UuidCachedValues.NodeId[2];

        Delta = InterlockedDecrement(&UuidCachedValues.AllocatedCount);

        if (Time.QuadPart != UuidCachedValues.Time.QuadPart)
            {
            // If our captured time doesn't match the cache then another
            // thread already took the lock and updated the cache. We'll
            // just loop and try again.
            continue;
            }

        if (Delta >= 0)
            {
            break;
            }

        //
        // Allocate block of Uuids.
        //

        Status = UuidGetValues( &UuidCachedValues );
        if (Status == RPC_S_OK)
            {
            UuidCacheValid = CACHE_VALID;
            }
        else
            {
            UuidCacheValid = CACHE_LOCAL_ONLY;
            }

        if (Status != RPC_S_OK
            && Status != RPC_S_UUID_LOCAL_ONLY)
            {
#ifdef DEBUGRPC
            if (Status != RPC_S_OUT_OF_MEMORY)
                PrintToDebugger("RPC: UuidGetValues returned or raised: %x\n", Status);
#endif
            ASSERT( (Status == RPC_S_OUT_OF_MEMORY) );


            return Status;
            }

        // Loop
        }


    Time.QuadPart -= Delta;

    RpcUuid->TimeLow = (unsigned long) Time.LowPart;
    RpcUuid->TimeMid = (unsigned short) (Time.HighPart & 0x0000FFFF);
    RpcUuid->TimeHiAndVersion = (unsigned short)
        (( (unsigned short)(Time.HighPart >> 16)
        & RPC_UUID_TIME_HIGH_MASK) | RPC_UUID_VERSION);

    ASSERT(   Status == RPC_S_OK
           || Status == RPC_S_UUID_LOCAL_ONLY);

    if (UuidCacheValid == CACHE_LOCAL_ONLY)
        {
        return RPC_S_UUID_LOCAL_ONLY;
        }

    return(Status);
}

RPC_STATUS RPC_ENTRY
UuidToString (
    IN UUID PAPI * Uuid,
    OUT unsigned short PAPI * PAPI * StringUuid
    )
/*++

Routine Description:

    This routine converts a UUID into its string representation.

Arguments:

    Uuid - Supplies the UUID to be converted into string representation.

    StringUuid - Returns the string representation of the UUID.  The
        runtime will allocate the string.  The caller is responsible for
        freeing the string using RpcStringFree.

Return Value:

    RPC_S_OK - We successfully converted the UUID into its string
        representation.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allocate
        a string.

--*/
{
    RPC_CHAR PAPI * String;

    InitializeIfNecessary();

    // The string representation of a UUID is always 36 character long,
    // and we need one more for the terminating zero.

    *StringUuid = (RPC_CHAR PAPI *) RpcpFarAllocate(sizeof(RPC_CHAR) * 37);
    if ( *StringUuid == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    String = ((RPC_UUID PAPI *) Uuid)->ConvertToString(*StringUuid);
    *String = 0;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
UuidFromString (
    IN unsigned short PAPI * StringUuid OPTIONAL,
    OUT UUID PAPI * Uuid
    )
/*++

Routine Description:

    We convert a UUID from its string representation into the binary
    representation.

Arguments:

    StringUuid - Optionally supplies the string representation of the UUID;
        if the string is not supplied, then the Uuid is set to the NIL UUID.

    Uuid - Returns the binary representation of the UUID.

Return Value:

    RPC_S_OK - The string representation was successfully converted into
        the binary representation.

    RPC_S_INVALID_STRING_UUID - The supplied string UUID is not correct.

--*/
{
    RPC_UUID RpcUuid;

    if ( StringUuid == 0 )
        {
        ((RPC_UUID PAPI *) Uuid)->SetToNullUuid();
        return(RPC_S_OK);
        }

    if ( RpcUuid.ConvertFromString(StringUuid) != 0)
        {
        return(RPC_S_INVALID_STRING_UUID);
        }
    ((RPC_UUID PAPI *) Uuid)->CopyUuid(&RpcUuid);
    return(RPC_S_OK);
}


signed int RPC_ENTRY
UuidCompare (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    The supplied uuids are compared and their order is determined.

Arguments:

    Uuid1, Uuid2 - Supplies the uuids to be compared.  A value of NULL can
        be supplied to indicate the nil uuid.

    Status - The status of the function.  Currently always RPC_S_OK.

Return Value:

    Returns the result of the comparison.  Negative one (-1) will be returned
    if Uuid1 precedes Uuid2 in order, zero will be returned if Uuid1 is equal
    to Uuid2, and positive one (1) will be returned if Uuid1 follows Uuid2 in
    order.  A nil uuid is the first uuid in order.

Note:

    The algorithm for comparing uuids is specified by the DCE RPC Architecture.

--*/
{
    int Uuid1Nil, Uuid2Nil;
    RPC_STATUS RpcStatus;

    Uuid1Nil = UuidIsNil(Uuid1, &RpcStatus);
    ASSERT(RpcStatus == RPC_S_OK);

    Uuid2Nil = UuidIsNil(Uuid2, &RpcStatus);
    ASSERT(RpcStatus == RPC_S_OK);

    *Status = RPC_S_OK;

    if ( Uuid1Nil != 0 )
        {
        // Uuid1 is the nil uuid.

        if ( Uuid2Nil != 0 )
            {
            // Uuid2 is the nil uuid.

            return(0);
            }
        else
            {
            return(-1);
            }
        }
    else if ( Uuid2Nil != 0 )
        {
        // Uuid2 is the nil uuid.

        return(1);
        }
    else
        {
        if ( Uuid1->Data1 == Uuid2->Data1 )
            {
            if ( Uuid1->Data2 == Uuid2->Data2 )
                {
                if ( Uuid1->Data3 == Uuid2->Data3 )
                    {
                    int compare = RpcpMemoryCompare(&Uuid1->Data4[0],
                                                    &Uuid2->Data4[0],
                                                    8);
                    if (compare > 0)
                        {
                        return(1);
                        }
                    else if (compare < 0 )
                        {
                        return(-1);
                        }
                    return(0);
                    }
                else if ( Uuid1->Data3 > Uuid2->Data3 )
                    {
                    return(1);
                    }
                else
                    {
                    return(-1);
                    }
                }
            else if ( Uuid1->Data2 > Uuid2->Data2 )
                {
                return(1);
                }
            else
                {
                return(-1);
                }
            }
        else if ( Uuid1->Data1 > Uuid2->Data1 )
            {
            return(1);
            }
        else
            {
            return(-1);
            }
        }

    ASSERT(!"This is not reached");
    return(1);
}


RPC_STATUS RPC_ENTRY
UuidCreateNil (
    OUT UUID __RPC_FAR * NilUuid
    )
/*++

Arguments:

    NilUuid - Returns a nil uuid.

--*/
{
    ((RPC_UUID __RPC_FAR *)NilUuid)->SetToNullUuid();

    return(RPC_S_OK);
}


int RPC_ENTRY
UuidEqual (
    IN UUID __RPC_FAR * Uuid1,
    IN UUID __RPC_FAR * Uuid2,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    This routine is used to determine if two uuids are equal.

Arguments:

    Uuid1, Uuid2 - Supplies the uuids to compared for equality.  A value of
        NULL can be supplied to indicate the nil uuid.

    Status - Will always be set to RPC_S_OK.

Return Value:

    Returns non-zero if Uuid1 equals Uuid2; otherwise, zero will be
        returned.

--*/
{
    *Status = RPC_S_OK;

    if (Uuid1 == 0)
        {
        if (    (Uuid2 == 0)
            ||  ((RPC_UUID __RPC_FAR *)Uuid2)->IsNullUuid())
            {
            return 1;
            }
        return 0;
        }

    if (Uuid2 == 0)
        {
        if (((RPC_UUID __RPC_FAR *)Uuid1)->IsNullUuid())
            {
            return 1;
            }
        return 0;
        }

    return( ((RPC_UUID __RPC_FAR *)Uuid1)->MatchUuid(
                 (RPC_UUID __RPC_FAR *)Uuid2)
             == 0 );
}


unsigned short RPC_ENTRY
UuidHash (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    An application will use this routine to create a hash value for a uuid.

Arguments:

    Uuid - Supplies the uuid for which we want to create a hash value.  A
        value of NULL can be supplied to indicate the nil uuid.

    Status - Will always be set to RPC_S_OK.

Return Value:

    Returns the hash value.

--*/
{
    *Status = RPC_S_OK;

    if ( Uuid == 0 )
        {
        return(0);
        }

    return( ((RPC_UUID __RPC_FAR *)Uuid)->HashUuid() );
}


int RPC_ENTRY
UuidIsNil (
    IN UUID __RPC_FAR * Uuid,
    OUT RPC_STATUS __RPC_FAR * Status
    )
/*++

Routine Description:

    We will determine if the supplied uuid is the nil uuid or not.

Arguments:

    Uuid - Supplies the uuid to check.  A value of NULL indicates the nil
        uuid.

    Status - This will always be RPC_S_OK.

Return Value:

    Returns non-zero if the supplied uuid is the nil uuid; otherwise, zero
    will be returned.

--*/
{
    *Status = RPC_S_OK;

    if ( Uuid == 0 )
        {
        return(1);
        }

    return ( ((RPC_UUID __RPC_FAR *) Uuid)->IsNullUuid() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\delaytab.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       delaytab.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    delaytab.cxx

Abstract:

    interface for DELAYED_ACTION_TABLE, which asynchronously calls
    functions after a specified delay.

Author:

    Jeff Roberts (jroberts)  2-Nov-1994

Revision History:

     2-Nov-1994     jroberts

        Created this module.

--*/

#include <precomp.hxx>
#include "delaytab.hxx"

#include "rpcuuid.hxx"
#include "sdict.hxx"
#include "binding.hxx"
#include "handle.hxx"
#include "rpcssp.h"
#include "secclnt.hxx"
#include "hndlsvr.hxx"



inline unsigned long
CurrentTimeInMsec(
     void
     )
{
    return GetTickCount();
}


BOOL
DelayedActionThread(
    LPVOID  Parms
    )

/*++

Routine Description:

    This is a thread proc for the delayed call table.

Arguments:

    Parms - address of table

Return Value:

    FALSE - thread should be returned to the the cache.

--*/
{
    DELAYED_ACTION_TABLE * pTable = (DELAYED_ACTION_TABLE *) Parms;

    pTable->ThreadProc();

    return FALSE;
}


void
DELAYED_ACTION_TABLE::ThreadProc()
{
/*++

Routine Description:

    This thread takes requests off the delayed-action list and processes them.
    After 15 seconds of inactivity, this thread terminates.

Arguments:

    none

Return Value:

    none

--*/

    BOOL     EmptyList = FALSE;
    long     CurrentTime;
    long     WaitTime;

    DELAYED_ACTION_NODE Copy;
    DELAYED_ACTION_NODE * pNode;

    //
    // Disabling the event priority boost has the benefit of allowing a thread
    // who posts a request to continue processing afterwards.  This should
    // improve locality of reference, since this thread will not preempt
    // the poster.
    //
    if (FALSE == SetThreadPriorityBoost(GetCurrentThread(), TRUE))
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: SetThreadPriorityBoost failed with %lu\n", GetLastError());
#endif
        }

    do
        {
        DELAYED_ACTION_FN pFn;
        void * pData;

        Mutex.Request();

#ifdef DEBUGRPC
        {
        unsigned ObservedCount = 0;
        DELAYED_ACTION_NODE * Scan = ActiveList.Next;
        while (Scan != &ActiveList)
            {
            ++ObservedCount;
            Scan = Scan->Next;
            }

        if (ObservedCount != NodeCount)
            {
            PrintToDebugger("RPC DG: delay thread sees %lu nodes but there should be %lu\n", ObservedCount, NodeCount);
            RpcpBreakPoint();
            }
        }
#endif

        pNode = ActiveList.Next;
        if (pNode != &ActiveList)
            {
            ASSERT(pNode->TriggerTime != DELAYED_ACTION_NODE::DA_NodeFree);

            EmptyList = FALSE;

            CurrentTime = CurrentTimeInMsec();
            if (pNode->TriggerTime - CurrentTime > 0)
                {
                WaitTime = pNode->TriggerTime - CurrentTime;
                }
            else
                {
                WaitTime = 0;

                pFn   = pNode->Fn;
                pData = pNode->Data;

                Cancel(pNode);
                }
            }
        else
            {
            CurrentTime = CurrentTimeInMsec();

            if (!EmptyList)
                {
                WaitTime = 15000UL;
                EmptyList = TRUE;
                }
            else
                {
                ThreadActive = FALSE;
                Mutex.Clear();
                break;
                }
            }

        ThreadWakeupTime = CurrentTime + WaitTime;

        Mutex.Clear();

        if (WaitTime)
            {
            ThreadEvent.Wait(WaitTime);
            }
        else
            {
            (*pFn)(pData);
            }
        }
    while ( !fExitThread );
}


DELAYED_ACTION_TABLE::DELAYED_ACTION_TABLE(
    RPC_STATUS * pStatus
    )
/*++

Routine Description:

    constructor for the delayed-action table.  Initially no thread is created.

Arguments:

    pStatus - if an error occurs, this will be filled in

Return Value:

    none

--*/

    : Mutex(pStatus),
      ThreadEvent(pStatus, 0),
      ActiveList(0, 0),
      fExitThread(0),
      ThreadActive(FALSE)
{
    fConstructorFinished = FALSE;

    if (*pStatus != RPC_S_OK)
        {
        return;
        }

    ActiveList.Next = &ActiveList;
    ActiveList.Prev = &ActiveList;

#ifdef DEBUGRPC

    LastAdded = 0;
    LastRemoved = 0;
    NodeCount = 0;

#endif

    fConstructorFinished = TRUE;
}


DELAYED_ACTION_TABLE::~DELAYED_ACTION_TABLE(
    )
/*++

Routine Description:

    Dsestructor for the delayed-action table.  It tells the associated thread
    to terminate, and waits until that happens.

Arguments:

    none

Return Value:

    none

--*/

{
    if (FALSE == fConstructorFinished)
        {
        return;
        }

    DELAYED_ACTION_NODE * pNode;

    fExitThread = 1;
    ThreadEvent.Raise();

    while (ActiveList.Next != &ActiveList)
        {
        Sleep(500);
        }
}


RPC_STATUS
DELAYED_ACTION_TABLE::Add(
    DELAYED_ACTION_NODE * pNode,
    unsigned Delay,
    BOOL ForceUpdate
    )
/*++

Routine Description:

    Adds a node to the table with the specified delay.  The action taken if
    the node is already in the list depends upon <ForceUpdate>: if FALSE,
    the old trigger time is kept; if TRUE, the new time is used and the node
    is moved in the list appropriately.

Arguments:

    pNode - the node

    Delay - delay time in milliseconds

    ForceUpdate - only used when pNode is already in the list (see text above)

Return Value:

    RPC_S_OK, or an error

--*/

{
    if (!ForceUpdate && pNode->IsActive())
        {
        return RPC_S_OK;
        }

    CLAIM_MUTEX Lock(Mutex);

    if (pNode->IsActive())
        {
        Cancel(pNode);
        }

    //
    // Add the node to the active list.
    //
    DELAYED_ACTION_NODE * pScan;

    pScan = ActiveList.Next;
    pNode->TriggerTime = Delay + CurrentTimeInMsec();

    long TriggerTime = pNode->TriggerTime;

    while (pScan != &ActiveList && pScan->TriggerTime - TriggerTime < 0)
        {
        ASSERT(pScan->IsActive());
        ASSERT(pScan != pNode);

        pScan = pScan->Next;
        }

    pNode->Next = pScan;
    pNode->Prev = pScan->Prev;

    pNode->Next->Prev = pNode;
    pNode->Prev->Next = pNode;

#ifdef DEBUGRPC
    ++NodeCount;
    LastAdded = pNode;
#endif

    if (!ThreadActive)
        {
        fExitThread = FALSE;

        RPC_STATUS Status = GlobalRpcServer->CreateThread(DelayedActionThread, this);
        if (Status)
            {
            return Status;
            }

        ThreadActive = TRUE;
        }
    else if (ActiveList.Next == pNode && TriggerTime - ThreadWakeupTime < 0)
        {
        ThreadEvent.Raise();
        }

    return RPC_S_OK;
}


BOOL
DELAYED_ACTION_TABLE::SearchForNode(
    DELAYED_ACTION_NODE * pNode
    )
/*++

Routine Description:

    Finds the node in the table.

Arguments:



Return Value:

    TRUE if pNode is in the table
    FALSE if not

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    //
    // Search for node in active list.
    //
    DELAYED_ACTION_NODE * pScan;

    pScan = ActiveList.Next;
    while (pScan != &ActiveList && pScan != pNode)
        {
        pScan = pScan->Next;
        }

    if (pScan)
        {
        return TRUE;
        }
    else
        {
        return FALSE;
        }
}


void
DELAYED_ACTION_TABLE::QueueLength(
    unsigned * pTotalCount,
    unsigned * pOverdueCount
    )
/*++

Routine Description:

    Determines the number of active entries and the number of entries
    that are late.

Arguments:



Return Value:

    none

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    DELAYED_ACTION_NODE * pScan = ActiveList.Next;
    unsigned Count = 0;
    long CurrentTime = GetTickCount();

    while (pScan != &ActiveList && CurrentTime - pScan->TriggerTime > 0)
        {
        ++Count;
        pScan = pScan->Next;
        }

    *pOverdueCount = Count;

    while (pScan != &ActiveList)
        {
        ++Count;
        pScan = pScan->Next;
        }

    *pTotalCount = Count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dgsvr.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dgsvr.cxx

Abstract:

    This is the server protocol code for datagram rpc.

Author:

    Dave Steckler (davidst) 15-Dec-1992

Revision History:

    Jeff Roberts  (jroberts) 11-22-1994

        Rewrote it.

    Jeff Roberts  (jroberts)  9-30-1996

        Began asynchronous call support.

    Edward Reus   (edwardr)   7-09-1997

        Support for large packets (Falcon).

--*/
#include <precomp.hxx>

//
// Remember that any #defines must go AFTER the precompiled header in order
// to be noticed by the compiler.
//

// uncomment this to have the server try the msconv interface, used by NT5 beta 1.
//
// #define TRY_MSCONV_INTERFACE


#include "sdict2.hxx"
#include "secsvr.hxx"
#include "hndlsvr.hxx"
#include "dgpkt.hxx"
#include "delaytab.hxx"
#include "hashtabl.hxx"
#include "locks.hxx"
#include "dgclnt.hxx"
#include "dgsvr.hxx"
#include <conv.h>
#include <convc.h>

#ifdef TRY_MSCONV_INTERFACE
#include <msconv.h>
#endif

#define IDLE_SCONNECTION_LIFETIME       (3 * 60 * 1000)
#define IDLE_SCONNECTION_SWEEP_INTERVAL (30 * 1000)
#define IDLE_SCALL_LIFETIME             (15 * 1000)


struct REMOTE_ADDRESS_INFO
{
#pragma warning(disable:4200)

    unsigned RemoteInfoLength;
    unsigned SecurityInfoPadLength;
    byte     Address[];

#pragma warning(default:4200)
};

//------------------------------------------------------------------------

LONG fPruning = FALSE;

SERVER_ACTIVITY_TABLE *  ServerConnections;
ASSOC_GROUP_TABLE *      AssociationGroups;

LONG ServerConnectionCount = 0;
LONG ServerCallCount = 0;

#ifdef INTRODUCE_ERRORS

extern long ServerDelayTime;
extern long ServerDelayRate;
extern long ServerDropRate;

#endif
//--------------------------------------------------------------------

extern int
StringLengthWithEscape (
    IN RPC_CHAR * String
    );

extern RPC_CHAR *
StringCopyEscapeCharacters (
    OUT RPC_CHAR * Destination,
    IN RPC_CHAR * Source
    );

void
ServerCallScavengerProc(
    void *  Parms
    );

RPC_STATUS
InitializeServerGlobals(
    );

void
InterpretFailureOptions(
    );

//--------------------------------------------------------------------

#if !defined(WIN96)
char __pure_virtual_called()
{
    ASSERT(0 && "rpc: pure virtual fn called in dg");
    return 0;
}
#endif


boolean ServerGlobalsInitialized = FALSE;

RPC_STATUS
InitializeServerGlobals(
    )
/*++

Routine Description:

    This fn initializes all the global variables used by the datagram
    server.  If anything fails, all the objects are destroyed.

Arguments:

    none

Return Value:

    RPC_S_OK if ok
    RPC_S_OUT_OF_MEMORY if an object could not be created

--*/

{
    RPC_STATUS Status = RPC_S_OK;

    //
    // Don't take the global mutex if we can help it.
    //
    if (ServerGlobalsInitialized)
        {
        return 0;
        }

    RequestGlobalMutex();

    if (0 != InitializeRpcProtocolDgClient())
        {
        ClearGlobalMutex();
        return RPC_S_OUT_OF_MEMORY;
        }

    if (!ServerGlobalsInitialized)
        {
        ServerConnections = new SERVER_ACTIVITY_TABLE(&Status);
        if (!ServerConnections)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        AssociationGroups = new ASSOC_GROUP_TABLE(&Status);
        if (!AssociationGroups)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        ServerGlobalsInitialized = TRUE;
        }

    ClearGlobalMutex();

    return Status;

    //--------------------------------------------------------------------

abend:

    delete AssociationGroups;
    AssociationGroups = 0;

    delete ServerConnections;
    ServerConnections = 0;

    ClearGlobalMutex();

    return Status;
}


RPC_ADDRESS *
DgCreateRpcAddress (
    IN TRANS_INFO * TransportInfo
    )
/*++

Routine Description:

    This is a psuedo-constructor for the DG_ADDRESS class. This is done this
    way so that the calling routine doesn't have to have any protocol-specific
    knowledge.

Arguments:

    TransportInterface - Pointer to a PDG_RPC_SERVER_TRANSPORT_INFO.
    pStatus - Pointer to where to put the return value

Return Value:

    pointer to new DG_ADDRESS.

--*/
{
    //
    // If the global active call table hasn't been initialized, then do
    // so now.
    //
    if (0 != InitializeServerGlobals())
        {
        return 0;
        }

    RPC_STATUS  Status = RPC_S_OK;

    PDG_ADDRESS Address;


    Address = new (TransportInfo) DG_ADDRESS(
                           TransportInfo,
                           &Status
                           );
    if (!Address)
        {
        return 0;
        }

    if (Status != RPC_S_OK)
        {
        delete Address;
        return 0;
        }

    return Address;
}


DG_ADDRESS::DG_ADDRESS(
    TRANS_INFO * a_LoadableTransport,
    RPC_STATUS * pStatus
    )
    : RPC_ADDRESS(pStatus),

    TotalThreadsThisEndpoint    (0),
    ThreadsReceivingThisEndpoint(0),
    MinimumCallThreads          (0),
    MaximumConcurrentCalls      (0),
    CachedConnections           (0),
    ActiveCallCount             (0),
    AutoListenCallCount         (0)

/*++

Routine Description:

    This is the constructor for a DG_ADDRESS.

Arguments:

    TransportInterface - Pointer to a PDG_RPC_SERVER_TRANSPORT_INFO

    pStatus - Pointer to where to put the return value

Return Value:

    None (this is a constructor)

Revision History:

--*/

{
    TransInfo = a_LoadableTransport;
    ObjectType = DG_ADDRESS_TYPE;

    //
    // Make sure the RPC_ADDRESS (et. al.) initialized correctly.
    //
    if (*pStatus != RPC_S_OK)
        {
        return;
        }

    Endpoint.TransportInterface = (RPC_DATAGRAM_TRANSPORT *)
                                        TransInfo->InqTransInfo();
}


DG_ADDRESS::~DG_ADDRESS()

/*++

Routine Description:

    This is the destructor for a DG_ADDRESS.
    It is called only if the endpoint failed!

Arguments:

    <None>

Return Value:

    <None>

--*/

{
}

inline void
DG_ADDRESS::BeginAutoListenCall (
    )
{
    AutoListenCallCount.Increment() ;
}

inline void
DG_ADDRESS::EndAutoListenCall (
    )
{
    ASSERT(AutoListenCallCount.GetInteger() >= 1);
    AutoListenCallCount.Decrement() ;
}


void
DG_ADDRESS::WaitForCalls(
    )
{
    while (InqNumberOfActiveCalls() > AutoListenCallCount.GetInteger())
        {
        ServerConnections->PruneEntireTable(0);
        PauseExecution(500);
        }
}

void
DG_ADDRESS::EncourageCallCleanup(
    RPC_INTERFACE * Interface
    )
{
    if (ServerGlobalsInitialized && AutoListenCallCount.GetInteger() > 0)
        {
        ServerConnections->PruneEntireTable(Interface);
        }
}

RPC_STATUS
DG_ADDRESS::ServerSetupAddress (
    IN RPC_CHAR * NetworkAddress,
    IN RPC_CHAR * *  pEndpointString,
    IN unsigned int  PendingQueueSize,
    IN void *        SecurityDescriptor,
    IN unsigned long EndpointFlags,
    IN unsigned long NICFlags,
    OUT NETWORK_ADDRESS_VECTOR * * ppNetworkAddressVector
    )
{
    RPC_STATUS  Status;

    Status = Endpoint.TransportInterface->Listen(
                                        Endpoint.TransportEndpoint,
                                        NetworkAddress,
                                        pEndpointString,
                                        SecurityDescriptor,
                                        EndpointFlags,
                                        NICFlags,
                                        ppNetworkAddressVector
                                        );
    if (!Status)
        {
        Status = Endpoint.TransportInterface->QueryEndpointStats(
                                        &Endpoint.TransportEndpoint,
                                        &Endpoint.Stats
                                        );
        }

    Endpoint.Flags = EndpointFlags;

    return Status;
}

#ifndef NO_PLUG_AND_PLAY

void
DG_ADDRESS::PnpNotify (
    )
{
    Endpoint.TransportInterface->PnpNotify();
}
#endif


RPC_STATUS
DG_ADDRESS::ServerStartingToListen (
    IN unsigned int MinThreads,
    IN unsigned int MaxCalls
    )
/*++

Routine Description:

    The runtime calls this fn to ensure a thread is listening on the address's
    endpoint.  Currently, it may be called from RpcServerUse*Protseq*() or
    from RpcServerRegisterIfEx().

Arguments:

    MinimumCallThreads - Supplies a number indicating the minimum number
        of call threads that should be created for this address. This is
        a hint, and datagram ignores it.

    MaximumConcurrentCalls - Supplies the maximum number of concurrent
        calls that this server will support.  RPC_INTERFACE::DispatchToStub
        limits the number of threads dispatched to a stub; the argument
        here is just a hint for the transport.

Return Value:

    RPC_S_OK             if everything went ok.
    RPC_S_OUT_OF_THREADS if we needed another thread and couldn't create one

--*/
{
    MaximumConcurrentCalls = MaxCalls;

    return CheckThreadPool();
}

RPC_STATUS
DG_ADDRESS::CompleteListen(
    )
{
    Endpoint.TransportInterface->CompleteListen(Endpoint.TransportEndpoint);

    return 0;
}

RPC_STATUS
DG_ADDRESS::CheckThreadPool(
    )
{
    return TransInfo->CreateThread();
}


RPC_STATUS RPC_ENTRY
I_RpcLaunchDatagramReceiveThread(
    void * pVoid
    )
{
/*++

Routine Description:

    If all of the following are true:

        - the transport is part of our thread-sharing scheme
        - this address's endpoint is being monitored by the shared thread
          (hence no RPC thread is receiving on the endpoint)
        - the shared thread detects data on this address's endpoint

    then the shared thread will call this (exported) function to create
    a thread to handle the incoming packet.

Arguments:

    pVoid - the DG_ADDRESS of the endpoint with data

Return Value:

    result from CreateThread()

--*/

    PDG_ADDRESS pAddress = (PDG_ADDRESS) pVoid;

    return pAddress->CheckThreadPool();
}


void
DG_ADDRESS::ServerStoppedListening (
    )

/*++

Routine Description:

    The runtime calls this fn to inform the address that the server is not
    listening any more.  Since auto-listen interfaces may still be present,
    this doesn't mean much anymore.

Arguments:

    <None>

Return Value:

    <None>

--*/
{
}


long
DG_ADDRESS::InqNumberOfActiveCalls (
    )
{
    return ActiveCallCount;
}


BOOL
DG_ADDRESS::ForwardPacketIfNecessary(
    IN PDG_PACKET           Packet,
    IN DG_TRANSPORT_ADDRESS RemoteAddress
    )
/*++

Routine Description:

       (courtesy of Connie)

       The runtime has determined that it is dedicated to the
       Epmapper and that pkts may arrive that are really
       destined for an endpoint other than that of the epmapper
       (ie: this is the beginning of dynamic endpoint resolution
       by the forwarding mechanism).

       The runtime has just received a packet and has called
       this routine to determine if (a) the packet is destined
       for the epmapper (in which case it returns indicating that
       the packet should be processed as is)  OR
       (b) the packet is destined for another local server (in
       which case it forwarded to its intented destination) OR
       (c) is in error (in which case returns indicating an error).

       It searches for the i/f.  If not found it calls the
       epmapper get forward function to determine the real destination
       endpoint for this i/f. If the epmapper recognizes the i/f,
       it calls ForwardPacket to forward the packet.

Return Value:

    TRUE  if the packet needed to be forwarded
    FALSE if it should be handled locally

--*/
{
    RPC_STATUS            Status;
    PNCA_PACKET_HEADER    pHeader = &Packet->Header;

    RPC_INTERFACE *       pRpcInterface;
    RPC_SYNTAX_IDENTIFIER RpcIfSyntaxIdentifier;
    char *                EndpointString = 0;

    //
    // Build an interface syntax identifier from the packet.
    //
    RpcpMemoryCopy(
        &RpcIfSyntaxIdentifier.SyntaxGUID,
        &pHeader->InterfaceId,
        sizeof(RPC_UUID)
        );

    RpcIfSyntaxIdentifier.SyntaxVersion.MajorVersion =
                              pHeader->InterfaceVersion.MajorVersion;
    RpcIfSyntaxIdentifier.SyntaxVersion.MinorVersion =
                              pHeader->InterfaceVersion.MinorVersion;
    //
    // Try to find the appropriate interface to dispatch to.
    //
    pRpcInterface = Server->FindInterface(&RpcIfSyntaxIdentifier);

    //
    //  If the Interface is Mgmt If .. EpMapper has registered it  and will be found
    //  The criteria then is .. If Packet has a Non NULL Obj Id forward .. else process
    //
    if (pRpcInterface &&
        0 == RpcpMemoryCompare(&pHeader->ObjectId, &NullUuid, sizeof(UUID)) )
        {
        //Interface found, just process as normal
        return FALSE;
        }
    else
        {
        //Interface wasn't found. Let's ask endpoint mapper to resolve it
        //for us.

        unsigned char * AnsiProtseq;

        // Must convert the protocol sequence into an ansi string.

        unsigned Length = 1 + RpcpStringLength(InqRpcProtocolSequence());
        AnsiProtseq = (unsigned char *) _alloca(Length);
        if (!AnsiProtseq)
            {
            return TRUE;
            }

        NTSTATUS NtStatus;
        NtStatus = RtlUnicodeToMultiByteN((char *) AnsiProtseq,
                                          Length,
                                          NULL,
                                          InqRpcProtocolSequence(),
                                          Length * sizeof(RPC_CHAR)
                                          );
        ASSERT(NT_SUCCESS(NtStatus));

        RpcTryExcept
            {
            // Call the epmapper get forward function. It returns the
            // endpoint of the server this packet is really destined for.

            Status =  (*Server->pRpcForwardFunction)(
                         (UUID *) &pHeader->InterfaceId,
                         (RPC_VERSION *) &pHeader->InterfaceVersion,
                         (UUID *) &pHeader->ObjectId,
                         AnsiProtseq,
                         (void * *) &EndpointString
                         );
            }
        RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
            {
            Status = RpcExceptionCode();
            }
        RpcEndExcept

        if (Status != RPC_S_OK)
            {
            if (!(pHeader->PacketFlags & DG_PF_BROADCAST) &&
                !(pHeader->PacketFlags & DG_PF_MAYBE))
                {
                // couldn't find the interface, or some other error occurred.
                // The X/Open version of the AES, available in 1997, says we should
                // set the boot time to zero in this situation.
                //
                InitErrorPacket(Packet, DG_REJECT, RPC_S_UNKNOWN_IF );
                Packet->Header.ServerBootTime = 0;
                SendPacketBack (&Packet->Header, Packet->GetPacketBodyLen(), RemoteAddress);
                }
            return TRUE;
            }

        if (EndpointString)
            {
            ForwardPacket(Packet, RemoteAddress, EndpointString);
            I_RpcFree(EndpointString);
            }
        }

    return TRUE;
}


RPC_STATUS
DG_ADDRESS::ForwardPacket(
    IN PDG_PACKET               Packet,
    IN DG_TRANSPORT_ADDRESS     RemoteAddress,
    IN char *                   ServerEndpointString
    )
/*++

Routine Description:

    This method will be called to forward a packet that was just
    received to the intended destination endpoint.

    The runtime has received a packet for an unknkown i/f.
    It has passed this packet to the epmapper who has found the
    correct destination enpoint in its table and has instructed the
    runtime to forward the packet to this Endpoint. This procedure
    will do just that.

--*/
{
    //
    // Avoid a loop if the server gets confused.
    //
    if (Packet->Header.PacketType != DG_REQUEST &&
        Packet->Header.PacketType != DG_PING    &&
        Packet->Header.PacketType != DG_QUIT)
        {
#ifdef DEBUGRPC
        DbgPrint("DG RPC: not forwarding packet of type %u\n", Packet->Header.PacketType);
#endif
        return RPC_S_OK;
        }

    //
    // Use the same value for 32 and 64 bit.
    //
    #define REMOTE_ADDRESS_PAD 8

    unsigned             Length;
    REMOTE_ADDRESS_INFO *pRemoteAddressInfo;
    unsigned             EndpointInfoStart  = Align( Packet->DataLength, REMOTE_ADDRESS_PAD );
    unsigned             EndpointInfoLength = sizeof(REMOTE_ADDRESS_INFO)
                                            + Endpoint.TransportInterface->AddressSize;
    //
    // We have not yet subtracted the header from the packet's DataLength.
    //
    Length = EndpointInfoStart + EndpointInfoLength;

    //
    // If the packet header was byte-swapped, restore it to its original format.
    //
    ByteSwapPacketHeaderIfNecessary(Packet);


    // BE CAREFUL READING OR WRITING THE PACKET HEADER AFTER IT IS BYTE-SWAPPED.


    //
    // If the original packet is short enough, we can append out data
    // to the end; otherwise, we need to send one packet with the original
    // data and another with the client address info.
    //
    if (Length <= Endpoint.Stats.PreferredPduSize)
        {
        //
        // Mark it "forwarded with appended endpoint info"
        //
        Packet->Header.PacketFlags  |=  DG_PF_FORWARDED;
        Packet->Header.PacketFlags2 &= ~DG_PF2_FORWARDED_2;

        pRemoteAddressInfo = (REMOTE_ADDRESS_INFO *) ( Packet->Header.Data
                                                     + EndpointInfoStart
                                                     - sizeof(NCA_PACKET_HEADER) );

        pRemoteAddressInfo->SecurityInfoPadLength = EndpointInfoStart - Packet->DataLength;
        }
    else
        {
        Length = EndpointInfoLength + sizeof(NCA_PACKET_HEADER);

        //
        // Mark it "forwarded without appended endpoint info"
        //
        Packet->Header.PacketFlags  &= ~DG_PF_FORWARDED;
        Packet->Header.PacketFlags2 |=  DG_PF2_FORWARDED_2;

        Endpoint.TransportInterface->ForwardPacket( Endpoint.TransportEndpoint,
                                                    0,
                                                    0,
                                                    &Packet->Header,
                                                    Packet->DataLength,
                                                    0,
                                                    0,
                                                    ServerEndpointString
                                                    );

        //
        // Mark it "endpoint info only".
        //
        Packet->Header.PacketFlags  |= DG_PF_FORWARDED;
        Packet->Header.PacketFlags2 |= DG_PF2_FORWARDED_2;

        Packet->SetPacketBodyLen(EndpointInfoLength);
        Packet->Header.AuthProto     = 0;

        pRemoteAddressInfo           = (REMOTE_ADDRESS_INFO *) Packet->Header.Data;

        pRemoteAddressInfo->SecurityInfoPadLength = 0;
        }

    //
    // Add endpoint info and send it.
    //
    pRemoteAddressInfo->RemoteInfoLength = sizeof(REMOTE_ADDRESS_INFO)
                                         + Endpoint.TransportInterface->AddressSize;
    RpcpMemoryCopy(
        pRemoteAddressInfo->Address,
        RemoteAddress,
        Endpoint.TransportInterface->AddressSize
        );

    Endpoint.TransportInterface->ForwardPacket( Endpoint.TransportEndpoint,
                                                0,
                                                0,
                                                &Packet->Header,
                                                Length,
                                                0,
                                                0,
                                                ServerEndpointString
                                                );
    return RPC_S_OK;
}


BOOL
DG_ADDRESS::CaptureClientAddress(
    IN  PDG_PACKET           Packet,
    OUT DG_TRANSPORT_ADDRESS RemoteAddress
    )
/*++

Routine Description:

        This method is called when a packet with DG_PF_FORWARDED arrives.
        This means the endpoint mapper sent it and it includes a
        REMOTE_ADDRESS_INFO structure.  The fn will remove it and store the
        client's remote address in RemoteAddress.

        If the packet was forwarded and not fragmented, we restore it to its
        original state and zap the DG_PF_FORWARDED bit.

Return Value:

    TRUE  if the packet was valid
    FALSE if it appeared malformed

--*/
{
    ASSERT( Packet->DataLength >= Packet->GetPacketBodyLen() );

    //
    // Watch for packets that might crash us.
    //
    unsigned AddressInfoLength = sizeof(REMOTE_ADDRESS_INFO)
                                + Endpoint.TransportInterface->AddressSize;

    if (Packet->DataLength < Packet->GetPacketBodyLen() ||
        Packet->DataLength - Packet->GetPacketBodyLen() < AddressInfoLength)
        {
        #ifdef DEBUGRPC
        DbgPrint("RPC DG: forwarded packet data is impossibly short\n");
        #endif
        return FALSE;
        }

    Packet->DataLength -= AddressInfoLength;

    //
    // If this is a nonfragmented packet, the endpoint info is beyond
    // the stub data and security trailer.
    //
    REMOTE_ADDRESS_INFO * pAddressInfo;

    if (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2)
        {
        pAddressInfo = (REMOTE_ADDRESS_INFO *) Packet->Header.Data;
        }
    else
        {
        // After fixing up the length, we can treat this like a packet
        // sent directly from the client.
        //
        Packet->Header.PacketFlags &= ~DG_PF_FORWARDED;

        pAddressInfo = (REMOTE_ADDRESS_INFO *) ( Packet->Header.Data
                                               + Packet->DataLength );

        if (pAddressInfo->RemoteInfoLength != AddressInfoLength)
            {
            #ifdef DEBUGRPC
            DbgPrint("RPC DG: forwarded packet contains wrong address structure length\n");
            #endif
            return FALSE;
            }

        if (pAddressInfo != AlignPtr( pAddressInfo, REMOTE_ADDRESS_PAD ))
            {
            #ifdef DEBUGRPC
            DbgPrint("RPC DG: forwarded packet contains a misaligned address structure\n");
            #endif
            return FALSE;
            }
        }

    if (pAddressInfo->SecurityInfoPadLength > REMOTE_ADDRESS_PAD ||
        Packet->DataLength < pAddressInfo->SecurityInfoPadLength)
        {
        #ifdef DEBUGRPC
        DbgPrint("RPC DG: forwarded packet's address struct has invalid pad length\n");
        #endif
        return FALSE;
        }

    Packet->DataLength -= pAddressInfo->SecurityInfoPadLength;

    //
    // Record the client's true endpoint.
    //
    RpcpMemoryCopy(
                RemoteAddress,
                pAddressInfo->Address,
                Endpoint.TransportInterface->AddressSize
                );

    return TRUE;
}

#pragma optimize("t", on)


void
ProcessDgServerPacket(
    IN DWORD                 Status,
    IN DG_TRANSPORT_ENDPOINT LocalEndpoint,
    IN void *                PacketHeader,
    IN unsigned long         PacketLength,
    IN DatagramTransportPair *AddressPair
    )
{
    PDG_PACKET Packet = DG_PACKET::FromPacketHeader(PacketHeader);

    Packet->DataLength = PacketLength;

#ifdef INTRODUCE_ERRORS

    if (::ServerDropRate)
        {
        if ((GetRandomCounter() % 100) < ::ServerDropRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DROP, (void *) Uuid, (void *) Type, Frag);

            Packet->Free();
            return;
            }
        }

    if (::ServerDelayRate)
        {
        if ((GetRandomCounter() % 100) < ::ServerDelayRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DELAY, (void *) Uuid, (void *) Type, Frag);

            Sleep(::ServerDelayTime);
            }
        }

#endif

    if (Status == RPC_P_OVERSIZE_PACKET)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async packet is too large\n");
#endif
        Packet->Flags |= DG_PF_PARTIAL;
        Status = RPC_S_OK;
        }

    if (Status != RPC_S_OK)
        {
        LogError(SU_PACKET, EV_STATUS, Packet, 0, Status);
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async receive completed with status 0x%lx\n", Status);
#endif
        Packet->Free();
        return;
        }

    DG_ADDRESS * Address = DG_ADDRESS::FromEndpoint(LocalEndpoint);

    Address->DispatchPacket(Packet, AddressPair);
}


void
DG_ADDRESS::DispatchPacket(
    DG_PACKET * Packet,
    IN DatagramTransportPair *AddressPair
    )
{
    RPC_INTERFACE *    pRpcInterface;
    RPC_SYNTAX_IDENTIFIER   RpcIfSyntaxIdentifier;

    //
    // Mask off bits not used by X/Open or by us.
    // Notice that the current arrangement strips the extra bits before
    // forwarding, so if these bits become important the code will have to
    // be rearranged.
    //
    Packet->Header.RpcVersion   &= 0x0F;
    Packet->Header.PacketType   &= 0x1F;

    Packet->Header.PacketFlags  &= 0x7f;
    Packet->Header.PacketFlags2 &= 0x87;

    //
    // Filter out packets that clients shouldn't send.
    //
    switch (Packet->Header.PacketType)
        {
        case DG_REQUEST:
        case DG_PING:
        case DG_FACK:
        case DG_QUIT:
        case DG_ACK:
            {
            break;
            }

        default:
            {
            LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            FreePacket(Packet);
            return;
            }
        } // switch (PacketType)

    if (Packet->Header.RpcVersion != DG_RPC_PROTOCOL_VERSION)
        {
#ifdef DEBUGRPC
        DbgPrint("dg rpc: packet %x has version %u\n", Packet, Packet->Header.RpcVersion);
        DbgPrint("  length %u\n", Packet->DataLength);

        if (Packet->DataLength > 80)
            {
            Packet->DataLength = 80;
            }

        DumpBuffer(&Packet->Header, Packet->DataLength);
#endif
        SendRejectPacket(Packet, NCA_STATUS_VERSION_MISMATCH, AddressPair->RemoteAddress);
        FreePacket(Packet);
        return;
        }

    ByteSwapPacketHeaderIfNecessary(Packet);

    //
    // Make sure the header is intact.
    // Allow a packet with truncated stub data to pass; the SCALL
    // will send a FACK-with-body to tell the client our max packet size.
    //
    if (Packet->DataLength < sizeof(NCA_PACKET_HEADER))
        {
#ifdef DEBUGRPC
        DbgPrint("dg rpc: packet %x has invalid length\n", Packet);
        DbgPrint("  length %u\n", Packet->DataLength);

        if (Packet->DataLength > 80)
            {
            Packet->DataLength = 80;
            }

        DumpBuffer(&Packet->Header, Packet->DataLength);
        RpcpBreakPoint();
#endif
        LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    //
    // If we are the endpoint mapper, forward packet if necessary.
    //
    if (GlobalRpcServer->pRpcForwardFunction)
        {
        if (TRUE == ForwardPacketIfNecessary(Packet, AddressPair->RemoteAddress))
            {
            LogEvent(SU_ADDRESS, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            FreePacket(Packet);
            return;
            }
        }

    //
    // Exclude RPC header from DataLength.
    //
    Packet->DataLength -= sizeof(NCA_PACKET_HEADER);

    //
    // If the packet includes a client address trailer from the endpoint mapper,
    // remove it and stick the client address in <RemoteAddres>.
    //
    if (Packet->Header.PacketFlags & DG_PF_FORWARDED)
        {
        if (FALSE == CaptureClientAddress(Packet, AddressPair->RemoteAddress))
            {
            LogEvent(SU_ADDRESS, EV_PKT_IN, this, (void *) 4, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            FreePacket(Packet);
            return;
            }
        }

    // Reject pkt if boot time in pkt does not match
    // the server's boot time.
    //
    if (Packet->Header.ServerBootTime != ProcessStartTime &&
        Packet->Header.ServerBootTime != 0)
        {
        if (!(Packet->Header.PacketFlags & DG_PF_MAYBE))
            {
            SendRejectPacket(Packet, NCA_STATUS_WRONG_BOOT_TIME, AddressPair->RemoteAddress);
            }

        LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 5, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    //
    // sometimes OSF packets say they include security info
    // when they don't.
    //
    DeleteSpuriousAuthProto(Packet);

    //
    // Find or create a connection and then give it the packet.
    //
    DG_SCONNECTION * Connection = ServerConnections->FindOrCreate(this, Packet);

    if (!Connection)
        {
        if (Packet->Header.PacketFlags & (DG_PF_BROADCAST | DG_PF_MAYBE))
            {
            //
            // not much point sending an error packet in this case
            //
            }
        else
            {
            if (Packet->Header.PacketType == DG_REQUEST)
                {
                SendRejectPacket(Packet, RPC_S_OUT_OF_MEMORY, AddressPair->RemoteAddress);
                }
            else
                {
                CleanupPacket(&Packet->Header);
                Packet->Header.PacketType    = DG_NOCALL;
                Packet->SetPacketBodyLen(0);
                Packet->SetFragmentNumber(0xffff);
                SetSerialNumber( &Packet->Header, 0);
                SendPacketBack( &Packet->Header, 0, AddressPair->RemoteAddress);
                }
            }

        LogError(SU_ADDRESS, EV_PKT_IN, this, (void *) 6, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    Connection->DispatchPacket(Packet, AddressPair);

    ServerConnections->Prune();
}

#pragma optimize("", on)


PDG_SCONNECTION
DG_ADDRESS::AllocateConnection(
    )
/*++

Routine Description:

    Allocates a new DG_SCONNECTION from the cache or from the heap.

Arguments:

    none

Return Value:

    the call

--*/

{
    PDG_SCONNECTION Connection;

    AddressMutex.Request();

    UUID_HASH_TABLE_NODE * Node = CachedConnections;

    if (Node)
        {
        CachedConnections = Node->pNext;

        AddressMutex.Clear();

        Connection = DG_SCONNECTION::FromHashNode(Node);
        }
    else
        {
        AddressMutex.Clear();

        RPC_STATUS Status = RPC_S_OK;

        Connection = new DG_SCONNECTION(this, &Status);

        if (!Connection)
            {
            return 0;
            }

        if (Status != RPC_S_OK)
            {
            delete Connection;
            return 0;
            }
        }

    LogEvent(SU_SCONN, EV_START, Connection, this);

    return Connection;
}


void
DG_ADDRESS::FreeConnection(
    PDG_SCONNECTION Connection
    )
/*++

Routine Description:

    Returns an unused DG_SCONNECTION to the cache or the heap.

Arguments:

    the connection

Return Value:

    none

--*/

{
    AddressMutex.Request();

    if (CachedConnections)
        {
        AddressMutex.Clear();
        delete Connection;
        return;
        }
    else
        {
        CachedConnections = &Connection->ActivityNode;
        Connection->ActivityNode.pNext = 0;
        AddressMutex.Clear();
        return;
        }

    AddressMutex.Request();

    Connection->ActivityNode.pNext = CachedConnections;

    CachedConnections = &Connection->ActivityNode;

    AddressMutex.Clear();
}


DG_SCALL::DG_SCALL(
    DG_ADDRESS * Address,
    RPC_STATUS * pStatus
    ) :
    DG_PACKET_ENGINE(DG_RESPONSE, Address->AllocatePacket(), pStatus),
    Connection      (0),
    PipeWaitEvent   (0),
    PipeWaitType    (PWT_NONE),
    PipeThreadId    (0),
    State           (CallInit),
    pCachedSid      (0),
    pwsCachedUserName(0),
    dwCachedUserNameSize(0)

/*++

Routine Description:

    This is the constructor for the DG_SCALL class. This class represents a
    call in progress on a server.

Arguments:

    pAddress - The address this call is taking place on.
    pStatus - Where to put a construction error code.

--*/
{
#ifdef MONITOR_SERVER_PACKET_COUNT
    OutstandingPacketCount = 0;
#endif

    DispatchBuffer = 0;

    LogEvent(SU_SCALL, EV_CREATE, this, Address);
    ObjectType = DG_SCALL_TYPE;

    InterlockedIncrement(&ServerCallCount);

    if (*pStatus)
        {
        return;
        }

    SourceEndpoint = &Address->Endpoint;
}


BOOL
DG_SCALL::Cleanup()
{
    if (ReferenceCount)
        {
        LogEvent(SU_SCALL, EV_CLEANUP, this, 0, ReferenceCount);

        ASSERT( State != CallComplete && State != CallInit );
        return FALSE;
        }

    if (pAsync)
        {
        DoPostDispatchProcessing();
        }

    switch (State)
        {
        case CallBeforeDispatch:
        case CallDispatched:

            CleanupReceiveWindow();

        case CallSendingResponse:

            RPC_MESSAGE Message;

            CleanupSendWindow();

            Message.Buffer = DispatchBuffer;
            Message.ReservedForRuntime = 0;
            FreeBuffer(&Message);

            ASSERT( !DispatchBuffer );

            if (Privileges)
                {
                ASSERT( Connection->ActiveSecurityContext );

                Connection->ActiveSecurityContext->DeletePac( Privileges );
                Privileges = 0;
                }

            if (Interface->IsAutoListenInterface())
                {
                Connection->pAddress->EndAutoListenCall();
                Interface->EndAutoListenCall();
                }

            Connection->pAddress->DecrementActiveCallCount();
            if (pAsync)
                {
                Interface->EndCall( FALSE, TRUE );
                }

            Cancelled = FALSE;

            ASSERT( PipeWaitType == PWT_NONE );

            PipeThreadId = 0;

        case CallInit:

            if ( LastReceiveBuffer )
                {
                RPC_MESSAGE Message;

                Message.Buffer = LastReceiveBuffer;
                Message.ReservedForRuntime = 0;
                FreeBuffer(&Message);
                }

#ifdef MONITOR_SERVER_PACKET_COUNT
            ASSERT( OutstandingPacketCount == 0 );
#endif
            Connection->FreeCall(this);
            SetState(CallComplete);
            break;

        case CallComplete:
            {
            LogEvent(SU_SCALL, EV_CLEANUP, this, 0, CallComplete);
            break;
            }

        default:
            {
            LogEvent(SU_SCALL, EV_CLEANUP, this, 0, State);
#ifdef DEBUGRPC
            DbgPrint("RPC: process %x bad call state %x in DG_SCALL::Cleanup\n",
                     GetCurrentProcessId(), State);
#endif
            }
        }

    return TRUE;
}


inline BOOL
DG_SCALL_TABLE::Add(
    PDG_SCALL     Call,
    unsigned long Sequence
    )
{
    //
    // Add the call to the end of the active call list.
    //
    Call->Next = 0;
    Call->Previous = ActiveCallTail;

    if (ActiveCallHead)
        {
        ASSERT( Call->GetSequenceNumber() > ActiveCallTail->GetSequenceNumber() );

        ActiveCallTail->Next = Call;
        }
    else
        {
        ActiveCallHead = Call;
        }

    ActiveCallTail = Call;

    return TRUE;
}

inline void
DG_SCALL_TABLE::Remove(
    PDG_SCALL Call
    )
{
    LogEvent(SU_SCALL, EV_REMOVED, Call, this);

    if (Call->Previous)
        {
        ASSERT( ActiveCallHead != Call );
        Call->Previous->Next = Call->Next;
        }
    else
        {
        ASSERT( ActiveCallHead == Call );
        ActiveCallHead = Call->Next;
        }

    if (Call->Next)
        {
        ASSERT( ActiveCallTail != Call );
        Call->Next->Previous = Call->Previous;
        }
    else
        {
        ASSERT( ActiveCallTail == Call );
        ActiveCallTail = Call->Previous;
        }

    Call->Next = 0;
    Call->Previous = 0;
}


inline PDG_SCALL
DG_SCALL_TABLE::Successor(
    PDG_SCALL Call
    )
{
//    ASSERT( Call == Find(Call->SequenceNumber) );

    return Call->Next;
}


inline PDG_SCALL
DG_SCALL_TABLE::Find(
    unsigned long Sequence
    )
{
    PDG_SCALL Call;

    for (Call = ActiveCallHead; Call; Call = Call->Next)
        {
        if (Call->GetSequenceNumber() == Sequence)
            {
            return Call;
            }

        if (Call->GetSequenceNumber() > Sequence)
            {
            return NULL;
            }
        }

    return NULL;
}


inline PDG_SCALL
DG_SCALL_TABLE::Predecessor(
    unsigned long Sequence
    )
{
    PDG_SCALL Call, Previous = 0;

    for (Call = ActiveCallHead; Call; Call = Call->Next)
        {
        if (Call->GetSequenceNumber() >= Sequence)
            {
            break;
            }

        Previous = Call;
        }

    return Previous;
}


inline void
DG_SCALL_TABLE::RemoveIdleCalls(
    BOOL            Aggressive,
    RPC_INTERFACE * Interface
    )
{
    PDG_SCALL Call;

    for (Call = ActiveCallHead; Call; )
        {
        ASSERT( !Call->InvalidHandle(DG_SCALL_TYPE) );

        PDG_SCALL Next = Call->Next;

        // If the call has in fact expired, it will be removed from this list
        // and added to the connection's cached call list.
        //
        Call->HasExpired( Aggressive, Interface );

        Call = Next;
        }
}


DG_SCONNECTION::DG_SCONNECTION(
    DG_ADDRESS * a_Address,
    RPC_STATUS * pStatus
    ) :
    DG_COMMON_CONNECTION(a_Address->Endpoint.TransportInterface, pStatus),
    pAddress            (a_Address),
    pAssocGroup         (0),
    CachedCalls         (0),
    LastInterface       (0),
    CurrentCall         (0),
    MaxKeySeq           (0),
    fFirstCall          (0),
    BlockIdleCallRemoval(0),
    pMessageMutex       (0)
{
    LogEvent(SU_SCONN, EV_CREATE, this, a_Address);
    ObjectType = DG_SCONNECTION_TYPE;
    fFirstCall = 0;
    InterlockedIncrement(&ServerConnectionCount);
}


DG_SCONNECTION::~DG_SCONNECTION()
{
    InterlockedDecrement(&ServerConnectionCount);
    delete CachedCalls;

    if (pMessageMutex)
        {
        delete pMessageMutex;
        }
}


void
DG_SCONNECTION::Activate(
    PNCA_PACKET_HEADER pHeader,
    unsigned short NewHash
    )
{
    AuthInfo.AuthenticationService = pHeader->AuthProto;
    if (AuthInfo.AuthenticationService)
        {
        DG_SECURITY_TRAILER * pVerifier = (DG_SECURITY_TRAILER *)
                     (pHeader->Data + pHeader->GetPacketBodyLen());

        AuthInfo.AuthenticationLevel   = pVerifier->protection_level;
        AuthInfo.AuthorizationService  = 0;
        AuthInfo.ServerPrincipalName   = 0;
        AuthInfo.PacHandle             = 0;
        }
    else
        {
        AuthInfo.AuthenticationLevel   = RPC_C_AUTHN_LEVEL_NONE;
        AuthInfo.AuthorizationService  = RPC_C_AUTHZ_NONE;
        AuthInfo.ServerPrincipalName   = 0;
        AuthInfo.PacHandle             = 0;
        }

    ActivityNode.Initialize(&pHeader->ActivityId);
    ActivityHint = NewHash;

    LogEvent( SU_SCONN, EV_START, this, IntToPtr(pHeader->ActivityId.Data1), ActivityHint );

    PDG_SCALL Call;

    for (Call = CachedCalls; Call; Call = Call->Next)
        {
        Call->BindToConnection(this);
        }

    Callback.State       = NoCallbackAttempted;
    MaxKeySeq            = 0;
    LowestActiveSequence = 0;
    LowestUnusedSequence = 0;

    TimeStamp = GetTickCount();
}


void
DG_SCONNECTION::Deactivate(
    )
{
    LogEvent(SU_SCONN, EV_STOP, this, pAddress);

    ASSERT( !CurrentCall );

    while (CachedCalls && CachedCalls->Next)
        {
        PDG_SCALL Call = CachedCalls;
        CachedCalls = Call->Next;
        delete Call;
        }

    for (unsigned u = 0; u <= MaxKeySeq; ++u)
        {
        delete SecurityContextDict.Delete(u);
        }

    //
    // Delete all previous interface callback results.
    //
    int cursor;
    InterfaceCallbackResults.Reset(cursor);
    while (InterfaceCallbackResults.Next(cursor, TRUE))
        ;

    ActiveSecurityContext = 0;

    if (pAssocGroup)
        {
        AssociationGroups->DecrementRefCount(pAssocGroup);
        pAssocGroup = 0;
        }

    pAddress->FreeConnection(this);
}


PDG_SCALL
DG_SCONNECTION::AllocateCall()
{
    PDG_SCALL Call = 0;

    if (CachedCalls)
        {
        Call = CachedCalls;
        CachedCalls = CachedCalls->Next;

        ASSERT( !Call->InvalidHandle(DG_SCALL_TYPE) );
        ASSERT( !CachedCalls || !CachedCalls->InvalidHandle(DG_SCALL_TYPE) );
        }
    else
        {
        RPC_STATUS Status = RPC_S_OK;

        Call = new (pAddress->Endpoint.TransportInterface) DG_SCALL(pAddress, &Status);
        if (!Call)
            {
            return 0;
            }

        if (Status)
            {
            delete Call;
            return 0;
            }

        Call->BindToConnection(this);
        }

    //
    // Allow ACTIVE_CALL_TABLE::Remove to succeed even if the call is not in the table.
    //
    Call->Next = Call;
    Call->Previous = Call;

    IncrementRefCount();

    return Call;
}


void
DG_SCONNECTION::FreeCall(
    PDG_SCALL Call
    )
{
    DecrementRefCount();

    if (CurrentCall == Call)
        {
        CurrentCall = ActiveCalls.Successor(Call);
        }

    if (Call->GetSequenceNumber() == LowestActiveSequence)
        {
        PDG_SCALL Successor = ActiveCalls.Successor(Call);

        if (Successor)
            {
            LowestActiveSequence = Successor->GetSequenceNumber();
            }
        else
            {
            LowestActiveSequence = LowestUnusedSequence;
            }
        }

    ActiveCalls.Remove(Call);
    AddCallToCache(Call);
}

void
DG_SCALL::NewCall(
    PDG_PACKET            a_Packet,
    DatagramTransportPair *AddressPair
    )
{
    ASSERT( State == CallInit || State == CallComplete );
    ASSERT( DispatchBuffer == 0 );

    SetState(CallInit);

    SequenceNumber = a_Packet->Header.SequenceNumber;

    pSavedPacket->Header.ObjectId       = a_Packet->Header.ObjectId;
    pSavedPacket->Header.SequenceNumber = SequenceNumber;
    pSavedPacket->Header.PacketFlags    = 0;

    BasePacketFlags = 0;

    DG_PACKET_ENGINE::NewCall();

    RpcpMemoryCopy(RemoteAddress, AddressPair->RemoteAddress, Connection->TransportInterface->AddressSize);
    LocalAddress = *(DWORD *)AddressPair->LocalAddress;

    if ((a_Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2)  &&
        (a_Packet->Header.PacketFlags  & DG_PF_FORWARDED) == 0)
        {
        KnowClientAddress = FALSE;
        }
    else
        {
        KnowClientAddress = TRUE;
        }

    CallWasForwarded  = FALSE;
    CallInProgress    = FALSE;
    Privileges        = 0;
    CancelEventId     = 0;
    pAsync            = 0;

    FinalSendBufferPresent = FALSE;
}


DG_SCALL::~DG_SCALL()
/*++

Routine Description:

    Destructor for the DG_SCALL object.

Arguments:

    <None>

Return Value:

    <None>

--*/
{
#ifdef MONITOR_SERVER_PACKET_COUNT
    ASSERT( OutstandingPacketCount == 0 );
#endif

    InterlockedDecrement(&ServerCallCount);

    delete PipeWaitEvent;
    PipeWaitEvent = 0;

    if (pCachedSid)
       {
       I_RpcFree(pCachedSid);
       }

    if (pwsCachedUserName)
       {
       I_RpcFree(pwsCachedUserName);
       }
}

RPC_STATUS
DG_SCALL::NegotiateTransferSyntax (
    IN OUT PRPC_MESSAGE Message
    )
{
    // this can happen in the callback case only.
    // Datagrams don't really support multiple transfer
    // syntaxes. Return whatever the stub wants, which is
    // already recorded in the transfer syntax field

    return RPC_S_OK;
}


RPC_STATUS
DG_SCALL::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )

/*++

Routine Description:

    This routine is called by the stub to allocate space. This space is to
    be used for output arguments.
    If these args fit into a single packet, then use the first packet
    on the to-be-deleted list.


Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    LogEvent(SU_SCALL, EV_PROC, this, IntToPtr(Message->BufferLength), 'G' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    RPC_STATUS Status = CommonGetBuffer(Message);

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);
    if (Status)
        {
        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        }

#ifdef MONITOR_SERVER_PACKET_COUNT
    DG_PACKET::FromStubData(Message->Buffer)->pCount = &OutstandingPacketCount;
    InterlockedIncrement( &OutstandingPacketCount );
    LogEvent( SU_SCALL, '(', this, DG_PACKET::FromStubData(Message->Buffer), OutstandingPacketCount );
#endif

    return Status;
}


void
DG_SCALL::FreeBuffer (
    IN PRPC_MESSAGE Message
    )

/*++

Routine Description:

    This routine is called to free up the marshalled data after the stub
    is through with it.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call

Return Value:

    <none>
--*/

{
    LogEvent(SU_SCALL, EV_PROC,      this, Message, 'F' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));
    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, 0);

    if (Message->Buffer)
        {
        if (Message->Buffer == DispatchBuffer)
            {
            DispatchBuffer = 0;
            }

        // The ReservedForRuntime field is a local variable of ProcessRpcCall,
        // so it is valid only during dispatch.
        //
        if (State == CallDispatched && Message->ReservedForRuntime)
            {
            PRPC_RUNTIME_INFO Info = (PRPC_RUNTIME_INFO) Message->ReservedForRuntime;
            if (Message->Buffer == Info->OldBuffer)
                {
                Info->OldBuffer = 0;
                }
            }
        CommonFreeBuffer(Message);
        }
}


RPC_STATUS
DG_SCALL::SendReceive (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This routine is called for a user-level callback.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

Revision History:

--*/

{
    Message->ReservedForRuntime = 0;
    FreeBuffer(Message);

    return RPC_S_CALL_FAILED;
}

#pragma optimize("t", on)


void
DG_SCONNECTION::DispatchPacket(
    IN DG_PACKET *           Packet,
    IN DatagramTransportPair *AddressPair
    )
/*++

Routine Description:

    Once a packet's activity UUID is known, this fn dispatches the packet
    to the appropriate DG_SCALL, creating one if necessary.

Arguments:

    Packet        - the packet to dispatch
    AddressPair   - the remote/local address that sent/received the packet

--*/
{
    PNCA_PACKET_HEADER pHeader = &Packet->Header;

#ifdef DEBUGRPC

    RPC_UUID * pInActivityUuid = &pHeader->ActivityId;

    ASSERT(0 == ActivityNode.CompareUuid(pInActivityUuid));

#endif

    TimeStamp = GetTickCount();

    //
    // Make sure the security info is consistent.
    //
    if (AuthInfo.AuthenticationService != pHeader->AuthProto)
        {
        if (pHeader->PacketType != DG_PING &&
            (0 == (pHeader->PacketFlags & DG_PF_MAYBE) || pHeader->AuthProto))
            {
            LogError(SU_SCONN, EV_PKT_IN, this, (void *) 10, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
#ifdef DEBUGRPC
            DbgPrint("dg rpc: %lx dropping %u whose auth service %u is inconsistent w/the activity %u\n",
                      GetCurrentProcessId(), pHeader->PacketType, pHeader->AuthProto, AuthInfo.AuthenticationService);
#endif
            Mutex.Clear();
            Packet->Free();
            return;
            }
        }
    else if (pHeader->AuthProto)
        {
        DG_SECURITY_TRAILER * Verifier = (DG_SECURITY_TRAILER *)
                     (Packet->Header.Data + Packet->GetPacketBodyLen());

        if (Verifier->protection_level != AuthInfo.AuthenticationLevel)
            {
            LogError(SU_SCONN, EV_PKT_IN, this, (void *) 11, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
#ifdef DEBUGRPC
            DbgPrint("dg rpc: %lx dropping pkt whose auth level is inconsistent with the activity\n", GetCurrentProcessId());
#endif
            Mutex.Clear();
            Packet->Free();
            return;
            }
        }

    //
    // Sanity-check the packet length.
    //
    if (0 == (Packet->Flags & DG_PF_PARTIAL))
        {
        if (pHeader->AuthProto)
            {
            if (Packet->DataLength < Packet->GetPacketBodyLen() + sizeof(DG_SECURITY_TRAILER))
                {
                #ifdef DEBUGRPC
                DbgPrint("dg rpc: secure packet truncated from at least %lu to %lu\n",
                         Packet->GetPacketBodyLen() + sizeof(DG_SECURITY_TRAILER), Packet->DataLength);
                #endif

                Mutex.Clear();

                LogError(SU_SCONN, EV_PKT_IN, this, (void *) 8, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                Packet->Free();
                return;
                }
            }
        else
            {
            if (Packet->DataLength < Packet->GetPacketBodyLen())
                {
#ifdef DEBUGRPC
                DbgPrint("dg rpc: packet truncated from %lu to %lu\n", Packet->GetPacketBodyLen(), Packet->DataLength);
#endif
                Mutex.Clear();
                LogError(SU_SCONN, EV_PKT_IN, this, (void *) 9, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                Packet->Free();
                return;
                }
            }
        }

    //
    // [maybe] calls require little of our advanced technology.
    //
    if (pHeader->PacketFlags & DG_PF_MAYBE)
        {
        if (HandleMaybeCall(Packet, AddressPair))
            {
            // mutex released in HandleMaybeCall.
            return;
            }
        }

    //
    // Calls below LowestActiveSequence are dead.
    //
    if (pHeader->SequenceNumber < LowestActiveSequence)
        {
        Mutex.Clear();
        LogEvent(SU_SCONN, EV_PKT_IN, this, (void *) 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        Packet->Free();
        return;
        }

    //
    // Find or allocate the DG_SCALL for this packet.
    //
    PDG_SCALL Call = 0;

    if (pHeader->SequenceNumber < LowestUnusedSequence)
        {
        Call = ActiveCalls.Find(pHeader->SequenceNumber);
        if (!Call)
            {
            Mutex.Clear();
            LogError(SU_SCONN, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
            Packet->Free();
            return;
            }
        }
    else
        {
        Call = HandleNewCall(Packet, AddressPair);
        if (!Call)
            {
            Mutex.Clear();
            Packet->Free();
            return;
            }
        }

    Mutex.VerifyOwned();

    Call->DispatchPacket(Packet, AddressPair->RemoteAddress);

    CallDispatchLoop();

    Mutex.Clear();

    Mutex.VerifyNotOwned();
}


void
DG_SCONNECTION::CallDispatchLoop()
{
    Mutex.VerifyOwned();

    //
    // The loop below is to handle the case where a bunch of async calls arrive
    // more or less simultaneously.  When stub #1 has finished, we should
    // dispatch stub #2 immediately instead of waiting for the client to ping.
    //
    while (CurrentCall && CurrentCall->ReadyToDispatch() &&
           (Callback.State == CallbackSucceeded  ||
            Callback.State == NoCallbackAttempted ))
        {
        PDG_SCALL Call = CurrentCall;

        Call->ProcessRpcCall();

        if (CurrentCall == Call)
            {
            CurrentCall = ActiveCalls.Successor(Call);
            }
        }

    Mutex.VerifyOwned();
}


PDG_SCALL
DG_SCONNECTION::HandleNewCall(
    IN DG_PACKET *           Packet,
    IN DatagramTransportPair *AddressPair
    )
{
    PDG_SCALL Call = 0;

    PNCA_PACKET_HEADER pHeader = &Packet->Header;

    //
    // Only a REQUEST can instantiate a new call.
    //
    if (pHeader->PacketType != DG_REQUEST)
        {
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

        CleanupPacket(&Packet->Header);

        Packet->Header.PacketType = DG_NOCALL;

        Packet->SetPacketBodyLen(0);
        Packet->SetFragmentNumber(0xffff);

        SealAndSendPacket( &pAddress->Endpoint,
                           AddressPair->RemoteAddress,
                           &Packet->Header,
                           0
                           );
        return 0;
        }

    if ((Packet->Header.PacketFlags  & DG_PF_FORWARDED) &&
        (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2) == 0)
        {
        //
        // This packet is not a true request.
        //
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        return 0;
        }

    //
    // See if the call closes a previous call.
    //
    if (0 == (pHeader->PacketFlags2 & DG_PF2_UNRELATED))
        {
        PDG_SCALL PreviousCall = ActiveCalls.Predecessor(pHeader->SequenceNumber);

        if (PreviousCall)
            {
            PreviousCall->FinishSendOrReceive(TRUE);
            PreviousCall->Cleanup();
            }
        }

    LowestUnusedSequence = pHeader->SequenceNumber + 1;

    //
    // Prepare a DG_SCALL to handle the packet.
    //
    Call = AllocateCall();
    LogEvent(SU_SCALL, EV_START, Call, this, pHeader->SequenceNumber);

    if (!Call)
        {
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 4, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        pAddress->SendRejectPacket(Packet, RPC_S_OUT_OF_MEMORY, AddressPair->RemoteAddress);
        return 0;
        }

    Call->NewCall(Packet, AddressPair);

    if (FALSE == ActiveCalls.Add(Call, pHeader->SequenceNumber))
        {
        AddCallToCache(Call);
        LogError(SU_SCONN, EV_PKT_IN, this, (void *) 5, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        pAddress->SendRejectPacket(Packet, RPC_S_OUT_OF_MEMORY, AddressPair->RemoteAddress);
        return 0;
        }

    if (!CurrentCall)
        {
        CurrentCall = Call;
        }

    return Call;
}

#pragma optimize("", on)


BOOL
DG_SCONNECTION::HandleMaybeCall(
    IN DG_PACKET *           Packet,
    IN DatagramTransportPair *AddressPair
    )
{
    PNCA_PACKET_HEADER pHeader = &Packet->Header;

    if (pHeader->PacketType != DG_REQUEST)
        {
        Mutex.Clear();
        Packet->Free();
        return TRUE;
        }

    if (!(pHeader->PacketFlags  & DG_PF_FORWARDED) &&
        !(pHeader->PacketFlags2 & DG_PF2_FORWARDED_2) )
        {
        DG_SCALL * Call = AllocateCall();

        LogEvent(SU_SCALL, EV_START, Call, this, pHeader->SequenceNumber);

        if (!Call)
            {
            Mutex.Clear();
            Packet->Free();
            return TRUE;
            }

        Call->NewCall(Packet, AddressPair);


        Call->DealWithRequest( Packet );

        if (Call->ReadyToDispatch())
            {
            Call->ProcessRpcCall();
            }

        BOOL Result = Call->Cleanup();
        ASSERT( Result );

        Mutex.Clear();
        return TRUE;
        }

    //
    // [maybe] calls fragmented by the ep mapper go through the normal route
    //
    return FALSE;
}


BOOL
DG_SCALL::ReadyToDispatch(
    )
{
    BOOL fReadyToDispatch = FALSE;

    //
    // Before we can execute the call, we need the client's true endpoint,
    // for a forwarded call.  For a non-idempotent call we also need a
    // successful callback.
    //
    // For a stub in a pipes interface, we need only fragment zero;
    // for ordinary interfaces we need all the fragments.
    //
    if (KnowClientAddress && State == CallBeforeDispatch)
        {
        //
        // See if we are ready to dispatch to the stub.
        //
        if (Interface->IsPipeInterface())
            {
            if (pReceivedPackets && 0 == pReceivedPackets->GetFragmentNumber())
                {
                fReadyToDispatch = TRUE;
                }
            }
        else
            {
            if (fReceivedAllFragments)
                {
                fReadyToDispatch = TRUE;
                }
            }
        }

    //
    // Make sure the callback succeeded.
    //
    if (fReadyToDispatch)
        {
        if (0 == (pReceivedPackets->Header.PacketFlags & DG_PF_IDEMPOTENT) &&
            !Connection->pAssocGroup)
            {
            fReadyToDispatch = FALSE;
            }
        }

    return fReadyToDispatch;
}

#pragma optimize("t", on)


void
DG_SCALL::DispatchPacket(
    IN PDG_PACKET Packet,
    IN DG_TRANSPORT_ADDRESS a_RemoteAddress
    )
{
#ifdef MONITOR_SERVER_PACKET_COUNT
    if (Packet->Header.PacketType == DG_REQUEST)
        {
        InterlockedIncrement( &OutstandingPacketCount );
        Packet->pCount = &OutstandingPacketCount;
        LogEvent( SU_SCALL, '(', this, Packet, OutstandingPacketCount );
        }
#endif

    TimeStamp = GetTickCount();

    if (State == CallInit &&
        Packet->Header.PacketType != DG_REQUEST)
        {
        LogError(SU_SCALL, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        if (KnowClientAddress)
            {
            SendFackOrNocall(Packet, DG_NOCALL);
            }

        FreePacket(Packet);
        return;
        }

    if (State == CallComplete)
        {
        LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        FreePacket(Packet);
        return;
        }

    //
    // FORWARDED    FORWARDED_2     Meaning
    // ---------    -----------     -------
    //    no            no          packet sent directly from client
    //    yes           no          packet forwarded by ep mapper (with DREP/ep trailer)
    //    no            yes         packet data forwarded by ep mapper (no trailer)
    //    yes           yes         sent from ep mapper; contains only the DREP/ep trailer
    //
    if (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2)
        {
        CallWasForwarded = TRUE;

        if (Packet->Header.PacketFlags & DG_PF_FORWARDED)
            {
            if (!KnowClientAddress)
                {
                //
                // Record the client's true endpoint.
                //
                RpcpMemoryCopy(
                            RemoteAddress,
                            a_RemoteAddress,
                            Connection->pAddress->Endpoint.TransportInterface->AddressSize
                            );

                KnowClientAddress = TRUE;
                }

            LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

            FreePacket(Packet);
            return;
            }
        }
    else
        {
        ASSERT( (Packet->Header.PacketFlags & DG_PF_FORWARDED) == 0 );
        }

    LogEvent(SU_SCALL, EV_PKT_IN, this, 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

    switch (Packet->Header.PacketType)
        {
        case DG_REQUEST:    DealWithRequest (Packet);  break;
        case DG_PING:       DealWithPing    (Packet);  break;
        case DG_FACK:       DealWithFack    (Packet);  break;
        case DG_QUIT:       DealWithQuit    (Packet);  break;
        case DG_ACK:        DealWithAck     (Packet);  break;
        default:
            {
            FreePacket(Packet);
            FinishSendOrReceive(TRUE);
            Cleanup();
            }
        }
}

#pragma optimize("", on)


void
DG_SCALL::DealWithPing(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Figures out what to do with a PING packet.  It may send a WORKING
    or NOCALL packet, or retransmit response fragments.

Arguments:

    pPacket - the PING packet

Return Value:

    none

--*/
{
    //
    // Ignore security trailer.  The only way extra PINGs can hose me is by
    // chewing up CPU, and authenticating would only make it worse.
    //

    NCA_PACKET_HEADER * pHeader = &pPacket->Header;

    unsigned PacketSeq = pHeader->SequenceNumber;

    unsigned short Serial = ReadSerialNumber(&pPacket->Header);
    if (Serial < ReceiveSerialNumber)
        {
        FreePacket(pPacket);
        return;
        }

    ReceiveSerialNumber = Serial;

    switch (State)
        {
        case CallInit:
            {
            SendFackOrNocall(pPacket, DG_NOCALL);
            break;
            }

        case CallBeforeDispatch:
        case CallDispatched:
        case CallAfterDispatch:
            {
            if (fReceivedAllFragments)
                {
                pHeader->PacketType = DG_WORKING;
                pHeader->SetPacketBodyLen(0);

                SealAndSendPacket(pHeader);
                }
            else
                {
                SendFackOrNocall(pPacket, DG_FACK);
                }
            break;
            }

        case CallSendingResponse:
            {
            SendSomeFragments();
            break;
            }

        case CallComplete:
            {
            break;
            }

        default:
            {
            ASSERT(0 && "invalid call state");
            }
        }

    FreePacket(pPacket);
}


RPC_STATUS
DG_SCONNECTION::VerifyNonRequestPacket(
    DG_PACKET * Packet
    )
{
    if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        if (AuthInfo.AuthenticationService != RPC_C_AUTHN_DCE_PRIVATE )
            {
            SECURITY_CONTEXT * Context = FindMatchingSecurityContext(Packet);

            if (!Context)
                {
                LogError(SU_SCONN, EV_STATUS, this, (void *) 110, RPC_S_ACCESS_DENIED );
                return RPC_S_ACCESS_DENIED;
                }

            return VerifySecurePacket(Packet, Context);
            }
        }

    return RPC_S_OK;
}


RPC_STATUS
DG_SCONNECTION::VerifyRequestPacket(
    DG_PACKET * Packet
    )
{
    if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        SECURITY_CONTEXT * Context = FindMatchingSecurityContext(Packet);

        if (!Context)
            {
            LogError(SU_SCONN, EV_STATUS, this, (void *) 111, RPC_S_ACCESS_DENIED );
            return RPC_S_ACCESS_DENIED;
            }

        return VerifySecurePacket(Packet, Context);
        }

    return RPC_S_OK;
}


void
DG_SCALL::DealWithQuit(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Handles a QUIT packet:

    - If the cancel event ID is new, we cancel the current call and send a QUACK.
    - If the event ID is the current one, we retransmit the QUACK.
    - If the event ID is older than the current one, we ignore the packet.

Arguments:

    the packet

Return Value:

    none

--*/
{
    if (RPC_S_OK != Connection->VerifyNonRequestPacket(pPacket))
        {
        FreePacket(pPacket);
        return;
        }

    QUIT_BODY_0 * pBody = (QUIT_BODY_0 *) pPacket->Header.Data;

    if (pPacket->GetPacketBodyLen() < sizeof(QUIT_BODY_0) ||
        pBody->Version != 0)
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: unknown quit format: version 0x%lx, length 0x%hx\n",
                 pBody->Version, pPacket->GetPacketBodyLen()
                 );
#endif

        FreePacket(pPacket);
        return;
        }

    if (pBody->EventId > CancelEventId)
        {
        CancelEventId = pBody->EventId;
        Cancel(0);
        }

    if (pBody->EventId == CancelEventId)
        {
        pSavedPacket->Header.PacketType     = DG_QUACK;
        pSavedPacket->Header.SequenceNumber = SequenceNumber;
        pSavedPacket->SetPacketBodyLen(sizeof(QUACK_BODY_0));

        QUACK_BODY_0 * pAckBody = (QUACK_BODY_0 *) pSavedPacket->Header.Data;

        pAckBody->Version  = 0;
        pAckBody->EventId = CancelEventId;

        //
        // If the app has picked up the cancel notification, set Accepted == TRUE.
        // This is likely only if the QUIT was  retransmitted.
        //
        if (Cancelled)
            {
            pAckBody->Accepted = FALSE;
            }
        else
            {
            pAckBody->Accepted = TRUE;
            }

        SealAndSendPacket(&pSavedPacket->Header);
        }
    else
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: stale cancel event id %lu\n", pBody->EventId);
#endif
        }

    FreePacket(pPacket);
}


void
DG_SCALL::DealWithAck(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Figures out what to do with an ACK packet.
    It turns off the fragment-retransmission timer.

Arguments:

    pPacket - the ACK packet

Return Value:

    none

--*/

{
    if (State == CallSendingResponse)
        {
        //
        // Accept only an authenticated ACK if the call is secure.
        //
        // Sometimes OSF clients will omit the sec trailer from the ACK.
        //
        if (RPC_S_OK != Connection->VerifyNonRequestPacket(pPacket))
            {
            FreePacket(pPacket);
            return;
            }

        FinishSendOrReceive(FALSE);
        Cleanup();
        }

    FreePacket(pPacket);
}


void
DG_SCALL::DealWithFack(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Figures out what to do with a FACK packet.
    If there is more data to send, it sends the next fragment
    and restarts the fragment-retransmission timer.

Arguments:

    pPacket - the packet

Return Value:

    none

--*/
{
    BOOL Ignore;

    // is call finished?
    if (State != CallSendingResponse)
        {
        FreePacket(pPacket);
        return;
        }

    if (RPC_S_OK != Connection->VerifyNonRequestPacket(pPacket))
        {
        FreePacket(pPacket);
        return;
        }

    //
    // Note fack arrival, and send more packets if necessary.
    //
    TimeoutCount = 0;

    SendBurstLength += 1;

    UpdateSendWindow(pPacket, &Ignore);

    //
    // See whether we need to wake up a call to I_RpcSend, or generate an APC.
    //
    if (IsBufferAcknowledged())
        {
        FinishSendOrReceive(FALSE);
        }

    FreePacket(pPacket);
}

#pragma optimize("t", on)


void
DG_SCALL::DealWithRequest(
    PDG_PACKET      pPacket
    )
{
    RPC_STATUS         Status  = RPC_S_OK;
    PNCA_PACKET_HEADER pHeader = &pPacket->Header;

    ASSERT(pHeader->SequenceNumber == SequenceNumber);

    switch (State)
        {
        case CallInit:
            {
            //
            // Be sure the server is listening and the interface is supported.
            //
            RPC_SYNTAX_IDENTIFIER InterfaceInfo;

            InterfaceInfo.SyntaxVersion = pHeader->InterfaceVersion;
            RpcpMemoryCopy(
                &(InterfaceInfo.SyntaxGUID),
                &(pHeader->InterfaceId),
                sizeof(RPC_UUID)
                );

            if (Connection->LastInterface &&
                0 == Connection->LastInterface->MatchInterfaceIdentifier(&InterfaceInfo))
                {
                Interface = Connection->LastInterface;
                }
            else
                {
                Interface = GlobalRpcServer->FindInterface(&InterfaceInfo);
                Connection->LastInterface = Interface;
                }

            if (!Interface)
                {
                Status = RPC_S_UNKNOWN_IF;
                }
            else if (!GlobalRpcServer->IsServerListening() &&
                     !Interface->IsAutoListenInterface())
                {
                Status = RPC_S_SERVER_TOO_BUSY;

                // If this is a message transport (i.e. Falcon) then
                // wait around for a while before giving up. The user
                // may not have called RpcServerListen() yet...
                if (Connection->TransportInterface->IsMessageTransport)
                   {
                   for (int i=0; i<100; i++)
                       {
                       if (GlobalRpcServer->IsServerListening())
                          {
                          Status = RPC_S_OK;
                          break;
                          }
                       else
                          {
                          Sleep(100);      // Loop 100 * Sleep 100 = 10 seconds.
                          }
                       }
                   }
                }

            if (Status == RPC_S_OK)
                {
                Status = Interface->IsObjectSupported(&pHeader->ObjectId);
                }

            if (Status == RPC_S_OK &&
                Connection->DidCallbackFail())
                {
                Status = RPC_S_CALL_FAILED_DNE;
                }

            if (Status != RPC_S_OK)
                {
                BOOL fSendReject = !(pHeader->PacketFlags & DG_PF_MAYBE);

                FreePacket(pPacket);
                if (fSendReject)
                    {
                    pSavedPacket->Header.SequenceNumber = SequenceNumber;
                    Connection->pAddress->SendRejectPacket(pSavedPacket, Status, RemoteAddress);
                    }

                Cleanup();
                break;
                }

            //
            // The server is listening and the interface is present.
            // We will increment these counters to declare that a call
            // is in progress.
            //
            CallInProgress = TRUE;

            Connection->pAddress->IncrementActiveCallCount();

            if (Interface->IsAutoListenInterface())
                {
                Interface->BeginAutoListenCall() ;
                Connection->pAddress->BeginAutoListenCall() ;
                }

            SetState(CallBeforeDispatch);

            //
            // No "break" here.
            //
            }

        case CallBeforeDispatch:
        case CallDispatched:
        case CallAfterDispatch:
            {
            if (fReceivedAllFragments)
                {
                pHeader->PacketType = DG_WORKING;
                pHeader->SetPacketBodyLen(0);

                SealAndSendPacket(pHeader);
                FreePacket(pPacket);
                break;
                }

            //
            // If the client sent an oversize fragment, send a FACK-with-body
            // telling him our limit.
            //
            if (pPacket->Flags & DG_PF_PARTIAL)
                {
                SendFackOrNocall(pPacket, DG_FACK);

                FreePacket(pPacket);
                break;
                }

            //
            // Add the fragment to the call's packet list.
            //
            BOOL Added = UpdateReceiveWindow(pPacket);

            if (!Added)
                {
                unsigned Frag = (pPacket->Header.PacketType << 16) | pPacket->GetFragmentNumber();

                LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) '!', Frag);
                }

            //
            // See whether we need to wake up a call to I_RpcReceive.
            //
            if (PipeWaitType == PWT_RECEIVE &&
                (fReceivedAllFragments ||
                 (PipeWaitLength && ConsecutiveDataBytes >= PipeWaitLength)))
                {
                FinishSendOrReceive(FALSE);
                }

            if (KnowClientAddress)
                {
                Connection->SubmitCallbackIfNecessary(this, pPacket, RemoteAddress);
                }

            if (!Added)
                {
                FreePacket(pPacket);
                }

            break;
            }

        case CallSendingResponse:
            {
            SendSomeFragments();
            FreePacket(pPacket);
            break;
            }

        default:
            {
            ASSERT(0 && "invalid call state");
            break;
            }
        }
}


void
DG_SCALL::ProcessRpcCall()
/*++

Routine Description:

    This routine is called when we determine that all the packets for a
    given call have been received.

--*/
{
    BOOL                    ObjectUuidSpecified;
    PNCA_PACKET_HEADER      pHeader = &pReceivedPackets->Header;
    PRPC_DISPATCH_TABLE DispatchTableToUse;

    ASSERT(State == CallBeforeDispatch);

    SetState(CallDispatched);

    //
    // Save the object uuid if necessary.
    //
    if (pHeader->ObjectId.IsNullUuid())
        {
        ObjectUuidSpecified = FALSE;
        }
    else
        {
        ObjectUuidSpecified = TRUE;
        pSavedPacket->Header.ObjectId.CopyUuid(&pHeader->ObjectId);
        }

    RpcRuntimeInfo.Length = sizeof(RPC_RUNTIME_INFO) ;
    RpcMessage.ReservedForRuntime = &RpcRuntimeInfo ;

    RpcMessage.Handle = (RPC_BINDING_HANDLE) this;
    RpcMessage.ProcNum = pHeader->OperationNumber;
    RpcMessage.TransferSyntax = 0;
    RpcMessage.ImportContext = 0;

    RpcMessage.RpcFlags = PacketToRpcFlags(pHeader->PacketFlags);

    unsigned OriginalSequenceNumber = SequenceNumber;
    unsigned long SavedAwayRpcFlags = RpcMessage.RpcFlags;

    RPC_STATUS  Status = RPC_S_OK;

    //
    // For secure RPC, verify packet integrity.
    //
    if (pHeader->AuthProto)
        {
        PDG_PACKET pScan = pReceivedPackets;

        do
            {
            Status = Connection->VerifyRequestPacket(pScan);
            if (Status)
                {
                LogError( SU_SCALL, EV_STATUS, this, UlongToPtr(0x200), Status );
                }
            pScan = pScan->pNext;
            }
        while (pScan && Status == RPC_S_OK);
        }

    //
    // Coalesce packet data.
    //
    if (RPC_S_OK == Status)
        {
        RpcMessage.Buffer = 0;
        RpcMessage.BufferLength = 0;
        Status = AssembleBufferFromPackets(&RpcMessage);
        }

    if (Status != RPC_S_OK)
        {
        InitErrorPacket(pSavedPacket, DG_REJECT, Status);
        SealAndSendPacket(&pSavedPacket->Header);

        Cleanup();
        return;
        }

    DispatchBuffer = RpcMessage.Buffer;

    //
    // The thread context is used by routines like RpcBindingInqAuthClient
    // when the user specifies hBinding == 0.
    //
    RpcpSetThreadContext(this);

    //
    // Make sure the thread is not impersonating.
    //
    ASSERT(0 == QueryThreadSecurityContext());

    TerminateWhenConvenient = FALSE;
    AsyncStatus = RPC_S_OK;

    //
    // Time to deal with the interface security callback. If it is required,
    // the call must be secure.  If we have already made a callback using
    // the current auth context, we can use the cached results; otherwise,
    // we should call back.
    //
    if (Interface->IsSecurityCallbackReqd())
        {
        Status = Connection->MakeApplicationSecurityCallback(Interface, this);
        if (Status)
            {
            LogError( SU_SCALL, EV_STATUS, this, UlongToPtr(0x201), Status );
            }
        }

    if (TerminateWhenConvenient)
        {
        RpcpSetThreadContext(0);
        Cleanup();
        return;
        }

    //
    // If this is a message based transport then we will need the
    // message mutex for call serialization:
    //
    if (Connection->TransportInterface->IsMessageTransport)
        {
        if (!Connection->pMessageMutex)
            {
            Connection->MessageMutexInitialize(&Status);
            }
        }

    //
    // If no errors have occurred, we are ready to dispatch.  Release
    // the call mutex, call the server stub, and grab the mutex again.
    //
    BOOL StubWasCalled = FALSE;

    if (RPC_S_OK == Status)
        {
        ASSERT(Interface);

        //
        // doc:appref
        //
        // SetAsyncHandle adds a reference to the call on behalf of the app,
        // so that the call cannot be deleted even though the manager routine
        // has completed and no Send or Receive calls are pending.
        // That reference should be removed when one of the following occurs:
        //
        //      a) (obsolete)
        //      b) the app sends the last buffer (RPC_BUFFER_PARTIAL not set)
        //      c) a Send() returns something other than OK or SEND_INCOMPLETE
        //      d) the app calls AbortAsyncCall
        //
        IncrementRefCount();

        Connection->Mutex.Clear();

        //
        // If this is a message based call (MQ) then take a mutex for
        // serialization:
        //
        if (Connection->TransportInterface->IsMessageTransport)
           {
           ASSERT(Connection->pMessageMutex);

           Connection->pMessageMutex->Request();

           Connection->TransportInterface->AllowReceives(
                               SourceEndpoint->TransportEndpoint,
                               FALSE,
                               FALSE );
           }
        else
           {
           //
           // Normal, non-message based calls:
           //
           Connection->pAddress->CheckThreadPool();
           }

        StubWasCalled = TRUE;

        RPC_STATUS ExceptionCode = 0;

        DispatchTableToUse = Interface->GetDefaultDispatchTable();
        if ( !ObjectUuidSpecified )
            {
            Status = Interface->DispatchToStub(
                &RpcMessage,                               // msg
                0,                                      // callback flag
                DispatchTableToUse,                     // dispatch table to use for
                                                        // this interface
                &ExceptionCode                          // exception code
                );
            }
        else
            {
            Status = Interface->DispatchToStubWithObject(
                &RpcMessage,                               // msg
                &pSavedPacket->Header.ObjectId,         // object uuid
                0,                                      // callback flag
                DispatchTableToUse,                     // dispatch table to use for
                                                        // this interface
                &ExceptionCode                          // exception code
                );
            }

        //
        // If this is a message based call (MQ) then clear the mutex:
        //
        if (Connection->TransportInterface->IsMessageTransport)
           {
           Connection->pMessageMutex->Clear();

           Connection->TransportInterface->AllowReceives(
                               SourceEndpoint->TransportEndpoint,
                               TRUE,
                               FALSE );

           Connection->pAddress->CheckThreadPool();
           }

        RpcMessage.RpcFlags = SavedAwayRpcFlags;

        if (Status == RPC_S_PROCNUM_OUT_OF_RANGE ||
            Status == RPC_S_UNSUPPORTED_TYPE     ||
            Status == RPC_S_SERVER_TOO_BUSY      ||
            Status == RPC_S_NOT_LISTENING        ||
            Status == RPC_S_UNKNOWN_IF)
            {
            StubWasCalled = FALSE;
            }

        Connection->Mutex.Request();
        DecrementRefCount();

        if (Status == RPC_P_EXCEPTION_OCCURED)
            {
            if (pAsync)
                {
                //
                // Abort any lingering receive.
                //
                FinishSendOrReceive(TRUE);
                DecrementRefCount();

                //
                // Later code will see TerminateWhenConvenient and will not send a fault packet.
                //
                InitErrorPacket(pSavedPacket, DG_FAULT, ExceptionCode);
                SealAndSendPacket(&pSavedPacket->Header);
                }

            Status = ExceptionCode;
            }

        //
        // If the manager routine impersonated the client,
        // restore the thread to its native security context.
        //
        RevertToSelf();
        }

    RpcpSetThreadContext(0);

    //
    // Remember that a sync stub may have called the completion routine,
    // or sent some [out] pipe data.
    //

    //
    // Don't send a response of any sort for a [maybe] call.
    //
    if (RpcMessage.RpcFlags & RPC_NCA_FLAGS_MAYBE)
        {
        if (!Status)
            {
            FreeBuffer(&RpcMessage);
            }
        return;
        }

    //
    // Has the client cancelled the call or another server thread aborted it?
    //
    if (TerminateWhenConvenient)
        {
//        if (!Status)
//            {
//            FreeBuffer(&Message);
//            }
        Cleanup();
        return;
        }

    ASSERT( State == CallDispatched      ||
            State == CallSendingResponse );

    //
    // Ordinary error?
    //
    if (Status != RPC_S_OK)
        {
        if (StubWasCalled)
            {
            InitErrorPacket(pSavedPacket, DG_FAULT, Status);
            }
        else
            {
            InitErrorPacket(pSavedPacket, DG_REJECT, Status);
            }

        SealAndSendPacket(&pSavedPacket->Header);

        Cleanup();
        return;
        }

    //
    // No error; the call is still in progress.
    //
    if (pAsync)
        {
        if (State == CallDispatched)
            {
            ASSERT( fReceivedAllFragments || Interface->IsPipeInterface() );

            SetState(CallAfterDispatch);
            }
        }
    else
        {
        ASSERT( fReceivedAllFragments );

        if (State == CallSendingResponse)
            {
            ASSERT( Interface->IsPipeInterface() );
            }

        SetState(CallSendingResponse);


        //
        // Send the static [out] call parameters; [out] pipes were sent by the stub.
        //
        SetFragmentLengths();

        PushBuffer(&RpcMessage);

        CleanupReceiveWindow();
        }
}

#pragma optimize("", on)


void
DG_SCALL::AddPacketToReceiveList(
    PDG_PACKET  pPacket
    )

/*++

Routine Description:

    Adds a packet to the receive list and lets the caller know whether this
    call is ready to be processed.

Arguments:

    pPacket - the packet to add to the list.

Return Value:



Revision History:

--*/

{
    PNCA_PACKET_HEADER pHeader = &pPacket->Header;

    unsigned Frag = (pPacket->Header.PacketType << 16) | pPacket->GetFragmentNumber();

    BOOL Added = UpdateReceiveWindow(pPacket);

    if (!Added)
        {
        LogEvent(SU_SCALL, EV_PKT_IN, this, (void *) '!', Frag);
        }

    //
    // See whether we need to wake up a call to I_RpcReceive.
    //
    if (fReceivedAllFragments ||
        (PipeWaitLength && ConsecutiveDataBytes >= PipeWaitLength))
        {
        FinishSendOrReceive(FALSE);
        }
}


RPC_STATUS
DG_SCALL::ImpersonateClient()
/*++

Routine Description:

    Force the current thread to impersonate the client of this DG_SCALL.
    Note that the current thread might not be the thread executing the
    server manager routine.

Arguments:

    none

Return Value:

    result of impersonating, or RPC_S_NO_CONTEXT_AVAILABLE if this is
    an insecure call.

--*/
{
    RPC_STATUS Status;

    if (!Connection->ActiveSecurityContext)
        {
        return RPC_S_NO_CONTEXT_AVAILABLE;
        }

    Status = SetThreadSecurityContext(Connection->ActiveSecurityContext);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    Status = Connection->ActiveSecurityContext->ImpersonateClient();
    if (RPC_S_OK != Status)
        {
        ClearThreadSecurityContext();
        }

    return Status;
}

RPC_STATUS
DG_SCALL::RevertToSelf (
    )
{
    SECURITY_CONTEXT * SecurityContext = ClearThreadSecurityContext();

    if (SecurityContext)
        {
        SecurityContext->RevertToSelf();
        }

    return(RPC_S_OK);
}


RPC_STATUS
DG_SCALL::InquireAuthClient (
    OUT RPC_AUTHZ_HANDLE * Privs,
    OUT RPC_CHAR * * ServerPrincipalName, OPTIONAL
    OUT unsigned long * AuthenticationLevel,
    OUT unsigned long * AuthenticationService,
    OUT unsigned long * pAuthorizationService,
    IN  unsigned long   Flags
    )
{
    if (0 == Connection->ActiveSecurityContext)
        {
        if ( (Connection->TransportInterface->InquireAuthClient) )
           {
           RPC_STATUS  Status;
           SID        *pSid;

           Status = Connection->TransportInterface->InquireAuthClient(
                                                      RemoteAddress,
                                                      ServerPrincipalName,
                                                      &pSid,
                                                      AuthenticationLevel,
                                                      AuthenticationService,
                                                      pAuthorizationService );
           if ( (Status == RPC_S_OK)
                && (ARGUMENT_PRESENT(ServerPrincipalName)))
              {
              Status = ConvertSidToUserW(pSid,(RPC_CHAR**)Privs);
              }

           return Status;
           }
        else
           {
           return RPC_S_BINDING_HAS_NO_AUTH;
           }
        }

    if (AuthenticationLevel)
        {
        *AuthenticationLevel = Connection->ActiveSecurityContext->AuthenticationLevel;
        }

    if (AuthenticationService)
        {
        *AuthenticationService = Connection->ActiveSecurityContext->AuthenticationService;
        }

    if (Privs || pAuthorizationService)
        {
        if (!Privileges)
            {
            Connection->ActiveSecurityContext->GetDceInfo(&Privileges, &AuthorizationService);
            }

        if (Privs)
            {
            *Privs = Privileges;
            }

        if (pAuthorizationService)
            {
            *pAuthorizationService = AuthorizationService;
            }
        }

    if (ARGUMENT_PRESENT(ServerPrincipalName))
        {
        RPC_STATUS Status;

        Status = GlobalRpcServer->InquirePrincipalName(
                                       *AuthenticationService,
                                       ServerPrincipalName
                                       );

        ASSERT(Status == RPC_S_OK           ||
               Status == RPC_S_OUT_OF_MEMORY );

        return Status;
        }

    return(RPC_S_OK);
}


RPC_STATUS
DG_SCALL::GetAssociationContextCollection (
    OUT ContextCollection **CtxCollection
    )
{
    RPC_STATUS Status = Connection->GetAssociationGroup(RemoteAddress);
    if (Status)
        {
        return Status;
        }

    ASSERT( Connection->pAssocGroup );

    Status = Connection->pAssocGroup->GetAssociationContextCollection(CtxCollection);

    return (Status);
}


void
DG_SCALL::InquireObjectUuid (
    OUT RPC_UUID * ObjectUuid
    )
{
    ObjectUuid->CopyUuid(&pSavedPacket->Header.ObjectId);
}


RPC_STATUS
DG_SCALL::ToStringBinding (
    OUT RPC_CHAR * * StringBinding
    )
/*++

Routine Description:

    We need to convert this particular SCALL into a string binding.
    Typically, we get the SCALL in Message structure. An SCall is associated
    with a particular address. We just ask the address to create a string
    binding

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK - The operation completed successfully.

    RPC_S_OUT_OF_MEMORY - We do not have enough memory available to
        allocate space for the string binding.

--*/
{
    BINDING_HANDLE * BindingHandle;
    RPC_STATUS Status;

    BindingHandle = Connection->pAddress->InquireBinding();
    if (BindingHandle == 0)
        return(RPC_S_OUT_OF_MEMORY);

    BindingHandle->SetObjectUuid(&pSavedPacket->Header.ObjectId);
    Status = BindingHandle->ToStringBinding(StringBinding);
    BindingHandle->BindingFree();
    return Status;
}


RPC_STATUS
DG_SCALL::ConvertToServerBinding (
    OUT RPC_BINDING_HANDLE * pServerBinding
    )
{
        return CreateReverseBinding(pServerBinding, FALSE);
}


RPC_STATUS
DG_SCALL::CreateReverseBinding (
    OUT RPC_BINDING_HANDLE * pServerBinding,
    BOOL IncludeEndpoint
    )
{
    RPC_STATUS Status;
    RPC_CHAR * ClientAddress;
    RPC_CHAR * ClientEndpoint;
    RPC_CHAR * StringBinding;

    ClientAddress = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * Connection->TransportInterface->AddressStringSize);
    if (!ClientAddress)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Status = Connection->TransportInterface->QueryAddress(RemoteAddress, ClientAddress);
    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    if (IncludeEndpoint)
        {
        ClientEndpoint = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * Connection->TransportInterface->EndpointStringSize);
        if (!ClientEndpoint)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        Status = Connection->TransportInterface->QueryEndpoint(RemoteAddress, ClientEndpoint);
        if ( Status != RPC_S_OK )
            {
            return(Status);
            }

        Status = RpcStringBindingCompose(0,
                                          Connection->pAddress->InqRpcProtocolSequence(),
                                          ClientAddress,
                                          ClientEndpoint,
                                          0,
                                          &StringBinding
                                          );
        }
    else
        {
        Status = RpcStringBindingCompose(0,
                                          Connection->pAddress->InqRpcProtocolSequence(),
                                          ClientAddress,
                                          0,
                                          0,
                                          &StringBinding
                                          );
        }

    if ( Status != RPC_S_OK )
        {
        return(Status);
        }

    Status = RpcBindingFromStringBinding(StringBinding, pServerBinding);
    if (RPC_S_OK == Status)
        {
        Status = RpcBindingSetObject(*pServerBinding,
                                     (UUID *) &pSavedPacket->Header.ObjectId
                                     );

        RpcStringFree(&StringBinding);
        }

    return(Status);
}


RPC_STATUS
DG_SCALL::ConvertSidToUserW(
    IN  SID       *pSid,
    OUT RPC_CHAR **ppwsPrincipal
    )
{
     // Called by InquireAuthClient to convert the SID passed up by the
     // client to a "Domain\User" string. The DG_SCALL cashes the last
     // SID (pCachedSid). If the new SID to convert matches the cashed
     // SID then just return that one (don't have to hit the domain server).
     //
     #define      MAX_USERNAME_SIZE    256
     #define      MAX_DOMAIN_SIZE      256
     RPC_STATUS   Status = RPC_S_OK;
     WCHAR        wsName[MAX_USERNAME_SIZE];
     WCHAR        wsDomain[MAX_DOMAIN_SIZE];
     DWORD        dwNameSize;
     DWORD        dwDomainSize;
     DWORD        dwSize;
     SID_NAME_USE sidType;


     if (  (pCachedSid) && (pSid)
        && (IsValidSid(pSid)) && (EqualSid(pCachedSid,pSid)) )
        {
        //
        // Great! SIDs match...
        //
        #ifdef DBG
           DbgPrint("DG_SCALL::ConvertSidToUserW(): Cash hit.\n");
        #endif
        *ppwsPrincipal = (RPC_CHAR*)I_RpcAllocate(dwCachedUserNameSize);
        if (*ppwsPrincipal)
           RpcpStringCopy(*ppwsPrincipal,pwsCachedUserName);
        else
           Status = RPC_S_OUT_OF_MEMORY;
        }
     else if ( (pSid) && (IsValidSid(pSid)) )
        {
        dwNameSize = sizeof(wsName);
        dwDomainSize = sizeof(wsDomain);

        if (LookupAccountSidW( NULL,
                               pSid,
                               wsName,
                               &dwNameSize,
                               wsDomain,
                               &dwDomainSize,
                               &sidType) )
           {
           //
           // Got a new SID, remember it for next time.
           //
           *ppwsPrincipal = 0;

           if (pCachedSid)
              {
              I_RpcFree(pCachedSid);
              pCachedSid = 0;
              }

           if (pwsCachedUserName)
              {
              I_RpcFree(pwsCachedUserName);
              pwsCachedUserName = 0;
              }

           dwCachedUserNameSize = 0;

           dwSize = GetLengthSid(pSid);
           pCachedSid = (SID*)I_RpcAllocate(dwSize);
           if (pCachedSid == 0)
              {
              return RPC_S_OUT_OF_MEMORY;
              }

           if (!CopySid(dwSize,pCachedSid,pSid))
              {
              return RPC_S_OUT_OF_MEMORY;
              }

           dwSize = sizeof(RPC_CHAR) * (2 + wcslen(wsName) + wcslen(wsDomain));
           pwsCachedUserName = (RPC_CHAR*)I_RpcAllocate(dwSize);
           if (pwsCachedUserName == 0)
              {
              return RPC_S_OUT_OF_MEMORY;
              }

           RpcpStringCopy(pwsCachedUserName,wsDomain);
           RpcpStringCat(pwsCachedUserName,RPC_CONST_STRING("\\"));
           RpcpStringCat(pwsCachedUserName,wsName);

           *ppwsPrincipal = (RPC_CHAR*)I_RpcAllocate(dwSize);
           if (*ppwsPrincipal)
              {
              RpcpStringCopy(*ppwsPrincipal,pwsCachedUserName);
              dwCachedUserNameSize = dwSize;
              }
           else
              {
              I_RpcFree(pCachedSid);
              pCachedSid = 0;
              dwCachedUserNameSize = 0;
              Status = RPC_S_OUT_OF_MEMORY;
              }
           }
        else
           {
           //
           // LookupAccountSidW() failed. Lookup its error and return.
           //
           Status = GetLastError();
           *ppwsPrincipal = 0;
           }
        }
     else
        {
        #ifdef DBG
           DbgPrint("DG_SCALL::ConvertSidToUserW(): No SID to convert.\n");
        #endif
        *ppwsPrincipal = 0;
        }

     return Status;
}




DG_SCALL *
DG_SCONNECTION::RemoveIdleCalls(
    DG_SCALL *      List,
    BOOL            Aggressive,
    RPC_INTERFACE * Interface
    )
{
    if (TRUE == Mutex.TryRequest())
        {
        if (BlockIdleCallRemoval)
            {
            Mutex.Clear();
            return 0;
            }

        long CurrentTime = GetTickCount();

        PDG_SCALL Node = 0;

        if (CachedCalls)
            {
            for (Node = CachedCalls->Next; Node; Node = Node->Next)
                {
                ASSERT( !Node->InvalidHandle(DG_SCALL_TYPE) );
                ASSERT(Node->TimeStamp != 0x31415926);

                if (CurrentTime - Node->TimeStamp > IDLE_SCALL_LIFETIME)
                    {
                    break;
                    }
                }
            }

        ActiveCalls.RemoveIdleCalls(Aggressive, Interface);

        if (Node)
            {
            PDG_SCALL Next = Node->Next;
            Node->Next = 0;
            Node = Next;
            }

        Mutex.Clear();

        while (Node)
            {
            ASSERT( !Node->InvalidHandle(DG_SCALL_TYPE) );
            ASSERT(Node->TimeStamp != 0x31415926);

            PDG_SCALL Next = Node->Next;

            Node->Next = List;
            List = Node;
            Node = Next;
            }
        }

    return List;
}


BOOL
DG_SCONNECTION::HasExpired()
{
    if (GetTickCount() - TimeStamp > FIVE_MINUTES_IN_MSEC &&
        0 == ReferenceCount)
        {
        CLAIM_MUTEX Lock(Mutex);

        if (GetTickCount() - TimeStamp > FIVE_MINUTES_IN_MSEC &&
            0 == ReferenceCount)
            {
            return TRUE;
            }
        }

    return FALSE;
}


BOOL
DG_SCALL::HasExpired(
    BOOL            Aggressive,
    RPC_INTERFACE * ExpiringInterface
    )
{
    long CurrentTime = CurrentTimeInMsec();

    if (CurrentTime - TimeStamp < 40 * 1000 )
        {
        return FALSE;
        }

    AsyncStatus = RPC_S_CALL_FAILED;

    if (PipeWaitType != PWT_NONE)
        {
#ifdef DEBUGRPC
        DbgPrint("RPC DG: aborting an abandoned pipe operation on %x\n", this);
#endif
        FinishSendOrReceive(TRUE);
        }
    else if (State == CallDispatched    ||
             State == CallAfterDispatch )
        {
#ifdef DEBUGRPC

        DbgPrint("RPC DG: possible blockage: scall %lx has been dispatched for %u seconds\n",
                 this, (CurrentTime - TimeStamp)/1000 );
#endif
        return FALSE;
        }

    return Cleanup();
}


PDG_SCONNECTION
SERVER_ACTIVITY_TABLE::FindOrCreate(
    DG_ADDRESS * Address,
    DG_PACKET *  Packet
    )
/*++

Routine Description:

    Looks for connection matching the packet's activity uuid.  If the activity
    hint is not 0xffff, we search in that hash bucket, otherwise we create
    a hash value and look there.

    If a connection is found or created, its mutex is taken.

Arguments:

    pPacket - data to find call (activity uuid and activity hint)

Return Value:

    the new call, or zero

--*/
{
    unsigned Hash = Packet->Header.ActivityHint;

    if (Hash == 0xffff)
        {
        Hash = MakeHash(&Packet->Header.ActivityId);
        }

    //
    // This can happen only if someone is sending garbage.
    //
    if (Hash >= BUCKET_COUNT)
        {
        return 0;
        }

    RequestHashMutex(Hash);

    PDG_SCONNECTION Connection = 0;
    UUID_HASH_TABLE_NODE * pNode = UUID_HASH_TABLE::Lookup(
                                        &Packet->Header.ActivityId,
                                        Hash
                                        );
    if (pNode)
        {
        Connection = DG_SCONNECTION::FromHashNode(pNode);

        if (FALSE == Connection->Mutex.TryRequest())
            {
            Connection->TimeStamp = GetTickCount();
            ReleaseHashMutex(Hash);

            // If the connection is busy more than five minutes,
            // then the connection will go away and this will crash.
            //
            Connection->Mutex.Request();
            }
        else
            {
            ReleaseHashMutex(Hash);
            }
        }
    else if (Packet->Header.PacketType == DG_REQUEST)
        {
        if ((Packet->Header.PacketFlags  & DG_PF_FORWARDED)       &&
            (Packet->Header.PacketFlags2 & DG_PF2_FORWARDED_2) == 0)
            {
            //
            // This packet doesn't have correct auth info.  We can't
            // instantiate a connection without it.
            //
            }
        else
            {
            Connection = Address->AllocateConnection();
            if (Connection)
                {
                ServerConnections->BeginIdlePruning();
                Connection->Activate(&Packet->Header, (unsigned short) Hash);
                Connection->Mutex.Request();
                UUID_HASH_TABLE::Add(&Connection->ActivityNode, Hash);
                }
            }

        ReleaseHashMutex(Hash);
        }
    else
        {
        ReleaseHashMutex(Hash);
        }

    return Connection;
}


void SERVER_ACTIVITY_TABLE::Prune()

/*++

Routine Description:

    Remove idle connections and calls from the activity table.
    Each call to this fn cleans one bucket.

--*/

{
    unsigned    Bucket;
    long        CurrentTime = GetTickCount();

    //
    // Don't check the whole table too often.
    //
    if (CurrentTime - LastFinishTime < IDLE_SCONNECTION_SWEEP_INTERVAL)
        {
        return;
        }

    Bucket = InterlockedIncrement(&BucketCounter) % BUCKET_COUNT;

    PruneSpecificBucket(Bucket, FALSE, 0);

    if (Bucket == BUCKET_COUNT-1)
        {
        LastFinishTime = CurrentTime;
        }
}

void
SERVER_ACTIVITY_TABLE::BeginIdlePruning()
{
    if (!fPruning)
        {
        if (InterlockedIncrement(&fPruning) > 1)
            {
            InterlockedDecrement(&fPruning);
            return;
            }

        IdleScavengerTimer.Initialize( PruneWhileIdle, 0 );
        DelayedProcedures->Add(&IdleScavengerTimer, IDLE_SCONNECTION_SWEEP_INTERVAL, FALSE);
        }
}

void
SERVER_ACTIVITY_TABLE::PruneWhileIdle( PVOID unused )
{
    if (GetTickCount() - ServerConnections->LastFinishTime > IDLE_SCONNECTION_SWEEP_INTERVAL)
        {
        BOOL fEmpty = ServerConnections->PruneEntireTable( 0 );
        if (fEmpty)
            {
            InterlockedDecrement(&fPruning);
            return;
            }
        }

    DelayedProcedures->Add(&ServerConnections->IdleScavengerTimer, IDLE_SCONNECTION_SWEEP_INTERVAL+5000, FALSE);
}

BOOL
SERVER_ACTIVITY_TABLE::PruneEntireTable(
   RPC_INTERFACE * Interface
   )
{
    BOOL Empty = TRUE;
    unsigned Bucket;

    //
    // Make sure this thread has an associated THREAD.
    // This won't be true for the RpcServerListen thread.
    //
    ThreadSelf();

    for (Bucket = 0; Bucket < BUCKET_COUNT; ++Bucket)
        {
        Empty &= PruneSpecificBucket( Bucket, TRUE, Interface );
        }

    LastFinishTime = GetTickCount();

    return Empty;
}


BOOL
SERVER_ACTIVITY_TABLE::PruneSpecificBucket(
    unsigned        Bucket,
    BOOL            Aggressive,
    RPC_INTERFACE * Interface
    )
{
    if (!Buckets[Bucket])
        {
        return TRUE;
        }

    //
    // Scan the bucket for idle calls and connections.
    // Remove them from the table, but don't delete them.
    //
    DG_SCALL *      IdleCalls = 0;

    UUID_HASH_TABLE_NODE * pNode;
    UUID_HASH_TABLE_NODE * IdleConnections = 0;

    unsigned Inactive = 0;

    RequestHashMutex(Bucket);

    pNode = Buckets[Bucket];
    while (pNode)
        {
        UUID_HASH_TABLE_NODE * pNext = pNode->pNext;

        DG_SCONNECTION * Connection = DG_SCONNECTION::FromHashNode(pNode);

        IdleCalls = Connection->RemoveIdleCalls( IdleCalls, Aggressive, Interface );

        if (Connection->HasExpired())
            {
            UUID_HASH_TABLE::Remove(pNode, Bucket);

            pNode->pNext = IdleConnections;
            IdleConnections = pNode;
            }

        pNode = pNext;
        }

    BOOL Empty = TRUE;

    if (Buckets[Bucket])
        {
        Empty = FALSE;
        }

    ReleaseHashMutex(Bucket);

    //
    // Now delete the idle objects.
    //
    while (IdleCalls)
        {
        ++Inactive;

        DG_SCALL * Call = IdleCalls;
        IdleCalls = Call->Next;

        delete Call;
        }

    while (IdleConnections)
        {
        DG_SCONNECTION * Connection = DG_SCONNECTION::FromHashNode(IdleConnections);

        IdleConnections = IdleConnections->pNext;

        Connection->Deactivate();
        }

    LogEvent(SU_STABLE, EV_PRUNE, IntToPtr(Bucket), 0, Inactive);

    return Empty;
}


ASSOCIATION_GROUP *
ASSOC_GROUP_TABLE::FindOrCreate(
    RPC_UUID * pUuid,
    unsigned short InitialPduSize
    )
/*++

Routine Description:

    Looks for an association group with the given UUID.
    If one is not found then a new one is created.

Arguments:

    pUuid - CAS uuid to find or create

Return Value:

    ptr to the association group if found or created
    zero if not found and a new one could not be created

--*/
{
    ASSOCIATION_GROUP * pGroup;
    unsigned Hash = MakeHash(pUuid);

    RequestHashMutex(Hash);

    UUID_HASH_TABLE_NODE * pNode = UUID_HASH_TABLE::Lookup(pUuid, Hash);
    if (pNode)
        {
        ASSOCIATION_GROUP::ContainingRecord(pNode)->IncrementRefCount();
        }
    else
        {
        RPC_STATUS Status = RPC_S_OK;

        pGroup = new ASSOCIATION_GROUP(pUuid, InitialPduSize, &Status);
        if (!pGroup || Status != RPC_S_OK)
            {
            delete pGroup;
            pGroup = 0;
            }
        else
            {
            pNode = &pGroup->Node;

            UUID_HASH_TABLE::Add(pNode, Hash);
            }
        }

    ReleaseHashMutex(Hash);

    if (pNode)
        {
        return ASSOCIATION_GROUP::ContainingRecord(pNode);
        }
    else
        {
        return 0;
        }
}


void
ASSOC_GROUP_TABLE::DecrementRefCount(
    ASSOCIATION_GROUP * pClient
    )
{
    UUID_HASH_TABLE_NODE * pNode = &pClient->Node;

    unsigned Hash = MakeHash(&pNode->Uuid);

    RequestHashMutex(Hash);

    pClient->RequestMutex();

    if (0 == pClient->DecrementRefCount())
        {
        UUID_HASH_TABLE::Remove(pNode, Hash);
        delete pClient;
        }
    else
        {
        pClient->ClearMutex();
        }

    ReleaseHashMutex(Hash);
}


inline RPC_STATUS
DG_SCONNECTION::CreateCallbackBindingAndReleaseMutex(
    DG_TRANSPORT_ADDRESS RemoteAddress
    )
{
    RPC_STATUS Status;

    RPC_CHAR * StringBinding;
    RPC_CHAR * Address;
    RPC_CHAR * Endpoint;

    unsigned Length;
    unsigned AddressLength;
    unsigned EndpointLength;
    unsigned ProtocolLength;

    Callback.Binding = 0;

    Address  = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * pAddress->Endpoint.TransportInterface->AddressStringSize);
    Endpoint = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * pAddress->Endpoint.TransportInterface->EndpointStringSize);

    if (!Address || !Endpoint)
        {
        Mutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    Status = pAddress->Endpoint.TransportInterface->QueryAddress(RemoteAddress, Address);
    if ( Status != RPC_S_OK )
        {
        Mutex.Clear();
        return Status;
        }

    Status = pAddress->Endpoint.TransportInterface->QueryEndpoint(RemoteAddress, Endpoint);
    if ( Status != RPC_S_OK )
        {
        Mutex.Clear();
        return Status;
        }

    ProtocolLength = StringLengthWithEscape(pAddress->InqRpcProtocolSequence());
    AddressLength  = StringLengthWithEscape(Address);
    EndpointLength = StringLengthWithEscape(Endpoint);

    StringBinding = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) *
                                        ( ProtocolLength
                                        + 1
                                        + AddressLength
                                        + 1
                                        + EndpointLength
                                        + 1
                                        + 1
                                        ));
    if (!StringBinding)
        {
        Mutex.Clear();
        return RPC_S_OUT_OF_MEMORY;
        }

    StringCopyEscapeCharacters(StringBinding, pAddress->InqRpcProtocolSequence());

    Length = ProtocolLength;

    StringBinding[Length++] = RPC_CONST_CHAR(':');

    StringCopyEscapeCharacters(StringBinding + Length, Address);

    Length += AddressLength;

    StringBinding[Length++] = RPC_CONST_CHAR('[');

    StringCopyEscapeCharacters(StringBinding + Length, Endpoint);

    Length += EndpointLength;

    StringBinding[Length++] = RPC_CONST_CHAR(']');
    StringBinding[Length]   = 0;

    //
    // We are entering the expensive phase of the callback.  Let's release
    // the call mutex so that other threads can respond to client PINGs etc.
    //
    IncrementRefCount();
    Mutex.Clear();

    pAddress->CheckThreadPool();

    //
    // Create a binding handle to the client endpoint.  It's important to do it
    // outside the call mutex because it causes a lot of memory allocation.
    //
    Status = RpcBindingFromStringBinding(StringBinding, &Callback.Binding);

    return Status;
}


inline void
DG_SCONNECTION::SubmitCallbackIfNecessary(
    PDG_SCALL   Call,
    PDG_PACKET  Packet,
    DG_TRANSPORT_ADDRESS RemoteAddress
    )
/*++

Routine Description:

    doc:callback

    This function determines whether the server should issue a conv callback
    to the client, and submits an async call if so.

    - The first non-idempotent call on a given activity ID requires a callback
      in order to guarantee the call wasn't executed by a prior server
      instance. If the activity stays quiet for 5 minutes and the
      DG_SCONNECTION is thrown away, the next call will force another callback.

    - Each security context requires a callback; this allows the cleint to
      transfer the session key securely to the server.

    In NT 5.0 beta 1:

        This function submits callbacks from the 'msconv' interface because that
        notifies an NT5 or better client that the server supports the
        DG_PF2_UNRELATED bit to overlap calls.

    In NT 5 beta 2:

        The callback request is sent with the DG_PF2_UNRELATED bit set, even
        though it doesn'nt need to be set.  That tells teh client that overlapped
        calls are OK.

    If ms_conv_who_are_you_auth fails, the server will try conv_who_are_you_auth.

    If ms_conv_who_are_you2 fails, the server will try conv_who_are_you2, which
    is supported by NT 3.51 and NT 4.0, as well as all current DCE systems;
    if that fails, we try conv_who_are_you which is all that NT 3.5 and the old
    UNIX NCA servers support. I doubt that we have ever tested interop with NCA...

    A connection is allowed only a single oustanding callback at a time. This
    should not be a significant restriction.

    The rule is that a thread must hold the connection mutex if it wants to
    change Callback.State from NoCallbackAttempted to any other value. It can
    then release the mutex and party on the other members of Callback, since
    all other instances of this procedure will exit immediately
    if Callback.State != NoCallbackAttempted.

    In a nutshell, this function
    - creates a binding handle to the client,
    - releases the connection mutex,
    - fills Callback.* with the info needed by FinishConvCallback(), and
    - calls an conv or msconv stub

    When the async call is complete (or fails), some thread will call
    ConvNotificationRoutine() which will either submit another async call
    or call FinishConvCallback() to mop up. For a successful secure callback,
    FinishConvCallback() will also call AcceptThirdLeg and then set
    ActiveSeurityContext to be the newly created context. For a failed
    callback, FinishConvCallback will notify the DG_SCALL that started
    all this, so it can send a REJECT to the client.

    A wrinkle is that two objects need access to Packet: the DG_SCALL
    is using it as [in] stub data, and this fn uses it for AcceptFirstTime.
    So future code shuffling needs to make sure the call doesn't die during
    a callback, and that the call doesn't delete the packet until
    AcceptFirstTime is complete.

--*/

{
    RPC_STATUS Status = RPC_S_OK;

    //
    // Has a callback already been attempted?
    //
    if (Callback.State != NoCallbackAttempted)
        {
        return;
        }

    //
    // Is a callback unnecessary?
    //
    DG_SECURITY_TRAILER * Verifier = (DG_SECURITY_TRAILER *)
                (Packet->Header.Data + Packet->GetPacketBodyLen());

    unsigned char KeySequenceNumber = Verifier->key_vers_num;

    if (Packet->Header.AuthProto == 0)
        {
        if (pAssocGroup ||
            (Packet->Header.PacketFlags & DG_PF_IDEMPOTENT))
            {
            return;
            }
        }
    else
        {
        //
        // See if we have already established a security context
        // for this client.
        //
        SECURITY_CONTEXT * CurrentContext = SecurityContextDict.Find(KeySequenceNumber);
        if (CurrentContext)
            {
            return;
            }
        }

    //
    // A callback is needed.
    //
    Callback.State           = SetupInProgress;
    Callback.Call            = Call;
    Callback.Binding         = 0;
    Callback.Credentials     = 0;
    Callback.TokenBuffer     = 0;
    Callback.ResponseBuffer  = 0;
    Callback.SecurityContext = 0;
    Callback.ThirdLegNeeded  = FALSE;
    Callback.DataRep         = 0x00ffffff & (*(unsigned long *) Packet->Header.DataRep);
    Callback.KeySequence     = KeySequenceNumber;

    Callback.Call->IncrementRefCount();

    Status = CreateCallbackBindingAndReleaseMutex( RemoteAddress );

    if (Status)
        {
        FinishConvCallback(Status);
        return;
        }

    Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
    if (Status)
        {
        FinishConvCallback(Status);
        return;
        }

    Callback.AsyncState.NotificationType    = RpcNotificationTypeCallback;
    Callback.AsyncState.u.NotificationRoutine = ConvNotificationRoutine;
    Callback.AsyncState.UserInfo            = this;

    if (Packet->Header.AuthProto)
        {
        unsigned long AuthenticationService = Packet->Header.AuthProto;
        unsigned long AuthenticationLevel   = Verifier->protection_level;

        //
        // OSF clients sometimes send these levels.
        //
        if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT ||
            AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL)
            {
            AuthenticationLevel = RPC_C_AUTHN_LEVEL_PKT;
            }

        //
        // Create an empty security context.
        //
        CLIENT_AUTH_INFO    Info;

        Info.AuthenticationService = AuthenticationService;
        Info.AuthenticationLevel   = AuthenticationLevel;
        Info.ServerPrincipalName = 0;
        Info.PacHandle           = 0;
        Info.AuthorizationService= 0;

        Callback.SecurityContext = new SECURITY_CONTEXT(&Info, KeySequenceNumber, TRUE, &Status);

        if (!Callback.SecurityContext)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        CallTestHook( TH_RPC_SECURITY_SERVER_CONTEXT_CREATED, Callback.SecurityContext, this );

        if (Status)
            {
            FinishConvCallback(Status);
            return;
            }

        //
        // Get my security credentials.
        //
        Status = pAddress->Server->AcquireCredentials(
                                      AuthenticationService,
                                      AuthenticationLevel,
                                      &Callback.Credentials
                                      );
        if (Status)
            {
            LogError(SU_SCONN, EV_STATUS, this, (void *) 100, Status );
            FinishConvCallback(Status);
            return;
            }

        //
        // Allocate challenge and response buffers.
        //
        Callback.TokenLength    = Callback.Credentials->MaximumTokenLength();

        Callback.TokenBuffer    = new unsigned char [2 * Callback.TokenLength];
        Callback.ResponseBuffer = Callback.TokenBuffer + Callback.TokenLength;

        if (!Callback.TokenBuffer)
            {
            FinishConvCallback(RPC_S_OUT_OF_MEMORY);
            return;
            }

        //
        // Get a skeletal context and a challenge from the security package.
        //
        DCE_INIT_SECURITY_INFO DceInitSecurityInfo;

        SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
        SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
        SECURITY_BUFFER InputBuffers[4];
        SECURITY_BUFFER OutputBuffers[4];
        DCE_INIT_SECURITY_INFO InitSecurityInfo;

        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers  = 4;
        InputBufferDescriptor.pBuffers  = InputBuffers;

        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer   = &Packet->Header;
        InputBuffers[0].cbBuffer   = sizeof(NCA_PACKET_HEADER);

        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer   = Packet->Header.Data;
        InputBuffers[1].cbBuffer   = Packet->GetPacketBodyLen();

        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer   = Verifier;
        InputBuffers[2].cbBuffer   = sizeof(DG_SECURITY_TRAILER);

        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer   = &DceInitSecurityInfo;
        InputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers  = 4;
        OutputBufferDescriptor.pBuffers  = OutputBuffers;

        OutputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[0].pvBuffer   = 0;
        OutputBuffers[0].cbBuffer   = 0;

        OutputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        OutputBuffers[1].pvBuffer   = 0;
        OutputBuffers[1].cbBuffer   = 0;

        OutputBuffers[2].BufferType = SECBUFFER_TOKEN;
        OutputBuffers[2].pvBuffer   = Callback.TokenBuffer;
        OutputBuffers[2].cbBuffer   = Callback.TokenLength;

        OutputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        OutputBuffers[3].pvBuffer   = &DceInitSecurityInfo;
        OutputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        DceInitSecurityInfo.PacketType           = ~0;
        DceInitSecurityInfo.AuthorizationService = ~0;
        DceInitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = ~0;
        DceInitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = KeySequenceNumber;
        DceInitSecurityInfo.DceSecurityInfo.AssociationUuid       = Packet->Header.ActivityId;

        Status = Callback.SecurityContext->AcceptFirstTime(
                                           Callback.Credentials,
                                           &InputBufferDescriptor,
                                           &OutputBufferDescriptor,
                                           AuthenticationLevel,
                                           Callback.DataRep,
                                           FALSE
                                           );
        LogEvent( SU_SCONN, EV_SEC_ACCEPT1, this, IntToPtr(Status), I_RpcGetExtendedError());

        switch (Status)
            {
            case RPC_S_OK:
                {
                break;
                }

            case RPC_P_CONTINUE_NEEDED:
                {
                Callback.ThirdLegNeeded = TRUE;
                break;
                }

            case RPC_P_COMPLETE_NEEDED:
                {
#ifdef DEBUGRPC
                DbgPrint("RPC: dg does not support RPC_P_COMPLETE_NEEDED from AcceptSecurityContext\n");
#endif
                break;
                }

            case RPC_P_COMPLETE_AND_CONTINUE:
                {
                Callback.ThirdLegNeeded = TRUE;
#ifdef DEBUGRPC
                DbgPrint("RPC: dg does not support RPC_P_COMPLETE_AND_CONTINUE from AcceptSecurityContext\n");
#endif
                break;
                }

            default:
                {
                LogError( SU_SCONN, EV_SEC_ACCEPT1, this, IntToPtr(Status), I_RpcGetExtendedError());
                FinishConvCallback(Status);
                return;
                }
            }

        Callback.TokenLength = OutputBuffers[2].cbBuffer;

        Callback.State = ConvWayAuthInProgress;
        Callback.DataIndex = 0;
        Callback.Status = 0;

        _conv_who_are_you_auth(
            &Callback.AsyncState,
            Callback.Binding,
            (UUID *) &ActivityNode.Uuid,
            ProcessStartTime,
            Callback.TokenBuffer,
            Callback.TokenLength,
            Callback.Credentials->MaximumTokenLength(),
            &Callback.ClientSequence,
            &Callback.CasUuid,
            Callback.ResponseBuffer,
            &Callback.ResponseLength,
            &Callback.Status
            );

        //
        // We have to take the mutex before leaving this fn, regardless of error.
        // Do it here so the check of Callback.State is protected.
        //
        Mutex.Request();

        //
        // If there is an error, see whether it is caused a notification.  If so,
        // ConvCallCompleted() has changed the callback state and this thread should do nothing.
        // If the state is unchanged, this thread must clean up.
        //
        if (Callback.Status && Callback.State == ConvWayAuthInProgress)
            {
            FinishConvCallback(Callback.Status);

            //
            // The mutex was recursively claimed by FinishConvCallback().
            // Get rid of the recursive one.
            //
            Mutex.Clear();
            }
        }
    else
        {
        BlockIdleCallRemoval = FALSE;

        Callback.State = ConvWay2InProgress;
        Callback.Status = 0;

        _conv_who_are_you2(
            &Callback.AsyncState,
            Callback.Binding,
            (UUID *) &ActivityNode.Uuid,
            ProcessStartTime,
            &Callback.ClientSequence,
            &Callback.CasUuid,
            &Callback.Status
            );

        //
        // We have to take the mutex before leaving this fn, regardless of error.
        // Do it here so the check of Callback.State is protected.
        //
        Mutex.Request();

        //
        // If there is an error, see whether it is caused a notification.  If so,
        // ConvCallCompleted() has changed the callback state and this thread should do nothing.
        // If the state is unchanged, this thread must clean up.
        //
        if (Callback.Status && Callback.State == ConvWay2InProgress)
            {
            FinishConvCallback(Callback.Status);

            //
            // The mutex was recursively claimed by FinishConvCallback().
            // Get rid of the recursive one.
            //
            Mutex.Clear();
            }
        }

    Mutex.VerifyOwned();
}


RPC_STATUS
DG_SCONNECTION::FinishConvCallback(
    RPC_STATUS Status
    )
{
    BlockIdleCallRemoval = FALSE;

    if (!Status && Callback.ThirdLegNeeded )
        {
#ifdef TRY_MSCONV_INTERFACE

        ASSERT( Callback.State ==   ConvWayAuthInProgress ||
                Callback.State == MsConvWayAuthInProgress );

#else

        ASSERT( Callback.State ==   ConvWayAuthInProgress ||
                Callback.State ==   ConvWayAuthMoreInProgress );

#endif
        //
        // Give the challenge response to the security package.
        //
        DCE_INIT_SECURITY_INFO DceInitSecurityInfo;

        SECURITY_BUFFER_DESCRIPTOR InputBufferDescriptor;
        SECURITY_BUFFER_DESCRIPTOR OutputBufferDescriptor;
        SECURITY_BUFFER InputBuffers[4];
        SECURITY_BUFFER OutputBuffers[4];

        InputBufferDescriptor.ulVersion = 0;
        InputBufferDescriptor.cBuffers  = 4;
        InputBufferDescriptor.pBuffers  = InputBuffers;

        InputBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[0].pvBuffer   = 0;
        InputBuffers[0].cbBuffer   = 0;

        InputBuffers[1].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        InputBuffers[1].pvBuffer   = 0;
        InputBuffers[1].cbBuffer   = 0;

        InputBuffers[2].BufferType = SECBUFFER_TOKEN;
        InputBuffers[2].pvBuffer   = Callback.ResponseBuffer;
        InputBuffers[2].cbBuffer   = Callback.DataIndex;

        InputBuffers[3].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        InputBuffers[3].pvBuffer   = &DceInitSecurityInfo;
        InputBuffers[3].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

        DceInitSecurityInfo.PacketType           = ~0;
        DceInitSecurityInfo.AuthorizationService = ~0;
        DceInitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = ~0;
        DceInitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = Callback.KeySequence;
        DceInitSecurityInfo.DceSecurityInfo.AssociationUuid       = ActivityNode.Uuid;

        OutputBufferDescriptor.ulVersion = 0;
        OutputBufferDescriptor.cBuffers  = 0;
        OutputBufferDescriptor.pBuffers  = 0;

        Status = Callback.SecurityContext->AcceptThirdLeg(
                          Callback.DataRep,
                          &InputBufferDescriptor,
                          &OutputBufferDescriptor
                          );

        LogEvent( SU_SCONN, EV_SEC_ACCEPT3, this, IntToPtr(Status), I_RpcGetExtendedError());
        }

    if (Callback.Binding)
        {
        RpcBindingFree(&Callback.Binding);
        }

    delete Callback.TokenBuffer;

    if (Callback.Credentials)
        {
        Callback.Credentials->DereferenceCredentials();
        }

    if (RPC_S_OK == Status)
        {
        Mutex.Request();
        DecrementRefCount();

        Callback.Call->DecrementRefCount();

        if (0 == pAssocGroup)
            {
            ASSOCIATION_GROUP * Cas;

            Cas = AssociationGroups->FindOrCreate(&Callback.CasUuid,
                                                  (unsigned short) pAddress->Endpoint.TransportInterface->BasePduSize);
            if (0 == Cas)
                {
                // We want to retry later.
                Callback.State = NoCallbackAttempted;
                delete Callback.SecurityContext;
                return RPC_S_OUT_OF_MEMORY;
                }

            pAssocGroup = Cas;
            }

        if (Callback.SecurityContext)
            {
            SecurityContextDict.Insert(
                Callback.SecurityContext->AuthContextId,
                Callback.SecurityContext
                );

            if (MaxKeySeq <= Callback.KeySequence)
                {
                MaxKeySeq = Callback.KeySequence;
                ActiveSecurityContext = Callback.SecurityContext;
                }
            }
        else
            {
            ASSERT( Callback.State !=   ConvWayAuthInProgress &&
                    Callback.State != MsConvWayAuthInProgress );
            }

        if (Callback.ClientSequence == CurrentCall->GetSequenceNumber())
            {
            Callback.State = CallbackSucceeded;
            }
        else
            {
            Callback.State = CallbackFailed;
            Status         = RPC_S_CALL_FAILED;

            PDG_SCALL Call = Callback.Call;
            do
                {
                PDG_SCALL Next;

                Next = ActiveCalls.Successor(Call);
                Call->ConvCallbackFailed(Status);
                Call = Next;
                }
            while ( Call );
            }
        }
    else
        {
        LogError( SU_SCONN, EV_SEC_ACCEPT3, this, IntToPtr(Status), I_RpcGetExtendedError());

        delete Callback.SecurityContext;

        Mutex.Request();
        DecrementRefCount();

        if (RPC_S_SERVER_UNAVAILABLE == Status ||
            RPC_S_CALL_FAILED_DNE    == Status ||
            RPC_S_CALL_FAILED        == Status ||
            RPC_S_PROTOCOL_ERROR     == Status)
            {
            Status = NCA_STATUS_WHO_ARE_YOU_FAILED;
            }

        if (Status == RPC_S_OUT_OF_MEMORY    ||
            Status == RPC_S_OUT_OF_RESOURCES )
            {
            Callback.State = NoCallbackAttempted;
            }
        else
            {
            Callback.State = CallbackFailed;
            }

        Callback.Call->DecrementRefCount();

        //
        // Map SSPI errors to access-denied.  SSPI errors are facility code 0009 (see windows.h),
        // therefore all security errors are of the form 0x8009xxxx.  (Again, see wondows.h)
        //
        if (0x80090000UL == (Status & 0xffff0000UL))
            {
#ifdef DEBUGRPC
            if (Status != SEC_E_NO_IMPERSONATION     &&
                Status != SEC_E_UNSUPPORTED_FUNCTION )
                {
                PrintToDebugger("RPC DG: mapping security error %lx to access-denied\n", Status);
                }
#endif
            Status = RPC_S_SEC_PKG_ERROR;
            }

        PDG_SCALL Call = Callback.Call;
        do
            {
            PDG_SCALL Next;

            Next = ActiveCalls.Successor(Call);
            Call->ConvCallbackFailed(Status);
            Call = Next;
            }
        while ( Call );
        }

    return Status;
}


void
ConvCallCompletedWrapper(
                         PVOID Connection
                         )
{
    PDG_SCONNECTION(Connection)->ConvCallCompleted();
}

// it's a static procedure

void RPC_ENTRY
DG_SCONNECTION::ConvNotificationRoutine (
    RPC_ASYNC_STATE * pAsync,
    void *            Reserved,
    RPC_ASYNC_EVENT   Event
    )
{
    //
    // This function is called when the callback completes.  The current thread
    // is holding the connection mutex for the callback, so we can't linger
    // in this procedure.  The PostEvent call will cause all the expensive
    // operations to occur in a separate thread.
    //

    PDG_SCONNECTION Connection = PDG_SCONNECTION(pAsync->UserInfo);

    ASSERT( Event == RpcCallComplete );
    ASSERT( Connection->Callback.AsyncState.UserInfo == Connection );

    Connection->pAddress->Endpoint.TransportInterface->PostEvent( DG_EVENT_CALLBACK_COMPLETE, Connection);
}

void
DG_SCONNECTION::ConvCallCompleted()
{
    RPC_STATUS Status;

    //
    // Ensure a thread is listening for new packets.  We are in an expensive function.
    //
    pAddress->CheckThreadPool();

    do
        {
        Status = RpcAsyncCompleteCall( &Callback.AsyncState, 0 );
        if (RPC_S_INVALID_ASYNC_CALL != Status)
            {
            break;
            }
        Sleep(10);
        }
    while ( 1 );

    LogEvent(SU_SCONN, EV_STATUS, this, 0, Status);

    ASSERT( Status != RPC_S_INVALID_ASYNC_CALL &&
                  Status != RPC_S_INVALID_ASYNC_HANDLE );

    if (!Status)
        {
        if (Callback.Status == ERROR_SHUTDOWN_IN_PROGRESS)
            {
            Callback.Status = RPC_P_CLIENT_SHUTDOWN_IN_PROGRESS;
            }

        Status = Callback.Status;
        LogEvent(SU_SCONN, EV_STATUS, this, 0, Status);
        }

    if (!Status)
        {
        if (Callback.State == ConvWayInProgress)
            {
            Status = UuidCreate((UUID *) &Callback.CasUuid);
            if (Status == RPC_S_UUID_LOCAL_ONLY)
                {
                Status = RPC_S_OK;
                }

            if (Status)
                {
                FinishConvCallback(Status);
                Mutex.Clear();
                return;
                }
            }
        else if (Callback.State == ConvWayAuthInProgress ||
                 Callback.State == ConvWayAuthMoreInProgress )
            {
            Callback.DataIndex += Callback.ResponseLength;
            }

        FinishConvCallback(Status);

        CallDispatchLoop();
        Mutex.Clear();
        }
    else switch (Callback.State)
        {
        case ConvWayAuthInProgress:
        case ConvWayAuthMoreInProgress:
            {
            if (RPC_S_SERVER_UNAVAILABLE == Status ||
                RPC_S_CALL_FAILED_DNE    == Status ||
                RPC_S_CALL_FAILED        == Status ||
                RPC_S_PROTOCOL_ERROR     == Status)
                {
                Callback.Status = NCA_STATUS_WHO_ARE_YOU_FAILED;
                }

            Callback.DataIndex += Callback.ResponseLength;

            if (NCA_STATUS_PARTIAL_CREDENTIALS == Status)
                {
                Callback.State = ConvWayAuthMoreInProgress;
                Callback.Status = 0;

                Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
                if (Status)
                    {
                    FinishConvCallback(Status);
                    Mutex.Clear();
                    return;
                    }

                if (Callback.Credentials->MaximumTokenLength() <= Callback.DataIndex)
                    {
                    FinishConvCallback(RPC_S_PROTOCOL_ERROR);
                    Mutex.Clear();
                    return;
                    }

                _conv_who_are_you_auth_more(
                    &Callback.AsyncState,
                    Callback.Binding,
                    (UUID *) &ActivityNode.Uuid,
                    ProcessStartTime,
                    Callback.DataIndex,
                    Callback.Credentials->MaximumTokenLength() - Callback.DataIndex,
                    Callback.ResponseBuffer + Callback.DataIndex,
                    &Callback.ResponseLength,
                    &Callback.Status
                    );

                //
                // If there is an error, see whether it is caused a notification.  If so,
                // ConvCallCompleted() has changed the callback state and this thread should do nothing.
                // If the state is unchanged, this thread must clean up.
                //
                if (Callback.Status)
                    {
                    Mutex.Request();

                    if (Callback.State == ConvWayAuthMoreInProgress)
                        {
                        FinishConvCallback(Callback.Status);

                        //
                        // The mutex was recursively claimed by FinishConvCallback().
                        //
                        Mutex.Clear();
                        Mutex.Clear();
                        return;
                        }
                    else
                        {
                        Mutex.Clear();
                        }
                    }

                break;
                }

            FinishConvCallback(Callback.Status);
            Mutex.Clear();
            break;
            }

        case ConvWay2InProgress:
            {
            Callback.State = ConvWayInProgress;
            Callback.Status = 0;

            Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
            if (Status)
                {
                FinishConvCallback(Status);
                Mutex.Clear();
                return;
                }

            Callback.AsyncState.NotificationType    = RpcNotificationTypeCallback;
            Callback.AsyncState.u.NotificationRoutine = ConvNotificationRoutine;
            Callback.AsyncState.UserInfo            = this;

            _conv_who_are_you(
                &Callback.AsyncState,
                Callback.Binding,
                (UUID *) &ActivityNode.Uuid,
                ProcessStartTime,
                &Callback.ClientSequence,
                &Callback.Status
                );

            //
            // If there is an error, see whether it is caused a notification.  If so,
            // ConvCallCompleted() has changed the callback state and this thread should do nothing.
            // If the state is unchanged, this thread must clean up.
            //
            if (Callback.Status)
                {
                Mutex.Request();

                if (Callback.State == ConvWayInProgress)
                    {
                    FinishConvCallback(Callback.Status);

                    //
                    // The mutex was recursively claimed by FinishConvCallback().
                    //
                    Mutex.Clear();
                    Mutex.Clear();
                    return;
                    }
                else
                    {
                    Mutex.Clear();
                    }
                }

            break;
            }

        case ConvWayInProgress:
            {
            FinishConvCallback(Callback.Status);
            Mutex.Clear();
            break;
            }

        default:
            {
#ifdef DBG
            DbgPrint("RPC dg: unexpected callback state %x in connection %x\n", Callback.State, this);
            ASSERT( 0 );
            break;
#endif
            }
        }

    Mutex.VerifyNotOwned();
}


RPC_STATUS
DG_SCONNECTION::GetAssociationGroup(
    DG_TRANSPORT_ADDRESS RemoteAddress
    )
{
    if (pAssocGroup)
        {
        return RPC_S_OK;
        }

    Mutex.Request();

    if (pAssocGroup)
        {
        Mutex.Clear();
        return RPC_S_OK;
        }

    if (Callback.State == NoCallbackAttempted)
        {
        //
        // A callback is needed.
        //
        RPC_STATUS Status;

        Callback.State           = SetupInProgress;
        Callback.Binding         = 0;
        Callback.Credentials     = 0;
        Callback.TokenBuffer     = 0;
        Callback.ResponseBuffer  = 0;
        Callback.SecurityContext = 0;
        Callback.ThirdLegNeeded  = FALSE;
        Callback.DataRep         = 0;       // used only by secure c/b
        Callback.KeySequence     = 0;       // used only by secure c/b

        Callback.Call            = (DG_SCALL *) RpcpGetThreadContext();

        if (NULL == Callback.Call)
            {
            Callback.State = CallbackFailed;
            Mutex.Clear();
            return RPC_S_OUT_OF_MEMORY;
            }

        Callback.Call->IncrementRefCount();

        Status = CreateCallbackBindingAndReleaseMutex( RemoteAddress );

        if (Status)
            {
            FinishConvCallback(Status);
            Mutex.Clear();
            return Status;
            }

        Status = RpcAsyncInitializeHandle(&Callback.AsyncState, sizeof(Callback.AsyncState));
        if (Status)
            {
            FinishConvCallback(Status);
            Mutex.Clear();
            return Status;
            }

        Callback.AsyncState.NotificationType    = RpcNotificationTypeCallback;
        Callback.AsyncState.u.NotificationRoutine = ConvNotificationRoutine;
        Callback.AsyncState.UserInfo            = this;

        //
        // If this were a secure connection, we wouldn't get into the
        // unmarshalling routine w/o a callback, and we would be here now.
        // So use conv_who_are_you2.
        //
        Callback.State = ConvWay2InProgress;
        Callback.Status = 0;

        _conv_who_are_you2(
            &Callback.AsyncState,
            Callback.Binding,
            (UUID *) &ActivityNode.Uuid,
            ProcessStartTime,
            &Callback.ClientSequence,
            &Callback.CasUuid,
            &Callback.Status
            );

        //
        // If there is an error, see whether it is caused a notification.  If so,
        // ConvCallCompleted() has changed the callback state and this thread should do nothing.
        // If the state is unchanged, this thread must clean up.
        //
        if (Callback.Status)
            {
            Mutex.Request();

            if (Callback.State == ConvWay2InProgress)
                {
                FinishConvCallback(Callback.Status);

                //
                // The mutex was recursively claimed by FinishConvCallback().
                //
                Mutex.Clear();
                Mutex.Clear();
                return Callback.Status;
                }
            else
                {
                Mutex.Clear();
                }
            }
        }
    else
        {
        Mutex.Clear();
        }

    Mutex.VerifyNotOwned();

    //
    // Wait for the result.  This is not quite as efficient as using event notification,
    // but it's a lot simpler, and that's important at this late stage of the ship process.
    //
    while (Callback.State != CallbackSucceeded &&
           Callback.State != CallbackFailed)
        {
        Sleep(500);
        }

    return Callback.Status;
}



RPC_STATUS
DG_SCONNECTION::MakeApplicationSecurityCallback(
    RPC_INTERFACE * Interface,
    PDG_SCALL Call
    )
{
    RPC_STATUS Status = RPC_S_OK;

    if (!ActiveSecurityContext)
        {
        LogError(SU_SCONN, EV_STATUS, this, (void *) 112, RPC_S_ACCESS_DENIED );
        Status = RPC_S_ACCESS_DENIED;
        }
    else
        {
        unsigned Info = InterfaceCallbackResults.Find(Interface);

        if ((Info & CBI_VALID)         == 0                               ||
            (Info & CBI_CONTEXT_MASK)  != ActiveSecurityContext->AuthContextId  ||
            (Info & CBI_SEQUENCE_MASK) != (Interface->SequenceNumber << CBI_SEQUENCE_SHIFT))
            {
            RPC_STATUS MyStatus;

            MyStatus = Interface->CheckSecurityIfNecessary(Call);

            if (RPC_S_OK == MyStatus)
                {
                LogEvent(SU_SCONN, EV_STATUS, this, (void *) 114, MyStatus );
                Info = CBI_ALLOWED;
                }
            else
                {
                LogError(SU_SCONN, EV_STATUS, this, (void *) 114, MyStatus );
                Info = 0;
                }

            Info |= CBI_VALID;
            Info |= ActiveSecurityContext->AuthContextId;
            Info |= (Interface->SequenceNumber << CBI_SEQUENCE_SHIFT);

            InterfaceCallbackResults.Update(Interface, Info);

            //
            // If the callback routine impersonated the client,
            // restore the thread to its native security context.
            //
            RevertToSelf();
            }
        else
            {
            LogEvent(SU_SCONN, EV_STATUS, this, (void *)115, Info);
            }

        if (0 == (Info & CBI_ALLOWED))
            {
            Status = RPC_S_ACCESS_DENIED;
            LogError(SU_SCONN, EV_STATUS, this, (void *) 113, Status );
            }
        }

    return Status;
}


RPC_STATUS
DG_SCONNECTION::SealAndSendPacket(
    IN DG_ENDPOINT *                 SourceEndpoint,
    IN DG_TRANSPORT_ADDRESS          RemoteAddress,
    IN UNALIGNED NCA_PACKET_HEADER  *Header,
    IN unsigned long                 DataOffset
    )
{
    ASSERT( 0 == ActivityNode.CompareUuid(&Header->ActivityId) );

    if (DG_REJECT == Header->PacketType)
        {
        return SendSecurePacket(  SourceEndpoint,
                                  RemoteAddress,
                                  Header,
                                  DataOffset,
                                  0
                                  );
        }
    else
        {
        return SendSecurePacket(  SourceEndpoint,
                                  RemoteAddress,
                                  Header,
                                  DataOffset,
                                  ActiveSecurityContext
                                  );
        }
}


RPC_STATUS
DG_SCALL::Cancel(
    void * ThreadHandle
    )
{
    Connection->Mutex.Request();

    ++Cancelled;
    BasePacketFlags2 |= DG_PF2_CANCEL_PENDING;

    Connection->Mutex.Clear();

    return RPC_S_OK;
}

unsigned
DG_SCALL::TestCancel()
{
    if (!Cancelled)
        {
        return 0;
        }

    unsigned CancelCount;

    Connection->Mutex.Request();

    CancelCount = Cancelled;
    Cancelled = 0;
    BasePacketFlags2 &= ~(DG_PF2_CANCEL_PENDING);

    Connection->Mutex.Clear();

    return CancelCount;
}


RPC_STATUS
DG_SCALL::WaitForPipeEvent()
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned Locus;

    if (!PipeWaitEvent)
        {
        PipeWaitEvent = new EVENT(&Status, FALSE);
        if (!PipeWaitEvent)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }
        else if (Status != RPC_S_OK)
            {
            delete PipeWaitEvent;
            PipeWaitEvent = 0;
            }

        if (Status)
            {
            PipeWaitType = PWT_NONE;
            PipeThreadId = 0;
            return Status;
            }
        }

    IncrementRefCount();
    Connection->Mutex.Clear();

    PipeWaitEvent->Wait();

    Connection->Mutex.Request();
    DecrementRefCount();

    ASSERT(PipeThreadId == GetCurrentThreadId());
    PipeThreadId = 0;

    if (TerminateWhenConvenient)
        {
        Status = RPC_S_CALL_FAILED;
        }

    return Status;
}


BOOL
DG_SCALL::FinishSendOrReceive(
    BOOL Abort
    )
{
    RPC_ASYNC_EVENT Event;

    if (Abort)
        {
        TerminateWhenConvenient = TRUE;
        }

    switch (PipeWaitType)
        {
        case PWT_NONE:    return FALSE;
        case PWT_SEND:    Event = RpcSendComplete; break;
        case PWT_RECEIVE: Event = RpcReceiveComplete; break;
        default:          ASSERT(0 && "bad pipe wait type"); return FALSE;
        }

    ASSERT( PipeThreadId != 0 );

    PipeWaitType = PWT_NONE;

    if (!pAsync)
        {
        PipeWaitEvent->Raise();
        return TRUE;
        }

    if (Event == RpcSendComplete)
        {
        if (FinalSendBufferPresent)
            {
            PipeThreadId = 0;
            return FALSE;
            }
        }

    IssueNotification( Event );
    return TRUE;
}


RPC_STATUS
DG_SCALL::Receive(
    PRPC_MESSAGE Message,
    unsigned     Size
    )
/*++

Routine Description:

    When a server stub calls I_RpcReceive, this fn will be called
    in short order.

    Sync case: the fn waits until the requested buffer bytes are available,
               copies them to Message->Buffer, and returns.

    Async case: the fn returns the data if available now, otherwise
               RPC_S_ASYNC_CALL_PENDING.  The app will be notified when the
               data becomes available.  It can also poll.

    The action depends upon Message->RpcFlags:

        RPC_BUFFER_PARTIAL:

                Data is stored beginning at Message->Buffer[0].

                Wait only until <Message->BufferLength> bytes are available;
                we may resize the buffer if the fragment data exceeds the
                current buffer length.

        RPC_BUFFER_EXTRA:

                Data is stored beginning at Message->Buffer[Message->BufferLength].

Arguments:

    Message - the request.

        Message->Buffer is explicitly allowed to be zero, in which case this
        fn is responsible for allocating it.

Return Value:

    the usual error codes

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned Locus;

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'A' + (('R' + (('c' + ('v' << 8)) << 8)) << 8));
        }
    else
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'R' + (('e' + (('c' + ('v' << 8)) << 8)) << 8));
        }

    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, (Message->RpcFlags << 4) | Size);

    Connection->Mutex.Request();

    if (TerminateWhenConvenient)
        {
        FreeBuffer(Message);

        Status = RPC_S_CALL_FAILED;
        if (pAsync)
            {
            //
            // case c) from doc:appref
            //
            DecrementRefCount();
            Cleanup();
            }

        Connection->Mutex.Clear();

        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        return Status;
        }

    //
    // Determine whether we already have enough data on hand.
    //
    BOOL fEnoughData;
    if (Message->RpcFlags & RPC_BUFFER_PARTIAL)
        {
        ASSERT(Size);

        if (fReceivedAllFragments || ConsecutiveDataBytes >= Size)
            {
            fEnoughData = TRUE;
            }
        else
            {
            fEnoughData = FALSE;
            PipeWaitLength = Size;
            }
        }
    else
        {
        fEnoughData = fReceivedAllFragments;
        PipeWaitLength = 0;
        }

    //
    // Wait for enough data.
    //
    if (!fEnoughData)
        {
        if (Message->RpcFlags & RPC_BUFFER_NONOTIFY)
            {
            Connection->Mutex.Clear();

            LogEvent(SU_SCALL, EV_STATUS, this, 0, RPC_S_ASYNC_CALL_PENDING);
            return RPC_S_ASYNC_CALL_PENDING;
            }

        if (Message->RpcFlags & RPC_BUFFER_ASYNC)
            {
            ASSERT((PWT_NONE    == PipeWaitType && 0 == PipeThreadId) ||
                   (PWT_RECEIVE == PipeWaitType && GetCurrentThreadId() == PipeThreadId));

            PipeWaitType   = PWT_RECEIVE;
            PipeThreadId   = GetCurrentThreadId();

            Connection->Mutex.Clear();

            LogEvent(SU_SCALL, EV_STATUS, this, 0, RPC_S_ASYNC_CALL_PENDING);
            return RPC_S_ASYNC_CALL_PENDING;
            }
        else
            {
            ASSERT(PWT_NONE == PipeWaitType);
            ASSERT(0 == PipeThreadId);

            PipeWaitType   = PWT_RECEIVE;
            PipeThreadId   = GetCurrentThreadId();

            Status = WaitForPipeEvent();
            if (Status)
                {
                //
                // I would like to delete the buffer here, but NDR has already saved Message->Buffer
                // somewhere else and will later ask that it be deleted again.
                //
                //  FreeBuffer(Message);

                if (pAsync)
                    {
                    //
                    // case c) from doc:appref
                    //
                    InitErrorPacket(pSavedPacket, DG_FAULT, Status);
                    SealAndSendPacket(&pSavedPacket->Header);
                    DecrementRefCount();
                    Cleanup();
                    }

                Connection->Mutex.Clear();

                LogError(SU_SCALL, EV_STATUS, this, 0, Status);
                return Status;
                }
            }
        }

    //
    // This is here only for async receive case, but the if() clause
    // would only slow us down.
    //
    ASSERT( PipeWaitType == PWT_NONE );
    PipeThreadId = 0;

    //
    // For secure RPC, verify packet integrity.
    //
    if (Connection->AuthInfo.AuthenticationLevel > RPC_C_AUTHN_LEVEL_NONE)
        {
        PDG_PACKET pScan = pReceivedPackets;

        do
            {
            Status = Connection->VerifyRequestPacket(pScan);
            pScan = pScan->pNext;
            }
        while (pScan && Status == RPC_S_OK);
        }

    if (RPC_S_OK == Status)
        {
        Status = AssembleBufferFromPackets(Message);
        }

    if (Status)
        {
        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        FreeBuffer(Message);
        }

    Connection->Mutex.Clear();

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    return Status;
}


RPC_STATUS
DG_SCALL::Send(
    PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Transfers a pipe data buffer to the client.

Arguments:

    Message - the usual data

Return Value:

    the usual suspects

--*/
{
    RPC_STATUS Status;

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'A' + (('S' + (('n' + ('d' << 8)) << 8)) << 8));
        }
    else
        {
        LogEvent(SU_SCALL, EV_PROC, this, Message, 'S' + (('e' + (('n' + ('d' << 8)) << 8)) << 8));
        }

    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);

    //
    // No notification occurs on the buffer containing the [out] static args.
    // This is consistent with synchronous pipes.
    //
    if (!(Message->RpcFlags & RPC_BUFFER_PARTIAL))
        {
        FinalSendBufferPresent = TRUE;
        Message->RpcFlags |= RPC_BUFFER_NONOTIFY;
        }

    Connection->Mutex.Request();

    ASSERT(fReceivedAllFragments);

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        ASSERT(pAsync);
        }
    else
        {
        ASSERT(State == CallDispatched      ||
               State == CallSendingResponse ||
               State == CallAfterDispatch   );
        }

    if (TerminateWhenConvenient)
        {
        FreeBuffer(Message);

        SetState(CallSendingResponse);
        Status = RPC_S_CALL_FAILED;
        if (pAsync)
            {
            //
            // case c) from doc:appref
            //
            DecrementRefCount();
            Cleanup();
            }

        Connection->Mutex.Clear();

        LogError(SU_SCALL, EV_STATUS, this, (void *) 1 , Status);
        return Status;
        }

    SetFragmentLengths();

    if ((Message->RpcFlags & RPC_BUFFER_PARTIAL) &&
        Message->BufferLength < (ULONG) MaxFragmentSize * SendWindowSize )
        {
        if (pAsync)
            {
            IssueNotification( RpcSendComplete );
            }

        Connection->Mutex.Clear();

        LogEvent(SU_SCALL, EV_STATUS, this, (void *) 2, RPC_S_SEND_INCOMPLETE);
        return RPC_S_SEND_INCOMPLETE;
        }

    if (State != CallSendingResponse)
        {
        SetState(CallSendingResponse);
        CleanupReceiveWindow();
        }

    //
    // Set the message buffer as the current send buffer.
    //
    Status = PushBuffer(Message);

    //
    // Ignore normal send errors - they are usually transient and a retry fixes the problem.
    //
    if (Status == RPC_P_SEND_FAILED)
        {
        Status = 0;
        }

    if (Status)
        {
        FreeBuffer(Message);

        if (pAsync)
            {
            //
            // case c) from doc:appref
            //
            InitErrorPacket(pSavedPacket, DG_FAULT, Status);
            SealAndSendPacket(&pSavedPacket->Header);
            DecrementRefCount();
            Cleanup();
            }

        Connection->Mutex.Clear();

        LogError(SU_SCALL, EV_STATUS, this, (void *) 3, Status);
        return Status;
        }

    PipeWaitType = PWT_SEND;
    PipeThreadId = GetCurrentThreadId();

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        }
    else
        {
        Status = WaitForPipeEvent();
        if (Status)
            {
            if (pAsync)
                {
                //
                // case c) from doc:appref
                //
                InitErrorPacket(pSavedPacket, DG_FAULT, Status);
                SealAndSendPacket(&pSavedPacket->Header);
                DecrementRefCount();
                Cleanup();
                }

            Connection->Mutex.Clear();

            LogError(SU_SCALL, EV_STATUS, this, (void *) 4, Status);
            return Status;
            }
        }

    if (pAsync && !(Message->RpcFlags & RPC_BUFFER_PARTIAL))
        {
        //
        // case b) from doc:appref
        // Don't nuke the call, just remove the extra reference
        //
        DecrementRefCount();
        }

    Connection->Mutex.Clear();

    //
    // Be careful looking at member data from here on!
    //

    //
    // if this was a PARTIAL send and the buffer did not occupy an even
    // number of packets, the message buffer and length now reflect
    // the unsent portion.
    //
    if (!Status && Message->BufferLength)
        {
        Status = RPC_S_SEND_INCOMPLETE;
        }

    if (Status)
        {
        LogEvent(SU_SCALL, EV_STATUS, this, 0, Status);
        }

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);

    return Status;
}


RPC_STATUS
DG_SCALL::AsyncSend (
    IN OUT PRPC_MESSAGE Message
    )
{
    return Send(Message);
}


RPC_STATUS
DG_SCALL::AsyncReceive (
    IN OUT PRPC_MESSAGE Message,
    IN unsigned int Size
    )
{
    return Receive(Message, Size);
}

RPC_STATUS
DG_SCALL::InqLocalConnAddress (
    IN OUT void *Buffer,
    IN OUT unsigned long *BufferSize,
    OUT unsigned long *AddressFormat
    )
/*++

Routine Description:

    This routine is used by a server application to inquire about the local
    address on which a call is made.

Arguments:

    Buffer - The buffer that will receive the output address

    BufferSize - the size of the supplied Buffer on input. On output the
        number of bytes written to the buffer. If the buffer is too small
        to receive all the output data, ERROR_MORE_DATA is returned,
        nothing is written to the buffer, and BufferSize is set to
        the size of the buffer needed to return all the data.

    AddressFormat - a constant indicating the format of the returned address.
        Currently supported for datagrams is RPC_P_ADDR_FORMAT_TCP_IPV4.

Return Values:

    RPC_S_OK - success.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to complete this
        operation.

    RPC_S_INVALID_BINDING - The supplied client binding is invalid.

    RPC_S_CANNOT_SUPPORT - The local address was inquired for a protocol 
        sequence that doesn't support this type of functionality. Currently
        only ncacn_ip_tcp supports it.

    RPC_S_* or Win32 error for other errors
--*/
{
    if (*BufferSize < sizeof(DWORD))
        {
        *BufferSize = sizeof(DWORD);
        return ERROR_MORE_DATA;
        }

    *AddressFormat = RPC_P_ADDR_FORMAT_TCP_IPV4;
    *(DWORD *)Buffer = LocalAddress;

    return RPC_S_OK;
}


RPC_STATUS
DG_SCALL::SetAsyncHandle (
    IN RPC_ASYNC_STATE * hAsync
    )
{
    THREAD *MyThread = RpcpGetThreadPointer();

    ASSERT(MyThread);
    LogEvent(SU_SCALL, EV_PROC, this, 0, 'S' + (('e' + (('t' + ('H' << 8)) << 8)) << 8));

    MyThread->fAsync = TRUE;
    Connection->Mutex.Request();

    ASSERT( State == CallDispatched );

    ASSERT(0 == pAsync);

    pAsync = hAsync;

    IncrementRefCount();

    Connection->Mutex.Clear();
    return RPC_S_OK;
}


RPC_STATUS
DG_SCALL::AbortAsyncCall (
    IN PRPC_ASYNC_STATE pAsync,
    IN unsigned long ExceptionCode
    )
{
    LogEvent(SU_SCALL, EV_PROC, this, 0, 'A' + (('b' + (('t' + ('C' << 8)) << 8)) << 8));

    Connection->Mutex.Request();

    ASSERT( State == CallDispatched    ||
            State == CallAfterDispatch );

    if ( State != CallDispatched    &&
         State != CallAfterDispatch )
        {
        Connection->Mutex.Clear();
        return RPC_S_INVALID_ASYNC_CALL;
        }

    SetState(CallSendingResponse);

    CleanupReceiveWindow();

    // case d) from doc:appref
    //
    InitErrorPacket(pSavedPacket, DG_FAULT, ExceptionCode);
    SealAndSendPacket(&pSavedPacket->Header);
    DecrementRefCount();
    Cleanup();

    Connection->Mutex.Clear();

    return RPC_S_OK;
}


BOOL
DG_SCALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
{
    LogEvent(SU_SCALL, EV_NOTIFY, this, 0, Event);

    if (Event == RpcSendComplete && !(pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE))
        {
        return TRUE;
        }

    if (pAsync->NotificationType == RpcNotificationTypeApc)
        {
        IncrementRefCount();
        }

    int i;
    for (i=1; i < 3; ++i)
        {
        if (CALL::IssueNotification(Event))
            {
            return TRUE;
            }

        Sleep(200);
        }

    DecrementRefCount();

    return FALSE;
}


void
DG_SCALL::FreeAPCInfo (
    IN RPC_APC_INFO *pAPCInfo
    )
{
    LogEvent(SU_SCALL, EV_APC, this);

    Connection->Mutex.Request();

    DecrementRefCount();

    BOOL Final = FALSE;

    if (pAPCInfo->Event == RpcSendComplete &&
        !(BufferFlags & RPC_BUFFER_PARTIAL))
        {
        Final = TRUE;
        }

    CALL::FreeAPCInfo(pAPCInfo);

    if (Final)
        {
        Cleanup();
        }

    Connection->Mutex.Clear();
}

void
DG_SCALL::FreePipeBuffer (
    IN PRPC_MESSAGE Message
    )
{
    FreeBuffer(Message);
}

RPC_STATUS
DG_SCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
{
    LogEvent(SU_SCALL, EV_PROC, this, Message, 'R' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));
    LogEvent(SU_SCALL, EV_BUFFER_IN, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);

    Connection->Mutex.Request();

    if (TerminateWhenConvenient)
        {
        Connection->Mutex.Clear();
        LogError(SU_SCALL, EV_STATUS, this, 0, RPC_S_CALL_FAILED);
        return RPC_S_CALL_FAILED;
        }

    RPC_STATUS Status;

    //
    // If we are updating the [in] buffer, we need to inform
    // DispatchToStubWorker of the new [in] buffer.
    //
    void * OldBuffer = Message->Buffer;

    Status = CommonReallocBuffer(Message, NewSize);
    if (Status == RPC_S_OK)
        {
        if (OldBuffer == DispatchBuffer)
            {
            DispatchBuffer = Message->Buffer;
            }

        // The ReservedForRuntime field is a local variable of ProcessRpcCall,
        // so it is valid only during dispatch.
        //
        if (State == CallDispatched)
            {
            PRPC_RUNTIME_INFO Info = (PRPC_RUNTIME_INFO) Message->ReservedForRuntime;
            if (OldBuffer == Info->OldBuffer)
                {
                Info->OldBuffer = Message->Buffer;
                }
            }

#ifdef MONITOR_SERVER_PACKET_COUNT
        if (Message->Buffer != OldBuffer)
            {
            ASSERT( DG_PACKET::FromStubData(Message->Buffer)->pCount == 0 );
            DG_PACKET::FromStubData(Message->Buffer)->pCount = &OutstandingPacketCount;
            InterlockedIncrement( &OutstandingPacketCount );
            LogEvent( SU_SCALL, '(', this, DG_PACKET::FromStubData(Message->Buffer), OutstandingPacketCount );
            }
#endif
        }

    Connection->Mutex.Clear();

    LogEvent(SU_SCALL, EV_BUFFER_OUT, this, Message->Buffer, (Message->RpcFlags << 4) | Message->BufferLength);
    if (Status)
        {
        LogError(SU_SCALL, EV_STATUS, this, 0, Status);
        }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dgclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dgclnt.cxx

Abstract:

    This is the client side of datagram rpc.

Author:

    Jeff Roberts

Revisions:

    Jeff Roberts  (jroberts)  9-30-1996

        Began asynchronous call support.
        Began to remove DOS and Win16 support.

--*/

#include <precomp.hxx>
#include <conv.h>
#include <convc.h>
#include <epmap.h>
#include <dgpkt.hxx>
#include <spseal.h>
#include <locks.hxx>
#include <dgclnt.hxx>

/*

There are a lot of mutexes in this architecture.  All these objects are
protected by mutexes:

  DG_BINDING_HANDLE
  DG_CASSOCIATION
  DG_CLIENT_ADDRESS_TABLE
  DG_CCONNECTION
  DG_ASSOCIATION_TABLE (exclusive access)

In many cases it is necessary to acquire multiple mutexes at a time.  To avoid
deadlock, multiple mutexes must be taken in the order they are listed above.
For most of the code's history this ordering was not articulated, so there is
no macro to help enforce it.  It's just a good idea.

*/

//
// If you #define INTRODUCE_ERRORS then you can get the client and server
// to drop or delay some packets.  Here are the environment variables that
// control this behavior:
//
// set ServerDelayRate=xxx    where xxx is a percentage 0..100
// set ServerDelayTime=xxx    where xxx is the number of msec to delay
// set ServerDropRate=xxx     where xxx is a percentage 0..100
//
// set ClientDelayRate=xxx    where xxx is a percentage 0..100
// set ClientDelayTime=xxx    where xxx is the number of msec to delay
// set ClientDropRate=xxx     where xxx is a percentage 0..100
//

#define IDLE_CCALL_LIFETIME          (30 * 1000)
#define IDLE_CCALL_SWEEP_INTERVAL    (30 * 1000)

//#define IDLE_CCONNECTION_LIFETIME       (5 * 60 * 1000)
//#define IDLE_CCONNECTION_SWEEP_INTERVAL (1 * 60 * 1000)
//#define IDLE_CASSOCIATION_LIFETIME   (10 * 60 * 1000)

#define IDLE_CCONNECTION_LIFETIME       (2 * 60 * 1000)
#define IDLE_CCONNECTION_SWEEP_INTERVAL (    30 * 1000)
#define IDLE_CASSOCIATION_LIFETIME      (    30 * 1000)

#define GLOBAL_SCAVENGER_INTERVAL    (30 * 1000)
#define IDLE_ENDPOINT_LIFETIME       (30 * 1000)
#define PENALTY_BOX_DURATION         (10 * 1000)

#define CXT_HANDLE_KEEPALIVE_INTERVAL (20 * 1000)
#define CXT_HANDLE_SWEEP_INTERVAL     (10 * 1000)

//
// endpoint flags
//

// in rpcdce.h:
// #define RPC_C_USE_INTERNET_PORT         0x1
// #define RPC_C_USE_INTRANET_PORT         0x2

// calls with the maybe attribute are banished to a separate endpoint
//
#define PORT_FOR_MAYBE_CALLS   (0x1000)

// if a call fails or sends an ACK, there is a chance that an ICMP will be sent
// and we don't want it sitting in the port buffer when the next call uses the endpoint.
//
#define PENALTY_BOX            (0x0800)

//-------------------------------------------------------------------

DG_ASSOCIATION_TABLE * ActiveAssociations;

CLIENT_ACTIVITY_TABLE * ClientConnections;
ENDPOINT_MANAGER *      EndpointManager;

DELAYED_ACTION_TABLE *  DelayedProcedures;

long                    GlobalScavengerTimeStamp;
DELAYED_ACTION_NODE *   GlobalScavengerTimer;
DELAYED_ACTION_NODE *   ContextHandleTimer;

LONG ClientConnectionCount = 0;
LONG ClientCallCount = 0;

//-------------------------------------------------------------------

void
ContextHandleProc(
                  void * arg
                  );

void
DelayedAckFn(
    void * parm
    );

void
DelayedSendProc(
    void * parm
    );

RPC_STATUS
DispatchCallbackRequest(
    DG_CLIENT_CALLBACK *    CallbackObject
    );

int
InitializeRpcProtocolDgClient();

//--------------------------------------------------------------------


void
EnableGlobalScavenger()
{
    DelayedProcedures->Add(GlobalScavengerTimer, GLOBAL_SCAVENGER_INTERVAL + (5 * 1000), FALSE);
}

void
GlobalScavengerProc(
    void * Arg
    )
{
    long CurrentTime = PtrToLong( Arg );

    if (!CurrentTime)
        {
        CurrentTime = GetTickCount();
        }

    if (CurrentTime - GlobalScavengerTimeStamp <= 0)
        {
        return;
        }

    GlobalScavengerTimeStamp = CurrentTime;

    boolean Continue = FALSE;

    Continue |= DG_PACKET::DeleteIdlePackets(CurrentTime);

    Continue |= ActiveAssociations->DeleteIdleEntries(CurrentTime);

    Continue |= EndpointManager->DeleteIdleEndpoints(CurrentTime);

    if (Continue)
        {
        EnableGlobalScavenger();
        }
}

#ifdef INTRODUCE_ERRORS

long ServerDelayTime;
long ServerDelayRate;
long ServerDropRate;

long ClientDelayTime;
long ClientDelayRate;
long ClientDropRate;

#endif


int
InitializeRpcProtocolDgClient ()
/*++

Routine Description:

    This routine initializes the datagram protocol.

Arguments:

    <none>

Return Value:

    0 if successfull, 1 if not.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    //
    // Don't take the global mutex if we can help it.
    //
    if (ProcessStartTime)
        {
        return 0;
        }

    RequestGlobalMutex();

    if (!ProcessStartTime)
        {
        Status = DG_PACKET::Initialize();
        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        DelayedProcedures = new DELAYED_ACTION_TABLE(&Status);
        if (!DelayedProcedures)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        GlobalScavengerTimer = new DELAYED_ACTION_NODE(GlobalScavengerProc, 0);
        if (!GlobalScavengerTimer)
            {
            goto abend;
            }

        GlobalScavengerTimeStamp = GetTickCount();

        ContextHandleTimer = new DELAYED_ACTION_NODE(ContextHandleProc, 0);
        if (!ContextHandleTimer)
            {
            goto abend;
            }

        ClientConnections = new CLIENT_ACTIVITY_TABLE(&Status);
        if (!ClientConnections)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        ActiveAssociations = new DG_ASSOCIATION_TABLE(&Status);
        if (!ActiveAssociations)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        EndpointManager = new ENDPOINT_MANAGER(&Status);
        if (!EndpointManager)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            goto abend;
            }

        //
        // Server boot time is represented as the number of seconds
        // since 1/1/1970.  It must increase with each boot of the server.
        //

        LARGE_INTEGER CurrentTime;
        NTSTATUS Nt_Status;

        Nt_Status = NtQuerySystemTime(&CurrentTime);

        ASSERT( NT_SUCCESS(Nt_Status) );

        RtlTimeToSecondsSince1980(&CurrentTime, &ProcessStartTime);

        ProcessStartTime += (60 * 60 * 24 * 365 * 10);


#ifdef INTRODUCE_ERRORS

        char EnvBuffer[64];

        if (GetEnvironmentVariableA("ServerDelayTime", EnvBuffer, 64))
            {
            ::ServerDelayTime = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ServerDelayRate", EnvBuffer, 64))
            {
            ::ServerDelayRate = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ServerDropRate", EnvBuffer, 64))
            {
            ::ServerDropRate = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ClientDelayTime", EnvBuffer, 64))
            {
            ::ClientDelayTime = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ClientDelayRate", EnvBuffer, 64))
            {
            ::ClientDelayRate = atol(EnvBuffer);
            }
        if (GetEnvironmentVariableA("ClientDropRate", EnvBuffer, 64))
            {
            ::ClientDropRate = atol(EnvBuffer);
            }
#endif
        }

    ClearGlobalMutex();

    return 0;

    //--------------------------------------------------------------------

abend:

    delete EndpointManager;
    EndpointManager = 0;

    delete ActiveAssociations;
    ActiveAssociations = 0;

    delete ClientConnections;
    ClientConnections = 0;

    delete GlobalScavengerTimer;
    GlobalScavengerTimer = 0;

    delete DelayedProcedures;
    DelayedProcedures = 0;

    ClearGlobalMutex();

    return 1;
}


BINDING_HANDLE  *
DgCreateBindingHandle ()
/*++

Routine Description:

    Pseudo-constructor for creating a dg binding handle. It is done in a
    separate function so that the calling routine doesn't have to know
    any protocol-specific information.

Arguments:

    <none>

Return Value:

    A DG_BINDING_HANDLE, if successful, otherwise 0 (indicating out of mem)

--*/
{
    RPC_STATUS Status = RPC_S_OK;
    BINDING_HANDLE * Binding;

    Binding = new DG_BINDING_HANDLE(&Status);
    if (Status != RPC_S_OK)
        {
        delete Binding;
        return 0;
        }

    return Binding;
}


void
DG_CASSOCIATION::FlushAcks(
                           )
{
    PDG_CCONNECTION Connection;
    DictionaryCursor cursor;


    MutexRequest();

    ActiveConnections.Reset(cursor);

    while (Connection = ActiveConnections.Next(cursor))
        {
        // If an ACK is pending, send it.
        //
        Connection->CancelDelayedAck( TRUE );
        }

    ASSERT( ReferenceCount.GetInteger() > 0 );

    MutexClear();
}


void
DG_CASSOCIATION::DecrementRefCount()
/*++

Routine Description:

    Decrements the ref count to an association. If the ref count hits zero,
    the association is marked for deletion.

    It is possible for the count to go to zero just as another thread is
    scavenging the association table.  This would be a rare occurence, and
    should cause no ill effect.

--*/
{
    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    ActiveAssociations->UpdateTimeStamp( this );

    long Count = ReferenceCount.Decrement();

    LogEvent(SU_CASSOC, EV_DEC, this, 0, Count);

    if (0 == Count)
        {
        LogEvent(SU_CASSOC, EV_STOP, this);
        EnableGlobalScavenger();
        }
}


RPC_STATUS
DG_CASSOCIATION::UpdateAssociationWithAddress(
    PDG_PACKET           Packet,
    DG_TRANSPORT_ADDRESS NewAddress
    )
{
    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    long OldAssociationFlags;

    if (!AssociationFlag)
        {
        return RPC_S_OK;
        }

    if (Packet->Header.PacketType != DG_FACK     &&
        Packet->Header.PacketType != DG_WORKING  &&
        Packet->Header.PacketType != DG_RESPONSE &&
        Packet->Header.PacketType != DG_FAULT    )
        {
        return RPC_S_OK;
        }

    OldAssociationFlags = InterlockedExchange(&AssociationFlag, 0);

    if (0 == OldAssociationFlags)
        {
        return RPC_S_OK;
        }

    LogEvent(SU_CASSOC, EV_RESOLVED, this, 0, OldAssociationFlags);

    CLAIM_MUTEX Lock( Mutex );

    //
    // Save the updated network address + endpoint.
    //
    RPC_STATUS Status;
    char * SecondAddress;

    SecondAddress =  (char *) (this + 1);
    SecondAddress += TransportInterface->AddressSize;

    //
    // The only flags we handle here are UNRESOLVEDEP and BROADCAST.
    //
    ASSERT( 0 == (OldAssociationFlags & ~(UNRESOLVEDEP | BROADCAST)) );

    if (OldAssociationFlags & BROADCAST)
        {
        RPC_STATUS Status = RPC_S_OK;
        DCE_BINDING * OldDceBinding = 0;
        DCE_BINDING * NewDceBinding = 0;
        RPC_CHAR * ObjectUuid = 0;
        RPC_CHAR * AddressString = (RPC_CHAR *) _alloca(TransportInterface->AddressStringSize * sizeof(RPC_CHAR));
        RPC_CHAR * EndpointString = pDceBinding->InqEndpoint();

        Status = TransportInterface->QueryAddress(NewAddress, AddressString);
        if ( Status != RPC_S_OK )
            {
            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        if (OldAssociationFlags & UNRESOLVEDEP)
            {
            Status = TransportInterface->QueryEndpoint(NewAddress, ResolvedEndpoint);
            if ( Status != RPC_S_OK )
                {
                LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
                SetErrorFlag();
                return Status;
                }

            EndpointString = ResolvedEndpoint;
            }

        ObjectUuid = pDceBinding->ObjectUuidCompose( &Status );
        if ( Status != RPC_S_OK )
            {
            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        NewDceBinding = new DCE_BINDING( ObjectUuid,
                                         pDceBinding->InqRpcProtocolSequence(),
                                         AddressString,
                                         EndpointString,
                                         pDceBinding->InqNetworkOptions(),
                                         &Status
                                         );
        RpcpFarFree( ObjectUuid );

        if (Status || !NewDceBinding)
            {
            delete NewDceBinding;

            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        OldDceBinding = pDceBinding;
        pDceBinding = NewDceBinding;

        delete OldDceBinding;
        }
    else if (OldAssociationFlags & UNRESOLVEDEP)
        {
        //
        // We have resolved a dynamic endpoint; update the endpoint in the DCE_BINDING.
        //
        Status = TransportInterface->QueryEndpoint(NewAddress, ResolvedEndpoint);
        if ( Status != RPC_S_OK )
            {
            LogError(SU_CASSOC, EV_STATUS, this, 0, Status);
            SetErrorFlag();
            return Status;
            }

        pDceBinding->AddEndpoint(ResolvedEndpoint);

        ResolvedEndpoint = 0;
        }
    else
        {
        ASSERT( 0 );
        }

    RpcpMemoryCopy( SecondAddress, NewAddress, TransportInterface->AddressSize );
    ServerAddress = SecondAddress;

    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::FindOrCreateAssociation(
    IN const PRPC_CLIENT_INTERFACE Interface,
    IN BOOL                        fReconnect,
    IN BOOL                        fBroadcast
    )
{
    RPC_STATUS Status;
    BOOL fPartial = FALSE;
    LONG AssociationFlag = 0;

    if (fBroadcast)
        {
        AssociationFlag = DG_CASSOCIATION::BROADCAST;
        }

    //
    // Check to see if we need to resolve this endpoint.
    //
    Status = pDceBinding->ResolveEndpointIfNecessary(
        Interface,
        InqPointerAtObjectUuid(),
        InquireEpLookupHandle(),
        TRUE,                         //UseEpMapper Ep If Necessary
        InqComTimeout(),
        INFINITE,        // CallTimeout
        NULL            // AuthInfo
        );

    if (Status == RPC_P_EPMAPPER_EP)
        {
        AssociationFlag |= DG_CASSOCIATION::UNRESOLVEDEP;
        fPartial = TRUE;
        Status = 0;
        }

    if (Status)
        {
        return Status;
        }

    //
    // A binding with the UNIQUE option set should maintain its own association,
    // never sharing with other binding handles.  This is used by the Wolfpack
    // cluster software to manage connections themselves.
    //
    ULONG_PTR fUnique;

    Status = InqTransportOption(RPC_C_OPT_UNIQUE_BINDING, &fUnique);
    ASSERT(Status == RPC_S_OK);

    if (fUnique == 0 && fBroadcast == FALSE)
        {
        //
        // Look for a matching association.
        //
        ASSERT( Association == 0 );

        Association = ActiveAssociations->Find( this, Interface, fContextHandle, fPartial, fReconnect );
        if (Association)
            {
            return 0;
            }
        }

    //
    // Create a matching association.
    //
    ASSERT(pDceBinding);

    DCE_BINDING * NewDceBinding = pDceBinding->DuplicateDceBinding();

    if (!NewDceBinding)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    Association = new (TransportInterface) DG_CASSOCIATION( TransportInterface,
                                                            AssociationFlag,
                                                            NewDceBinding,
                                                            (BOOL) fUnique,
                                                            &Status
                                                            );

    if (Association == 0)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }

    if (Status)
        {
        delete Association;
        Association = 0;

        return Status;
        }

    //
    // Other threads using this binding handle for the same interface
    // will reuse this association instead of creating a new one.
    //
    Association->AddInterface(Interface, InqPointerAtObjectUuid());

    return 0;
}



RPC_STATUS
DG_BINDING_HANDLE::SetTransportOption( IN unsigned long option,
                                       IN ULONG_PTR     optionValue )
/*++

Routine Description:

  Set the binding specific transport option to the optionValue.

Arguments:

  option      -- Option to set (transport specific).
  optionValue -- New value for option.

Return Value: RPC_S_OK
              RPC_S_CANNOT_SUPPORT
              RPC_S_ARG_INVALID
              RPC_S_OUT_OF_MEMORY

--*/
{
  RPC_STATUS  Status = RPC_S_OK;

  if (option >= RPC_C_OPT_BINDING_NONCAUSAL)
      {
      //
      // This option can be changed only before a call is made.
      //
      if (option == RPC_C_OPT_UNIQUE_BINDING && Association != NULL)
      {
          return RPC_S_WRONG_KIND_OF_BINDING;
          }

      return BINDING_HANDLE::SetTransportOption(option, optionValue);
      }

  if ( (TransportInterface) && (TransportInterface->OptionsSize > 0) )
     {
     if (pvTransportOptions == NULL)
        {
        pvTransportOptions = (void*)I_RpcAllocate(TransportInterface->OptionsSize);
        if (pvTransportOptions == NULL)
           {
           return RPC_S_OUT_OF_MEMORY;
           }

        Status = TransportInterface->InitOptions(pvTransportOptions);
        }

     if (Status == RPC_S_OK)
        {
        Status = TransportInterface->SetOption(pvTransportOptions,option,optionValue);
        }
     }
  else
     {
     Status = RPC_S_CANNOT_SUPPORT;
     }

  return Status;
}



RPC_STATUS
DG_BINDING_HANDLE::InqTransportOption( IN  unsigned long  option,
                                       OUT ULONG_PTR     *pOptionValue )
/*++

Routine Description:

  Get the value of a transport specific binding option.

Arguments:

  option      -- Option to inquire.
  pOptionValue - Place to return the current value.

Return Value: RPC_S_OK
              RPC_S_CANNOT_SUPPORT
              RPC_S_ARG_INVALID
              RPC_S_OUT_OF_MEMORY

--*/
{
  RPC_STATUS    Status = RPC_S_OK;

  if (option >= RPC_C_OPT_BINDING_NONCAUSAL)
      {
      return BINDING_HANDLE::InqTransportOption(option, pOptionValue);
      }

  if ( (TransportInterface) && (TransportInterface->OptionsSize > 0) )
  {
    if (pvTransportOptions == NULL)
    {
      pvTransportOptions = (void*)I_RpcAllocate(TransportInterface->OptionsSize);
      if (pvTransportOptions == NULL)
        return RPC_S_OUT_OF_MEMORY;

      Status = TransportInterface->InitOptions(pvTransportOptions);
    }

    if (Status == RPC_S_OK)
      Status = TransportInterface->InqOption(pvTransportOptions,option,pOptionValue);
  }
  else
    Status = RPC_S_CANNOT_SUPPORT;

  return Status;
}



RPC_STATUS
DG_BINDING_HANDLE::GetBuffer (
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This is the routine that is called to initiate an rpc. At this point,
    the client stub is allocating memory to place the parameters into. Ask our
    association for a DG_CCALL object to transact this call on then send
    the buffer request off to that DG_CCALL.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    RPC_S_OUT_OF_MEMORY

    RPC_S_OK

Revision History:

--*/
{
    BOOL fBroadcast = FALSE;
    RPC_STATUS  Status;

    LogEvent(  SU_HANDLE, EV_PROC, this, 0, 'G' + (('e' + (('t' + ('B' << 8)) << 8)) << 8));

    if (Message->RpcFlags & (RPC_NCA_FLAGS_MAYBE | RPC_NCA_FLAGS_BROADCAST))
        {
        Message->RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;
        }

    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        Status = TransportObject->CreateThread();
        if (Status != RPC_S_OK)
            {
            return Status;
            }
        }

    if (Message->RpcFlags & RPC_NCA_FLAGS_BROADCAST)
        {
        fBroadcast = TRUE;
        }

    MutexRequest();

    ASSERT(pDceBinding != 0);

    //
    // Have we already determined the association for this binding handle?
    //
    if (Association == 0)
        {
        Status = FindOrCreateAssociation( (PRPC_CLIENT_INTERFACE) Message->RpcInterfaceInformation, FALSE, fBroadcast );
        if (Status)
            {
            MutexClear();
            LogError(SU_HANDLE, EV_STATUS, this, 0, Status);
            return (Status);
            }
        }


    {
    const CLIENT_AUTH_INFO * AuthInfo = InquireAuthInformation();

    if ( AuthInfo &&
         AuthInfo->AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE  &&
         AuthInfo->IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC )
        {
        Status = ReAcquireCredentialsIfNecessary();
        if (Status != RPC_S_OK)
            {
            MutexClear();
            LogError(SU_HANDLE, EV_STATUS, this, 0, Status);
            return (Status);
            }
        }
    }

    // Here's the deal, Sparky:
    //      association refcount = (# of binding handles with a pointer to it)
    //                           + (# of the association's connections in use)
    //      connection refcount  = (# of the connection's CCALLs in use)
    //      binding refcount     = (# of connections with a pointer to it)

    PDG_CCALL Call = 0;
    const CLIENT_AUTH_INFO * AuthInfo;

    if (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE)
        {
        AuthInfo = 0;
        }
    else
        {
        AuthInfo = InquireAuthInformation();
        }

    Status = Association->AllocateCall( this, AuthInfo, &Call, (Message->RpcFlags & RPC_BUFFER_ASYNC) ? TRUE : FALSE );

    MutexClear();

    if (Status != RPC_S_OK)
        {
        LogError(SU_HANDLE, EV_STATUS, this, 0, Status);
        return Status;
        }

    return Call->GetInitialBuffer(Message, ObjectUuid);
}


BOOL
DG_CASSOCIATION::SendKeepAlive()
/*++

Routine Description:

    This calls convc_indy() to tell the server to keep the association's
    context handles alive.  The NT server code does not register the convc interface,
    since the mere fact of activity on a connection keeps the connection, and therefore
    the association group, alive.

Return Value:

    TRUE  if successful
    FALSE if not

--*/
{
    RPC_STATUS status = 0;

    LogEvent(SU_CASSOC, EV_ACK, this);

    if (!KeepAliveHandle)
        {
        MutexRequest();

        if (!KeepAliveHandle)
            {
            DCE_BINDING * NewDceBinding;

            NewDceBinding = pDceBinding->DuplicateDceBinding();
            if (!NewDceBinding)
                {
                MutexClear();
                return FALSE;
                }

            KeepAliveHandle = new DG_BINDING_HANDLE(this, NewDceBinding, &status);

            if (status)
                {
                delete KeepAliveHandle;
                delete NewDceBinding;
                MutexClear();
                return FALSE;
                }

            if (!KeepAliveHandle)
                {
                delete NewDceBinding;
                MutexClear();
                return FALSE;
                }

            IncrementBindingRefCount( FALSE );
            }

        MutexClear();
        }

    RpcTryExcept
        {
        _convc_indy( KeepAliveHandle, &ActiveAssociations->CasUuid );
        }
    RpcExcept( I_RpcExceptionFilter(RpcExceptionCode()) )
        {
        // don't care
#ifdef DBG
        DbgPrint("RPC: exception 0x%x in context-handle keep-alive\n", RpcExceptionCode());
#endif
        }
    RpcEndExcept;

    return TRUE;
}


PDG_CCONNECTION
DG_CASSOCIATION::AllocateConnection(
    IN  PDG_BINDING_HANDLE BindingHandle,
    IN  const CLIENT_AUTH_INFO * AuthInfo,
    IN  DWORD ThreadId,
    IN  BOOL  fAsync,
    OUT RPC_STATUS * pStatus
    )
{
    if (!ThreadId)
        {
        ThreadId = GetCurrentThreadId();
        }

    boolean fStacking = FALSE;
    RPC_STATUS Status = RPC_S_OK;
    PDG_CCONNECTION Connection = 0;
    PDG_CCONNECTION BusyConnection;
    DictionaryCursor cursor;

                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 0 ), this, Connection );

    long StartTime = GetTickCount();

retry:

    BusyConnection = 0;

    MutexRequest();

    //
    // Multiple async calls from the same thread should all use a single
    // connection unless the binding handle is marked "non-causal".
    // A synchronous call from the same thread should use a different
    // connection.
    //
    // A connection waiting to send a delayed ACK is still marked active,
    // but we want to reuse it anyway.
    //
    // The plan, therefore, is to search first for an active connection if
    // the call is async and causal, then search for a connection that is
    // inactive except for a delayed ack, then search for an idle connection.
    //

    if (fAsync)
        {
        ULONG_PTR fNonCausal;

        Status = BindingHandle->InqTransportOption(
                                                   RPC_C_OPT_BINDING_NONCAUSAL,
                                                   &fNonCausal);
        ASSERT(Status == RPC_S_OK);

        if (fNonCausal == 0)
            {
            fStacking = TRUE;
            }
        }

    //
    // Search for a connection handling this thread's async calls.
    //
    if (fStacking)
        {
        ActiveConnections.Reset(cursor);

        while (Connection = ActiveConnections.Next(cursor))
            {
            BusyConnection = Connection;

            if ( Connection->BindingHandle != BindingHandle ||
                 Connection->ThreadId      != ThreadId )
                 {
                 continue;
                 }

            //
            // The app may have changed the security info since the other
            // calls were submitted.
            //
            if (FALSE == fLoneBindingHandle &&
                FALSE == Connection->IsSupportedAuthInfo(AuthInfo))
                {
                continue;
                }

            Connection->MutexRequest();
            if (Connection->fBusy)
                {
                // The connection is in a transitional state and is unavailable right now.
                // If this is a Unique binding handle, retry.  Otherwise keep looking.
                //
                Connection->MutexClear();

                if (fLoneBindingHandle)
                    {
                    LogError(SU_CASSOC, EV_PROC, this, (void *) 4, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
                    MutexClear();
                    Sleep(1);
                    goto retry;
                    }
                continue;
                }

            if ( Connection->BindingHandle != BindingHandle ||
                 Connection->ThreadId      != ThreadId )
                {
                Connection->MutexClear();
                continue;
                }

            MutexClear();

            //
            // Add a reference for the new call to come.
            //
            Connection->IncrementRefCount();

            Connection->CancelDelayedAck();

            return Connection;
            }
        }

    //
    // Search for a connection that is waiting on a delayed ack.
    //
    ActiveConnections.Reset(cursor);

    while (Connection = ActiveConnections.Next(cursor))
        {
        BusyConnection = Connection;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 1 ), this, Connection );
        if (!Connection->AckPending)
            {
            continue;
            }

        if (FALSE == fLoneBindingHandle &&
            FALSE == Connection->IsSupportedAuthInfo(AuthInfo))
            {
            continue;
            }
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 2 ), this, Connection );
        Connection->MutexRequest();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 3 ), this, Connection );
        if (Connection->fBusy)
            {
            // The connection is in a transitional state and is unavailable right now.
            // If this is a Unique binding handle, retry.  Otherwise keep looking.
            //
            Connection->MutexClear();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 4 ), this, Connection );
            if (fLoneBindingHandle)
                {
                LogError(SU_CASSOC, EV_PROC, this, (void *) 5, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
                MutexClear();
                Sleep(1);
                goto retry;
            }

            continue;
            }
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 5 ), this, Connection );
        if (!Connection->AckPending)
            {
            Connection->MutexClear();
            continue;
        }

        DG_BINDING_HANDLE * OldHandle = Connection->BindingHandle;

        Connection->BindingHandle = BindingHandle;
        Connection->ThreadId      = ThreadId;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 6 ), this, Connection );
#ifdef DBG
        //
        // debugging code for clustering
        //
        if (fLoneBindingHandle)
            {
            DG_CCONNECTION * SecondConnection = 0;

            //
            // See if a valid inactive connection exists,  This could cause trouble, too.
            //
            InactiveConnections.Reset(cursor);

            SecondConnection = InactiveConnections.Next(cursor);
            if (SecondConnection &&
                SecondConnection->fError == FALSE)
                {
                DbgPrint("RPC: failure of unique-handle semantics (2)\n");
                DbgBreakPoint();
                }
            }
#endif

        MutexClear();

        //
        // Add a reference for the call to come.  This prevents the conn from
        // accidentally being moved to the inactive list.
        //
        Connection->IncrementRefCount();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 7 ), this, Connection );
        //
        // Must cancel the delayed ACK before releasing the mutex, so other threads
        // can't pick it up like this thread did.
        //
        Connection->CancelDelayedAck();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_CONN, 8 ), this, Connection );
        if (OldHandle != Connection->BindingHandle)
            {
            Connection->MutexClear();

            BindingHandle->IncrementRefCount();
            OldHandle->DecrementRefCount();

            Connection->MutexRequest();
            }

        return Connection;
        }

    //
    // Search for an idle connection with matching security info.
    //
    InactiveConnections.Reset(cursor);

    while (0 != (Connection = InactiveConnections.Next(cursor)))
        {
        BusyConnection = Connection;

        if (Connection->fError)
            {
            continue;
            }

        if (fLoneBindingHandle ||
            Connection->IsSupportedAuthInfo(AuthInfo))
            {
            LogEvent(SU_CCONN, EV_START, Connection, this);

            ASSERT( FALSE == Connection->fAutoReconnect );
            ASSERT( FALSE == Connection->fError );

            InactiveConnections.Delete(Connection->AssociationKey);
            Connection->AssociationKey = ActiveConnections.Insert(Connection);
            if (-1 == Connection->AssociationKey)
                {
                MutexClear();
                *pStatus = RPC_S_OUT_OF_MEMORY;
                delete Connection;
                return 0;
                }

            IncrementRefCount();

            ASSERT( FALSE == Connection->fBusy );

            Connection->MutexRequest();

            Connection->BindingHandle = BindingHandle;
            Connection->ThreadId      = ThreadId;

            ClientConnections->Add(Connection);

            MutexClear();

            BindingHandle->IncrementRefCount();

            //
            // Add a reference for the call to come.
            //
            Connection->IncrementRefCount();

            return Connection;
            }
        }

    //
    // Unique handles have special semantics.
    //
    if (fLoneBindingHandle && BusyConnection)
        {
        if (BindingHandle == KeepAliveHandle)
            {
            LogEvent(SU_CASSOC, EV_PROC, this, (void *) 1, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
            //
            // Keep-alive was begun just as the app thread began using the handle.
            // Don't bother executing the keep-alive.
            //
            MutexClear();
            *pStatus = RPC_S_CALL_IN_PROGRESS;
            return 0;
            }

        ASSERT( BusyConnection->BindingHandle );

        if (BusyConnection->BindingHandle == KeepAliveHandle)
            {
            LogEvent(SU_CASSOC, EV_PROC, this, (void *) 2, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
#if 0
            if (GetTickCount() - StartTime > 10*1000)
                {
                DbgPrint("RPC: keep-alive tied up a connection for > 10 seconds\n");
                DbgBreakPoint();
                }
#endif
            //
            // App thread began a call just as the keep-alive thread was finishing one.
            // Wait for the keep-alive to finish.
            //
            MutexClear();

            Sleep(1);

            goto retry;
            }

        //
        // Two app threads contending, or the current connection is closing.
        //
        if (BusyConnection->fBusy)
            {
            LogError(SU_CASSOC, EV_PROC, this, (void *) 6, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));
            MutexClear();
            Sleep(1);
            goto retry;
            }

        //
        // Create a new connection.
        //
        LogEvent(SU_CASSOC, EV_PROC, this, (void *) 3, 'R' + (('e' + (('t' + ('r' << 8)) << 8)) << 8));

#ifdef DBG
        //
        // If it's in use, it should be doing something.
        //
        if ( FALSE == BusyConnection->fError &&
             BusyConnection->TimeStamp != 0  &&
             (GetTickCount() - BusyConnection->TimeStamp) > 60000)
            {
            DbgPrint("RPC: failure of unique-handle semantics (3)\n");
            DbgBreakPoint();
            }
#endif
        }

    //
    // Create a new connection and add it to the active conn list.
    // Increment the refcount here to avoid having the assoc deleted
    // while we are tied up.
    //
    IncrementRefCount();

    MutexClear();

    Connection = new (TransportInterface) DG_CCONNECTION(this, AuthInfo, &Status);
    if (!Connection)
        {
        Status = RPC_S_OUT_OF_MEMORY;
        }
    if (Status != RPC_S_OK)
        {
        DecrementRefCount();
        delete Connection;
        *pStatus = Status;
        return 0;
        }

    Connection->BindingHandle = BindingHandle;
    Connection->ThreadId      = ThreadId;

    MutexRequest();

    Connection->MutexRequest();

    LogEvent(SU_CCONN, EV_START, Connection, this);
    Connection->AssociationKey = ActiveConnections.Insert(Connection);

    MutexClear();

    if (-1 == Connection->AssociationKey)
        {
        DecrementRefCount();

        // don't have to release the connection mutex because we are deleting it
        delete Connection;
        *pStatus = RPC_S_OUT_OF_MEMORY;
        return 0;
        }

    BindingHandle->IncrementRefCount();

    ClientConnections->Add(Connection);

    //
    // Add a reference for the call in progress.
    //
    Connection->IncrementRefCount();

    return Connection;
}


RPC_STATUS
DG_CASSOCIATION::AllocateCall(
    IN  PDG_BINDING_HANDLE BindingHandle,
    IN  const CLIENT_AUTH_INFO * AuthInfo,
    OUT PDG_CCALL * ppCall,
    IN  BOOL  fAsync
    )
{
    RPC_STATUS Status = 0;
    PDG_CCONNECTION Connection;

    Connection = AllocateConnection(BindingHandle, AuthInfo, 0, fAsync, &Status);

    if (!Connection)
        {
        return Status;
        }

    *ppCall = Connection->AllocateCall();

    if (!*ppCall)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}


void
DG_CASSOCIATION::ReleaseConnection(
    IN PDG_CCONNECTION Connection
    )
{
    DG_BINDING_HANDLE * MyHandle;

    LogEvent(SU_CCONN, EV_STOP, Connection, this);

    ClientConnections->Remove(Connection);

    int Key;

    MutexRequest();

    ActiveConnections.Delete(Connection->AssociationKey);
    Connection->AssociationKey = InactiveConnections.Insert(Connection);
    Key = Connection->AssociationKey;

    Connection->WaitForNoReferences();

    MyHandle = Connection->BindingHandle;
    Connection->BindingHandle = 0;

    MutexClear();

    if (MyHandle)
        {
        MyHandle->DecrementRefCount();
        }

    if (-1 == Key)
        {
        Connection->CancelDelayedAck();
        delete Connection;
        }

    DecrementRefCount();
}


DG_CCALL *
DG_CCONNECTION::AllocateCall()

/*++

Description:

    Provides a DG_CCALL to use.  The connection mutex is cleared on exit.

--*/
{
    DG_CCALL * Call = 0;
    RPC_STATUS Status = RPC_S_OK;

    Mutex.VerifyOwned();

    ASSERT( !AckPending );
    ASSERT( ReferenceCount );

    if (CachedCalls)
        {
        Call = CachedCalls;
        CachedCalls = CachedCalls->Next;

        MutexClear();
        }
    else
        {
        MutexClear();

        Call = new DG_CCALL(this, &Status);
        if (!Call)
            {
            Status = RPC_S_OUT_OF_MEMORY;
            }

        if (Status != RPC_S_OK)
            {
            delete Call;

            MutexRequest();

            DecrementRefCount();
            return 0;
            }
        }

    Call->IncrementRefCount();

    Call->Cancelled = FALSE;
    Call->CancelPending = FALSE;

    LogEvent(SU_CCALL, EV_START, Call, this);

    return Call;
}


RPC_STATUS
DG_BINDING_HANDLE::BindingFree (
    )
/*++

Routine Description:

    Implements RpcBindingFree for dg binding handles.

Arguments:

    <none>

Return Value:

    RPC_S_OK

--*/
{
    LogEvent( SU_HANDLE, EV_PROC, this, 0, 'F' + (('r' + (('e' + ('e' << 8)) << 8)) << 8), TRUE);

    if (!ThreadSelf())
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    // Flush the delayed ack on any connection using this handle.
    //
    if (Association)
        {
        PDG_CASSOCIATION TempAssociation;

        MutexRequest();

        TempAssociation = Association;
        Association = 0;

        MutexClear();

        if (TempAssociation != 0)
            {
            TempAssociation->DecrementBindingRefCount(fContextHandle);
            }
        }

    //
    // Decrement the ref count. If the count has hit zero, this call will
    // delete this.
    //
    DecrementRefCount();

    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::PrepareBindingHandle (
    IN TRANS_INFO *     a_TransportInterface,
    IN DCE_BINDING *    DceBinding
    )
/*++

Routine Description:

    Serves as an auxiliary constructor for DG_BINDING_HANDLE. This is called
    to initialize stuff after the DG_BINDING_HANDLE has been constructed.

Arguments:

    TransportInterface - pointer to the DG_CLIENT_TRANSPORT object that this
        DG_BINDING_HANDLE is active on.

    DceBinding - Pointer to the DCE_BINDING that we are associated with.

Return Value:

    none

--*/
{
    ASSERT(pDceBinding == 0);

    Association        = 0;
    pDceBinding        = DceBinding;
    TransportObject    = a_TransportInterface;
    TransportInterface = (RPC_DATAGRAM_TRANSPORT *) a_TransportInterface->InqTransInfo();

    RPC_CHAR * Endpoint = pDceBinding->InqEndpoint();
    if (!Endpoint || Endpoint[0] == 0)
        {
        fDynamicEndpoint = TRUE;
        }
    else
        {
        fDynamicEndpoint = FALSE;
        }
    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::ToStringBinding (
    OUT RPC_CHAR __RPC_FAR * __RPC_FAR * StringBinding
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    <return from DG_CASSOCIATION::ToStringBinding>


--*/
{
    CLAIM_MUTEX Lock( BindingMutex );

    if (Association == 0)
        {
        *StringBinding = pDceBinding->StringBindingCompose(
            InqPointerAtObjectUuid()
            );
        if (*StringBinding == 0)
            {
            return RPC_S_OUT_OF_MEMORY;
            }
        return RPC_S_OK;
        }
    else
        {
        return Association->ToStringBinding(
            StringBinding,
            InqPointerAtObjectUuid()
            );
        }
}


RPC_STATUS
DG_BINDING_HANDLE::ResolveBinding (
    IN RPC_CLIENT_INTERFACE __RPC_FAR * RpcClientInterface
    )
/*++

Routine Description:

    Resolve this binding.

Arguments:

    RpcClientInterface - Interface info used to resolve the endpoint.

Return Value:

    RPC_S_OK
    <return from DCE_BINDING::ResolveEndpointIfNecessary>

--*/
{
    CLAIM_MUTEX Lock( BindingMutex );

    LogEvent( SU_HANDLE, EV_RESOLVED, this, Association );

    if ( Association == 0 )
        {
        RPC_STATUS Status;
        Status = pDceBinding->ResolveEndpointIfNecessary(
            RpcClientInterface,
            InqPointerAtObjectUuid(),
            InquireEpLookupHandle(),
            FALSE,
            InqComTimeout(),
            INFINITE,        // CallTimeout
            NULL            // AuthInfo
            );

        if (Status)
            {
            LogError( SU_HANDLE, EV_STATUS, this, 0, Status );
            }

        return Status;
        }
    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::BindingReset (
    )
/*++

Routine Description:

    Reset this binding to a 'zero' value.

Arguments:

    <none>

Return Value:

    RPC_S_OK;

--*/
{
    LogEvent( SU_HANDLE, EV_PROC, this, 0, 'R' + (('e' + (('s' + ('e' << 8)) << 8)) << 8), TRUE);

    MutexRequest();

    DisassociateFromServer();

    pDceBinding->MakePartiallyBound();

    if (0 != *InquireEpLookupHandle())
        {
        EpFreeLookupHandle(*InquireEpLookupHandle());
        *InquireEpLookupHandle() = 0;
        }

    MutexClear();
    return RPC_S_OK;
}


RPC_STATUS
DG_BINDING_HANDLE::BindingCopy (
    OUT BINDING_HANDLE  * __RPC_FAR * DestinationBinding,
    IN unsigned int MaintainContext
    )
/*++

Routine Description:

    Creates a copy of this binding handle.

Arguments:

    DestinationBinding - Where to place a pointer to the new binding.

Return Value:

    RPC_S_OK

--*/
{
    RPC_STATUS          Status = RPC_S_OK;
    PDG_BINDING_HANDLE  Binding;
    DCE_BINDING *       NewDceBinding = 0;

    *DestinationBinding = 0;

    Binding = new DG_BINDING_HANDLE(&Status);
    if ( Binding == 0 || Status != RPC_S_OK)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    MutexRequest();

    //
    // If the binding refers to a dynamic endpoint or is used for broadcast calls,
    // then the association may have a more up-to-date DCE_BINDING.
    //
    if (Association)
        {
        NewDceBinding = Association->DuplicateDceBinding();
        }
    else
        {
        NewDceBinding = pDceBinding->DuplicateDceBinding();
        }

    if (!NewDceBinding)
        {
        MutexClear();
        delete Binding;
        return RPC_S_OUT_OF_MEMORY;
        }

    //
    // Clone calls MapAuthLevel which depends on these items, so copy them first.
    //
    Binding->TransportObject    = TransportObject;
    Binding->TransportInterface = TransportInterface;
    Binding->pDceBinding        = NewDceBinding;
    Binding->fDynamicEndpoint   = fDynamicEndpoint;
    Binding->fContextHandle     = MaintainContext;

    Status = Binding->BINDING_HANDLE::Clone( this );
    if (Status != RPC_S_OK)
        {
        MutexClear();
        delete Binding;
        Binding = 0;
        return Status;
        }

    //
    //  If we clone a binding handle with the UNIQUE option set, we want
    // to use a separate association.
    //
    if (Association && !Association->fLoneBindingHandle)
        {
        Binding->Association = Association;
        Binding->Association->IncrementBindingRefCount( MaintainContext );
        }
    else
        {
        Binding->Association = 0;
        }

    MutexClear();

    *DestinationBinding = (BINDING_HANDLE  *) Binding;

    if (MaintainContext)
        {
        //
        // We've created a context handle; ensure the keep-alive proc is active.
        //
        DelayedProcedures->Add(ContextHandleTimer, CXT_HANDLE_SWEEP_INTERVAL, FALSE);
        }
    return RPC_S_OK;
}


PDG_CCONNECTION
DG_BINDING_HANDLE::GetReplacementConnection(
    PDG_CCONNECTION OldConnection,
    PRPC_CLIENT_INTERFACE Interface
    )
{
    BOOL fBroadcast = FALSE;

    CLAIM_MUTEX Lock( BindingMutex );

    if (OldConnection->CurrentCall->IsBroadcast())
        {
        fBroadcast = TRUE;
        }

    if (OldConnection->Association == Association)
        {
        BOOL Dynamic = fDynamicEndpoint;

        Association->SetErrorFlag();

        //
        // If the binding handle has no object ID, releasing the current
        // endpoint would mean all mgmt calls on the new connection would fail.
        //
        if (IsMgmtIfUuid(&Interface->InterfaceId.SyntaxGUID))
            {
            fDynamicEndpoint = FALSE;
            }

        DisassociateFromServer();

        fDynamicEndpoint = (boolean) Dynamic;
        }

    if (!Association && RPC_S_OK != FindOrCreateAssociation(Interface, TRUE, fBroadcast))
        {
        return 0;
        }

    RPC_STATUS Status;
    return Association->AllocateConnection(this,
                                           OldConnection->InqAuthInfo(),
                                           OldConnection->ThreadId,
                                           OldConnection->CurrentCall->pAsync ? TRUE : FALSE,
                                           &Status
                                           );
}


void
DG_BINDING_HANDLE::DisassociateFromServer()
{
    PDG_CASSOCIATION TempAssociation;

    LogEvent(SU_HANDLE, EV_DISASSOC, this, Association, 0, TRUE);

    MutexRequest();

    TempAssociation = Association;
    Association = 0;

    //
    // This frees memory while holding the mutex - not ideal..
    // One could modify DCE_BINDING::MakePartiallyBound to return the old
    // endpoint so we can delete it outside the mutex.
    //
    if (fDynamicEndpoint)
        {
        pDceBinding->MakePartiallyBound();
        }

    MutexClear();

    if (TempAssociation != 0)
        {
        TempAssociation->DecrementBindingRefCount(fContextHandle);
        }
}


unsigned long
DG_BINDING_HANDLE::MapAuthenticationLevel (
    IN unsigned long AuthenticationLevel
    )
{
    if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_CONNECT ||
        AuthenticationLevel == RPC_C_AUTHN_LEVEL_CALL )
        {
        return(RPC_C_AUTHN_LEVEL_PKT);
        }

    // This is an additional mapping for the reliable DG protocols
    // (i.e. Falcon/RPC). This protocols only use the following
    // three levels: RPC_C_AUTHN_LEVEL_NONE           1
    //               RPC_C_AUTHN_LEVEL_PKT_INTEGRITY  5
    //               RPC_C_AUTHN_LEVEL_PKT_PRIVACY    6
    if (TransportInterface->IsMessageTransport)
       {
       if (AuthenticationLevel == RPC_C_AUTHN_LEVEL_DEFAULT)
          {
          return RPC_C_AUTHN_LEVEL_NONE;
          }

       if (  (AuthenticationLevel > RPC_C_AUTHN_LEVEL_NONE)
          && (AuthenticationLevel < RPC_C_AUTHN_LEVEL_PKT_PRIVACY) )
          {
          return RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
          }
       }

    return(AuthenticationLevel);
}


BOOL
DG_BINDING_HANDLE::SetTransportAuthentication(
                      IN  unsigned long  ulAuthenticationLevel,
                      IN  unsigned long  ulAuthenticationService,
                      OUT RPC_STATUS    *pStatus )
//  Routine Description:
//
//    Do transport specific security for one of the datagram transports.
//    This is currently only for the Falcon transport.
//
//  Return Values:
//
//    TRUE   -- Continue with the RPC level authenticaion.
//
//    FALSE  -- This setting is just for the transport, so don't continue
//              setting RPC level authenticaion.
//
{
   BOOL  fContinue;


   if (RPC_C_AUTHN_NONE == ulAuthenticationService)
      {
      // RPC_C_AUTHN_NONE is a special case that is applied to both RPC and transport
      // authentication.
      *pStatus = SetTransportOption(RPC_C_OPT_MQ_AUTHN_SERVICE,ulAuthenticationService);
      fContinue = TRUE;
      }
   else
      {
      *pStatus = SetTransportOption(RPC_C_OPT_MQ_AUTHN_SERVICE,ulAuthenticationService);

      if (RPC_S_OK == *pStatus)
         {
         *pStatus = SetTransportOption(RPC_C_OPT_MQ_AUTHN_LEVEL,ulAuthenticationLevel);
         fContinue = FALSE;
         }
      else
         {
         *pStatus = RPC_S_CANNOT_SUPPORT;
         fContinue = TRUE;
         }
      }

   return fContinue;
}



DG_CASSOCIATION::DG_CASSOCIATION(
    IN     RPC_DATAGRAM_TRANSPORT * a_Transport,
    IN     LONG                     a_AssociationFlag,
    IN     DCE_BINDING *            a_DceBinding,
    IN     BOOL                     a_Unique,
    IN OUT RPC_STATUS *             pStatus
    ) :
    Mutex               ( pStatus ),
    TransportInterface  ( a_Transport ),
    AssociationFlag     ( a_AssociationFlag ),
    pDceBinding         ( a_DceBinding ),
    CurrentPduSize      ( a_Transport->BasePduSize ),
    fLoneBindingHandle  ( (boolean) a_Unique ),
    RemoteWindowSize    ( 1 ),
    ServerAddress       ( 0 ),
    ServerBootTime      ( 0 ),
    ReferenceCount      ( 0 ),
    BindingHandleReferences( 0 ),
    InternalTableIndex  ( -1 ),
    KeepAliveHandle     ( 0 ),
    fServerSupportsAsync(FALSE),
    fErrorFlag          (FALSE)
/*++

Remarks:

    Notice that the object is initialized so that the destructor can be called
    even if the constructor bails out early.

Arguments:

    pDceBinding - DCE_BINDING that we are associated with
    pStatus     - where failure codes go; should be RPC_S_OK on entry

--*/
{
    ObjectType = DG_CASSOCIATION_TYPE;

    LogEvent(SU_CASSOC, EV_CREATE, this, 0, *pStatus);

    ResolvedEndpoint = NULL;

    if (*pStatus != RPC_S_OK)
        {
        LogError(SU_CASSOC, EV_CREATE, this, 0, *pStatus);
        return;
        }

    ServerAddress = this + 1;

    ResolvedEndpoint = new RPC_CHAR[1+TransportInterface->EndpointStringSize];
    if (!ResolvedEndpoint)
        {
        *pStatus = RPC_S_OUT_OF_MEMORY;
        return;
        }

    *pStatus = TransportInterface->InitializeAddress(ServerAddress,
                                                     pDceBinding->InqNetworkAddress(),
                                                     pDceBinding->InqEndpoint(),
                                                     TRUE, // use cache
                                                     ( a_AssociationFlag & BROADCAST) ? TRUE : FALSE
                                                     );
    if (*pStatus == RPC_P_FOUND_IN_CACHE)
        {
        *pStatus = RPC_S_OK;
        }

    if (*pStatus)
        {
        return;
        }

    LogEvent(SU_CASSOC, EV_START, this);

    *pStatus = ActiveAssociations->Add( this );
    if (*pStatus)
        {
        LogError(SU_CASSOC, EV_START, this, 0, *pStatus);
        return;
        }

    //
    // If this was created by a UNIQUE binding handle, we want connection keep-alives
    // even though no context handles point to it.  This will keep our connection
    // alive on the server.
    //
    IncrementBindingRefCount( fLoneBindingHandle );
    if (fLoneBindingHandle)
        {
        DelayedProcedures->Add(ContextHandleTimer, CXT_HANDLE_SWEEP_INTERVAL, FALSE);
        }

    LastReceiveTime = GetTickCount();
}


DG_CASSOCIATION::~DG_CASSOCIATION()
/*++

Routine Description:

    Destructor for a DG_CASSOCIATION. This will free up the cached DG_CCALL
    and deregister us from the transport.

Arguments:

    <none>

Return Value:

    <none>

--*/
{
    LogEvent(SU_CASSOC, EV_DELETE, this);

    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    PDG_CCONNECTION Connection;
    DictionaryCursor cursor;

    //
    // Delete all calls for this association..
    //
    InactiveConnections.Reset(cursor);
    while ( (Connection = InactiveConnections.Next(cursor)) != 0 )
        {
        InactiveConnections.Delete(Connection->AssociationKey);
        Connection->CancelDelayedAck();
        delete Connection;
        }

   delete pDceBinding;
   delete ResolvedEndpoint;
   delete KeepAliveHandle;

#if 0
   char * FirstAddress;
   char * SecondAddress;

   FirstAddress =  (char *) (this + 1);
   SecondAddress = FirstAddress + TransportInterface->AddressSize;

   ASSERT( ServerAddress == FirstAddress || ServerAddress == SecondAddress );

   TransportInterface->CloseAddress( FirstAddress );

   if (ServerAddress == SecondAddress)
       {
       TransportInterface->CloseAddress( SecondAddress );
       }
#endif
}


RPC_STATUS
DG_CASSOCIATION::ToStringBinding (
    OUT RPC_CHAR * * StringBinding,
    IN RPC_UUID *    ObjectUuid
    )
/*++

Routine Description:

    We need to convert the binding handle into a string binding.

Arguments:

    StringBinding - Returns the string representation of the binding
        handle.

    ObjectUuid - Supplies the object uuid of the binding handle which
        is requesting that we create a string binding.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY

--*/
{
    CLAIM_MUTEX Lock(Mutex);

    *StringBinding = pDceBinding->StringBindingCompose(ObjectUuid);
    if (*StringBinding == 0)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    return RPC_S_OK;
}


BOOL
OptionalStringsEqual(
    RPC_CHAR * String1,
    RPC_CHAR * String2
    )
/*++

Routine Description:

    Compares two strings, checking for NULL pointers.

Arguments:

    the strings

Return Value:

    TRUE if they are equal
    FALSE if they differ

--*/

{
    if (String1 == String2)
        {
        return TRUE;
        }

    if (!String1 || !String2)
        {
        return FALSE;
        }

    if (0 == RpcpStringCompare(String1, String2))
        {
        return TRUE;
        }

    return FALSE;
}


BOOL
DG_CASSOCIATION::ComparePartialBinding(
    PDG_BINDING_HANDLE Binding,
    void * InterfaceInformation
    )
/*++

Routine Description:

    Checks compatibility between the association and a partially-bound handle.

Arguments:

    Binding - the binding handle

    InterfaceInformation - a pointer to the RPC_INTERFACE to be used

Return Value:

    TRUE if the association is compatible
    FALSE if not

--*/

{
    RPC_CHAR * String1;
    RPC_CHAR * String2;

    CLAIM_MUTEX lock( Mutex );

    if (FALSE == OptionalStringsEqual(
                     pDceBinding->InqRpcProtocolSequence(),
                     Binding->pDceBinding->InqRpcProtocolSequence()
                     ))
        {
        return FALSE;
        }

    if (FALSE == OptionalStringsEqual(
                     pDceBinding->InqNetworkAddress(),
                     Binding->pDceBinding->InqNetworkAddress()
                     ))
        {
        return FALSE;
        }

    if (FALSE == OptionalStringsEqual(
                     pDceBinding->InqNetworkOptions(),
                     Binding->pDceBinding->InqNetworkOptions()
                     ))
        {
        return FALSE;
        }

    RPC_UUID Object;
    Binding->InquireObjectUuid(&Object);

    return InterfaceAndObjectDict.Find(InterfaceInformation, &Object);
}


BOOL
DG_CASSOCIATION::AddInterface(
    void *     InterfaceInformation,
    RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    Declares that this association supports the given <interface, object uuid>
    pair.

Arguments:

    InterfaceInformation - a pointer to the RPC_INTERFACE

    ObjectUuid - the object UUID

Return Value:

    TRUE if the pair was added to the dictionary
    FALSE if an error occurred

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    return InterfaceAndObjectDict.Insert(InterfaceInformation, ObjectUuid);
}


BOOL
DG_CASSOCIATION::RemoveInterface(
    void *     InterfaceInformation,
    RPC_UUID * ObjectUuid
    )
/*++

Routine Description:

    Declares that this association no longer supports the given
    <interface, object uuid> pair.

Arguments:

    InterfaceInformation - a pointer to the RPC_INTERFACE

    ObjectUuid - the object UUID


Return Value:

    TRUE if the pair was in the dictionary
    FALSE if not

--*/

{
    CLAIM_MUTEX Lock(Mutex);

    return InterfaceAndObjectDict.Delete(InterfaceInformation, ObjectUuid);
}


DG_CCONNECTION::DG_CCONNECTION(
    IN     PDG_CASSOCIATION    a_Association,
    IN     const CLIENT_AUTH_INFO *  a_AuthInfo,
    IN OUT RPC_STATUS *        pStatus
    ) :
    DG_COMMON_CONNECTION    (a_Association->TransportInterface, pStatus),
    Association             (a_Association),
    AuthInfo                (a_AuthInfo, pStatus),
    AssociationKey          (-1),
    TimeStamp               (0),
    SecurityContextId       (0),
    BindingHandle           (0),
    ThreadId                (0),
    CachedCalls             (0),
    ActiveCallHead          (0),
    ActiveCallTail          (0),
    CurrentCall             (0),
    AckPending              (0),
    AckOrphaned             (FALSE),
    SecurityBuffer          (0),
    SecurityBufferLength    (0),
    ServerResponded         (FALSE),
    CallbackCompleted       (FALSE),
    fServerSupportsAsync    (a_Association->fServerSupportsAsync),
    fSecurePacketReceived   (FALSE),
    InConnectionTable       (FALSE),
    fBusy                 (FALSE),
    PossiblyRunDown         (FALSE),
    fAutoReconnect          (FALSE),
    fError                  (FALSE),
    DelayedAckTimer         (DelayedAckFn, 0)
{
    ObjectType = DG_CCONNECTION_TYPE;
    LogEvent(SU_CCONN, EV_CREATE, this, a_Association, *pStatus);

    InterlockedIncrement(&ClientConnectionCount);

    if (RPC_S_OK != *pStatus)
        {
        return;
        }

    CurrentPduSize   = Association->CurrentPduSize;
    RemoteWindowSize = Association->RemoteWindowSize;

    *pStatus = UuidCreate((UUID *) &ActivityNode.Uuid);
    if (*pStatus == RPC_S_UUID_LOCAL_ONLY)
        {
        *pStatus = RPC_S_OK;
        }

    if (*pStatus)
        {
        return;
        }

    if (AuthInfo.AuthenticationLevel != RPC_C_AUTHN_LEVEL_NONE)
        {
        *pStatus = InitializeSecurityContext();

        if (*pStatus == RPC_P_CONTINUE_NEEDED ||
            *pStatus == RPC_P_COMPLETE_NEEDED ||
            *pStatus == RPC_P_COMPLETE_AND_CONTINUE)
            {
            *pStatus = RPC_S_OK;
            }
        }

    if (*pStatus)
        {
        LogError(SU_CCONN, EV_SEC_INIT1, this, IntToPtr(*pStatus), I_RpcGetExtendedError());
        return;
        }
}

DG_CCONNECTION::~DG_CCONNECTION()
{
    InterlockedDecrement(&ClientConnectionCount);
    LogEvent(SU_CCONN, EV_DELETE, this, Association);

#ifdef DEBUGRPC
    BOOL Cancelled = DelayedProcedures->Cancel(&DelayedAckTimer);

    ASSERT( !Cancelled );
#endif

    while ( AckPending )
        {
        Sleep(10);
        }

    while (CachedCalls)
        {
        DG_CCALL * Call = CachedCalls;

        CachedCalls = CachedCalls->Next;

        delete Call;
        }

    if (SecurityBuffer)
        {
        delete SecurityBuffer;
}
}


long
DG_CCONNECTION::DecrementRefCountAndKeepMutex()
{
    Mutex.VerifyOwned();

    long Count = --ReferenceCount;

    LogEvent(SU_CCONN, EV_DEC, this, 0, Count, TRUE);

    // Since this->ThreadId is still nonzero, no other thread will increment
    // the refcount behind our back.

    if (0 == Count)
        {
        TimeStamp = GetTickCount();

        fBusy = TRUE;
        MutexClear();

        fAutoReconnect = FALSE;
        fError         = FALSE;

        Association->ReleaseConnection(this);

        // the association may have been deleted
        }

    return Count;
}

long
DG_CCONNECTION::DecrementRefCount()
{
    long Count = DecrementRefCountAndKeepMutex();

    if (Count > 0)
        {
        MutexClear();
        }

    return Count;
}


void
DG_CCONNECTION::PostDelayedAck(
    )
{
    Mutex.VerifyOwned();

    LogEvent(SU_CCONN, EV_PROC, this, IntToPtr((AckOrphaned << 16) | AckPending), 0x41736f50);

    if (!AckPending)
        {
        IncrementRefCount();

        ++AckPending;
        DelayedAckTimer.Initialize(DelayedAckFn, this);
        DelayedProcedures->Add(&DelayedAckTimer, TWO_SECS_IN_MSEC, TRUE);
        }
}

void
DelayedAckFn(
    void * parm
    )
{
    PDG_CCONNECTION(parm)->SendDelayedAck();
}

void
DG_CCONNECTION::SendDelayedAck()
{
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 1 ), this );
    MutexRequest();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 2 ), this );

    LogEvent(SU_CCONN, EV_PROC, this, IntToPtr((AckOrphaned << 16) | AckPending), 0x41646e53);

    if (AckOrphaned)
        {
        AckOrphaned = FALSE;
        DecrementRefCount();
        return;
        }

    ASSERT( AckPending == 1 );

    //
    // Keep DG_CASSOCIATION::AllocateConnection() from taking the connection
    // once AckPending drops to zero.
    //
    fBusy = TRUE;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 3 ), this );
    --AckPending;
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 4 ), this );
    DecrementRefCountAndKeepMutex();
    CurrentCall->SendAck();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 5 ), this );
    CurrentCall->DecrementRefCount();
                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 6 ), this );
}

void
DG_CCONNECTION::CancelDelayedAck(
                                 BOOL Flush
                                 )
{
    boolean Cancelled;

    if (Flush)
        {
        if (!MutexTryRequest())
            {
            return;
            }
        }
    else
        {
        MutexRequest();
        }

    ASSERT( AckPending == 0 || AckPending == 1 );

    Cancelled = (boolean) DelayedProcedures->Cancel(&DelayedAckTimer);

    LogEvent(SU_CCONN, EV_PROC, this, IntToPtr((Cancelled << 16) | AckPending), 0x416e6143);

                                                                CallTestHook( MAKE_TEST_HOOK_ID( TH_DG_SEND_ACK, 7 ), this, (PVOID) Cancelled );

    if (AckPending)
        {
        if (Flush)
            {
            CurrentCall->SendAck();
            }

        if (Cancelled)
            {
            // the proc was queued and had not yet fired
            //
            DecrementRefCountAndKeepMutex();
            }
        else
            {
            // the proc was called but had not yet taken the connection mutex.
            // some callers of this procedure already hold the mutex, so we can't release it
            // and let the othre thread run.  So we set this flag to let it know not to send
            // the ack.  There is no need to keep a count: there is only one delayed-procedure
            // thread, so only one such proc can be outstanding at a time.

            // This assert doesn't work: if a proc is orphaned, then AckPending is TRUE.
            // Until that thread finishes, every time another thread calls CancelDelayedAck
            // it will come here.
            //
            // ASSERT( AckOrphaned == FALSE );

            AckOrphaned = TRUE;
            }

        --AckPending;
        CurrentCall->DecrementRefCount();
        }
    else
        {
        if (Cancelled)
            {
            ASSERT( 0 && "delayed ack queued but AckPending == 0" );
            }
        else
            {
            // The proc was not queued, or already ran to completion
            //
            }
        MutexClear();
        }
}


DG_CCALL::DG_CCALL(
    IN  PDG_CCONNECTION    a_Connection,
    OUT RPC_STATUS *       pStatus
    ) : State                   (CallInit),
    Connection              (a_Connection),
    InterfacePointer        (0),
    DelayedSendPending      (0),
    CancelPending           (FALSE),

#pragma warning(disable:4355)
    TransmitTimer           (DelayedSendProc, this),
#pragma warning(default:4355)

    DG_PACKET_ENGINE( DG_REQUEST,
                      DG_PACKET::AllocatePacket(a_Connection->TransportInterface->ExpectedPduSize),
                      pStatus )
{

    Previous = Next = 0;

    ObjectType = DG_CCALL_TYPE;
    pAsync = 0;

    InterlockedIncrement(&ClientCallCount);

    if (*pStatus != RPC_S_OK)
        {
        return;
        }

    CancelEventId = 1;

    ReadConnectionInfo(a_Connection, 0);

    pSavedPacket->Header.ActivityHint  = 0xffff;

    LogEvent(SU_CCALL, EV_CREATE, this, a_Connection);
}

DG_CCALL::~DG_CCALL()
{
    LogEvent(SU_CCALL, EV_DELETE, this, Connection);
    InterlockedDecrement(&ClientCallCount);
}

inline RPC_STATUS
DG_CCALL::GetInitialBuffer(
    IN OUT RPC_MESSAGE * Message,
    IN UUID *MyObjectUuid
    )
{
    AsyncStatus = RPC_S_ASYNC_CALL_PENDING;

    Message->Handle = (RPC_BINDING_HANDLE) this;

    Next = DG_CCALL_NOT_ACTIVE;

    if (MyObjectUuid)
        {
        UuidSpecified = 1;
        RpcpMemoryCopy(&ObjectUuid, MyObjectUuid, sizeof(UUID));
        }
    else if (Connection->BindingHandle->InqIfNullObjectUuid() == 0)
        {
        UuidSpecified = 1;
        RpcpMemoryCopy(&ObjectUuid,
                       Connection->BindingHandle->InqPointerAtObjectUuid(),
                       sizeof(UUID));
        }
    else
        {
        UuidSpecified = 0;
        }

    if (GetTickCount() - Connection->TimeStamp > (3 * 60 * 1000))
        {
        Connection->PossiblyRunDown = TRUE;
        }

    RPC_STATUS Status = GetBuffer(Message);

    if (Status)
        {
        Connection->MutexRequest();
        DecrementRefCount();
        }

    return Status;
}

long
DG_CCALL::DecrementRefCount()
{
    long Count = DecrementRefCountAndKeepMutex();

    if (Count > 0)
        {
        Connection->MutexClear();
        }

    return Count;
}

long
DG_CCALL::DecrementRefCountAndKeepMutex()
{
    Connection->Mutex.VerifyOwned();

    --ReferenceCount;

    LogEvent(SU_CCALL, EV_DEC, this, 0, ReferenceCount);

    if (ReferenceCount == 0)
        {
        ASSERT( !DelayedSendPending );

        if (SourceEndpoint)
            {
            EndpointManager->ReleaseEndpoint(SourceEndpoint);
            SourceEndpoint = 0;
            }

        TimeStamp = GetTickCount();

//        ASSERT( !LastReceiveBuffer );

//        CheckForLeakedPackets();

        SetState(CallInit);

        Connection->EndCall(this);
        Connection->AddCallToCache(this);

        return Connection->DecrementRefCountAndKeepMutex();
        }
    else
        {
        return 1;
        }
}


RPC_STATUS
DG_CCONNECTION::TransferCallsToNewConnection(
    PDG_CCALL FirstCall,
    PDG_CCONNECTION NewConnection
    )
{
    PDG_CCALL Call;
    PDG_CCALL NextCall;

    int Count;

    for (Call = FirstCall; Call; Call = NextCall)
        {
        LogError(SU_CCONN, EV_TRANSFER, this, Call);

        NextCall = Call->Next;

        EndCall(Call);
        Count = DecrementRefCountAndKeepMutex();

        NewConnection->BeginCall(Call);
        NewConnection->IncrementRefCount();

        Call->SwitchConnection(NewConnection);
        }

    //
    // AllocateConnection() incremented the refcount so now we have one ref too many.
    //
    NewConnection->DecrementRefCountAndKeepMutex();

    // <this> may have been deleted, I'm not sure.

    if (Count)
        {
        MutexClear();
        }

    NewConnection->fAutoReconnect = TRUE;

    return RPC_S_OK;
}


void
DG_CASSOCIATION::DeleteIdleConnections(
    long CurrentTime
    )
{
    DictionaryCursor cursor;

    if (CurrentTime - LastScavengeTime < IDLE_CCONNECTION_SWEEP_INTERVAL )
        {
        return;
        }

    if (fLoneBindingHandle)
        {
        //
        // This was created by a binding that wanted exclusive use of the association.
        // The way the cluster guys are using it, retiring connections  would only be
        // an intrusion.
        //
        return;
        }

    long ContextHandles = ActiveAssociations->GetContextHandleCount(this);

    MutexRequest();

    if (CurrentTime - LastScavengeTime < IDLE_CCONNECTION_SWEEP_INTERVAL )
        {
        MutexClear();
        return;
        }

    InactiveConnections.Reset(cursor);

    DG_CCONNECTION * Head = 0;
    DG_CCONNECTION * Node = InactiveConnections.Next(cursor);

    //
    // We should never see a context handle on an association with no connections.
    // We preserve one connection on the association so that we can send keep-alives.
    //
    if (ContextHandles > 0 && ActiveConnections.Size() == 0)
        {
        ASSERT( Node );

        Node = InactiveConnections.Next(cursor);
        }

    while (Node)
        {
        if (CurrentTime - Node->TimeStamp > IDLE_CCONNECTION_LIFETIME)
            {
            InactiveConnections.Delete(Node->AssociationKey);

            Node->Next = Head;
            Head = Node;
            }

        Node = InactiveConnections.Next(cursor);
        }

    LastScavengeTime = CurrentTime;

    MutexClear();

    while (Head)
        {
        Node = Head->Next;

        Head->CancelDelayedAck();
        delete Head;

        Head = Node;
        }
}


DG_CCALL *
DG_CCONNECTION::FindIdleCalls(
    long CurrentTime
    )
{
    Mutex.VerifyOwned();

    if (CurrentTime - LastScavengeTime < IDLE_CCALL_SWEEP_INTERVAL )
        {
        return 0;
        }

    LastScavengeTime = CurrentTime;


    DG_CCALL * Node;

    for (Node = CachedCalls; Node; Node = Node->Next)
        {
        if (CurrentTime - Node->TimeStamp > IDLE_CCALL_LIFETIME )
            {
            break;
            }
        }

    if (Node)
        {
        DG_CCALL * Next = Node->Next;
        Node->Next = 0;
        Node = Next;
        }

    return Node;
}


RPC_STATUS
DG_CCALL::GetBuffer(
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This method is called to actually allocate memory for an rpc call.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.
    ObjectUuid - Ignored

Return Value:

    RPC_S_OUT_OF_MEMORY
    RPC_S_OK

--*/
{
    LogEvent(SU_CCALL, EV_PROC, this, IntToPtr(Message->BufferLength), 'G' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    RPC_STATUS Status = CommonGetBuffer(Message);

    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    if (Status)
        {
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);
        }

    return Status;
}


void
DG_CCALL::FreeBuffer(
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This is called by stubs in order to free a marshalling buffer.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    <none>

--*/
{
    FreePipeBuffer(Message);

    Connection->MutexRequest();
    DecrementRefCount();
}

void
DG_CCALL::FreePipeBuffer (
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    Called by stubs to free a buffer used for marshalling pipe data.

Arguments:

    Message - description of the buffer

Return Value:

z    none

--*/

{
    LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'F' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    CommonFreeBuffer(Message);
}


RPC_STATUS
DG_CCALL::ReallocPipeBuffer (
    IN PRPC_MESSAGE Message,
    IN unsigned int NewSize
    )
/*++

Routine Description:

    Called by stubs to change the size of a pipe buffer.  If possible, the
    buffer will be reallocated in place; otherwise, we will allocate a new
    buffer and duplicate the existing data.

Arguments:

    Message - (on entry) describes the existing  buffer
              (on exit)  describes the new buffer

    NewSize - new requested buffer size

Return Value:

    mainly RPC_S_OK for success or RPC_S_OUT_OF_MEMORY for failure

--*/

{
    LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'R' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    RPC_STATUS Status = CommonReallocBuffer(Message, NewSize);

    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    if (Status)
        {
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);
        }

    return Status;
}


void
DG_CCALL::BuildNcaPacketHeader(
    PNCA_PACKET_HEADER Header,
    PRPC_MESSAGE       Message
    )
/*++

Routine Description:

    Given an input RPC_MESSAGE, builds a nca packet header.

Arguments:

    pNcaPacketHeader - Where to build the new packet header.

    Message - The original RPC_MESSAGE.

Return Value:

    <none>

--*/
{
    PRPC_CLIENT_INTERFACE pCli = (PRPC_CLIENT_INTERFACE) (Message->RpcInterfaceInformation);
    RPC_UUID * pUuid = (RPC_UUID *) (&(pCli->InterfaceId.SyntaxGUID));

    Header->InterfaceId = *pUuid;

    if (UuidSpecified)
        {
        RpcpMemoryCopy(&(Header->ObjectId), &ObjectUuid, sizeof(UUID));
        }
    else
        {
        RpcpMemorySet(&Header->ObjectId, 0, sizeof(UUID));
        }

    Header->InterfaceVersion.MajorVersion = pCli->InterfaceId.SyntaxVersion.MajorVersion;
    Header->InterfaceVersion.MinorVersion = pCli->InterfaceId.SyntaxVersion.MinorVersion;

    Header->SequenceNumber  = SequenceNumber;
    Header->OperationNumber = (unsigned short) Message->ProcNum;
    Header->ServerBootTime  = Connection->Association->ServerBootTime;

    Header->InterfaceHint  = 0xffff;
    Header->PacketType     = DG_REQUEST;
    Header->PacketFlags    = (unsigned char) RpcToPacketFlagsArray[Message->RpcFlags & RPC_NCA_PACKET_FLAGS];
    Header->PacketFlags2   = 0;
}


inline RPC_STATUS
DG_CCONNECTION::UpdateServerAddress(
    IN DG_PACKET *          Packet,
    IN DG_TRANSPORT_ADDRESS Address
    )
{
    ServerResponded = TRUE;

    Association->CurrentPduSize   = CurrentPduSize;
    Association->RemoteWindowSize = RemoteWindowSize;

    return Association->UpdateAssociationWithAddress( Packet, Address );
}


void
DG_CCALL::SendAck(
    )
{
    LogEvent(SU_CCALL, EV_ACK, this);

    pSavedPacket->Header.PacketType    = DG_ACK;
    pSavedPacket->SetPacketBodyLen(0);
    pSavedPacket->SetFragmentNumber(ReceiveFragmentBase);

    SetSerialNumber(&pSavedPacket->Header, SendSerialNumber);

    Connection->SealAndSendPacket(SourceEndpoint, 0, &pSavedPacket->Header, 0);

    if (FALSE == SourceEndpoint->Async)
        {
        SourceEndpoint->Flags |= PENALTY_BOX;
        }
}

inline RPC_STATUS
DG_CCALL::SendPing(
    )
{
    pSavedPacket->Header.PacketType = DG_PING;
    pSavedPacket->Header.PacketFlags &= DG_PF_IDEMPOTENT;
    pSavedPacket->SetPacketBodyLen(0);

    AddSerialNumber(&pSavedPacket->Header);

    unsigned Frag = (pSavedPacket->Header.PacketType << 16) | pSavedPacket->GetFragmentNumber();
    LogEvent(SU_CCALL, EV_PKT_OUT, this, 0, Frag);

    RPC_STATUS Status = Connection->SealAndSendPacket(SourceEndpoint, 0, &pSavedPacket->Header, 0);

    ++SendSerialNumber;

    return Status;
}


PDG_CCONNECTION
MapGenericHandleToConnection(
    handle_t Handle,
    UUID * Uuid
    )
{
    PDG_CCONNECTION Connection;

    ASSERT( Handle );

    if (PMESSAGE_OBJECT(Handle)->Type(DG_CCONNECTION_TYPE))
        {
        Connection = PDG_CCONNECTION(Handle);

        Connection->MutexRequest();
        }
    else
        {
        ASSERT( PMESSAGE_OBJECT(Handle)->Type(DG_CALLBACK_TYPE) );

        Connection = PDG_CLIENT_CALLBACK(Handle)->Connection;
        if (Connection)
            {
            Connection->MutexRequest();
            }
        else
            {
            Connection = ClientConnections->Lookup( (RPC_UUID *) Uuid );
            PDG_CLIENT_CALLBACK(Handle)->Connection = Connection;
            }
        }

    return Connection;
}

#define CCC_SEQUENCE    0x0001
#define CCC_CAS         0x0002
#define CCC_AUTH        0x0004
#define CCC_ASYNC_OK    0x0008
#define CCC_AUTH_MORE   0x0010

void
ConvCore(
    DWORD           Bits,
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    byte *          InData,
    long            InLength,
    long            OutMaxLength,
    unsigned long * SequenceNumber,
    UUID *          pCASUuid,
    byte *          OutData,
    long *          pOutLength,
    error_status_t *Status
    )
{
    if (pOutLength)
        {
        *pOutLength = 0;
        }

    PDG_CCONNECTION Connection = MapGenericHandleToConnection(Handle, Uuid);

    LogEvent(SU_CCONN, EV_CALLBACK, Connection, 0, Bits);

    if (!Connection)
        {
        *Status = NCA_STATUS_BAD_ACTID;

        RpcAsyncCompleteCall(AsyncHandle, 0);
        return;
        }

    //
    // See if this activity id has a call in progress.
    //
    if (Connection->ActivityNode.CompareUuid(Uuid) != 0)
        {
        Connection->MutexClear();
        *Status = NCA_STATUS_BAD_ACTID;
        RpcAsyncCompleteCall(AsyncHandle, 0);
        return;
        }

    *Status = RPC_S_OK;

    if (Connection->Association->ServerBootTime == 0)
        {
        //
        // the server is responding to our first call.
        //
        Connection->Association->ServerBootTime       = ServerBootTime;
        }
    else if (Connection->Association->ServerBootTime != ServerBootTime)
        {
        //
        // The server crashed.
        //
        Connection->MutexClear();
        *Status = NCA_STATUS_YOU_CRASHED;
        RpcAsyncCompleteCall(AsyncHandle, 0);
        return;
        }

    if (Bits & CCC_ASYNC_OK)
        {
        Connection->EnableOverlappedCalls();
        }

    if (Bits & CCC_SEQUENCE)
        {
        *SequenceNumber = Connection->GetSequenceNumber();
        }

    if (Bits & CCC_CAS)
        {
        ASSERT( ActiveAssociations->fCasUuidReady );

        *pCASUuid = ActiveAssociations->CasUuid;
        }

    if (Bits & CCC_AUTH)
        {
        if (Connection->PossiblyRunDown)
            {
            Connection->PossiblyRunDown = FALSE;
            Connection->fSecurePacketReceived = FALSE;
            }

        *Status = MapToNcaStatusCode(
                        Connection->DealWithAuthCallback(
                                    InData,
                                    InLength,
                                    OutData,
                                    OutMaxLength,
                                    pOutLength
                                    )
                        );
        }

    if (Bits & CCC_AUTH_MORE)
        {
        *Status = MapToNcaStatusCode(
                        Connection->DealWithAuthMore(
                                    InLength,
                                    OutData,
                                    OutMaxLength,
                                    pOutLength
                                    )
                        );
        }

    if (RPC_S_OK == *Status)
        {
        Connection->CallbackCompleted = TRUE;
        }

    Connection->MutexClear();
    RpcAsyncCompleteCall(AsyncHandle, 0);
}

void
conv_are_you_there(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t Handle,
    UUID * Uuid,
    unsigned long ServerBootTime,
    error_status_t *Status
    )
{
    ConvCore(0,                 // bits
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             0,                 // sequence number
             0,                 // CAS UUID
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
conv_who_are_you(
    PRPC_ASYNC_STATE AsyncHandle,
    IN handle_t           Handle,
    IN UUID          *    Uuid,
    IN unsigned long      ServerBootTime,
    OUT unsigned long *   SequenceNumber,
    OUT error_status_t *  Status
    )

/*++

Routine Description:

    This is the conv_who_are_you callback routine that the server will
    call to check if it crashed.

Arguments:

    pUuid - Activity Uuid.

    ServerBootTime - The server's record of its boot time.

    SequenceNumber - We return our record of our sequence number.

    Status - 0 if we think things are ok, else an NCA error code

Return Value:

    <none>
--*/

{
    ConvCore(CCC_SEQUENCE,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             SequenceNumber,
             0,                 // CAS UUID
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
conv_who_are_you2(
    PRPC_ASYNC_STATE AsyncHandle,
    IN  handle_t            Handle,
    IN  UUID          *     Uuid,
    IN  unsigned long       ServerBootTime,
    OUT unsigned long *     SequenceNumber,
    OUT UUID          *     pCASUuid,
    OUT error_status_t *    Status
    )

/*++

Routine Description:

    This is the conv_who_are_you callback routine that the server will
    call to check if it crashed.

Arguments:


Return Value:

    <none>
--*/

{
    ConvCore(CCC_SEQUENCE | CCC_CAS,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             SequenceNumber,
             pCASUuid,
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
conv_who_are_you_auth(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    byte *          InData,
    long            InLength,
    long            OutMaxLength,
    unsigned long * SequenceNumber,
    UUID *          pCASUuid,
    byte *          OutData,
    long *          pOutLength,
    error_status_t *Status
    )
{
    ConvCore(CCC_SEQUENCE | CCC_CAS | CCC_AUTH,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             InData,
             InLength,
             OutMaxLength,
             SequenceNumber,
             pCASUuid,
             OutData,
             pOutLength,
             Status
             );
}



void
conv_who_are_you_auth_more(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    long            Index,
    long            OutMaxLength,
    byte *          OutData,
    long *          pOutLength,
    error_status_t *Status
    )
{
    ConvCore(CCC_AUTH_MORE,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,
             Index,
             OutMaxLength,
             0,
             0,
             OutData,
             pOutLength,
             Status
             );
}



void
ms_conv_are_you_there(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    error_status_t *Status
    )
/*++

Routine Description:

    This is the conv_who_are_you callback routine that the server will
    call to check if it crashed.

Arguments:


Return Value:

    <none>
--*/

{
    ConvCore(CCC_ASYNC_OK,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             0,                 // sequence number
             0,                 // CAS UUID
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
ms_conv_who_are_you2(
    PRPC_ASYNC_STATE        AsyncHandle,
    IN  handle_t            Handle,
    IN  UUID          *     Uuid,
    IN  unsigned long       ServerBootTime,
    OUT unsigned long *     SequenceNumber,
    OUT UUID          *     pCASUuid,
    OUT error_status_t *    Status
    )

/*++

Routine Description:

    This is the conv_who_are_you callback routine that the server will
    call to check if it crashed.

Arguments:


Return Value:

    <none>
--*/

{
    ConvCore(CCC_ASYNC_OK | CCC_SEQUENCE | CCC_CAS,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             0,                 // in  auth data
             0,                 // in  auth data length
             0,                 // out auth data max length
             SequenceNumber,
             pCASUuid,
             0,                 // out auth data
             0,                 // out auth data length
             Status
             );
}


void
ms_conv_who_are_you_auth(
    PRPC_ASYNC_STATE AsyncHandle,
    handle_t        Handle,
    UUID *          Uuid,
    unsigned long   ServerBootTime,
    byte *          InData,
    long            InLength,
    long            OutMaxLength,
    unsigned long * SequenceNumber,
    UUID *          pCASUuid,
    byte *          OutData,
    long *          pOutLength,
    error_status_t *Status
    )
{
    ConvCore(CCC_ASYNC_OK | CCC_SEQUENCE | CCC_CAS | CCC_AUTH,
             AsyncHandle,
             Handle,
             Uuid,
             ServerBootTime,
             InData,
             InLength,
             OutMaxLength,
             SequenceNumber,
             pCASUuid,
             OutData,
             pOutLength,
             Status
             );
}


void
DG_CCONNECTION::EnableOverlappedCalls()
{
    Association->fServerSupportsAsync = TRUE;

    if (FALSE == fServerSupportsAsync)
        {
        fServerSupportsAsync = TRUE;

        MutexRequest();
        MaybeTransmitNextCall();
        MutexClear();
        }
}


RPC_STATUS
DG_CCALL::GetEndpoint(
    DWORD EndpointFlags
    )
{
    SourceEndpoint = EndpointManager->RequestEndpoint(
                   Connection->TransportInterface,
                   (pAsync) ? TRUE : FALSE,
                   EndpointFlags
                   );

    if (!SourceEndpoint)
        {
        return RPC_S_OUT_OF_RESOURCES;
        }

    if (pSavedPacket->MaxDataLength < SourceEndpoint->Stats.PreferredPduSize)
        {
        PDG_PACKET NewPacket = DG_PACKET::AllocatePacket(SourceEndpoint->Stats.PreferredPduSize);
        if (!NewPacket)
            {
            EndpointManager->ReleaseEndpoint(SourceEndpoint);
            SourceEndpoint = 0;
            return RPC_S_OUT_OF_MEMORY;
            }

        NewPacket->Header = pSavedPacket->Header;

        FreePacket(pSavedPacket);
        pSavedPacket = NewPacket;
        }

    //
    // If there is a chance that the endpoint has queued ICMP rejects, drain them.
    //
    if (FALSE == SourceEndpoint->Async &&
        (SourceEndpoint->Flags & PENALTY_BOX))
        {
        RPC_STATUS Status;

        do
            {
            PDG_PACKET Packet = 0;
            DG_TRANSPORT_ADDRESS ReceiveAddress = 0;
            unsigned Length = 0;
            void * Buffer = 0;

            Status = Connection->TransportInterface->SyncReceive(
                                    &SourceEndpoint->TransportEndpoint,
                                    &ReceiveAddress,
                                    &Length,
                                    &Buffer,
                                    0
                                    );

            LogEvent( SU_CCALL, EV_PKT_IN, Connection, Buffer, Status);

            if (Buffer)
                {
                Packet = DG_PACKET::FromPacketHeader(Buffer);
                Packet->DataLength = Length;

                FreePacket(Packet);
        }

            if (Status == RPC_P_PORT_DOWN)
                {
                Status = 0;
                }

            }
        while ( !Status );
        }

    SourceEndpoint->Flags &= ~(PENALTY_BOX);

    return 0;
}


RPC_STATUS
DG_CCALL::BeforeSendReceive(
    PRPC_MESSAGE Message
    )
{
    DWORD         EndpointFlags;
    RPC_STATUS    Status;

    NotificationIssued = -1;

    ASSERT( 0 == (Connection->BindingHandle->EndpointFlags & PORT_FOR_MAYBE_CALLS));

    EndpointFlags = Connection->BindingHandle->EndpointFlags;

    if (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE)
        {
        if (FALSE == Connection->Association->TransportInterface->IsMessageTransport)
            {
            EndpointFlags |= PORT_FOR_MAYBE_CALLS;
            }
        }

    Status = GetEndpoint(EndpointFlags);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    Status = Connection->BeginCall(this);
    if (Status != RPC_S_OK)
        {
        EndpointManager->ReleaseEndpoint(SourceEndpoint);
        SourceEndpoint = 0;
        return Status;
        }

    InterfacePointer = (PRPC_CLIENT_INTERFACE) Message->RpcInterfaceInformation;

    UnansweredRequestCount  = 0;

    NewCall();

    //
    // Set transport specific options for this binding handle (if any).
    // NOTE: These options are from RpcBindingSetOption().
    //
    if ( (Connection->BindingHandle->pvTransportOptions)
         && (Connection->Association->TransportInterface->ImplementOptions) )
       {
       Status = Connection->Association->TransportInterface->ImplementOptions(
                                                                SourceEndpoint->TransportEndpoint,
                                                                Connection->BindingHandle->pvTransportOptions);
       }

    //
    // Fill in common fields of the send packet.
    //
    BuildNcaPacketHeader(&pSavedPacket->Header, Message);

    BasePacketFlags = pSavedPacket->Header.PacketFlags;

    SetState(CallQuiescent);

    ForceAck        = FALSE;
    AllArgsSent     = FALSE;
    StaticArgsSent  = FALSE;

    ASSERT( !DelayedSendPending );

//#ifdef NTENV

    if (!pAsync)
        {
        Status = RegisterForCancels(this);
        if (Status != RPC_S_OK)
            {
            Connection->EndCall(this);

            EndpointManager->ReleaseEndpoint(SourceEndpoint);
            SourceEndpoint = 0;

            return Status;
            }
        }
//#endif

    //
    // If this is a call on the "conv" interface, we should set it also.
    //
    PRPC_CLIENT_INTERFACE pCli = (PRPC_CLIENT_INTERFACE) (Message->RpcInterfaceInformation);
    RPC_UUID * pUuid = (RPC_UUID *) (&(pCli->InterfaceId.SyntaxGUID));

    if (0 == pUuid->MatchUuid((RPC_UUID *) &((PRPC_SERVER_INTERFACE) conv_ServerIfHandle)->InterfaceId.SyntaxGUID ))
        {
        BasePacketFlags2 = DG_PF2_UNRELATED;
        if (Previous)
            {
            Previous->ForceAck = TRUE;
            }
        }

    unsigned TimeoutLevel = Connection->BindingHandle->InqComTimeout();

    if (Message->RpcFlags & RPC_NCA_FLAGS_BROADCAST)
        {
        ReceiveTimeout = 3000;
        TimeoutLimit = 1000 * (TimeoutLevel+1)/2;
        }
    else if (TimeoutLevel == RPC_C_BINDING_INFINITE_TIMEOUT)
        {
        ReceiveTimeout = 5000;
        TimeoutLimit = 0x7fffffff;
        }
    else if (Connection->TransportInterface->IsMessageTransport)
        {
        ReceiveTimeout = 5000;
        TimeoutLimit = 300000 + 10000 * ( 1 << TimeoutLevel );
        }
    else
        {
        ReceiveTimeout = 250 + 250 * (TimeoutLevel+1)/2;
        TimeoutLimit = 1000 * ( 1 << TimeoutLevel );
        }

    LastReceiveTime = GetTickCount();

    return Status;
}


RPC_STATUS
DG_CCALL::AfterSendReceive(
    PRPC_MESSAGE Message,
    RPC_STATUS Status
    )
{
    DG_BINDING_HANDLE * OldBinding = 0;

    Connection->Mutex.VerifyOwned();

    PDG_CASSOCIATION Association = Connection->Association;

    CancelDelayedSend();

//#ifdef NTENV

    if (!pAsync)
        {
        EVAL_AND_ASSERT(RPC_S_OK == UnregisterForCancels());
        }

//#endif

    if (RPC_S_OK == Status)
        {
        ASSERT( !Buffer );

        Connection->PossiblyRunDown = FALSE;

        if (0 == (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE))
            {
            Association->ClearErrorFlag();
            }

        // NOTE: No ACK for [message] calls.
        if ( (ForceAck) && !(Message->RpcFlags & RPCFLG_MESSAGE) )
            {
            SendAck();
            }
        else if (Next)
            {
            //
            // Don't ACK because we will transmit the next queued call momentarily.
            //
            }
        else if (0 == (BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT) ||
                 Message->BufferLength > MaxFragmentSize)
            {
            //
            // NOTE: We don't need an ACK for [message] calls...
            //
            if ( !(Message->RpcFlags & RPCFLG_MESSAGE) &&
                 !(Message->RpcFlags & RPC_NCA_FLAGS_MAYBE) )
                {
                ++ReferenceCount;
                LogEvent(SU_CCALL, EV_INC, this, 0, ReferenceCount);
                Connection->PostDelayedAck();
                }
            }
        }
    else
        {
        if (FALSE == SourceEndpoint->Async)
            {
            SourceEndpoint->Flags |= PENALTY_BOX;
            }

        Status = MapErrorCode(Status);

        CleanupSendWindow();
        CleanupReceiveWindow();

        if (RPC_S_SERVER_UNAVAILABLE == Status ||
            RPC_S_UNKNOWN_IF         == Status ||
            RPC_S_CALL_FAILED        == Status ||
            RPC_S_CALL_FAILED_DNE    == Status ||
            RPC_S_COMM_FAILURE       == Status ||
            RPC_S_CALL_CANCELLED     == Status ||
            RPC_S_PROTOCOL_ERROR     == Status
            )
            {
            Connection->fError = TRUE;
            Association->SetErrorFlag();
            OldBinding = Connection->BindingHandle;
            OldBinding->IncrementRefCount();
            }
        }

    SetState(CallComplete);

    pAsync = 0;

    long CurrentTime = GetTickCount();
    DG_CCALL * IdleCalls = Connection->FindIdleCalls(CurrentTime);

    if (Status == RPC_S_OK)
        {
        Connection->MutexClear();

        //
        // Record that this interface is valid for this association.
        //
        Association->AddInterface(Message->RpcInterfaceInformation, &pSavedPacket->Header.ObjectId);
        }
    else
        {
        RPC_UUID Object;

        Object.CopyUuid(&pSavedPacket->Header.ObjectId);
        Association->IncrementRefCount();

        //
        // If the call is dying, we need to free the current buffer here
        // instead of letting NDR do it on the usual schedule.
        //
        if (0 == DecrementRefCount())
            {
            FreePipeBuffer(Message);
            Message->Handle = 0;
            }

        Association->RemoveInterface(Message->RpcInterfaceInformation, &Object);
        Association->DecrementRefCount();
        }

    if (OldBinding)
        {
        OldBinding->DisassociateFromServer();
        OldBinding->DecrementRefCount();
        }

    while (IdleCalls)
        {
        DG_CCALL * Next = IdleCalls->Next;

        delete IdleCalls;

        IdleCalls = Next;
        }

    return Status;
}


RPC_STATUS
DG_CCALL::MapErrorCode(
    RPC_STATUS Status
    )
{
    LogError(SU_CCALL, EV_STATUS, this, 0, Status);

    //
    // Map security errors to access-denied.
    //
    if (0x80090000UL == (Status & 0xffff0000UL))
        {
#ifdef DEBUGRPC
        if (Status != SEC_E_NO_IMPERSONATION     &&
            Status != SEC_E_UNSUPPORTED_FUNCTION )
            {
            PrintToDebugger("RPC DG: mapping security error %lx to access-denied\n", Status);
            }
#endif
        Status = RPC_S_SEC_PKG_ERROR;
        }

    //
    // We have to return CALL_FAILED if all the [in] static parms have
    // been sent, even if they weren't acknowledged.
    //
    if (RPC_P_HOST_DOWN      == Status ||
        RPC_P_PORT_DOWN      == Status ||
        RPC_P_SEND_FAILED    == Status ||
        RPC_P_RECEIVE_FAILED == Status ||
        RPC_P_TIMEOUT        == Status )
        {
        if (Connection->CallbackCompleted &&
            !(BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT) &&
            StaticArgsSent)
            {
            Status = RPC_S_CALL_FAILED;
            }
        else if (Connection->ServerResponded)
            {
            Status = RPC_S_CALL_FAILED_DNE;
            }
        else
            {
            Status = RPC_S_SERVER_UNAVAILABLE;
            }
        }

    return Status;
}


RPC_STATUS
DG_CCALL::SendReceive(
    IN OUT PRPC_MESSAGE Message
    )
{
    LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 0x52646e53);

    RPC_STATUS Status;

    ASSERT(  !(Message->RpcFlags & RPC_BUFFER_ASYNC) && !pAsync);

    Connection->MutexRequest();

    Status = BeforeSendReceive(Message);
    if (Status)
        {
        FreeBuffer(Message);

        Connection->MutexClear();

        return Status;
        }

    //
    // [maybe], [maybe, broadcast] and [message] calls.
    //
    if (  (Message->RpcFlags & RPC_NCA_FLAGS_MAYBE)
          || (Message->RpcFlags & RPCFLG_MESSAGE) )
        {
        Message->RpcFlags |= RPC_NCA_FLAGS_MAYBE;

        Status = MaybeSendReceive(Message);

        return AfterSendReceive(Message, Status);
        }

    if (Message->RpcFlags & RPC_NCA_FLAGS_BROADCAST)
        {
        if (Message->BufferLength > SourceEndpoint->Stats.PreferredPduSize)
            {
            FreeBuffer(Message);
            Connection->MutexClear();

            return RPC_S_SERVER_UNAVAILABLE;
            }
        }

    //
    // Send a single burst of packets.
    // An asynchronous call will return to the caller; an ordinary call
    // will loop until the call is complete.
    //
    SetFragmentLengths();

    SetState(CallSendReceive);

    Status = PushBuffer(Message);
    if (Status)
        {
        LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);

        FreePipeBuffer(Message);

        return AfterSendReceive(Message, Status);
        }

    ASSERT( !Message->Buffer );
    ASSERT( !Message->BufferLength );

    while (RPC_S_OK == Status && FALSE == fReceivedAllFragments)
        {
        Status = ReceiveSinglePacket();
        }

    if (Status)
        {
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);
        }

    if (RPC_S_OK == Status)
        {
        Status = AssembleBufferFromPackets(Message, this);
        }

    //
    // Depending upon circumstances, AfterSendReceive() may cause the ccall,
    // the association, and/or the binding handle to be freed.
    //

    SetState(CallQuiescent);

    return AfterSendReceive(Message, Status);
}


RPC_STATUS
DG_CCALL::AttemptAutoReconnect()
{
    RPC_STATUS Status;

    ASSERT( State == CallSend || State == CallSendReceive ||
            (State == CallReceive && !fRetransmitted && SendWindowBase == 0
             ) );

/*

If the call's association has the error flag set, look for a follow-up
association, otherwise create a follow-up association.

link the binding handle to the new association, and ask it for a connection
to be associated with the existing connection's thread ID.  Move this call
and successors to the new connection, send some packets, and return
to the packet loop.

*/
    PDG_CCONNECTION OldConnection = Connection;
    PDG_CCONNECTION NewConnection;

    //
    // To avoid a deadlock, we must release the connection mutex before
    // taking the binding mutex.  The fBusy flag prevents another thread
    // from using it.
    //
    OldConnection->fError  = TRUE;
    OldConnection->fBusy = TRUE;
    OldConnection->MutexClear();

    NewConnection = OldConnection->BindingHandle->GetReplacementConnection(OldConnection, InterfacePointer);
    if (!NewConnection)
        {
        OldConnection->MutexRequest();
        return RPC_S_CALL_FAILED_DNE;
        }

    //
    // We now own NewConnection's mutex.  Transfer calls to be retried.
    //
    OldConnection->MutexRequest();
    Status = OldConnection->TransferCallsToNewConnection(this, NewConnection);

    ASSERT( !Status );

    if (FALSE == SourceEndpoint->Async)
        {
        //
        // Get a fresh endpoint to avoid a race with any ICMP rejects.
        // If that fails, leave the old endpoint in place and bail out of the call.
        //
        DG_ENDPOINT * OldEndpoint = SourceEndpoint;

        SourceEndpoint = 0;

        Status = GetEndpoint(OldEndpoint->Flags);

        OldEndpoint->Flags |= PENALTY_BOX;

        if (Status)
                {
            SourceEndpoint = OldEndpoint;
            return Status;
                }

        EndpointManager->ReleaseEndpoint(OldEndpoint);
            }

    //
    // Attempt the call again.
    //
    LastReceiveTime = GetTickCount();

    Status = SendSomeFragments();

    return Status;
}


RPC_STATUS
DG_CCALL::ReceiveSinglePacket()
{
    RPC_STATUS Status;
    PDG_PACKET Packet = 0;
    DG_TRANSPORT_ADDRESS ReceiveAddress = 0;

    Connection->MutexClear();

    unsigned Length = 0;
    void * Buffer = 0;

    Status = Connection->TransportInterface->SyncReceive(
                            &SourceEndpoint->TransportEndpoint,
                            &ReceiveAddress,
                            &Length,
                            &Buffer,
                            ReceiveTimeout
                            );

    if (Buffer)
        {
        Packet = DG_PACKET::FromPacketHeader(Buffer);
        Packet->DataLength = Length;
        }

    Connection->MutexRequest();

    if (Status == RPC_P_HOST_DOWN)
        {
        RpcpErrorAddRecord( EEInfoGCRuntime,
                            Status,
                            EEInfoDLDG_CCALL__ReceiveSinglePacket10
                            );

        return Status;
        }

    //
    // If the transport tells us the server is not present (ICMP reject)
    // then we can try auto-reconnect - as long as there is no possibility
    // that the server crashed while executing our stub.
    //
    if (Status == RPC_P_PORT_DOWN)
        {
        RpcpErrorAddRecord( EEInfoGCRuntime,
                            Status,
                            EEInfoDLDG_CCALL__ReceiveSinglePacket20,
                            (ULONG) Connection->fAutoReconnect,
                            (ULONG) BufferFlags
                            );

        if (!Connection->fAutoReconnect &&
            (!fRetransmitted || (BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT)))
            {
            Status = AttemptAutoReconnect();
            return Status;
            }

        ASSERT( !Packet && !ReceiveAddress );
        return Status;
        }

    if (Status == RPC_P_OVERSIZE_PACKET)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: packet is too large\n");
#endif
        Packet->Flags |= DG_PF_PARTIAL;
        Status = RPC_S_OK;
        }
    else
        {
        ASSERT( !Packet || Packet->DataLength <= Packet->MaxDataLength );
        }

    if (Status == RPC_S_OK)
        {
        LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

        do
            {
            //
            // Request packets are special.
            //
            if (Packet->Header.PacketType == DG_REQUEST)
                {
                Status = StandardPacketChecks(Packet);
                if (Status)
                    {
                    LogError(SU_CCALL, EV_PKT_IN, this, (void *) 1, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                    FreePacket(Packet);
                    break;
                    }

                if (Packet->Header.AuthProto != 0)
                    {
                    LogError(SU_CCALL, EV_PKT_IN, this, (void *) 2, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                    FreePacket(Packet);
                    break;
                    }

                if (Packet->Flags & DG_PF_PARTIAL)
                    {
                    LogError(SU_CCALL, EV_PKT_IN, this, (void *) 3, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                    FreePacket(Packet);
                    break;
                    }

                LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 4, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

                Connection->ServerResponded = TRUE;
                Status = DealWithRequest(Packet, ReceiveAddress);
                if (Status)
                    {
                    //
                    // Make sure that the call times out in a reasonable time period.
                    //
                    if (long(GetTickCount()) - LastReceiveTime > TimeoutLimit)
                        {
                        LogError(SU_CCALL, EV_STATUS, this, (void *) 7, RPC_P_TIMEOUT);

                        SendQuit();
                        return RPC_P_TIMEOUT;
                        }

                    }

                return RPC_S_OK;
                }

            Status = StandardPacketChecks(Packet);
            if (Status)
                {
                LogError(SU_CCALL, EV_PKT_IN, this, (void *) 5, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                FreePacket(Packet);

                if (Status == NCA_STATUS_VERSION_MISMATCH)
                    {
                    Status = 0;
                    }

                break;
                }

            if (Packet->Header.SequenceNumber != SequenceNumber ||
                Connection->ActivityNode.Uuid.MatchUuid(&Packet->Header.ActivityId))
                {
                LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 6, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
                FreePacket(Packet);
                break;
                }

            Status = Connection->UpdateServerAddress(Packet, ReceiveAddress);
            if (Status)
                {
                break;
                }

            Status = DispatchPacket(Packet);
            }
        while ( 0 );
        }
    else
        {
        ASSERT( !Packet && !ReceiveAddress );

        if (SequenceNumber <= Connection->CurrentSequenceNumber())
            {
            if (!TimeoutCount)
                {
                ReceiveTimeout = 500;
                }

            ++TimeoutCount;

            //
            // Shorten the burst length.
            //
            SendBurstLength = (1+SendBurstLength)/2;

            if (Status == RPC_P_TIMEOUT)
                {
                LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);

                IncreaseReceiveTimeout();
                }
            else
                {
                RpcpErrorAddRecord( EEInfoGCRuntime,
                                    Status,
                                    EEInfoDLDG_CCALL__ReceiveSinglePacket30
                                    );

                LogError(SU_CCALL, EV_STATUS, this, 0, Status);

                //
                // Perhaps it's a transient error.  Wait a moment and try again.
                //
#ifdef DEBUGRPC
                if (Status != RPC_S_OUT_OF_RESOURCES &&
                    Status != RPC_S_OUT_OF_MEMORY    &&
                    Status != RPC_P_RECEIVE_FAILED   )
                    {
                    DbgPrint("RPC: d/g receive status %x\n"
                             "Please send the error code to jroberts, and hit 'g'",
                             Status
                             );

                    RpcpBreakPoint();
                    }
#endif

                Sleep(500);
                }
            }

        Status = DealWithTimeout();
        }

    return Status;
}


RPC_STATUS
DG_CCALL::AsyncSend(
    PRPC_MESSAGE Message
    )
{
    if (AsyncStatus != RPC_S_OK &&
        AsyncStatus != RPC_S_ASYNC_CALL_PENDING )
        {
        Connection->MutexRequest();

        return AfterSendReceive(Message, AsyncStatus);
        }

    return Send(Message);
}


RPC_STATUS
DG_CCALL::Send(
    PRPC_MESSAGE Message
    )
{
    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
        {
        LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'A' + (('S' + (('n' + ('d' << 8)) << 8)) << 8));
        }
    else
        {
        LogEvent(SU_CCALL, EV_PROC, this, Message->Buffer, 'S' + (('e' + (('n' + ('d' << 8)) << 8)) << 8));
        }

    LogEvent(SU_CCALL, EV_BUFFER_IN, this, Message->Buffer, Message->BufferLength);

    RPC_STATUS Status = RPC_S_OK;

    Connection->MutexRequest();

    //
    // See DG_CCALL::CancelDelayedSend for details.
    //
    while (State == CallCancellingSend)
        {
        Connection->MutexClear();
        Sleep(1);
        Connection->MutexRequest();
        }

    if (State == CallInit)
        {
        Status = BeforeSendReceive(Message);
        if (RPC_S_OK != Status)
            {
            Connection->MutexClear();
            FreeBuffer(Message);
            return Status;
            }
        }

    SetFragmentLengths();

    if ((Message->RpcFlags & RPC_BUFFER_PARTIAL) &&
        Message->BufferLength < (ULONG) MaxFragmentSize * SendWindowSize )
        {
        Status = RPC_S_SEND_INCOMPLETE;

        Connection->IncrementRefCount();
        if (pAsync)
            {
            IssueNotification( RpcSendComplete );
            }

        Connection->DecrementRefCount();

        LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);
        return Status;
        }

    SetState(CallSend);

    Status = PushBuffer(Message);
    if (Status)
        {
        FreePipeBuffer(Message);
        Status = AfterSendReceive(Message, Status);

        LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
        LogError(SU_CCALL, EV_STATUS, this, 0, Status);

        return Status;
        }

    if (pAsync)
        {
        Connection->MutexClear();
        }
    else
        {
        while (RPC_S_OK == Status && !IsBufferAcknowledged())
            {
            Status = ReceiveSinglePacket();
            }

        SetState(CallQuiescent);

        if (Status == RPC_S_OK)
            {
            Connection->MutexClear();
            }
        else
            {
            Status = AfterSendReceive(Message, Status);
            }
        }

    if (!Status && Message->BufferLength)
        {
        Status = RPC_S_SEND_INCOMPLETE;
        }

    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);
    LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);

    return Status;
}


RPC_STATUS
DG_CCALL::MaybeSendReceive(
    IN OUT PRPC_MESSAGE Message
    )

/*++

Routine Description:

    Sends a [maybe], [broadcast, maybe] or [message] call.

Arguments:

    Message - Message to be sent.

Return Value:

    RPC_S_OK
    <error from Transport>

--*/

{
    RPC_STATUS  Status = RPC_S_OK;

    //
    // Make sure this fits into a single packet.
    //
    if ( !(Message->RpcFlags & RPCFLG_MESSAGE)
         && (Message->BufferLength > MaxFragmentSize) )
        {
        FreePipeBuffer(Message);
        return RPC_S_OK;
        }

    //
    // [maybe] calls are implicitly idempotent.
    //
    Message->RpcFlags |= RPC_NCA_FLAGS_IDEMPOTENT;

    //
    // Build the request packet.
    //
    PDG_PACKET         Packet = DG_PACKET::FromStubData(Message->Buffer);
    PNCA_PACKET_HEADER Header = &Packet->Header;

    *Header = pSavedPacket->Header;

    BuildNcaPacketHeader(Header, Message);

    Header->SetPacketBodyLen (Message->BufferLength);
    Header->SetFragmentNumber(0);
    Header->AuthProto      = 0;
    Header->ServerBootTime = 0;

    AddSerialNumber(Header);

    //
    // Send the packet.
    //
    LogEvent(SU_CCALL, EV_PKT_OUT, this, 0, 0);

    Status = SendSecurePacket(SourceEndpoint,
                              Connection->Association->InqServerAddress(),
                              Header,
                              0,
                              0
                              );

    FreePipeBuffer(Message);
    Message->BufferLength = 0;

    if (Message->RpcFlags & RPCFLG_MESSAGE)
        {
        return Status;
        }
    else
        {
        return RPC_S_OK;
        }
}


RPC_STATUS
DG_CCALL::AsyncReceive(
    PRPC_MESSAGE Message,
    unsigned MinimumSize
    )
{
    LogEvent(SU_CCALL, EV_PROC, this, IntToPtr(MinimumSize), 0x76635241);
    LogEvent(SU_CCALL, EV_BUFFER_IN, this, Message->Buffer, Message->BufferLength);

    ASSERT( pAsync && (Message->RpcFlags & RPC_BUFFER_ASYNC) );

    Connection->MutexRequest();

    if (State == CallSend)
        {
        Connection->MutexClear();
        return RPC_S_ASYNC_CALL_PENDING;
        }

    //
    // See DG_CCALL::CancelDelayedSend for details.
    //
    while (State == CallCancellingSend)
        {
        Connection->MutexClear();
        Sleep(1);
        Connection->MutexRequest();
        }

    if (AsyncStatus != RPC_S_OK &&
        AsyncStatus != RPC_S_ASYNC_CALL_PENDING )
        {
        return AfterSendReceive(Message, AsyncStatus);
        }

    if (!fReceivedAllFragments &&
        !(ConsecutiveDataBytes >= MinimumSize && (Message->RpcFlags & RPC_BUFFER_PARTIAL)))
        {
        if (Message->RpcFlags & RPC_BUFFER_NONOTIFY)
            {
            // just checking
            }
        else
            {
            SetState(CallReceive);

            PipeReceiveSize = MinimumSize;
            }

        Connection->MutexClear();

        LogEvent(SU_CCALL, EV_STATUS, this, 0, RPC_S_ASYNC_CALL_PENDING);

        return RPC_S_ASYNC_CALL_PENDING;
        }

    RPC_STATUS Status = RPC_S_OK;

    Status = AssembleBufferFromPackets(Message, this);

    LogEvent(SU_CCALL, EV_STATUS, this, 0, Status);
    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);

    if (0 == (Message->RpcFlags & RPC_BUFFER_PARTIAL) ||
        (Message->RpcFlags & RPC_BUFFER_COMPLETE)     ||
        RPC_S_OK != Status                            )
        {
        Status = AfterSendReceive(Message, Status);
        }
    else
        {
        Connection->MutexClear();
        }

    return Status;
}


RPC_STATUS
DG_CCALL::Receive(
    PRPC_MESSAGE Message,
    unsigned MinimumSize
    )
{
    LogEvent(SU_CCALL, EV_PROC, this, IntToPtr(MinimumSize), 0x76636552);
    LogEvent(SU_CCALL, EV_BUFFER_IN, this, Message->Buffer, Message->BufferLength);

    RPC_STATUS Status = RPC_S_OK;

    Connection->MutexRequest();

    SetState(CallReceive);

    while (RPC_S_OK == Status &&
           !fReceivedAllFragments &&
           !(ConsecutiveDataBytes >= MinimumSize && (Message->RpcFlags & RPC_BUFFER_PARTIAL)))
        {
        Status = ReceiveSinglePacket();
        }

    if (RPC_S_OK == Status)
        {
        Status = AssembleBufferFromPackets(Message, this);
        }

    LogEvent(SU_CCALL, EV_STATUS, this, 0, RPC_S_OK);
    LogEvent(SU_CCALL, EV_BUFFER_OUT, this, Message->Buffer, Message->BufferLength);

    if (0 == (Message->RpcFlags & RPC_BUFFER_PARTIAL) ||
        (Message->RpcFlags & RPC_BUFFER_COMPLETE)     ||
        RPC_S_OK != Status                            )
        {
        Status = AfterSendReceive(Message, Status);
        }
    else
        {
        Connection->MutexClear();
        }

    return Status;
}


BOOL
DG_CCALL::IssueNotification (
    IN RPC_ASYNC_EVENT Event
    )
{
    Connection->Mutex.VerifyOwned();

    LogEvent(SU_CCALL, EV_NOTIFY, this, (void *) Event, AsyncStatus);

    if (State == CallInit     ||
        State == CallComplete ||
        State == CallCancellingSend )
        {
#ifdef DEBUGRPC
        DbgPrint("RPC: redundant notification on ccall %lx\n", this);
#endif
        return TRUE;
        }

    if (Event == RpcCallComplete)
        {
        SetState(CallComplete);
        }
    else
        {
        SetState(CallQuiescent);
        }

    if (pAsync->NotificationType == RpcNotificationTypeApc)
        {
        IncrementRefCount();
        }

    int i;
    for (i=1; i < 3; ++i)
        {
        if (CALL::IssueNotification(Event))
            {
            return TRUE;
            }

        Sleep(200);
        }

    DecrementRefCountAndKeepMutex();

    return FALSE;
}

void
DG_CCALL::FreeAPCInfo (
    IN RPC_APC_INFO *pAPCInfo
    )
{
    LogEvent(SU_CCALL, EV_APC, this);

    Connection->MutexRequest();

    CALL::FreeAPCInfo(pAPCInfo);

    DecrementRefCount();
}


RPC_STATUS
DG_CCALL::CancelAsyncCall (
    IN BOOL fAbort
    )
{
    Connection->MutexRequest();

    if (State == CallInit     ||
        State == CallComplete ||
        State == CallCancellingSend )
        {
        Connection->MutexClear();
        return RPC_S_OK;
        }

    RpcpErrorAddRecord( EEInfoGCRuntime,
                        RPC_S_CALL_CANCELLED,
                        EEInfoDLDG_CCALL__CancelAsyncCall10,
                        (ULONG) fAbort
                        );

    SendQuit();

    Connection->IncrementRefCount();

    if (fAbort)
        {
        CancelDelayedSend();
        CleanupReceiveWindow();

        AsyncStatus = RPC_S_CALL_CANCELLED;
        IssueNotification( RpcCallComplete );
        }
    else
        {
        CancelPending = TRUE;
        }

    Connection->DecrementRefCount();

    return RPC_S_OK;
}


RPC_STATUS
DG_CCALL::DealWithRequest(
    IN PDG_PACKET           Packet,
    IN DG_TRANSPORT_ADDRESS ReceiveAddress
    )
{
    RPC_STATUS Status = RPC_S_OK;
    RPC_MESSAGE CallbackMessage;
    PNCA_PACKET_HEADER OriginalHeader;
    DG_CLIENT_CALLBACK Callback;

    //
    // Save the server data rep for challenge response processing.
    //
    Connection->Association->ServerDataRep = 0x00ffffff & (*(unsigned long *) (Packet->Header.DataRep));

    Callback.LocalEndpoint = SourceEndpoint;
    Callback.Connection    = Connection;
    Callback.RemoteAddress = ReceiveAddress;
    Callback.Request       = Packet;

    return DispatchCallbackRequest(&Callback);
}



RPC_STATUS
DG_CCALL::DealWithFack(
    PDG_PACKET pPacket
    )
{
    BOOL Updated;
    RPC_STATUS Status;

    SendBurstLength += 1;

    Status = UpdateSendWindow(pPacket, &Updated);

    if (Updated)
        {
        Connection->UpdateAssociation();
        }

    FreePacket(pPacket);

    if (Status != RPC_P_PORT_DOWN &&
        Status != RPC_P_HOST_DOWN)
        {
        Status = 0;
        }

    return Status;
}


RPC_STATUS
DG_CCALL::DealWithResponse(
    PDG_PACKET pPacket
    )
{
    #ifdef DBG
    if (!Connection->TransportInterface->IsMessageTransport)
       {
       ASSERT( !(pPacket->GetPacketBodyLen() % 8)               ||
               !(pPacket->Header.PacketFlags & DG_PF_FRAG)      ||
               (pPacket->Header.PacketFlags & DG_PF_LAST_FRAG) );
       }
    #endif

    Connection->Association->LastReceiveTime = LastReceiveTime;

    //
    // The first response is implicitly a FACK for the final request packet.
    //
    MarkAllPacketsReceived();

    //
    // Add packet to received list, and send a fack if necessary.
    //
    if (FALSE == UpdateReceiveWindow(pPacket))
        {
        FreePacket(pPacket);
        }

    Connection->MaybeTransmitNextCall();

    return RPC_S_OK;
}


RPC_STATUS
DG_CCALL::DealWithWorking(
    PDG_PACKET pPacket
    )
{
    Connection->Association->LastReceiveTime = LastReceiveTime;

    //
    // WORKING is implicitly a FACK for the final request packet.
    //
    MarkAllPacketsReceived();

    Connection->MaybeTransmitNextCall();

    //
    // Reduce server load by increasing the timeout during long calls.
    //
    IncreaseReceiveTimeout();

    FreePacket(pPacket);

    return RPC_S_OK;
}


void
DG_CCALL::IncreaseReceiveTimeout()
{
    if (Connection->TransportInterface->IsMessageTransport)
        {
        return;
        }

    ReceiveTimeout *= 2;
    if (ReceiveTimeout > 16000)
        {
        ReceiveTimeout = 16000;
        }

    if (long(GetTickCount()) - LastReceiveTime + ReceiveTimeout > TimeoutLimit)
        {
        ReceiveTimeout = 1 + TimeoutLimit - (GetTickCount() - LastReceiveTime);
        if (ReceiveTimeout < 0)
            {
            ReceiveTimeout = 0;
            }
        }

    long CancelTimeout = ThreadGetRpcCancelTimeout();
    if (CancelTimeout != RPC_C_CANCEL_INFINITE_TIMEOUT)
        {
        CancelTimeout *= 1000;

        if (CancelTimeout < 2000)
            {
            CancelTimeout = 2000;
            }

        if (ReceiveTimeout > CancelTimeout)
            {
            ReceiveTimeout = CancelTimeout;
            }
        }
}


RPC_STATUS
DG_CCALL::DealWithNocall(
    PDG_PACKET pPacket
    )
{
    BOOL Used;
    BOOL Updated;
    RPC_STATUS Status;

    if (pPacket->GetPacketBodyLen() == 0)
        {
        //
        // Don't trust the FragmentNumber field.
        //
        pPacket->SetFragmentNumber(0xffff);
        }

    Status = UpdateSendWindow(pPacket, &Updated);

    if (Updated)
        {
        Connection->UpdateAssociation();
        }

    FreePacket(pPacket);

    //
    // Ordinarily a NOCALL means the request wasn't received, and we should
    // fail the call after several in a row.  But a NOCALL with window size 0
    // means the request was received and queued, and we want to back off as
    // for a WORKING packet.
    //
    if (SendWindowSize != 0)
        {
        ++UnansweredRequestCount;
        }

//    IncreaseReceiveTimeout();

    if (UnansweredRequestCount > 4)
        {
        SendQuit();
        return RPC_P_PORT_DOWN;
        }

    if (Status != RPC_P_PORT_DOWN &&
        Status != RPC_P_HOST_DOWN)
        {
        Status = 0;
        }

    return Status;
}

RPC_STATUS
DG_CCALL::ProcessFaultOrRejectData(
    PDG_PACKET Packet
    )
{
    RPC_STATUS Status = RPC_S_CALL_FAILED;

    //
    // Read the standard OSF error code.
    //
    if (Packet->GetPacketBodyLen() >= sizeof(unsigned long))
        {
        unsigned long Error = * (unsigned long *) Packet->Header.Data;

        if (NeedsByteSwap(&Packet->Header))
            {
            Error = RpcpByteSwapLong(Error);
            }
        Status = MapFromNcaStatusCode(Error);

        LogEvent( SU_CCALL, EV_STATUS, this, 0, Error);
        }

    //
    // Read the extended error info, if present.
    //
    if (Packet->GetPacketBodyLen() > sizeof(EXTENDED_FAULT_BODY))
        {
        EXTENDED_FAULT_BODY * body = (EXTENDED_FAULT_BODY *) Packet->Header.Data;

        if (body->Magic == DG_EE_MAGIC_VALUE)
            {
            ExtendedErrorInfo *EEInfo;

            UnpickleEEInfoFromBuffer( body->EeInfo,
                                      Packet->GetPacketBodyLen() - sizeof(EXTENDED_FAULT_BODY)
                                      );

            EEInfo = RpcpGetEEInfo();
            if (EEInfo && pAsync)
                {
                ASSERT(this->EEInfo == NULL);

                // move the eeinfo to the call. Even though it is possible
                // that the call will be completed on this thread, it is
                // still ok, as we will move it back during completion
                this->EEInfo = EEInfo;
                RpcpClearEEInfo();
                }
            }
        }

    return Status;
}


RPC_STATUS
DG_CCALL::DealWithFault(
    PDG_PACKET pPacket
    )
{
    RPC_STATUS Status = ProcessFaultOrRejectData(pPacket);

    FreePacket(pPacket);

    SendAck();

    return Status;
}


RPC_STATUS
DG_CCALL::DealWithReject(
    PDG_PACKET pPacket
    )
{
    RPC_STATUS Status = ProcessFaultOrRejectData(pPacket);

    FreePacket(pPacket);

    if (!fRetransmitted || (BufferFlags & RPC_NCA_FLAGS_IDEMPOTENT))
        {
        if (Status == NCA_STATUS_WRONG_BOOT_TIME ||
            (!Connection->fAutoReconnect && Status == RPC_S_CALL_FAILED_DNE))
            {
            Status = AttemptAutoReconnect();
            }
        }

    return Status;
}


RPC_STATUS
DG_CCALL::SendQuit(
    )
{
    QUIT_BODY_0 * pBody = (QUIT_BODY_0 *) pSavedPacket->Header.Data;

    pSavedPacket->Header.PacketType    = DG_QUIT;
    pSavedPacket->Header.PacketFlags   &= DG_PF_IDEMPOTENT;
    pSavedPacket->SetPacketBodyLen(sizeof(QUIT_BODY_0));

    AddSerialNumber(&pSavedPacket->Header);

    pBody->Version = 0;
    pBody->EventId = CancelEventId;

    unsigned Frag = (pSavedPacket->Header.PacketType << 16) | pSavedPacket->GetFragmentNumber();
    LogEvent(SU_CCALL, EV_PKT_OUT, this, 0, Frag);

    return Connection->SealAndSendPacket(SourceEndpoint, 0, &pSavedPacket->Header, 0);
}


RPC_STATUS
DG_CCALL::DealWithQuack(
    PDG_PACKET pPacket
    )
{
    if (FALSE == CancelPending)
        {
        FreePacket(pPacket);
        return RPC_S_OK;
        }

    QUACK_BODY_0 * pBody = (QUACK_BODY_0 *) pPacket->Header.Data;

    if (0 == pPacket->GetPacketBodyLen())
        {
        //
        // The server orphaned a call.  I hope it is the current one.
        //
        goto ok;
        }

    //
    // The ver 0 quack packet contains two ulongs and a uchar; I'd like to
    // test for sizeof(quack body) but C++ likes to pad structure sizes
    // to 0 mod 4.  Hence the explicit test for length < 9.
    //
    if (pPacket->GetPacketBodyLen() < 9 ||
        pBody->Version != 0)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: unknown QUACK format: version 0x%lx, length 0x%hx\n",
                 pBody->Version, pPacket->GetPacketBodyLen()
                 );
#endif
        FreePacket(pPacket);
        return RPC_S_OK;
        }

    if (pBody->EventId != CancelEventId)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: ignoring unknown QUACK event id 0x%lx\n",
                 pBody->EventId
                 );
#endif
        FreePacket(pPacket);
        return RPC_S_OK;
        }

ok:

    CancelPending = FALSE;
    FreePacket(pPacket);

    return RPC_S_OK;
}


RPC_STATUS
DG_CCONNECTION::SealAndSendPacket(
    IN DG_ENDPOINT *                 SourceEndpoint,
    IN DG_TRANSPORT_ADDRESS          UnusedRemoteAddress,
    IN UNALIGNED NCA_PACKET_HEADER * Header,
    IN unsigned long                 DataOffset
    )
/*

- NT 3.5 did not support secure datagram RPC.

- NT 3.51 and NT 4.0 servers will probably fail to decrypt a multifragment
request if some fragments are encrypted with one context and others use a
different context, since they decrypt all the packets using the last active
context instead of looking at each packet's 'ksno' field.

- NT 3.51 and NT 4.0 servers dispose of stale contexts only when the activity
is deleted.

- NT 3.51 and NT 4.0 clients use only one set of security parameters
(provider, level, principal name) per connection.  The only time the ksno
changes is on NT 4.0 when a Kerberos context expires and must be renewed.

- NT 3.51 and NT 4.0 clients do not notice if ksno rises above 0xff.  If it
does, the next call will fail because the server sees only the lowest 8 bits
and mistakenly reuses another context.

- NT 3.51 clients do not notice whether the thread is impersonating, so they
can mistakenly reuse a connection if all info except the username is identical.

- NT 3.51 clients mistakenly send [maybe] calls with an auth trailer, if the
underlying connection is secure.  OSF and NT 4.0 force [maybe] calls insecure.

*/

{
    ASSERT( 0 == ActivityNode.CompareUuid(&Header->ActivityId) );

retry_packet:

    RPC_STATUS Status;
    Status = SendSecurePacket(SourceEndpoint,
                              Association->InqServerAddress(),
                              Header,
                              DataOffset,
                              ActiveSecurityContext
                              );

    if (Status == SEC_E_CONTEXT_EXPIRED)
        {
        Status = InitializeSecurityContext();
        if (RPC_S_OK == Status)
            {
            goto retry_packet;
            }
        }

    return Status;
}


RPC_STATUS
DG_CCONNECTION::InitializeSecurityContext(
    )
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    delete ActiveSecurityContext;

    if (SecurityContextId > 0xff)
        {
        ActiveSecurityContext = 0;
        return RPC_S_OUT_OF_RESOURCES;
        }

    ActiveSecurityContext = new SECURITY_CONTEXT(&AuthInfo, SecurityContextId, TRUE, &RpcStatus);
    if (0 == ActiveSecurityContext)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (RpcStatus)
        {
        delete ActiveSecurityContext;
        ActiveSecurityContext = 0;
        return RPC_S_OUT_OF_MEMORY;
        }

    ++SecurityContextId;

    SECURITY_BUFFER_DESCRIPTOR BufferDescriptorIn;
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    SECURITY_BUFFER SecurityBuffersIn[1];

    BufferDescriptorIn.ulVersion = 0;
    BufferDescriptorIn.cBuffers  = 1;
    BufferDescriptorIn.pBuffers  = SecurityBuffersIn;

    SecurityBuffersIn[0].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
    SecurityBuffersIn[0].pvBuffer   = &InitSecurityInfo;
    SecurityBuffersIn[0].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

    InitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = 0;
    InitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = ActiveSecurityContext->AuthContextId;
    RpcpMemoryCopy(&InitSecurityInfo.DceSecurityInfo.AssociationUuid, &ActivityNode.Uuid, sizeof(UUID));

    InitSecurityInfo.AuthorizationService = AuthInfo.AuthorizationService;
    InitSecurityInfo.PacketType           = ~0;

    RpcStatus = ActiveSecurityContext->InitializeFirstTime(
                    AuthInfo.Credentials,
                    AuthInfo.ServerPrincipalName,
                    AuthInfo.AuthenticationLevel,
                    &BufferDescriptorIn
                    );

    LogEvent(SU_CCONN, EV_SEC_INIT1, this, IntToPtr(RpcStatus), I_RpcGetExtendedError());

    return RpcStatus;
}


RPC_STATUS
DG_CCONNECTION::DealWithAuthCallback(
    IN void  * InToken,
    IN long  InTokenLength,
    OUT void * OutToken,
    OUT long MaxOutTokenLength,
    OUT long * OutTokenLength
    )
{
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptorIn;
    SECURITY_BUFFER_DESCRIPTOR BufferDescriptorOut;
    DCE_INIT_SECURITY_INFO InitSecurityInfo;
    SECURITY_BUFFER SecurityBuffersIn [2];
    SECURITY_BUFFER SecurityBuffersOut[2];
    RPC_STATUS Status;

    InitSecurityInfo.DceSecurityInfo.SendSequenceNumber    = 0;
    InitSecurityInfo.DceSecurityInfo.ReceiveSequenceNumber = ActiveSecurityContext->AuthContextId;
    ActivityNode.QueryUuid( &InitSecurityInfo.DceSecurityInfo.AssociationUuid );

    InitSecurityInfo.AuthorizationService = AuthInfo.AuthorizationService;
    InitSecurityInfo.PacketType           = ~0;

    BufferDescriptorIn.ulVersion = 0;
    BufferDescriptorIn.cBuffers  = 2;
    BufferDescriptorIn.pBuffers  = SecurityBuffersIn;

    SecurityBuffersIn[0].BufferType = SECBUFFER_TOKEN;
    SecurityBuffersIn[0].pvBuffer   = InToken;
    SecurityBuffersIn[0].cbBuffer   = InTokenLength;

    SecurityBuffersIn[1].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
    SecurityBuffersIn[1].pvBuffer   = &InitSecurityInfo;
    SecurityBuffersIn[1].cbBuffer   = sizeof(DCE_INIT_SECURITY_INFO);

    BufferDescriptorOut.ulVersion = 0;
    BufferDescriptorOut.cBuffers  = 1;
    BufferDescriptorOut.pBuffers  = SecurityBuffersOut;

    SecurityBuffersOut[0].BufferType = SECBUFFER_TOKEN;
    SecurityBuffersOut[0].pvBuffer   = OutToken;
    SecurityBuffersOut[0].cbBuffer   = MaxOutTokenLength;

    Status = ActiveSecurityContext->InitializeThirdLeg(
                                                  AuthInfo.Credentials,
                                                  Association->ServerDataRep,
                                                  &BufferDescriptorIn,
                                                  &BufferDescriptorOut
                                                  );


    if (Status != RPC_S_OK)
        {
        LogError(SU_CCONN, EV_SEC_INIT3, this, IntToPtr(Status), I_RpcGetExtendedError());

        *OutTokenLength = 0;
        return (Status);
        }
    else
        {
        LogEvent(SU_CCONN, EV_SEC_INIT3, this, IntToPtr(Status), I_RpcGetExtendedError());

        *OutTokenLength = SecurityBuffersOut[0].cbBuffer;
        }

    //
    // If the result buffer spans multiple packets, return the first and store
    // the complete buffer in the connection for conv_who_are_you_auth_more().
    //
    if (!CurrentCall)
        {
        return 0;
        }

    long MaxData = CurrentCall->SourceEndpoint->Stats.MaxPduSize - sizeof(NCA_PACKET_HEADER) - 0x28;

    if (*OutTokenLength > MaxData)
        {
        if (SecurityBuffer)
            {
            delete SecurityBuffer;
            }

        SecurityBuffer = new unsigned char[ *OutTokenLength ];
        if (!SecurityBuffer)
            {
            *OutTokenLength = 0;
            return NCA_STATUS_REMOTE_OUT_OF_MEMORY;
            }

        memcpy( SecurityBuffer, SecurityBuffersOut[0].pvBuffer, *OutTokenLength );

        SecurityBufferLength = *OutTokenLength;

        *OutTokenLength = MaxData;
        return NCA_STATUS_PARTIAL_CREDENTIALS;
        }

    return (Status);
}


RPC_STATUS
DG_CCONNECTION::DealWithAuthMore(
    IN  long Index,
    OUT void * OutToken,
    OUT long MaxOutTokenLength,
    OUT long * OutTokenLength
    )
{
    if (0 == SecurityBuffer)
        {
        *OutTokenLength = 0;
        return 0;
        }

    if (SecurityBufferLength <= Index)
        {
        *OutTokenLength = 0;
        return 0;
        }

    if (!CurrentCall)
        {
        return 0;
        }

    long MaxData = CurrentCall->SourceEndpoint->Stats.MaxPduSize - sizeof(NCA_PACKET_HEADER) - 0x28;

    *OutTokenLength = SecurityBufferLength - Index;
    if (*OutTokenLength > MaxData)
        {
        *OutTokenLength = MaxData;
        memcpy(OutToken, SecurityBuffer + Index, *OutTokenLength);
        return NCA_STATUS_PARTIAL_CREDENTIALS;
        }

    memcpy(OutToken, SecurityBuffer + Index, *OutTokenLength);
    return 0;
}


RPC_STATUS
DG_CCONNECTION::VerifyPacket(
    DG_PACKET * Packet
    )
{
    if (AuthInfo.AuthenticationLevel == RPC_C_AUTHN_LEVEL_NONE ||
        (Packet->Flags & DG_PF_PARTIAL))
        {
        return RPC_S_OK;
        }

    if (!Packet->Header.AuthProto)
        {
        if (!fSecurePacketReceived && Packet->Header.PacketType != DG_RESPONSE)
            {
            return RPC_S_OK;
            }

        if (Packet->Header.PacketType == DG_REJECT ||
            Packet->Header.PacketType == DG_NOCALL)
            {
            return RPC_S_OK;
            }

        return RPC_S_ACCESS_DENIED;
        }

    RPC_STATUS Status;
    PDG_SECURITY_TRAILER Verifier = (PDG_SECURITY_TRAILER) (Packet->Header.Data + Packet->GetPacketBodyLen());

    if (Verifier->key_vers_num == ActiveSecurityContext->AuthContextId)
        {
        Status = VerifySecurePacket(Packet, ActiveSecurityContext);
        }
//    else if (Verifier->key_vers_num == ActiveSecurityContext->AuthContextId - 1)
//        {
//        Status = VerifySecurePacket(Packet, PreviousSecurityContext);
//        }
    else
        {
        Status = RPC_P_CONTEXT_EXPIRED;
        }

    if (RPC_S_OK == Status)
        {
        fSecurePacketReceived = TRUE;
        }

    return Status;
}


inline
int
DG_CCONNECTION::IsSupportedAuthInfo(
    IN const CLIENT_AUTH_INFO * ClientAuthInfo
    )
{
    return( AuthInfo.IsSupportedAuthInfo(ClientAuthInfo) );
}


int
DG_CASSOCIATION::CompareWithBinding(
    IN PDG_BINDING_HANDLE Binding
    )
{
    BOOL Ignored;

    ASSERT( !InvalidHandle(DG_CASSOCIATION_TYPE) );

    CLAIM_MUTEX lock( Mutex );

    if (0 != pDceBinding->Compare(Binding->pDceBinding,
                                    &Ignored    // fOnlyEndpointDifferent
                                    )
       )
        {
        return 1;
        }

    return 0;
}

RPC_STATUS
DG_CCALL::Cancel(
    void * ThreadHandle
    )
{
    LogError( SU_CCALL, EV_PROC, this, 0, 'C' + (('a' + (('n' + (' ' << 8) )<< 8) )<< 8));
    InterlockedIncrement(&Cancelled);

    return RPC_S_OK;
}

unsigned
DG_CCALL::TestCancel()
{
    LogEvent( SU_CCALL, EV_PROC, this, IntToPtr(Cancelled), 'T' + (('s' + (('t' + ('C' << 8)) << 8)) << 8));

    if (!Cancelled)
        {
        return 0;
        }

    return InterlockedExchange(&Cancelled, 0);
}


RPC_STATUS
DG_CCALL::SendSomeFragments(
    )
{
    RPC_STATUS Status;

    if (0 == FirstUnsentFragment)
        {
        if (SequenceNumber > Connection->CurrentSequenceNumber())
            {
            return RPC_S_OK;
            }

        //
        // If we begin sending this call's request before a previous call
        // is complete, then we should add the DG_PF2_UNRELATED bit to this call.
        //
        if (Connection->Association->fServerSupportsAsync)
            {
            ASSERT( Connection->Association->fServerSupportsAsync );

            PDG_CCALL node = Previous;

            while (node && node->fReceivedAllFragments)
                {
                node = node->Previous;
                }

            if (node)
                {
                BasePacketFlags2 = DG_PF2_UNRELATED;
                Previous->ForceAck = TRUE;
                }
            }

        // Note that Previous may not be the call immediately prior to this one,
        // since the prior call may have completed already and been removed
        // from the list.
        }

    LogEvent(SU_CCALL, EV_PROC, this, (void *) 1, 0x656d6f53);

    Status = DG_PACKET_ENGINE::SendSomeFragments();

    if (IsBufferSent())
        {
        //
        // The first buffer contains all the static args; it's simpler
        // to set the flags multiple times than to set it only for the
        // first buffer.
        //
        StaticArgsSent = TRUE;

        if (0 == (BufferFlags & RPC_BUFFER_PARTIAL))
            {
            AllArgsSent = TRUE;
            }
        }

    if (pAsync && AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
        {
        PostDelayedSend();
        }

    return Status;
}


BOOL
DG_CCALL::CheckForCancelTimeout()
{
    if (!CancelPending && TestCancel() > 0)
        {
        ++CancelEventId;
        CancelPending = TRUE;
        CancelTime = GetTickCount();
        }

    if (CancelPending)
        {
        SendQuit();

        if ((long(GetTickCount()) - CancelTime) / 1000 > ThreadGetRpcCancelTimeout() )
            {
            CancelPending = FALSE;
            return TRUE;
            }
        }

    return FALSE;
}


RPC_STATUS
DG_CCALL::DealWithTimeout()
{
    RPC_STATUS Status;

#ifdef DEBUGRPC
    Status = 0xbaadcccc;
#endif

    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x656d6f53);

    ASSERT (State != CallComplete);

    if (!CancelPending && TestCancel() > 0)
        {
        ++CancelEventId;
        CancelPending = TRUE;
        CancelTime = GetTickCount();
        }

    if (CancelPending)
        {
        SendQuit();

        if ((long(GetTickCount()) - CancelTime) / 1000 > ThreadGetRpcCancelTimeout() )
            {
            RpcpErrorAddRecord( EEInfoGCRuntime,
                                RPC_S_CALL_CANCELLED,
                                EEInfoDLDG_CCALL__DealWithTimeout10,
                                (ULONG) ThreadGetRpcCancelTimeout(),
                                (ULONG) (long(GetTickCount()) - CancelTime)
                                );

            CancelPending = FALSE;
            return RPC_S_CALL_CANCELLED;
            }

        return RPC_S_OK;
        }

    if (long(GetTickCount()) - LastReceiveTime > TimeoutLimit)
        {
        LogError(SU_CCALL, EV_PROC, this, (void *) 2, 0x656d6f53);

        RpcpErrorAddRecord( EEInfoGCRuntime,
                            RPC_P_TIMEOUT,
                            EEInfoDLDG_CCALL__DealWithTimeout20,
                            (ULONG) TimeoutLimit,
                            (ULONG) (long(GetTickCount()) - LastReceiveTime)
                            );

        SendQuit();
        return RPC_P_TIMEOUT;
        }

    LogEvent(SU_CCALL, EV_PROC, this, (void *) 4, 0x656d6f53);

    int ConvComparisonResult = 1;

    //
    // The client for NT 3.5 (build 807) swallows requests for conv_who_are_you2.
    // If the server pings the callback instead of retransmitting the request,
    // the 807 client will give up before we ever try conv_who_are_you.  Instead,
    // retransmit the request packet for calls over the conv interface.
    //
    PRPC_SERVER_INTERFACE Conv = (PRPC_SERVER_INTERFACE) conv_ServerIfHandle;
    if (FALSE == AllArgsSent ||
        (BufferFlags & RPC_NCA_FLAGS_BROADCAST) ||
        (0 == (ConvComparisonResult = RpcpMemoryCompare(&pSavedPacket->Header.InterfaceId,
                                                        &Conv->InterfaceId.SyntaxGUID,
                                                        sizeof(UUID)
                                                        ))))
        {
        //
        // Not all request packets have been transferred.
        //
        Status = SendSomeFragments();
        }
    else
        {
        //
        // Send a FACK if we have seen at least one response packet.
        //
        if (pReceivedPackets || ReceiveFragmentBase > 0)
            {
            Status = SendFackOrNocall(pReceivedPackets, DG_FACK);
            }
        else
            {
            Status = SendPing();
            }
        }

    if (pAsync && AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
        {
        PostDelayedSend();
        }

    if (Status != RPC_P_PORT_DOWN &&
        Status != RPC_P_HOST_DOWN)
        {
        Status = 0;
        }
    else
        {
        RpcpErrorAddRecord( EEInfoGCRuntime,
                            Status,
                            EEInfoDLDG_CCALL__DealWithTimeout30
                            );
        }

    return Status;
}


BOOL
INTERFACE_AND_OBJECT_LIST::Insert(
    void     __RPC_FAR * Interface,
    RPC_UUID __RPC_FAR * Object
    )
{
    INTERFACE_AND_OBJECT * Current;
    INTERFACE_AND_OBJECT * Prev;
    unsigned Count;

    for (Count = 0, Prev = 0, Current = Head;
         Count < MAX_ELEMENTS, Current != NULL;
         Count++, Prev = Current, Current = Current->Next)
        {
        if (Interface == Current->Interface &&
            0 == Current->Object.MatchUuid(Object))
            {
            return TRUE;
            }
        }

    if (Current)
        {
        //
        // We have too many elements in the list. Reuse this one, the oldest.
        //
        if (Current == Head)
            {
            Head = Current->Next;
            }
        else
            {
            Prev->Next = Current->Next;
            }
        }
    else
        {
        if (Cache1Available)
            {
            Cache1Available = FALSE;
            Current = &Cache1;
            }
        else if (Cache2Available)
            {
            Cache2Available = FALSE;
            Current = &Cache2;
            }
        else
            {
            Current = new INTERFACE_AND_OBJECT;
            if (!Current)
                {
                return FALSE;
                }
            }
        }

    Current->Update(Interface, Object);
    Current->Next = Head;
    Head = Current;

    return TRUE;
}


BOOL
INTERFACE_AND_OBJECT_LIST::Find(
    void     __RPC_FAR * Interface,
    RPC_UUID __RPC_FAR * Object
    )
{
    INTERFACE_AND_OBJECT * Current;
    INTERFACE_AND_OBJECT * Prev;

    for (Current = Head; Current; Prev = Current, Current = Current->Next)
        {
        if (Interface == Current->Interface &&
            0 == Current->Object.MatchUuid(Object))
            {
            break;
            }
        }

    if (!Current)
        {
        return FALSE;
        }

    if (Current != Head)
        {
        Prev->Next = Current->Next;
        Current->Next = Head;
        Head = Current;
        }

    return TRUE;
}


BOOL
INTERFACE_AND_OBJECT_LIST::Delete(
    void     __RPC_FAR * Interface,
    RPC_UUID __RPC_FAR * Object
    )
{
    INTERFACE_AND_OBJECT * Current;
    INTERFACE_AND_OBJECT * Prev;

    for (Current = Head; Current; Prev = Current, Current = Current->Next)
        {
        if (Interface == Current->Interface &&
            0 == Current->Object.MatchUuid(Object))
            {
            break;
            }
        }

    if (!Current)
        {
        return FALSE;
        }

    if (Current == Head)
        {
        Head = Current->Next;
        }
    else
        {
        Prev->Next = Current->Next;
        }

    if (Current == &Cache1)
        {
        Cache1Available = TRUE;
        }
    else if (Current == &Cache2)
        {
        Cache2Available = TRUE;
        }
    else
        {
        delete Current;
        }

    return TRUE;
}


INTERFACE_AND_OBJECT_LIST::~INTERFACE_AND_OBJECT_LIST(
    )
{
    INTERFACE_AND_OBJECT * Next;

    while (Head)
        {
        Next = Head->Next;

        if (Head != &Cache1 && Head != &Cache2)
            {
            delete Head;
            }

        Head = Next;
        }
}


#ifdef DEBUGRPC

void
DumpBuffer(
    void FAR * Buffer,
    unsigned Length
    )
{
    const BYTES_PER_LINE = 16;

    unsigned char FAR *p = (unsigned char FAR *) Buffer;

    //
    // 3 chars per byte for hex display, plus an extra space every 4 bytes,
    // plus a byte for the printable representation, plus the \0.
    //
    char Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+BYTES_PER_LINE+1];
    Outbuf[0] = 0;
    Outbuf[sizeof(Outbuf)-1] = 0;
    char * HexDigits = "0123456789abcdef";

    unsigned Index;
    for (unsigned Offset=0; Offset < Length; Offset++)
        {
        Index = Offset % BYTES_PER_LINE;

        if (Index == 0)
            {
            DbgPrint("   %s\n", Outbuf);
            memset(Outbuf, ' ', sizeof(Outbuf)-1);
            }

        Outbuf[Index*3+Index/4  ] = HexDigits[p[Offset] / 16];
        Outbuf[Index*3+Index/4+1] = HexDigits[p[Offset] % 16];
        Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+Index] = iscntrl(p[Offset]) ? '.' : p[Offset];
        }

    DbgPrint("   %s\n", Outbuf);
}
#endif

//------------------------------------------------------------------------


RPC_STATUS
DispatchCallbackRequest(
    DG_CLIENT_CALLBACK *    CallbackObject
    )
{
    BOOL                fAsyncCapable = FALSE;
    RPC_STATUS          Status = RPC_S_OK;
    RPC_MESSAGE         CallbackMessage;
    PNCA_PACKET_HEADER  pHeader = &CallbackObject->Request->Header;

    CallbackMessage.Buffer = 0;

    if (pHeader->PacketFlags2 & DG_PF2_UNRELATED)
        {
        fAsyncCapable = TRUE;
        }

    //
    // Allow only the internal "conv" interface as a callback.
    //
    if (0 != pHeader->InterfaceId.MatchUuid((RPC_UUID *) &((PRPC_SERVER_INTERFACE) conv_ServerIfHandle)->InterfaceId.SyntaxGUID ))
        {
        Status = RPC_S_UNKNOWN_IF;
        }
    else if (0 != (CallbackObject->Request->Header.PacketFlags & DG_PF_FRAG))
        {
        Status = RPC_S_CALL_FAILED_DNE;
        }
    else
        {
        //
        // Dispatch to the callback stub.
        // The client doesn't support Manager EPVs or nonidempotent callbacks.
        //
        RPC_STATUS ExceptionCode;

        CallbackMessage.Handle = CallbackObject;
        CallbackMessage.DataRepresentation = 0x00ffffff & (*(unsigned long *) &pHeader->DataRep);
        CallbackMessage.Buffer = pHeader->Data;
        CallbackMessage.BufferLength = pHeader->GetPacketBodyLen();
        CallbackMessage.ProcNum = pHeader->OperationNumber;

        CallbackMessage.ManagerEpv = 0;
        CallbackMessage.ImportContext = 0;
        CallbackMessage.TransferSyntax = 0;
        CallbackMessage.RpcFlags = RPC_NCA_FLAGS_IDEMPOTENT;

        CallbackMessage.RpcInterfaceInformation = conv_ServerIfHandle;

        Status = DispatchCallback(((PRPC_SERVER_INTERFACE) CallbackMessage.RpcInterfaceInformation)->DispatchTable,
                                  &CallbackMessage,
                                  &ExceptionCode
                                  );
        if (Status)
            {
            if (Status == RPC_P_EXCEPTION_OCCURED)
                {
                Status = ExceptionCode;
                }
            }
        else if (fAsyncCapable && CallbackObject->Connection)
            {
            CallbackObject->Connection->EnableOverlappedCalls();
            }

        LogEvent(SU_CCONN, EV_STATUS, CallbackObject->Connection, 0, Status);
        }

    if (Status != RPC_S_OK)
        {
        LogError(SU_CCONN, EV_STATUS, CallbackObject->Connection, 0, Status);

        InitErrorPacket(CallbackObject->Request, DG_REJECT, Status);
        CallbackObject->SendPacket( pHeader );
        }

    return Status;
}

//------------------------------------------------------------------------


PDG_CCONNECTION
CLIENT_ACTIVITY_TABLE::Lookup(
    RPC_UUID * Uuid
    )
/*++

Routine Description:


Arguments:

    Packet

Return Value:


--*/
{
    unsigned Hash = MakeHash(Uuid);

    RequestHashMutex(Hash);

    UUID_HASH_TABLE_NODE * Node = UUID_HASH_TABLE::Lookup(Uuid, Hash);

    PDG_CCONNECTION Connection = 0;

    if (Node)
        {
        Connection = DG_CCONNECTION::FromHashNode(Node);

        Connection->MutexRequest();
        ReleaseHashMutex(Hash);
        }
    else
        {
        ReleaseHashMutex(Hash);
        }

    return Connection;
}


RPC_STATUS
StandardPacketChecks(
    DG_PACKET * pPacket
    )
{
    if (pPacket->Header.RpcVersion != DG_RPC_PROTOCOL_VERSION)
        {
        return NCA_STATUS_VERSION_MISMATCH;
        }

    ByteSwapPacketHeaderIfNecessary(pPacket);

    if (0 == (pPacket->Flags & DG_PF_PARTIAL))
        {
        //
        // Check for inconsistent packet length fields.
        //
        if (pPacket->DataLength < sizeof(NCA_PACKET_HEADER) ||
            pPacket->DataLength - sizeof(NCA_PACKET_HEADER) < pPacket->GetPacketBodyLen())
            {
            return RPC_S_PROTOCOL_ERROR;
            }
        }

    pPacket->DataLength -= sizeof(NCA_PACKET_HEADER);

    //
    // The X/Open standard does not give these fields a full byte.
    //
    pPacket->Header.RpcVersion &= 0x0F;
    pPacket->Header.PacketType &= 0x1F;

    //
    // Fix up bogus OSF packets.
    //
    DeleteSpuriousAuthProto(pPacket);

    return RPC_S_OK;
}

//------------------------------------------------------------------------


void
ProcessDgClientPacket(
    IN DWORD                 Status,
    IN DG_TRANSPORT_ENDPOINT LocalEndpoint,
    IN void *                PacketHeader,
    IN unsigned long         PacketLength,
    IN DatagramTransportPair *AddressPair
    )
{
    PDG_PACKET Packet = DG_PACKET::FromPacketHeader(PacketHeader);

    Packet->DataLength = PacketLength;

#ifdef INTRODUCE_ERRORS

    if (::ClientDropRate)
        {
        if ((GetRandomCounter() % 100) < ::ClientDropRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DROP, (void *) Uuid, (void *) Type, Frag);

            Packet->Free();
            return;
            }
        }

    if (::ClientDelayRate)
        {
        if ((GetRandomCounter() % 100) < ::ClientDelayRate)
            {
            unsigned Frag = (Packet->Header.PacketType << 16) | Packet->Header.GetFragmentNumber();
            unsigned Uuid = *(unsigned *) &Packet->Header.ActivityId;
            unsigned Type = Packet->Header.PacketType;

            LogError(SU_PACKET, EV_DELAY, (void *) Uuid, (void *) Type, Frag);

            Sleep(::ClientDelayTime);
            }
        }

#endif


    if (Status == RPC_P_OVERSIZE_PACKET)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async packet is too large\n");
#endif
        Packet->Flags |= DG_PF_PARTIAL;
        Status = RPC_S_OK;
        }

    if (Status != RPC_S_OK)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: async receive completed with status 0x%lx\n", Status);
        RpcpBreakPoint();
#endif
        Packet->Free(FALSE);
        }

    if (Packet->Header.PacketType == DG_REQUEST)
        {
        DG_CLIENT_CALLBACK CallbackObject;

        CallbackObject.LocalEndpoint = DG_ENDPOINT::FromEndpoint( LocalEndpoint );
        CallbackObject.Connection    = 0;
        CallbackObject.Request       = Packet;
        CallbackObject.RemoteAddress = AddressPair->RemoteAddress;

        DispatchCallbackRequest(&CallbackObject);
        return;
        }

    RPC_UUID ActivityId = Packet->Header.ActivityId;

    if (NeedsByteSwap(&Packet->Header))
        {
        ByteSwapUuid(&ActivityId);
        }

    PDG_CCONNECTION Connection = ClientConnections->Lookup( &ActivityId );

    if (Connection)
        {
        Connection->DispatchPacket(Packet, AddressPair->RemoteAddress);
        }
    else
        {
#ifdef DEBUGRPC
        if (Packet->Header.PacketType != DG_QUACK)
            {
            PrintToDebugger("RPC DG: no connection found for async packet of type 0x%hx\n",
                            Packet->Header.PacketType);
            }
#endif
        Packet->Free(FALSE);
        }
}


void
DG_CCONNECTION::DispatchPacket(
    PDG_PACKET Packet,
    DG_TRANSPORT_ADDRESS Address
    )
{
    Mutex.VerifyOwned();

    PDG_CCALL Call;

    if (RPC_S_OK != StandardPacketChecks(Packet))
        {
        Packet->Free();
        return;
        }

    RPC_STATUS Status = UpdateServerAddress(Packet, Address);
    if (Status)
        {
        MutexClear();
        LogEvent(SU_CCONN, EV_PKT_IN, this, IntToPtr(Packet->Header.SequenceNumber), (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        Packet->Free();
        }

    Call = ActiveCallHead;
    while (Call && Call->GetSequenceNumber() < Packet->Header.SequenceNumber)
        {
        Call = Call->Next;
        }

    if (Call && Call->GetSequenceNumber() == Packet->Header.SequenceNumber)
        {
        Call->IncrementRefCount();
        Call->DispatchPacket(Packet);
        Call->DecrementRefCount();
        }
    else
        {
        MutexClear();
        LogEvent(SU_CCONN, EV_PKT_IN, this, IntToPtr(Packet->Header.SequenceNumber), (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());
        Packet->Free();
        }
}

//------------------------------------------------------------------------


RPC_STATUS
DG_CCALL::DispatchPacket(
    IN DG_PACKET * Packet
    )
{
    BOOL ExtrasReference = FALSE;
    RPC_STATUS Status;
    PNCA_PACKET_HEADER pHeader = &Packet->Header;

    LogEvent(SU_CCALL, EV_PKT_IN, this, (void *) 0, (Packet->Header.PacketType << 16) | Packet->GetFragmentNumber());

    if (State == CallCancellingSend ||
        State == CallComplete )
        {
        FreePacket(Packet);
        return RPC_S_OK;
        }

    CancelDelayedSend();

    if (!CancelPending && TestCancel() > 0)
        {
        ++CancelEventId;
        CancelPending = TRUE;
        CancelTime = GetTickCount();
        }

    if (CancelPending)
        {
        if ((long(GetTickCount()) - CancelTime) / 1000 > ThreadGetRpcCancelTimeout() )
            {
            RpcpErrorAddRecord( EEInfoGCRuntime,
                                RPC_S_CALL_CANCELLED,
                                EEInfoDLDG_CCALL__DispatchPacket10,
                                (ULONG) ThreadGetRpcCancelTimeout(),
                                (ULONG) (long(GetTickCount()) - CancelTime)
                                );

            SendQuit();
            CancelPending = FALSE;
            FreePacket(Packet);
            return RPC_S_CALL_CANCELLED;
            }
        }

    if (Packet->Flags & DG_PF_PARTIAL)
        {
        SendFackOrNocall(Packet, DG_FACK);

        FreePacket(Packet);
        return RPC_S_OK;
        }

    // If the security context has expired, loop again - we will send
    // a packet using the current security context, and the server
    // will begin using that context to respond.
    //
    Status = Connection->VerifyPacket(Packet);
    if (Status)
        {
        FreePacket(Packet);

        if (Status == ERROR_SHUTDOWN_IN_PROGRESS)
            {
            return ERROR_SHUTDOWN_IN_PROGRESS;
            }

        if (pAsync && AsyncStatus == RPC_S_ASYNC_CALL_PENDING)
            {
            PostDelayedSend();
            }

        return RPC_S_OK;
        }

    if (DG_NOCALL != pHeader->PacketType)
        {
        UnansweredRequestCount = 0;
        TimeoutCount = 0;
        Connection->fAutoReconnect = FALSE;
        }

    LastReceiveTime = GetTickCount();

    //
    // It's not clear when the hint is allowed to change, so let's
    // always save it.
    //
    InterfaceHint                       = pHeader->InterfaceHint;
    ActivityHint                        = pHeader->ActivityHint;

    pSavedPacket->Header.InterfaceHint  = pHeader->InterfaceHint;
    pSavedPacket->Header.ActivityHint   = pHeader->ActivityHint;

    //
    // Handle the packet.
    //
    switch (pHeader->PacketType)
        {
        case DG_RESPONSE: Status = DealWithResponse(Packet); break;
        case DG_FACK:     Status = DealWithFack    (Packet); break;
        case DG_WORKING:  Status = DealWithWorking (Packet); break;
        case DG_NOCALL:   Status = DealWithNocall  (Packet); break;
        case DG_QUACK:    Status = DealWithQuack   (Packet); break;
        case DG_FAULT:    Status = DealWithFault   (Packet); break;
        case DG_REJECT:   Status = DealWithReject  (Packet); break;
        case DG_PING:              FreePacket      (Packet); break;
        default:          Status = RPC_S_PROTOCOL_ERROR;     break;
        }

    if (pAsync)
        {
        if (RPC_S_OK == Status)
            {
            if (State == CallSend )
                {
                if (IsBufferAcknowledged())
                    {
                    SetState(CallQuiescent);

                    if (pAsync->Flags & RPC_C_NOTIFY_ON_SEND_COMPLETE)
                        {
                        IssueNotification( RpcSendComplete );
                        }
                    }
                }

            if (fReceivedAllFragments)
                {
                AsyncStatus = RPC_S_OK;
                IssueNotification(RpcCallComplete);
                }
            else
                {
                if (State == CallReceive )
                    {
                    if (PipeReceiveSize && ConsecutiveDataBytes >= PipeReceiveSize)
                        {
                        IssueNotification( RpcReceiveComplete );
                        }
                    }

                PostDelayedSend();
                }
            }
        else
            {
            CancelDelayedSend();

            AsyncStatus = MapErrorCode(Status);
            IssueNotification(RpcCallComplete);
            }
        }

    if (CancelPending)
        {
        SendQuit();
        }

    return Status;
}


RPC_STATUS
DG_CCONNECTION::BeginCall(
    PDG_CCALL Call
    )
{
    //
    // Add the call to the end of the active call list.
    //
    Call->SetSequenceNumber(LowestUnusedSequence++);
    Call->Next = 0;
    Call->Previous = ActiveCallTail;

    if (ActiveCallHead)
        {
        ASSERT( Call->GetSequenceNumber() > ActiveCallTail->GetSequenceNumber() );

        ActiveCallTail->Next = Call;
        }
    else
        {
        ActiveCallHead = Call;
        }

    ActiveCallTail = Call;

    //
    // Update CurrentCall if appropriate.
    //
    if (WillNextCallBeQueued() == RPC_S_ASYNC_CALL_PENDING)
        {
        LogEvent(SU_CCONN, EV_PUSH, this, Call, (ULONG_PTR) CurrentCall);
        }
    else
        {
        LogEvent(SU_CCONN, EV_PUSH, this, Call, 0);
        if (CurrentCall)
            {
            CancelDelayedAck();
            }
        CurrentCall = Call;
        }

    return RPC_S_OK;
}


void
DG_CCONNECTION::EndCall(
    PDG_CCALL Call
    )
/*++

Routine Description:

    This fn removes a call from the active call list.
    If the call posts a delayed ACK, this fn should not be called
    until the delayed procedure runs or is cancelled.

Arguments:

    Call - the call to remove

--*/
{
    if (Call->Next == DG_CCALL_NOT_ACTIVE)
        {
        return;
        }

    if (Call->GetSequenceNumber() == LowestActiveSequence)
        {
        if (Call->Next)
            {
            LowestActiveSequence = Call->Next->GetSequenceNumber();
            }
        else
            {
            LowestActiveSequence = LowestUnusedSequence;
            }
        }

    if (CurrentCall == Call)
        {
        CurrentCall = Call->Next;

        //
        // Queued async calls on a dead connection are cancelled, one at a time.
        // As one is cleaned up, it will cancel the next, by induction.
        //
        if (this->fError)
            {
            if (CurrentCall && CurrentCall->InProgress())
                {
                CurrentCall->CancelAsyncCall( TRUE );
                }
            }

        if (!CurrentCall)
            {
            CurrentCall = Call->Previous;
            }
        }

    //
    // Now remove the call from the active list.
    //
    if (Call->Previous)
        {
        Call->Previous->Next = Call->Next;
        }
    else
        {
        ActiveCallHead = Call->Next;
        }

    if (Call->Next)
        {
        Call->Next->Previous = Call->Previous;
        }
    else
        {
        ActiveCallTail = Call->Previous;
        }

    Call->Next = DG_CCALL_NOT_ACTIVE;
}


RPC_STATUS
DG_CCONNECTION::MaybeTransmitNextCall()
{
    RPC_STATUS Status = 0;

    Mutex.VerifyOwned();

    if (WillNextCallBeQueued() == RPC_S_ASYNC_CALL_PENDING)
        {
        return RPC_S_OK;
        }

    if (!CurrentCall || !CurrentCall->Next)
        {
        LogEvent(SU_CCONN, EV_POP, this, 0);
        return RPC_S_OK;
        }

    PDG_CCALL Call = CurrentCall->Next;

    LogEvent(SU_CCONN, EV_POP, this, Call);

    ASSERT( Call->GetSequenceNumber() > CurrentCall->GetSequenceNumber() );

    CancelDelayedAck();

    CurrentCall = Call;

    Status = Call->SendSomeFragments();
    if (Status == RPC_P_HOST_DOWN ||
        Status == RPC_P_PORT_DOWN)
        {
        return Status;
        }

    return 0;
}


RPC_STATUS
DG_CCONNECTION::WillNextCallBeQueued()
{
    if (!CurrentCall)
        {
        return RPC_S_OK;
        }

    if (fServerSupportsAsync)
        {
        if (CurrentCall->AllArgsSent &&
            CurrentCall->IsBufferAcknowledged())
            {
            return RPC_S_OK;
            }
        }
    else
        {
        if (CurrentCall->fReceivedAllFragments)
            {
            return RPC_S_OK;
            }
        }

    return RPC_S_ASYNC_CALL_PENDING;
}


RPC_STATUS
DG_CLIENT_CALLBACK::GetBuffer(
    IN OUT PRPC_MESSAGE Message,
    IN UUID *ObjectUuid
    )
/*++

Routine Description:

    This method is called to actually allocate memory for an rpc call.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.
    ObjectUuid - Ignored

Return Value:

    RPC_S_OUT_OF_MEMORY
    RPC_S_OK

--*/
{
    PDG_PACKET  pPacket;

    //
    // Set up the message structure to point at this DG_CCALL.
    //
    Message->Handle = (RPC_BINDING_HANDLE)this;

    if (Message->BufferLength < LocalEndpoint->Stats.PreferredPduSize)
        {
        Message->BufferLength = LocalEndpoint->Stats.PreferredPduSize;
        }

    pPacket = DG_PACKET::AllocatePacket(Message->BufferLength);

    if (0 == pPacket)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    //
    // Point the buffer at the appropriate place in the packet.
    //
    Message->Buffer = pPacket->Header.Data;

    return RPC_S_OK;
}


void
DG_CLIENT_CALLBACK::FreeBuffer(
    IN OUT PRPC_MESSAGE Message
    )
/*++

Routine Description:

    This is called by stubs in order to free a marshalling buffer.

Arguments:

    Message - The RPC_MESSAGE structure associated with this call.

Return Value:

    <none>

--*/
{
    if (Message->Buffer)
        {
        PDG_PACKET Packet = DG_PACKET::FromStubData(Message->Buffer);

        Packet->Free(FALSE);
        if (Packet == Request)
            {
            Request = 0;
            }

        Message->Buffer = 0;
        }
}


RPC_STATUS
DG_CLIENT_CALLBACK::SetAsyncHandle (
    IN RPC_ASYNC_STATE * hAsync
    )
{
    return RPC_S_OK;
}

RPC_STATUS
DG_CLIENT_CALLBACK::AsyncSend(
    IN OUT PRPC_MESSAGE Message
    )
{
    return Send(Message);
}

RPC_STATUS
DG_CLIENT_CALLBACK::Send(
    IN OUT PRPC_MESSAGE Message
    )
{
    PNCA_PACKET_HEADER pHeader = CONTAINING_RECORD( Message->Buffer, NCA_PACKET_HEADER, Data );
    DG_PACKET * Packet         = CONTAINING_RECORD( Message->Buffer, DG_PACKET, Header.Data );

    //
    // The callback was successful, so the buffer has changed.
    // Create the packet header, send the response, and free the
    // request and response buffers.
    //

    *pHeader = Request->Header;

    SetMyDataRep(pHeader);

    pHeader->PacketType   = DG_RESPONSE;
    pHeader->PacketFlags  = DG_PF_NO_FACK;
    pHeader->AuthProto    = 0;
    pHeader->SetPacketBodyLen (Message->BufferLength);
    pHeader->SetFragmentNumber(0);

    if (Message->BufferLength + sizeof(NCA_PACKET_HEADER) > LocalEndpoint->Stats.MaxPduSize)
        {
        InitErrorPacket( Packet, DG_FAULT, NCA_STATUS_OUT_ARGS_TOO_BIG );
        }

    SendPacket( pHeader );

    FreeBuffer(Message);

    return RPC_S_OK;
}

RPC_STATUS
DG_CLIENT_CALLBACK::SendReceive(
    IN OUT PRPC_MESSAGE Message
    )
{
    return RPC_S_CANNOT_SUPPORT;
}

RPC_STATUS
DG_CLIENT_CALLBACK::Receive(
    IN OUT PRPC_MESSAGE Message,
    IN unsigned MinimumSize
    )
{
    return RPC_S_CANNOT_SUPPORT;
}


ENDPOINT_MANAGER::ENDPOINT_MANAGER(
    IN OUT RPC_STATUS * pStatus
    ) :
    Mutex(pStatus)
{
    unsigned u;

    for (u=0; u < DG_TRANSPORT_COUNT; ++u)
        {
        AsyncEndpoints[u] = 0;
        }

    Endpoints = 0;

    LastScavengeTime = GetTickCount();
}


DG_ENDPOINT *
ENDPOINT_MANAGER::RequestEndpoint(
    IN RPC_DATAGRAM_TRANSPORT * TransportInterface,
    IN BOOL Async,
    IN DWORD Flags
    )
{
    ASSERT(0 == (Flags & PENALTY_BOX) );

    if (Async)
        {
        unsigned u;
        for (u=0; u < DG_TRANSPORT_COUNT && AsyncEndpoints[u]; ++u)
            {
            if (AsyncEndpoints[u]->TransportInterface == TransportInterface &&
                AsyncEndpoints[u]->Flags == Flags)
                {
                LogEvent(SU_CENDPOINT, EV_START, AsyncEndpoints[u], 0, Async);

                InterlockedIncrement(&AsyncEndpoints[u]->NumberOfCalls);

                return AsyncEndpoints[u];
                }
            }

        Mutex.Request();

        for (; u < DG_TRANSPORT_COUNT && AsyncEndpoints[u]; ++u)
            {
            if (AsyncEndpoints[u]->TransportInterface == TransportInterface &&
                AsyncEndpoints[u]->Flags == Flags)
                {
                Mutex.Clear();
                LogEvent(SU_CENDPOINT, EV_START, AsyncEndpoints[u], 0, Async);

                InterlockedIncrement(&AsyncEndpoints[u]->NumberOfCalls);

                return AsyncEndpoints[u];
                }
            }

        DG_ENDPOINT * Node;

        Node = (DG_ENDPOINT *) new char[sizeof(DG_ENDPOINT) + TransportInterface->ClientEndpointSize];

        LogEvent(SU_CENDPOINT, EV_CREATE, Node, TransportInterface, Async);

        if (Node)
            {
            Node->TransportInterface = TransportInterface;
            Node->Async = TRUE;
            Node->Flags = Flags;

            RPC_STATUS Status = TransportInterface->OpenEndpoint(&Node->TransportEndpoint, TRUE, Flags);
            if (Status)
                {
                LogError(SU_CENDPOINT, EV_STATUS, Node, 0, Status);

                Mutex.Clear();
                delete Node;
                return 0;
                }

            Status = TransportInterface->QueryEndpointStats(&Node->TransportEndpoint, &Node->Stats);
            if (Status)
                {
                LogError(SU_CENDPOINT, EV_STATUS, Node, 0, Status);
                Mutex.Clear();

                Node->TransportInterface->Close(Node->TransportEndpoint);
                delete Node;
                return 0;
                }

            Node->NumberOfCalls = 1;

            AsyncEndpoints[u] = Node;

            Mutex.Clear();

            return AsyncEndpoints[u];
            }

        LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, 0);
        return 0;
        }
    else
        {
        Mutex.Request();

        DG_ENDPOINT * Previous = 0;
        DG_ENDPOINT * Node = Endpoints;

        //
        // Look for a node on the right transport and with the same flags.
        // If the flags match except for the penalty box, use it only if
        // the endpoint has been idle for the right length of time.
        // The caller must drain any buffered packets on a penalty-box endpoint.
        //
        for ( ; Node; Previous=Node, Node=Node->Next )
            {
            if (Node->TransportInterface != TransportInterface)
                {
                continue;
                }

            if (Node->Flags == Flags)
                {
                break;
                }

            if (Node->Flags == (Flags | PENALTY_BOX) &&
                GetTickCount() - Node->TimeStamp >= PENALTY_BOX_DURATION)
            {
                break;
                }
            }

        if (Node)
            {
            if (Previous)
                {
                Previous->Next = Node->Next;
                }
            else
                {
                Endpoints = Node->Next;
                }

            Node->NumberOfCalls = 1;

            Mutex.Clear();

            LogEvent(SU_CENDPOINT, EV_START, Node, 0, Async);

            return Node;
            }
        else
            {
            Mutex.Clear();

            Node = (DG_ENDPOINT *) new char[sizeof(DG_ENDPOINT) + TransportInterface->ClientEndpointSize];

            LogEvent(SU_CENDPOINT, EV_CREATE, Node, TransportInterface, Async);

            if (Node)
                {
                Node->TransportInterface = TransportInterface;
                Node->Async = FALSE;
                Node->Flags = Flags;

                RPC_STATUS Status = TransportInterface->OpenEndpoint(&Node->TransportEndpoint, FALSE, Flags);
                if (Status)
                    {
                    LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, Status);

                    delete Node;
                    return 0;
                    }

                Status = TransportInterface->QueryEndpointStats(&Node->TransportEndpoint, &Node->Stats);
                if (Status)
                    {
                    LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, Status);

                    Mutex.Clear();

                    Node->TransportInterface->Close(Node->TransportEndpoint);
                    delete Node;
                    return 0;
                    }

                Node->NumberOfCalls = 1;
                return Node;
                }

            LogEvent(SU_CENDPOINT, EV_STATUS, Node, 0, 0);
            return 0;
            }
        }
}


void
ENDPOINT_MANAGER::ReleaseEndpoint(
    IN DG_ENDPOINT * Node
    )
{
    LogEvent(SU_CENDPOINT, EV_STOP, Node, 0, Node->Async);

    if (Node->Async)
        {
        InterlockedDecrement(&Node->NumberOfCalls);
        }
    else
        {
        Node->TimeStamp = GetTickCount();

        Mutex.Request();

        Node->Next = Endpoints;
        Endpoints = Node;

        Mutex.Clear();

        EnableGlobalScavenger();
        }
}


BOOL
ENDPOINT_MANAGER::DeleteIdleEndpoints(
    long CurrentTime
    )
{
    boolean More = FALSE;

    Mutex.Request();

    DG_ENDPOINT * Node;
    DG_ENDPOINT * Prev = 0;

    for (Node = Endpoints; Node; Node = Node->Next)
        {
        ASSERT( Node->Async == FALSE );

        if (CurrentTime - Node->TimeStamp > IDLE_ENDPOINT_LIFETIME )
            {
            break;
            }

        Prev = Node;
        More = TRUE;
        }

    if (Prev)
        {
        Prev->Next = 0;
        }
    else
        {
        Endpoints = 0;
        }

    LastScavengeTime = CurrentTime;

    Mutex.Clear();

    while (Node)
        {
        DG_ENDPOINT * Next = Node->Next;

        LogEvent(SU_CENDPOINT, EV_DELETE, Node, Node->TransportInterface, Node->Async);

        Node->TransportInterface->Close(Node->TransportEndpoint);
        delete Node;

        Node = Next;
        }

    return More;
}

void
DG_CCALL::PostDelayedSend()
{
    Connection->Mutex.VerifyOwned();

    //
    // Cancel the rpevious send, to make sure the pending-send count is accurate.
    // Then post the new request.
    //
    CancelDelayedSend();

    DelayedSendPending++;
    DelayedProcedures->Add(&TransmitTimer, (GetTickCount() - LastReceiveTime) + ReceiveTimeout, TRUE);

    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x6e534450);
}

void
DG_CCALL::CancelDelayedSend()
{
    Connection->Mutex.VerifyOwned();

    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x6e534443);
    if (!DelayedSendPending)
        {
        return;
        }

    if (TRUE == DelayedProcedures->Cancel(&TransmitTimer))
        {
        DelayedSendPending--;
        return;
        }

    //
    // We just missed the activation of the delayed procedure.
    // This thread must let go of the mutex in order for ExecuteDelayedSend
    // to continue.  It's important that no other thread change the call state
    // during this process, since ExecuteDelayedSend checks for that state.
    //
    DG_CLIENT_STATE OldState = State;

    SetState(CallCancellingSend);

    Connection->MutexClear();

    while (DelayedSendPending)
        {
        Sleep(1);
        }

    Connection->MutexRequest();

    SetState(OldState);
}

void
DG_CCALL::ExecuteDelayedSend()
{
    LogEvent(SU_CCALL, EV_PROC, this, 0, 0x6e534445);

    Connection->MutexRequest();

    DelayedSendPending--;

    if (DelayedSendPending)
        {
        //
        // Multiple sends are pending.  Only one is helpful.
        //
        Connection->MutexClear();
        return;
        }

    if (State == CallCancellingSend)
        {
        Connection->MutexClear();
        return;
        }

    if (!TimeoutCount)
        {
        ReceiveTimeout = 500;
        }

    IncreaseReceiveTimeout();

    RPC_STATUS Status = DealWithTimeout();

    if (Status != RPC_S_OK)
        {
        AsyncStatus = MapErrorCode(Status);
        IssueNotification( RpcCallComplete );
        }

    Connection->MutexClear();
}


void
DelayedSendProc(
    void * parm
    )
{
    PDG_CCALL(parm)->ExecuteDelayedSend();
}


DG_ASSOCIATION_TABLE::DG_ASSOCIATION_TABLE(
                                           RPC_STATUS * pStatus
                                           )
                                           : Mutex( *pStatus )
{
    Associations       = InitialAssociations;
    AssociationsLength = INITIAL_ARRAY_LENGTH;

    long i;
    for (i=0; i < AssociationsLength; ++i)
        {
        Associations[i].fBusy = FALSE;
        Associations[i].Hint  = ~0;
        }

    fCasUuidReady      = FALSE;

    PreviousFreedCount = MINIMUM_IDLE_ENTRIES;
}




RPC_STATUS
DG_ASSOCIATION_TABLE::Add(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Adds <Association> to the table.

Return Value:

    zero if success
    a Win32 error if failure

--*/
{
    LONG i;
    LONG OldAssociationsLength;

    //
    // Make a hint for the association.
    //
    HINT Hint = MakeHint( Association->pDceBinding );

    //
    // Look for an open space in the current block.
    //
    Mutex.LockExclusive();

    //
    // Make sure this process has a "client address space UUID".  The callback
    // for each connection will ask for it.
    // We do this here because we are not supposed to do it in InitializeRpcProtocolDgClient.
    // It would cause a perf hit even in code that uses only LRPCbindings.
    //
    if (!fCasUuidReady)
        {
        RPC_STATUS Status;

        Status = UuidCreate(&CasUuid);
        if (Status == RPC_S_UUID_LOCAL_ONLY)
            {
            Status = 0;
            }

        if (Status)
            {
            Mutex.UnlockExclusive();

            LogEvent( SU_CASSOC, EV_STATUS, 0, 0, Status );
            return Status;
            }

        fCasUuidReady = TRUE;
        }

    for (i = 0; i < AssociationsLength; ++i)
        {
        if (!Associations[i].fBusy)
            {
            break;
            }
        }

    if (i == AssociationsLength)
        {
        //
        // The current block is full; allocate an expanded block.
        //
        LONG NewAssociationsLength = 2*AssociationsLength;
        NODE * NewAssociations = new NODE[ NewAssociationsLength ];
        if (!NewAssociations)
            {
            Mutex.UnlockExclusive();

            LogEvent( SU_CASSOC, EV_STATUS, 0, 0, RPC_S_OUT_OF_MEMORY );
            return RPC_S_OUT_OF_MEMORY;
            }

        //
        // Initialize the used and unused sections of the new block.
        //
        RpcpMemoryCopy( NewAssociations, Associations, sizeof(NODE) * AssociationsLength );

        RpcpMemorySet( &NewAssociations[ AssociationsLength ], 0, sizeof(NODE) * (NewAssociationsLength-AssociationsLength) );

        //
        // Replace the block.
        //
        if (Associations != InitialAssociations)
            {
            delete Associations;
            }

        i = AssociationsLength;

        Associations = NewAssociations;
        AssociationsLength = NewAssociationsLength;
        }

    Associations[i].fBusy       = TRUE;
    Associations[i].Hint        = Hint;
    Associations[i].Association = Association;
    Associations[i].TimeStamp   = GetTickCount();
    Associations[i].ContextHandleCount = 0;

    Association->InternalTableIndex = i;

    Mutex.UnlockExclusive();

    return 0;
}


DG_CASSOCIATION *
DG_ASSOCIATION_TABLE::Find(
     DG_BINDING_HANDLE    * Binding,
     RPC_CLIENT_INTERFACE * Interface,
     BOOL                   fContextHandle,
     BOOL                   fPartial,
     BOOL                   fAutoReconnect
     )
/*++

Routine Description:

    Locate an association that matches <Binding>'s DCE_BINDING.
    If <fPartial> is true, the endpoint will not be compared, but the
    association must have <Interface> in its list of successful interfaces
    in order to match. <fContextHandle> is true if the binding handle is
    embedded in a context handle.

Return Value:

    the association, if an matching one was found
    NULL otherwise

--*/
{
    //
    // Calculate the hint for a matching association.
    //
    HINT Hint = MakeHint( Binding->pDceBinding );

    //
    // For auto-reconnect, only recently-successful associations qualify.
    // MinimumTime is after the failed call began, at least for most com-timeout
    // settings.
    //
    long MinimumTime = GetTickCount() - (15 * 1000);

    Mutex.LockShared();

    long i;
    for (i = 0; i < AssociationsLength; ++i)
        {
        if (Associations[i].Hint == Hint &&
            Associations[i].fBusy)
            {
            DG_CASSOCIATION * Association = Associations[i].Association;

            if (Association->ErrorFlag())
                {
                continue;
                }

            if (Association->fLoneBindingHandle)
                {
                continue;
                }

            if (fAutoReconnect &&
                MinimumTime - Association->LastReceiveTime > 0)
                {
                continue;
                }

            if (fPartial)
                {
                if (Association->ComparePartialBinding(Binding, Interface) == TRUE)
                   {
                   Association->IncrementBindingRefCount(fContextHandle);
                   Associations[i].TimeStamp   = GetTickCount();

                   Mutex.UnlockShared();
                   return Association;
                   }
                }
            else
                {
                if (Association->CompareWithBinding(Binding) == 0)
                   {
                   Association->IncrementBindingRefCount(fContextHandle);
                   Associations[i].TimeStamp   = GetTickCount();

                   Mutex.UnlockShared();
                   return Association;
                   }
                }
            }
        }

    Mutex.UnlockShared();
    return 0;
}


void
ContextHandleProc(
                  void * arg
                  )
{
    ActiveAssociations->SendContextHandleKeepalives();
}

BOOL
DG_ASSOCIATION_TABLE::SendContextHandleKeepalives()
{
    BOOL fContextHandles = FALSE;
    long StartTime = GetTickCount();

    Mutex.LockShared();

    long i;
    for (i=0; i < AssociationsLength; ++i)
        {
        if (!Associations[i].fBusy)
            {
            continue;
            }

        if (Associations[i].ContextHandleCount > 0)
            {
            fContextHandles = TRUE;

            if (StartTime - Associations[i].TimeStamp >= CXT_HANDLE_KEEPALIVE_INTERVAL)
                {
                //
                // We have to avoid holding the shared lock when calling a procedure
                // that may take the exclusive lock.
                // DG_CASSOCIATION::DecrementRefCount may delete the association,
                // and that would want the exclusive table lock.
                //
                Associations[i].Association->IncrementRefCount();
                Mutex.UnlockShared();

                if (Associations[i].Association->SendKeepAlive())
                    {
                    Associations[i].TimeStamp = GetTickCount();
                    }

                Associations[i].Association->DecrementRefCount();
                Mutex.LockShared();
                }
            }
        }

    Mutex.UnlockShared();

    if (fContextHandles)
        {
        long FinishTime = GetTickCount();

        if (FinishTime-StartTime >= CXT_HANDLE_SWEEP_INTERVAL)
            {
            //
            // We are behind. Recursion or "goto start" would be cheaper,
            // but would block other delayed procs that are ready to fire.
            //
            DelayedProcedures->Add(ContextHandleTimer, 0, TRUE);
            }
        else
            {
            DelayedProcedures->Add(ContextHandleTimer, CXT_HANDLE_SWEEP_INTERVAL-(FinishTime-StartTime), TRUE);
            }
        }
    return fContextHandles;
}


void
DG_ASSOCIATION_TABLE::Delete(
    DG_CASSOCIATION * Association
    )
{
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        return;
        }

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    Mutex.LockExclusive();

    ASSERT( Associations[Index].fBusy );

    Associations[Index].fBusy = FALSE;
    Associations[Index].Hint  = ~0;

    Mutex.UnlockExclusive();

    delete Association;
}


BOOL
DG_ASSOCIATION_TABLE::DeleteIdleEntries(
                                        long CurrentTime
                                        )
/*++

Routine Description:

    This deletes entries idle more than IDLE_CASSOCIATION_LIFETIME milliseconds.

    The fn takes only the read lock until it finds an entry that needs deletion.
    Then it takes the write lock, and keeps it until the table is scoured.

Return Value:

    TRUE if items are left in the table at the end
    FALSE if the table is empty at the end

--*/
{
    BOOL fExclusive = FALSE;
    BOOL fLeftovers = FALSE;
    long i = 0;
    DG_CASSOCIATION * Association;

    //
    // Initialize an array to hold removed associations.
    //
    long NextFreedEntry = 0;
    long MaximumFreedEntries = PreviousFreedCount;

    DG_CASSOCIATION ** FreedEntries = (DG_CASSOCIATION **) _alloca( sizeof(DG_CASSOCIATION *) * MaximumFreedEntries );

    memset( FreedEntries, 0, sizeof(DG_CASSOCIATION *) * MaximumFreedEntries );

    //
    //
    //
    Mutex.LockShared();

    for (i=0; i < AssociationsLength; ++i)
        {
        if (Associations[i].fBusy)
            {
            if (CurrentTime - Associations[i].TimeStamp > IDLE_CASSOCIATION_LIFETIME)
                {
                //
                // We must claim the exclusive lock now to get an accurate answer.
                //
                if (!fExclusive)
                    {
                    fExclusive = TRUE;
                    Mutex.ConvertToExclusive();
                    }

                if (Associations[i].fBusy &&
                    CurrentTime - Associations[i].TimeStamp > IDLE_CASSOCIATION_LIFETIME &&
                    Associations[i].Association->ReferenceCount.GetInteger() == 0)
                    {
                    //
                    // It's official; the association will be deleted.
                    // Add it to the deletion array and release its slot in Associations[]..
                    //
                    Associations[i].Association->InternalTableIndex = -1;
                    FreedEntries[ NextFreedEntry ] = Associations[i].Association;

                    Associations[i].fBusy = FALSE;
                    Associations[i].Hint  = ~0;

                    ++NextFreedEntry;
                    if (NextFreedEntry == MaximumFreedEntries)
                        {
                        break;
                        }
                    }
                else
                    {
                    fLeftovers = TRUE;
                    }
                }
            else
                {
                fLeftovers = TRUE;
                }
            }
        }

    if (fExclusive)
        {
        Mutex.UnlockExclusive();
        }
    else
        {
        Mutex.UnlockShared();
        }

    //
    // Calculate the length of the array for the next pass.
    //
    if (NextFreedEntry == MaximumFreedEntries)
        {
        fLeftovers = TRUE;
        PreviousFreedCount = MaximumFreedEntries * 2;
        }
    else if (NextFreedEntry < MINIMUM_IDLE_ENTRIES)
        {
        PreviousFreedCount = MINIMUM_IDLE_ENTRIES;
        }
    else
        {
        PreviousFreedCount = NextFreedEntry;
        }

    //
    // Delete the removed associations.
    //
    --NextFreedEntry;
    while (NextFreedEntry >= 0)
        {
        delete FreedEntries[ NextFreedEntry ];
        --NextFreedEntry;
        }

    return fLeftovers;
}


DG_ASSOCIATION_TABLE::HINT
DG_ASSOCIATION_TABLE::MakeHint(
                               DCE_BINDING * pDceBinding
                               )
/*++

Routine Description:

    Construct a cheap hint to scan the association table.
    The hint should not depend on the endpoint, since we want
    a partial binding's pDceBinding to match an association
    that has a resolved endpoint.

Return Value:

    The hint.

--*/
{
    HINT Hint = 0;
    RPC_CHAR * String;

    String = pDceBinding->InqNetworkAddress();

    while (*String)
        {
        Hint *= 37;
        Hint += *String;
        ++String;
        }

    return Hint;
}


void
DG_ASSOCIATION_TABLE::IncrementContextHandleCount(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Increment the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        return;
        }

    Mutex.LockShared();

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    ++Associations[Index].ContextHandleCount;

    Mutex.UnlockShared();
}


void
DG_ASSOCIATION_TABLE::DecrementContextHandleCount(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Decrement the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        return;
        }

    Mutex.LockShared();

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    --Associations[Index].ContextHandleCount;

    Mutex.UnlockShared();
}


long
DG_ASSOCIATION_TABLE::GetContextHandleCount(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Decrement the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    long Count;
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        return 0;
        }
    Mutex.LockShared();

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    Count = Associations[Index].ContextHandleCount;

    Mutex.UnlockShared();

    return Count;
}


void
DG_ASSOCIATION_TABLE::UpdateTimeStamp(
    DG_CASSOCIATION * Association
    )
/*++

Routine Description:

    Decrement the count of context handles associated with this index.
    This is stired in the table rather than in the association
    so that the count can be accessed even if the association is swapped out.

--*/
{
    long Index = Association->InternalTableIndex;

    if (Index == -1)
        {
        return;
        }

    ASSERT( Index >= 0 && Index < AssociationsLength );
    ASSERT( Associations[Index].Association == Association );

    Associations[Index].TimeStamp = GetTickCount();
}


//
// test hook data.
//
//
// casting unsigned to/from void * is OK in this case.
//
#pragma warning(push)
#pragma warning(disable:4312)
NEW_NAMED_SDICT2( TEST_HOOK, RPC_TEST_HOOK_FN_RAW, RPC_TEST_HOOK_ID );
#pragma warning(pop)

TEST_HOOK_DICT2 * pTestHookDict;

RPCRTAPI
DWORD
RPC_ENTRY
I_RpcSetTestHook(
    RPC_TEST_HOOK_ID id,
    RPC_TEST_HOOK_FN fn
    )
{
    InitializeIfNecessary();

    GlobalMutexRequest();

    if (0 == pTestHookDict)
        {
        pTestHookDict = new TEST_HOOK_DICT2;
        if (!pTestHookDict)
            {
            GlobalMutexClear();
            return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

    pTestHookDict->Delete( id );
    pTestHookDict->Insert( id, fn );

    GlobalMutexClear();
    return 0;
}

void
ForceCallTestHook(
    RPC_TEST_HOOK_ID id,
    PVOID            subject,
    PVOID            object
    )
{
    if (pTestHookDict)
        {
        RPC_TEST_HOOK_FN fn = pTestHookDict->Find( id );

        if (fn)
            {
            (*fn)(id, subject, object);
            }
        }
}


RPC_TEST_HOOK_FN
GetTestHook(
    RPC_TEST_HOOK_ID id
    )
{
    return pTestHookDict->Find( id );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dgpkt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dgpkt.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    dgpkt.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  22-May-1995

Revision History:

     22-May-1995     jroberts

        Created this module.

     09-Jul-1997     edwardr

        Added support for large packets (>65535) for Falcon/RPC.

--*/

#include <precomp.hxx>
#include <dgpkt.hxx>

unsigned long   ProcessStartTime;
unsigned        RandomCounter = 0x6789abce;


const unsigned
RpcToPacketFlagsArray[8] =
{
    0,
    DG_PF_IDEMPOTENT,
                       DG_PF_BROADCAST,
    DG_PF_IDEMPOTENT | DG_PF_BROADCAST,
                                         DG_PF_MAYBE,
    DG_PF_IDEMPOTENT |                   DG_PF_MAYBE,
                       DG_PF_BROADCAST | DG_PF_MAYBE,
    DG_PF_IDEMPOTENT | DG_PF_BROADCAST | DG_PF_MAYBE,
};

const unsigned
PacketToRpcFlagsArray[8] =
{
            0           |            0             |           0            ,
    RPC_NCA_FLAGS_MAYBE |            0             |           0            ,
            0           | RPC_NCA_FLAGS_IDEMPOTENT |           0            ,
    RPC_NCA_FLAGS_MAYBE | RPC_NCA_FLAGS_IDEMPOTENT |           0            ,
            0           |            0             | RPC_NCA_FLAGS_BROADCAST,
    RPC_NCA_FLAGS_MAYBE |            0             | RPC_NCA_FLAGS_BROADCAST,
            0           | RPC_NCA_FLAGS_IDEMPOTENT | RPC_NCA_FLAGS_BROADCAST,
    RPC_NCA_FLAGS_MAYBE | RPC_NCA_FLAGS_IDEMPOTENT | RPC_NCA_FLAGS_BROADCAST,
};


DG_PACKET_ENGINE::DG_PACKET_ENGINE(
    unsigned char           a_PacketType,
    DG_PACKET *             a_Packet,
    RPC_STATUS *            pStatus
    ) :
    pSavedPacket          (a_Packet),
    PacketType            (a_PacketType),
    ReferenceCount        (0),
    BaseConnection        (0),
    SourceEndpoint        (0),
    RemoteAddress         (0),
    Buffer                (0),
    BufferLength          (0),
    QueuedBufferHead      (0),
    QueuedBufferTail      (0),
    pReceivedPackets      (0),
    pLastConsecutivePacket(0),
    ConsecutiveDataBytes  (0),
    ReceiveFragmentBase   (0),
    CachedPacket          (0),
    LastReceiveBuffer     (0),
    LastReceiveBufferLength(0),

    Cancelled             (FALSE)

{
    if (!a_Packet)
        {
        *pStatus = RPC_S_OUT_OF_MEMORY;
        }

    if (*pStatus)
        {
        return;
        }

    pSavedPacket->Header.RpcVersion    = DG_RPC_PROTOCOL_VERSION;
    pSavedPacket->Header.PacketFlags   = 0;

    SetMyDataRep(&pSavedPacket->Header);

#ifdef DEBUGRPC
    BasePacketFlags = ~0;
#endif
}

void
DG_PACKET_ENGINE::ReadConnectionInfo(
    DG_COMMON_CONNECTION * a_Connection,
    DG_TRANSPORT_ADDRESS   a_RemoteAddress
    )
{
    BaseConnection        = a_Connection;
    RemoteAddress         = a_RemoteAddress;

    CurrentPduSize        = 0;
    SetFragmentLengths();

    pSavedPacket->Header.InterfaceHint = 0xffff;
    RpcpMemoryCopy( &pSavedPacket->Header.ActivityId,
                    &a_Connection->ActivityNode.Uuid,
                    sizeof(UUID)
                    );
}

DG_PACKET_ENGINE::~DG_PACKET_ENGINE(
    )
{
    ASSERT( !LastReceiveBuffer );
    ASSERT( !pReceivedPackets  );
    ASSERT( !QueuedBufferHead  );
    ASSERT( !Buffer            );

    if (pSavedPacket)
        {
        FreePacket(pSavedPacket);
        }

    if (CachedPacket)
        {
        FreePacket(CachedPacket);
        }

    CleanupReceiveWindow();
}


void
DG_PACKET_ENGINE::NewCall()
/*++

Routine Description:

    A new call dawns.

Arguments:



Return Value:

    none

--*/

{
    ASSERT( !pLastConsecutivePacket );
    ASSERT( !ConsecutiveDataBytes );

    ASSERT( !LastReceiveBuffer );

    SetFragmentLengths();

    Buffer = 0;

    fReceivedAllFragments = FALSE;
    fRetransmitted        = FALSE;

    TimeoutCount        = 0;

    RepeatedFack        = 0;
    FackSerialNumber    = 0;
    SendSerialNumber    = 0;
    ReceiveSerialNumber = 0;

    SendWindowBase      = 0;
    FirstUnsentFragment = 0;
    SendBurstLength     = SendWindowSize;

    ReceiveFragmentBase = 0;

    RingBufferBase = 0;

#ifdef DEBUGRPC

    for (unsigned i=0; i < MAX_WINDOW_SIZE; i++)
        {
        FragmentRingBuffer[i].SerialNumber = 0xeeee0000;
        FragmentRingBuffer[i].Length       = 0xdd000000;
        FragmentRingBuffer[i].Offset       = 0xb000b000;
        }

#endif

    BasePacketFlags2 = 0;
}


RPC_STATUS
DG_PACKET_ENGINE::PushBuffer(
    PRPC_MESSAGE Message
    )
/*++

Function Description:

    Submits a buffer to be sent over the network.
    If a buffer is in progress, the new buffer is added to the
    "pending" list.  IF not, the buffer is placed in the "active" slot.

    The only time a buffer will not go in the active slot is during an
    async pipe call when the app is not waiting for send-complete
    notifications before submitting new buffers.

Notes:

    The buffer sent will be truncated to the nearest packet if
    RPC_BUFFER_PARTIAL is set, and Message.BufferLength is set to
    the amount actually sent.

--*/
{
//    ASSERT( Buffer == 0 || IsBufferAcknowledged() );

    RPC_STATUS Status = 0;
    RPC_STATUS FixupStatus = 0;
    unsigned FractionalPart = Message->BufferLength % MaxFragmentSize;
    unsigned SendLength     = Message->BufferLength;

    if (Message->RpcFlags & RPC_BUFFER_PARTIAL)
        {
        SendLength -= FractionalPart;
        }

    if (!Buffer || IsBufferAcknowledged())
        {
        SetCurrentBuffer(Message->Buffer,
                         SendLength,
                         Message->RpcFlags
                         );

        Status = SendSomeFragments();
        }
    else
        {
        QUEUED_BUFFER * Node = new QUEUED_BUFFER;
        if (!Node)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        Node->Buffer       = Message->Buffer;
        Node->BufferLength = SendLength;
        Node->BufferFlags  = Message->RpcFlags;
        Node->Next = 0;

        if (QueuedBufferTail)
            {
            QueuedBufferTail->Next = Node;
            }
        else
            {
            ASSERT( !QueuedBufferHead );

            QueuedBufferHead = Node;
            }

        QueuedBufferTail = Node;

        Status = 0;
        }

    FixupStatus = FixupPartialSend(Message);

    if (!Status)
        {
        Status = FixupStatus;
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::PopBuffer(
                            BOOL fSend
                            )
/*++

Function Description:

    Move the next pending send buffer into the active send buffer slot.
    This is a no-op except unless this is an async pipe call and the app
    is not waiting for send-complete notifications.

Notes:

    The buffer sent will be truncated to the nearest packet if
    RPC_BUFFER_PARTIAL is set, and Message.BufferLength is set to
    the amount actually sent.

--*/
{
    RPC_STATUS Status = 0;
    RPC_MESSAGE Message;

    Message.Buffer       = Buffer;
    Message.BufferLength = BufferLength;

    QUEUED_BUFFER * Node = QueuedBufferHead;

    if (Node)
        {
        QueuedBufferHead = Node->Next;
        if (!QueuedBufferHead)
            {
            QueuedBufferTail = 0;
            }

        SetCurrentBuffer(Node->Buffer, Node->BufferLength, Node->BufferFlags);
        if (fSend)
            {
            Status = SendSomeFragments();
            }
        delete Node;
        }
    else
        {
        Buffer       = 0;
        BufferLength = 0;
        BufferFlags  = 0;
        }

    if (Message.Buffer)
        {
        CommonFreeBuffer(&Message);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::FixupPartialSend(
    RPC_MESSAGE * Message
    )
/*++

Function Description:

    This fn "does the right thing" with the unsent bit at the end of
    a pipe send.  For sync sends, this means moving the unsent bit
    to the front of the existing buffer.  For async sends, this means
    allocating a new buffer and copying the unsent bit into it.

--*/
{
    if (!(Message->RpcFlags & RPC_BUFFER_PARTIAL))
        {
        // We need this so Receive will be passed a null buffer
        // unless the stub sticks one in the message.

        Message->Buffer = 0;
        Message->BufferLength = 0;
        return RPC_S_OK;
        }

    unsigned FractionalPart;

//    if (Message->RpcFlags & RPC_BUFFER_ASYNC)
//        {
        RPC_MESSAGE NewMessage;

        FractionalPart = Message->BufferLength % MaxFragmentSize;
        if (!FractionalPart)
            {
            Message->Buffer = 0;
            Message->BufferLength = 0;
            return RPC_S_OK;
            }

        DG_PACKET * Packet = DG_PACKET::AllocatePacket(CurrentPduSize);
        if (!Packet)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        RpcpMemoryCopy(Packet->Header.Data,
                       ((char *) Message->Buffer) + (Message->BufferLength - FractionalPart),
                       FractionalPart
                       );

        Message->Buffer       = Packet->Header.Data;
        Message->BufferLength = FractionalPart;
//        }
//    else
//        {
//        char * Temp = (char *) Message->Buffer;
//
//        FractionalPart = Message->BufferLength - FirstUnsentOffset;
//        if (!FractionalPart)
//            {
//            return RPC_S_OK;
//            }
//
//        RpcpMemoryMove(Message->Buffer, Temp + FirstUnsentOffset, FractionalPart);
//        Message->BufferLength = FractionalPart;
//        }

    return RPC_S_OK;
}


void
DG_PACKET_ENGINE::SetCurrentBuffer(
     void *        a_Buffer,
     unsigned      a_BufferLength,
     unsigned long a_BufferFlags
     )
{
    Buffer       = a_Buffer;
    BufferLength = a_BufferLength;
    BufferFlags  = a_BufferFlags;

    TimeoutCount = 0;
    SendWindowBits = 0;
    FirstUnsentOffset = 0;

    if (BufferLength == 0)
        {
        FinalSendFrag = SendWindowBase;
        }
    else
        {
        FinalSendFrag = SendWindowBase + (BufferLength-1) / MaxFragmentSize;
        }
}


RPC_STATUS
DG_PACKET_ENGINE::CommonGetBuffer(
    RPC_MESSAGE * Message
    )
{
    unsigned char SubjectType;
    void * Subject;

    unsigned    Length;
    PDG_PACKET  pPacket;

    Length = sizeof(NCA_PACKET_HEADER)
             + Align8(Message->BufferLength)
             + SecurityTrailerSize;

    unsigned BaseLength = BaseConnection->TransportInterface->BasePduSize;

//    if (Length <= BaseLength)
//        {
//        pPacket = DG_PACKET::AllocatePacket(BaseLength);
//        }
//    else if (Length <= CurrentPduSize)
//        {
//        pPacket = AllocatePacket();
//        }
//    else
        {
        pPacket = DG_PACKET::AllocatePacket(Length);
        }

    if (0 == pPacket)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    //
    // Point the buffer at the appropriate place in the packet.
    //
    Message->Buffer = pPacket->Header.Data;

//    if (pPacket->MaxDataLength < 256)
//        {
//        AddActivePacket(pPacket);
//        }

    return RPC_S_OK;
}


void
DG_PACKET_ENGINE::CommonFreeBuffer(
    RPC_MESSAGE * Message
    )
{
    if (!Message->Buffer)
        {
        return;
        }

    PDG_PACKET Packet = DG_PACKET::FromStubData(Message->Buffer);

    LogEvent(SU_ENGINE, EV_PROC, this, Message->Buffer, 'F' + (('B' + (('u' + ('f' << 8)) << 8)) << 8));

    ASSERT( Packet->MaxDataLength < 0x7fffffffUL );

//    if (Packet && Packet->MaxDataLength < 256)
//        {
//        RemoveActivePacket(Packet);
//        }

    FreePacket(Packet);

    if (Message->Buffer == LastReceiveBuffer)
        {
        LastReceiveBuffer = 0;
        LastReceiveBufferLength = 0;
        }

    Message->Buffer = 0;
}


RPC_STATUS
DG_PACKET_ENGINE::CommonReallocBuffer(
    IN RPC_MESSAGE * Message,
    IN unsigned int NewSize
    )
{
    if (Message->Buffer == LastReceiveBuffer &&
        NewSize <= LastReceiveBufferLength)
        {
        Message->BufferLength = NewSize;

        return RPC_S_OK;
        }

    RPC_STATUS Status;
    RPC_MESSAGE NewMessage;

    NewMessage.BufferLength = NewSize;

    Status = CommonGetBuffer(&NewMessage);
    if (RPC_S_OK != Status)
        {
        return Status;
        }

    LastReceiveBuffer       = NewMessage.Buffer;
    LastReceiveBufferLength = NewMessage.BufferLength;

    if (NewSize >= Message->BufferLength)
        {
        RpcpMemoryCopy(NewMessage.Buffer,
                       Message->Buffer,
                       Message->BufferLength
                       );
        }

    CommonFreeBuffer(Message);

    Message->Buffer             = NewMessage.Buffer;
    Message->BufferLength       = NewMessage.BufferLength;

    return RPC_S_OK;
}

void
DG_PACKET_ENGINE::CleanupSendWindow()
{
    while (Buffer)
        {
        PopBuffer(FALSE);
        }
}

void
DG_PACKET_ENGINE::CleanupReceiveWindow()
{
    //
    // Free any response packets.
    //
    while (pReceivedPackets)
        {
        PDG_PACKET Next = pReceivedPackets->pNext;
        FreePacket(pReceivedPackets);
        pReceivedPackets = Next;
        }

    pLastConsecutivePacket = 0;
    ConsecutiveDataBytes = 0;
}


RPC_STATUS
DG_PACKET_ENGINE::SendSomeFragments()
/*++

Routine Description:

    Sends some fragments of the user buffer.

Arguments:



Return Value:

    result of the send operation

--*/

{
    RPC_STATUS Status = RPC_S_OK;
    unsigned short i = 0;
    unsigned short AckFragment;
    unsigned short Frag;
    unsigned short Remainder;
    unsigned Offset;
    unsigned FragmentsSent = 0;

#ifdef DEBUGRPC
    if (!Buffer &&
        (BufferFlags & RPC_BUFFER_PARTIAL))
        {
//        return RPC_S_SEND_INCOMPLETE;
        RpcpBreakPoint();
        }
#endif

    if (SendBurstLength > SendWindowSize)
        {
        SendBurstLength = SendWindowSize;
        }

    //
    // If we can extend the window, do so; otherwise, resend old packets.
    //
    if (FirstUnsentFragment <= FinalSendFrag &&
        FirstUnsentFragment < SendWindowBase + SendWindowSize)
        {
        unsigned short ThisBurstLength;

        Frag = FirstUnsentFragment;

        ThisBurstLength = SendBurstLength;

        if (ThisBurstLength > FinalSendFrag + 1 - Frag)
            {
            ThisBurstLength = FinalSendFrag + 1 - Frag;
            }

        if (Frag + ThisBurstLength > SendWindowBase + SendWindowSize)
            {
            ThisBurstLength = (SendWindowBase + SendWindowSize) - Frag;
            }

        while (++FragmentsSent <= ThisBurstLength && Status == RPC_S_OK)
            {
            if (FragmentsSent == ThisBurstLength &&
                (Frag != FinalSendFrag || (BufferFlags & RPC_BUFFER_PARTIAL) || (BasePacketFlags2 & DG_PF2_UNRELATED)))
                {
                Status = SendFragment(Frag, PacketType, TRUE);
                }
            else
                {
                Status = SendFragment(Frag, PacketType, FALSE);
                }

            ++Frag;
            }

        //
        // Cut down the burst length if our window is maxed out.
        //
        if (Frag - SendWindowBase >= SendWindowSize)
            {
            SendBurstLength = (1+SendBurstLength)/2;
            }
        }

    if (0 == FragmentsSent && !IsBufferAcknowledged())
        {
        // We can get here if all the unacknowledged fragments have serial
        // numbers greater than the one the client last acknowledged, and
        // the window is also maxed out.
        //
        // This could mean the network is very slow, or the unack'ed packets
        // have been lost.
        //
        Status = SendFragment(SendWindowBase, PacketType, TRUE);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::SendFragment(
    unsigned FragNum,
    unsigned char PacketType,
    BOOL fFack
    )
{
    NCA_PACKET_HEADER PriorData;
    UNALIGNED NCA_PACKET_HEADER __RPC_FAR * pHeader;

    //
    // Figure out where the packet starts and how long it is.
    //
    unsigned Offset;
    unsigned Length;
    unsigned Index = (FragNum - SendWindowBase + RingBufferBase) % MAX_WINDOW_SIZE;
    unsigned DistanceToEnd;

    if (FragNum < FirstUnsentFragment)
        {
        Offset = FragmentRingBuffer[Index].Offset;
        Length = FragmentRingBuffer[Index].Length;
        DistanceToEnd = BufferLength - Offset;

#ifdef DEBUGRPC
        if (Offset >= 0xb000b000 || Length >= 0xdd000000)
            {
            RpcpBreakPoint();
            }
#endif
        fRetransmitted = TRUE;
        }
    else
        {
        ASSERT(FragNum == FirstUnsentFragment);

        Offset = FirstUnsentOffset;
        Length = MaxFragmentSize;
        DistanceToEnd = BufferLength - Offset;

        if (DistanceToEnd < Length)
            {
            Length = DistanceToEnd;
            }

        FirstUnsentOffset += Length;
        FirstUnsentFragment = 1 + FragNum;
        }

    if (BufferLength)
        {
// this is harmless and can sometimes be triggered on the first call of an activity
//        ASSERT(Length);
//        ASSERT(Offset < BufferLength);
        }
    else
        {
        ASSERT(!Length);
        ASSERT(!Offset);
        }

    //
    // Time to start assembling the buffer.
    //
    pHeader = (PNCA_PACKET_HEADER) (PCHAR(Buffer) - sizeof(NCA_PACKET_HEADER));

    *pHeader = pSavedPacket->Header;

    pHeader->PacketType      = PacketType;
    pHeader->PacketFlags     = BasePacketFlags;
    pHeader->PacketFlags2    = BasePacketFlags2;

    if (FinalSendFrag != 0 ||
        (BufferFlags & RPC_BUFFER_PARTIAL))
        {
        pHeader->PacketFlags |= DG_PF_FRAG;

        if (FragNum == FinalSendFrag &&
            0 == (BufferFlags & RPC_BUFFER_PARTIAL))
            {
            pHeader->PacketFlags |= DG_PF_LAST_FRAG;
            }
        }

    pHeader->SetPacketBodyLen (Length);
    pHeader->SetFragmentNumber((unsigned short) FragNum);

    if (FALSE == fFack)
        {
        pHeader->PacketFlags |= DG_PF_NO_FACK;
        }

    AddSerialNumber(pHeader);

    RPC_STATUS Status;

    //
    // Stub data is encrypted in-place; we need not to encrypt the original data
    // so we can retransmit it if necessary.
    //
    unsigned Frag = (pHeader->PacketType << 16) | pHeader->GetFragmentNumber();
    LogEvent(SU_ENGINE, EV_PKT_OUT, this, 0, Frag);

    if (BaseConnection->ActiveSecurityContext  &&
        BaseConnection->ActiveSecurityContext->AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
        RpcpMemoryCopy(&pSavedPacket->Header,     pHeader,                sizeof(NCA_PACKET_HEADER));
        RpcpMemoryCopy(pSavedPacket->Header.Data, pHeader->Data + Offset, pHeader->GetPacketBodyLen());

        Status = BaseConnection->SealAndSendPacket(SourceEndpoint, RemoteAddress, &pSavedPacket->Header, 0);
        }
    else
        {
        Status = BaseConnection->SealAndSendPacket(SourceEndpoint, RemoteAddress, pHeader, Offset);
        }

    FragmentRingBuffer[Index].SerialNumber = SendSerialNumber;
    FragmentRingBuffer[Index].Length       = Length;
    FragmentRingBuffer[Index].Offset       = Offset;

    ++SendSerialNumber;

    if (Status)
        {
        LogError(SU_ENGINE, EV_STATUS, this, 0, Status);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::UpdateSendWindow(
    PDG_PACKET pPacket,
    BOOL * pfUpdated
    )
/*++

Routine Description:

    Update the send window based upon a received FACK or NOCALL.
    The caller should filter out other packet types.

Arguments:

    pPacket - the packet received

Return Value:

    return code:

        TRUE if PDU size or window size changed
        FALSE if not
--*/
{
    RPC_STATUS Status = 0;

    FACK_BODY_VER_0 PAPI * pBody = (FACK_BODY_VER_0 PAPI *) pPacket->Header.Data;

    *pfUpdated = FALSE;

    unsigned short Diff;
    unsigned short RemoteBase = 1+pPacket->GetFragmentNumber();


    ASSERT(pPacket->TimeReceived == 0x31415926);

    //
    // Check that we can understand this packet.
    //
    if (0 != pPacket->GetPacketBodyLen())
        {
        //
        // Version 0 and version 1 are identical.
        //
        if (0 != pBody->Version &&
            1 != pBody->Version)
            {
#ifdef DEBUGRPC
            PrintToDebugger("RPC DG: warning - FACK body version %u\n", pBody->Version);
#endif
            pPacket->SetPacketBodyLen(0);
            }
        else if (pPacket->GetPacketBodyLen() < sizeof(FACK_BODY_VER_0))
            {
#ifdef DEBUGRPC
            PrintToDebugger("RPC DG: warning - FACK body truncated\n");
#endif
            pPacket->SetPacketBodyLen(0);
            }
        else if (pPacket->GetPacketBodyLen() < sizeof(FACK_BODY_VER_0) + pBody->AckWordCount * sizeof(unsigned long))
            {
#ifdef DEBUGRPC
            PrintToDebugger("RPC DG: warning - FACK body length inconsistent\n");
#endif
            pPacket->SetPacketBodyLen(0);
            }
        else
            {
            if (NeedsByteSwap(&pPacket->Header))
                {
                ByteSwapFackBody0(pBody);
                }

            //
            // NT 1057 used 0xffff to signal no packets have been received.
            // This doesn't match OSF.
            //
            if (0xffff == pBody->SerialNumber)
                {
                pBody->SerialNumber = 0;
                }

            //
            // If the other guy is resending the same FACK, we should resend.
            // If it's different, then we are likely OK.
            //
            if (pBody->SerialNumber == FackSerialNumber)
                {
                goto send;
                }

            if (pBody->SerialNumber < FackSerialNumber)
                {
                FackSerialNumber = pBody->SerialNumber;
                goto dont_send;
                }

            FackSerialNumber = pBody->SerialNumber;
            }
        }

    //
    // Update send window.
    //
    if (RemoteBase < SendWindowBase)
        {
        //
        // Fragments previously acknowledged are now missing.  Either this
        // packet was delivered out of order, or the server crashed and
        // restarted.  Ignore the packet.
        //
        goto dont_send;
        }

    if (RemoteBase > FirstUnsentFragment)
        {
#ifdef DEBUGRPC
        PrintToDebugger("RPC DG: bogus FACK packet received\n");
#endif
        goto dont_send;
        }

    //
    // We are moving the window base forward.  We need to advance the
    // ring buffer base by the same amount, and clear the entries
    // corresponding to unsent packets.
    //
    Diff = RemoteBase - SendWindowBase;

    ASSERT(Diff <= MAX_WINDOW_SIZE);

#ifdef DEBUGRPC
    while (Diff)
        {
        FragmentRingBuffer[RingBufferBase].SerialNumber |= 0xeeee0000;
        FragmentRingBuffer[RingBufferBase].Length       |= 0xdd000000;
        FragmentRingBuffer[RingBufferBase].Offset       |= 0xb0000000;

        ++RingBufferBase;
        RingBufferBase %= MAX_WINDOW_SIZE;
        --Diff;
        }
#else
    RingBufferBase += Diff;
    RingBufferBase %= MAX_WINDOW_SIZE;
#endif

    SendWindowBase = RemoteBase;
    SendWindowBits = 0;

    ASSERT( SendWindowBase <= FirstUnsentFragment );

    if (IsBufferAcknowledged())
        {
        PopBuffer(FALSE);
        }

    if (0 != pPacket->GetPacketBodyLen())
        {
        LogEvent(SU_ENGINE, EV_WINDOW, this, (void *) pBody->WindowSize, pBody->Acks[0]);

        if (pBody->AckWordCount)
            {
            //
            // Save missing-packet bitmask.
            //
            SendWindowBits = pBody->Acks[0];
            }

        //
        // Adjust window size.
        //
        if (pBody->WindowSize > MAX_WINDOW_SIZE)
            {
            pBody->WindowSize = MAX_WINDOW_SIZE;
            }

        SendWindowSize = pBody->WindowSize;

        if (SendBurstLength > SendWindowSize)
            {
            SendBurstLength = SendWindowSize;
            }

        //
        // Adjust maximum PDU length.
        //
        unsigned NewPduSize;
        NewPduSize = pBody->MaxDatagramSize;
        if (NewPduSize > SourceEndpoint->Stats.PreferredPduSize)
            {
            NewPduSize = SourceEndpoint->Stats.PreferredPduSize;
            }

        BaseConnection->CurrentPduSize    = (unsigned short) NewPduSize;
        BaseConnection->RemoteWindowSize  = pBody->WindowSize;

        //
        // If no packets are getting through, we probably are sending
        // packets that are too large.
        //
        if (0 == RemoteBase     &&
            0 == SendWindowBits &&
            NewPduSize < CurrentPduSize)
            {
            CurrentPduSize = (unsigned short) NewPduSize;
            SetFragmentLengths();

            FirstUnsentFragment = 0;
            FirstUnsentOffset   = 0;
            FinalSendFrag = SendWindowBase + (BufferLength-1) / MaxFragmentSize;
            }

        *pfUpdated = TRUE;
        }

send:

    Status = SendSomeFragments();

dont_send:

    return Status;
}


BOOL
DG_PACKET_ENGINE::UpdateReceiveWindow(
    PDG_PACKET pPacket
    )
/*++

Routine Description:

    Adds a fragment to the receive list, and sends a FACK.

Arguments:



Return Value:



--*/
{
    ASSERT(pPacket->TimeReceived == 0x31415926);

    //
    // Don't retain data from previous pipe buffers.
    //
    if (pPacket->GetFragmentNumber() < ReceiveFragmentBase)
        {
        if (0 == (pPacket->Header.PacketFlags & DG_PF_NO_FACK))
            {
            SendFackOrNocall(pPacket, DG_FACK);
            }

        return FALSE;
        }

    //
    // Attempt to guess the client's max PDU size.  Round down to a multiple
    // of eight, for NDR.
    //
    if (pPacket->DataLength + sizeof(NCA_PACKET_HEADER) > BaseConnection->CurrentPduSize)
        {
        unsigned RemoteTransportBuffer = BaseConnection->CurrentPduSize * BaseConnection->RemoteWindowSize;

        BaseConnection->CurrentPduSize   = ((pPacket->DataLength + sizeof(NCA_PACKET_HEADER)) & ~7);
        BaseConnection->RemoteWindowSize = RemoteTransportBuffer / BaseConnection->CurrentPduSize;
        if (0 == BaseConnection->RemoteWindowSize)
            {
            BaseConnection->RemoteWindowSize = 1;
            }
        }

    PNCA_PACKET_HEADER pHeader = &pPacket->Header;

    unsigned short Serial = ReadSerialNumber(pHeader);

    if (Serial > ReceiveSerialNumber)
        {
        ReceiveSerialNumber = Serial;
        }

    //
    // Authentication levels above AUTHN_LEVEL_PKT will checksum the packet,
    // so we must remove these bits from the header.
    //
    pPacket->Header.PacketFlags  &= ~(DG_PF_FORWARDED);
    pPacket->Header.PacketFlags2 &= ~(DG_PF2_FORWARDED_2);

    //
    // Check the easy case: is this a single packet call?
    //
    if ((pHeader->PacketFlags & DG_PF_FRAG) == 0  &&
        (pHeader->PacketFlags & DG_PF_LAST_FRAG) == 0)
        {
        if (pReceivedPackets)
            {
            ASSERT( pReceivedPackets->Header.SequenceNumber == pPacket->Header.SequenceNumber );
            return FALSE;
            }

        pReceivedPackets = pPacket;
        pLastConsecutivePacket = pPacket;

        pPacket->pNext = pPacket->pPrevious = 0;

        ConsecutiveDataBytes += pHeader->GetPacketBodyLen();

        fReceivedAllFragments = TRUE;

        return TRUE;
        }

    //
    // This is a multi-packet call.  Insert the packet in pReceivedPackets
    // and send a FACK.
    //
    PDG_PACKET      pScan;
    PDG_PACKET      pTrail;
    BOOL            PacketAddedToList = TRUE;

    if (pReceivedPackets == 0)
        {
        pReceivedPackets = pPacket;

        if (ReceiveFragmentBase == pHeader->GetFragmentNumber())
            {
            pLastConsecutivePacket = pPacket;
            ConsecutiveDataBytes += pHeader->GetPacketBodyLen();
            }

        pPacket->pNext = pPacket->pPrevious = 0;
        }
    else
        {
        //
        // Not the first packet to be received. So scan for its place in the
        // list.
        //
        unsigned short FragNum = pHeader->GetFragmentNumber();

        if (pLastConsecutivePacket)
            {
            pScan = pLastConsecutivePacket;
            }
        else
            {
            pScan = pReceivedPackets;
            }

        pTrail = 0;
        while (pScan && pScan->GetFragmentNumber() < FragNum)
            {
            ASSERT(pScan->TimeReceived == 0x31415926);
            ASSERT(pScan->Header.SequenceNumber == SequenceNumber);

            pTrail = pScan;
            pScan = pScan->pNext;
            }

        if (pScan != 0)
            {
            if (pScan->GetFragmentNumber() > FragNum)
                {
                if (pScan->pPrevious &&
                    pScan->pPrevious->GetFragmentNumber() >= FragNum)
                    {
                    //
                    // The new packet is a duplicate of a preexisting one
                    // upstream from pLastConsecutivePacket.
                    //
                    PacketAddedToList = FALSE;
                    }
                else
                    {
                    //
                    // Our fragment fills a gap in the series.
                    //
                    pPacket->pPrevious = pScan->pPrevious;
                    pPacket->pNext     = pScan;

                    if (pScan->pPrevious == 0)
                        {
                        pReceivedPackets = pPacket;
                        }
                    else
                        {
                        pScan->pPrevious->pNext = pPacket;
                        }
                    pScan->pPrevious = pPacket;
                    }
                }
            else
                {
                //
                // The new packet is a duplicate of a preexisting one
                // downstream from pLastConsecutivePacket.
                //
                PacketAddedToList = FALSE;
                }
            }
        else
            {
            //
            // The fragnum is larger than everything seen so far.
            //
            pTrail->pNext = pPacket;
            pPacket->pPrevious = pTrail;
            pPacket->pNext = 0;
            }
        }

    if (TRUE == PacketAddedToList)
        {
        //
        // Scan the list for the first missing fragment.
        //
        unsigned short ScanNum;
        if (pLastConsecutivePacket)
            {
            pScan = pLastConsecutivePacket->pNext;
            ScanNum = pLastConsecutivePacket->GetFragmentNumber() + 1;
            }
        else
            {
            pScan = pReceivedPackets;
            ScanNum = ReceiveFragmentBase;
            }

        while (pScan)
            {
            if (ScanNum == pScan->GetFragmentNumber())
                {
                ConsecutiveDataBytes += pScan->GetPacketBodyLen();
                pLastConsecutivePacket = pScan;
                }

            pScan = pScan->pNext;
            ++ScanNum;
            }

        //
        // We have updated pLastConsecutivePacket; is the whole buffer here?
        //
        if (pLastConsecutivePacket &&
            pLastConsecutivePacket->Header.PacketFlags & DG_PF_LAST_FRAG)
            {
            fReceivedAllFragments = TRUE;
            }
        }

    ASSERT(pReceivedPackets);

    //
    // Fack the fragment if necessary.
    //
    if (0 == (pHeader->PacketFlags & DG_PF_NO_FACK))
        {
        SendFackOrNocall(pPacket, DG_FACK);
        }

    return PacketAddedToList;
}


RPC_STATUS
DG_PACKET_ENGINE::SendFackOrNocall(
    PDG_PACKET pPacket,
    unsigned char PacketType
    )
{
    unsigned ReceiveWindowSize;

    ReceiveWindowSize = SourceEndpoint->Stats.ReceiveBufferSize
                      / ((1+SourceEndpoint->NumberOfCalls) * CurrentPduSize);

    if (0 == ReceiveWindowSize)
        {
        ReceiveWindowSize = 1;
        }
    else if (ReceiveWindowSize > MAX_WINDOW_SIZE)
        {
        ReceiveWindowSize = MAX_WINDOW_SIZE;
        }

    pSavedPacket->Header.PacketType     = PacketType;
    pSavedPacket->Header.SequenceNumber = SequenceNumber;
    pSavedPacket->Header.PacketFlags2   = 0;

    FACK_BODY_VER_0 PAPI * pBody = (FACK_BODY_VER_0 PAPI *) pSavedPacket->Header.Data;

    pBody->Version         = 1;
    pBody->Pad1            = 0;
    pBody->MaxDatagramSize = SourceEndpoint->Stats.PreferredPduSize;
    pBody->MaxPacketSize   = SourceEndpoint->Stats.MaxPacketSize;
    pBody->AckWordCount    = 1;
    pBody->WindowSize      = (unsigned short) ReceiveWindowSize;

    if (pPacket)
        {
        pBody->SerialNumber = ReadSerialNumber(&pPacket->Header);
        }
    else
        {
        pBody->SerialNumber = ReceiveSerialNumber;
        }

    unsigned short FragNum = ReceiveFragmentBase-1;
    PDG_PACKET     pScan   = 0;

    if (pLastConsecutivePacket)
        {
        FragNum = pLastConsecutivePacket->GetFragmentNumber();
        pScan   = pLastConsecutivePacket->pNext;
        }
    else if (pReceivedPackets)
        {
        pScan   = pReceivedPackets->pNext;
        }

    unsigned Bit;
    pBody->Acks[0] = 0;

    while ( pScan )
        {
        Bit = pScan->GetFragmentNumber() - FragNum - 1;

        pBody->Acks[0] |= (1 << Bit);

        pScan = pScan->pNext;
        }

    if (pBody->Acks[0] == 0)
        {
        pBody->AckWordCount = 0;
        }

    pSavedPacket->SetPacketBodyLen( sizeof(FACK_BODY_VER_0) + sizeof(unsigned long) );
    pSavedPacket->SetFragmentNumber(FragNum);

    AddSerialNumber(&pSavedPacket->Header);

    unsigned Frag = (pSavedPacket->Header.PacketType << 16) | pSavedPacket->GetFragmentNumber();
    LogEvent(SU_ENGINE, EV_PKT_OUT, this, 0, Frag);

    RPC_STATUS Status;

    Status = BaseConnection->SealAndSendPacket(SourceEndpoint, RemoteAddress, &pSavedPacket->Header, 0);

    if (Status)
        {
        LogError(SU_ENGINE, EV_STATUS, this, 0, Status);
        }

    return Status;
}


RPC_STATUS
DG_PACKET_ENGINE::AssembleBufferFromPackets(
    RPC_MESSAGE *   Message,
    CALL *          Call
    )
/*++

Routine Description:

    This function coalesces the list of consecutive packets into a monolithic
    buffer.

Arguments:

    Message - if .Buffer != 0 , use it.  Otherwise allocate one.

    Call    - in case we need to call GetBuffer

Return Value:

    RPC_S_OK - success

    RPC_S_OUT_OF_MEMORY - we couldn't allocate or reallocate Message.Buffer

--*/

{
    ASSERT( pLastConsecutivePacket );
    //
    // If only one packet is available, use the packet buffer itself.
    //
    if (0 == Message->Buffer && 0 == pReceivedPackets->pNext)
        {
        ASSERT(ConsecutiveDataBytes == pReceivedPackets->GetPacketBodyLen());

        Message->Buffer = pReceivedPackets->Header.Data;
        Message->BufferLength = ConsecutiveDataBytes;
        Message->DataRepresentation = 0x00ffffff & (*(unsigned long PAPI *) &pReceivedPackets->Header.DataRep);

        if (0 == (pReceivedPackets->Header.PacketFlags & DG_PF_FRAG))
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE;
            }

        if (pReceivedPackets->Header.PacketFlags & DG_PF_LAST_FRAG)
            {
            Message->RpcFlags |= RPC_BUFFER_COMPLETE;
            }

        pReceivedPackets = 0;
        pLastConsecutivePacket = 0;

        ConsecutiveDataBytes = 0;

        ++ReceiveFragmentBase;

        LastReceiveBuffer       = Message->Buffer;
        LastReceiveBufferLength = Message->BufferLength;

        return RPC_S_OK;
        }

    //
    // Get a buffer if we need it.
    //
    RPC_STATUS Status;

    if (0 == Message->Buffer)
        {
        ASSERT(0 == (Message->RpcFlags & RPC_BUFFER_EXTRA));

        Message->BufferLength = ConsecutiveDataBytes;

        Status = Call->GetBuffer(Message, 0);
        if (RPC_S_OK != Status)
            {
            return Status;
            }

        LastReceiveBuffer       = Message->Buffer;
        LastReceiveBufferLength = Message->BufferLength;
        }

    //
    // Reallocate the buffer if it is too small.
    //
    char __RPC_FAR * CopyBuffer = (char __RPC_FAR *) Message->Buffer;

    if (Message->RpcFlags & (RPC_BUFFER_EXTRA | RPC_BUFFER_PARTIAL))
        {
        ASSERT( !LastReceiveBufferLength         ||
                (CopyBuffer >= LastReceiveBuffer &&
                 CopyBuffer <= ((char __RPC_FAR *) LastReceiveBuffer) + LastReceiveBufferLength) );

        if (0 == (Message->RpcFlags & RPC_BUFFER_EXTRA))
            {
            Message->BufferLength = 0;
            }

        unsigned Offset = Message->BufferLength;
        CopyBuffer += Offset;
        if (CopyBuffer + ConsecutiveDataBytes > ((char __RPC_FAR *) LastReceiveBuffer) + LastReceiveBufferLength)
            {
            Status = I_RpcReallocPipeBuffer(Message, Offset + ConsecutiveDataBytes);
            if (RPC_S_OK != Status)
                {
                return Status;
                }

            CopyBuffer = (char __RPC_FAR *) Message->Buffer + Offset;
            }
        else
            {
            Message->BufferLength += ConsecutiveDataBytes;
            }
        }
    else
        {
        Message->BufferLength = ConsecutiveDataBytes;
        }

    Message->DataRepresentation = 0x00ffffff & (*(unsigned long PAPI *) &pReceivedPackets->Header.DataRep);

    {
    PDG_PACKET pkt = DG_PACKET::FromStubData(Message->Buffer);

    ASSERT( pkt->MaxDataLength >= Message->BufferLength );
    }

    //
    // Copy the stub data into the buffer.
    //
#ifdef DEBUGRPC
    unsigned long Count = 0;
#endif

    PDG_PACKET Packet;
    BOOL fLastPacket = FALSE;
    do
        {
        ASSERT(pReceivedPackets->TimeReceived == 0x31415926);
        ASSERT(ReceiveFragmentBase == pReceivedPackets->GetFragmentNumber());

        if (pReceivedPackets == pLastConsecutivePacket)
            {
            fLastPacket = TRUE;

            if (0 == (pReceivedPackets->Header.PacketFlags & DG_PF_FRAG))
                {
                Message->RpcFlags |= RPC_BUFFER_COMPLETE;
                }

            if (pReceivedPackets->Header.PacketFlags & DG_PF_LAST_FRAG)
                {
                Message->RpcFlags |= RPC_BUFFER_COMPLETE;
                }
            }

        unsigned Length = pReceivedPackets->GetPacketBodyLen();
        RpcpMemoryCopy(CopyBuffer, pReceivedPackets->Header.Data, Length);

#ifdef DEBUGRPC
        Count += Length;
#endif

        CopyBuffer += Length;
        Packet = pReceivedPackets;

        pReceivedPackets = pReceivedPackets->pNext;
        ASSERT(!pReceivedPackets || pReceivedPackets->pPrevious == Packet);
        FreePacket(Packet);

        ++ReceiveFragmentBase;
        }
    while (!fLastPacket);

    ASSERT(Count == ConsecutiveDataBytes);

    ASSERT(fLastPacket || 0 == Count % 8);

    pLastConsecutivePacket = 0;
    ConsecutiveDataBytes = 0;

    if (pReceivedPackets)
        {
        pReceivedPackets->pPrevious = 0;
        }

    return RPC_S_OK;
}


void
DG_PACKET_ENGINE::SetFragmentLengths()
{
    PSECURITY_CONTEXT pSecurityContext = BaseConnection->ActiveSecurityContext;

    if (0 == pSecurityContext)
        {
        SecurityTrailerSize = 0;
        }
    else switch (pSecurityContext->AuthenticationLevel)
        {
        case RPC_C_AUTHN_LEVEL_NONE:
            {
            SecurityTrailerSize = 0;
            break;
            }

        case RPC_C_AUTHN_LEVEL_PKT:
        case RPC_C_AUTHN_LEVEL_PKT_INTEGRITY:
            {
            SecurityTrailerSize  = (unsigned short) pSecurityContext->MaximumSignatureLength();
            SecurityTrailerSize += (unsigned short) Align4(sizeof(DG_SECURITY_TRAILER));
            break;
            }

        case RPC_C_AUTHN_LEVEL_PKT_PRIVACY:
            {
            SecurityTrailerSize  = (unsigned short) pSecurityContext->MaximumHeaderLength();
            SecurityTrailerSize += (unsigned short) Align(sizeof(DG_SECURITY_TRAILER), Align4(pSecurityContext->BlockSize()));
            break;
            }

        default:
            {
            ASSERT(0 && "RPC: unknown protect level");
            break;
            }
        }

    if (CurrentPduSize != BaseConnection->CurrentPduSize)
        {
        CurrentPduSize = (unsigned short) BaseConnection->CurrentPduSize;
        SendWindowSize = (unsigned short) BaseConnection->RemoteWindowSize;
        }

    MaxFragmentSize = CurrentPduSize - sizeof(NCA_PACKET_HEADER);

    if (SecurityTrailerSize)
        {
        MaxFragmentSize -= SecurityTrailerSize;
        MaxFragmentSize -= MaxFragmentSize % SECURITY_HEADER_ALIGNMENT;
        }
}


void
ByteSwapPacketHeader(
    PDG_PACKET  pPacket
    )
/*++

Routine Description:

    Byte swaps the packet header of the specified packet.

Arguments:

    pPacket - Pointer to the packet whose header needs byte swapping.

Return Value:

    <none>

--*/
{
    unsigned long __RPC_FAR * VerNum = (unsigned long __RPC_FAR *) &(pPacket->Header.InterfaceVersion);

    ByteSwapUuid(&(pPacket->Header.ObjectId));
    ByteSwapUuid(&(pPacket->Header.InterfaceId));
    ByteSwapUuid(&(pPacket->Header.ActivityId));
    pPacket->Header.ServerBootTime = RpcpByteSwapLong(pPacket->Header.ServerBootTime);
    *VerNum = RpcpByteSwapLong(*VerNum);
    pPacket->Header.SequenceNumber = RpcpByteSwapLong(pPacket->Header.SequenceNumber);
    pPacket->Header.OperationNumber = RpcpByteSwapShort(pPacket->Header.OperationNumber);
    pPacket->Header.InterfaceHint = RpcpByteSwapShort(pPacket->Header.InterfaceHint);
    pPacket->Header.ActivityHint = RpcpByteSwapShort(pPacket->Header.ActivityHint);
    pPacket->Header.PacketBodyLen = RpcpByteSwapShort(pPacket->Header.PacketBodyLen);
    pPacket->Header.FragmentNumber = RpcpByteSwapShort(pPacket->Header.FragmentNumber);
}


void
ByteSwapFackBody0(
    FACK_BODY_VER_0 __RPC_FAR * pBody
    )
{
    pBody->WindowSize = RpcpByteSwapShort(pBody->WindowSize);
    pBody->MaxDatagramSize = RpcpByteSwapLong (pBody->MaxDatagramSize);
    pBody->MaxPacketSize = RpcpByteSwapLong (pBody->MaxPacketSize);
    pBody->SerialNumber = RpcpByteSwapShort(pBody->SerialNumber);
    pBody->AckWordCount = RpcpByteSwapShort(pBody->AckWordCount);

    unsigned u;
    for (u=0; u < pBody->AckWordCount; ++u)
        {
        pBody->Acks[u] = RpcpByteSwapLong (pBody->Acks[u]);
        }
}



RPCRTAPI RPC_STATUS RPC_ENTRY
I_RpcTransDatagramAllocate(
    IN  DG_TRANSPORT_ENDPOINT TransportEndpoint,
    OUT BUFFER *pBuffer,
    OUT PUINT pBufferLength,
    OUT DatagramTransportPair **pAddressPair
    )
{
    DG_ENDPOINT * Endpoint = DG_ENDPOINT::FromEndpoint(TransportEndpoint);
    RPC_DATAGRAM_TRANSPORT * Transport = Endpoint->TransportInterface;

    if ( !Endpoint->Stats.PreferredPduSize )
        {
        RpcpBreakPoint();
        }

    DG_PACKET * Packet = DG_PACKET::AllocatePacket(Endpoint->Stats.PreferredPduSize 
        + Transport->AddressSize 
        + sizeof(DatagramTransportPair));
    if (!Packet)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DG_TRANSPORT_ADDRESS Address = DG_TRANSPORT_ADDRESS(Packet->Header.Data - sizeof(NCA_PACKET_HEADER) + Endpoint->Stats.PreferredPduSize);

    *pBuffer        = &Packet->Header;
    *pBufferLength  = Endpoint->Stats.PreferredPduSize;
    *pAddressPair = (DatagramTransportPair *)((char *)Address + Transport->AddressSize);
    (*pAddressPair)->RemoteAddress = Address;

    return RPC_S_OK;
}

RPCRTAPI RPC_STATUS RPC_ENTRY
I_RpcTransDatagramAllocate2(
    IN     DG_TRANSPORT_ENDPOINT TransportEndpoint,
    OUT    BUFFER               *pBuffer,
    IN OUT PUINT                 pBufferLength,
    OUT    DG_TRANSPORT_ADDRESS *pAddress
    )
{
    DG_ENDPOINT             *pEndpoint = DG_ENDPOINT::FromEndpoint(TransportEndpoint);
    RPC_DATAGRAM_TRANSPORT *pTransport = pEndpoint->TransportInterface;
    DWORD        dwSize = *pBufferLength;

    if (dwSize < pEndpoint->Stats.PreferredPduSize)
        {
        dwSize = pEndpoint->Stats.PreferredPduSize;
        }

    DG_PACKET * Packet = DG_PACKET::AllocatePacket( dwSize + pTransport->AddressSize);

    if (!Packet)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    DG_TRANSPORT_ADDRESS Address = DG_TRANSPORT_ADDRESS(Packet->Header.Data - sizeof(NCA_PACKET_HEADER) + dwSize);

    *pBuffer        = &Packet->Header;
    *pBufferLength  = dwSize;
    *pAddress       = Address;

    return RPC_S_OK;
}


RPCRTAPI RPC_STATUS RPC_ENTRY
I_RpcTransDatagramFree(
    IN RPC_TRANSPORT_ADDRESS ThisAddress,
    IN BUFFER Buffer
    )
{
    DG_PACKET * Packet = DG_PACKET::FromPacketHeader( Buffer );

    Packet->Free();

    return RPC_S_OK;
}

RPC_STATUS
DG_PACKET::Initialize(
    )
{
    return RPC_S_OK;
}


BOOL
DG_PACKET::DeleteIdlePackets(
    long CurrentTime
    )
/*++

Routine Description:

    This fn scans the free packet list for very old packets and deletes them.

Arguments:

    none

Return Value:

    none

--*/
{
    return FALSE;
}


DG_COMMON_CONNECTION::DG_COMMON_CONNECTION(
    RPC_DATAGRAM_TRANSPORT *a_TransportInterface,
    RPC_STATUS *            pStatus
    ) :
    Mutex               (pStatus),
    TimeStamp           (0),
    TransportInterface  (a_TransportInterface),
    ReferenceCount      (0),
    CurrentPduSize      (a_TransportInterface->BasePduSize),
    RemoteWindowSize    (1),
    RemoteDataUpdated   (FALSE),
    LowestActiveSequence(0),
    LowestUnusedSequence(0),
    ActiveSecurityContext(0)
{
}

DG_COMMON_CONNECTION::~DG_COMMON_CONNECTION()
{
    delete ActiveSecurityContext;
}


RPC_STATUS
SendSecurePacket(
    IN DG_ENDPOINT *                SourceEndpoint,
    IN DG_TRANSPORT_ADDRESS         RemoteAddress,
    IN UNALIGNED NCA_PACKET_HEADER *pHeader,
    IN unsigned long                DataOffset,
    IN SECURITY_CONTEXT *           SecurityContext
    )
{
    RPC_STATUS Status = RPC_S_OK;
    unsigned TrailerLength   = 0;
    unsigned MaxTrailerSize  = 0;

    PDG_SECURITY_TRAILER pTrailer = 0;

    if (SecurityContext && SecurityContext->AuthenticationLevel > RPC_C_AUTHN_LEVEL_NONE)
        {
        // Pad the stub data length to a multiple of 8, so the security
        // trailer is properly aligned.  OSF requires that the pad bytes
        // be included in PacketBodyLen.
        //
        pHeader->SetPacketBodyLen(Align8(pHeader->GetPacketBodyLen()));

        pHeader->AuthProto = (unsigned char) SecurityContext->AuthenticationService;

        SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
        SECURITY_BUFFER SecurityBuffers[5];
        DCE_MSG_SECURITY_INFO MsgSecurityInfo;

        BufferDescriptor.ulVersion = 0;
        BufferDescriptor.cBuffers = 5;
        BufferDescriptor.pBuffers = SecurityBuffers;

        SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[0].pvBuffer   = pHeader;
        SecurityBuffers[0].cbBuffer   = sizeof(NCA_PACKET_HEADER);

        SecurityBuffers[1].BufferType = SECBUFFER_DATA;
        SecurityBuffers[1].pvBuffer   = pHeader->Data + DataOffset;
        SecurityBuffers[1].cbBuffer   = pHeader->GetPacketBodyLen();

        if (SecurityContext->AuthenticationLevel == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
            {
            SecurityBuffers[2].cbBuffer = (ULONG) Align(sizeof(DG_SECURITY_TRAILER), Align4(SecurityContext->BlockSize()));
            SecurityBuffers[3].cbBuffer = SecurityContext->MaximumHeaderLength();
            }
        else
            {
            SecurityBuffers[2].cbBuffer = (ULONG) Align4(sizeof(DG_SECURITY_TRAILER));
            SecurityBuffers[3].cbBuffer = SecurityContext->MaximumSignatureLength();
            }

        pTrailer = (PDG_SECURITY_TRAILER) _alloca(SecurityBuffers[2].cbBuffer + SecurityBuffers[3].cbBuffer);

        SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
        SecurityBuffers[2].pvBuffer   = pTrailer;

        SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
        SecurityBuffers[3].pvBuffer   = (unsigned char *) pTrailer
                                      + SecurityBuffers[2].cbBuffer;

        SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
        SecurityBuffers[4].pvBuffer   = &MsgSecurityInfo;
        SecurityBuffers[4].cbBuffer   = sizeof(DCE_MSG_SECURITY_INFO);

        MsgSecurityInfo.SendSequenceNumber    = pHeader->GetFragmentNumber();
        MsgSecurityInfo.ReceiveSequenceNumber = SecurityContext->AuthContextId;
        MsgSecurityInfo.PacketType            = ~0;

        TrailerLength = SecurityBuffers[2].cbBuffer;

        pTrailer->protection_level = (unsigned char) SecurityContext->AuthenticationLevel;
        pTrailer->key_vers_num     = (unsigned char) SecurityContext->AuthContextId;

        Status = SecurityContext->SignOrSeal (
                pHeader->SequenceNumber,
                SecurityContext->AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor );

        ASSERT( SecurityBuffers[3].cbBuffer > 0 );

        TrailerLength += SecurityBuffers[3].cbBuffer;
        }
    else
        {
        //
        // Unsecure packet.
        //
        pHeader->AuthProto = 0;
        }

    if (RPC_S_OK == Status)
        {
        Status = SourceEndpoint->TransportInterface->Send(
                                          &SourceEndpoint->TransportEndpoint,
                                          RemoteAddress,
                                          pHeader,
                                          sizeof(NCA_PACKET_HEADER),
                                          pHeader->Data + DataOffset,
                                          pHeader->GetPacketBodyLen(),
                                          pTrailer,
                                          TrailerLength
                                          );
        }

    return Status;
}


RPC_STATUS
VerifySecurePacket(
    PDG_PACKET pPacket,
    SECURITY_CONTEXT * pSecurityContext
    )
{
    RPC_STATUS Status = RPC_S_OK;
    PDG_SECURITY_TRAILER pVerifier = (PDG_SECURITY_TRAILER)
                      (pPacket->Header.Data + pPacket->GetPacketBodyLen());

    if (pSecurityContext->AuthenticationLevel < RPC_C_AUTHN_LEVEL_PKT)
        {
        return RPC_S_OK;
        }

    ASSERT(pVerifier->protection_level >= RPC_C_AUTHN_LEVEL_PKT);
    ASSERT(pVerifier->protection_level <= RPC_C_AUTHN_LEVEL_PKT_PRIVACY);

    SECURITY_BUFFER_DESCRIPTOR BufferDescriptor;
    SECURITY_BUFFER            SecurityBuffers[5];
    DCE_MSG_SECURITY_INFO      MsgSecurityInfo;

    BufferDescriptor.ulVersion = 0;
    BufferDescriptor.cBuffers = 5;
    BufferDescriptor.pBuffers = SecurityBuffers;

    SecurityBuffers[0].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
    SecurityBuffers[0].pvBuffer   = &pPacket->Header;
    SecurityBuffers[0].cbBuffer   = sizeof(NCA_PACKET_HEADER);

    SecurityBuffers[1].BufferType = SECBUFFER_DATA;
    SecurityBuffers[1].pvBuffer   = pPacket->Header.Data;
    SecurityBuffers[1].cbBuffer   = pPacket->GetPacketBodyLen();

    SecurityBuffers[2].BufferType = SECBUFFER_DATA | SECBUFFER_READONLY;
    SecurityBuffers[2].pvBuffer   = pVerifier;

    if (pVerifier->protection_level == RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
        unsigned Alignment = Align4(pSecurityContext->BlockSize());

        SecurityBuffers[2].cbBuffer = (ULONG) Align(sizeof(DG_SECURITY_TRAILER), Alignment);
        SecurityBuffers[3].pvBuffer = AlignPtr(pVerifier + 1,               Alignment);
        }
    else
        {
        SecurityBuffers[2].cbBuffer = (ULONG) Align4(sizeof(DG_SECURITY_TRAILER));
        SecurityBuffers[3].pvBuffer = AlignPtr4(pVerifier + 1);
        }

    SecurityBuffers[3].BufferType = SECBUFFER_TOKEN;
    SecurityBuffers[3].cbBuffer   = pPacket->DataLength
                                  - SecurityBuffers[1].cbBuffer
                                  - SecurityBuffers[2].cbBuffer;

    SecurityBuffers[4].BufferType = SECBUFFER_PKG_PARAMS | SECBUFFER_READONLY;
    SecurityBuffers[4].pvBuffer   = &MsgSecurityInfo;
    SecurityBuffers[4].cbBuffer   = sizeof(DCE_MSG_SECURITY_INFO);

    MsgSecurityInfo.SendSequenceNumber    = pPacket->GetFragmentNumber();
    MsgSecurityInfo.ReceiveSequenceNumber = pSecurityContext->AuthContextId;
    MsgSecurityInfo.PacketType            = ~0;

    //
    // If the packet came from a big-endian machine, we must restore
    // the header to its original condition or the checksum will fail.
    //
    ByteSwapPacketHeaderIfNecessary(pPacket);

    Status = pSecurityContext->VerifyOrUnseal(
                pPacket->Header.SequenceNumber,
                pVerifier->protection_level != RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                &BufferDescriptor
                );

    //
    // Gotta re-swap the header so we can still look at its fields.
    //
    ByteSwapPacketHeaderIfNecessary(pPacket);

    if (RPC_S_OK != Status)
        {
#ifdef DEBUGRPC
            DbgPrint("dg rpc: %lx: pkt %lx type %lx has bad security info (error 0x%lx)\n",
                     GetCurrentProcessId(), pPacket, pPacket->Header.PacketType, Status);
#endif

        ASSERT(Status == RPC_S_ACCESS_DENIED ||
               Status == ERROR_SHUTDOWN_IN_PROGRESS ||
               Status == ERROR_PASSWORD_MUST_CHANGE ||
               Status == ERROR_PASSWORD_EXPIRED ||
               Status == ERROR_ACCOUNT_DISABLED ||
               Status == ERROR_INVALID_LOGON_HOURS);
        }

    return(Status);
}

BOOL
DG_PickleEEInfoIntoPacket (
    IN DG_PACKET * Packet,
    IN size_t PickleStartOffset
    )
/*++
Function Name: PickeEEInfoIntoPacket

Parameters:
    PickleStartOffset - the offset in bytes where the pickling starts
    pHeader - pointer to the packet to fill

Description:
    Checks for EEInfo on the thread, trims the EEInfo to Packet->MaxDataLength,
        and pickles the EEInfo starting from PickleStartOffset.

Returns:
    TRUE if EEInfo was pickled. FALSE if not.

--*/
{
    BOOL fEEInfoPresent = FALSE;
    ExtendedErrorInfo *EEInfo;
    RPC_STATUS RpcStatus;
    size_t CurrentPacketSize;

    EEInfo = RpcpGetEEInfo();
    if (EEInfo)
        {
        AddComputerNameToChain(EEInfo);
        TrimEEInfoToLength (Packet->MaxDataLength, &CurrentPacketSize);
        if (CurrentPacketSize != 0)
            {
            CurrentPacketSize += PickleStartOffset;

            ASSERT(IsBufferAligned(Packet->Header.Data + PickleStartOffset));

            RpcpMemorySet(Packet->Header.Data, 0, CurrentPacketSize);

            RpcStatus = PickleEEInfo( EEInfo,
                                      Packet->Header.Data + PickleStartOffset,
                                      CurrentPacketSize   - PickleStartOffset
                                      );

            if (RpcStatus == RPC_S_OK)
                {
                fEEInfoPresent = TRUE;
                Packet->SetPacketBodyLen( CurrentPacketSize );
                }
            }
        }

    return fEEInfoPresent;
}


void
InitErrorPacket(
    DG_PACKET *     pPacket,
    unsigned char   PacketType,
    RPC_STATUS      RpcStatus
    )
/*++

Routine Description:

    Maps <ProcessStatus> to an NCA error code and sends
    a FAULT or REJECT packet to the client, as appropriate.

Arguments:

    pSendPacket - a packet to use, or zero if this fn should allocate one

    ProcessStatus - NT RPC error code

Return Value:

    none

--*/
{
    NCA_PACKET_HEADER * pHeader = &pPacket->Header;

    CleanupPacket(pHeader);

    pHeader->PacketType = PacketType;

    size_t FaultSize;
    BOOL fEEInfoPresent = FALSE;

    //
    // This mapping distinguishes client-side shutdown from server-side shutdown.
    //
    if (RpcStatus == ERROR_SHUTDOWN_IN_PROGRESS)
        {
        if (PacketType == DG_REJECT)
            {
            RpcStatus = RPC_S_SERVER_UNAVAILABLE;
            }
        else
            {
            RpcStatus = ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
            }
        }
    else if (RpcStatus == RPC_P_CLIENT_SHUTDOWN_IN_PROGRESS)
        {
        RpcStatus = ERROR_SHUTDOWN_IN_PROGRESS;
        }

    if (g_fSendEEInfo)
        {
        fEEInfoPresent = DG_PickleEEInfoIntoPacket( pPacket, FIELD_OFFSET( EXTENDED_FAULT_BODY, EeInfo) );
        }

    if (fEEInfoPresent)
        {
        //
        // Packet body length already set.
        //
        EXTENDED_FAULT_BODY * body = (EXTENDED_FAULT_BODY *) pHeader->Data;

        body->NcaStatus = MapToNcaStatusCode(RpcStatus);
        body->Magic     = DG_EE_MAGIC_VALUE;
        body->reserved1 = 0;
        body->reserved2 = 0;
        }
    else
        {
        size_t XopenFaultSize = sizeof(unsigned long);

        *(unsigned long *)(pHeader->Data) = MapToNcaStatusCode(RpcStatus);

        pHeader->SetPacketBodyLen(XopenFaultSize);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dispatch.h ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dispatch.h

Abstract:

Author:

    Michael Montague (mikemon) 11-Jun-1992

Revision History:

--*/

#ifndef __DISPATCH_H__
#define __DISPATCH_H__

#ifdef __cplusplus
extern "C" {
#endif

unsigned int
DispatchToStubInC (
    IN RPC_DISPATCH_FUNCTION Stub,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS * ExceptionCode
    );

#ifdef __cplusplus
}
#endif

#endif // __DISPATCH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dispatch.c ===
/*++

Copyright (C) Microsoft Corporation, 1992 - 1999

Module Name:

    dispatch.h

Abstract:

Author:

    Michael Montague (mikemon) 11-Jun-1992

Revision History:

--*/

#include <sysinc.h>
#include <rpc.h>
#include <rpcdcep.h>
#include <dispatch.h>

unsigned int
DispatchToStubInC (
    IN RPC_DISPATCH_FUNCTION Stub,
    IN OUT PRPC_MESSAGE Message,
    OUT RPC_STATUS * ExceptionCode
    )
/*++

Routine Description:

    Dispatch a remote procedure call to a stub.  This must be in C
    because cfront does not support try-except on MIPS.

Arguments:

    Stub - Supplies the pointer to the function to dispatch to.

    Message - Supplies the request and returns the response.

    ExceptionCode - Returns the exception code if an exception
        occured.

Return Value:

    A non-zero value will be returned in an exception occured.

--*/
{
    unsigned int ExceptionHappened = 0;

    RpcTryExcept
        {
        (*Stub)(Message);
        }

    // Return "non-fatal" errors to clients.  Catching fatal errors
    // makes it harder to debug.
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        ExceptionHappened = 1;
        *ExceptionCode = RpcExceptionCode();
        ASSERT(*ExceptionCode != RPC_S_OK);
        }
    RpcEndExcept

    return(ExceptionHappened);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\dumpcert.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       dumpcert.cxx
//
//--------------------------------------------------------------------------

#include "precomp.hxx"
#include <wincrypt.h>
#include <rpcssl.h>

#if 0

stuff clobbered by Unicode -> ANSI port:

wchar_t -> char
WCHAR   -> char
L""     -> ""
%S      -> %s
W suffix-> A suffix
wcscmp  -> strcmp
wmain   -> main
LPWSTR  -> LPSTR

#endif


#define ByteSwapShort(Value) \
    Value = (  (((Value) & 0x00FF) << 8) \
             | (((Value) & 0xFF00) >> 8))

#define INITIAL_NAME_LENGTH 100

#define     MSSTD_PREFIX_LENGTH 6
const char MSSTD_PREFIX[]    = "msstd:";

#define     FULLPATH_PREFIX_LENGTH 8
const char FULLPATH_PREFIX[] = "fullsic:";

//------------------------------------------------------------------------

void DumpCertInfo( PCERT_INFO Info );
void RecordErrorAndExit( char * Action, unsigned long Error );

extern "C"
{
int __cdecl
main( int argc,
       char * argv[],
       char * envp[]
       );
}



int __cdecl
main(  int argc,
       char * argv[],
       char * envp[]
       )
{
    HCERTSTORE Store;
    PCCERT_CONTEXT Context = 0;
    unsigned Criterion  = CERT_FIND_ANY;
    void *   SearchData = 0;
    char * StoreName = "My";
    int i;
    char * MatchString = 0;
    BOOL fMatch = FALSE;
    BOOL fOutput = FALSE;
    unsigned long OutputFlags = 0;
    DWORD StoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;

    for (i=1; i < argc; ++i)
        {
        if (0 == strcmp(argv[i], "-subject"))
            {
            Criterion = CERT_FIND_SUBJECT_STR_W;
            ++i;
            if (i >= argc)
                {
                printf("-subject must be followed by a subject name or substring\n");
                return 1;
                }

            SearchData = argv[i];
            }
        else if (0 == strcmp(argv[i], "-issuer"))
            {
            Criterion = CERT_FIND_ISSUER_STR_W;
            ++i;
            if (i >= argc)
                {
                printf("-issuer must be followed by an issuer name or substring\n");
                return 1;
                }
            SearchData = argv[i];
            }
        else if (0 == strcmp(argv[i], "-store"))
            {
            ++i;
            if (i >= argc)
                {
                printf("-store must be followed by a store name, such as 'Root' or 'My'\n");
                return 1;
                }
            StoreName = argv[i];
            }
        else if (0 == strcmp(argv[i], "-location"))
            {
            ++i;

            if (i >= argc)
                {
                printf("-location must be followed by 'USER:' or by 'HKLM'\n");
                return 1;
                }

            if (0 == strcmp(argv[i], "USER:"))
                {
                StoreFlags = CERT_SYSTEM_STORE_CURRENT_USER;
                }
            else if (0 == strcmp(argv[i], "HKLM"))
                {
                StoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;
                }
            else
                {
                printf("-location must be followed by 'USER:' or by 'HKLM'\n");
                return 1;
                }
            }
        else if (0 == strcmp(argv[i], "-output"))
            {
            fOutput = TRUE;
            ++i;

            if(i >= argc)
                {
                printf("-output must be followed by 'msstd' or by 'fullsic'\n");
                return 1;
                }

            if (0 == strcmp(argv[i], "fullsic"))
                {
                OutputFlags = RPC_C_FULL_CERT_CHAIN;
                }
            else if (0 == strcmp(argv[i], "msstd"))
                {
                OutputFlags = 0;
                }
            else
                {
                printf("-output must be followed by 'msstd' or by 'fullsic'\n");
                return 1;
                }
            }
        else if (0 == strcmp(argv[i], "-match"))
            {
            fMatch = TRUE;

            ++i;
            if(i >= argc)
                {
                printf("-match must be followed by '@filename', listing the name of the file containing the match string\n");
                return 1;
                }

            if (argv[i][0] == '@')
                {
                DWORD BytesRead;
                HANDLE hMatchFile;

                hMatchFile = CreateFileA( argv[i]+1,
                                          GENERIC_READ,
                                          FILE_SHARE_READ,
                                          0,                 // no security
                                          OPEN_EXISTING,     // must already exist
                                          FILE_ATTRIBUTE_NORMAL,
                                          NULL               // no template file
                                          );

                if (hMatchFile == ULongToHandle(0xffffffff))
                    {
                    printf("can't open file %s\n", argv[i]+1);
                    return 1;
                    }

                DWORD Size = GetFileSize( hMatchFile, 0);
                if (Size == 0xffffffff)
                    {
                    printf("GetFileSize failed with 0x%x\n", GetLastError());
                    return 1;
                    }

                if (Size % 2)
                    {
                    printf("the match-string file must be in Unicode.\n");
                    return 1;
                    }

                MatchString = new char[ Size/sizeof(char) + sizeof(char) ];
                if (!MatchString)
                    {
                    printf("can't allocate memory\n");
                    return 1;
                    }

                if (!ReadFile( hMatchFile,
                               MatchString,
                               Size,
                               &BytesRead,
                               0            // not overlapped
                               )
                    || BytesRead != Size)
                    {
                    printf("can't read file data: 0x%x\n", GetLastError());
                    return 1;
                    }

                MatchString[ Size/sizeof(char) ] = 0;

                if (MatchString[0] == 0xfeff)
                    {
                    ++MatchString;
                    }
                else if (MatchString[0] == 0xfffe)
                    {
                    char * pc;

                    for (pc = MatchString; *pc; ++pc)
                        {
                        ByteSwapShort(*pc);
                        }

                    ++MatchString;
                    }
                }
            else
                {
                MatchString = argv[i];
                }

            printf("string to match is '%s'\n", MatchString);
            }
        else if (0 == strcmp(argv[i], "-?") ||
                 0 == strcmp(argv[i], "-help"))
            {
            printf("usage:\n"
                   "    dumpcert \n"
                   "        [-subject subject-substring]\n"
                   "        [-issuer issuer-substring]\n"
                   "        [-store store-name]\n"
                   "        [-output ('fullsic' | 'msstd')\n"
                   "        [-location ('HKLM' | 'USER:')\n"
                   "        [-match @filename]\n"
                   );
            return 1;
            }
        else
            {
            printf("unknown option '%s'\n", argv[i]);
            return 1;
            }
        }

    Store = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                           0,
                           0,
                           StoreFlags,
                           StoreName
                           );

    if (!Store)
        {
        RecordErrorAndExit("opening the store", GetLastError());
        }

    for(;;)
        {
        Context = CertFindCertificateInStore( Store,
                                              X509_ASN_ENCODING,
                                              0,
                                              Criterion,
                                              SearchData,
                                              Context
                                              );
        if (!Context)
            {
            break;
            }

        DumpCertInfo( Context->pCertInfo );
        if (fOutput)
            {
            unsigned char * OutputBuffer = 0;
            DWORD Status = RpcCertGeneratePrincipalNameA( Context, OutputFlags, &OutputBuffer );
            if (Status)
                {
                printf("GeneratePrincName returned %d = 0x%x\n", Status, Status);
                }
            else
                {
                printf("    generated name = '%s'\n", OutputBuffer);
                }
            }

        if (fMatch)
            {
            printf("matching is not implemented because RpcCertMatchPrincipalName is not exported\n");
#if 0
            DWORD Status = RpcCertMatchPrincipalName( Context, MatchString );
            if (Status)
                {
                printf("MatchPrincipalName returned %d = 0x%x\n", Status, Status);
                }
            else
                {
                printf("The names matched.\n");
                }
#endif
            }
        }

    if (GetLastError() != CRYPT_E_NOT_FOUND)
        {
        RecordErrorAndExit("getting certificates", GetLastError());
        }

    return 0;
}

void DumpCertInfo( PCERT_INFO Info )
{
    SYSTEMTIME NotBeforeTime;
    SYSTEMTIME NotAfterTime;
    char      SubjectName[1000];
    char      IssuerName[1000];

    if (!FileTimeToSystemTime( &Info->NotBefore, &NotBeforeTime ))
        {
        RecordErrorAndExit("translating not-before time", GetLastError());
        }

    if (!FileTimeToSystemTime( &Info->NotAfter, &NotAfterTime ))
        {
        RecordErrorAndExit("translating not-after time",  GetLastError());
        }

    if (!CertNameToStrA( X509_ASN_ENCODING,
                        &Info->Subject,
                        CERT_X500_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
                        SubjectName,
                        sizeof(SubjectName)
                        ))
        {
        RecordErrorAndExit("unpacking subject name", GetLastError());
        }

    if (!CertNameToStrA( X509_ASN_ENCODING,
                        &Info->Issuer,
                        CERT_X500_NAME_STR | CERT_NAME_STR_SEMICOLON_FLAG,
                        IssuerName,
                        sizeof(IssuerName)
                        ))
        {
        RecordErrorAndExit("unpacking issuer name", GetLastError());
        }

    printf("----------------------------------------------------\n\n");

    printf("    subject: %s\n", SubjectName);
    printf("    issuer:  %s\n", IssuerName);
    printf("    version %d\n", Info->dwVersion );
    printf("    valid from %02d:%02d:%02d on %d-%02d-%d\n",
           NotBeforeTime.wHour,
           NotBeforeTime.wMinute,
           NotBeforeTime.wSecond,
           NotBeforeTime.wMonth,
           NotBeforeTime.wDay,
           NotBeforeTime.wYear
           );

    printf("          to   %02d:%02d:%02d on %d-%02d-%d\n",
           NotAfterTime.wHour,
           NotAfterTime.wMinute,
           NotAfterTime.wSecond,
           NotAfterTime.wMonth,
           NotAfterTime.wDay,
           NotAfterTime.wYear
           );
}


void RecordErrorAndExit( char * Action, unsigned long Error )
{
    char * lpMsgBuf = "";

    FormatMessageA( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                   FORMAT_MESSAGE_FROM_SYSTEM |
                   FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL,
                   Error,
                   MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                   (LPSTR) &lpMsgBuf,
                   0,
                   NULL
                   );

    printf("error while %s: %x (%d) \"%s\"", Action, Error, Error, lpMsgBuf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\eeinfo.cxx ===
/*++

Copyright (C) Microsoft Corporation, 2000

Module Name:

    EEInfo.cxx

Abstract:

    Extended Error Info public & private functions

Author:

    Kamen Moutafov    [KamenM]


Revision History:

    KamenM      Mar 2000    Initial version
    KamenM      Oct 2000    Add caching of EEInfo blocks to 
                            solve Exchange perf problems

--*/
#include <precomp.hxx>
#include <EEInfo.h>
#include <EEInfo.hxx>

const int MaxBinaryBlobSize = 4096; // 4K limit

ExtendedErrorInfo *
AllocateExtendedErrorInfoRecord (
    IN int NumberOfParams
    )
/*++

Routine Description:

    Allocates a memory block large enough to hold an
    extended error record with the specified number of
    parameters. It is allocated with MIDL_user_allocate.

Arguments:
    NumberOfParams - number of paramaters to provide space
        for

Return Value:

    The address of the block or NULL if out of memory

--*/
{
    ExtendedErrorInfo *EEInfo;
    THREAD *ThisThread;

    ThisThread = ThreadSelf();
    if (ThisThread)
        {
        EEInfo = ThisThread->GetCachedEEInfoBlock(NumberOfParams);
        }
    else
        EEInfo = NULL;

    if (EEInfo == NULL)
        {
        EEInfo = (ExtendedErrorInfo *) MIDL_user_allocate(sizeof(ExtendedErrorInfo) + 
            (NumberOfParams - 1) * sizeof(ExtendedErrorParam));
        }

    if (EEInfo)
        EEInfo->nLen = (short)NumberOfParams;
    return EEInfo;
}

inline void
FreeEEInfoRecordShallow (
    IN ExtendedErrorInfo *InfoToFree
    )
/*++

Routine Description:

    Frees only the eeinfo record - not any of
    the pointers contained in it.

Arguments:
    InfoToFree - the eeinfo record

Return Value:

    void

--*/
{
    MIDL_user_free(InfoToFree);
}

RPC_STATUS
DuplicatePrivateString (
    IN EEUString *SourceString,
    OUT EEUString *DestString
    )
/*++

Routine Description:

    Takes a EEUString structure and makes a copy
    of it.

Arguments:
    SourceString - the string to copy
    DestString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    DestString->nLength = SourceString->nLength;
    DestString->pString = (LPWSTR)MIDL_user_allocate(DestString->nLength * sizeof(unsigned short));
    if (DestString->pString != NULL)
        {
        RpcpMemoryCopy(DestString->pString, SourceString->pString, DestString->nLength * sizeof(unsigned short));
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS
DuplicatePrivateString (
    IN EEAString *SourceString,
    OUT EEAString *DestString
    )
/*++

Routine Description:

    Takes a EEAString structure and makes a copy
    of it.

Arguments:
    SourceString - the string to copy
    DestString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    DestString->nLength = SourceString->nLength;
    DestString->pString = (unsigned char *)MIDL_user_allocate(DestString->nLength);
    if (DestString->pString != NULL)
        {
        RpcpMemoryCopy(DestString->pString, SourceString->pString, DestString->nLength);
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS
DuplicateBlob (
    IN void *SourceBlob,
    IN short Size,
    OUT void **DestBlob)
/*++

Routine Description:

    Takes a blob and makes a copy of it.

Arguments:
    SourceBlob - the blob to copy
    Size - the size of the blob
    DestBlob - a placeholder where a pointer to the copied
        buffer will be put

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    void *CopiedBlob;

    CopiedBlob = MIDL_user_allocate(Size);
    if (CopiedBlob)
        {
        RpcpMemoryCopy(CopiedBlob, SourceBlob, Size);
        *DestBlob = CopiedBlob;
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS 
DuplicatePrivateBlob (
    IN BinaryEEInfo *SourceBlob,
    OUT BinaryEEInfo *DestBlob)
/*++

Routine Description:

    Takes a binary param and makes a copy of it.

Arguments:
    SourceBlob - the blob to copy
    DestBlob - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS Status;

    Status = DuplicateBlob(SourceBlob->pBlob, SourceBlob->nSize, (PVOID *)&DestBlob->pBlob);
    if (Status == RPC_S_OK)
        {
        DestBlob->nSize = SourceBlob->nSize;
        }

    return Status;
}

RPC_STATUS 
ConvertPublicStringToPrivateString (
    IN LPWSTR PublicString,
    OUT EEUString *PrivateString)
/*++

Routine Description:

    Takes a LPWSTR string and makes a copy
    of it into a EEUString structure

Arguments:
    PublicString - the string to copy - cannot be NULL
    PrivateString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    // the StringLength is in bytes
    int StringLength = (wcslen(PublicString) + 1) * 2;
    LPWSTR CopiedString;
    CopiedString = (LPWSTR)MIDL_user_allocate(StringLength);
    if (CopiedString)
        {
        RpcpMemoryCopy(CopiedString, PublicString, StringLength);
        PrivateString->pString = CopiedString;
        PrivateString->nLength = (short)StringLength / 2;
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS 
ConvertPublicStringToPrivateString (
    IN LPSTR PublicString,
    OUT EEAString *PrivateString)
/*++

Routine Description:

    Takes a LPSTR string and makes a copy
    of it into a EEAString structure

Arguments:
    PublicString - the string to copy - cannot be NULL
    PrivateString - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    int StringLength = strlen(PublicString) + 1;
    LPSTR CopiedString;
    CopiedString = (LPSTR)MIDL_user_allocate(StringLength);
    if (CopiedString)
        {
        RpcpMemoryCopy(CopiedString, PublicString, StringLength);
        PrivateString->pString = (unsigned char *)CopiedString;
        PrivateString->nLength = (short)StringLength;
        return RPC_S_OK;
        }
    else
        {
        return RPC_S_OUT_OF_MEMORY;
        }
}

RPC_STATUS 
ConvertPublicBlobToPrivateBlob (
    IN BinaryParam *PublicBlob,
    OUT BinaryEEInfo *PrivateBlob)
/*++

Routine Description:

    Takes a binary param and converts it to private format.

Arguments:
    PublicBlob - the blob to copy - cannot be NULL
    PrivateBlob - a placeholder allocated by caller to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    unsigned char *CopiedBlob;

    if (PublicBlob->Size > MaxBinaryBlobSize)
        {
        return ERROR_INVALID_PARAMETER;
        }

    RPC_STATUS Status;

    Status = DuplicateBlob(PublicBlob->Buffer, PublicBlob->Size, (PVOID *)&PrivateBlob->pBlob);
    if (Status == RPC_S_OK)
        {
        PrivateBlob->nSize = PublicBlob->Size;
        }

    return Status;
}

RPC_STATUS
ConvertPrivateStringToPublicString (
    IN EEUString *PrivateString,
    IN BOOL CopyStrings,
    OUT LPWSTR *PublicString
    )
/*++

Routine Description:

    Takes a EEUString and makes a copy
    of it into a LPWSTR

Arguments:
    PrivateString - the string to copy
    CopyStrings - if non-zero this routine will allocate
        space on the process heap and will copy the string.
        If zero, it will alias the PublicString to the
        pString member of PrivateString
    PublicString - the string to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    LPWSTR ReturnString;
    int StringLength;   // in bytes

    if (CopyStrings)
        {
        StringLength = PrivateString->nLength * 2;
        ReturnString = (LPWSTR)RtlAllocateHeap(RtlProcessHeap(), 0, StringLength);
        if (ReturnString == NULL)
            return RPC_S_OUT_OF_MEMORY;
        RpcpMemoryCopy(ReturnString, PrivateString->pString, StringLength);
        }
    else
        {
        ReturnString = PrivateString->pString;
        }

    *PublicString = ReturnString;
    return RPC_S_OK;
}

RPC_STATUS
ConvertPrivateStringToPublicString (
    IN EEAString *PrivateString,
    IN BOOL CopyStrings,
    OUT LPSTR *PublicString
    )
/*++

Routine Description:

    Takes a EEAString and makes a copy
    of it into a LPSTR

Arguments:
    PrivateString - the string to copy
    CopyStrings - if non-zero this routine will allocate
        space on the process heap and will copy the string.
        If zero, it will alias the PublicString to the
        pString member of PrivateString
    PublicString - the string to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    LPSTR ReturnString;
    if (CopyStrings)
        {
        ReturnString = (LPSTR)RtlAllocateHeap(RtlProcessHeap(), 0, PrivateString->nLength);
        if (ReturnString == NULL)
            return RPC_S_OUT_OF_MEMORY;
        RpcpMemoryCopy(ReturnString, PrivateString->pString, PrivateString->nLength);
        }
    else
        {
        ReturnString = (char *)PrivateString->pString;
        }

    *PublicString = ReturnString;
    return RPC_S_OK;
}

RPC_STATUS
ConvertPrivateBlobToPublicBlob (
    IN BinaryEEInfo *PrivateBlob,
    IN BOOL CopyStrings,
    OUT BinaryParam *PublicBlob
    )
/*++

Routine Description:

    Takes a private blob and makes a copy
    of it into a public blob format

Arguments:
    PrivateBlob - the blob to copy
    CopyStrings - if non-zero this routine will allocate
        space on the process heap and will copy the blob.
        If zero, it will alias the PublicBlob to the
        Blob.pBlob member of PrivateBlob
    PublicBlob - the blob to copy to

Return Value:

    RPC_S_OK or RPC_S_OUT_OF_MEMORY

--*/
{
    void *ReturnBuffer;
    if (CopyStrings)
        {
        ReturnBuffer = RtlAllocateHeap(RtlProcessHeap(), 0, PrivateBlob->nSize);
        if (ReturnBuffer == NULL)
            return RPC_S_OUT_OF_MEMORY;
        RpcpMemoryCopy(ReturnBuffer, PrivateBlob->pBlob, PrivateBlob->nSize);
        }
    else
        {
        ReturnBuffer = PrivateBlob->pBlob;
        }

    PublicBlob->Buffer = ReturnBuffer;
    PublicBlob->Size = PrivateBlob->nSize;
    return RPC_S_OK;
}

inline void
FreePublicStringIfNecessary (
    OUT LPWSTR PublicString,
    IN BOOL CopyStrings
    )
/*++

Routine Description:

    Deletes the string if necessary

Arguments:
    PublicString - the string to delete. Must be on the
        process heap
    CopyStrings - the value of the CopyStrings parameter
        when RpcErrorGetNextRecord was called. If non-zero
        the string will be freed. Otherwise, the function
        is a no-op

Return Value:

    void

--*/
{
    if (CopyStrings)
        {
        if (PublicString)
            {
            RtlFreeHeap(RtlProcessHeap(), 0, PublicString);
            }
        }
}

void
FreeEEInfoPrivateParam (
    IN ExtendedErrorParam *Param
    )
{
    if ((Param->Type == eeptiAnsiString)
        || (Param->Type == eeptiUnicodeString))
        {
        // AnsiString & UnicodeString occupy the same
        // memory location - ok to free any of them
        MIDL_user_free(Param->AnsiString.pString);
        }
    else if (Param->Type == eeptiBinary)
        {
        MIDL_user_free(Param->Blob.pBlob);
        }
}

void
FreeEEInfoPublicParam (
    IN OUT RPC_EE_INFO_PARAM *Param,
    IN BOOL CopyStrings
    )
/*++

Routine Description:

    If the type of parameter is string (ansi or unicode)
        and CopyStrings, free the string

Arguments:
    Param - the parameter to free
    CopyStrings - the value of the CopyStrings parameter
        when RpcErrorGetNextRecord was called. If non-zero
        the string will be freed. Otherwise, the function
        is a no-op

Return Value:

    void

--*/
{
    if ((Param->ParameterType == eeptAnsiString)
        || (Param->ParameterType == eeptUnicodeString))
        {
        if (CopyStrings)
            {
            RtlFreeHeap(RtlProcessHeap(), 0, Param->u.AnsiString);
            }
        }
    else if (Param->ParameterType == eeptBinary)
        {
        if (CopyStrings)
            {
            RtlFreeHeap(RtlProcessHeap(), 0, Param->u.BVal.Buffer);
            }
        }
}

RPC_STATUS 
ConvertPublicParamToPrivateParam (
    IN RPC_EE_INFO_PARAM *PublicParam,
    OUT ExtendedErrorParam *PrivateParam
    )
/*++

Routine Description:

    Takes a parameter in format RPC_EE_INFO_PARAM and
    converts it to ExtendedErrorParam.

Arguments:
    PublicParam - the parameter to copy.
    PrivateParam - the parameter to copy to

Return Value:

    RPC_S_OK, RPC_S_INTERNAL_ERROR, RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    PrivateParam->Type = (ExtendedErrorParamTypesInternal)PublicParam->ParameterType;
    switch (PrivateParam->Type)
        {
        case eeptiAnsiString:
            RpcStatus = ConvertPublicStringToPrivateString(PublicParam->u.AnsiString,
                 &PrivateParam->AnsiString);
            break;

        case eeptiUnicodeString:
            RpcStatus = ConvertPublicStringToPrivateString(PublicParam->u.UnicodeString,
                &PrivateParam->UnicodeString);
            break;

        case eeptiLongVal:
            PrivateParam->LVal = PublicParam->u.LVal;
            break;

        case eeptiShortVal:
            PrivateParam->IVal = PublicParam->u.SVal;
            break;

        case eeptiPointerVal:
            PrivateParam->PVal = (ULONGLONG)PublicParam->u.PVal;
            break;

        case eeptiNone:
            break;

        case eeptiBinary:
            RpcStatus = ConvertPublicBlobToPrivateBlob(&PublicParam->u.BVal,
                &PrivateParam->Blob);
            break;

        default:
            ASSERT(FALSE);
            RpcStatus = ERROR_INVALID_PARAMETER;
        }
    return RpcStatus;
}

RPC_STATUS 
ConvertPrivateParamToPublicParam (
    IN ExtendedErrorParam *PrivateParam,
    IN BOOL CopyStrings,
    OUT RPC_EE_INFO_PARAM *PublicParam
    )
/*++

Routine Description:

    Takes a parameter in format ExtendedErrorParam and
    converts it to RPC_EE_INFO_PARAM.

Arguments:
    PrivateParam - the parameter to copy
    CopyStrings - if non-zero, this function will allocate
        space for any strings to be copied on the process
        heap and will copy the strings. If FALSE, it
        will alias the output pointers to RPC internal
        data structures
    PublicParam - the parameter to copy to

Return Value:

    RPC_S_OK, RPC_S_INTERNAL_ERROR, RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    PublicParam->ParameterType = (ExtendedErrorParamTypes)PrivateParam->Type;
    switch (PublicParam->ParameterType)
        {
        case eeptAnsiString:
            RpcStatus = ConvertPrivateStringToPublicString(&PrivateParam->AnsiString,
                CopyStrings,
                &PublicParam->u.AnsiString);
            break;

        case eeptUnicodeString:
            RpcStatus = ConvertPrivateStringToPublicString(&PrivateParam->UnicodeString,
                CopyStrings,
                &PublicParam->u.UnicodeString);
            break;

        case eeptLongVal:
            PublicParam->u.LVal = PrivateParam->LVal;
            break;

        case eeptShortVal:
            PublicParam->u.SVal = PrivateParam->IVal;
            break;

        case eeptPointerVal:
            PublicParam->u.PVal = PrivateParam->PVal;
            break;

        case eeptNone:
            break;

        case eeptBinary:
            RpcStatus = ConvertPrivateBlobToPublicBlob(&PrivateParam->Blob,
                CopyStrings,
                &PublicParam->u.BVal);
            break;

        default:
            ASSERT(FALSE);
            RpcStatus = RPC_S_INTERNAL_ERROR;
        }
    return RpcStatus;    
}

void
InitializePrivateEEInfo (
    IN ExtendedErrorInfo *ErrorInfo
    )
/*++

Routine Description:

    Initializes the common data members of the ExtendedErrorInfo
    structure.

Arguments:
    ErrorInfo - the structure to initialize

Return Value:

    void

--*/
{
    ErrorInfo->Next = NULL;
    ErrorInfo->ComputerName.Type = eecnpNotPresent;
    ErrorInfo->ProcessID = GetCurrentProcessId();
    GetSystemTimeAsFileTime((FILETIME *)&ErrorInfo->TimeStamp);
    ErrorInfo->Flags = 0;
}

RPC_STATUS 
ConvertPublicEEInfoToPrivateEEInfo (
    IN RPC_EXTENDED_ERROR_INFO *PublicEEInfo,
    IN short DetectionLocation,
    OUT ExtendedErrorInfo *PrivateEEInfo
    )
/*++

Routine Description:

    Takes a RPC_EXTENDED_ERROR_INFO record and converts
    it to an ExtendedErrorInfo record.

Arguments:
    PublicEEInfo - the public record to convert
    DetectionLocation - the detection location to use in the
        private record.
    PrivateEEInfo - the private record to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    int NumberOfParams;
    int i;
    RPC_STATUS RpcStatus = RPC_S_OK;

    ASSERT(PrivateEEInfo != NULL);
    ASSERT(PrivateEEInfo->nLen == PublicEEInfo->NumberOfParameters);

    if (PublicEEInfo->Version != RPC_EEINFO_VERSION)
        return RPC_S_INVALID_LEVEL;

    InitializePrivateEEInfo(PrivateEEInfo);
    // EEInfoGCCOM can come externally. If it's not, set it to
    // EEInfoGCApplication
    if (PublicEEInfo->GeneratingComponent != EEInfoGCCOM)
        {
        PrivateEEInfo->GeneratingComponent = EEInfoGCApplication;
        }
    else
        {
        PrivateEEInfo->GeneratingComponent = EEInfoGCCOM;
        }
    PrivateEEInfo->Status = PublicEEInfo->Status;
    PrivateEEInfo->DetectionLocation = DetectionLocation;
    // the next line should have been executed by the allocating code
    //PrivateEEInfo->nLen = PublicEEInfo->NumberOfParameters;
    NumberOfParams = PrivateEEInfo->nLen;

    for (i = 0; i < NumberOfParams; i ++)
        {
        if ((PublicEEInfo->Parameters[i].ParameterType < eeptAnsiString)
            || (PublicEEInfo->Parameters[i].ParameterType > eeptBinary))
            RpcStatus = ERROR_INVALID_PARAMETER;

        if (RpcStatus == RPC_S_OK)
            {
            RpcStatus = ConvertPublicParamToPrivateParam(&PublicEEInfo->Parameters[i],
                &PrivateEEInfo->Params[i]);
            }

        if (RpcStatus != RPC_S_OK)
            {
            // go backward and free all memory
            i --;
            for (; i >= 0; i --)
                {
                FreeEEInfoPrivateParam(&PrivateEEInfo->Params[i]);
                }
            break;
            }
        }

    return RpcStatus;
}

RPC_STATUS 
ConvertPrivateEEInfoToPublicEEInfo (
    IN ExtendedErrorInfo *PrivateEEInfo,
    IN BOOL CopyStrings,
    OUT RPC_EXTENDED_ERROR_INFO *PublicEEInfo
    )
/*++

Routine Description:

    Takes an ExtendedErrorInfo record and converts
    it to a RPC_EXTENDED_ERROR_INFO  record.

Arguments:
    PrivateEEInfo - the private record to convert
    CopyStrings - If non-zero, all strings will be allocated
        space on the process heap and will be copied. Otherwise
        they will be aliased to the privated data structure 
        strings
    PublicEEInfo - the public record to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    BOOL Result;
    int NumberOfParams;
    int i;
    RPC_STATUS RpcStatus;

    ASSERT (PublicEEInfo != NULL);

    if (PublicEEInfo->Version != RPC_EEINFO_VERSION)
        return RPC_S_INVALID_LEVEL;

    if (PublicEEInfo->NumberOfParameters < PrivateEEInfo->nLen)
        return RPC_S_BUFFER_TOO_SMALL;

    if (PublicEEInfo->Flags & (~EEInfoValidInputFlags))
        return RPC_S_INVALID_LEVEL;

    if (PrivateEEInfo->ComputerName.Type == eecnpNotPresent)
        {
        PublicEEInfo->ComputerName = NULL;
        }
    else
        {
        RpcStatus = ConvertPrivateStringToPublicString(&PrivateEEInfo->ComputerName.Name,
            CopyStrings, &PublicEEInfo->ComputerName);
        if (RpcStatus != RPC_S_OK)
            return RpcStatus;
        }
    PublicEEInfo->ProcessID = PrivateEEInfo->ProcessID;
    if (PublicEEInfo->Flags & EEInfoUseFileTime)
        {
        RpcpMemoryCopy(&PublicEEInfo->u.FileTime, &PrivateEEInfo->TimeStamp, sizeof(FILETIME));
        }
    else
        {
        Result = FileTimeToSystemTime((FILETIME *)&PrivateEEInfo->TimeStamp,
            &PublicEEInfo->u.SystemTime);
        if (Result == 0)
            return GetLastError();
        }
    PublicEEInfo->GeneratingComponent = PrivateEEInfo->GeneratingComponent;
    PublicEEInfo->Status = PrivateEEInfo->Status;
    PublicEEInfo->DetectionLocation = PrivateEEInfo->DetectionLocation;
    PublicEEInfo->Flags = PrivateEEInfo->Flags;
    // restore the consistency of the flags, if necessary
    if (PrivateEEInfo->Next)
        {
        // if there is next record, and its flags indicate that
        // a previous record is missing
        if (PrivateEEInfo->Next->Flags & EEInfoPreviousRecordsMissing)
            PublicEEInfo->Flags |= EEInfoNextRecordsMissing;
        }
    NumberOfParams = PrivateEEInfo->nLen;
    PublicEEInfo->NumberOfParameters = NumberOfParams;

    for (i = 0; i < NumberOfParams; i ++)
        {
        // convert the params
        RpcStatus = ConvertPrivateParamToPublicParam(&PrivateEEInfo->Params[i],
            CopyStrings, &PublicEEInfo->Parameters[i]);
        if (RpcStatus != RPC_S_OK)
            {
            // go back, and free eveyrthing
            FreePublicStringIfNecessary(PublicEEInfo->ComputerName, CopyStrings);
            i --;
            for ( ; i >= 0; i --)
                {
                FreeEEInfoPublicParam(&PublicEEInfo->Parameters[i], CopyStrings);
                }
            return RpcStatus;
            }
        }

    return RPC_S_OK;
}

void
FreeEEInfoRecord (
    IN ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Frees a single ExtendedErrorInfo record and
    all strings within it.

Arguments:
    EEInfo - record to free

Return Value:

    void

--*/
{
    int i;
    THREAD *Thread;

    for (i = 0; i < EEInfo->nLen; i ++)
        {
        FreeEEInfoPrivateParam(&EEInfo->Params[i]);
        }

    if (EEInfo->ComputerName.Type == eecnpPresent)
        {
        MIDL_user_free(EEInfo->ComputerName.Name.pString);
        }

    Thread = RpcpGetThreadPointer();

    if (Thread)
        {
        Thread->SetCachedEEInfoBlock(EEInfo, EEInfo->nLen);
        }
    else
        {
        FreeEEInfoRecordShallow(EEInfo);
        }
}

void
FreeEEInfoChain (
    IN ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Frees a chain of ExtendedErrorInfo records and
        all strings within them.

Arguments:
    EEInfo - head of list to free

Return Value:

    void

--*/
{
    ExtendedErrorInfo *CurrentInfo, *NextInfo;

    CurrentInfo = EEInfo;
    while (CurrentInfo != NULL)
        {
        // get the next link while we can
        NextInfo = CurrentInfo->Next;
        FreeEEInfoRecord(CurrentInfo);
        CurrentInfo = NextInfo;
        }
}

RPC_STATUS
CloneEEInfoParam (
    IN ExtendedErrorParam *SourceParam,
    OUT ExtendedErrorParam *DestParam
    )
/*++

Routine Description:

    Makes an exact deep copy of an ExtendedErrorParam structure

Arguments:
    SourceParam - the parameter to copy from
    DestParam - the parameter to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;

    ASSERT (DestParam != NULL);

    switch (SourceParam->Type)
        {
        case eeptiAnsiString:
            RpcStatus = DuplicatePrivateString(&SourceParam->AnsiString,
                &DestParam->AnsiString);
            break;

        case eeptiUnicodeString:
            RpcStatus = DuplicatePrivateString(&SourceParam->UnicodeString,
                &DestParam->UnicodeString);
            break;

        case eeptiLongVal:
            DestParam->LVal = SourceParam->LVal;
            break;

        case eeptiShortVal:
            DestParam->IVal = SourceParam->IVal;
            break;

        case eeptiPointerVal:
            DestParam->PVal = SourceParam->PVal;
            break;

        case eeptiNone:
            break;

        case eeptiBinary:
            RpcStatus = DuplicatePrivateBlob(&SourceParam->Blob,
                &DestParam->Blob);
            break;

        default:
            ASSERT(0);
            RpcStatus = RPC_S_INTERNAL_ERROR;
        }

    DestParam->Type = SourceParam->Type;

    return RpcStatus;
}

RPC_STATUS
CloneEEInfoRecord (
    IN ExtendedErrorInfo *SourceInfo,
    OUT ExtendedErrorInfo **DestInfo
    )
/*++

Routine Description:

    Makes an exact deep copy of a single ExtendedErrorInfo record

Arguments:
    SourceInfo - the record to copy from
    DestInfo - the record to copy to

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *NewInfo;
    int NumberOfParams;
    int i;
    RPC_STATUS RpcStatus;
    EEUString *ComputerNameToFree = NULL;

    *DestInfo = NULL;
    NumberOfParams = SourceInfo->nLen;
    NewInfo = AllocateExtendedErrorInfoRecord(NumberOfParams);
    if (NewInfo == NULL)
        return RPC_S_OUT_OF_MEMORY;

    // shallow copy all the fields. This is good for most fields
    // we will process the ones that need deep copy further down.
    // we copy everything, but the first param, which may require
    // deep copying
    RpcpMemoryCopy(NewInfo, SourceInfo, sizeof(ExtendedErrorInfo) - sizeof(ExtendedErrorParam));
    // N.B. Zero out the next field before any failure paths
    NewInfo->Next = NULL;
    if (SourceInfo->ComputerName.Type == eecnpPresent)
        {
        RpcStatus = DuplicatePrivateString(&SourceInfo->ComputerName.Name,
            &NewInfo->ComputerName.Name);
        if (RpcStatus != RPC_S_OK)
            {
            FreeEEInfoRecordShallow(NewInfo);
            return RpcStatus;
            }

        ComputerNameToFree = &NewInfo->ComputerName.Name;
        }

    for (i = 0; i < NumberOfParams; i ++)
        {
        RpcStatus = CloneEEInfoParam(&SourceInfo->Params[i],
            &NewInfo->Params[i]);
        if (RpcStatus != RPC_S_OK)
            {
            if (ComputerNameToFree)
                MIDL_user_free(ComputerNameToFree->pString);
            i --;
            for ( ; i >= 0; i --)
                {
                FreeEEInfoPrivateParam(&NewInfo->Params[i]);
                }
            FreeEEInfoRecordShallow(NewInfo);

            return RpcStatus;
            }
        }

    *DestInfo = NewInfo;
    return RPC_S_OK;
}

RPC_STATUS
CloneEEInfoChain (
    IN ExtendedErrorInfo *SourceEEInfo,
    OUT ExtendedErrorInfo **DestEEInfo
    )
/*++

Routine Description:

    Makes an exact deep copy of an ExtendedErrorInfo chain

Arguments:
    SourceEEInfo - the head of the chain to copy from
    DestEEInfo - a pointer to the head of the cloned chain.
        The memory for the head of the cloned chain will be
        allocated by this function and the given pointer
        will be set to point to it.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *CurrentInfo, *NewInfo, *NewInfoHead = NULL;
    ExtendedErrorInfo *LastNewInfo = NULL;
    RPC_STATUS RpcStatus;

    CurrentInfo = SourceEEInfo;
    while (CurrentInfo != NULL)
        {
        RpcStatus = CloneEEInfoRecord(CurrentInfo, &NewInfo);
        if (RpcStatus != RPC_S_OK)
            {
            if (NewInfoHead != NULL)
                FreeEEInfoChain(NewInfoHead);
            return RpcStatus;
            }
        if (NewInfoHead == NULL)
            NewInfoHead = NewInfo;

        if (LastNewInfo != NULL)
            LastNewInfo->Next = NewInfo;

        // advance both chains
        LastNewInfo = NewInfo;
        CurrentInfo = CurrentInfo->Next;
        }

    *DestEEInfo = NewInfoHead;
    return RPC_S_OK;
}

const ULONG EnumSignatureLive = 0xfcfcfcfc;
const ULONG EnumSignatureDead = 0xfdfdfdfd;

void
InitializeEnumHandleWithEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Initializes the common fields of a RPC_ERROR_ENUM_HANDLE
    structure

Arguments:
    EEInfo - the chain we're enumerating from
    EnumHandle - the structure to initialize

Return Value:

    void

--*/
{
    ASSERT(EEInfo != NULL);
    EnumHandle->Signature = EnumSignatureLive;
    EnumHandle->Head = EEInfo;
    EnumHandle->CurrentPos = EEInfo;
}

RPC_STATUS 
RpcpErrorStartEnumerationFromEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Starts an eeinfo enumeration using the passed
        EEInfo structure to start the enumeration

Arguments:
    EEInfo - the chain we will enumerate
    EnumHandle - the enumeration handle

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *ClonedEEInfo;
    RPC_STATUS RpcStatus;
    
    RpcStatus = CloneEEInfoChain(EEInfo, &ClonedEEInfo);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    InitializeEnumHandleWithEEInfo(ClonedEEInfo, EnumHandle);

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorStartEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Starts an eeinfo enumeration using the eeinfo on 
    the thread

Arguments:
    EnumHandle - the enumeration handle. Allocated by caller

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *ClonedEEInfo, *EEInfo;
    RPC_STATUS RpcStatus;
    THREAD *Thread;
    
    // get the EEInfo from the Teb
    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return RPC_S_ENTRY_NOT_FOUND;

    EEInfo = Thread->GetEEInfo();

    if (EEInfo == NULL)
        return RPC_S_ENTRY_NOT_FOUND;

    return RpcpErrorStartEnumerationFromEEInfo(EEInfo, EnumHandle);
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNextRecord (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    IN BOOL CopyStrings, 
    OUT RPC_EXTENDED_ERROR_INFO *ErrorInfo
    )
/*++

Routine Description:

    Retrieves the next private record from the enumeration
    and converts it to public format

Arguments:
    EnumHandle - the enumeration handle
    CopyStrings - if non-zero, all strings converted to public
        format will be allocated space for on the process heap
        and will be copied there. If FALSE, the strings in the
        public structures will be aliases to the private structure
    ErrorInfo - the public record that will be filled on output

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    ExtendedErrorInfo *CurrentRecord;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    if (EnumHandle->CurrentPos == NULL)
        return RPC_S_ENTRY_NOT_FOUND;

    CurrentRecord = (ExtendedErrorInfo *) EnumHandle->CurrentPos;
    RpcStatus = ConvertPrivateEEInfoToPublicEEInfo(CurrentRecord,
        CopyStrings, ErrorInfo);

    if (RpcStatus == RPC_S_OK)
        {
        EnumHandle->CurrentPos = CurrentRecord->Next;
        }

    return RpcStatus;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorEndEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Finished the enumeration and frees all resources associated with
    the enumeration

Arguments:
    EnumHandle - the enumeration handle

Return Value:

    RPC_S_OK or RPC_S_* error - can fail only if given invalid parameters

--*/
{
    ExtendedErrorInfo *EEInfoChain;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    EEInfoChain = (ExtendedErrorInfo *)EnumHandle->Head;
    FreeEEInfoChain(EEInfoChain);
    EnumHandle->Head = NULL;
    EnumHandle->Signature = EnumSignatureDead;

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorResetEnumeration (
    IN OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Reset the enumeration so that the next call to
        RpcErrorGetNextRecord returns the first record
        again.

Arguments:
    EnumHandle - the enumeration handle

Return Value:

    RPC_S_OK or RPC_S_* error - can fail only if given invalid
        parameters

--*/
{
    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    EnumHandle->CurrentPos = EnumHandle->Head;

    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorGetNumberOfRecords (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    OUT int *Records
    )
/*++

Routine Description:

    Gets the number of records in the chain that it currently
    enumerated

Arguments:
    EnumHandle - the enumeration handle
    Records - on output will contain the number of records

Return Value:

    RPC_S_OK or RPC_S_* error - the function cannot fail unless
        given invalid parameters

--*/
{
    ExtendedErrorInfo *CurrentRecord;
    int Count;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    CurrentRecord = (ExtendedErrorInfo *) EnumHandle->Head;
    Count = 0;
    while (CurrentRecord != NULL)
        {
        Count ++;
        CurrentRecord = CurrentRecord->Next;
        }

    *Records = Count;
    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorSaveErrorInfo (
    IN RPC_ERROR_ENUM_HANDLE *EnumHandle, 
    OUT PVOID *ErrorBlob, 
    OUT size_t *BlobSize
    )
/*++

Routine Description:

    Saves the eeinfo in the enumeration to a memory block

Arguments:
    EnumHandle - the enumeration handle
    ErrorBlob - on output the allocated and filled in blob
        containing the eeinfo in binary format
    BlobSize - on output the size of the blob

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ULONG EncodedSize;
    ExtendedErrorInfo *EEInfo;
    handle_t PickleHandle;
    char *TempBuffer;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;
    size_t MarshallSize;
    HANDLE ProcessHeap;
    PVOID Buffer;

    ASSERT(EnumHandle != NULL);
    ASSERT(EnumHandle->Head != NULL);
    ASSERT(EnumHandle->Signature != EnumSignatureDead);

    if (EnumHandle->Signature != EnumSignatureLive)
        return ERROR_INVALID_PARAMETER;

    // pickle the eeinfo into a buffer
    RpcStatus = MesEncodeDynBufferHandleCreate(&TempBuffer, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfo = (ExtendedErrorInfo *) EnumHandle->Head;
    EEInfoPtr = &EEInfo;

    // get the estimated size
    MarshallSize = ExtendedErrorInfoPtr_AlignSize(PickleHandle, EEInfoPtr);

    ProcessHeap = RtlProcessHeap();

    Buffer = RtlAllocateHeap(ProcessHeap, 0, MarshallSize);
    if (Buffer == NULL)
        {
        MesHandleFree(PickleHandle);
        return RPC_S_OUT_OF_MEMORY;
        }
    TempBuffer = (char *)Buffer;

    // re-initialize the handle to fixed buffer
    RpcStatus = MesBufferHandleReset(PickleHandle, 
        MES_FIXED_BUFFER_HANDLE, 
        MES_ENCODE, 
        &TempBuffer, 
        MarshallSize, 
        &EncodedSize);

    if (RpcStatus != RPC_S_OK)
        {
        MesHandleFree(PickleHandle);
        RtlFreeHeap(ProcessHeap, 0, Buffer);
        return RpcStatus;
        }

    // do the pickling itself
    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    if (RpcStatus != RPC_S_OK)
        {
        MesHandleFree(PickleHandle);
        RtlFreeHeap(ProcessHeap, 0, Buffer);
        return RpcStatus;
        }

    // whack out the rest, to prevent random process data going out on the wire/disk
    RpcpMemorySet((unsigned char *)Buffer + EncodedSize, 0, MarshallSize - EncodedSize);

    MesHandleFree(PickleHandle);
    
    *ErrorBlob = Buffer;
    *BlobSize = EncodedSize;
    return RPC_S_OK;
}

RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorLoadErrorInfo (
    IN PVOID ErrorBlob, 
    IN size_t BlobSize, 
    OUT RPC_ERROR_ENUM_HANDLE *EnumHandle
    )
/*++

Routine Description:

    Creates an enumeration from a blob

Arguments:
    ErrorBlob - the blob as obtained by RpcErrorSaveErrorInfo
    BlobSize - the size of the blob as obtained by RpcErrorSaveErrorInfo
    EnumHandle - the enumeration handle allocated by the caller
        and filled on output

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    ExtendedErrorInfo *EEInfo;

    RpcStatus = UnpickleEEInfo((unsigned char *)ErrorBlob, BlobSize, &EEInfo);
    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    InitializeEnumHandleWithEEInfo(EEInfo, EnumHandle);

    return RPC_S_OK;
}

RPC_STATUS
AddPrivateRecord (
    IN ExtendedErrorInfo *ErrorInfo
    )
/*++

Routine Description:

    Adds the supplied record to the top of the chain in the teb

    N.B. There can be no additional failure paths in the callers
    after this function. This is because it will chain this
    record to the teb, and if we bail out later, the teb will
    point to invalid record.

Arguments:
    ErrorInfo - the eeinfo record to add to the chain

Return Value:

    RPC_S_OK or RPC_S_* error - the function cannot fail if the
        RPC per-thread object has already been allocated for this
        thread

--*/
{
    THREAD *Thread;

    Thread = ThreadSelf();
    if (Thread == NULL)
        return RPC_S_OUT_OF_MEMORY;

    ErrorInfo->Next = Thread->GetEEInfo();
    Thread->SetEEInfo(ErrorInfo);

    return RPC_S_OK;
}

inline LPWSTR
ReplaceWithEmptyStringIfNull (
    IN LPWSTR String
    )
{
    return (String ? String : L"");
}

inline LPSTR
ReplaceWithEmptyStringIfNull (
    IN LPSTR String
    )
{
    return (String ? String : "");
}

void
RpcpErrorAddRecord (
    ULONG GeneratingComponent,
    ULONG Status,
    USHORT DetectionLocation,
    int NumberOfParameters,
    ExtendedErrorParam *Params
    )
/*++

Routine Description:

    Adds an extended error info to the thread. The
    following is a description of how fields are set:
    Next - will be set to the next record.
    ComputerName - will be set to not-present (eecnpNotPresent)
    ProcessID - will be set to the process ID
    TimeStamp - will be set to the current time
    GeneratingComponent - set to GeneratingComponent
    Status - set to Status
    DetectionLocation - set to DetectionLocation
    Flags - set to 0.
    nLen - set to NumberOfParameters
    Params will be copied to the parameters array. The caller can
        allocate them off the stack if it wants.

    N.B. The runtime should never directly call this function. If it
    needs to add records, it should call one of the overloaded 
    RpcpErrorAddRecord functions below. If there isn't one suitable,
    add one. All the RpcpErrorAddRecord functions below are just
    syntactic sugar for this function.

Arguments:
    GeneratingComponent - will be set in the record
    Status - will be set in the record
    DetectionLocation - will be set in the record
    NumberOfParameters - the number of parameters in the Params array
    Params - the parameters to add

Return Value:

    void - this is a best effort - no guarantees. Even if we
    return failure, there's little the caller can do about it.

--*/
{
    ExtendedErrorInfo *NewRecord;
    RPC_STATUS RpcStatus;
    int i;

    LogEvent(SU_EEINFO, 
        (char)GeneratingComponent, 
        ULongToPtr(Status), 
        ULongToPtr(DetectionLocation), 
        (NumberOfParameters > 0) ? Params[0].LVal : 0);

    NewRecord = AllocateExtendedErrorInfoRecord(NumberOfParameters);
    if (NewRecord == NULL)
        return;

    InitializePrivateEEInfo(NewRecord);
    NewRecord->DetectionLocation = DetectionLocation;
    NewRecord->GeneratingComponent = GeneratingComponent;
    NewRecord->Status = Status;
    
    for (i = 0; i < NumberOfParameters; i ++)
        {
        // all parameter types requiring an allocation have already
        // been copied by our caller - no need to clone - we can just
        // do shallow copy
        RpcpMemoryCopy(&NewRecord->Params[i], &Params[i], sizeof(ExtendedErrorParam));
        }

    RpcStatus = AddPrivateRecord(NewRecord);
    if (RpcStatus != RPC_S_OK)
        {
        FreeEEInfoRecord(NewRecord);
        }
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN short Short,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiShortVal;
    Params[1].IVal = Short;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN short Short,
    IN ULONG Long2,
    IN ULONG Long3
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiShortVal;
    Params[1].IVal = Short;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long2;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long3;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String1,
    IN LPWSTR String2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];
    RPC_STATUS RpcStatus;
    int i;
    LPWSTR Strings[2];

    Strings[0] = ReplaceWithEmptyStringIfNull(String1);
    Strings[1] = ReplaceWithEmptyStringIfNull(String2);
    for (i = 0; i < 2; i ++)
        {
        RpcStatus = ConvertPublicStringToPrivateString(Strings[i],
            &Params[i].UnicodeString);
        if (RpcStatus == RPC_S_OK)
            {
            Params[i].Type = eeptiUnicodeString;
            }
        else
            {
            Params[i].Type = eeptiNone;
            }
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);

}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String1,
    IN LPWSTR String2,
    IN ULONG Long1,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];
    RPC_STATUS RpcStatus;
    int i;
    LPWSTR Strings[2];

    Strings[0] = ReplaceWithEmptyStringIfNull(String1);
    Strings[1] = ReplaceWithEmptyStringIfNull(String2);
    for (i = 0; i < 2; i ++)
        {
        RpcStatus = ConvertPublicStringToPrivateString(Strings[i],
            &Params[i].UnicodeString);
        if (RpcStatus == RPC_S_OK)
            {
            Params[i].Type = eeptiUnicodeString;
            }
        else
            {
            Params[i].Type = eeptiNone;
            }
        }

    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long1;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);

}


void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String1,
    IN LPWSTR String2,
    IN ULONG Long1,
    IN ULONGLONG PVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];
    RPC_STATUS RpcStatus;
    int i;
    LPWSTR Strings[2];

    Strings[0] = ReplaceWithEmptyStringIfNull(String1);
    Strings[1] = ReplaceWithEmptyStringIfNull(String2);
    for (i = 0; i < 2; i ++)
        {
        RpcStatus = ConvertPublicStringToPrivateString(Strings[i],
            &Params[i].UnicodeString);
        if (RpcStatus == RPC_S_OK)
            {
            Params[i].Type = eeptiUnicodeString;
            }
        else
            {
            Params[i].Type = eeptiNone;
            }
        }

    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long1;
    Params[3].Type = eeptiPointerVal;
    Params[3].PVal = (long)PVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);

}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long1,
    IN ULONG Long2,
    IN LPWSTR String,
    IN ULONG Long3
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];
    RPC_STATUS RpcStatus;

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long1;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long2;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long3;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[2].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[2].Type = eeptiUnicodeString;
        }
    else
        {
        Params[2].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String,
    IN ULONG Long
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];
    RPC_STATUS RpcStatus;

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[1].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[1].Type = eeptiUnicodeString;
        }
    else
        {
        Params[1].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String,
    IN ULONG Long1,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];
    RPC_STATUS RpcStatus;

    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long1;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long2;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[0].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[0].Type = eeptiUnicodeString;
        }
    else
        {
        Params[0].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPWSTR String
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[1];
    RPC_STATUS RpcStatus;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[0].UnicodeString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[0].Type = eeptiUnicodeString;
        }
    else
        {
        Params[0].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        1,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN LPSTR String
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[1];
    RPC_STATUS RpcStatus;

    RpcStatus = ConvertPublicStringToPrivateString(
        ReplaceWithEmptyStringIfNull(String),
        &Params[0].AnsiString);
    if (RpcStatus == RPC_S_OK)
        {
        Params[0].Type = eeptiAnsiString;
        }
    else
        {
        Params[0].Type = eeptiNone;
        }

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        1,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONG Long2,
    IN ULONG Long3
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)Long2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long3;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2,
    IN ULONG Long
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2,
    IN ULONG Long1,
    IN ULONG Long2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)Long1;
    Params[3].Type = eeptiLongVal;
    Params[3].LVal = (long)Long2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        4,
        Params);
}


void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONGLONG PVal1,
    IN ULONG LVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiPointerVal;
    Params[0].PVal = PVal1;
    Params[1].Type = eeptiLongVal;
    Params[1].PVal = LVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONGLONG PVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[2];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = Long;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        2,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long,
    IN ULONGLONG PVal1,
    IN ULONGLONG PVal2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal1;
    Params[2].Type = eeptiPointerVal;
    Params[2].PVal = PVal2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG Long
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[1];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)Long;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        1,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG LVal1,
    IN ULONGLONG PVal1,
    IN ULONG LVal2
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[3];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)LVal1;
    Params[1].Type = eeptiPointerVal;
    Params[1].PVal = PVal1;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)LVal2;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}

void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG LVal1,
    IN ULONG LVal2,
    IN ULONG LVal3,
    IN ULONGLONG PVal1
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)LVal1;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)LVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)LVal3;
    Params[3].Type = eeptiPointerVal;
    Params[3].PVal = PVal1;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}


void
RpcpErrorAddRecord (
    IN ULONG GeneratingComponent,
    IN ULONG Status,
    IN USHORT DetectionLocation,
    IN ULONG LVal1,
    IN ULONG LVal2,
    IN ULONG LVal3,
    IN ULONG LVal4
    )
/*++

    See description of RpcpErrorAddRecord(ULONG, ULONG, 
        USHORT, int, ExtendedErrorParam*) above

--*/
{
    ExtendedErrorParam Params[4];

    Params[0].Type = eeptiLongVal;
    Params[0].LVal = (long)LVal1;
    Params[1].Type = eeptiLongVal;
    Params[1].LVal = (long)LVal2;
    Params[2].Type = eeptiLongVal;
    Params[2].LVal = (long)LVal3;
    Params[3].Type = eeptiLongVal;
    Params[3].PVal = LVal4;

    RpcpErrorAddRecord (GeneratingComponent,
        Status,
        DetectionLocation,
        3,
        Params);
}


RPCRTAPI
RPC_STATUS 
RPC_ENTRY
RpcErrorAddRecord (
    IN RPC_EXTENDED_ERROR_INFO *ErrorInfo
    )
/*++

Routine Description:

    Adds the supplied record to the top of the chain in the teb

Arguments:
    ErrorInfo - the eeinfo record to add to the chain

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *NewRecord;
    RPC_STATUS RpcStatus;

    if (ErrorInfo->Version != RPC_EEINFO_VERSION)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->ComputerName != NULL)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->Flags != 0)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->NumberOfParameters < 0)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->NumberOfParameters > MaxNumberOfEEInfoParams)
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->DetectionLocation != 0)
        return ERROR_INVALID_PARAMETER;

    // EEInfoGCCOM can come externally. If it's not EEInfoGCCOM, it must be 0
    if ((ErrorInfo->GeneratingComponent != 0) && (ErrorInfo->GeneratingComponent != EEInfoGCCOM))
        return ERROR_INVALID_PARAMETER;

    if (ErrorInfo->ProcessID != 0)
        return ERROR_INVALID_PARAMETER;

    NewRecord = AllocateExtendedErrorInfoRecord(ErrorInfo->NumberOfParameters);
    if (NewRecord == NULL)
        return RPC_S_OUT_OF_MEMORY;

    RpcStatus = ConvertPublicEEInfoToPrivateEEInfo(ErrorInfo, EEInfoDLApi, NewRecord);
    if (RpcStatus != RPC_S_OK)
        {
        FreeEEInfoRecordShallow(NewRecord);
        return RpcStatus;
        }

    RpcStatus = AddPrivateRecord(NewRecord);
    if (RpcStatus != RPC_S_OK)
        {
        FreeEEInfoRecord(NewRecord);
        }

    return RpcStatus;
}

RPCRTAPI
void 
RPC_ENTRY
RpcErrorClearInformation (
    void
    )
/*++

Routine Description:

    Clears the existing eeinfo on the teb (if any)

Arguments:
    void

Return Value:

    void

--*/
{
    ExtendedErrorInfo *EEInfo;
    THREAD *Thread;

    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return;

    EEInfo = Thread->GetEEInfo();
    Thread->SetEEInfo(NULL);
    FreeEEInfoChain(EEInfo);
}

BOOL
KnockOffLastButOneEEInfoRecord (
    IN ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Will delete the last-but-one record from the chain. If there
    are two or less record, nothing is deleted, and FALSE gets
    returned.

Arguments:
    EEInfo - the extended error info chain

Return Value:
    TRUE - a record was deleted
    FALSE - there were two or less records, and nothing was deleted.

--*/
{
    ExtendedErrorInfo *NextRecord, *LastButOneRecord;
    ExtendedErrorInfo *PreviousRecord;

    LastButOneRecord = NextRecord = EEInfo;
    while ((NextRecord != NULL) && (NextRecord->Next != NULL))
        {
        PreviousRecord = LastButOneRecord;
        LastButOneRecord = NextRecord;
        NextRecord = NextRecord->Next;
        }

    if ((NextRecord == EEInfo) || (LastButOneRecord == EEInfo))
        {
        return FALSE;
        }

    PreviousRecord->Next = NextRecord;
    // indicate that the chain has been broken
    PreviousRecord->Flags |= EEInfoNextRecordsMissing;
    NextRecord->Flags |= EEInfoPreviousRecordsMissing;
    // move the computer name up if necessary
    if ((LastButOneRecord->ComputerName.Type == eecnpPresent)
        && (NextRecord->ComputerName.Type == eecnpNotPresent))
        {
        // N.B. Not covered by unit tests
        LastButOneRecord->ComputerName.Type = eecnpNotPresent;
        NextRecord->ComputerName.Type = eecnpPresent;
        NextRecord->ComputerName.Name.nLength = LastButOneRecord->ComputerName.Name.nLength;
        NextRecord->ComputerName.Name.pString = LastButOneRecord->ComputerName.Name.pString;
        }
    FreeEEInfoRecord(LastButOneRecord);
    return TRUE;
}

RPC_STATUS
TrimEEInfoToLengthByRemovingRecords (
    IN ExtendedErrorInfo *EEInfo,
    IN size_t MaxLength,
    OUT BOOL *fTrimmedEnough,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    This function removes records, until either two records are
    left, or the pickled length drops below MaxLength. If the
    pickled length is below the MaxLength to start with, no
    records should be dropped. The records are dropped starting
    from the last-but-one, and going backwards (towards the
    current record). The previous and next records should
    have their chain broken flags set, and the computer name
    should be moved up the chain, if the last record has
    no computer name.

Arguments:
    EEInfo - the EE chain
    MaxLength - the length that we need to trim to.
    fTrimmedEnough - will be set to TRUE if the pickled length
        on return from this function fits in MaxLength. Undefined
        if the return value is not RPC_S_OK
    NeededLength - if fTrimmedEnough was set to TRUE, and the
        return value is RPC_S_OK, the current pickled length.
        Otherwise, this value must not be touched (i.e. use
        a local variable until you're sure that both conditions
        are true).

Return Value:
    RPC_S_OK on success.
    != RPC_S_OK on error. On error, fTrimmedEnough is undefined, and
        NeededLength is not touched.

--*/
{
    ULONG EncodedSize;
    handle_t PickleHandle = NULL;
    char *TempBuffer;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;
    PVOID Buffer = NULL;
    size_t CurrentlyNeededLength;
    size_t PickleLength;
    size_t BufferLength;
    BOOL Result;

    RpcStatus = MesEncodeDynBufferHandleCreate(&TempBuffer, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    // our first goal is to drive the pickled length to less than 2 times
    // the MaxLength. Since the actual pickling often takes less than the
    // estimated, we will do the fine tuning by actually pickling and measuring
    // the resulting size. For the rough tuning, we will use the estimate, and
    // knock off it, if we are over the estimate
    CurrentlyNeededLength = MaxLength * 2;
    while (TRUE)
        {
        EEInfoPtr = &EEInfo;

        // get the estimated size
        PickleLength = ExtendedErrorInfoPtr_AlignSize(PickleHandle, EEInfoPtr);
        if (PickleLength <= CurrentlyNeededLength)
            {
            break;
            }

        // knock off the last-but-one element
        Result = KnockOffLastButOneEEInfoRecord(EEInfo);
        if (Result == FALSE)
            {
            *fTrimmedEnough = FALSE;
            goto SuccessCleanupAndExit;
            }
        }

    // here, the PickleHandle should be valid, and ready for actual pickling
    // do the fine-tuned trimming - actually pickle, and see whether it fits
    Buffer = MIDL_user_allocate(PickleLength);
    if (Buffer == NULL)
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    BufferLength = PickleLength;

    TempBuffer = (char *)Buffer;

    CurrentlyNeededLength = MaxLength;

    while (TRUE)
        {
        // re-initialize the handle to fixed buffer
        RpcStatus = MesBufferHandleReset(PickleHandle, 
            MES_FIXED_BUFFER_HANDLE, 
            MES_ENCODE, 
            &TempBuffer, 
            BufferLength, 
            &EncodedSize);

        if (RpcStatus != RPC_S_OK)
            {
            goto CleanupAndExit;
            }

        RpcTryExcept
            {
            ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            RpcStatus = RpcExceptionCode();
            }
        RpcEndExcept

        if (RpcStatus != RPC_S_OK)
            {
            goto CleanupAndExit;
            }

        if (EncodedSize <= CurrentlyNeededLength)
            {
            *fTrimmedEnough = TRUE;
            *NeededLength = EncodedSize;
            goto SuccessCleanupAndExit;
            }

        Result = KnockOffLastButOneEEInfoRecord(EEInfo);
        if (Result == FALSE)
            {
            *fTrimmedEnough = FALSE;
            goto SuccessCleanupAndExit;
            }
        }

SuccessCleanupAndExit:
    RpcStatus = RPC_S_OK;

CleanupAndExit:
    if (Buffer != NULL)
        {
        MIDL_user_free(Buffer);
        }

    if (PickleHandle != NULL)
        {
        MesHandleFree(PickleHandle);
        }
    return RpcStatus;
}

RPC_STATUS
GetLengthOfPickledEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    Calculate the length of the given eeinfo when pickled. It 
    does that by pickling it in a temporary buffer and 
    checking the resulting length.

Arguments:
    ErrorInfo - the eeinfo chain whose length we need to calculate
    NeededLength - the length in bytes

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ULONG EncodedSize;
    handle_t PickleHandle = NULL;
    char *TempBuffer;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;
    PVOID Buffer = NULL;
    size_t MarshallSize;

    RpcStatus = MesEncodeDynBufferHandleCreate(&TempBuffer, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfoPtr = &EEInfo;

    // get the estimated size
    MarshallSize = ExtendedErrorInfoPtr_AlignSize(PickleHandle, EEInfoPtr);
    Buffer = MIDL_user_allocate(MarshallSize);
    if (Buffer == NULL)
        {
        RpcStatus = RPC_S_OUT_OF_MEMORY;
        goto CleanupAndExit;
        }

    TempBuffer = (char *)Buffer;

    // re-initialize the handle to fixed buffer
    RpcStatus = MesBufferHandleReset(PickleHandle, 
        MES_FIXED_BUFFER_HANDLE, 
        MES_ENCODE, 
        &TempBuffer, 
        MarshallSize, 
        &EncodedSize);

    if (RpcStatus != RPC_S_OK)
        {
        goto CleanupAndExit;
        }

    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    if (RpcStatus != RPC_S_OK)
        {
        goto CleanupAndExit;
        }

    *NeededLength = EncodedSize;

CleanupAndExit:
    if (Buffer != NULL)
        {
        MIDL_user_free(Buffer);
        }

    if (PickleHandle != NULL)
        {
        MesHandleFree(PickleHandle);
        }
    return RpcStatus;
}

RPC_STATUS
TrimEEInfoToLengthByRemovingStrings (
    IN ExtendedErrorInfo *EEInfo,
    IN size_t MaxLength,
    OUT BOOL *fTrimmedEnough,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    Try to trim the eeinfo to the given length by whacking any
    strings in the eeinfo chain. After each string is whacked
    a re-measurement is made

Arguments:
    ErrorInfo - the eeinfo chain that we need to fit in MaxLength
        bytes.
    MaxLength - the length we need to trim to
    fTrimmedEnough - non-zero if we were able to trim the length below
        MaxLength.
    NeededLength - the length in bytes of the trimmed eeinfo. Not
        touched if fTrimmedEnough is FALSE.

    N.B. This function should only be called after 
    TrimEEInfoToLengthByRemovingRecords

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    ExtendedErrorInfo *CurrentRecord;
    size_t CurrentLength;
    int i;
    RPC_STATUS RpcStatus;
    BOOL TrimLongParam;
    void *ParameterToTrim;

    // we shouldn't be here if there are more than two records
    if (EEInfo->Next && EEInfo->Next->Next)
        {
        ASSERT(0);
        }

    CurrentRecord = EEInfo;
    while (CurrentRecord != NULL)
        {
        // trim the parameters and remeasure. If still nothing, move on to
        // the computer name.
        for (i = 0; i < EEInfo->nLen; i ++)
            {
            TrimLongParam = FALSE;
            if ((CurrentRecord->Params[i].Type == eeptiAnsiString) 
                || (CurrentRecord->Params[i].Type == eeptiUnicodeString))
                {
                TrimLongParam = TRUE;
                // both string pointers occupy the same memory location,
                // so it is ok to free either
                ParameterToTrim = CurrentRecord->Params[i].AnsiString.pString;
                }
            else if (CurrentRecord->Params[i].Type == eeptiBinary)
                {
                TrimLongParam = TRUE;
                ParameterToTrim = CurrentRecord->Params[i].Blob.pBlob;
                }

            if (TrimLongParam)
                {
                MIDL_user_free(CurrentRecord->Params[i].AnsiString.pString);
                CurrentRecord->Params[i].Type = eeptiNone;

                // remeasure
                RpcStatus = GetLengthOfPickledEEInfo(EEInfo, &CurrentLength);
                if (RpcStatus != RPC_S_OK)
                    return RpcStatus;

                if (CurrentLength <= MaxLength)
                    {
                    *NeededLength = CurrentLength;
                    *fTrimmedEnough = TRUE;
                    return RPC_S_OK;
                    }
                }
            }

        // if the computer name is there, try to trim it. If nothing,
        // move on to the next record
        if (CurrentRecord->ComputerName.Type == eecnpPresent)
            {
            // N.B. Not covered by unit tests
            MIDL_user_free(CurrentRecord->ComputerName.Name.pString);
            CurrentRecord->ComputerName.Type = eecnpNotPresent;

            RpcStatus = GetLengthOfPickledEEInfo(EEInfo, &CurrentLength);
            if (RpcStatus != RPC_S_OK)
                return RpcStatus;

            if (CurrentLength <= MaxLength)
                {
                // N.B. Not covered by unit tests
                *NeededLength = CurrentLength;
                *fTrimmedEnough = TRUE;
                return RPC_S_OK;
                }
            // N.B. Not covered by unit tests
            }

        CurrentRecord = CurrentRecord->Next;
        }

    // N.B. In the current implementation, the minimum fragment length
    // belongs to LRPC, and is 0xb8. At this length, two records
    // with strings stripped always fit. Therefore, we can never be
    // here. The code below is untested, and is left only for future
    // work where we have a transport supporting fragment length
    // which doesn't hold two records with strings stripped
    ASSERT(0);
    // if we are here, obviously we couldn't trim enough
    *fTrimmedEnough = FALSE;
    return RPC_S_OK;
}

void
TrimEEInfoToLength (
    IN size_t MaxLength,
    OUT size_t *NeededLength
    )
/*++

Routine Description:

    Some protocols don't allow transmitting arbitrary lengths
    of information. This function will attempt to trim the pickled
    length of the existing error information so as to fit MaxLength.
    First, it will try to knock off records, starting from the
    last-but-one, and going back. If this is not sufficient, it will
    whack any string arguments/computer names in the record. If this
    is also, not sufficient, it should drop the top record. This should
    leave the total length to be about 128 bytes. All protocols must
    be able to transmit that, as this routine cannot trim it any
    further.
    If MaxLength is larger than the current pickled length, no trimming
    is done, and the actual pickled length will be returned in
    NeededLength

Arguments:
    MaxLength - the maximum length for this chain.
    NeededLength - on success, how much we actually need to transfer
        the existing extended error info. This must be less than
        MaxLength. If the function cannot get estimation for some
        reason (probably out-of-memory), or there is no extended
        error information, it will return 0 in this parameter.

Return Value:
    void

--*/
{
    RPC_STATUS RpcStatus;
    BOOL fTrimmedEnough;
    ExtendedErrorInfo *EEInfo;
    THREAD *Thread;
    ExtendedErrorInfo *LastRecord;

    ASSERT(MaxLength >= MinimumTransportEEInfoLength);

    *NeededLength = 0;
    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return;

    EEInfo = Thread->GetEEInfo();
    if (EEInfo == NULL)
        return;

    RpcStatus = TrimEEInfoToLengthByRemovingRecords(EEInfo, MaxLength, &fTrimmedEnough, NeededLength);
    if (RpcStatus != RPC_S_OK)
        return;

    // if fTrimmedEnough is set, NeededLength should have been set
    if (fTrimmedEnough == TRUE)
        {
        ASSERT(*NeededLength <= MaxLength);
        return;
        }
    ASSERT(*NeededLength == 0);

    RpcStatus = TrimEEInfoToLengthByRemovingStrings(EEInfo, MaxLength, &fTrimmedEnough, NeededLength);
    if (RpcStatus != RPC_S_OK)
        return;

    // if fTrimmedEnough is set, NeededLength should have been set
    if (fTrimmedEnough == TRUE)
        {
        ASSERT(*NeededLength <= MaxLength);
        return;
        }

    // N.B. In the current implementation, the minimum fragment length
    // belongs to LRPC, and is 0xb8. At this length, two records
    // with strings stripped always fit. Therefore, we can never be
    // here. The code below is untested, and is left only for future
    // work where we have a transport supporting fragment length
    // which doesn't hold two records with strings stripped

    ASSERT(0);
    // again, we couldn't trim it enough
    // drop the first record

    // make sure there are exactly two records
    // this is so, because if we have only one record,
    // it should have fit by now. If we had more than two
    // records, there is a bug in the trimming records code
    ASSERT(EEInfo->Next);
    ASSERT(EEInfo->Next->Next == NULL);

    LastRecord = EEInfo->Next;
    FreeEEInfoRecord(EEInfo);
    EEInfo = LastRecord;
    Thread->SetEEInfo(LastRecord);

#if DBG
    RpcStatus = GetLengthOfPickledEEInfo(EEInfo, NeededLength);
    if (RpcStatus != RPC_S_OK)
        return;

    ASSERT(*NeededLength <= MaxLength);
#endif
}

size_t
EstimateSizeOfEEInfo (
    void
    )
/*++

Routine Description:

    Takes the EEInfo from the teb (if any) and calculates the size
    of the pickled eeinfo

Arguments:
    void

Return Value:

    the size or 0 if it fails

--*/
{
    ExtendedErrorInfo *EEInfo;
    THREAD *Thread;
    RPC_STATUS RpcStatus;
    size_t NeededLength;

    Thread = RpcpGetThreadPointer();
    if (Thread == NULL)
        return 0;

    EEInfo = Thread->GetEEInfo();
    if (EEInfo == NULL)
        return 0;

    RpcStatus = GetLengthOfPickledEEInfo(EEInfo, &NeededLength);
    if (RpcStatus != RPC_S_OK)
        return 0;

    return NeededLength;
}

RPC_STATUS
PickleEEInfo (
    IN ExtendedErrorInfo *EEInfo,
    IN OUT unsigned char *Buffer,
    IN size_t BufferSize
    )
/*++

Routine Description:

    This routine does the actual pickling in a user supplied buffer.
    The buffer must have been allocated large enough to hold all
    pickled data. Some of the other functions should have been
    used to get the size of the pickled data and the buffer
    should have been allocated appropriately

Arguments:
    Buffer - the actual Buffer to pickle into
    BufferSize - the size of the Buffer.

Return Value:
    RPC_S_OK if the pickling was successful.
    other RPC_S_* codes if it failed.

--*/
{
    ULONG EncodedSize;
    handle_t PickleHandle = NULL;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;

    ASSERT(((ULONG_PTR)Buffer & 0x7) == 0);
    RpcStatus = MesEncodeFixedBufferHandleCreate((char *)Buffer, BufferSize, &EncodedSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfoPtr = &EEInfo;

    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Encode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    ASSERT(EncodedSize <= BufferSize);

    MesHandleFree(PickleHandle);
    return RpcStatus;
}

RPC_STATUS
UnpickleEEInfo (
    IN OUT unsigned char *Buffer,
    IN size_t BufferSize,
    OUT ExtendedErrorInfo **NewEEInfo
   )
/*++

Routine Description:

    This routine does the actual pickling in a user supplied buffer.
    The buffer must have been allocated large enough to hold all
    pickled data. Some of the other functions should have been
    used to get the size of the pickled data and the buffer
    should have been allocated appropriately

Arguments:
    Buffer - the actual Buffer to pickle into
    BufferSize - the size of the Buffer.

Return Value:
    RPC_S_OK if the pickling was successful.
    other RPC_S_* codes if it failed.

--*/
{
    ExtendedErrorInfo *EEInfo;
    handle_t PickleHandle;
    RPC_STATUS RpcStatus;
    ExtendedErrorInfoPtr *EEInfoPtr;

    RpcStatus = MesDecodeBufferHandleCreate((char *)Buffer, BufferSize, &PickleHandle);
    if (RpcStatus != RPC_S_OK)
        {
        return RpcStatus;
        }

    EEInfoPtr = &EEInfo;
    EEInfo = NULL;
    RpcTryExcept
        {
        ExtendedErrorInfoPtr_Decode(PickleHandle, EEInfoPtr);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    MesHandleFree(PickleHandle);

    if (RpcStatus == RPC_S_OK)
        *NewEEInfo = EEInfo;

    return RpcStatus;
}

void
NukeStaleEEInfoIfNecessary (
    IN RPC_STATUS exception
    )
/*++

Routine Description:

    Matches the given error code to the error code in the
    first record of the eeinfo chain in the teb. If they match
    or if there is *no* Win32<->NT_STATUS correspondence b/n them
    the eeinfo in the teb is nuked

Arguments:
    exception - the error code to match against

Return Value:
    void

--*/
{
    THREAD *Thread;
    ExtendedErrorInfo *EEInfo;
    long ExceptionNtStatus;
    long EEInfoNtStatus;

    Thread = RpcpGetThreadPointer();
    if (Thread)
        {
        EEInfo = Thread->GetEEInfo();
        if (EEInfo && Thread->Context)
            {
            // there is extended info - try to match it to what we have
            ExceptionNtStatus = I_RpcMapWin32Status(exception);
            EEInfoNtStatus = I_RpcMapWin32Status(EEInfo->Status);
            if (EEInfoNtStatus != ExceptionNtStatus)
                {
                // they are not the same - nuke the stale info
                // to prevent confusion
                RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
                }
            }
        }
}

LPWSTR
AllocateAndGetComputerName (
    IN ComputerNameAllocators AllocatorToUse,
    IN COMPUTER_NAME_FORMAT NameToRetrieve,
    IN size_t ExtraBytes,
    IN int StartingOffset,
    OUT DWORD *Size
    )
/*++

Routine Description:

    Allocates space for the computer name and gets it

Arguments:
    Size - on output the size of the string, including
        the terminating NULL

Return Value:
    The computer name or NULL of out-of-memory

--*/
{
    DWORD LocalSize = 0;
    BOOL Result;
    LPWSTR Buffer = NULL;
    DWORD LastError;

    Result = GetComputerNameEx(NameToRetrieve, 
        Buffer, 
        &LocalSize);
    ASSERT(Result == 0);

    LastError = GetLastError();
    if (LastError == ERROR_MORE_DATA)
        {
        if (AllocatorToUse == cnaMidl)
            {
            Buffer = (LPWSTR)MIDL_user_allocate(LocalSize * sizeof(RPC_CHAR) + ExtraBytes);
            }
        else
            {
            ASSERT(AllocatorToUse == cnaNew);
            Buffer = (RPC_CHAR *)new char[LocalSize * sizeof(RPC_CHAR) + ExtraBytes];
            }
        if (Buffer)
            {
            Result = GetComputerNameEx(NameToRetrieve, 
                (RPC_CHAR *)((char *)Buffer + StartingOffset), 
                &LocalSize);
            if (Result == 0)
                {
                if (AllocatorToUse == cnaMidl)
                    {
                    MIDL_user_free(Buffer);
                    }
                else
                    {
                    delete Buffer;
                    }
                Buffer = NULL;
                }
            else
                {
                // sometimes GetComputerNameEx returns the size
                // without the terminating NULL regardless of what
                // the MSDN says. The base group (Earhart, NeillC)
                // know about it but won't change it for now.
                // Code it in such a way that it works regardless
                // of when and if they change it.
                *Size = wcslen((RPC_CHAR *)((char *)Buffer + StartingOffset)) + 1;
                }
            }
        }

    return Buffer;
}

void
AddComputerNameToChain (
    ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Checks the first record in eeinfo, and if it doesn't have
    a computer name to it, adds it.

Arguments:
    EEInfo - the eeinfo chain to add the computer name to

Return Value:
    void - best effort - no guarantees.

--*/
{
    LPWSTR Buffer;
    DWORD Size;

    if (EEInfo->ComputerName.Type == eecnpNotPresent)
        {
        Buffer = AllocateAndGetComputerName(cnaMidl,
            ComputerNamePhysicalDnsHostname,
            0,      // extra bytes
            0,      // starting offset
            &Size);
        if (Buffer)
            {
            EEInfo->ComputerName.Type = eecnpPresent;
            EEInfo->ComputerName.Name.nLength = (CSHORT)Size;
            EEInfo->ComputerName.Name.pString = Buffer;
            }
        }
}

void
StripComputerNameIfRedundant (
    ExtendedErrorInfo *EEInfo
    )
/*++

Routine Description:

    Checks the first record in eeinfo, and if it does have
    a computer name to it and it is the same as the computer
    name of this machine, remove it. This is done to keep
    the length of the chain short during local calls using
    remote protocols

Arguments:
    EEInfo - the eeinfo chain to remove the computer name from

Return Value:
    void

--*/
{
    LPWSTR Buffer = NULL;
    DWORD Size;

    if (EEInfo->ComputerName.Type == eecnpPresent)
        {
        Buffer = AllocateAndGetComputerName(cnaMidl,
            ComputerNamePhysicalDnsHostname,
            0,  // extra bytes
            0,      // starting offset
            &Size);
        if (Buffer)
            {
            if (Size != (DWORD)EEInfo->ComputerName.Name.nLength)
                goto CleanupAndExit;

            // The strings are Unicode - need to multiply by two
            if (RpcpMemoryCompare(Buffer, EEInfo->ComputerName.Name.pString, Size * 2) == 0)
                {
                MIDL_user_free(EEInfo->ComputerName.Name.pString);
                EEInfo->ComputerName.Type = eecnpNotPresent;
                }
            }
        }

CleanupAndExit:
    if (Buffer)
        {
        MIDL_user_free(Buffer);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\epmap.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epmap.h

Abstract:

    This file specifies the interface to the endpoint mapper Dll which
    provides endpoint mapping services to the RPC runtime.

Author:

    Michael Montague (mikemon) 06-Jan-1992

Revision History:

--*/

#ifndef __EPMAP_H__
#define __EPMAP_H__

START_C_EXTERN

typedef struct _ProtseqEndpointPair {
  char  PAPI * Protseq;
  char  PAPI * Endpoint;
} ProtseqEndpointPair;

RPC_STATUS RPC_ENTRY
EpResolveEndpoint (
    IN UUID PAPI * ObjectUuid, OPTIONAL
    IN RPC_SYNTAX_IDENTIFIER PAPI * IfId,
    IN RPC_SYNTAX_IDENTIFIER PAPI * XferId,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * NetworkOptions,
    IN OUT void PAPI * PAPI * EpLookupHandle,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo, OPTIONAL
    OUT RPC_CHAR * PAPI * Endpoint
    );

    
RPC_STATUS  RPC_ENTRY
EpGetEpmapperEndpoint(
    IN OUT RPC_CHAR  * PAPI * Endpoint,
    IN RPC_CHAR  PAPI * Protseq
    );

void RPC_ENTRY
EpFreeLookupHandle (
    IN void PAPI * EpLookupHandle
    );

RPC_STATUS RPC_ENTRY
BindToEpMapper(
    OUT RPC_BINDING_HANDLE PAPI * MapperHandle,
    IN RPC_CHAR * NWAddress OPTIONAL,
    IN RPC_CHAR * Protseq OPTIONAL,
    IN RPC_CHAR * Options OPTIONAL,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo OPTIONAL
    );

RPC_STATUS
InitializeEPMapperClient(
    void
    );

END_C_EXTERN

#endif // __EPMAP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\epclnt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epclnt.cxx

Abstract:

    This file contains the client runtime entry points into the
    endpoint mapper dll.

Author:

    Michael Montague (mikemon) 06-Jan-1992

Revision History:


--*/
#include <precomp.hxx>
#include <epmp.h>
#include <epmap.h>
#include <twrproto.h>
#include <CharConv.hxx>
#include <OsfPcket.hxx>
#include <BitSet.hxx>
#include <ProtBind.hxx>
#include <OsfClnt.hxx>

extern RPC_STATUS __RPC_FAR
MapFromNcaStatusCode (
    IN unsigned long NcaStatus
    );

static ProtseqEndpointPair EpMapperTable[] =

                                  {
                                     "ncacn_np", "\\pipe\\epmapper",
                                     "ncalrpc", "epmapper",
                                     "ncacn_ip_tcp", "135",
                                     "ncadg_ip_udp", "135",
#ifdef NETBIOS_ON
                                     "ncacn_nb_nb", "135",
                                     "ncacn_nb_tcp", "135",
                                     "ncacn_nb_ipx", "135",
#endif
#ifdef SPX_ON
                                     "ncacn_spx", "34280",
#endif
#ifdef IPX_ON
                                     "ncadg_ipx", "34280",
#endif
#ifdef APPLETALK_ON
                                     "ncacn_at_dsp", "Endpoint Mapper",
#endif
#ifdef NCADG_MQ_ON
                                     "ncadg_mq", "EpMapper",
#endif
                                     "ncacn_http", "593"
                                   };

unsigned long PartialRetries=0;
unsigned long ReallyTooBusy=0;

typedef struct _EP_LOOKUP_DATA
{
    unsigned int NumberOfEndpoints;
    unsigned int MaximumEndpoints;
    unsigned int CurrentEndpoint;
    RPC_CHAR *  PAPI *  Endpoints;
} EP_LOOKUP_DATA;




RPC_STATUS RPC_ENTRY
EpResolveEndpoint (
    IN UUID PAPI * ObjectUuid, OPTIONAL
    IN RPC_SYNTAX_IDENTIFIER PAPI * IfId,
    IN RPC_SYNTAX_IDENTIFIER PAPI * XferId,
    IN RPC_CHAR PAPI * RpcProtocolSequence,
    IN RPC_CHAR PAPI * NetworkAddress,
    IN RPC_CHAR PAPI * Options,
    IN OUT void PAPI * PAPI * EpLookupHandle,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo, OPTIONAL
    OUT RPC_CHAR * PAPI * Endpoint
    )
/*++

Routine Description:

    The runtime will call this routine to resolve an endpoint.

Arguments:

    ObjectUuid - Optional specifies the object uuid in the binding
        for which we are trying to resolve an endpoint.

    Ifid - Pointer to the Syntax Identifier for the Interface

    Xferid - Pointer to the Syntax Identifier for the Transfer Syntax.

    RpcProtocolSequence - Supplies the rpc protocol sequence contained
        in the binding.

    NetworkAddress - Supplies the network address.  This will be used
        to contact the endpoint mapper on that machine in order to
        resolve the endpoint.

    EpLookupHandle - Supplies the current version of the lookup handle
        for this iteration through the endpoint mapper.  A new value
        for the lookup handle will be returned.  If RPC_S_NO_ENDPOINT_FOUND
        is returned, this parameter will be set to its initial value,
        zero.

    ConnTimeout - the connection timeout

    CallTimeout - the call timeout

    AutInfo - any auth info that needs to be used during the resolution process

    Endpoint - Returns the endpoint resolved by the endpoint mapper on
        the machine specified by the network address argument.  The
        storage for the endpoint must have been allocated using the
        runtime API I_RpcAllocate.

Return Value:

    RPC_S_OK - The endpoint was successfully resolved.

    EP_S_NOT_REGISTERED  - There are no more endpoints to be found
        for the specified combination of interface, network address,
        and lookup handle.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to allow
        resolution of the endpoint.

    EP_S_CANT_PERFORM_OP - The operation failed due to misc. error e.g.
                           unable to bind to the EpMapper.

--*/
{
    RPC_BINDING_HANDLE MapperHandle;
    RPC_STATUS RpcStatus;
    twr_p_t InputTower = 0;
    twr_p_t OutputTower[4];
    unsigned long Returned;
    error_status ErrorStatus;
    ept_lookup_handle_t ContextHandle = 0;
    EP_LOOKUP_DATA PAPI * EpLookupData = (EP_LOOKUP_DATA PAPI *)
            *EpLookupHandle;
    unsigned long RetryCount, i;
    unsigned char PAPI * EPoint;

    CHeapAnsi AnsiNWAddr, AnsiOptions;
    CStackAnsi AnsiProtseq;
    CNlUnicode nlEndpoint;


    ASSERT(*Endpoint == 0);



    // We have already taken all of the endpoints from the endpoint mapper;
    // now we just return them back to the runtime one at a time.

ReturnEndpointFromList:

    if ( EpLookupData != 0 )
        {

        // When we reach the end of the list of endpoints, return an error,
        // and set things up so that we will start at the beginning again.

        if ( EpLookupData->CurrentEndpoint == EpLookupData->NumberOfEndpoints )
            {
            RpcpErrorAddRecord(EEInfoGCRuntime, 
                EPT_S_NOT_REGISTERED,
                EEInfoDLEpResolveEndpoint10,
                RpcProtocolSequence,
                NetworkAddress,
                IfId->SyntaxGUID.Data1,
                (ULONG)((EpLookupData->CurrentEndpoint << 16) | EpLookupData->NumberOfEndpoints));
            EpLookupData->CurrentEndpoint = 0;
            return(EPT_S_NOT_REGISTERED);
            }

        *Endpoint = DuplicateString(
                EpLookupData->Endpoints[EpLookupData->CurrentEndpoint]);
        EpLookupData->CurrentEndpoint += 1;

        if ( *Endpoint == 0 )
            {
            return(RPC_S_OUT_OF_MEMORY);
            }

        return(RPC_S_OK);
        }

    // Otherwise, we need to take the list of endpoints from the endpoint
    // mapper.

    EpLookupData = (EP_LOOKUP_DATA PAPI *) RpcpFarAllocate(
            sizeof(EP_LOOKUP_DATA));
    if ( EpLookupData == 0 )
        {
        return(RPC_S_OUT_OF_MEMORY);
        }
    EpLookupData->MaximumEndpoints = 64;
    EpLookupData->Endpoints = (RPC_CHAR * PAPI *) RpcpFarAllocate(
            sizeof(RPC_CHAR PAPI *) * EpLookupData->MaximumEndpoints);
    if ( EpLookupData->Endpoints == 0 )
        {
        RpcpFarFree(EpLookupData);
        EpLookupData = 0;
        return(RPC_S_OUT_OF_MEMORY);
        }
    EpLookupData->NumberOfEndpoints = 0;
    EpLookupData->CurrentEndpoint = 0;

    RpcStatus = AnsiNWAddr.Attach(NetworkAddress);
    if ( RpcStatus != RPC_S_OK )
        {
        ASSERT( RpcStatus == RPC_S_OUT_OF_MEMORY );
        RpcpFarFree(EpLookupData);
        EpLookupData = 0;
        return(RpcStatus);
        }

    i = 1+RpcpStringLength(RpcProtocolSequence);
    *(AnsiProtseq.GetPAnsiString()) = (char *)_alloca(i);
    RpcStatus = AnsiProtseq.Attach(RpcProtocolSequence, i, i * 2);
    if ( RpcStatus != RPC_S_OK )
        {
        ASSERT( RpcStatus == RPC_S_OUT_OF_MEMORY );
        RpcpFarFree(EpLookupData);
        EpLookupData = 0;
        return(RpcStatus);
        }

    RpcStatus = AnsiOptions.Attach(Options);
    if ( RpcStatus != RPC_S_OK )
        {
        ASSERT( RpcStatus == RPC_S_OUT_OF_MEMORY );
        RpcpFarFree(EpLookupData);
        EpLookupData = 0;
        return(RpcStatus);
        }

    RpcStatus = BindToEpMapper(&MapperHandle, 
        NetworkAddress, 
        RpcProtocolSequence, 
        Options, 
        ConnTimeout,
        CallTimeout,
        AuthInfo
        );

    if ( RpcStatus != RPC_S_OK )
        {
        MapperHandle = 0;
        goto CleanupAndReturn;
        }

    RpcStatus = TowerConstruct((RPC_IF_ID PAPI *) IfId,
            (RPC_TRANSFER_SYNTAX PAPI *) XferId, (char PAPI *) AnsiProtseq,
            NULL, (char PAPI *) AnsiNWAddr, &InputTower);
    if ( RpcStatus != RPC_S_OK )
        {
        goto CleanupAndReturn;
        }

    for (RetryCount = 0;;)
        {

        OutputTower[0] = 0;
        OutputTower[1] = 0;
        OutputTower[2] = 0;
        OutputTower[3] = 0;

        RpcTryExcept
            {
            ept_map(MapperHandle, ObjectUuid, InputTower, &ContextHandle, 4L,
                    &Returned, &OutputTower[0], &ErrorStatus);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            ErrorStatus = RpcExceptionCode();
            }
        RpcEndExcept

        if ( ErrorStatus == RPC_S_SERVER_TOO_BUSY)
           {
           if (RetryCount < 3)
              {
              RetryCount ++;
              PartialRetries++;
              continue;
              }
           else
              {
              ReallyTooBusy++;
              }

           }

        if ( ErrorStatus != 0 )
            {
            // For DCE interop the endpoint mapper returns DCE errors on the
            // wire.  We need to map some of them to the MS RPC ones.

            switch (ErrorStatus)
                {
                case EP_S_CANT_PERFORM_OP :
                    RpcStatus = EPT_S_CANT_PERFORM_OP;
                    break;

                case EP_S_NOT_REGISTERED :
                    RpcpErrorAddRecord(EEInfoGCRuntime, 
                        EPT_S_NOT_REGISTERED,
                        EEInfoDLEpResolveEndpoint20,
                        RpcProtocolSequence,
                        NetworkAddress,
                        IfId->SyntaxGUID.Data1,
                        (ULONGLONG)MapperHandle);
                    RpcStatus = EPT_S_NOT_REGISTERED;
                    break;

                default :
                    RpcStatus = MapFromNcaStatusCode(ErrorStatus);
                    break;
                }

            break;
            }

        ASSERT( ((Returned != 0) || (ContextHandle == 0)) && (Returned <= 4) );

        for (i = 0; i < Returned; i++)
            {
            if (OutputTower[i] == 0)
                {
                return RPC_S_OUT_OF_MEMORY ;
                }

            RpcStatus = TowerExplode(
                                 OutputTower[i],
                                 NULL,
                                 NULL,
                                 NULL,
                                 (char PAPI * PAPI *) &EPoint,
                                 NULL
                                 );

            if ( RpcStatus != RPC_S_OK )
                {
                break;
                }

            RpcStatus = nlEndpoint.Attach((char *)EPoint);
            *Endpoint = nlEndpoint;

            I_RpcFree(EPoint);

            if ( *Endpoint == 0 )
                {
                RpcStatus = RPC_S_OUT_OF_MEMORY;
                break;
                }

            EpLookupData->Endpoints[EpLookupData->NumberOfEndpoints] =
                                                                   *Endpoint;
            EpLookupData->NumberOfEndpoints += 1;
            if ( EpLookupData->NumberOfEndpoints ==
                                             EpLookupData->MaximumEndpoints )
                {
                goto OutsideTheLoop;
                }
            }//..for Loop over parse all towers/eps in this loop

        for (i = 0; i < Returned; i++)
            {
            MIDL_user_free(OutputTower[i]);
            }

        if ( (ContextHandle == 0)  || (RpcStatus != RPC_S_OK) )
            {
            break;
            }
        } //..for loop over get all endpoints

OutsideTheLoop:

    ASSERT( InputTower != 0 );
    I_RpcFree(InputTower);

CleanupAndReturn:

    if ( MapperHandle != 0 )
        {
        RPC_STATUS Status = RpcBindingFree(&MapperHandle);
        ASSERT( Status == RPC_S_OK );
        }

    if ( ContextHandle != 0 )
        {
        RpcSsDestroyClientContext(&ContextHandle);
        }

    if (   ( RpcStatus == EPT_S_NOT_REGISTERED )
        || ( RpcStatus == RPC_S_OK ) )
        {
        if ( EpLookupData->NumberOfEndpoints != 0 )
            {
            *EpLookupHandle = EpLookupData;
            goto ReturnEndpointFromList;
            }
        RpcStatus = EPT_S_NOT_REGISTERED;
        }

    if ( EpLookupData != 0 )
        {
        if ( EpLookupData->Endpoints != 0 )
            {
            while ( EpLookupData->NumberOfEndpoints > 0 )
                {
                EpLookupData->NumberOfEndpoints -= 1;
                delete EpLookupData->Endpoints[EpLookupData->NumberOfEndpoints];
                }
            RpcpFarFree(EpLookupData->Endpoints);
            }
        RpcpFarFree(EpLookupData);
        }

    return(RpcStatus);
}


RPC_STATUS RPC_ENTRY
EpGetEpmapperEndpoint(
    IN OUT RPC_CHAR * PAPI * Endpoint,
    IN RPC_CHAR     PAPI * Protseq
    )
/*+

Routine Description:

    Returns the Endpoint mappers well known endpoint for a given
    protocol sequence.

Arguments:

    Endpoint  - Place to store the epmappers well known endpoint.

    Protsq   - Protocol sequence the client wishes to use.

Return Value:

    RPC_S_OK  - Found the protocol sequence in the epmapper table and
                am returning the associated well known endpoint.

    EPT_S_CANT_PERFORM_OP - Protocol sequence not found.

--*/

{
    RPC_STATUS          Status = EPT_S_CANT_PERFORM_OP;
    RPC_STATUS          rc;
    unsigned            int i, Count;

    CStackAnsi          AnsiProtseq;
    CNlUnicode          nlEndpoint;

    unsigned char PAPI * Epoint;

    if (Protseq != NULL)
        {

#ifdef UNICODE
        //Must convert the protocol sequence into an ansi string from unicode
        i = 1 + RpcpStringLength(Protseq);
        *(AnsiProtseq.GetPAnsiString()) = (char *)_alloca(i);
        rc = AnsiProtseq.Attach(Protseq, i, i * 2);

        if ( rc != RPC_S_OK )
            {
            ASSERT( rc == RPC_S_OUT_OF_MEMORY );
            return(Status);
            }

#else

        AnsiProtseq = Protseq;

#endif


        Count = sizeof(EpMapperTable)/sizeof(EpMapperTable[0]);

        for (i = 0; i < Count; i++)
            {


            //Search for the protocol sequence client is using.


            if ( RpcpStringCompareA((char PAPI *)AnsiProtseq,
                               (char PAPI *)EpMapperTable[i].Protseq) )
                {

                //Not yet found.
                continue;

                }
            else
                {

                //Found a match. Grab the epmappers known endpoint.


                Epoint = (unsigned char __RPC_FAR *)(EpMapperTable[i].Endpoint);

                rc = nlEndpoint.Attach((char *)Epoint);
                *Endpoint = nlEndpoint;

                Status = RPC_S_OK;
                break;

                }
            } //for
        }//if

    return(Status);

}



RPC_STATUS  RPC_ENTRY
BindToEpMapper(
    OUT RPC_BINDING_HANDLE PAPI * MapperHandle,
    IN RPC_CHAR * NWAddress OPTIONAL,
    IN RPC_CHAR * Protseq OPTIONAL,
    IN RPC_CHAR * Options OPTIONAL,
    IN unsigned ConnTimeout,
    IN ULONG CallTimeout,
    IN CLIENT_AUTH_INFO *AuthInfo OPTIONAL
    )
/*+

Routine Description:

    This helper routine is used to by RpcEpRegister[NoReplace],
    RpcEpUnRegister and EpResolveEndpoint(epclnt.cxx) to bind to
    the EpMapper. If a Protseq is supplied, that particular protseq
    is tried, otherwise lrpc is used to connect to the local epmapper.
    If a NW Address is specified EpMapper at that host is contacted, else
    local Endpoint mapper is used.

Arguments:

    MapperHandle- Returns binding handle to the Endpoint mapper

    NWAddress - NW address of the Endpoint mapper to bind to.
                Ignored if protseq is NULL.

    Protseq   - Protocol sequence the client wishes to use.
                NULL indicates a call to the local endpoint mapper.

    ConnTimeout - the connection timeout

    CallTimeout - the call timeout

    AuthInfo - authentication information for the resolution

Return Value:

    RPC_S_OK - The ansi string was successfully converted into a unicode
        string.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available for the unicode
        string.

    EP_S_CANT_PERFORM_OP - The binding was unsuccessful, possibly because
                           the protocol sequence is not supported.

--*/
{
    RPC_STATUS Status = EPT_S_CANT_PERFORM_OP;
    RPC_CHAR * BindingString = NULL;
    unsigned int i, Count;
    BOOL fHttp = FALSE;

    Count = sizeof(EpMapperTable)/sizeof(EpMapperTable[0]);

    // If Protseq == NULL use lrpc.
    if (NULL == Protseq)
        {
        ASSERT(NWAddress == 0);
        BindingString = RPC_STRING_LITERAL("ncalrpc:[epmapper]");
        }
    else
        {
        char * AnsiProtseq;

        AnsiProtseq = (char *) _alloca(1+RpcpStringLength(Protseq));
        if (!AnsiProtseq)
            {
            return RPC_S_OUT_OF_MEMORY;
            }

        SimpleUnicodeToAnsi(Protseq, AnsiProtseq);

        if (Options)
            {
            fHttp = (0 == RpcpStringCompare(Protseq, RPC_STRING_LITERAL("ncacn_http")));
            }

        for (i = 0; i < Count; i++)
            {
            if (RpcpStringCompareA(AnsiProtseq,
                         (char PAPI *) EpMapperTable[i].Protseq) )
                continue;

            // Found it.

            RPC_CHAR * Endpoint;

            Endpoint = (RPC_CHAR *) _alloca(sizeof(RPC_CHAR) * (1+strlen(EpMapperTable[i].Endpoint)));
            if (!Endpoint)
                {
                return RPC_S_OUT_OF_MEMORY;
                }

            SimpleAnsiToPlatform(EpMapperTable[i].Endpoint, Endpoint);

            Status = RpcStringBindingCompose( NULL,
                                              Protseq,
                                              NWAddress,
                                              Endpoint,
                                              (fHttp ? Options : 0),
                                              &BindingString);
            break;
            }
        }

    if (BindingString)
       {
       Status = RpcBindingFromStringBinding(BindingString, MapperHandle);
       }

    if (BindingString != NULL && Protseq != NULL)
       {
       RpcStringFree(&BindingString);
       }

    if (Status != RPC_S_OK)
       {
       return(EPT_S_CANT_PERFORM_OP);
       }

    if (AuthInfo && (RpcpStringNCompare(Protseq, RPC_STRING_LITERAL("ncacn_"), 6) == 0))
        {
        Status = SetAuthInformation (*MapperHandle, AuthInfo);

        if (Status != RPC_S_OK)
            return Status;
        }

    Status = RpcMgmtSetComTimeout(*MapperHandle, ConnTimeout);

    if (Status != RPC_S_OK)
       {
       return(EPT_S_CANT_PERFORM_OP);
       }

    return(RPC_S_OK);
}

void RPC_ENTRY
EpFreeLookupHandle (
    IN void PAPI * EpLookupHandle
    )
{
    EP_LOOKUP_DATA PAPI * EpLookupData = (EP_LOOKUP_DATA PAPI *) EpLookupHandle;

    if ( EpLookupData->Endpoints != 0 )
        {
        while ( EpLookupData->NumberOfEndpoints > 0 )
            {
            EpLookupData->NumberOfEndpoints -= 1;
            delete EpLookupData->Endpoints[EpLookupData->NumberOfEndpoints];
            }
        RpcpFarFree(EpLookupData->Endpoints);
        }
    RpcpFarFree(EpLookupData);
}

HPROCESS hRpcssContext = 0;

RPC_STATUS RPC_ENTRY
I_RpcServerAllocateIpPort(
    IN DWORD Flags,
    OUT USHORT *pPort
    )
{
    USHORT Port;
    RPC_STATUS status;
    RPC_BINDING_HANDLE hServer;
    PORT_TYPE type;

    *pPort = 0;

    // Figure out what sort of port to allocate

    if (Flags & RPC_C_USE_INTERNET_PORT)
        {
        type = PORT_INTERNET;
        Flags &= ~RPC_C_USE_INTERNET_PORT;
        }
    else if (Flags & RPC_C_USE_INTRANET_PORT)
        {
        type = PORT_INTRANET;
        Flags &= ~RPC_C_USE_INTRANET_PORT;
        }
    else
        {
        type = PORT_DEFAULT;
        }

    // Setup process context in the endpoint mapper if needed.

    if (hRpcssContext == 0)
        {
        HPROCESS hProcess;

        status = RpcBindingFromStringBinding(RPC_STRING_LITERAL("ncalrpc:[epmapper]"),
                                              &hServer);
        if (status != RPC_S_OK)
            {
            return(status);
            }

        hProcess = 0;

        status = OpenEndpointMapper(hServer,
                                    &hProcess);

        RPC_STATUS statust =
        RpcBindingFree(&hServer);
        ASSERT(statust == RPC_S_OK);

        if (status != RPC_S_OK)
            {
            return(status);
            }

        GlobalMutexRequest();

        if (hRpcssContext != 0)
            {
            ASSERT(hRpcssContext != hProcess);
            RpcSmDestroyClientContext(&hProcess);
            }
        else
            {
            hRpcssContext = hProcess;
            }

        GlobalMutexClear();
        }

    // Actually allocate a port.

    RPC_STATUS allocstatus;

    status = AllocateReservedIPPort(hRpcssContext,
                                    type,
                                    &allocstatus,
                                    pPort);

    if (status != RPC_S_OK)
        {
        ASSERT(*pPort == 0);
        return(status);
        }

    return(allocstatus);
}

// Very special code for our older (NT 3.1 Era) servers.
//
// These server send out unique pointers which will confuse our
// stubs while unmarshalling.  Here we go through and fixup the
// node id's to look like full pointers.
//
// This code can be removed when support for NT 3.1 era servers
// is no longer required.

extern "C"
void FixupForUniquePointerServers(PRPC_MESSAGE pMessage)
{
    int CurrentPointer = 3;
    unsigned int NumberOfPointers;
    unsigned int i;
    unsigned long __RPC_FAR *pBuffer;

    pBuffer = (unsigned long __RPC_FAR *) pMessage->Buffer;

    // The output buffer looks like:

    // [ out-context handle (20b) ]
    // [ count (4b) ]
    // [ max (4b) ]
    // [ min (4b) ]
    // [ length (4b) ]      // should be the same as count
    // [ pointer node (count of them) ]

    ASSERT(pBuffer[5] == pBuffer[8]);

    NumberOfPointers = pBuffer[5];

    ASSERT(pMessage->BufferLength >= 4 * 9 + 4 * NumberOfPointers);

    for(i = 0; i < NumberOfPointers; i++)
        {
        if (pBuffer[9 + i] != 0)
            {
            pBuffer[9 + i] = CurrentPointer;
            CurrentPointer++;
            }
        }

    return;
}

#if defined(WIN) || defined(WIN32)

void __RPC_FAR * __RPC_API
MIDL_user_allocate(
       size_t  Size
      )
/*++

Routine Description:

    MIDL generated stubs need this routine.

Arguments:

    Size - Supplies the length of the memory to allocate in bytes.

Return Value:

    The buffer allocated will be returned, if there is sufficient memory,
    otherwise, zero will be returned.

--*/
{
    void PAPI * pvBuf;

    pvBuf = I_RpcAllocate(Size);

    return(pvBuf);
}

void __RPC_API
MIDL_user_free (
         void __RPC_FAR *Buf
         )
{

    I_RpcFree(Buf);

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\epmapper.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    epmapper.cxx

Abstract:

    This routine implements the server side DCE runtime APIs.  The
    routines in this file are used by server applications only.

Author:

    Bharat Shah (barats) 3-5-92

Revision History:

    06-03-96    gopalp      Added code to cleanup stale EP Mapper entries.

--*/

#include <precomp.hxx>
#include <rpcobj.hxx>
#include <epmap.h>
#include <epmp.h>
#include <twrproto.h>
#include <startsvc.h>
#include <hndlsvr.hxx>
#include <CharConv.hxx>


//
// Global EP cleanup context handle. Initially NULL, this will
// be allocated by Endpoint Mapper. As of now, it points to the
// EP entries registered by this process. This way, the Endpoint
// Mapper can cleanup entries of this process as soon as process
// goes away.
//

void * hEpContext = NULL;
MUTEX *EpContextMutex = NULL;


RPC_STATUS
InitializeEPMapperClient(
    void
    )
{
    RPC_STATUS Status = RPC_S_OK;

    EpContextMutex = new MUTEX(&Status,
                               TRUE     // pre-allocate semaphore
                               );

    if (EpContextMutex == NULL)
        {
        return RPC_S_OUT_OF_MEMORY;
        }

    if (Status != RPC_S_OK)
        {
        delete EpContextMutex;
        EpContextMutex = NULL;
        }

    return Status;
}

inline void RequestEPClientMutex(void)
{
    EpContextMutex->Request();
}

inline void ClearEPClientMutex(void)
{
    EpContextMutex->Clear();
}


RPC_STATUS
BindingAndIfToTower(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_HANDLE BindingHandle,
    OUT twr_t PAPI * PAPI * Tower
)
/*+

Routine Description:
    Helper routine that returns a Tower from the Interface Spec
    and a bindinh handle

Arguments:

    IfSpec - Client or Server IfSpec structure.

    BindingHandle - A partially bound binding handle

    Tower - Returns a Tower if the Binding Handle had a
        dynamic endpoint, else Tower=NULL. The caller needs
        to free this memory.

Return Value:

    RPC_S_OK - The ansi string was successfully converted into a unicode
        string.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available for the unicode
        string.

    EP_S_CANT_PERFORM_OP - The Binding Handle or IfSpec were in valid.

--*/
{
    RPC_STATUS err          = 0;
    unsigned char *Protseq  = 0;
    unsigned char *NWAddress= 0;
    unsigned char *Binding  = 0;
    unsigned char *Endpoint = 0;
    RPC_CHAR * String       = 0;
    RPC_IF_ID Ifid;
    RPC_TRANSFER_SYNTAX Xferid;
    unsigned int Size;

    *Tower = NULL;
    err = RpcIfInqId(IfSpec, &Ifid);
    if (!err)
        {
        err = I_RpcIfInqTransferSyntaxes(
                    IfSpec,
                    &Xferid,
                    sizeof(Xferid),
                    &Size
                    );
        }

    if (!err)
        {
        err = I_RpcBindingInqDynamicEndpoint(BindingHandle, &String);
        }

    if (err)
        {
        return (err);
        }


    if (!err)
        {
        err = RpcBindingToStringBindingA(BindingHandle, &Binding);
        }

    if (!err)
        {
        if (String != 0)
            {
            // It is a dynamic endpoint
            Endpoint = UnicodeToAnsiString(String, &err);
            if (!err)
                {
                err = RpcStringBindingParseA(
                            Binding,
                            NULL,
                            &Protseq,
                            &NWAddress,
                            NULL,
                            NULL
                            );
                }
            }
        else
            {
            err = RpcStringBindingParseA(
                        Binding,
                        NULL,
                        &Protseq,
                        &NWAddress,
                        &Endpoint,
                        NULL
                        );
            }
        }

    if (!err)
        {
        err = TowerConstruct(
                    &Ifid,
                    &Xferid,
                    (char PAPI*)Protseq,
                    (char PAPI *)Endpoint,
                    (char PAPI *)NWAddress,
                    Tower
                    );
        }

    if (Endpoint)
        RpcStringFreeA(&Endpoint);

    if (String)
        RpcStringFreeA((unsigned char PAPI * PAPI *)&String);

    if (Protseq)
        RpcStringFreeA(&Protseq);

    if (NWAddress)
        RpcStringFreeA(&NWAddress);

    if (Binding)
        RpcStringFreeA(&Binding);

    return(err);
}




RPC_STATUS
RegisterEntries(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * ObjUuidVector,
    IN unsigned char * Annotation,
    IN unsigned long ReplaceNoReplace
    )
/*++


Routine Description:

    This helper function is called by RpcEpRegister or RpcEpRegisterNoReplace
    Depending on the TypeOp, it tries to Add or replace endpoint entries
    in the EP-database.

Arguments:

    IfSpec - Interface Spec Handle for which the entries are to be registered.

    BindingVector - A Vector of Binding Handles which need to be registered

    ObjUUIDVector - A Vector of Objects

    Annotation - A String representing the Annotation

    TypeOp - A Flag : REGISTER_REPLACE or REGISTER_NO_REPLACE

Return Value:

    RPC_S_OK - Some of the entries specified were successfully registered.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available,

    EP_S_CANT_PERFORM_OP - Misc. local error occured; e.g. could not bind to
        the EpMapper.

--*/
{
    RPC_STATUS err;
    unsigned int i, j, k, Entries, CountBH, CountObj;
    RPC_BINDING_HANDLE EpMapperHandle;
    unsigned char * PStringBinding = NULL;
    twr_p_t Twr;
    ept_entry_t * EpEntries = NULL, *p;
    unsigned long ArgC = 0;
    char *ArgV[1] = { NULL };

    if (BindingVector->Count == 0)
        {
        //
        // PNP
        //
        err = GlobalRpcServer->InterfaceExported(
                                                 (PRPC_SERVER_INTERFACE) IfSpec,
                                                 ObjUuidVector,
                                                 Annotation,
                                                 ReplaceNoReplace);
        return RPC_S_OK;
        }

    if (err = BindToEpMapper(&EpMapperHandle,
        NULL,       // NetworkAddress
        NULL,       // Protseq
        0,          // Options
        RPC_C_BINDING_DEFAULT_TIMEOUT,
        INFINITE,    // CallTimeout
        NULL        // AuthInfo
        ))
        {
        return err;
        }

    CountObj =  (unsigned int)ObjUuidVector->Count;
    CountBH = (unsigned int) BindingVector->Count;

    if ((p = (EpEntries =  (ept_entry_t *)
        I_RpcAllocate(CountBH * sizeof(ept_entry_t)))) == NULL)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    for (i = 0, Entries = 0;  (!err) && (i < CountBH); i++)
        {
        if (BindingVector->BindingH[i] == 0)
            {
            continue;
            }

        if (err = BindingAndIfToTower(IfSpec, BindingVector->BindingH[i], &Twr))
            {
            err = 0;
            continue;
            }

        if (Twr == NULL)
            {
            continue;
            }

        Entries ++;
        p->tower = Twr;
        lstrcpyA((char PAPI *)p->annotation, (char PAPI *)Annotation);
        p++;
        }

    for (j = 0; j < CountObj; j++)
        {
        for (k = 0, p = EpEntries; k < Entries; k++, p++)
            {
            RpcpMemoryCopy(
                (char PAPI *)&p->object,
                (char PAPI *)ObjUuidVector->Uuid[j],
                sizeof(UUID)
                );
            }

        RequestEPClientMutex();
        RpcTryExcept
            {
            ept_insert_ex(
                EpMapperHandle,
                &hEpContext,
                Entries,
                EpEntries,
                ReplaceNoReplace,
                (error_status PAPI *)&err
                );
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            err = RpcExceptionCode();
            }
        RpcEndExcept
        ClearEPClientMutex();

        if (err == RPC_S_SERVER_UNAVAILABLE)
            {
            //
            //Try to start the epmapper and retry
            //

            err = StartServiceIfNecessary();

            if (err == RPC_S_OK)
                {
                RequestEPClientMutex();
                RpcTryExcept
                    {
                    ept_insert_ex(
                        EpMapperHandle,
                        &hEpContext,
                        Entries,
                        EpEntries,
                        ReplaceNoReplace,
                        (error_status PAPI *)&err
                        );
                    }
                RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
                    {
                    RpcpErrorAddRecord(EEInfoGCRuntime,
                        EPT_S_CANT_CREATE,
                        EEInfoDLRegisterEntries10,
                        RpcExceptionCode());
                    err = EPT_S_CANT_CREATE;
                    }
                RpcEndExcept
                ClearEPClientMutex();
                }
            }

        if (err != RPC_S_OK)
            {
            RpcpErrorAddRecord(EEInfoGCRuntime,
                EPT_S_CANT_CREATE,
                EEInfoDLRegisterEntries20,
                err);
            err = EPT_S_CANT_CREATE;
            break;
            }

         // Subsequent Inserts should be (ALWAYS) NOREPLACE
         // ReplaceNoReplace = REGISTER_NOREPLACE;

        }  // for loop over UUID Vectors


    for (i = 0, p = EpEntries; i < Entries; i++,p++)
        I_RpcFree(p->tower);

    if (EpEntries)
        {
        I_RpcFree(EpEntries);
        }

    RpcBindingFree(&EpMapperHandle);

    if (err == RPC_S_OK)
        {
        //
        // We successfully registered our bindings,
        // reflect that in the interface so that if we get a
        // PNP notification, we can update the bindings
        //
        err = GlobalRpcServer->InterfaceExported(
                                                 (PRPC_SERVER_INTERFACE) IfSpec,
                                                 ObjUuidVector,
                                                 Annotation,
                                                 ReplaceNoReplace);
        }

    return(err);
}




RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register
    a series of end points with the local endpoint mapper.

Arguments:


Return Value:


--*/
{
    UUID_VECTOR UuidVectorNull;
    UUID_VECTOR PAPI *PObjUuidVector = &UuidVectorNull;
    UUID NilUuid;
    unsigned char AnnotStr[] = {'\0'};
    THREAD *Thread;

    if (!ARGUMENT_PRESENT(Annotation))
        Annotation = AnnotStr;

    if (strlen((char PAPI *)Annotation) >= ep_max_annotation_size)
        return(EPT_S_INVALID_ENTRY);

    if (!ARGUMENT_PRESENT( BindingVector))
        {
        return(RPC_S_NO_BINDINGS);
        }

    if (ARGUMENT_PRESENT( UuidVector ))
        {
        PObjUuidVector = UuidVector;
        }
    else
        {
        UuidVectorNull.Count = 1;
        RpcpMemorySet(&NilUuid, 0, sizeof(UUID));
        UuidVectorNull.Uuid[0] = &NilUuid;
        }

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(RegisterEntries(
            IfSpec,
            BindingVector,
            PObjUuidVector,
            Annotation,
            EP_REGISTER_NOREPLACE
            ));
}





RPC_STATUS RPC_ENTRY
RpcEpRegisterNoReplaceW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned short * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register [Add]
    a series of end points with the local endpoint mapper
    This is the Unicode version of the API.

Arguments:

    IfSpec  - Server side Interface specification structure generated
        by MIDL, that describes Interface UUId and version

   Binding Vector - A vector of binding handles that the server has registered
        with the runtime.

   UuidVector- A vector of Uuids of objects that the server is supporting

   Annotation - Annotation String

Return Value:


--*/
{
        CHeapAnsi AnsiString;
        USES_CONVERSION;
    RPC_STATUS err;

    if (ARGUMENT_PRESENT(Annotation))
        {
        ATTEMPT_HEAP_W2A(AnsiString, Annotation);
        }

    err = RpcEpRegisterNoReplaceA(
                IfSpec,
                BindingVector,
                UuidVector,
                AnsiString
                );

    return(err);
}





RPC_STATUS RPC_ENTRY
RpcEpRegisterA (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector OPTIONAL,
    IN unsigned char * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register
    a series of end points with the local endpoint mapper, replacing
    existing database entries in the process.

    This is the Ansi version of the API.

Arguments:

    IfSpec  - Server side Interface specification structure generated
        by MIDL, that describes Interface UUId and version

    Binding Vector- A vector of binding handles that the server has registered
        with the runtime.

    UuidVector- A vector of Uuids of objects that the server is supporting

    Annotation - Annotation String

Return Value:


--*/
{
    UUID_VECTOR UuidVectorNull;
    UUID_VECTOR PAPI *PObjUuidVector = &UuidVectorNull;
    UUID NilUuid;
    unsigned char AnnotStr[] = {'\0'};
    THREAD *Thread;

    if (!ARGUMENT_PRESENT(Annotation))
        Annotation = AnnotStr;

    if (strlen((char PAPI *)Annotation) >= ep_max_annotation_size)
        return(EPT_S_INVALID_ENTRY);

    if (!ARGUMENT_PRESENT( BindingVector))
        {
        return(RPC_S_NO_BINDINGS);
        }

    if (ARGUMENT_PRESENT( UuidVector ))
        {
        PObjUuidVector = UuidVector;
        }
    else
        {
        UuidVectorNull.Count = 1;
        RpcpMemorySet(&NilUuid, 0, sizeof(UUID));
        UuidVectorNull.Uuid[0] = &NilUuid;
        }

    Thread = ThreadSelf();
    if (Thread)
        {
        RpcpPurgeEEInfoFromThreadIfNecessary(Thread);
        }

    return(RegisterEntries(
                IfSpec,
                BindingVector,
                PObjUuidVector,
                Annotation,
                EP_REGISTER_REPLACE
                ));
}



RPC_STATUS RPC_ENTRY
RpcEpRegisterW (
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector,
    IN unsigned short * Annotation
    )
/*++


Routine Description:

    A server application will call this routine to register
    a series of end points with the local endpoint mapper, replcaing
    existing entries in the process.
    This is the Unicode version of the API.

Arguments:

    IfSpec  - Server side Interface specification structure generated
        by MIDL, that describes Interface UUId and version

    Binding Vector- A vector of binding handles that the server has registered
        with the runtime.

    UuidVector- A vector of Uuids of objects that the server is supporting

    Annotation - Annotation String

Return Value:


--*/
{
    USES_CONVERSION;
    CHeapAnsi AnsiString;
    RPC_STATUS err;

    if (ARGUMENT_PRESENT(Annotation))
        {
        ATTEMPT_HEAP_W2A(AnsiString, Annotation);
        }

    err = RpcEpRegisterA(
                IfSpec,
                BindingVector,
                UuidVector,
                AnsiString
                );

    return(err);
}





RPC_STATUS RPC_ENTRY
RpcEpUnregister(
    IN RPC_IF_HANDLE IfSpec,
    IN RPC_BINDING_VECTOR * BindingVector,
    IN UUID_VECTOR * UuidVector
    )
/*++


Routine Description:

    A server application will call this routine to unregister
    a series of end points.

Arguments:

    IfSpec - Pointer to Interface Specification generated by MIDL

    BindingVector - A Vector of Binding handles maintained by runtime
        for the server.

    UuidVector - A Vector of UUIDs for objects supported by the the server

Return Value:

    RPC_S_OK -

    RPC_S_OUT_OF_MEMORY - There is no memory available to construct
                          towers

--*/
{
    UUID_VECTOR UuidVectorNull;
    UUID_VECTOR PAPI *PObjUuidVector = &UuidVectorNull;
    UUID NilUuid;
    RPC_STATUS err;
    unsigned int i, j, CountBH, CountObj;
    RPC_BINDING_HANDLE EpMapperHandle;
    ept_entry_t PAPI * EpEntries, * p;
    twr_t PAPI *Twr;

    if (!ARGUMENT_PRESENT( BindingVector))
        {
        return(RPC_S_NO_BINDINGS);
        }

    if (ARGUMENT_PRESENT( UuidVector ))
        {
        PObjUuidVector = UuidVector;
        }
    else
        {
        UuidVectorNull.Count = 1;
        RpcpMemorySet(&NilUuid, 0, sizeof(UUID));
        UuidVectorNull.Uuid[0] = &NilUuid;
        }

    if (err = BindToEpMapper(
        &EpMapperHandle,
        NULL,           // NetworkAddress
        NULL,           // Protseq
        0,              // Options
        RPC_C_BINDING_DEFAULT_TIMEOUT,
        INFINITE,        // CallTimeout
        NULL        // AuthInfo
        ))
        {
        return(err);
        }

    CountObj = (unsigned int)PObjUuidVector->Count;

    if ((EpEntries = (ept_entry_t *)
        I_RpcAllocate(sizeof(ept_entry_t)*CountObj)) == NULL)
        {
        RpcBindingFree(&EpMapperHandle);
        return(RPC_S_OUT_OF_MEMORY);
        }

    RPC_STATUS FinalStatus = EPT_S_CANT_PERFORM_OP;
    CountBH = (unsigned int) BindingVector->Count;

    for (i = 0; i < CountBH; i++)
        {
        if (BindingVector->BindingH[i] == 0)
            {
            continue;
            }

        if (err = BindingAndIfToTower(IfSpec, BindingVector->BindingH[i], &Twr))
            {
            FinalStatus = err;
            break;
            }

        if (Twr == NULL)
            {
            continue;
            }

        for (p=EpEntries,j = 0; j < CountObj; j++,p++)
            {
            RpcpMemoryCopy(
                (char PAPI *)&p->object,
                (char PAPI *)PObjUuidVector->Uuid[j],
                sizeof(UUID)
                );
            p->tower = Twr;
            p->annotation[0] = '\0';
            }

        RequestEPClientMutex();
        RpcTryExcept
            {
            ept_delete_ex(
                EpMapperHandle,
                &hEpContext,
                CountObj,
                EpEntries,
                (error_status PAPI *)&err
                );
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            err = EPT_S_CANT_PERFORM_OP;
            }
        RpcEndExcept
        ClearEPClientMutex();

        I_RpcFree(Twr);

        } // For loop over Binding Handle Vector

    if (FinalStatus != RPC_S_OK)
        {
        FinalStatus = err;
        }

    I_RpcFree(EpEntries);

    RpcBindingFree(&EpMapperHandle);

    return(FinalStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\epmgmt.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    epmgmt.c

Abstract:

    We implement the endpoint mapper management routines: RpcMgmtEpEltInqBegin,
    RpcMgmtEpEltInqDone, RpcMgmtEpEltInqNext, and RpcMgmtEpUnregister.

Author:

    Michael Montague (mikemon) 14-Apr-1993

Revision History:

--*/

#include <precomp.hxx>
#include <epmp.h>
#include <twrproto.h>
#include <epmap.h>
#include <charconv.hxx>

#define EP_INQUIRY_CONTEXT_MAGIC_VALUE 0xBAD00DADL

typedef struct _EP_INQUIRY_CONTEXT
{
    unsigned long MagicValue;
    RPC_BINDING_HANDLE BindingHandle;
    ept_lookup_handle_t ContextHandle;
    unsigned long InquiryType;
    RPC_IF_ID IfId;
    unsigned long VersOption;
    UUID ObjectUuid;
} EP_INQUIRY_CONTEXT;

#define NOMOREEPS  0xFFFFFFFEL

#define NOMOREEPS_HANDLE  ((ept_lookup_handle_t)ULongToPtr(NOMOREEPS))
// const ept_lookup_handle_t NOMOREEPS_HANDLE = (ept_lookup_handle_t)ULongToPtr(NOMOREEPS);


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqBegin (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN unsigned long InquiryType,
    IN RPC_IF_ID __RPC_FAR * IfId OPTIONAL,
    IN unsigned long VersOption OPTIONAL,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    )
/*++

Routine Description:

    This routine is used to create an inquiry context for viewing the elements
    in a local or remote endpoint mapper database.

Arguments:

    EpBinding - Optionally supplies a binding indicating the endpoint mapper on
        which host should be interogated.  The binding must have a nil object
        uuid; otherwise, EPT_S_CANT_PERFORM_OP will be returned.  To specify
        this host (meaning the one the application is running on), specify NULL
        for this argument.  Only the network address and transport type will
        be used from the binding handle.

    InquiryType - Supplies the type of interogation to be performed; this must
        be one of: RPC_C_EP_ALL_ELTS, RPC_C_EP_MATCH_BY_IF,
        RPC_C_EP_MATCH_BY_OBJ, and RPC_C_EP_MATCH_BY_BOTH.

    IfId - Optionally supplies the interface identifier we are interogating
        the endpoint mapper with.  This argument must be supplied when the
        inquiry type is RPC_C_EP_MATCH_BY_IF or RPC_C_EP_MATCH_BY_BOTH;
        otherwise, this argument is ignored and NULL can be supplied.

    VersOption - Optionally supplies a flag specifying how interface versions
        are to be matched.  This argument must be supplied when IfId is
        supplied; otherwise, this argument is ignored.  Valid values for this
        flag are: RPC_C_VERS_ALL, RPC_C_VERS_COMPATIBLE, RPC_C_VERS_EXACT,
        RPC_C_VERS_MAJOR_ONLY, and RPC_C_VERS_UPTO.

    ObjectUuid - Optionally supplies the object uuid find in the endpoint
        mapper database.  This argument must be supplied when the inquiry
        typedef is RPC_C_EP_MATCH_BY_OBJ or RPC_EP_MATCH_BY_BOTH; otherwise,
        this argument is ignored and NULL can be supplied.

    InquiryContext - Returns a context handle which can be passed to
        RpcMgmtEpEltInqNext to obtain the results of the interogation of the
        endpoint mapper database.

Return Value:

    RPC_S_INVALID_ARG
    EPT_S_CANT_PERFORM_OP
    RPC_S_OUT_OF_MEMORY

--*/
{
    RPC_STATUS RpcStatus;
    RPC_CHAR __RPC_FAR * ProtocolSequence;
    RPC_CHAR __RPC_FAR * NetworkAddress;
    RPC_CHAR __RPC_FAR * Options;
    EP_INQUIRY_CONTEXT __RPC_FAR * EpInquiryContext;
    unsigned Timeout;

    switch ( InquiryType )
        {
        case RPC_C_EP_ALL_ELTS :
            IfId = 0;
            ObjectUuid = 0;
            break;

        case RPC_C_EP_MATCH_BY_IF :
            ObjectUuid = 0;
            // no break
        case RPC_C_EP_MATCH_BY_BOTH :
            if ( IfId == 0 )
                {
                return(RPC_S_INVALID_ARG);
                }

            if (   ( VersOption != RPC_C_VERS_ALL )
                && ( VersOption != RPC_C_VERS_COMPATIBLE )
                && ( VersOption != RPC_C_VERS_EXACT )
                && ( VersOption != RPC_C_VERS_MAJOR_ONLY )
                && ( VersOption != RPC_C_VERS_UPTO ) )
                {
                return(RPC_S_INVALID_ARG);
                }

            if (   ( InquiryType == RPC_C_EP_MATCH_BY_BOTH )
                && ( ObjectUuid == 0 ) )
                {
                return(RPC_S_INVALID_ARG);
                }
            break;

        case RPC_C_EP_MATCH_BY_OBJ :
            IfId = 0;
            if ( ObjectUuid == 0 )
                {
                return(RPC_S_INVALID_ARG);
                }
            break;

        default:
            return(RPC_S_INVALID_ARG);
        }

    // At this point, we have validated the InquiryType, IfId, VersOption,
    // and ObjectUuid parameters.

    if ( EpBinding != 0 )
        {
        UUID Uuid;
        int Result;
        RPC_CHAR __RPC_FAR * StringBinding;

        RpcStatus = RpcBindingInqObject(EpBinding, &Uuid);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }
        Result = UuidIsNil(&Uuid, &RpcStatus);
        if ( Result == 0 )
            {
            return(EPT_S_CANT_PERFORM_OP);
            }

        RpcStatus = RpcBindingToStringBinding(EpBinding, &StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcStringBindingParse(StringBinding, 0, &ProtocolSequence,
                &NetworkAddress, 0, &Options);
        RpcStringFree(&StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcMgmtInqComTimeout(EpBinding, &Timeout);
        if ( RpcStatus != RPC_S_OK )
            {
            RpcStringFree(&ProtocolSequence);
            RpcStringFree(&NetworkAddress);
            RpcStringFree(&Options);
            return(RpcStatus);
            }
        }
    else
        {
        NetworkAddress = 0;
        ProtocolSequence = 0;
        Options = 0;
        Timeout = RPC_C_BINDING_DEFAULT_TIMEOUT;
        }

    // When we reach here, the EpBinding will have been validated, and the
    // network address and protocol sequence to be used to reach the endpoint
    // mapper have been determined.

    // Thus all of the arguments will have been validated.

    EpInquiryContext = (EP_INQUIRY_CONTEXT __RPC_FAR *) I_RpcAllocate(
            sizeof(EP_INQUIRY_CONTEXT));
    if ( EpInquiryContext == 0 )
        {
        if (EpBinding != 0)
            {
            RpcStringFree(&ProtocolSequence);
            RpcStringFree(&NetworkAddress);
            RpcStringFree(&Options);
            }
        return(RPC_S_OUT_OF_MEMORY);
        }

    RpcStatus = BindToEpMapper(&(EpInquiryContext->BindingHandle),
            NetworkAddress, 
            ProtocolSequence, 
            Options, 
            Timeout,
            INFINITE,        // CallTimeout
            NULL            // AuthInfo
            );

    if (EpBinding != 0)
        {
        RpcStringFree(&ProtocolSequence);
        RpcStringFree(&NetworkAddress);
        RpcStringFree(&Options);
        }

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    EpInquiryContext->MagicValue = EP_INQUIRY_CONTEXT_MAGIC_VALUE;
    EpInquiryContext->ContextHandle = 0;
    EpInquiryContext->InquiryType = InquiryType;
    if ( IfId != 0 )
        {
        EpInquiryContext->IfId = *IfId;
        }
    EpInquiryContext->VersOption = VersOption;
    if ( ObjectUuid != 0 )
        {
        EpInquiryContext->ObjectUuid = *ObjectUuid;
        }

    *InquiryContext = (RPC_EP_INQ_HANDLE)EpInquiryContext;

    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqDone (
    IN OUT RPC_EP_INQ_HANDLE __RPC_FAR * InquiryContext
    )
/*++

Routine Description:

    The context handle used to interogate an endpoint mapper database is
    cleaned up in this routine.

Arguments:

    InquiryContext - Supplies the context handle to be deleted; on return,
        it will be set to zero.

Return Value:

    RPC_S_OK - Everything worked out just fine.

    RPC_S_INVALID_ARG - The supplied value supplied for the inquiry context
        is not an endpoint mapper inquiry context.

--*/
{
    EP_INQUIRY_CONTEXT __RPC_FAR * EpInquiryContext =
            (EP_INQUIRY_CONTEXT __RPC_FAR *) *InquiryContext;

    if ( EpInquiryContext->MagicValue != EP_INQUIRY_CONTEXT_MAGIC_VALUE )
        {
        return(RPC_S_INVALID_ARG);
        }

    RpcBindingFree(&(EpInquiryContext->BindingHandle));

    if ( (EpInquiryContext->ContextHandle != 0) &&
         (EpInquiryContext->ContextHandle != NOMOREEPS_HANDLE) )
        {
        RpcSsDestroyClientContext(&(EpInquiryContext->ContextHandle));
        }

    I_RpcFree(EpInquiryContext);
    *InquiryContext = 0;
    return(RPC_S_OK);
}


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextW (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned short __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    )
/*++

Routine Description:

    This routine is the unicode thunk to RpcMgmtEpEltInqNextA.

--*/
{
    unsigned char * AnsiAnnotation;
    RPC_STATUS RpcStatus;

    RpcStatus = RpcMgmtEpEltInqNextA( InquiryContext,
                                      IfId,
                                      Binding,
                                      ObjectUuid,
                                      Annotation ? &AnsiAnnotation : 0
                                      );

    if ( (RpcStatus == RPC_S_OK) && (Annotation) )
        {
        RpcStatus = A2WAttachHelper((char *)AnsiAnnotation, Annotation);
        I_RpcFree(AnsiAnnotation);
        }

    return RpcStatus;
}


RPC_STATUS RPC_ENTRY
RpcMgmtEpEltInqNextA (
    IN RPC_EP_INQ_HANDLE InquiryContext,
    OUT RPC_IF_ID __RPC_FAR * IfId,
    OUT RPC_BINDING_HANDLE __RPC_FAR * Binding OPTIONAL,
    OUT UUID __RPC_FAR * ObjectUuid OPTIONAL,
    OUT unsigned char __RPC_FAR * __RPC_FAR * Annotation OPTIONAL
    )
/*++

Routine Description:

    An application will use this routine to obtain the results of an
    interogation of the endpoint mapper database.

Arguments:

    InquiryContext - Supplies a context handle for the interogation.

    IfId - Returns the interface identifier of the element which was
        found in the endpoint mapper database.

    Binding - Optionally returns the binding handle contained in the element.

    Annotation - Optionally returns the annotation stored in the element.

Return Value:

    RPC_S_OK - We have successfully returned an element from the endpoint
        mapper database.

    RPC_S_OUT_OF_MEMORY - Insufficient memory is available to perform the
        operation.

    RPC_S_INVALID_ARG - The supplied value for the inquiry context is not
        a valid endpoint mapper inquiry context.

    EPT_S_CANT_PERFORM_OP -

    RPC_X_NO_MORE_ENTRIES - No more entries are available.  This will be
        returned after all of the entries have been returned from the
        endpoint mapper.

--*/
{
    EP_INQUIRY_CONTEXT __RPC_FAR * EpInquiryContext =
            (EP_INQUIRY_CONTEXT __RPC_FAR *) InquiryContext;
    unsigned long Returned;
    ept_entry_t EpEntry;
    error_status ErrorStatus;
    RPC_STATUS RpcStatus = RPC_S_OK;
    unsigned char __RPC_FAR * StringBinding;
    unsigned char __RPC_FAR * ProtocolSequence;
    unsigned char __RPC_FAR * Endpoint;
    unsigned char __RPC_FAR * NWAddress = 0;

    if ( EpInquiryContext->MagicValue != EP_INQUIRY_CONTEXT_MAGIC_VALUE )
        {
        return(RPC_S_INVALID_ARG);
        }

    if ( EpInquiryContext->ContextHandle == NOMOREEPS_HANDLE )
        {
        return (RPC_X_NO_MORE_ENTRIES);
        }

    while (1)
        {

        EpEntry.tower = 0;
        RpcTryExcept
            {
            ept_lookup(EpInquiryContext->BindingHandle,
                EpInquiryContext->InquiryType, &(EpInquiryContext->ObjectUuid),
                &(EpInquiryContext->IfId), EpInquiryContext->VersOption,
                &(EpInquiryContext->ContextHandle), 1, &Returned, &EpEntry,
                &ErrorStatus);
            }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
            {
            RpcStatus = RpcExceptionCode();
            }
        RpcEndExcept

        if ( RpcStatus == RPC_S_OK )
            {
            if ( ErrorStatus == EP_S_NOT_REGISTERED )
                {
                RpcStatus = RPC_X_NO_MORE_ENTRIES;
                }
            else if ( ErrorStatus != 0 )
                {
                RpcStatus = EPT_S_CANT_PERFORM_OP;
                }
            }

        if (   ( RpcStatus == RPC_S_OK )
            && ( Returned != 1 ) )
            {
            RpcStatus = EPT_S_CANT_PERFORM_OP;
            }

        if (EpInquiryContext->ContextHandle == 0)
            {
            EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
            }

        if ( RpcStatus != RPC_S_OK )
            {
            if (RpcStatus == RPC_S_SERVER_UNAVAILABLE)
               {
               RpcStatus = RPC_X_NO_MORE_ENTRIES;
               }

            return(RpcStatus);
            }

        RpcStatus = TowerExplode(EpEntry.tower, IfId, 0,
                (char __RPC_FAR * __RPC_FAR *) &ProtocolSequence,
                (char __RPC_FAR * __RPC_FAR *) &Endpoint,
                (char __RPC_FAR * __RPC_FAR *) &NWAddress
                );

        MIDL_user_free(EpEntry.tower);
        if (RpcStatus != RPC_S_OK)
            {
            if (  (EpInquiryContext->ContextHandle == 0) || (EpInquiryContext->ContextHandle == NOMOREEPS_HANDLE) )
              {
              EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
              return(RPC_X_NO_MORE_ENTRIES);
              }
            else
              {
              RpcStatus = RPC_S_OK;
              continue;
              }
            }
        else
            {
            //Tower Explode returned Success
            if ( Binding != 0 )
                {
                if ( RpcStatus != RPC_S_OK )
                    {
                    return(RpcStatus);
                    }

                RpcStatus = RpcStringBindingComposeA(0,
                                                ProtocolSequence, NWAddress,
                                                Endpoint, 0, &StringBinding);
                if ( RpcStatus == RPC_S_OK )
                    {
                    RpcStatus = RpcBindingFromStringBindingA(
                                                StringBinding,
                                                Binding
                                                );
                    RpcStringFreeA(&StringBinding);
                    }
                if ( RpcStatus != RPC_S_OK )
                    {
                    RpcStringFreeA(&ProtocolSequence);
                    RpcStringFreeA(&Endpoint);
                    if (NWAddress != 0)
                       {
                       RpcStringFreeA(&NWAddress);
                       }

                    if ( (EpInquiryContext->ContextHandle == 0) || (EpInquiryContext->ContextHandle == NOMOREEPS_HANDLE) )
                        {
                        EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
                        return(RPC_X_NO_MORE_ENTRIES);
                        }
                    else
                        {
                        RpcStatus = RPC_S_OK;
                        continue;
                        }
                    }
                }

            if (ObjectUuid != 0)
               {
               memcpy(ObjectUuid, &EpEntry.object, sizeof(UUID));
               }

            RpcStringFreeA(&ProtocolSequence);
            RpcStringFreeA(&Endpoint);
            if (NWAddress != 0)
               {
               RpcStringFreeA(&NWAddress);
               }
            }

        if ( Annotation != 0 )
            {
            *Annotation = (unsigned char __RPC_FAR *) I_RpcAllocate(
                strlen((LPCSTR) EpEntry.annotation) + 1);
            if ( *Annotation == 0 )
                {
                return(RPC_S_OUT_OF_MEMORY);
                }
            strcpy((LPSTR) *Annotation, (LPCSTR) EpEntry.annotation);
            }

        //MIDL_user_free(EpEntry.tower);
        break;
        }

        if (EpInquiryContext->ContextHandle == 0)
            {
            EpInquiryContext->ContextHandle = NOMOREEPS_HANDLE;
            }

        return(RpcStatus);

}


RPC_STATUS RPC_ENTRY
RpcMgmtEpUnregister (
    IN RPC_BINDING_HANDLE EpBinding OPTIONAL,
    IN RPC_IF_ID __RPC_FAR * IfId,
    IN RPC_BINDING_HANDLE Binding,
    IN UUID __RPC_FAR * ObjectUuid OPTIONAL
    )
/*++

Routine Description:

    This routine is used by management applications to remote server address
    information from a local or remote endpoint map.

Arguments:

    EpBinding - Optionally supplies a binding handle specifying which host
        from which to unregister remote server address information.  To
        specify this host, supply zero for this argument.  If a binding
        handle is supplied, then the object uuid in the binding handle must
        be zero.

    IfId - Supplies the interface identifier to be removed from the endpoint
        mapper database.

    Binding - Supplies the binding handle to be removed from the endpoint
        mapper database.

    ObjectUuid - Optionally supplies an object uuid to be removed; a value
        of zero indicates there is no object uuid to be removed.

Return Value:

    RPC_S_OK -

    EPT_S_NOT_REGISTERED -

    EPT_S_CANT_PERFORM_OP -

--*/
{
    UUID Uuid;
    RPC_STATUS RpcStatus;
    int Result;

    RPC_CHAR * ProtocolSequence;
    RPC_CHAR * NetworkAddress;
    RPC_CHAR * Options;
    RPC_CHAR * StringBinding;

    unsigned char __RPC_FAR * AnsiProtocolSequence;
    unsigned char __RPC_FAR * AnsiNetworkAddress;
    unsigned char __RPC_FAR * AnsiEndpoint;
    unsigned char __RPC_FAR * AnsiStringBinding;

    RPC_BINDING_HANDLE EpBindingHandle;
    unsigned long UuidFlag;
    unsigned long ErrorStatus;
    twr_t __RPC_FAR * Tower;
    RPC_TRANSFER_SYNTAX TransferSyntax;
    unsigned Timeout;

    if ( EpBinding != 0 )
        {
        RpcStatus = RpcBindingInqObject(EpBinding, &Uuid);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }
        Result = UuidIsNil(&Uuid, &RpcStatus);
        if ( Result == 0 )
            {
            return(EPT_S_CANT_PERFORM_OP);
            }

        RpcStatus = RpcBindingToStringBinding(EpBinding, &StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcStringBindingParse(  StringBinding,
                                            0,
                                            &ProtocolSequence,
                                            &NetworkAddress,
                                            0,
                                            &Options);
        RpcStringFree(&StringBinding);
        if ( RpcStatus != RPC_S_OK )
            {
            return(RpcStatus);
            }

        RpcStatus = RpcMgmtInqComTimeout(EpBinding, &Timeout);
        if ( RpcStatus != RPC_S_OK )
            {
            RpcStringFree(&ProtocolSequence);
            RpcStringFree(&NetworkAddress);
            RpcStringFree(&Options);
            return(RpcStatus);
            }
        }
    else
        {
        NetworkAddress = 0;
        ProtocolSequence = 0;
        Options = 0;
        Timeout = RPC_C_BINDING_DEFAULT_TIMEOUT;
        }

    // When we reach here, the EpBinding will have been validated, and the
    // network address and protocol sequence to be used to reach the endpoint
    // mapper have been determined.

    RpcStatus = BindToEpMapper( &EpBindingHandle,
                                NetworkAddress,
                                ProtocolSequence,
                                Options,
                                Timeout,
                                INFINITE,        // CallTimeout
                                NULL            // AuthInfo
                                );

    RpcStringFree(&ProtocolSequence);
    RpcStringFree(&NetworkAddress);
    RpcStringFree(&Options);

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    RpcStatus = RpcBindingToStringBindingA(Binding, &AnsiStringBinding);
    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    RpcStatus = RpcStringBindingParseA( AnsiStringBinding,
                                        0,
                                        &AnsiProtocolSequence,
                                        &AnsiNetworkAddress,
                                        &AnsiEndpoint,
                                        0);
    RpcStringFree(&StringBinding);
    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    RpcStatus = TowerConstruct( IfId,
                                &TransferSyntax,
                                (LPSTR) AnsiProtocolSequence,
                                (LPSTR) AnsiEndpoint,
                                (LPSTR) AnsiNetworkAddress,
                                &Tower);

    RpcStringFreeA(&AnsiProtocolSequence);
    RpcStringFreeA(&AnsiNetworkAddress);
    RpcStringFreeA(&AnsiEndpoint);

    if ( RpcStatus != RPC_S_OK )
        {
        return(RpcStatus);
        }

    if ( ObjectUuid != 0 )
        {
        Uuid = *ObjectUuid;
        UuidFlag = 1;
        }
    else
        {
        UuidFlag = 0;
        }

    ASSERT( RpcStatus == RPC_S_OK );

    RpcTryExcept
        {
        ept_mgmt_delete(EpBindingHandle, UuidFlag, &Uuid, Tower, &ErrorStatus);
        }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
        RpcStatus = RpcExceptionCode();
        }
    RpcEndExcept

    if ( RpcStatus == RPC_S_OK )
        {
        if ( ErrorStatus != 0 )
            {
            RpcStatus = EPT_S_NOT_REGISTERED;
            }
        }
    else
    if ( RpcStatus == RPC_S_SERVER_UNAVAILABLE )
        {
        RpcStatus = EPT_S_NOT_REGISTERED;
        }

    RpcBindingFree(&EpBindingHandle);
    return(RpcStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\eventwrp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       eventwrp.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

                      Microsoft OS/2 LAN Manager
                   Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: mutex.cxx

Description:

This file contains the system independent mutex class for NT.

History:

mikemon    ??-??-??    The beginning.
mikemon    12-31-90    Upgraded the comments.

-------------------------------------------------------------------- */

#include <precomp.hxx>


EVENT::EVENT (
    IN OUT RPC_STATUS PAPI * RpcStatus,
    IN int ManualReset,
    IN BOOL fDelayInit
    )
{
    EventHandle = NULL;

    // DelayInit events are auto reset
    ASSERT(ManualReset == FALSE || fDelayInit == FALSE);

    if (!fDelayInit && *RpcStatus == RPC_S_OK )
        {
		EventHandle = CreateEvent(NULL, ManualReset, 0, NULL);
        if ( EventHandle != NULL )
            {
            LogEvent(SU_EVENT, EV_CREATE, EventHandle, 0, 0, 1, 2);
            *RpcStatus = RPC_S_OK;
            }
        else
            {
            *RpcStatus = RPC_S_OUT_OF_MEMORY;
            }
        }	
}


EVENT::~EVENT (
    )
{

    if ( EventHandle )
        {
        LogEvent(SU_EVENT, EV_DELETE, EventHandle, 0, 0, 1, 2);
		
        BOOL bResult;
		bResult = CloseHandle(EventHandle);
		ASSERT(bResult != 0);
        }
}

int
EVENT::Wait (
    long timeout
    )
{
    DWORD result;

    if (NULL == EventHandle)
        {
        InitializeEvent();
        }

    result = WaitForSingleObject(EventHandle, timeout);

    if (result == WAIT_TIMEOUT)
        return(1);
    return(0);
}


void
EVENT::InitializeEvent (
    )
// Used when fDelayInit is TRUE in the c'tor.
{
    if (EventHandle)
        {
        return;
        }


    HANDLE event = CreateEvent(0, FALSE, FALSE, 0);

    if (event)
        {
        if (InterlockedCompareExchangePointer(&EventHandle, event, 0) != 0)
            {
            CloseHandle(event);
            }
        return;
        }

    // Can't allocate an event.
    RpcRaiseException(RPC_S_OUT_OF_RESOURCES);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\gc.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    GC.cxx

Abstract:

    The garbage collection mechanism common code. See the comment
    below for more details.

Author:

    Kamen Moutafov (kamenm)   Apr 2000

Garbage Collection Mechanism:
    This comment describes how the garbage collection mechanism works.
    The code itself is spread in variety in places.

    Purpose:
    There are two types of garbage collection we perform - periodic
    and one-time. Periodic may be needed by the Osf idle connection
    cleanup mechanism, which tries to cleanup unused osf connections
    if the app explicitly asked for it via RpcMgmtEnableIdleCleanup.
    The one-time cleanup is used by the lingering associations. If
    an association is lingered, it will request cleanup to be performed
    after a certain period of time. The garbage collection needs to
    support both of those mechanisms.

    Design Goals:
    Have minimal memory and CPU consumption requirements
    Don't cause periodic background activity if there is no
    garbage collection to be performed.
    Guarantee that garbage collection will be performed in
    a reasonable amount of time after its request time (i.e. 10 minutes
    to an hour at worst case)

    Implementation:
    We use the worker threads in the thread pools to perform garbage
    collection. There are several thread pools - the Ioc thread pool
    (remote threads) as well as one thread pool for each LRPC address.
    Within each pool, from a gc perspective, we differentiate between
    two types of threads - threads on a short wait and threads on a
    long wait. Threads on a short wait are either threads waiting for
    something to happen with a timeout of gThreadTimeout or less, or
    threads performing a work item (threads doing both are also
    considered to be on a short wait). Threads on a long wait are
    threads waiting for more than that. As part of our thread management
    we will keep count of how many threads are on a short wait and how
    many are on a long wait.

    All threads in all thread pools will attempt to do garbage collection 
    when they timeout waiting for something to happen. Since all thread pools 
    need at least one listening thread, all thread pools are guaranteed to 
    have a thread timing out once every so often. The garbage collection attempt 
    will be cut very short if there is nothing to garbage collect, so the
    attempt is not performance expensive in the common case. The function
    to attempt garbage collection is PerformGarbageCollection

    If a thread times out on the completion port/LPC port, it will
    do garbage collection, and then will check whether there are
    more items to garbage collect (either one-time or periodic) and how
    many threads from this thread pool are on a short wait. If there is
    garbage collection to be done, and there are no other threads on short
    wait, this thread will not go on a long wait, but it will repeat its
    short wait. This ensures timely garbage collection. If all the threads
    have gone on a long wait, and a piece of code needs garbage collection,
    it will request the garbage collection and it will tickle a worker thread.
    The tickling consist of posting an empty message to the completion port
    or LPC port. All the synchronization b/n worker threads and threads
    requesting garbage collection is done using interlocks, to avoid perf
    hit. This introduces a couple of benign races through the code, which may
    prevent a thread from going on a long wait once, but that's ok.

    In order to ensure that we do gc only when needed, in most cases we refcount 
    the number of items that need garbage collection.

--*/

#include <precomp.hxx>
#include <hndlsvr.hxx>
#include <lpcpack.hxx>
#include <lpcsvr.hxx>
#include <osfpcket.hxx>
#include <bitset.hxx>
#include <queue.hxx>
#include <ProtBind.hxx>
#include <osfclnt.hxx>
#include <rpcqos.h>
#include <lpcclnt.hxx>

// used by periodic cleanup only - the period
// on which to do cleanup. This is in seconds
unsigned long WaitToGarbageCollectDelay = 0;

// The number of items on which garbage collection
// is needed. If 0, no periodic garbage collection
// is necessary. Each item that needs garbage collection
// will InterlockIncrement this when it is created,
// and will InterlockDecrement this when it is destroyed
long PeriodicGarbageCollectItems = 0;

// set non-zero when we need to cleanup idle LRPC_SCONTEXTs
unsigned int fEnableIdleLrpcSContextsCleanup = 0;

// set to non-zero when we enable garbage collection cleanup. This either
// happens when the user calls it explicitly with 
// RpcMgmtEnableIdleCleanup or implicitly if we gather too many 
// connection in an association
unsigned int fEnableIdleConnectionCleanup = 0;

unsigned int IocThreadStarted = 0;

// used by one-time garbage collection items only!
long GarbageCollectionRequested = 0;

// The semantics of this variable should be
// interpreted as follows - don't bother to cleanup
// before this time stamp - you won't find anything.
// This means that after this interval, there may be
// many items to cleanup later on - it just says the
// first is at this time.
// The timestamp is in millseconds. 
DWORD NextOneTimeCleanup = 0;


const int MaxPeriodsWithoutGC = 100;


BOOL
GarbageCollectionNeeded (
    IN BOOL fOneTimeCleanup,
    IN unsigned long GarbageCollectInterval
    )
/*++

Routine Description:

    A routine used by code throughout RPC to arrange
    for garbage collection to be performed. Currently,
    there are two types of garbage collecting -
    idle Osf connections and lingering associations.

Parameters:
    fOneTimeCleanup - if non-zero, this is a one time
    cleanup and GarbageCollectInterval is interpreted as the 
    minimum time after which we want garbage collection 
    performed. Note that the garbage collection code can kick
    off earlier than that. Appropriate arrangements must be
    made to protect items not due for garbage collection.
    If 0, this is a periodic cleanup, and 

    GarbageCollectInterval is interpreted as the period for
    which we wait before making the next garbage collection
    pass. Note that for the periodic cleanup, this is a hint 
    that can be ignored - don't count on it. The time is in
    milliseconds.

Return Value:
    non-zero - garbage collection is available and will be done
    FALSE - garbage collection is not available

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    THREAD * Thread;
    DWORD LocalTickCount;
    LOADABLE_TRANSPORT *LoadableTransport;
    LOADABLE_TRANSPORT *FirstTransport = NULL;
    DictionaryCursor cursor;
    BOOL fRetVal = FALSE;
    LRPC_ADDRESS *CurrentAddress;
    LRPC_ADDRESS *LrpcAddressToTickle = NULL;

    if (fOneTimeCleanup)
        {
        LocalTickCount = GetTickCount();
        // N.B. There is a race here where two threads can set this -
        // the race is benign - the second thread will win and write
        // its time, which by virtue of the small race window will
        // be shortly after the first thread
        if (!GarbageCollectionRequested)
            {
            NextOneTimeCleanup = LocalTickCount + GarbageCollectInterval;
            GarbageCollectionRequested = 1;
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) GC requested - tick count %d\n",
                GetCurrentProcessId(), GetCurrentProcessId(), LocalTickCount);
#endif

            }
        }
    else
        {
        // WaitToGarbageCollectDelay is a global variable - avoid sloshing
        if (WaitToGarbageCollectDelay == 0)
            WaitToGarbageCollectDelay = GarbageCollectInterval;

        InterlockedIncrement(&PeriodicGarbageCollectItems);
        }

    // is the completion port started? If yes, we will use it as the
    // preferred method of garbage collection
    if (IocThreadStarted)
        {
        // if we use the completion port, we either need a thread on a
        // short wait (i.e. it will perform garbage collection soon
        // anyway), or we need to tickle a thread on a long wait. We know
        // that one of these will be true, because we always keep
        // listening threads on the completion port - the only
        // question is whether it is on a long or short wait thread that
        // we have.

        // this dictionary is guaranteed to never grow beyond the initial
        // dictionary size and elements from it are never deleted - therefore, 
        // it is safe to iterate it without holding a mutex - we may miss
        // an element if it was just being added, but that's ok. The important
        // thing is that we can't fault
        LoadedLoadableTransports->Reset(cursor);
        while ((LoadableTransport
                = LoadedLoadableTransports->Next(cursor)) != 0)
            {

            if (LoadableTransport->GetThreadsDoingShortWait() > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: there are Ioc threads on short wait - don't tickle\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
                // there is a transport with threads on short wait
                // garbage collection will be performed soon even without
                // our help - we can bail out
                FirstTransport = NULL;
                fRetVal = TRUE;
                break;
                }

            if (FirstTransport == NULL)
                FirstTransport = LoadableTransport;

            }
        }
    else if (LrpcAddressList 
        && (((RTL_CRITICAL_SECTION *)(NtCurrentPeb()->LoaderLock))->OwningThread != NtCurrentTeb()->ClientId.UniqueThread))
        {

        LrpcMutexRequest();

        // else, if there are Lrpc Addresses, check whether they are doing short wait
        // and can gc for us
        CurrentAddress = LrpcAddressList;
        while (CurrentAddress)
            {
            // can this address gc for us?
            if (CurrentAddress->GetNumberOfThreadsDoingShortWait() > 0)
                {
#if defined (RPC_GC_AUDIT)
                DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: there are threads on short wait (%d) on address %X - don't tickle\n",
                    GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), CurrentAddress,
                    CurrentAddress->GetNumberOfThreadsDoingShortWait());
#endif
                LrpcAddressToTickle = NULL;
                fRetVal = TRUE;
                break;
                }

            if ((LrpcAddressToTickle == NULL) && (CurrentAddress->IsPreparedForLoopbackTickling()))
                {
                LrpcAddressToTickle = CurrentAddress;
                }
            CurrentAddress = CurrentAddress->GetNextAddress();
            }

        // N.B. It is possible that Osf associations need cleanup, but only LRPC worker
        // threads are available, and moreover, no LRPC associations were created, which
        // means none of the Lrpc addresses is prepared for loopback tickling. If this is
        // the case, choose the first address, and make sure it is prepared for tickling
        if ((LrpcAddressToTickle == NULL) && (fRetVal == FALSE))
            {
            LrpcAddressToTickle = LrpcAddressList;

            // prepare the selected address for tickling
            fRetVal = LrpcAddressToTickle->PrepareForLoopbackTicklingIfNecessary();
            if (fRetVal == FALSE)
                {
                // if this fails, zero out the address for tickling. This
                // will cause this function to return failure
                LrpcAddressToTickle = NULL;
                }
            }

        LrpcMutexClear();
        }
    else if (fEnableIdleConnectionCleanup)
        {
        // if fEnableIdleConnectionCleanup is set, we have to create a thread if there is't one yet
        RpcStatus = CreateGarbageCollectionThread();
        if (RpcStatus == RPC_S_OK)
            {
            // the thread creation was successful - tell our caller we
            // will be doing garbage collection
            fRetVal = TRUE;
            }
        }

    // neither Ioc nor the LRPC thread pools have threads on short wait
    // We have to tickle somebody - we try the Ioc thread pool first
    if (FirstTransport)
        {
        // we couldn't find any transport with threads on short wait -
        // tickle a thread from the RPC transport in order to ensure timely
        // cleanup
#if defined (RPC_GC_AUDIT)
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: No Ioc threads on short wait found - tickling one\n",
            GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
        RpcStatus = TickleIocThread();
        if (RpcStatus == RPC_S_OK)
            fRetVal = TRUE;
        }
    else if (LrpcAddressToTickle)
        {
        // try to tickle the LRPC address
        fRetVal = LrpcAddressToTickle->LoopbackTickle();
        }

    return fRetVal;
}

RPC_STATUS CreateGarbageCollectionThread (
    void
    )
/*++

Routine Description:

    Make a best effort to create a garbage collection thread. In this
    implementation we simply choose to create a completion port thread,
    as it has many uses.

Return Value:

    RPC_S_OK on success or RPC_S_* on error

--*/
{
    TRANS_INFO *TransInfo;
    RPC_STATUS RpcStatus;

    if (IsGarbageCollectionAvailable())
        return RPC_S_OK;

    RpcStatus = LoadableTransportInfo(L"rpcrt4.dll", 
        L"ncacn_ip_tcp",
        &TransInfo);

    if (RpcStatus != RPC_S_OK)
        return RpcStatus;

    RpcStatus = TransInfo->CreateThread();

    return RpcStatus;
}


RPC_STATUS
EnableIdleConnectionCleanup (
    void
    )
/*++

Routine Description:

    We need to enable idle connection cleanup.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    fEnableIdleConnectionCleanup = 1;

    return(RPC_S_OK);
}


RPC_STATUS
EnableIdleLrpcSContextsCleanup (
    void
    )
/*++

Routine Description:

    We need to enable idle LRPC SContexts cleanup.

Return Value:

    RPC_S_OK - This value will always be returned.

--*/
{
    // this is a global variable - prevent sloshing
    if (fEnableIdleLrpcSContextsCleanup == 0)
        fEnableIdleLrpcSContextsCleanup = 1;

    return(RPC_S_OK);
}


long GarbageCollectingInProgress = 0;
DWORD LastCleanupTime = 0;


void
PerformGarbageCollection (
    void
    )
/*++

Routine Description:

    This routine should be called periodically so that each protocol
    module can perform garbage collection of resources as necessary.

--*/
{
    DWORD LocalTickCount;
    DWORD Diff;

#if defined (RPC_GC_AUDIT)
    DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: trying to garbage collect\n",
        GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
    if (InterlockedIncrement(&GarbageCollectingInProgress) > 1)
        {
        //
        // Don't need more than one thread garbage collecting
        //
#if defined (RPC_GC_AUDIT)
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: beaten to GC - returning\n",
            GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
        InterlockedDecrement(&GarbageCollectingInProgress);
        return;
        }

    if ((fEnableIdleConnectionCleanup || fEnableIdleLrpcSContextsCleanup) && PeriodicGarbageCollectItems)
        {
        LocalTickCount = GetTickCount();
        // make sure we don't cleanup too often - this is unnecessary
        if (LocalTickCount - LastCleanupTime > WaitToGarbageCollectDelay)
            {
            LastCleanupTime = LocalTickCount;
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Doing periodic garbage collection\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif

            // the periodic cleanup
            if (fEnableIdleLrpcSContextsCleanup)
                {
                GlobalRpcServer->EnumerateAndCallEachAddress(RPC_SERVER::actCleanupIdleSContext,
                    NULL);
                }

            if (fEnableIdleConnectionCleanup)
                {
                OSF_CCONNECTION::OsfDeleteIdleConnections();
                }
            }
        else
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Too soon for periodic gc - skipping (%d, %d)\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), LocalTickCount,
                LastCleanupTime);
#endif
            }
        }

    if (GarbageCollectionRequested)
        {
        LocalTickCount = GetTickCount();

        Diff = LocalTickCount - NextOneTimeCleanup;
        if ((int)Diff >= 0)
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Doing one time gc\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId());
#endif
            // assume the garbage collection will succeed. If it doesn't, the
            // functions called below have the responsibility to re-raise the flag
            // Note that there is a race condition where they may fail, but when
            // the flag was down, a thread went on a long wait. This again is ok,
            // because the current thread will figure out there is more garbage
            // collection to be done, because the flag is raised, and will do
            // a short wait. In worst case, the gc may be delayed because this
            // thread will pick a work item, and won't spawn another thread,
            // because there is already a thread in the IOCP, which is doing a
            // long wait. This may delay the gc from short to long wait. This is
            // Ok as it is in accordance with our design goals.
            GarbageCollectionRequested = 0;

            OSF_CASSOCIATION::OsfDeleteLingeringAssociations();
            LRPC_CASSOCIATION::LrpcDeleteLingeringAssociations();
            }
        else
            {
#if defined (RPC_GC_AUDIT)
            DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Thread %X: Too soon for one time gc - skipping (%d)\n",
                GetCurrentProcessId(), GetCurrentProcessId(), GetCurrentThreadId(), (int)Diff);
#endif
            }
        }

    GarbageCollectingInProgress = 0;
}

BOOL
CheckIfGCShouldBeTurnedOn (
    IN ULONG DestroyedAssociations,
    IN const ULONG NumberOfDestroyedAssociationsToSample,
    IN const long DestroyedAssociationBatchThreshold,
    IN OUT ULARGE_INTEGER *LastDestroyedAssociationsBatchTimestamp
    )
/*++

Routine Description:

    Checks if it makes sense to turn on garbage collection
    for this process just for the pruposes of having
    association lingering available.

Parameters:
    DestroyedAssociations - the number of associations destroyed
    for this process so far (Osf and Lrpc may keep a separate 
    count)
    NumberOfDestroyedAssociationsToReach - how many associations
    it takes to destroy for gc to be turned on
    DestroyedAssociationBatchThreshold - the time interval for which
    we have to destroy NumberOfDestroyedAssociationsToReach in
    order for gc to kick in
    LastDestroyedAssociationsBatchTimestamp - the timestamp when
    we made the last check

Return Value:
    non-zero - GC should be turned on
    FALSE - GC is either already on, or should not be turned on

--*/
{
    FILETIME CurrentSystemTimeAsFileTime;
    ULARGE_INTEGER CurrentSystemTime;
    BOOL fEnableGarbageCollection;

    if (IsGarbageCollectionAvailable() 
        || ((DestroyedAssociations % NumberOfDestroyedAssociationsToSample) != 0))
        {
        return FALSE;
        }

    fEnableGarbageCollection = FALSE;

    GetSystemTimeAsFileTime(&CurrentSystemTimeAsFileTime);
    CurrentSystemTime.LowPart = CurrentSystemTimeAsFileTime.dwLowDateTime;
    CurrentSystemTime.HighPart = CurrentSystemTimeAsFileTime.dwHighDateTime;
    if (LastDestroyedAssociationsBatchTimestamp->QuadPart != 0)
        {
#if defined (RPC_GC_AUDIT)
        ULARGE_INTEGER Temp;
        Temp.QuadPart = CurrentSystemTime.QuadPart - LastDestroyedAssociationsBatchTimestamp->QuadPart;
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) LRPC time stamp diff: %X %X\n",
            GetCurrentProcessId(), GetCurrentProcessId(), Temp.HighPart, Temp.LowPart);
#endif
        if (CurrentSystemTime.QuadPart - LastDestroyedAssociationsBatchTimestamp->QuadPart <= 
            DestroyedAssociationBatchThreshold)
            {
            // we have destroyed plenty (NumberOfDestroyedAssociationsToSample) of
            // associations for less than DestroyedAssociationBatchThreshold
            // this process will probably benefit from garbage collection turned on as it
            // does a lot of binds. Return so to the caller
            fEnableGarbageCollection = TRUE;
            }
        }
#if defined (RPC_GC_AUDIT)
    else
        {
        DbgPrintEx(77, DPFLTR_WARNING_LEVEL, "%d (0x%X) Time stamp is 0 - set it\n",
            GetCurrentProcessId(), GetCurrentProcessId());
        }
#endif

    LastDestroyedAssociationsBatchTimestamp->QuadPart = CurrentSystemTime.QuadPart;

    return fEnableGarbageCollection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\hashtabl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       hashtabl.cxx
//
//--------------------------------------------------------------------------

/*++

Module Name:

    hashtabl.cxx

Abstract:



Author:

    Jeff Roberts (jroberts)  9-Nov-1994

Revision History:

     9-Nov-1994     jroberts

        Created this module.

--*/

#include <precomp.hxx>
#include "hashtabl.hxx"


UUID_HASH_TABLE::UUID_HASH_TABLE(
    RPC_STATUS * pStatus,
    unsigned long SpinCount
    )
/*++

Routine Description:



Arguments:



Return Value:



Exceptions:



--*/
{
    unsigned u;
    for (u = 0; u < BUCKET_COUNT; ++u)
        {
#ifdef DEBUGRPC
        Counts[u] = 0;
#endif
        Buckets[u] = 0;
        }

    //
    // Allocate bucket mutexes.  If one or more fail to initialize,
    // continue anyway so that the pointer is valid for all 'u'.
    // They will be deleted in the destructor.
    // BUBUG this modification needs testing
    //
    for (u = 0; u < MUTEX_COUNT; ++u)
        {
        BucketMutexes[u] = new MUTEX(pStatus);
        if ((BucketMutexes[u] == NULL) || (*pStatus))
            {
            if (BucketMutexes[u] == NULL)
                *pStatus = RPC_S_OUT_OF_MEMORY;
            }
        else
            {
            BucketMutexes[u]->SetSpinCount(SpinCount);
            }
        }
}


UUID_HASH_TABLE::~UUID_HASH_TABLE(
    )
{
    unsigned u;
    for (u = 0; u < MUTEX_COUNT; ++u)
        {
        delete BucketMutexes[u];
        }
}


unsigned
UUID_HASH_TABLE::Add(
    UUID_HASH_TABLE_NODE * pNode,
    unsigned Hash
    )
{
    if (Hash == NO_HASH)
        {
        Hash = MakeHash(&pNode->Uuid);
        }

    ASSERT( Hash < BUCKET_COUNT );

    if (Buckets[Hash])
        {
        ASSERT(Buckets[Hash]->pPrev == 0);
        }

#ifdef DEBUGRPC

    BOOL Seen = FALSE;
    unsigned Count = 0;
    UUID_HASH_TABLE_NODE * pScan = Buckets[Hash];
    while (pScan)
        {
        ++Count;
        ASSERT(Count <= Counts[Hash]);

        if (pScan == pNode)
            {
            Seen = TRUE;
            }

        if (pScan->pNext)
            {
            ASSERT(pScan->pNext->pPrev == pScan);
            }

        pScan = pScan->pNext;
        }

    ASSERT(!Seen);
    ASSERT(Count == Counts[Hash]);

    ++Counts[Hash];

#endif

    pNode->pPrev = 0;
    pNode->pNext = Buckets[Hash];
    Buckets[Hash] = pNode;

    if (pNode->pNext)
        {
        pNode->pNext->pPrev = pNode;
        }
    return Hash;
}


void
UUID_HASH_TABLE::Remove(
    UUID_HASH_TABLE_NODE * pNode,
    unsigned Hash
    )
{
    if (Hash == NO_HASH)
        {
        Hash = MakeHash(&pNode->Uuid);
        }

    ASSERT( Hash < BUCKET_COUNT );

#ifdef DEBUGRPC

    BOOL Seen = FALSE;
    unsigned Count = 0;
    UUID_HASH_TABLE_NODE * pScan = Buckets[Hash];
    while (pScan)
        {
        ++Count;
        ASSERT(Count <= Counts[Hash]);

        if (pScan == pNode)
            {
            Seen = TRUE;
            }

        if (pScan->pNext)
            {
            ASSERT(pScan->pNext->pPrev == pScan);
            }

        pScan = pScan->pNext;
        }

    ASSERT(Seen);
    ASSERT(Count == Counts[Hash]);

    --Counts[Hash];

#endif

    ASSERT(pNode->pPrev != pNode);
    ASSERT(pNode->pNext != pNode);

    if (pNode->pPrev != 0)
        {
        ASSERT(pNode->pPrev->pNext == pNode);
        pNode->pPrev->pNext = pNode->pNext;
        }
    else
        {
        ASSERT(Buckets[Hash] == pNode);
        Buckets[Hash] = pNode->pNext;
        }

    if (pNode->pNext != 0)
        {
        ASSERT(pNode->pNext->pPrev == pNode);
        pNode->pNext->pPrev = pNode->pPrev;
        }

#ifdef DEBUGRPC

    pNode->pPrev = INVALID_NODE;
    pNode->pNext = INVALID_NODE;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\rpc\runtime\mtrt\handle.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1990 - 1999
//
//  File:       handle.cxx
//
//--------------------------------------------------------------------------

/* --------------------------------------------------------------------

              Microsoft OS/2 LAN Manager
           Copyright(c) Microsoft Corp., 1990

-------------------------------------------------------------------- */
/* --------------------------------------------------------------------

File: handle.cxx

Description:

The actual code for all of the classes specified by handle.hxx is
contained in this file.  These routines are independent of the actual RPC
protocol / transport layer.  In addition, these routines are also
independent of the specific operating system in use.

History :

mikemon    ??-??-??    First bit in the bucket.
mikemon    12-28-90    Cleaned up the comments.

    Kamen Moutafov (KamenM) Dec 99 - Feb 2000 - Support for cell debugging stuff

-------------------------------------------------------------------- */

#include <precomp.hxx>
#include <epmap.h>
#include <rpccfg.h>

#include <dispatch.h>
#include <crypt.h>
#include <charconv.hxx>

extern unsigned  DefaultMaxDatagramLength = DEFAULT_MAX_DATAGRAM_LENGTH;
extern unsigned  DefaultConnectionBufferLength = DEFAULT_CONNECTION_BUFFER_LENGTH;

/*

   A helper routine to capture the logon ID of this thread, if it is
   impersonating another process.

   Routine returns RPC_S_OK on success. If the process is not impersonating,
   but running under its own process identity, this routine will fail.

   All failures, currently, get treated as if the thread is not impersonating

*/

RPC_STATUS
GetTokenStats(TOKEN_STATISTICS *pTokenStats)
{
    BOOL Result;
    HANDLE Handle;
    unsigned long Size;

    Result = OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_READ,
                 TRUE,
                 &Handle
                 );

    if (Result != TRUE)
        {
        return (GetLastError());
        }

    Result = GetTokenInformation(
                 Handle,
                 TokenStatistics,
                 pTokenStats,
                 sizeof(TOKEN_STATISTICS),
                 &Size
                 );

    CloseHandle(Handle);
    if (Result != TRUE)
        {
        return (GetLastError());
        }

    return RPC_S_OK;
}

RPC_STATUS
CaptureModifiedId(
    LUID * ModifiedId
    )
{
    TOKEN_STATISTICS TokenStatisticsInformation;
    RPC_STATUS Status;

    Status = GetTokenStats(&TokenStatisticsInformation);
    if (Status != RPC_S_OK)
        {
        return Status;
        }

    RpcpMemoryCopy(ModifiedId,
        &TokenStatisticsInformation.ModifiedId, sizeof(LUID));

    return (RPC_S_OK);
}

void WipeOutAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Wipes out the important parts of an auth identity structure.
    Works on encrypted and decrypted identities.

Arguments:

    AuthIdentity - the auth identity to wipe out.

Return Value:

--*/
{
    if (AuthIdentity == NULL)
        return;

    if (AuthIdentity->User != NULL)
        {
        RpcpMemorySet(AuthIdentity->User, 0, AuthIdentity->UserLength * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Domain != NULL)
        {
        RpcpMemorySet(AuthIdentity->Domain, 0, AuthIdentity->DomainLength * sizeof(RPC_CHAR));
        }

    if (AuthIdentity->Password != NULL)
        {
        RpcpMemorySet(AuthIdentity->Password, 0, AuthIdentity->PasswordLength * sizeof(RPC_CHAR));
        }
}

// if RTL_ENCRYPT_MEMORY_SIZE gets changed, the padding logic below
// must get changed also
C_ASSERT(RTL_ENCRYPT_MEMORY_SIZE == 8);

RPC_CHAR *
ReallocAndPad8IfNeccessary (
    IN RPC_CHAR *OldBuffer,
    IN OUT ULONG *Length
    )
/*++

Routine Description:

    Encrypts the important parts of an auth identity structure.
    On success, if reallocation was done, the old buffer is deleted.

Arguments:

    OldBuffer - the old, unpadded buffer

    Length - on input, the length of the old unpadded buffer in characters without
        the terminating null. On output the length of the encrypted buffer with
        padding. Unmodified on failure.

Return Value:

    The new buffer (may be the same as the old) or NULL if there is
    insufficient memory.

--*/
{
    ULONG NewLength;
    ULONG InputLength = *Length;
    RPC_CHAR *NewBuffer;
    
    NewLength = Align8(InputLength + 1);
    if (NewLength == InputLength + 1)
        {
        *Length = NewLength;
        return OldBuffer;
        }

    NewBuffer = new RPC_CHAR[NewLength];
    if (NewBuffer == NULL)
        return NULL;

    RpcpMemoryCopy(NewBuffer, OldBuffer, (InputLength + 1) * sizeof(RPC_CHAR));

    // wipe out the old buffer before freeing it
    RpcpMemorySet(OldBuffer, 0, (InputLength + 1) * sizeof(RPC_CHAR));
    delete [] OldBuffer;

    *Length = NewLength;

    return NewBuffer;
}

RPC_STATUS EncryptAuthIdentity (
    IN SEC_WINNT_AUTH_IDENTITY_W *AuthIdentity
    )
/*++

Routine Description:

    Encrypts the important parts of an auth identity structure.

Arguments:

    AuthIdentity - the auth identity to encrypt.

Return Value:

    RPC_S_OK or RPC_S_* error

--*/
{
    RPC_STATUS RpcStatus;
    NTSTATUS NtStatus;

    if (AuthIdentity->User != NULL)
        {
        AuthIdentity->User = ReallocAndPad8IfNeccessary(AuthIdentity->User,
            &AuthIdentity->UserLength
            );
        if (AuthIdentity->User == NULL)
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        NtStatus = RtlEncryptMemory(AuthIdentity->User,
            AuthIdentity->UserLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            ASSERT(NtStatus != STATUS_INVALID_PARAMETER);
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    if (AuthIdentity->Domain != NULL)
        {
        AuthIdentity->Domain = ReallocAndPad8IfNeccessary(AuthIdentity->Domain,
            &AuthIdentity->DomainLength
            );
        if (AuthIdentity->Domain == NULL)
            {
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }

        NtStatus = RtlEncryptMemory(AuthIdentity->Domain,
            AuthIdentity->DomainLength * sizeof(RPC_CHAR),
            0);

        if (!NT_SUCCESS(NtStatus))
            {
            ASSERT(NtStatus != STATUS_INVALID_PARAMETER);
            WipeOutAuthIdentity(AuthIdentity);
            return RPC_S_OUT_OF_MEMORY;
            }
        }

    if (AuthIdentity->Password != NULL)
        {
        AuthIdentity->Password = ReallocAndPad8IfNeccessary(AuthIdentity->P