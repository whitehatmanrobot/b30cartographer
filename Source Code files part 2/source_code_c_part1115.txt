
    DWORD   dwSize             = 0;

    TCHAR szBuffer[BUFFER_SIZE];

    // ISSUE-2002/02/28-stelo- I don't use the hKey passed in.  For some reason, the Network
    //    component objects don't point to the section of the registry I need
    //    to read from.  Is this a bug with Network Component Objects?

    dwSize = sizeof( szBuffer );

    if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      REGKEY_MSCLIENT_LOCATION,
                      0,
                      SecurityAccess,
                      &hNameServiceKey ) != ERROR_SUCCESS )
    {

        //
        //  need this key to read in other MS Client values so bail if we
        //  can't get it
        //
        return;

    }


    if( RegQueryValueEx( hNameServiceKey,
                         REGVAL_NAME_SERVICE_PROVIDER,
                         NULL,
                         NULL,
                         (LPBYTE) szBuffer,
                         &dwSize ) == ERROR_SUCCESS )
    {

        if ( LSTRCMPI(szBuffer, _T("ncacn_ip_tcp")) == 0 )
        {
            NetSettings.NameServiceProvider = MS_CLIENT_DCE_CELL_DIR_SERVICE;

            dwSize = sizeof( szBuffer );

            if( RegQueryValueEx( hNameServiceKey,
                                 REGVAL_NETWORK_ADDRESS,
                                 0,
                                 NULL,
                                 (LPBYTE) szBuffer,
                                 &dwSize) == ERROR_SUCCESS )
            {

                lstrcpyn( NetSettings.szNetworkAddress, 
                          szBuffer, 
                          MAX_NETWORK_ADDRESS_LENGTH + 1 );

            }

        }
        else
        {
            NetSettings.NameServiceProvider = MS_CLIENT_WINDOWS_LOCATOR;
        }

    }

    RegCloseKey( hNameServiceKey );

}

//----------------------------------------------------------------------------
//
// Function: ReadAppletalkSettingsFromRegistry
//
// Purpose:  Read in registry settings on Appletalk and fill the global structs
//           with the appropriate values
//
// Arguments: HKEY *hKey
//
// Returns:  HRESULT returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static VOID
ReadAppletalkSettingsFromRegistry( IN HKEY *hKey )
{

    REGSAM  SecurityAccess     = KEY_QUERY_VALUE;

    // ISSUE-2002/02/28-stelo- write this function



}

//----------------------------------------------------------------------------
//
// Function: ReadIpxSettingsFromRegistry
//
// Purpose:  Read in registry settings on IPX and fill the global structs
//           with the appropriate values
//
// Arguments: HKEY *hKey
//
// Returns:  HRESULT returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static VOID
ReadIpxSettingsFromRegistry( IN HKEY *hKey )
{

    REGSAM     SecurityAccess         =  KEY_QUERY_VALUE;
    HKEY       hIpxAdaptersKey        =  NULL;
    HKEY       hNetworkAdapterKey     =  NULL;
    DWORD      dwSize                 =  0;
    NETWORK_ADAPTER_NODE *pNetAdapter =  NULL;

    WCHAR   szStringGuid[MAX_GUID_STRING];
    
    TCHAR szBuffer[BUFFER_SIZE];

    if( RegOpenKeyEx( *hKey,
                      REGVAL_ADAPTERS,
                      0,
                      SecurityAccess,
                      &hIpxAdaptersKey ) != ERROR_SUCCESS )
    {

        //
        // need this key to read in other IPX values so bail if we can't get it
        //
        return;

    }

    dwSize = sizeof( szBuffer );

    if( RegQueryValueEx( *hKey,
                         REGVAL_VIRTUAL_NETWORK_NUMBER,
                         0,
                         NULL,
                         (LPBYTE) szBuffer,
                         &dwSize ) == ERROR_SUCCESS )
    {

        lstrcpyn( NetSettings.szInternalNetworkNumber, 
                  szBuffer, 
                  MAX_INTERNAL_NET_NUMBER_LEN + 1 );

    }

    //
    //  For each Network Adapter, load its IPX settings
    //

    for( pNetAdapter = NetSettings.NetworkAdapterHead;
         pNetAdapter;
         pNetAdapter = pNetAdapter->next )
    {

        StringFromGUID2( pNetAdapter->guid, 
                         szStringGuid, 
                         StrBuffSize( szStringGuid ) );

        if( RegOpenKeyEx( hIpxAdaptersKey,
                          szStringGuid,
                          0,
                          SecurityAccess,
                          &hNetworkAdapterKey ) == ERROR_SUCCESS )
        {

            dwSize = sizeof( szBuffer );

            if( RegQueryValueEx( hNetworkAdapterKey,
                                 REGVAL_PKT_TYPE,
                                 0,
                                 NULL,
                                 (LPBYTE) szBuffer,
                                 &dwSize) == ERROR_SUCCESS )
            {

                lstrcpyn( pNetAdapter->szFrameType, _T("0x"), AS(pNetAdapter->szFrameType) );

                lstrcatn( pNetAdapter->szFrameType, szBuffer, MAX_FRAMETYPE_LEN );

            }

            dwSize = sizeof( szBuffer );

            if( RegQueryValueEx( hNetworkAdapterKey,
                                 REGVAL_NETWORK_NUMBER,
                                 0,
                                 NULL,
                                 (LPBYTE) szBuffer,
                                 &dwSize) == ERROR_SUCCESS )
            {

                lstrcpyn( pNetAdapter->szNetworkNumber, 
                          szBuffer, 
                          MAX_NET_NUMBER_LEN + 1 );

            }

        }
    }
}

//----------------------------------------------------------------------------
//
// Function: ReadTcpipSettingsFromRegistry
//
// Purpose:  Read in registry settings on TCP/IP and fill the global structs
//           with the appropriate values
//
// Arguments: HKEY *hKey - 
//
// Returns:  HRESULT returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static VOID
ReadTcpipSettingsFromRegistry( IN HKEY *hKey )
{

    HKEY    hTcpipInterfaceKey = NULL;
    REGSAM  SecurityAccess     = KEY_QUERY_VALUE;

    NETWORK_ADAPTER_NODE *pNetAdapter = NULL;

    if( RegOpenKeyEx( *hKey,
                      REGVAL_INTERFACES,
                      0,
                      SecurityAccess,
                      &hTcpipInterfaceKey ) != ERROR_SUCCESS )
    {

        //
        // need this key to read in all other TCP/IP values so bail if we can't get it
        //

        return;

    }

    //
    //  For each Network Adapter, load its TCP/IP settings
    //

    for( pNetAdapter = NetSettings.NetworkAdapterHead;
         pNetAdapter;
         pNetAdapter = pNetAdapter->next )
    {

        ReadAdapterSpecificTcpipSettings( hTcpipInterfaceKey, pNetAdapter );

    }

    // ISSUE-2002/20/28-stelo -not reading in LM Hosts setting

}

//----------------------------------------------------------------------------
//
// Function: ReadAdapterSpecificTcpipSettings
//
// Purpose:  Reads network adapter specific TCP/IP settings and populates the
//           pNetAdapter structure with their values.
//
// Arguments:  
//    IN HKEY hTcpipInterfaceKey - handle to the TCP/IP settings portion of
//        the registry
//    IN OUT NETWORK_ADAPTER_NODE *pNetAdapter - ptr to structure to load the
//        TCP/IP values into
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
ReadAdapterSpecificTcpipSettings( IN HKEY hTcpipInterfaceKey,
                                  IN OUT NETWORK_ADAPTER_NODE *pNetAdapter )
{

    DWORD   dwDHCP             = 0;
    DWORD   dwSize             = 0;
    DWORD   dwSize2            = 0;
    REGSAM  SecurityAccess     = KEY_QUERY_VALUE;
    HKEY    hNetworkAdapterKey = NULL;
    LPTSTR  lpszBuffer         = NULL;
    LPTSTR  lpszBuffer2        = NULL;
    TCHAR   szStringGuid[MAX_GUID_STRING];

    //
    // Make sure we can allocate big enough buffers...
    //
    lpszBuffer  = (LPTSTR) MALLOC( BUFFER_SIZE * sizeof(TCHAR) );
    if ( !lpszBuffer )
    {
        // Unable to allocate memory... bail!
        return;
    }
    lpszBuffer2 = (LPTSTR) MALLOC( BUFFER_SIZE * sizeof(TCHAR) );
    if ( !lpszBuffer2 )
    {
        // Unable to allocate memory... bail!
        FREE( lpszBuffer );
        return;
    }

    StringFromGUID2( pNetAdapter->guid, 
                     szStringGuid, 
                     StrBuffSize( szStringGuid ) );

    if( RegOpenKeyEx( hTcpipInterfaceKey,
                      szStringGuid,
                      0,
                      SecurityAccess,
                      &hNetworkAdapterKey ) == ERROR_SUCCESS )
    {

        dwSize = sizeof( dwDHCP );

        if( RegQueryValueEx( hNetworkAdapterKey,
                             REGVAL_ENABLE_DHCP,
                             0,
                             NULL,
                             (LPBYTE) &dwDHCP,
                             &dwSize ) == ERROR_SUCCESS )
        {
    
            if( dwDHCP == 1 )
            {

                pNetAdapter->bObtainIPAddressAutomatically = TRUE;

            }
            else
            {

                pNetAdapter->bObtainIPAddressAutomatically = FALSE;

            }

        }

        if( ! pNetAdapter->bObtainIPAddressAutomatically )
        {
            TCHAR *pszIpAddresses;
            TCHAR *pszSubnetAddresses;
            TCHAR *pszGatewayAddresses;
            TCHAR *pszDnsAddresses;
            TCHAR *pszWinsAddresses;
            TCHAR szWinsRegPath[MAX_INILINE_LEN + 1] = _T("");
            HKEY  hWinsKey = NULL;
            HRESULT hrCat;

            dwSize  = BUFFER_SIZE * sizeof(TCHAR);
            dwSize2 = BUFFER_SIZE * sizeof(TCHAR);

            if( (RegQueryValueEx( hNetworkAdapterKey,
                                  REGVAL_IPADDRESS,
                                  0,
                                  NULL,
                                  (LPBYTE) lpszBuffer,
                                  &dwSize ) == ERROR_SUCCESS)
                &&
                (RegQueryValueEx( hNetworkAdapterKey,
                                  REGVAL_SUBNETMASK,
                                  0,
                                  NULL,
                                  (LPBYTE) lpszBuffer2,
                                  &dwSize2 ) == ERROR_SUCCESS ) )
            {

                pszIpAddresses      = lpszBuffer;   // contains the IP Addresses
                pszSubnetAddresses  = lpszBuffer2;  // contains the Subnet Masks

                if( *pszIpAddresses != _T('\0') && *pszSubnetAddresses != _T('\0') ) {

                    //
                    //  Add the IP and Subnet masks to their namelists
                    //

                    do
                    {

                        TcpipAddNameToNameList( &pNetAdapter->Tcpip_IpAddresses,
                                                pszIpAddresses );

                        TcpipAddNameToNameList( &pNetAdapter->Tcpip_SubnetMaskAddresses,
                                                pszSubnetAddresses );

                    } while( GetNextIp( &pszIpAddresses ) && GetNextIp( &pszSubnetAddresses ) );

                }

            }

            dwSize = BUFFER_SIZE * sizeof(TCHAR);

            if( RegQueryValueEx( hNetworkAdapterKey,
                                 REGVAL_DEFAULTGATEWAY,
                                 0,
                                 NULL,
                                 (LPBYTE) lpszBuffer,
                                 &dwSize ) == ERROR_SUCCESS )
            {

                pszGatewayAddresses = lpszBuffer;   // contains the Gateway Addresses

                if( *pszGatewayAddresses != _T('\0') )
                {

                    //
                    //  Add the Gateways to its namelist
                    //

                    do
                    {
                        AddNameToNameList( &pNetAdapter->Tcpip_GatewayAddresses,
                                           pszGatewayAddresses );

                    } while( GetNextIp( &pszGatewayAddresses ) );

                }

            }

            //
            //  Get the DNS IPs
            //
            dwSize = BUFFER_SIZE * sizeof(TCHAR);

            if( RegQueryValueEx( hNetworkAdapterKey,
                                 REGVAL_NAMESERVER,
                                 0,
                                 NULL,
                                 (LPBYTE) lpszBuffer,
                                 &dwSize ) == ERROR_SUCCESS )
            {

                pszDnsAddresses = lpszBuffer;  // Contains the DNS addresses

                if( *pszDnsAddresses != _T('\0') )
                {

                    TCHAR szDnsBuffer[MAX_INILINE_LEN + 1];

                    NetSettings.bObtainDNSServerAutomatically = FALSE;

                    //
                    //  Loop grabbing the DNS IPs and inserting them into
                    //  its namelist
                    //

                    while( GetCommaDelimitedEntry( szDnsBuffer, &pszDnsAddresses ) )
                    {

                        TcpipAddNameToNameList( &pNetAdapter->Tcpip_DnsAddresses,
                                                szDnsBuffer );

                    }

                }

            }

            //
            //  Get the WINS server list
            //
            //  Have to jump to different location in the registry to read
            //  the WINS data
            //

            //
            //  Build up the WINS registry path
            //

            lstrcpyn( szWinsRegPath, REGVAL_WINS, AS(szWinsRegPath) );

            hrCat=StringCchCat( szWinsRegPath, AS(szWinsRegPath), szStringGuid );

            //
            //  Grab all the WINS values from the registry
            //

            if( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              szWinsRegPath,
                              0,
                              SecurityAccess,
                              &hWinsKey ) != ERROR_SUCCESS )
            {

                //
                //  need this key to read in the WINS values so bail if we
                //  can't get it
                //
                return;

            }

            dwSize = BUFFER_SIZE * sizeof(TCHAR);

            if( RegQueryValueEx( hWinsKey,
                                 REGVAL_NAMESERVERLIST,
                                 NULL,
                                 NULL,
                                 (LPBYTE) lpszBuffer,
                                 &dwSize ) == ERROR_SUCCESS )
            {

                pszWinsAddresses = lpszBuffer;

                if( *pszWinsAddresses != _T('\0') )
                {

                    //
                    //  Add the WINS IPs to the namelist
                    //
                    do
                    {

                        AddNameToNameList( &pNetAdapter->Tcpip_WinsAddresses,
                                           pszWinsAddresses );

                    } while( GetNextIp( &pszWinsAddresses ) ); 

                }

            }

            //
            //  Get the Domain
            //
            dwSize = BUFFER_SIZE * sizeof(TCHAR);

            if( RegQueryValueEx( hNetworkAdapterKey,
                                 REGVAL_DOMAIN,
                                 0,
                                 NULL,
                                 (LPBYTE) lpszBuffer,
                                 &dwSize ) == ERROR_SUCCESS )
            {

                lstrcpyn( pNetAdapter->szDNSDomainName, 
                          lpszBuffer, 
                          MAX_DNS_DOMAIN_LENGTH + 1 );

            }

            // ISSUE-2002/20/28-stelo- not reading the NetBiosOption

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: GetNextIp
//
// Purpose:  Gets the next string in a multi-NULL terminated string
//
// Arguments:  TCHAR *ppszString - pointer to the current string
//
// Returns: BOOL - TRUE if ppszString points to the IP string
//                 FALSE if there are no more IP strings left
//          TCHAR *ppszString - on TRUE, points to the next IP string 
//                            - on FALSE, points to NULL
//
//----------------------------------------------------------------------------
static BOOL 
GetNextIp( IN OUT TCHAR **ppszString )
{

    while( **ppszString != _T('\0') )
    {
        (*ppszString)++;
    }

    //
    // check that Char after the one we are currently looking at to see if it
    // is the true end of the string(s)
    //

    if( *( (*ppszString) + 1 ) == _T('\0') )
    {
        //
        // 2 NULLs in a row signify there are no more IPs to read
        //

        return( FALSE );

    }
    else
    {
        //
        //  Advance one more so we go past the \0 and point to the first char
        //  of the new IP address
        //

        (*ppszString)++;

        return( TRUE );

    }

}

//----------------------------------------------------------------------------
//
// Function: GetDomainMembershipInfo
//
// Purpose:  Gets the domain/workgroup for the machine it is running on.
//           Assumes enough space is already allocated in szName for the copy.
//
// Arguments: BOOL* bDomainMember - if TRUE, then the contents of szName is a Domain
//                                  if FALSE, then the contents of szName is a Workgroup
//
// Returns: NTSTATUS - returns success or failure of the function
//
//----------------------------------------------------------------------------
static NTSTATUS
GetDomainMembershipInfo( OUT BOOL* bDomainMember, OUT TCHAR *szName )
{

    NTSTATUS                     ntstatus;
    POLICY_PRIMARY_DOMAIN_INFO*  ppdi;
    LSA_OBJECT_ATTRIBUTES        loa;
    LSA_HANDLE                   hLsa = 0;

    loa.Length                    = sizeof(LSA_OBJECT_ATTRIBUTES);
    loa.RootDirectory             = NULL;
    loa.ObjectName                = NULL;
    loa.Attributes                = 0;
    loa.SecurityDescriptor        = NULL;
    loa.SecurityQualityOfService  = NULL;

    ntstatus = LsaOpenPolicy( NULL, &loa, POLICY_VIEW_LOCAL_INFORMATION, &hLsa );

    if( LSA_SUCCESS( ntstatus ) )
    {

        ntstatus = LsaQueryInformationPolicy( hLsa, 
                                              PolicyPrimaryDomainInformation,
                                              (VOID **) &ppdi );

        if( LSA_SUCCESS( ntstatus ) )
        {

            if( ppdi->Sid > 0 )
            {
                *bDomainMember = TRUE;
            }
            else
            {
                *bDomainMember = FALSE;
            }
            
            lstrcpyn( szName, ppdi->Name.Buffer, AS(szName) );

        }

        LsaClose( hLsa );

    }
    
    return( ntstatus );

}

//----------------------------------------------------------------------------
//
// Function: InitializeComInterface
//
// Purpose:  Obtains the INetCfgClass interface and enumerates all the 
//           components.  Handles cleanup of all interfaces if failure
//           returned.
//
// Arguments: 
//     const GUID* pGuid - pointer to GUID representing the class of
//          components represented by the returned pointer
//     INetCfg* pNetCfg - pointer to initialized INetCfg interface
//     INetCfgClass** ppNetCfgClass - output parameter pointing to 
//          the interface requested by the GUID
//     IEnumNetCfgComponent *pEnum - output param that points to an 
//          IEnumNetCfgComponent to get to each individual INetCfgComponent 
//     INetCfgComponent *arrayComp[MAX_NUM_NET_COMPONENTS] - array of all
//          the INetCfgComponents that correspond to the the given GUID
//     ULONG* pCount - the number of INetCfgComponents in the array
//
// Returns: HRESULT - returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static HRESULT 
InitializeComInterface( const GUID *pGuid,
                        INetCfg *pNetCfg,
                        INetCfgClass *pNetCfgClass,
                        IEnumNetCfgComponent *pEnum,
                        INetCfgComponent *arrayComp[MAX_NUM_NET_COMPONENTS],
                        ULONG* pCount )
{

    HRESULT hr;
    HRESULT TempHr;

    //
    // Obtain the INetCfgClass interface pointer
    //

    hr = GetClass( pGuid,
                   pNetCfg,
                   &pNetCfgClass );

    //
    //  Check validity of the pointer we got back from GetClass
    //

    TempHr = ChkInterfacePointer( pNetCfgClass, IID_INetCfgClass );

    if( FAILED( hr ) || FAILED( TempHr ) )
    {

        ReleaseInterfaces( pNetCfg );

        return( E_FAIL );

    }

    //
    // Retrieve the enumerator interface
    //

    hr = pNetCfgClass->EnumComponents( &pEnum );

    if( FAILED( hr ) ||
        FAILED( ChkInterfacePointer( pEnum, IID_IEnumNetCfgComponent ) ) )
    {

        if( pNetCfgClass )
        {
            pNetCfgClass->Release();
        }

        ReleaseInterfaces( pNetCfg );

        return( E_FAIL );

    }

    hr = pEnum->Next( MAX_NUM_NET_COMPONENTS, &arrayComp[0], pCount );

    if( FAILED( hr ) )
    {

        if( pEnum ) 
        {
            pEnum->Release();
        }

        if( pNetCfgClass ) 
        {
            pNetCfgClass->Release();
        }

        ReleaseInterfaces( pNetCfg );

        return( E_FAIL );

    }

    return( S_OK );

}

//----------------------------------------------------------------------------
//
// Function: UninitializeComInterface
//
// Purpose:  To release the Net Config object interfaces.
//
// Arguments: INetCfgClass *pNetCfgClass - the INetCfgClass to be released
//            IEnumNetCfgComponent *pEnum - the IEnumNetCfgComponent to be released
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID 
UninitializeComInterface( INetCfgClass *pNetCfgClass,
                          IEnumNetCfgComponent *pEnum ) 
{

    if( pNetCfgClass )
    {
        pNetCfgClass->Release();
    }

    if( pEnum )
    {
        pEnum->Release();
    }

}

//----------------------------------------------------------------------------
//
// Function: InitializeInterfaces
//
// Purpose:  Initializes COM, creates, and initializes the NetCfg
//
// Arguments:  INetCfg** ppNetCfg - output param that is the created and
//                 initialized INetCfg interface
//
// Returns: HRESULT - returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static HRESULT 
InitializeInterfaces( INetCfg** ppNetCfg )
{

    HRESULT hr = S_OK;

    hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE );

    if( FAILED( hr ) )
    {
        return( hr );
    }
    
    hr = CreateAndInitNetCfg( ppNetCfg );

    return( hr );

}

//----------------------------------------------------------------------------
//
// Function: CreateAndInitNetCfg
//
// Purpose:  Instantiate and initalize an INetCfg interface
//
// Arguments: INetCfg** ppNetCfg - output parameter that is the initialized
//                  INetCfg interface
//
// Returns: HRESULT - returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static HRESULT
CreateAndInitNetCfg( INetCfg** ppNetCfg )
{

    HRESULT     hr               = S_OK;
    INetCfg*    pNetCfg    = NULL;

    if( ( ppNetCfg == NULL ) ||
        IsBadWritePtr( ppNetCfg, sizeof(ppNetCfg) ) )
    {

        return( E_INVALIDARG );

    }

    *ppNetCfg = NULL;

    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_INPROC_SERVER,
                           IID_INetCfg, 
                           reinterpret_cast<LPVOID*>(&pNetCfg) );

    if( FAILED( hr ) )
    {
        return( hr );    
    }

    *ppNetCfg = pNetCfg;

    //
    // Initialize the INetCfg object.
    //

    hr = (*ppNetCfg)->Initialize( NULL );

    if( FAILED( hr ) )
    {

        (*ppNetCfg)->Release();
        
        CoUninitialize();

        return( hr );

    }

    return( hr );
    
}

//----------------------------------------------------------------------------
//
// Function: ReleaseInterfaces
//
// Purpose:  Uninitializes the NetCfg object and releases the interfaces 
//
// Arguments: INetCfg* pNetCfg - the INetCfg interface to be released
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID 
ReleaseInterfaces( INetCfg* pNetCfg )
{

    HRESULT     hr = S_OK;

    //
    // Check validity of the pNetCfg interface pointer
    //

    hr = ChkInterfacePointer( pNetCfg, IID_INetCfg );

    if( FAILED( hr ) )
    {
        return;
    }

    if( pNetCfg != NULL )
    {
        pNetCfg->Uninitialize();

        pNetCfg->Release();
    }

    CoUninitialize();

    return;

}

//----------------------------------------------------------------------------
//
// Function: ChkInterfacePointer
//
// Purpose:  Checks if an interface pointer is valid and if it can query itself
//
// Arguments:  IUnknown* pInterface - interface pointer to check
//             REFIID IID_IInterface - the IID of parameter 1
//
// Returns: HRESULT - returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static HRESULT 
ChkInterfacePointer( IUnknown* pInterface, REFIID IID_IInterface )
{

    HRESULT     hr             = S_OK;
    IUnknown*   pResInterface  = NULL;

    if( (pInterface == NULL) || IsBadReadPtr( pInterface, sizeof(pInterface) ) )
    {
        hr = E_INVALIDARG;

        return( hr );
    }

    hr = pInterface->QueryInterface( IID_IInterface, (void**)&pResInterface );

    if( FAILED( hr ) )
    {
        return( hr );
    }

    if( pInterface != pResInterface )
    {
        hr = E_FAIL;

        pResInterface->Release();

        return( hr );
    }

    pResInterface->Release();

    return( S_OK );

}

//----------------------------------------------------------------------------
//
// Function: GetClass
//
// Purpose:  Retrieves INetCfgClass for the specified pGuid
//
// Arguments: const GUID* pGuid - pointer to GUID representing the class of
//                   components represented by the returned pointer
//            INetCfg* pNetCfg - pointer to initialized INetCfg interface
//            INetCfgClass** ppNetCfgClass - output parameter pointing to 
//                   the interface requested by the GUID
//
// Returns: HRESULT - returns status of success or failure of the function
//
//----------------------------------------------------------------------------
static HRESULT
GetClass( const GUID* pGuid, INetCfg* pNetCfg, INetCfgClass** ppNetCfgClass )
{

    HRESULT         hr            = S_OK;
    INetCfgClass*   pNetCfgClass  = NULL;

    hr = ChkInterfacePointer( pNetCfg, IID_INetCfg );

    if( FAILED( hr ) )
    {
        return( E_INVALIDARG );
    }

    if( IsBadWritePtr( ppNetCfgClass, sizeof(ppNetCfgClass) ) )
    {
        return( E_INVALIDARG );
    }

    hr = pNetCfg->QueryNetCfgClass( pGuid, 
                                    IID_INetCfgClass, 
                                    (void**)&pNetCfgClass );

    if( FAILED( hr ) )
    {
        return( hr );
    }

    *ppNetCfgClass = pNetCfgClass;

    return( hr );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\exe\resource.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      resource.h
//
// Description:  
//      Contains the resource IDs for the setupmgr.rc file (that haven't
//      already been defined in the components sub-dir)
//      
//---------------------------------------------------------------------------

#define IDS_APPNAME     1
#define IDS_DLLERROR    2
#define IDS_VERERROR    3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\common\savefile.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      savefile.c
//
// Description:
//      The wizard pages plug in here to get there settings queued to
//      the answer file.  We read the globals in setupmgr.h and figure
//      out what needs to be written or deleted.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "allres.h"
#include "encrypt.h"
#include "optcomp.h"

//
// String constants
//

static const LPTSTR StrConstYes  = _T("Yes");
static const LPTSTR StrConstNo   = _T("No");
static const LPTSTR StrConstStar = _T("*");
static const LPTSTR StrComma     = _T(",");

//
// local prototypes
//

// NTRAID#NTBUG9-551746-2002/02/27-stelo,swamip - Unused code, should be removed
//
static VOID WriteOutOemBootFiles( VOID );
static VOID WriteOutMassStorageDrivers( VOID );

static VOID WriteOutTapiSettings(VOID);
static VOID WriteOutRegionalSettings(VOID);

static VOID WriteOutRemoteInstallSettings(VOID);

static VOID WriteOutIeSettings(VOID);

//
// Call out to savenet.c to save the network settings
//

extern VOID WriteOutNetSettings( HWND );

//----------------------------------------------------------------------------
//
// Function: QueueSettingsToAnswerFile
//
// Purpose: This function looks at the global structs that dlgprocs
//          have been scribbling into and queues up all the settings
//          in preparation to be written out to disk.
//
//          This function is called by the SaveScript page indirectly.
//          See common\save.c for details.
//
//          The answer file queue (and the .udf queue) is initialized
//          with the original settings in the answer file loaded near
//          the beginning of the wizard.
//
//          Ensure that you clear settings that should not be present
//          in the answer file.
//
// Arguments: VOID
//
// Returns: BOOL
//
//----------------------------------------------------------------------------

BOOL
QueueSettingsToAnswerFile(HWND hwnd)
{
    TCHAR *lpValue;
    TCHAR Buffer[MAX_INILINE_LEN];
   HRESULT hrPrintf;    

    //
    // Create each of the sections in the order we want them to appear
    // in the outputed answer file.
    //


    SettingQueue_AddSetting(
        _T("Data"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("SetupData"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("Unattended"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("GuiUnattended"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("UserData"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("Display"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("LicenseFilePrintData"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("TapiLocation"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("RegionalSettings"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("MassStorageDrivers"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("OEMBootFiles"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("OEM_Ads"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(
        _T("SetupMgr"), _T(""), _T(""), SETTING_QUEUE_ANSWERS);

    // Let networking go last, then remaining RIS sections



    //
    // Set the UnattendMode
    //

    lpValue = _T("");

    //
    //  Don't write out the Unattend Mode on a sysprep
    //
    if( WizGlobals.iProductInstall != PRODUCT_SYSPREP ) {

        switch ( GenSettings.iUnattendMode ) {

            case UMODE_GUI_ATTENDED:    lpValue = _T("GuiAttended");    break;
            case UMODE_PROVIDE_DEFAULT: lpValue = _T("ProvideDefault"); break;
            case UMODE_DEFAULT_HIDE:    lpValue = _T("DefaultHide");    break;
            case UMODE_READONLY:        lpValue = _T("ReadOnly");       break;
            case UMODE_FULL_UNATTENDED: lpValue = _T("FullUnattended"); break;

            default:
                AssertMsg(FALSE, "Bad case for UnattendMode");
                break;
        }

    }

    SettingQueue_AddSetting(_T("Unattended"),
                            _T("UnattendMode"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    //  Skip the EULA if they said 'yes' on the EULA page
    //
    if( GenSettings.bSkipEulaAndWelcome ) {

        SettingQueue_AddSetting(_T("Unattended"),
                                _T("OemSkipEula"),
                                StrConstYes,
                                SETTING_QUEUE_ANSWERS);
    }

    //
    // Write out OemPreInstall depending how user answer StandAlone page
    //

    if( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL )
        lpValue = StrConstNo;
    else if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
        lpValue = _T("");
    else
        lpValue = WizGlobals.bStandAloneScript ? StrConstNo : StrConstYes;

    SettingQueue_AddSetting(_T("Unattended"),
                            _T("OemPreinstall"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    // Write out the PnpDriver path that was computed in adddirs.c
    //

    SettingQueue_AddSetting(_T("Unattended"),
                            _T("OemPnPDriversPath"),
                            WizGlobals.OemPnpDriversPath,
                            SETTING_QUEUE_ANSWERS);

    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {

         TCHAR szDrive[MAX_PATH];
         TCHAR szSysprepPath[MAX_PATH] = _T("");

         ExpandEnvironmentStrings( _T("%SystemDrive%"), 
                                   szDrive, 
                                   MAX_PATH );

        // Note-ConcatenatePaths truncates to prevent overflow
         ConcatenatePaths( szSysprepPath,
                           szDrive,
                           _T("\\sysprep\\i386"),
                           NULL );


         SettingQueue_AddSetting(_T("Unattended"),
                                 _T("InstallFilesPath"),
                                 szSysprepPath,
                                 SETTING_QUEUE_ANSWERS);

    }

    //
    //  Don't write out the AutoPartition, MsDosInitiated and the
    //  UnattendedInstall keys on a sysprep install.
    //

    if( WizGlobals.iProductInstall != PRODUCT_SYSPREP )
    {

        SettingQueue_AddSetting(_T("Data"),
                                _T("AutoPartition"),
                                _T("1"),
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("Data"),
                                _T("MsDosInitiated"),
                                _T("\"0\""),
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("Data"),
                                _T("UnattendedInstall"),
                                _T("\"Yes\""),
                                SETTING_QUEUE_ANSWERS);

    }


    //
    // Product ID
    //

    Buffer[0] = _T('\0');

    if ( GenSettings.ProductId[0][0] != _T('\0') ) {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer),
                  _T("%s-%s-%s-%s-%s"),
                  GenSettings.ProductId[0],
                  GenSettings.ProductId[1],
                  GenSettings.ProductId[2],
                  GenSettings.ProductId[3],
                  GenSettings.ProductId[4]);
    }

    SettingQueue_AddSetting(_T("UserData"),
                            _T("ProductKey"),
                            Buffer,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("UserData"),
                            _T("ProductId"),
                            NULLSTR,
                            SETTING_QUEUE_ANSWERS);

    //
    // Username & org
    //

    {
        TCHAR   szName[MAX_PATH],
                szOrg[MAX_PATH];

        hrPrintf=StringCchPrintf(szName, AS(szName), _T("\"%s\""), GenSettings.UserName);
        hrPrintf=StringCchPrintf(szOrg, AS(szOrg), _T("\"%s\""), GenSettings.Organization);

        SettingQueue_AddSetting(_T("UserData"),
                                _T("FullName"),
                                szName,
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("UserData"),
                                _T("OrgName"),
                                szOrg,
                                SETTING_QUEUE_ANSWERS);
    }

#ifdef OPTCOMP

    //
    // Write out the windows component settings only if doing an unattended installation
    //
    if ( WizGlobals.iProductInstall == PRODUCT_UNATTENDED_INSTALL )
    {
        DWORD   dwIndex;
        BOOL    bInstallComponent = FALSE;

        // Iterate through each component and determine if we should install
        //
        for (dwIndex=0;dwIndex<AS(s_cComponent);dwIndex++)
        {
            // Determine if the component should be installed and write out proper setting
            //
            bInstallComponent = (GenSettings.dwWindowsComponents & s_cComponent[dwIndex].dwComponent) ? TRUE : FALSE;
            SettingQueue_AddSetting(_T("Components"), s_cComponent[dwIndex].lpComponentString, (bInstallComponent ? _T("On") : _T("Off")), SETTING_QUEUE_ANSWERS);
        }
    }
#endif

    //
    //  Write out IE settings
    //

    WriteOutIeSettings();

    //
    // Set the [LicenseFilePrintData] section.
    //
    // Note that we'll allow changing product type between workstation and
    // server on an edit, so be sure to clear these settings in case we're
    // changing from server to workstation.
    //

    {
        TCHAR *pAutoMode  = _T("");
        TCHAR *pAutoUsers = _T("");

        if ( WizGlobals.iPlatform == PLATFORM_SERVER || WizGlobals.iPlatform == PLATFORM_ENTERPRISE || WizGlobals.iPlatform == PLATFORM_WEBBLADE) {
            if ( GenSettings.bPerSeat ) {
                pAutoMode = _T("PerSeat");
            } else {
                pAutoMode = _T("PerServer");
                hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("%d"), GenSettings.NumConnections);
                pAutoUsers = Buffer;
            }
        }

        SettingQueue_AddSetting(_T("LicenseFilePrintData"),
                                _T("AutoMode"),
                                pAutoMode,
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("LicenseFilePrintData"),
                                _T("AutoUsers"),
                                pAutoUsers,
                                SETTING_QUEUE_ANSWERS);
    }

    //
    // Computer name(s).
    //
    // ComputerName=* means setup should autogenerate a name
    //

    {
        INT    nEntries = GetNameListSize(&GenSettings.ComputerNames);
        INT    i;
        LPTSTR pName;

        //
        // Figure out computername setting.  Make sure it is not present
        // in the case of multiple computer names.
        //
        if ( (GenSettings.bAutoComputerName && GenSettings.Organization[0]) || ( nEntries > 1 ) )
            pName = StrConstStar;
        else if ( nEntries == 1 )
            pName = GetNameListName(&GenSettings.ComputerNames, 0);
        else
            pName = _T("");

        SettingQueue_AddSetting(_T("UserData"),
                                _T("ComputerName"),
                                pName,
                                SETTING_QUEUE_ANSWERS);

        //
        // If multiple computer names, we need to queue the proper settings
        // to the .udf.
        //
        // ISSUE-2002/02/27-stelo -Should read the .udf instead of saving in [SetupMgr]
        //
        // Here is a sample udf
        //      [UniqueIds]
        //          foo0=UserData
        //          foo1=UserData
        //
        //      [foo0:UserData]
        //          ComputerName=foo0
        //
        //      [foo1:UserData]
        //          ComputerName=foo1
        //

        if ( nEntries > 1 ) {

            for ( i=0; i<nEntries; i++ ) {

                pName = GetNameListName(&GenSettings.ComputerNames, i);

                hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("ComputerName%d"), i);

                SettingQueue_AddSetting(_T("SetupMgr"),
                                        Buffer,
                                        pName,
                                        SETTING_QUEUE_ANSWERS);

                //
                // Write the UniqueIds entry to the udf
                //

                SettingQueue_AddSetting(_T("UniqueIds"),
                                        pName,
                                        _T("UserData"),
                                        SETTING_QUEUE_UDF);

                //
                // Now write the foo0:UserData section for this pName
                //

                hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("%s:UserData"), pName);

                SettingQueue_AddSetting(Buffer,
                                        _T("ComputerName"),
                                        pName,
                                        SETTING_QUEUE_UDF);
            }
        }
    }

    //
    // Targetpath
    //

    if ( GenSettings.iTargetPath == TARGPATH_WINNT )
        lpValue = _T("\\WINDOWS");
    else if ( GenSettings.iTargetPath == TARGPATH_SPECIFY )
        lpValue = GenSettings.TargetPath;
    else if ( GenSettings.iTargetPath == TARGPATH_AUTO )
        lpValue = StrConstStar;
    else
        lpValue = _T("");

    SettingQueue_AddSetting(_T("Unattended"),
                            _T("TargetPath"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    //  Write out the HAL to be used
    //

    //  ISSUE-2002/02/27-stelo -There are spaces in the friendly name so it gets quoted but I assume
    //    the ,OEM has to be outside the quotes
    if( GenSettings.szHalFriendlyName[0] != _T('\0') ) {
        hrPrintf=StringCchPrintf( Buffer, AS(Buffer), _T("\"%s\",OEM"), GenSettings.szHalFriendlyName );

        SettingQueue_AddSetting(_T("Unattended"),
                                _T("ComputerType"),
                                Buffer,
                                SETTING_QUEUE_ANSWERS);
    }

    WriteOutMassStorageDrivers();

    WriteOutOemBootFiles();

    //
    //  Write out OEM Ads Logo and Background bitmaps
    //

    if ( ! (lpValue = MyGetFullPath( GenSettings.lpszLogoBitmap ) ) )
        lpValue = _T("");

    SettingQueue_AddSetting(_T("OEM_Ads"),
                            _T("Logo"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    if ( ! (lpValue = MyGetFullPath( GenSettings.lpszBackgroundBitmap ) ) )
        lpValue = _T("");

    SettingQueue_AddSetting(_T("OEM_Ads"),
                            _T("Background"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    // Admin password
    //

    if ( GenSettings.bSpecifyPassword ) 
    {
        if ( GenSettings.AdminPassword[0] )
        {
            lpValue = GenSettings.AdminPassword;
            // See if we should encrypt the admin password
            if (GenSettings.bEncryptAdminPassword)
            {
                TCHAR owfPwd[STRING_ENCODED_PASSWORD_SIZE];

                if (StringEncodeOwfPassword (lpValue, owfPwd, NULL)) 
                {
                    lpValue = (LPTSTR) owfPwd;
                } 
                else 
                {
                    // Error Case. Popup up a message box asking if the user
                    // wants to continue using an non-encrypted password
                    int iRet = ReportErrorId(hwnd,
                                             MSGTYPE_YESNO,
                                             IDS_ERR_PASSWORD_ENCRYPT_FAILED);

                    if ( iRet == IDYES ) 
                    {
                        GenSettings.bEncryptAdminPassword  = FALSE;
                    }
                    else
                    {
                        SetLastError(ERROR_CANCELLED);
                        return FALSE;
                    }
                }
            }
            // Now make sure that the password is surrounded by quotes (if it hasn't been encrypted)
            //
            if (!GenSettings.bEncryptAdminPassword)
            {
                TCHAR szTemp[MAX_PASSWORD + 3];  // +3 is for surrounding quotes and terminating '\0"
                lstrcpyn(szTemp, GenSettings.AdminPassword,AS(szTemp));
                hrPrintf=StringCchPrintf(GenSettings.AdminPassword,AS(GenSettings.AdminPassword), _T("\"%s\""), szTemp);
            }
        }
        else
        {
            lpValue = StrConstStar;             // blank password
            GenSettings.bEncryptAdminPassword = FALSE; // Cannot encrypt a blank password
        }            
    }
    else
    {
        lpValue = _T("");                          // prompt user
        GenSettings.bEncryptAdminPassword = FALSE; // Cannot encrypt nothing
    }
     
    SettingQueue_AddSetting(_T("GuiUnattended"),
                            _T("AdminPassword"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);
    // set the value in the answer file indicating that 
    // state of the admin password
    SettingQueue_AddSetting(_T("GuiUnattended"),
                            _T("EncryptedAdminPassword"),
                            GenSettings.bEncryptAdminPassword ? _T("Yes") : _T("NO"),
                            SETTING_QUEUE_ANSWERS);
    {

        TCHAR *lpAutoLogonCount;

        if( GenSettings.bAutoLogon )
        {
            lpValue = StrConstYes;

            hrPrintf=StringCchPrintf( Buffer, AS(Buffer), _T("%d"), GenSettings.nAutoLogonCount );

            lpAutoLogonCount = Buffer;
        }
        else
        {
            lpValue = _T("");

            lpAutoLogonCount= _T("");
        }

        SettingQueue_AddSetting(_T("GuiUnattended"),
                                _T("AutoLogon"),
                                lpValue,
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("GuiUnattended"),
                                _T("AutoLogonCount"),
                                lpAutoLogonCount,
                                SETTING_QUEUE_ANSWERS);

    }

    //
    //  Write out whether to show Regional Settings pages in NT setup
    //

    lpValue = _T("");

    //
    //  If they didn't do advanced pages and 
    //

    if( ! WizGlobals.bDoAdvancedPages ) {

        if( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED ) {

            lpValue = _T("1");

        }

    }
    else {

        switch( GenSettings.iRegionalSettings ) {

            case REGIONAL_SETTINGS_NOT_SPECIFIED:

                AssertMsg(FALSE, "User went to the regional settings page but regional settings data never got set.");

                break;

            case REGIONAL_SETTINGS_SKIP:

                lpValue = _T("0");
                break;

            case REGIONAL_SETTINGS_DEFAULT:
            case REGIONAL_SETTINGS_SPECIFY:

                lpValue = _T("1");
                break;

            default:
                AssertMsg(FALSE, "Bad case for Regional Settings");
                break;

        }

    }

    SettingQueue_AddSetting(_T("GuiUnattended"),
                            _T("OEMSkipRegional"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    //  Write out Sysprep OEM Duplicator string
    //

    lpValue = _T("");

    if ( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
        lpValue = GenSettings.szOemDuplicatorString;

    SettingQueue_AddSetting(_T("GuiUnattended"),
                            _T("OEMDuplicatorstring"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    // Display settings
    //

    lpValue = _T("");

    if ( GenSettings.DisplayColorBits >= 0 ) {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("%d"), GenSettings.DisplayColorBits);
        lpValue = Buffer;
    }

    SettingQueue_AddSetting(_T("Display"),
                            _T("BitsPerPel"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    lpValue = _T("");

    if ( GenSettings.DisplayXResolution >= 0 ) {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("%d"), GenSettings.DisplayXResolution);
        lpValue = Buffer;
    }

    SettingQueue_AddSetting(_T("Display"),
                            _T("Xresolution"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    lpValue = _T("");

    if ( GenSettings.DisplayYResolution >= 0 ) {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("%d"), GenSettings.DisplayYResolution);
        lpValue = Buffer;
    }

    SettingQueue_AddSetting(_T("Display"),
                            _T("YResolution"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    lpValue = _T("");

    if ( GenSettings.DisplayRefreshRate >= 0 ) {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("%d"), GenSettings.DisplayRefreshRate);
        lpValue = Buffer;
    }

    SettingQueue_AddSetting(_T("Display"),
                            _T("Vrefresh"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    // RunOnce commands
    //

    {
        TCHAR  szCommandLineBuffer[MAX_INILINE_LEN + 1];
        INT    nEntries = GetNameListSize(&GenSettings.RunOnceCmds);
        INT    i;
        LPTSTR pName;

        for ( i=0; i<nEntries; i++ )
        {
            hrPrintf=StringCchPrintf(Buffer,AS(Buffer), _T("Command%d"), i);

            pName = GetNameListName(&GenSettings.RunOnceCmds, i);

            //
            //  Force the command line to always be quoted
            //
            hrPrintf=StringCchPrintf( szCommandLineBuffer,AS(szCommandLineBuffer), _T("\"%s\""), pName );

            SettingQueue_AddSetting(_T("GuiRunOnce"),
                                    Buffer,
                                    pName,
                                    SETTING_QUEUE_ANSWERS);
        }
    }

    //
    // Timezone
    //

    // Must handle the case that the user never went to the timezone page
    //
    if ( GenSettings.TimeZoneIdx == TZ_IDX_UNDEFINED )
    {
        if ( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL )
            GenSettings.TimeZoneIdx = TZ_IDX_SETSAMEASSERVER;
        else
            GenSettings.TimeZoneIdx = TZ_IDX_DONOTSPECIFY;
    }

    if( GenSettings.TimeZoneIdx == TZ_IDX_SETSAMEASSERVER ) 
        lpValue = _T("%TIMEZONE%");
    else if ( GenSettings.TimeZoneIdx == TZ_IDX_DONOTSPECIFY )
        lpValue = _T("");
    else {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer),_T("%d"), GenSettings.TimeZoneIdx);
        lpValue = Buffer;
    }

    SettingQueue_AddSetting(_T("GuiUnattended"),
                            _T("TimeZone"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    //  Skip the Welcome page if they said 'yes' on the EULA page
    //
    if( GenSettings.bSkipEulaAndWelcome ) {

        SettingQueue_AddSetting(_T("GuiUnattended"),
                                _T("OemSkipWelcome"),
                                _T("1"),
                                SETTING_QUEUE_ANSWERS);
    }

    //
    // Write out the distribution share to the [SetupMgr] section so
    // that we remember it on an edit.
    //

    if( WizGlobals.bStandAloneScript ) {
        lpValue = _T("");
    }
    else {
        lpValue = WizGlobals.DistFolder;
    }

    SettingQueue_AddSetting(_T("SetupMgr"),
                            _T("DistFolder"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    lpValue = !WizGlobals.bStandAloneScript ? WizGlobals.DistShareName : _T("");

    SettingQueue_AddSetting(_T("SetupMgr"),
                            _T("DistShare"),
                            lpValue,
                            SETTING_QUEUE_ANSWERS);

    //
    // Write out [Identification] section
    //

    {
        LPTSTR lpWorkgroup     = _T("");
        LPTSTR lpDomain        = _T("");
        LPTSTR lpAdmin         = _T("");
        LPTSTR lpPassword      = _T("");

        if( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL ) {

            lpDomain        = _T("%MACHINEDOMAIN%");

        } else if ( NetSettings.bWorkgroup ) {

            lpWorkgroup     = NetSettings.WorkGroupName;

        } else {

            lpDomain        = NetSettings.DomainName;

            if ( NetSettings.bCreateAccount ) {
                lpAdmin         = NetSettings.DomainAccount;
                lpPassword      = NetSettings.DomainPassword;
            }

        }

        SettingQueue_AddSetting(_T("Identification"),
                                _T("JoinWorkgroup"),
                                lpWorkgroup,
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("Identification"),
                                _T("JoinDomain"),
                                lpDomain,
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("Identification"),
                                _T("DomainAdmin"),
                                lpAdmin,
                                SETTING_QUEUE_ANSWERS);

        SettingQueue_AddSetting(_T("Identification"),
                                _T("DomainAdminPassword"),
                                lpPassword,
                                SETTING_QUEUE_ANSWERS);
    }

    //
    //  Write out network settings
    //

    WriteOutNetSettings( hwnd );

    //
    // TAPI and regional settings
    //

    WriteOutTapiSettings();
    WriteOutRegionalSettings();

    //
    // Write out the remaining RIS specific settings
    //

    if( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL ) {

        WriteOutRemoteInstallSettings();

    }

    return TRUE;
}

//
// NTRAID#NTBUG9-551746-2002/02/27-stelo,swamip - Unused code, should be removed
//

//----------------------------------------------------------------------------
//
// Function: WriteOutMassStorageDrivers
//
// Purpose:  
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
WriteOutMassStorageDrivers( VOID ) {

    INT   i;
    TCHAR *lpValue;
    INT   iEntries = GetNameListSize( &GenSettings.MassStorageDrivers );

    for( i = 0; i < iEntries; i++ ) {

        lpValue = GetNameListName( &GenSettings.MassStorageDrivers, i );

        SettingQueue_AddSetting(_T("MassStorageDrivers"),
                                lpValue,
                                _T("OEM"),
                                SETTING_QUEUE_ANSWERS);
    }

}

//
// NTRAID#NTBUG9-551746-2002/02/27-stelo,swamip - Unused code, should be removed
//
//----------------------------------------------------------------------------
//
// Function: WriteOutOemBootFiles
//
// Purpose:  Write out OEM Boot files (this includes the filenames for the
//           HAL and SCSI drivers)
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
WriteOutOemBootFiles( VOID ) {

    INT   i;
    TCHAR *lpValue;
    INT   iHalEntries  = GetNameListSize( &GenSettings.OemHalFiles );
    INT   iScsiEntries = GetNameListSize( &GenSettings.OemScsiFiles );

    if( iHalEntries != 0 || iScsiEntries != 0 ) {

        //
        //  Write out the txtsetup.oem file
        //
        SettingQueue_AddSetting(_T("OEMBootFiles"),
                                _T(""),
                                OEM_TXTSETUP_NAME,
                                SETTING_QUEUE_ANSWERS);

        //
        //  Write out all the HAL and SCSI files
        //
        for( i = 0; i < iHalEntries; i++ ) {

            lpValue = GetNameListName( &GenSettings.OemHalFiles, i );

            SettingQueue_AddSetting(_T("OEMBootFiles"),
                                    _T(""),
                                    lpValue,
                                    SETTING_QUEUE_ANSWERS);

        }

        for( i = 0; i < iScsiEntries; i++ ) {
        
            lpValue = GetNameListName( &GenSettings.OemScsiFiles, i );

            SettingQueue_AddSetting(_T("OEMBootFiles"),
                                    _T(""),
                                    lpValue,
                                    SETTING_QUEUE_ANSWERS);

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: WriteOutTapiSettings
//
// Purpose: Queue up the remaining settings that need to be in the
//          answerfile tapi settings.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
WriteOutTapiSettings( VOID ) {

    TCHAR Buffer[MAX_INILINE_LEN];
    TCHAR *lpValue;
   HRESULT hrPrintf;

    //
    // Set or clear the country code.  If user selected DONTSPECIFY, be
    // sure the setting is removed.
    //

    Buffer[0] = _T('\0');

    if( GenSettings.dwCountryCode != DONTSPECIFYSETTING )
    {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer),_T("%d"), GenSettings.dwCountryCode);
    }

    SettingQueue_AddSetting(_T("TapiLocation"),
                            _T("CountryCode"),
                            Buffer,
                            SETTING_QUEUE_ANSWERS);

    //
    // Set or clear the dialing method.  Make sure it is cleared if "Don't
    // specify setting" was selected.
    //

    if ( GenSettings.iDialingMethod == TONE )
        lpValue = _T("Tone");
    else if ( GenSettings.iDialingMethod == PULSE )
        lpValue = _T("Pulse");
    else
        lpValue = _T("");

    SettingQueue_AddSetting( _T("TapiLocation"),
                             _T("Dialing"),
                             lpValue,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("TapiLocation"),
                             _T("AreaCode"),
                             GenSettings.szAreaCode,
                             SETTING_QUEUE_ANSWERS );

    Buffer[0] = _T('\0');

    if( GenSettings.szOutsideLine[0] != _T('\0') )
    {
        hrPrintf=StringCchPrintf( Buffer,AS(Buffer), _T("\"%s\""), GenSettings.szOutsideLine );
    }

    SettingQueue_AddSetting( _T("TapiLocation"),
                             _T("LongDistanceAccess"),
                             Buffer,
                             SETTING_QUEUE_ANSWERS );
}

//----------------------------------------------------------------------------
//
// Function: WriteOutRegionalSettings
//
// Purpose: Queue up the remaining settings that need to be in the
//          answerfile regional settings.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
WriteOutRegionalSettings( VOID ) {

    TCHAR Buffer[MAX_INILINE_LEN]  = _T("");

    LPTSTR lpLanguageGroup         = _T("");
    LPTSTR lpLanguage              = _T("");
    LPTSTR lpSystemLocale          = _T("");
    LPTSTR lpUserLocale            = _T("");
    LPTSTR lpInputLocale           = _T("");

    if( GenSettings.iRegionalSettings == REGIONAL_SETTINGS_SPECIFY ) {

        if( GenSettings.bUseCustomLocales ) {

            lpSystemLocale = GenSettings.szMenuLanguage;

            lpUserLocale = GenSettings.szNumberLanguage;

            lpInputLocale = GenSettings.szKeyboardLayout;

        }
        else {

            lpLanguage = GenSettings.szLanguage;

        }

    }

    if( GetNameListSize( &GenSettings.LanguageGroups ) > 0 ) {

        NamelistToCommaString( &GenSettings.LanguageGroups, Buffer, AS(Buffer) );

        lpLanguageGroup = Buffer;

    }

    SettingQueue_AddSetting(_T("RegionalSettings"),
                            _T("LanguageGroup"),
                            lpLanguageGroup,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("RegionalSettings"),
                            _T("Language"),
                            lpLanguage,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("RegionalSettings"),
                            _T("SystemLocale"),
                            lpSystemLocale,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("RegionalSettings"),
                            _T("UserLocale"),
                            lpUserLocale,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("RegionalSettings"),
                            _T("InputLocale"),
                            lpInputLocale,
                            SETTING_QUEUE_ANSWERS);

}

//----------------------------------------------------------------------------
//
// Function: WriteOutRemoteInstallSettings
//
// Purpose: Queue up the remaining settings that need to be in the
//          answerfile for a remote install to work.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------


//
// Some long string constants used by this function
//

#define RIS_ORISRC     _T("\"\\\\%SERVERNAME%\\RemInst\\%INSTALLPATH%\"")

#define RIS_SRCDEVICE  _T("\"\\Device\\LanmanRedirector\\") \
                       _T("%SERVERNAME%\\RemInst\\%INSTALLPATH%\"")

#define RIS_LAUNCHFILE _T("\"%INSTALLPATH%\\%MACHINETYPE%\\templates\\startrom.com\"")


static VOID 
WriteOutRemoteInstallSettings(VOID)
{

    SettingQueue_AddSetting(_T("Data"),
                            _T("floppyless"),
                            _T("\"1\""),
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Data"),
                            _T("msdosinitiated"),
                            _T("\"1\""),
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Data"),
                            _T("OriSrc"),
                            RIS_ORISRC,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Data"),
                            _T("OriTyp"),
                            _T("\"4\""),
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Data"),
                            _T("LocalSourceOnCD"),
                            _T("1"),
                            SETTING_QUEUE_ANSWERS);
    //
    // [SetupData] section.  This section is only written out if RIS.
    //

    SettingQueue_AddSetting(_T("SetupData"),
                            _T("OsLoadOptions"),
                            _T("/noguiboot /fastdetect"),
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("SetupData"),
                            _T("SetupSourceDevice"),
                            RIS_SRCDEVICE,
                            SETTING_QUEUE_ANSWERS);

    //
    // Write some RIS specific settings to [Unattended].  Only write settings
    // that QueueSettingsToAnswerFile() does not write.
    //
    // RIS requires these settings to be present in the .sif and requires
    // them to have a fixed value.  We will not preserve the value we read
    // on an edit (in case user changed it by hand).
    //

    SettingQueue_AddSetting(_T("Unattended"),
                            _T("FileSystem"),
                            _T("LeaveAlone"),
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Unattended"),
                            _T("NtUpgrade"),
                            StrConstNo,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Unattended"),
                            _T("OverwriteOemFilesOnUpgrade"),
                            StrConstNo,
                            SETTING_QUEUE_ANSWERS);

    //
    // Additional settings for
    //      [RemoteInstall]
    //      [Display]
    //      [Networking]
    //      [Identification]
    //      [OSChooser]
    //

    SettingQueue_AddSetting(_T("RemoteInstall"),
                            _T("Repartition"),
                            StrConstYes,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Networking"),
                            _T("ProcessPageSections"),
                            StrConstYes,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("Identification"),
                            _T("DoOldStyleDomainJoin"),
                            StrConstYes,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("OSChooser"),
                            _T("Description"),
                            GenSettings.szSifDescription,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("OSChooser"),
                            _T("Help"),
                            GenSettings.szSifHelpText,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("OSChooser"),
                            _T("LaunchFile"),
                            RIS_LAUNCHFILE,
                            SETTING_QUEUE_ANSWERS);

    SettingQueue_AddSetting(_T("OSChooser"),
                            _T("ImageType"),
                            _T("Flat"),
                            SETTING_QUEUE_ANSWERS);

}

//
//  Write out the IE Favorites
//
static VOID
WriteOutIeFavorites( VOID )
{
    INT    nEntries = GetNameListSize( &GenSettings.Favorites );
    INT    i;
    INT    iEntryNumber;
    LPTSTR pFriendlyName;
    LPTSTR pWebAddress;
    TCHAR  Key[MAX_INILINE_LEN + 1];
    TCHAR  Value[MAX_INILINE_LEN + 1];
    HRESULT hrPrintf;

    // ISSUE-2002/02/27-stelo - make sure to clear the entries if they are no favorites

    for( i = 0; i < nEntries; i = i + 2 )
    {

        iEntryNumber = ( i / 2 ) + 1;

        pFriendlyName = GetNameListName( &GenSettings.Favorites, i );

        pWebAddress = GetNameListName( &GenSettings.Favorites, i + 1 );

        hrPrintf=StringCchPrintf( Key,AS(Key),
                   _T("Title%d"),
                   iEntryNumber );

        //
        //  Always quote the friendly name
        //

        hrPrintf=StringCchPrintf( Value,AS(Value),
                   _T("\"%s.url\""),
                   pFriendlyName );

        SettingQueue_AddSetting( _T("FavoritesEx"),
                                 Key,
                                 Value,
                                 SETTING_QUEUE_ANSWERS );

        hrPrintf=StringCchPrintf( Key,AS(Key),
                   _T("URL%d"),
                   iEntryNumber );

        //
        //  Always quote the web address
        //

        hrPrintf=StringCchPrintf( Value,AS(Value),
                   _T("\"%s\""),
                   pWebAddress );

        SettingQueue_AddSetting( _T("FavoritesEx"),
                                 Key,
                                 Value,
                                 SETTING_QUEUE_ANSWERS );
    }
}

static LPTSTR 
AllocateAddressPortString( LPTSTR lpszAddressString, LPTSTR lpszPortString )
{
    LPTSTR lpszAddressPortString;
    int iAddressPortStringLen;
    HRESULT hrCat;

    iAddressPortStringLen=(lstrlen(lpszAddressString) + lstrlen(lpszPortString) + 2);
    lpszAddressPortString = MALLOC(iAddressPortStringLen * sizeof(TCHAR) );
    if ( lpszAddressPortString )
    {
        lstrcpyn( lpszAddressPortString, lpszAddressString, iAddressPortStringLen);

        if ( *lpszPortString )
        {
            hrCat=StringCchCat( lpszAddressPortString, iAddressPortStringLen, _T(":") );
            hrCat=StringCchCat( lpszAddressPortString, iAddressPortStringLen, lpszPortString );
        }
    }

    return lpszAddressPortString;
}

//----------------------------------------------------------------------------
//
// Function: WriteOutIeSettings
//
// Purpose: Queue up the answerfile settings for IE.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
WriteOutIeSettings( VOID )
{
    LPTSTR lpIeBrandingFile               = _T("");
    LPTSTR lpAutoConfig                   = _T("");
    LPTSTR lpAutoConfigUrl                = _T("");
    LPTSTR lpAutoConfigUrlJscript         = _T("");
    LPTSTR lpUseProxyServer               = _T("");
    LPTSTR lpUseSameProxyForAllProtocols  = _T("");
    LPTSTR lpProxyExceptions              = _T("");
    LPTSTR lpHomePage                     = _T("");
    LPTSTR lpHelpPage                     = _T("");
    LPTSTR lpSearchPage                   = _T("");
    LPTSTR lpHttpProxy                    = NULL;
    LPTSTR lpSecureProxy                  = NULL;
    LPTSTR lpFtpProxy                     = NULL;
    LPTSTR lpGopherProxy                  = NULL;
    LPTSTR lpSocksProxy                   = NULL;

    LPTSTR lpUseUnattendFileForBranding   = _T("Yes");
    HRESULT hrCat;

    if( GenSettings.IeCustomizeMethod == IE_NO_CUSTOMIZATION )
    {
        //
        //  Don't write out any IE keys when the choose not to customize IE
        //

        return;
    }
    else if( GenSettings.IeCustomizeMethod == IE_USE_BRANDING_FILE )
    {

        lpIeBrandingFile = GenSettings.szInsFile;

        lpUseUnattendFileForBranding = _T("No");

        //
        //  Write out the Auto Config settings
        //

        if( GenSettings.bUseAutoConfigScript )
        {

            lpAutoConfig = _T("1");

            lpAutoConfigUrl = GenSettings.szAutoConfigUrl;

            lpAutoConfigUrlJscript = GenSettings.szAutoConfigUrlJscriptOrPac;

        }
        else
        {
            lpAutoConfig = _T("0");
        }

    }

    //
    //  Write out the proxy settings
    //

    if( GenSettings.bUseProxyServer )
    {
        lpUseProxyServer = _T("1");
    }
    else
    {
        lpUseProxyServer = _T("0");
    }

    if( GenSettings.bUseSameProxyForAllProtocols )
    {

        lpUseSameProxyForAllProtocols = _T("1");
    }
    else
    {
        lpUseSameProxyForAllProtocols = _T("0");
    }

    //
    //  For each proxy server, if the port is not empty concatenate it.
    //
    lpHttpProxy = AllocateAddressPortString( GenSettings.szHttpProxyAddress, GenSettings.szHttpProxyPort );

    //
    //  Only write out the proxy server if they aren't using the same one
    //

    if( ! GenSettings.bUseSameProxyForAllProtocols )
    {
        lpSecureProxy = AllocateAddressPortString( GenSettings.szSecureProxyAddress, GenSettings.szSecureProxyPort );

        lpFtpProxy    = AllocateAddressPortString( GenSettings.szFtpProxyAddress, GenSettings.szFtpProxyPort );

        lpGopherProxy = AllocateAddressPortString( GenSettings.szGopherProxyAddress, GenSettings.szGopherProxyPort );

        lpSocksProxy  = AllocateAddressPortString( GenSettings.szSocksProxyAddress, GenSettings.szSocksProxyPort );
    }

    //
    //  Append the string <local> to the exception list if the user wants to
    //  bypass the proxy for local addresses
    //

    if( GenSettings.bBypassProxyForLocalAddresses )
    {

        if( GenSettings.szProxyExceptions[0] != _T('\0') )
        {

            INT iLastChar;

            iLastChar = lstrlen( GenSettings.szProxyExceptions );

            if( GenSettings.szProxyExceptions[iLastChar - 1] != _T(';') )
            {
                hrCat=StringCchCat( GenSettings.szProxyExceptions, AS(GenSettings.szProxyExceptions),_T(";") );
            }

        }

        hrCat=StringCchCat( GenSettings.szProxyExceptions, AS(GenSettings.szProxyExceptions),_T("<local>") );

    }

    lpProxyExceptions = GenSettings.szProxyExceptions;

    lpHomePage = GenSettings.szHomePage;

    lpHelpPage = GenSettings.szHelpPage;

    lpSearchPage = GenSettings.szSearchPage;

    //
    // Write out the IE Favorites...
    //
    WriteOutIeFavorites( );

    SettingQueue_AddSetting( _T("Branding"),
                             _T("BrandIEUsingUnattended"),
                             lpUseUnattendFileForBranding,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Branding"),
                             _T("IEBrandingFile"),
                             lpIeBrandingFile,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("URL"),
                             _T("AutoConfig"),
                             lpAutoConfig,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("URL"),
                             _T("AutoConfigURL"),
                             lpAutoConfigUrl,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("URL"),
                             _T("AutoConfigJSURL"),
                             lpAutoConfigUrlJscript,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("Proxy_Enable"),
                             lpUseProxyServer,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("Use_Same_Proxy"),
                             lpUseSameProxyForAllProtocols,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("HTTP_Proxy_Server"),
                             lpHttpProxy ? lpHttpProxy : _T(""),
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("Secure_Proxy_Server"),
                             lpSecureProxy ? lpSecureProxy : _T(""),
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("FTP_Proxy_Server"),
                             lpFtpProxy ? lpFtpProxy : _T(""),
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("Gopher_Proxy_Server"),
                             lpGopherProxy ? lpGopherProxy : _T(""),
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("Socks_Proxy_Server"),
                             lpSocksProxy ? lpSocksProxy : _T(""),
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("Proxy"),
                             _T("Proxy_Override"),
                             lpProxyExceptions,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("URL"),
                             _T("Home_Page"),
                             lpHomePage,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("URL"),
                             _T("Help_Page"),
                             lpHelpPage,
                             SETTING_QUEUE_ANSWERS );

    SettingQueue_AddSetting( _T("URL"),
                             _T("Search_Page"),
                             lpSearchPage,
                             SETTING_QUEUE_ANSWERS );

    //
    // Free any memory we may have allocated...
    //
    if ( lpHttpProxy )
        FREE ( lpHttpProxy );

    if ( lpSecureProxy )
        FREE ( lpSecureProxy );

    if ( lpFtpProxy )
        FREE ( lpFtpProxy );

    if ( lpGopherProxy )
        FREE ( lpGopherProxy );

    if ( lpSocksProxy )
        FREE ( lpSocksProxy );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\common\save.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      save.c
//
// Description:
//      This file has the code that dumps the user's answers to the
//      answer file.
//
//      The entry point SaveAllSettings() is called by the wizard when
//      it is time to save the answer file (and possibly the .udf and
//      sample batch script).
//
//      The global vars GenSettings, NetSettings, etc. are examined
//      and we decide what [Section] key=value settings need to be
//      written.
//
//      If you're adding a page to this wizard, see the function
//      QueueSettingsToAnswerFile().
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "allres.h"


#define FILE_DOT_UDB                _T(".udb")

//
// local prototypes
//

static BOOL IsOkToOverwriteFiles(HWND hwnd);
static BOOL BuildAltFileNames(HWND hwnd);
static BOOL WriteSampleBatchScript(HWND hwnd);

static VOID QuoteStringIfNecessary( OUT TCHAR *szOutputString, 
                                    IN const TCHAR* const szInputString,
                                    IN DWORD cbSize);

//
// Localized "Usage" string
//

static TCHAR *StrUsage = NULL;

//
// External function in savefile.c
//

extern BOOL QueueSettingsToAnswerFile(HWND hwnd);

BOOL SettingQueueHalScsi_Flush(LPTSTR   lpFileName,
                               QUEUENUM dwWhichQueue);

static TCHAR *StrSampleBatchScriptLine1    = NULL;
static TCHAR *StrSampleBatchScriptLine2    = NULL;
static TCHAR *StrBatchScriptSysprepWarning = NULL;

//----------------------------------------------------------------------------
//
// Function: SetCdRomPath
//
// Purpose:  To find the CD-ROM on this local machine and set 
//           WizGlobals.CdSourcePath to it.
//
// Arguments: VOID
//
// Returns: BOOL  TRUE - if the CD path was set
//                FALSE - if no CD path was found
//
//----------------------------------------------------------------------------
static BOOL
SetCdRomPath( VOID )
{

    TCHAR *p;
    TCHAR DriveLetters[MAX_PATH];
    TCHAR PathBuffer[MAX_PATH];

    //
    // Find the CD-ROM
    //
    // GetLogicalDriveStrings() fills in the DriveLetters buffer, and it
    // looks like:
    //
    //      c:\(null)d:\(null)x:\(null)(null)
    //
    // (i.e. double-null at the end)
    //


    // ISSUE-2002/02/27-stelo,swamip - Replace with existing code that searches drives
    //
    if ( ! GetLogicalDriveStrings(MAX_PATH, DriveLetters) )
        DriveLetters[0] = _T('\0');

    p = DriveLetters;

    while ( *p ) {

        if ( GetDriveType(p) == DRIVE_CDROM ) {

            SYSTEM_INFO SystemInfo;
            HRESULT hrCat;

            lstrcpyn( PathBuffer, p , AS(PathBuffer));

            GetSystemInfo( &SystemInfo );

            switch( SystemInfo.wProcessorArchitecture )
            {
                case PROCESSOR_ARCHITECTURE_INTEL:

                    hrCat=StringCchCat( PathBuffer, AS(PathBuffer),  _T("i386") );

                    break;

                case PROCESSOR_ARCHITECTURE_AMD64:

                    hrCat=StringCchCat( PathBuffer, AS(PathBuffer),  _T("amd64") );

                    break;

                default:

                    hrCat=StringCchCat( PathBuffer, AS(PathBuffer),  _T("i386") );

                    AssertMsg( FALSE,
                               "Unknown Processor.  Can't set setup files path." );

            }

            break;

        }

        while ( *p++ );
    }

    //
    //  If no CD Found, leave the setup files path blank
    //
    if( *p == _T('\0') )
    {
        lstrcpyn( WizGlobals.CdSourcePath, _T(""), AS(WizGlobals.CdSourcePath) );

        return( FALSE );
    }
    else
    {
        lstrcpyn( WizGlobals.CdSourcePath, PathBuffer, AS(WizGlobals.CdSourcePath) );

        return( TRUE );
    }

}

//----------------------------------------------------------------------------
//
// Function: DidSetupmgrWriteThisFile
//
// Purpose:  To check to see if a specific file was written by Setup Manager
//
// Arguments: IN LPTSTR lpFile - the full path and name of the file to check
//
// Returns: BOOL  TRUE -  if setup manager wrote the file
//                FALSE - if it didn't
//
//----------------------------------------------------------------------------
static BOOL
DidSetupmgrWriteThisFile( IN LPTSTR lpFile )
{

    INT iRet;
    TCHAR Buffer[MAX_INILINE_LEN];
    FILE *fp = My_fopen(lpFile, _T("r") );

    if ( fp == NULL )
        return( FALSE );

    if ( My_fgets(Buffer, MAX_INILINE_LEN - 1, fp) == NULL )
        return( FALSE );

    My_fclose(fp);

    if ( lstrcmp(Buffer, _T(";SetupMgrTag\n")) == 0 ||
         lstrcmp(Buffer, _T("@rem SetupMgrTag\n")) == 0 )
    {
        return( TRUE );
    }
    else
    {
        return( FALSE );
    }

}

//----------------------------------------------------------------------------
//
// Function: SaveAllSettings
//
// Purpose: This is the entry point for saving the answer file.  It is
//          called by the SaveScript page.
//
//          If multiple computers were specified, it also writes a .udf.
//
//          It always writes a batch file that makes it easy to use the
//          answer file just created.
//
// Arguments: HWND hwnd
//
// Returns: BOOL
//
//----------------------------------------------------------------------------

BOOL
SaveAllSettings(HWND hwnd)
{
    //
    // Build the file names for the .udf and sample batch script.  The
    // results are stored in FixedGlobals.
    //
    // After calling BuildAltFileNames(), FixedGlobals.UdfFileName and
    // FixedGlobals.BatchFileName will be null strings if we're not
    // supposed to write those files out
    //

    if ( ! BuildAltFileNames(hwnd) )
        return FALSE;

    //
    // Before overwriting anything do some checks.
    //

    if ( ! IsOkToOverwriteFiles(hwnd) )
        return FALSE;

    //
    // Empty any intermediatte stuff we have on the queues because
    // user is going back & next alot.
    //
    // Then initialize the queues with the original settings.
    //

    SettingQueue_Empty(SETTING_QUEUE_ANSWERS);
    SettingQueue_Empty(SETTING_QUEUE_UDF);

    SettingQueue_Copy(SETTING_QUEUE_ORIG_ANSWERS,
                      SETTING_QUEUE_ANSWERS);

    SettingQueue_Copy(SETTING_QUEUE_ORIG_UDF,
                      SETTING_QUEUE_UDF);

    //
    // Call the function that everybody plugs into in savefile.c to
    // queue up all the answers from the UI.
    //

    if (!QueueSettingsToAnswerFile(hwnd))
        return FALSE;

    //
    // Flush the answer file queue.
    //

    if ( ! SettingQueue_Flush(FixedGlobals.ScriptName,
                              SETTING_QUEUE_ANSWERS) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERRORS_WRITING_ANSWER_FILE,
                      FixedGlobals.ScriptName);
        return FALSE;
    }

    //
    // If multiple computernames, flush the .udf queue
    //

    if ( FixedGlobals.UdfFileName[0] ) {

        if ( ! SettingQueue_Flush(FixedGlobals.UdfFileName,
                                  SETTING_QUEUE_UDF) ) {
            ReportErrorId(hwnd,
                          MSGTYPE_ERR | MSGTYPE_WIN32,
                          IDS_ERRORS_WRITING_UDF,
                          FixedGlobals.UdfFileName);
            return FALSE;
        }
    }


    //
    //  If they are using SCSI or HAL files, then flush the txtsetup.oem queue
    //

    // NTRAID#NTBUG9-551746-2002/02/27-stelo,swamip - Unused code, should be removed
    //
    if ( GetNameListSize( &GenSettings.OemScsiFiles ) > 0 ||
         GetNameListSize( &GenSettings.OemHalFiles )  > 0 ) {

        TCHAR szTextmodePath[MAX_PATH + 1] = _T("");

        // Note-ConcatenatePaths truncates to prevent overflow
        ConcatenatePaths( szTextmodePath,
                          WizGlobals.OemFilesPath,
                          _T("Textmode\\txtsetup.oem"),
                          NULL );

        if ( ! SettingQueueHalScsi_Flush(szTextmodePath,
                                         SETTING_QUEUE_TXTSETUP_OEM) ) {
            ReportErrorId(hwnd,
                          MSGTYPE_ERR | MSGTYPE_WIN32,
                          IDS_ERRORS_WRITING_ANSWER_FILE,
                          szTextmodePath);
            return FALSE;
        }
    }

    //
    // Write the sample batch script if BuildAltFileNames hasn't already
    // determined that we should not (i.e. If a remote boot answer file,
    // don't write a sample batch script)
    //

    if ( FixedGlobals.BatchFileName[0] ) {
        if ( ! WriteSampleBatchScript(hwnd) )
            return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//
// Function: IsOkToOverwriteFiles
//
// Purpose: This is called prior to writing the answer file, .udf and sample
//          batch script.
//
//          Before overwriting any file, we make sure that it was created
//          by setupmgr.  If not, we prompt the user.
//
// Returns:
//      TRUE  - to go ahead and overwrite any of the files that might exist
//      FALSE - user canceled the overwrite
//
//----------------------------------------------------------------------------

static BOOL
IsOkToOverwriteFiles(HWND hwnd)
{
    INT   i;
    INT   iRet;

    //
    //  If we are editing a script just write out the files
    //
    if( ! WizGlobals.bNewScript )
    {
        return( TRUE );
    }

    //
    // Check foo.txt foo.udf and foo.bat that we're about to write out.
    // If any of them already exists, then check to see if they were
    // created by setupmgr.  We will prompt the user before overwriting
    // something we didn't write before.
    //

    for ( i=0; i<3; i++ ) {

        LPTSTR lpFile = NULL;

        //
        // The answer file, .udf or the batch script?
        //

        if ( i == 0 )
            lpFile = FixedGlobals.ScriptName;
        else  if ( i == 1 )
            lpFile = FixedGlobals.UdfFileName;
        else
            lpFile = FixedGlobals.BatchFileName;

        //
        // If the file already exists, prompt the user if it doesn't
        // have our tag.
        //
        // Look for ;SetupMgrTag in the answer file and .udf
        // Look for rem SetupMgrTag in the batch script
        //

        if ( lpFile[0] && DoesFileExist(lpFile) ) {

            if( DidSetupmgrWriteThisFile( lpFile ) )
            {

                iRet = ReportErrorId(hwnd,
                                     MSGTYPE_YESNO,
                                     IDS_ERR_FILE_ALREADY_EXISTS,
                                     lpFile);
                if ( iRet == IDNO )
                    return( FALSE );

            }
            else {

                iRet = ReportErrorId(hwnd,
                                     MSGTYPE_YESNO,
                                     IDS_ERR_SAVEFILE_NOT_SETUPMGR,
                                     lpFile);
                if ( iRet == IDNO )
                    return( FALSE );

            }

        }

    }

    return( TRUE );
}

//----------------------------------------------------------------------------
//
//  Function: BuildAltFileNames
//
//  Purpose: This function derives the name for the .udf and the .bat
//           associatted with a given answer filename.
//
//  Note: This function has a couple of side-effects.  If there is no
//        extension on FixedGlobals.ScriptName, it adds one.
//
//        Also, after this function runs, FixedGlobals.UdfFileName will
//        be a null string if there <= 1 computer names (i.e. no udf)
//
//        If we're writing a .sif (remote boot), FixGlobals.BatchFileName
//        will be a null-string.
//
//        The finish page relies on this.
//
//  Returns: BOOL
//
//----------------------------------------------------------------------------

static BOOL
BuildAltFileNames(HWND hwnd)
{
    TCHAR PathBuffer[MAX_PATH],
          *lpFilePart               = NULL, 
          *pExtension;

    INT nEntries                    = GetNameListSize(&GenSettings.ComputerNames);
    BOOL bMultipleComputers         = ( nEntries > 1 );
    HRESULT hrCat;

    //
    // Find out the filename part of the answer file pathname and copy
    // it to PathBuffer[]
    //

    GetFullPathName(FixedGlobals.ScriptName,
                    MAX_PATH,
                    PathBuffer,
                    &lpFilePart);

    if (lpFilePart == NULL)
        return FALSE;
    //
    // Point at the extension in the PathBuffer[].
    //
    // e.g. foo.txt, point at the dot.
    //      foo, point at the null byte.
    //
    // If there is no extension, put one on it
    //

    if ( (pExtension = wcsrchr(lpFilePart, _T('.'))) == NULL ) {

        pExtension = &lpFilePart[lstrlen(lpFilePart)];

        if ( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL )
            hrCat=StringCchCat(FixedGlobals.ScriptName, AS(FixedGlobals.ScriptName), _T(".sif"));
        else
            hrCat=StringCchCat(FixedGlobals.ScriptName, AS(FixedGlobals.ScriptName), _T(".txt"));
    }

    //
    // Cannot allow foo.bat or foo.udf as answer file names because we
    // will probably be writing other stuff to foo.bat and/or foo.udf
    //

    if ( (LSTRCMPI(pExtension, _T(".bat")) == 0) ||
         (LSTRCMPI(pExtension, FILE_DOT_UDB) == 0) )
    {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR,
                      IDS_ERR_BAD_SCRIPT_EXTENSION);
        return FALSE;
    }

    //
    // Build the .udf name if there was > 1 computer names specified
    //

    if ( bMultipleComputers ) {
        lstrcpyn(pExtension, FILE_DOT_UDB, MAX_PATH- (int)(pExtension - PathBuffer) );
        lstrcpyn(FixedGlobals.UdfFileName, PathBuffer,AS(FixedGlobals.UdfFileName));
    } else {
        FixedGlobals.UdfFileName[0] = _T('\0');
    }

    //
    // Build the .bat file name.  We won't be creating a sample batch
    // script in the case of remote boot, so null it out, else the Finish
    // page will be broken.
    //

    if ( (WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL) ||
         (WizGlobals.iProductInstall == PRODUCT_SYSPREP) ) {
        FixedGlobals.BatchFileName[0] = _T('\0');
    } else {
        lstrcpyn(pExtension, _T(".bat"), MAX_PATH - (int)(pExtension - PathBuffer) );
        lstrcpyn(FixedGlobals.BatchFileName, PathBuffer,AS(FixedGlobals.BatchFileName));
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function: AddLanguageSwitch
//
//  Purpose: Add the /copysource language switch to copy over the right
//           language files
//
//  Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
AddLanguageSwitch( TCHAR *Buffer, DWORD cbSize )
{
    INT iNumLanguages;
    HRESULT hrCat;

    iNumLanguages = GetNameListSize( &GenSettings.LanguageFilePaths );

    if ( iNumLanguages > 0 )
    {
        hrCat=StringCchCat( Buffer, cbSize, _T(" /copysource:lang") );

    }

    hrCat=StringCchCat( Buffer, cbSize, _T("\n") ); // make sure it has a line-feed at the end
}

//----------------------------------------------------------------------------
//
//  Function: WriteSampleBatchScript
//
//  Purpose: writes the sample batch script
//
//  Returns: FALSE if errors writing the file.  Any errors are reported
//           to the user.
//
//----------------------------------------------------------------------------

static BOOL
WriteSampleBatchScript(HWND hwnd)
{

    FILE *fp;
    TCHAR Buffer[MAX_INILINE_LEN];
    TCHAR *pszScriptName = NULL;
    TCHAR szComputerName[MAX_PATH];
    TCHAR SetupFilesBuffer[MAX_INILINE_LEN];
    TCHAR AnswerFileBuffer[MAX_INILINE_LEN];
    TCHAR SetupFilesQuotedBuffer[MAX_INILINE_LEN];
    TCHAR Winnt32Buffer[MAX_INILINE_LEN];
    DWORD dwSize;
    INT nEntries = GetNameListSize(&GenSettings.ComputerNames);
    BOOL bMultipleComputers = ( nEntries > 1 );
   HRESULT hrPrintf;

    if ( (fp = My_fopen(FixedGlobals.BatchFileName, _T("w")) ) == NULL ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERR_OPEN_SAMPLE_BAT,
                      FixedGlobals.BatchFileName);
        return FALSE;
    }

    My_fputs(_T("@rem SetupMgrTag\n@echo off\n\n"), fp);

    if( StrSampleBatchScriptLine1 == NULL )
    {
        StrSampleBatchScriptLine1 = MyLoadString( IDS_BATCH_SCRIPT_LINE1 );
        StrSampleBatchScriptLine2 = MyLoadString( IDS_BATCH_SCRIPT_LINE2 );
    }


    My_fputs( _T("rem\nrem "), fp );

    My_fputs( StrSampleBatchScriptLine1, fp );

    My_fputs( _T("\nrem "), fp );

    My_fputs( StrSampleBatchScriptLine2, fp );

    My_fputs( _T("\nrem\n\n"), fp );


    if ( !(pszScriptName = MyGetFullPath( FixedGlobals.ScriptName )) )
    {
        My_fclose( fp );
        return FALSE;
    }

    //
    //  Quote the Script name if it contains spaces
    //

    QuoteStringIfNecessary( AnswerFileBuffer, pszScriptName, AS(AnswerFileBuffer) );

    // Note: MAX_INILINE_LEN=1K AnswerFileBuffer at this time is MAX_PATH+2 MAX
    // buffer overrun should not be a problem.
    hrPrintf=StringCchPrintf( Buffer, AS(Buffer), _T("set AnswerFile=.\\%s\n"), AnswerFileBuffer );

    My_fputs( Buffer, fp );

    if( bMultipleComputers )
    {

        TCHAR UdfFileBuffer[1024];

        pszScriptName = MyGetFullPath( FixedGlobals.UdfFileName );

        //
        //  Quote the UDF name if it contains spaces
        //

        QuoteStringIfNecessary( UdfFileBuffer, pszScriptName, AS(UdfFileBuffer) );

        hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
                  _T("set UdfFile=.\\%s\nset ComputerName=%%1\n"),
                  UdfFileBuffer );

        My_fputs( Buffer, fp );

    }


    if( WizGlobals.bStandAloneScript )
    {

        SetCdRomPath();

        lstrcpyn( SetupFilesBuffer, WizGlobals.CdSourcePath, AS(SetupFilesBuffer) );

    }
    else
    {

        GetComputerNameFromUnc( WizGlobals.UncDistFolder, szComputerName, AS(szComputerName) );

        hrPrintf=StringCchPrintf( SetupFilesBuffer, AS(SetupFilesBuffer),
                  _T("%s%s%s%s%s"),
                  szComputerName,
                  _T("\\"),
                  WizGlobals.DistShareName,
                  _T("\\"),
                  WizGlobals.Architecture );
    }

    QuoteStringIfNecessary( SetupFilesQuotedBuffer, SetupFilesBuffer, AS(SetupFilesQuotedBuffer) );

    hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
              _T("set SetupFiles=%s\n\n"), 
              SetupFilesQuotedBuffer );
    My_fputs( Buffer, fp );

    hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
              _T("%s\\winnt32"), 
              SetupFilesBuffer );

    QuoteStringIfNecessary( Winnt32Buffer, Buffer, AS(Winnt32Buffer) );

    if( bMultipleComputers )
    {

        if( StrUsage == NULL )
        {
            StrUsage = MyLoadString( IDS_USAGE );
        }

        hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
                  _T("if \"%%ComputerName%%\" == \"\" goto USAGE\n\n") );
        
        My_fputs( Buffer, fp );

        hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
                  _T("%s%s"),
                  Winnt32Buffer,
                  _T(" /s:%SetupFiles% ")
                  _T("/unattend:%AnswerFile% ")
                  _T("/udf:%ComputerName%,%UdfFile% ")
                  _T("/makelocalsource") );

        AddLanguageSwitch( Buffer, AS(Buffer) );

        My_fputs( Buffer, fp );

        My_fputs( _T("goto DONE\n\n"), fp );

        My_fputs( _T(":USAGE\n"), fp );

        My_fputs( _T("echo.\n"), fp );

        hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
                  _T("echo %s: unattend ^<computername^>\n"),
                  StrUsage );

        My_fputs( Buffer, fp );

        My_fputs( _T("echo.\n\n"), fp );

        My_fputs( _T(":DONE\n"), fp );

    }
    else
    {
        hrPrintf=StringCchPrintf(Buffer, AS(Buffer),
                 _T("%s%s"),
                 Winnt32Buffer,
                 _T(" /s:%SetupFiles% ")
                 _T("/unattend:%AnswerFile%"));

        AddLanguageSwitch( Buffer, AS(Buffer) );

        My_fputs( Buffer, fp );
    }

    My_fclose( fp );

    return( TRUE );
}

//----------------------------------------------------------------------------
//
//  Function: QuoteStringIfNecessary
//
//  Purpose:  If the given input string has white space then the whole string
//       is quoted and returned in the output string.  Else just the string
//       is returned in the output string.
//
//       szOutputString is assumed to be of size MAX_INILINE_LEN
//
//  Arguments: OUT TCHAR *szOutputString
//
//  Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
QuoteStringIfNecessary( OUT TCHAR *szOutputString, 
                        IN const TCHAR* const szInputString,
                        IN DWORD cbSize)
{
   HRESULT hrPrintf;

    if( DoesContainWhiteSpace( szInputString ) )
    {
         hrPrintf=StringCchPrintf( szOutputString, cbSize,
                  _T("\"%s\""), 
                  szInputString );
    }
    else
    {
        lstrcpyn( szOutputString, szInputString ,cbSize);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\exe\main.c ===
/****************************************************************************\

    MAIN.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Main source file for the OPK Wizard.  Contains WinMain() and global
    variable declarations.

    4/99 - Jason Cohen (JCOHEN)
        Added this new main source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Pre-include Defined Value(s):
//

// Needed to define this so we don't include
// the extern declarations of the globals that
// are declared in this file.
//
#define _MAIN_C_


//
// Include File(s):
//
#include "setupmgr.h"
#include "allres.h"

//
// Global Variable(s):
//

GAPP g_App;


//
// Internal Defined Value(s):
//


// Tag files
//
#ifndef DBCS
#define FILE_DBCS_TAG           _T("dbcs.tag")
#endif // DBCS

// Directories off the root of the tool instal location.
//
#define DIR_LANG                _T("lang")
#define DIR_CONFIGSETS          _T("cfgsets")
#define DIR_DOCS                _T("docs")

#define FILE_HELPCONTENT_CHM    _T("opk.chm")

#define STR_TAGFILE             _T("HIJPP 1.0")
#define STR_VERSION             _T("Version")
#define REGSTR_IEXPLORER        _T("Software\\Microsoft\\Internet Explorer")

// Unique string.
//
#define OPKWIZ_MUTEX            _T("OPKWIZ-MUTEX-5c9fbbd0-ee0e-11d2-9a21-0000f81edacc")


//
// Internal Function Prototype(s):
//

static BOOL ParseCmdLine(LPTSTR);
static BOOL FileWritable(LPTSTR lpszFile);
BOOL CALLBACK HelpDlgProc(HWND, UINT, WPARAM, LPARAM);
static BOOL CheckIEVersion();
static BOOL ParseVersionString(TCHAR* pszVersion, DWORD* pdwMajor, DWORD* pdwMinor, 
                               DWORD* pdwBuild, DWORD* pdwSubbuild);
static VOID SetWizardHelpFile(LPTSTR lpszHelpFilePath);

//
// Main Function:
//

int StartWizard(HINSTANCE hInstance, LPSTR lpCmdLine)
{
    HANDLE  hMutex              = NULL;
    int     nReturn             = 0;
    TCHAR   szCmdLine[MAX_PATH] = NULLSTR;

    // Convert cmdline from char to wchar
    //
    MultiByteToWideChar(CP_ACP, 0, lpCmdLine, -1, szCmdLine, AS(szCmdLine));

    // Check for another instance of the OPK wizard.
    //
    SetLastError(ERROR_SUCCESS);
    if ( ( hMutex = CreateMutex(NULL, TRUE, OPKWIZ_MUTEX) ) &&
         ( GetLastError() == ERROR_ALREADY_EXISTS ) )
    {
        HWND    hwndWizard;
        LPTSTR  lpAppName = AllocateString(NULL, IDS_APPNAME);

        // Find the window, set it to the forground, and return.
        //
        if ( ( lpAppName ) && ( hwndWizard = FindWindow(NULL, lpAppName) ) )
            SetForegroundWindow(hwndWizard);
        FREE(lpAppName);
    }
    else if ( CheckIEVersion() )
    {
        TCHAR   szBuffer[MAX_PATH];
        LPTSTR  lpBuffer;
                        

        // Init some more of the global data.
        //
        g_App.hInstance = hInstance;

        // Get the path to where the EXE is.
        //
        szBuffer[0] = NULLCHR;
        lpBuffer = NULL;
        
        // ISSUE-2002/02/27-stelo,swamip - Check return Value and make sure that szBuffer has data in it.
        GetModuleFileName(hInstance, szBuffer, STRSIZE(szBuffer));
        if ( GetFullPathName(szBuffer, STRSIZE(g_App.szOpkDir), g_App.szOpkDir, &lpBuffer) &&
             g_App.szOpkDir[0] &&
             lpBuffer )
        {
            // Chop off the exe name from the path we want.
            //
            *lpBuffer = NULLCHR;
            StrRTrm(g_App.szOpkDir, CHR_BACKSLASH);
        }

        // Setup the full path to the ini file for the wizard.
        //
        lstrcpyn(g_App.szSetupMgrIniFile, g_App.szOpkDir,AS(g_App.szSetupMgrIniFile));
        AddPathN(g_App.szSetupMgrIniFile, FILE_SETUPMGR_INI,AS(g_App.szSetupMgrIniFile));

        // Need to know where the root of the folder where wizard files are installed.
        //
        lstrcpyn(g_App.szWizardDir, g_App.szOpkDir,AS(g_App.szWizardDir));
        AddPathN(g_App.szWizardDir, DIR_WIZARDFILES,AS(g_App.szWizardDir));

        // Need to know where the configuration set folder is.
        //
        lstrcpyn(g_App.szConfigSetsDir, g_App.szOpkDir, AS(g_App.szConfigSetsDir));
        AddPathN(g_App.szConfigSetsDir, DIR_CONFIGSETS,AS(g_App.szConfigSetsDir));

        // Need to know where the lang directory is.
        //
        lstrcpyn(g_App.szLangDir, g_App.szOpkDir,AS(g_App.szLangDir));
        AddPathN(g_App.szLangDir, DIR_LANG,AS(g_App.szLangDir));

        // Setup the full paths to the help files.
        //
        SetWizardHelpFile(g_App.szHelpFile);
        lstrcpyn(g_App.szHelpContentFile, g_App.szOpkDir,AS(g_App.szHelpContentFile));
        AddPathN(g_App.szHelpContentFile, DIR_DOCS,AS(g_App.szHelpContentFile));
        AddPathN(g_App.szHelpContentFile, FILE_HELPCONTENT_CHM,AS(g_App.szHelpContentFile));

        // Setup the full path to the OPK input file.
        //
        lstrcpyn(g_App.szOpkInputInfFile, g_App.szWizardDir,AS(g_App.szOpkInputInfFile));
        AddPathN(g_App.szOpkInputInfFile, FILE_OPKINPUT_INF,AS(g_App.szOpkInputInfFile));

        // First check for the OEM tag file in the same folder
        // as the exe, just in case they are running it right
        // off the CD or network share.  We need to catch this
        // case so we can stop them from running in corp mode
        // by accidentally.
        //
        lstrcpyn(szBuffer, g_App.szOpkDir,AS(szBuffer));
        AddPathN(szBuffer, FILE_OEM_TAG,AS(szBuffer));
        if ( FileExists(szBuffer) )
            SET_FLAG(OPK_OEM, TRUE);

        // Get a pointer to the end of a buffer with the wizard
        // directory in it.
        //
        lstrcpyn(szBuffer, g_App.szWizardDir,AS(szBuffer));
        AddPathN(szBuffer, NULLSTR,AS(szBuffer));
        lpBuffer = szBuffer + lstrlen(szBuffer);

        // Check to see if this is the DBCS version.
        //
        // NTRAID#NTBUG9-547380-2002/02/27-stelo,swamip - We need to base the DBCS descisions (conditions) at runtime not at compile time.  Since an English OPK
        //                                                can deploy a variety of languages, the compile time tag does not make sense.
        #ifdef DBCS
        SET_FLAG(OPK_DBCS, TRUE);
        #else // DBCS
        lstrcpyn(lpBuffer, FILE_DBCS_TAG, (AS(szBuffer)-lstrlen(szBuffer)));
        SET_FLAG(OPK_DBCS, FileExists(szBuffer));
        #endif // DBCS

        // Check for the OEM tag file.
        //
        lstrcpyn(lpBuffer, FILE_OEM_TAG, (AS(szBuffer)-lstrlen(szBuffer)));
        if ( FileExists(szBuffer) )
            SET_FLAG(OPK_OEM, TRUE);

        //
        // Make sure that szBuffer is pointing to the OEM tag file at this point,
        // because we are going to try and write to it in the next check.
        //

        // The OPK input file must exist to run the wizard if this
        // is running in OEM mode.
        //
        if ( ( g_App.szOpkDir[0] ) &&
             ( ( !GET_FLAG(OPK_OEM) ) ||
               ( FileExists(g_App.szOpkInputInfFile) && FileWritable(szBuffer) ) ) )
        {
            // Check out the command line options.
            //
            if ( ParseCmdLine(szCmdLine) )
            {
                // Set this so on the very first wizard page, we can cancel with
                // out getting the confirmation dialog.
                //
                SET_FLAG(OPK_EXIT, TRUE);

                // Now create the wizard.
                //
                nReturn = CreateMaintenanceWizard(hInstance, NULL);

                // Clean up the temporary directory used if we didn't finish.
                //
                if ( g_App.szTempDir[0] )
                {
                    // Make sure the temp dir and the wizard dir have trailing backslashes.
                    //
                    AddPathN(g_App.szWizardDir, NULLSTR,AS(g_App.szWizardDir));
                    AddPathN(g_App.szTempDir, NULLSTR,AS(g_App.szTempDir));
                    if ( lstrcmpi(g_App.szWizardDir, g_App.szTempDir) != 0 )
                        DeletePath(g_App.szTempDir);
                    #ifdef DBG
                    else
                    {
                        DBGOUT(NULL, _T("OPKWIZ: Temp and Wizard directory are the same on exit (%s).\n"), g_App.szTempDir);
                        DBGMSGBOX(NULL, _T("Temp and Wizard directory are the same on exit (%s)."), _T("OPKWIZ Debug Message"), MB_ERRORBOX, g_App.szTempDir);
                    }
                    #endif // DBG
                }
            }
        }
        else
            MsgBox(NULL, IDS_ERR_WIZBAD, IDS_APPNAME, MB_ERRORBOX);
    }
    else 
        MsgBox(NULL, IDS_ERR_IE5, IDS_APPNAME, MB_ERRORBOX);

    // Do the final cleanup before exiting.
    //
    if ( hMutex )
        CloseHandle(hMutex);

    return nReturn;
}

//
// Internal Function(s):
//

static BOOL ParseCmdLine(LPTSTR lpszCmdLineOrg)
{
    DWORD   dwArgs;
    LPTSTR  *lpArgs;
    BOOL    bRet    = TRUE,
            bError = FALSE;

    // ISSUE-2002/02/27-stelo,swamip - lpszCmdLineOrg is not being used any where, and before calling this function we are 
    //                                 doing some MultibytetoWideChar stuff on the buffer, those can be removed as well.
    if ( (dwArgs = GetCommandLineArgs(&lpArgs) ) && lpArgs )
    {
        LPTSTR  lpArg;
        DWORD   dwArg;

        // We want to skip over the first argument (it is the path
        // to the command being executed.
        //
        if ( dwArgs > 1 )
        {
            dwArg = 1;
            lpArg = *(lpArgs + dwArg);
        }
        else
            lpArg = NULL;

        // Loop through all the arguments.
        //
        while ( lpArg && !bError )
        {
            // Now we check to see if the first char is a dash or not.
            //
            if ( ( *lpArg == _T('-') ) ||
                 ( *lpArg == _T('/') ) )
            {
                LPTSTR  lpOption = CharNext(lpArg);
                BOOL    bOption;

                //
                // This is where you add command line options that start with a dash (-).
                //
                // Set bError if you don't recognize the command line option (unless you
                // want to just ignore it and continue).
                //

                switch( UPPER(*lpOption) )
                {
                    case _T('M'):

                        // Maintanence mode.
                        //
                        if ( ( *(++lpOption) == _T(':') ) && *(++lpOption) )
                        {
                            LPTSTR lpConfigName;
                            
                            lstrcpyn(g_App.szTempDir, g_App.szConfigSetsDir,AS(g_App.szTempDir));
                            AddPathN(g_App.szTempDir, NULLSTR,AS(g_App.szTempDir));
                            lpConfigName = g_App.szTempDir + lstrlen(g_App.szTempDir);

                            // ISSUE-2002/02/27-stelo,swamip - will never hit this conditional code?
                            //
                            if ( *lpOption == _T('"') )
                                lpOption++;

                            lstrcpyn(lpConfigName, lpOption, (AS(g_App.szTempDir)-lstrlen(g_App.szTempDir)));
                            StrTrm(lpConfigName, CHR_SPACE);
                            StrTrm(lpConfigName, CHR_QUOTE);
                            lstrcpyn(g_App.szConfigName, lpConfigName,AS(g_App.szConfigName));
                            AddPathN(g_App.szTempDir, NULLSTR,AS(g_App.szTempDir));
                            SET_FLAG(OPK_MAINTMODE, TRUE);
                            SET_FLAG(OPK_CMDMM, TRUE);

                            // Now make sure that the directory actually exists.
                            //
                            if ( !DirectoryExists(g_App.szTempDir) )
                            {
                                MsgBox(NULL, IDS_ERR_BADCONFIG, IDS_APPNAME, MB_ERRORBOX, g_App.szConfigName);
                                bRet = FALSE;
                            }
                        }
                        else
                            bError = TRUE;
                        break;

                    case _T('?'):

                        // Help.
                        //
                        DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_HELP), NULL, (DLGPROC) HelpDlgProc);
                        bRet = FALSE;
                        break;

                    case _T('A'):

                        // Set the flag for the autorun feature
                        //
                        SET_FLAG(OPK_AUTORUN, TRUE);
                        break;

                    case _T('B'):
                    case _T('I'):
                        //Going into batch/INS mode

                        // Set bOption if it is a batch file, otherwise it
                        // is the install ins file.
                        //
                        bOption = ( _T('B') == UPPER(*lpOption) );

                        //Check to see that there's a file name
                        if ( ( *(++lpOption) == _T(':') ) && *(++lpOption) )
                        {
                            LPTSTR      lpFileName,
                                        lpFilePart              = NULL;
                            TCHAR       szFullPath[MAX_PATH]    = NULLSTR,
                                        szBuf[MAX_URL];

                            // Set the lpFileName based on the command line
                            //
                            // ISSUE-2002/02/27-stelo,swamip - will never hit this conditional code?
                            //
                            if ( *lpOption == _T('"') )
                                lpOption++;

                            // Strip off the spaces and quotes from parameter
                            //
                            StrTrm(lpOption, CHR_SPACE);
                            StrTrm(lpOption, CHR_QUOTE);
                        
                            // Grab the full path of the batch/INS file
                            //
                            if (( GetFullPathName(lpOption, STRSIZE(szFullPath), szFullPath, &lpFilePart) ))
                            {
                                // Verify the the batch/INS file exists
                                //
                                if ( !FileExists(szFullPath))
                                {
                                    MsgBox(NULL, bOption ? IDS_ERR_BADBATCH : IDS_ERR_BADINS, IDS_APPNAME, MB_ERRORBOX, szFullPath);
                                    bRet = FALSE;
                                }
                                else
                                {
                                    // The file exists, we're ready to start, Set the batch/INS mode flag to TRUE
                                    // Set the global batch file to the given batch/INS file name
                                    if (bOption)
                                       lstrcpyn(g_App.szOpkWizIniFile, szFullPath, AS(g_App.szOpkWizIniFile));
                                    else
                                       lstrcpyn(g_App.szInstallInsFile, szFullPath, AS(g_App.szInstallInsFile));
                                    SET_FLAG(bOption ? OPK_BATCHMODE : OPK_INSMODE, TRUE);
                                    bRet = TRUE;
                                }

                                // Set the configuration set name
                                //
                                szBuf[0] = NULLCHR;
                                // ISSUE-2002/02/27-stelo,swamip - Need to check the return value of GetPrivateProfileString.  Also check for possible buffer overflow
                                //                                as szBuf is MAX_URL and ConfigName is MAX_PATH
                                GetPrivateProfileString( INI_SEC_CONFIGSET, INI_SEC_CONFIG, NULLSTR, szBuf, STRSIZE(szBuf), g_App.szOpkWizIniFile );
                                lstrcpyn(g_App.szConfigName, szBuf, AS(g_App.szConfigName));
                            }
                            else
                                bRet = FALSE;
                        }
                        else
                            bError = TRUE;
                        break;

                    default:
                        bError = TRUE;
                        break;
                }
            }
            else if ( *lpArg )
            {
                //
                // This is where you would read any command line parameters that are just passed
                // in on the command line w/o any proceeding characters (like - or /).
                //
                // Set bError if you don't have any of these types of parameters (unless you
                // want to just ignore it and continue).
                //

                bError = TRUE;
            }

            // Setup the pointer to the next argument in the command line.
            //
            if ( ++dwArg < dwArgs )
                lpArg = *(lpArgs + dwArg);
            else
                lpArg = NULL;
        }

        // Make sure to free the two buffers allocated by the GetCommandLineArgs() function.
        //
        FREE(*lpArgs);
        FREE(lpArgs);
    }
    //Check to see if the arguments provided are valid and that we have not already hit an error
    if  (((GET_FLAG(OPK_BATCHMODE) && GET_FLAG(OPK_MAINTMODE)) ||
        (!(GET_FLAG(OPK_BATCHMODE)) && GET_FLAG(OPK_INSMODE)) ||
        (!(GET_FLAG(OPK_BATCHMODE)) && GET_FLAG(OPK_AUTORUN)) ||
        (GET_FLAG(OPK_MAINTMODE) && GET_FLAG(OPK_INSMODE))) && bRet && !bError)
    {
        MsgBox(NULL, IDS_ERR_INVCMD, IDS_APPNAME, MB_OK);
        bRet = FALSE;
    }

    // If we hit an error, display the error and show the help.
    //
    if ( bError )
    {
        MsgBox(NULL, IDS_ERR_BADCMDLINE, IDS_APPNAME, MB_ERRORBOX);
        bRet = FALSE;
    }

    return bRet;
}

static BOOL FileWritable(LPTSTR lpszFile)
{
    BOOL    bRet    = TRUE;
    DWORD   dwAttr  = GetFileAttributes(lpszFile);

    // ISSUE-2002/02/27-stelo,swamip - The logic appears to incorrect, we should check READ_ONLY attribute
    if ( ( dwAttr != 0xFFFFFFFF ) &&
         ( SetFileAttributes(lpszFile, dwAttr) == 0 ) )
    {
         bRet = FALSE;
    }

    return bRet;
}

void SetConfigPath(LPCTSTR lpDirectory)
{
    HINF        hInf;
    INFCONTEXT  InfContext;
    BOOL        bLoop;
    DWORD       dwErr;

    // ISSUE-2002/02/27-stelo,swamip -  Make sure lpdirectory is a valid pointer
    if ( (hInf = SetupOpenInfFile(g_App.szOpkInputInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, &dwErr)) != INVALID_HANDLE_VALUE )
    {
        for ( bLoop = SetupFindFirstLine(hInf, INF_SEC_COPYFILES, NULL, &InfContext);
              bLoop;
              bLoop = SetupFindNextLine(&InfContext, &InfContext) )
        {
            TCHAR   szFile[MAX_PATH]    = NULLSTR,
                    szSubDir[MAX_PATH]  = NULLSTR;
            LPTSTR  lpBuffer;
            int iBufferLen;

            // Get the source filename.
            //
            if ( SetupGetStringField(&InfContext, 1, szFile, AS(szFile), NULL) && szFile[0] )
            {
                // Now find out if this is a file we care about.
                //
                if ( LSTRCMPI(szFile, FILE_INSTALL_INS) == 0 ) {
                    lpBuffer = g_App.szInstallInsFile;
                    iBufferLen= AS(g_App.szInstallInsFile);
                } else if ( LSTRCMPI(szFile, FILE_OPKWIZ_INI) == 0 ) {
                    lpBuffer = g_App.szOpkWizIniFile;
                    iBufferLen= AS(g_App.szOpkWizIniFile);
                } else if ( LSTRCMPI(szFile, FILE_OOBEINFO_INI) == 0 ) {
                    lpBuffer = g_App.szOobeInfoIniFile;
                    iBufferLen= AS(g_App.szOobeInfoIniFile);
                } else if ( LSTRCMPI(szFile, FILE_OEMINFO_INI) == 0 ) {
                    lpBuffer = g_App.szOemInfoIniFile;
                    iBufferLen= AS(g_App.szOemInfoIniFile);
                } else if ( LSTRCMPI(szFile, FILE_WINBOM_INI) == 0 ) {
                    lpBuffer = g_App.szWinBomIniFile;
                    iBufferLen= AS(g_App.szWinBomIniFile);
                } else if ( LSTRCMPI(szFile, FILE_UNATTEND_TXT) == 0 ) {
                    lpBuffer = g_App.szUnattendTxtFile;
                    iBufferLen= AS(g_App.szUnattendTxtFile);                
                } else {
                    lpBuffer = NULL;
                    iBufferLen=0;
                }

                // Get the full path to the file if this is one we are saving.
                //
                if ( lpBuffer )
                {
                    lstrcpyn(lpBuffer, lpDirectory,iBufferLen);

                    // Get the optional destination sub directory and add it
                    // if it is there.
                    //
                    if ( SetupGetStringField(&InfContext, 3, szSubDir, AS(szSubDir), NULL) && szSubDir[0] )
                    {
                        AddPathN(lpBuffer, szSubDir, iBufferLen);
                        if ( !DirectoryExists(lpBuffer) )
                        {
                            // ISSUE-2002/02/27-stelo,swamip - We should check the return value of CreatePath and pass up to SetConfigPath
                            CreatePath(lpBuffer);
                        }
                    }

                    AddPathN(lpBuffer, szFile, iBufferLen);
                }
            }
        }
    }
}

BOOL CALLBACK HelpDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {   
        case WM_COMMAND:
            switch ( LOWORD(wParam) )
            {
                case IDOK:
                    EndDialog(hwnd, LOWORD(wParam));
                    break;
            }
            return FALSE;
        default:
            return FALSE;
    }

    return FALSE;
}



// Get the IE version from the registry, return TRUE if IE > 5
BOOL CheckIEVersion()
{
    DWORD dwSize = 255;
    TCHAR szVersion[255];
    HKEY hKey = 0;
    DWORD dwType = 0;
    BOOL bRet = FALSE;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_IEXPLORER, &hKey))
    {
        // Version for IE
        DWORD dwMajor, dwMinor, dwBuild, dwSubbuild;

        if (ERROR_SUCCESS == RegQueryValueEx(hKey, STR_VERSION, 0, &dwType, (LPBYTE)szVersion, &dwSize))
        {
            // Get the major version number
            if (ParseVersionString(szVersion, &dwMajor, &dwMinor, &dwBuild, &dwSubbuild) && 
                (dwMajor >= 5))
            {
                bRet = TRUE;
            }
        }

        RegCloseKey(hKey);      
    }

    return bRet;
}

// Parses 5.00.0518.10  into dwMajor = 5, dwMinor = 0   
// <major version>.<minor version>.<build number>.<sub-build number>

BOOL ParseVersionString(TCHAR* pszVersion, DWORD* pdwMajor, DWORD* pdwMinor, 
                        DWORD* pdwBuild, DWORD* pdwSubbuild)
{
    TCHAR szTemp[255];
    int i = 0;

    if (!pdwMajor || !pdwMinor || !pdwBuild || !pdwSubbuild)
        return FALSE;

    // ISSUE-2002/02/27-stelo,swamip - Check for the end of the string condition during while loops.
    // Major version
    while (pszVersion && *pszVersion != TEXT('.'))
        szTemp[i++] = *pszVersion++;
    *pdwMajor = _tcstoul(szTemp, 0, 10);

    pszVersion++;

    // Minor version
    i = 0;
    while (pszVersion && *pszVersion != TEXT('.'))
        szTemp[i++] = *pszVersion++;
    *pdwMinor = _tcstoul(szTemp, 0, 10);

    pszVersion++;

    // Build version
    i = 0;
    while (pszVersion && *pszVersion != TEXT('.'))
        szTemp[i++] = *pszVersion++;
    *pdwBuild = _tcstoul(szTemp, 0, 10);

    pszVersion++;

    // Sub build version
    i = 0;
    while (pszVersion && *pszVersion != TEXT('\0'))
        szTemp[i++] = *pszVersion++;
    *pdwSubbuild = _tcstoul(szTemp, 0, 10);

    return TRUE;
}

// Saves us from making sure we check if we use this function we always check if batch mode
//
BOOL OpkGetPrivateProfileSection(LPCTSTR pszAppName, LPTSTR pszSection, INT cchSectionMax, LPCTSTR pszFileName)
{
    if (!pszAppName || !pszSection || !pszFileName)
        return FALSE;

    return GetPrivateProfileSection(pszAppName, pszSection, cchSectionMax, 
        GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : pszFileName);
}

// Saves us from making two calls when writing and also so we don't forget about
// writing to batch mode inf
//
BOOL OpkWritePrivateProfileSection(LPCTSTR pszAppName, LPCTSTR pszKeyName, LPCTSTR pszFileName)
{
    if (!pszAppName || !pszFileName)
        return FALSE;

    // Write to batch inf
    //
    if (FALSE == WritePrivateProfileSection(pszAppName, pszKeyName, g_App.szOpkWizIniFile))
        return FALSE;

    // Write to user inf
    //
    return WritePrivateProfileSection(pszAppName, pszKeyName, pszFileName);
}

// Saves us from making two calls when writing and also so we don't forget about
// writing to batch mode inf
//
BOOL OpkWritePrivateProfileString(LPCTSTR pszAppName, LPCTSTR pszKeyName, LPCTSTR pszValue, 
                                  LPCTSTR pszFileName)
{
    BOOL fRet = FALSE;

    if (!pszAppName || !pszFileName)
        return FALSE;

    // Write to batch inf
    //
    if (FALSE == WritePrivateProfileString(pszAppName, pszKeyName, pszValue, g_App.szOpkWizIniFile))
        return FALSE;

    // Write to user inf
    //
    return WritePrivateProfileString(pszAppName, pszKeyName, pszValue, pszFileName);
}

// Saves us from making sure we check if we use this function we always check if batch mode
//
BOOL OpkGetPrivateProfileString(LPCTSTR pszAppName, LPCTSTR pszKeyName, LPCTSTR pszDefault, LPTSTR pszValue, 
                                INT cchValue, LPCTSTR pszFileName)
{
    if (!pszAppName || !pszKeyName || !pszDefault || !pszValue || !pszFileName)
        return FALSE;

    return GetPrivateProfileString(pszAppName, pszKeyName, pszDefault, pszValue, cchValue,
        GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : pszFileName);
}

// Note: pszHelpFilePath must be at least size MAX_PATH
VOID SetWizardHelpFile(LPTSTR pszHelpFilePath)
{
    // The help file can be in two location, in the docs folder or 
    // the current directory.  Check the docs folder first.
    //
    TCHAR szDocsFolder[MAX_PATH] = NULLSTR;

    // Build the docs folder path
    //
    lstrcpyn(szDocsFolder, g_App.szOpkDir,AS(szDocsFolder));
    AddPathN(szDocsFolder, DIR_DOCS,AS(szDocsFolder));
    
    // Test if help file exists in docs folder
    //
    if (pszHelpFilePath) {
        if (DirectoryExists(szDocsFolder)) {
            lstrcpyn(pszHelpFilePath, szDocsFolder, MAX_PATH);
            AddPathN(pszHelpFilePath, FILE_OPKWIZ_HLP, MAX_PATH);

            if (!FileExists(pszHelpFilePath)) {
                lstrcpyn(pszHelpFilePath, g_App.szOpkDir, MAX_PATH);
                AddPathN(pszHelpFilePath, FILE_OPKWIZ_HLP, MAX_PATH);
            }
        }
        else {
            lstrcpyn(pszHelpFilePath, g_App.szOpkDir, MAX_PATH);
            AddPathN(pszHelpFilePath, FILE_OPKWIZ_HLP, MAX_PATH);
        }    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\exe\setupmgr.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      setupmgr.c
//
// Description:
//      This file has the setupmgr manager function that gets the wizard going.
//
//----------------------------------------------------------------------------
#define _SMGR_DECLARE_GLOBALS_

#include <locale.h>

#include "setupmgr.h"
#include "allres.h"

//
// Local prototypes
//

static VOID SetupFonts(IN HINSTANCE hInstance,
                       IN HWND      hwnd,
                       IN HFONT     *pBigBoldFont,
                       IN HFONT     *pBoldFont);

static VOID DestroyFonts(IN HFONT hBigBoldFont,
                         IN HFONT hBoldFont);

static BOOL VerifyVersion(VOID);
//----------------------------------------------------------------------------
//
// Function: setupmgr
//
// Purpose: This is the only export from setupmgr.dll.  The stub loader
//          calls this function iff we're running on Windows Whistler.  Note
//          that DllMain() runs before this function is called.
//
//----------------------------------------------------------------------------

int APIENTRY WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPSTR lpCmdLine,
        int nCmdShow)
{
    // Zero out the global data.
    //
    ZeroMemory(&g_App, sizeof(GAPP));

    // This function checks to make sure that we are running the correct OS/Version
    //
    if (!VerifyVersion())
        return 1;
   
    //
    //  Sets the locale to the default, which is the system-default ANSI code
    //  page obtained from the operating system
    //

    setlocale(LC_CTYPE, "");

    // Set up the hInstance for the application
    //
    FixedGlobals.hInstance = hInstance;

    SetupFonts(FixedGlobals.hInstance,
               NULL,
               &FixedGlobals.hBigBoldFont,
               &FixedGlobals.hBoldFont);

    InitTheWizard();

    StartWizard(hInstance, lpCmdLine);

    DestroyFonts(FixedGlobals.hBigBoldFont, FixedGlobals.hBoldFont);

    return 0;
    
}


//----------------------------------------------------------------------------
//
// Function: SetupFonts
//
// Purpose: This function creates a BoldFont and a BigBoldFont and saves
//          handles to these in global vars.
//
//----------------------------------------------------------------------------

static VOID SetupFonts(IN HINSTANCE hInstance,
                       IN HWND      hwnd,
                       IN HFONT     *pBigBoldFont,
                       IN HFONT     *pBoldFont)
{
    NONCLIENTMETRICS ncm = {0};
    LOGFONT BigBoldLogFont  = ncm.lfMessageFont;
    LOGFONT BoldLogFont     = ncm.lfMessageFont;
    TCHAR FontSizeString[MAX_PATH],
          FontSizeSmallString[MAX_PATH];
    INT FontSize,
        FontSizeSmall;
    HDC hdc = GetDC( hwnd );

    //
    // Create the fonts we need based on the dialog font
    //
    // ISSUE-2002/02/28-stelo- Variable ncm is not being used any where
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    //
    // Create Big Bold Font and Bold Font
    //
    BigBoldLogFont.lfWeight   = FW_BOLD;
    BoldLogFont.lfWeight      = FW_BOLD;

    //
    // Load size and name from resources, since these may change
    // from locale to locale based on the size of the system font, etc.
    //
    if(!LoadString(hInstance,IDS_LARGEFONTNAME,BigBoldLogFont.lfFaceName,LF_FACESIZE)) 
    {
        lstrcpyn(BigBoldLogFont.lfFaceName,TEXT("MS Shell Dlg"),AS(BigBoldLogFont.lfFaceName));
    }

    if(LoadString(hInstance,IDS_LARGEFONTSIZE,FontSizeString,sizeof(FontSizeString)/sizeof(TCHAR))) 
    {
        FontSize = _tcstoul( FontSizeString, NULL, 10 );
    } 
    else 
    {
        FontSize = 12;
    }

    // Load the smaller sized font settings
    //
    if(!LoadString(hInstance,IDS_SMALLFONTNAME,BoldLogFont.lfFaceName,LF_FACESIZE)) 
    {
        lstrcpyn(BoldLogFont.lfFaceName,TEXT("MS Shell Dlg"),AS(BoldLogFont.lfFaceName));
    }

    if(LoadString(hInstance,IDS_SMALLFONTSIZE,FontSizeSmallString,sizeof(FontSizeSmallString)/sizeof(TCHAR))) 
    {
        FontSizeSmall = _tcstoul( FontSizeSmallString, NULL, 10 );
    } 
    else 
    {
        FontSizeSmall = 12;
    }

    if( hdc )
    {
        BigBoldLogFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSize / 72);
        BoldLogFont.lfHeight    = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * FontSizeSmall / 72);

        *pBigBoldFont = CreateFontIndirect(&BigBoldLogFont);
        *pBoldFont    = CreateFontIndirect(&BoldLogFont);

        ReleaseDC(hwnd,hdc);
    }
}


//----------------------------------------------------------------------------
//
// Function: DestroyFonts
//
// Purpose: Frees up the space used by loading the fonts
//
//----------------------------------------------------------------------------

static VOID DestroyFonts(IN HFONT hBigBoldFont,
                         IN HFONT hBoldFont)
{
    if( hBigBoldFont ) {
        DeleteObject( hBigBoldFont );
    }

    if( hBoldFont ) {
        DeleteObject( hBoldFont );
    }
}


//----------------------------------------------------------------------------
//
//  Function:   VerifyVersion
//
//  Purpose:    Verifies that we are running on the correct Operating System
//              If we are not running on a supported OS, this function prompts 
//              the user and returns FALSE
//
//----------------------------------------------------------------------------
static BOOL VerifyVersion(VOID)
{
    OSVERSIONINFOEXA    osVersionInfo;
    BOOL                bResult = FALSE;

    // Clean up the memory
    //
    ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);

    // This condition checks for the following:
    //      Are we able to get system information
    //      Are we running on NT
    //      Is our version NT4 and Service Pack 5 or greater
    //
    if (GetVersionExA((LPOSVERSIONINFOA) &osVersionInfo))
    {
        if (osVersionInfo.dwPlatformId & VER_PLATFORM_WIN32_NT)
        {
            g_App.dwOsVer = MAKELONG(MAKEWORD(LOBYTE(osVersionInfo.wServicePackMajor), LOBYTE(LOWORD(osVersionInfo.dwMinorVersion))), LOWORD(osVersionInfo.dwMajorVersion));
            if ( g_App.dwOsVer > OS_NT4_SP5 )
            {
                bResult = TRUE;
            }
            else
            {
                // The OS is a non-supported NT platform, error out
                //
                MsgBox(NULL, IDS_ERROR_VERSION, IDS_APPNAME, MB_ERRORBOX);
            }
        }
        else
        {
            // The OS is a 9x platform, we must error out
            //
            CHAR    szMessage[MAX_PATH],
                    szTitle[MAX_PATH];

            LoadStringA(NULL, IDS_ERROR_VERSION, szMessage, STRSIZE(szMessage));
            LoadStringA(NULL, IDS_APPNAME, szTitle, STRSIZE(szTitle));

            MessageBoxA(NULL, szMessage, szTitle, MB_ERRORBOX);
        }
    }

    return bResult;        

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\appver.h ===
/****************************************************************************\

    APPVER.H / Setup Manager (SETUPMGR.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    Contains version information for this program.
        
    04/2001 - Jason Cohen (JCOHEN)
        Added header file with version info so that I can use this info in
        help/about dialog and the resource file.

\****************************************************************************/


#ifndef _APPVER_H_
#define _APPVER_H_


#include <ntverp.h>
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Microsoft Setup Manager Wizard"
#define VER_INTERNALNAME_STR        "SETUPMGR"
#define VER_ORIGINALFILENAME_STR    "SETUPMGR.EXE"
#include <common.ver>


#endif // _APPVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\comres.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// Filename:
//    comres.h
//
// Description:
//      This is the header file associated with common\common.rc.  It is
//      placed in the include directory so that it can be automatically
//      included in setupmgr.h
//
//      common\common.rc contains all the string resources for the
//      setupmgr project.  Common.rc and this file are maintained by
//      hand (no VC).
//
//----------------------------------------------------------------------------

// Wizard page titles & subtitles (300)
#define IDS_NEWOREDIT_TITLE                30000
#define IDS_NEWOREDIT_SUBTITLE             30001
#define IDS_PRODUCT_TITLE                  30004
#define IDS_PRODUCT_SUBTITLE               30005
#define IDS_UNATTENDMODE_TITLE             30006
#define IDS_UNATTENDMODE_SUBTITLE          30007
#define IDS_NAMEORG_TITLE                  30008
#define IDS_NAMEORG_SUBTITLE               30009
#define IDS_PID_TITLE                      30010
#define IDS_PID_SUBTITLE                   30011
#define IDS_NETWORKING_TITLE               30012
#define IDS_NETWORKING_SUBTITLE            30013
#define IDS_DOMAINJ_TITLE                  30014
#define IDS_DOMAINJ_SUBTITLE               30015
#define IDS_SAVESCRIPT_TITLE               30016
#define IDS_SAVESCRIPT_SUBTITLE            30017
#define IDS_PRINTERS_TITLE                 30018
#define IDS_PRINTERS_SUBTITLE              30019
#define IDS_RUNONCE_TITLE                  30020
#define IDS_RUNONCE_SUBTITLE               30021
#define IDS_CMDLINES_TITLE                 30022
#define IDS_CMDLINES_SUBTITLE              30023
#define IDS_ADDDIRS_TITLE                  30024
#define IDS_ADDDIRS_SUBTITLE               30025
#define IDS_COPYFILES_TITLE                30026
#define IDS_COPYFILES_SUBTITLE             30027
#define IDS_TIMEZONE_TITLE                 30028
#define IDS_TIMEZONE_SUBTITLE              30029
#define IDS_TARGETPATH_TITLE               30030
#define IDS_TARGETPATH_SUBTITLE            30031
#define IDS_ADMINPASSWD_TITLE              30032
#define IDS_ADMINPASSWD_SUBTITLE           30033
#define IDS_DISPLAY_TITLE                  30034
#define IDS_DISPLAY_SUBTITLE               30035
#define IDS_COMPNAME_TITLE                 30036
#define IDS_COMPNAME_SUBTITLE              30037
#define IDS_LANWIZ_TITLE                   30038
#define IDS_LANWIZ_SUBTITLE                30039
#define IDS_DISTFOLD_TITLE                 30042
#define IDS_DISTFOLD_SUBTITLE              30043
#define IDS_SRVLICENSE_TITLE               30046
#define IDS_SRVLICENSE_SUBTITLE            30047
#define IDS_ADVANCED_TITLE                 30048
#define IDS_ADVANCED_SUBTITLE              30049
#define IDS_COPYFILES1_TITLE               30050
#define IDS_COPYFILES1_SUBTITLE            30051
#define IDS_NUMNET_TITLE                   30052
#define IDS_NUMNET_SUBTITLE                30053
#define IDS_OEMADS_TITLE                   30054
#define IDS_OEMADS_SUBTITLE                30055
#define IDS_TAPI_TITLE                     30056
#define IDS_TAPI_SUBTITLE                  30057
#define IDS_STANDALONE_TITLE               30058
#define IDS_STANDALONE_SUBTITLE            30059
#define IDS_REGIONAL_TITLE                 30060
#define IDS_REGIONAL_SUBTITLE              30061
#define IDS_LANGUAGES_TITLE                30062
#define IDS_LANGUAGES_SUBTITLE             30063
#define IDS_SIF_TEXT_TITLE                 30064
#define IDS_SIF_TEXT_SUBTITLE              30065
#define IDS_OEM_DUP_STRING_TITLE           30066
#define IDS_OEM_DUP_STRING_SUBTITLE        30067
#define IDS_SCSI_TITLE                     30076
#define IDS_SCSI_SUBTITLE                  30077
#define IDS_HAL_TITLE                      30078
#define IDS_HAL_SUBTITLE                   30079
#define IDS_LICENSEAGREEMENT_TITLE         30080
#define IDS_LICENSEAGREEMENT_SUBTITLE      30081
#define IDS_SYSPREP_FOLDER_TITLE           30082
#define IDS_SYSPREP_FOLDER_SUBTITLE        30083
#define IDS_SYSPREP_COMPNAME_TITLE         30084
#define IDS_SYSPREP_COMPNAME_SUBTITLE      30085
#define IDS_WIZARD_TITLE                   30086
#define IDS_IE_TITLE                       30087
#define IDS_IE_SUBTITLE                    30088
#define IDS_PLATFORM_TITLE                 30089
#define IDS_PLATFORM_SUBTITLE              30090
#define IDS_LICENSE_TITLE                  30091    
#define IDS_LICENSE_SUBTITLE               30092
#define IDS_CONFIG_TITLE                   30093
#define IDS_CONFIG_SUBTITLE                30094
#define IDS_LANG_TITLE                     30095
#define IDS_LANG_SUBTITLE                  30096
#define IDS_CREATE_TITLE                   30097
#define IDS_CREATE_SUBTITLE                30098
#define IDS_MODE_TITLE                     30099
#define IDS_MODE_SUBTITLE                  30100
#define IDS_OEMINFO_TITLE                  30101
#define IDS_OEMINFO_SUBTITLE               30102
#define IDS_LOGO_TITLE                     30103          
#define IDS_LOGO_SUBTITLE                  30104
#define IDS_APPINSTALL_TITLE               30105
#define IDS_APPINSTALL_SUBTITLE            30106
#define IDS_OOBECUST_TITLE                 30107
#define IDS_OOBECUST_SUBTITLE              30108
#define IDS_SCREENSTWO_TITLE               30109   
#define IDS_SCREENSTWO_SUBTITLE            30110
#define IDS_OOBEUSB_TITLE                  30111     
#define IDS_OOBEUSB_SUBTITLE               30112  
#define IDS_HELPCENT_TITLE                 30113
#define IDS_HELPCENT_SUBTITLE              30114
#define IDS_ISP_TITLE                      30117
#define IDS_ISP_SUBTITLE                   30118
#define IDS_OEMCUST_TITLE                  30119
#define IDS_OEMCUST_SUBTITLE               30120
#define IDS_BTITLE_TITLE                   30121
#define IDS_BTITLE_SUBTITLE                30122
#define IDS_BTOOLBARS_TITLE                30123
#define IDS_BTOOLBARS_SUBTITLE             30124
#define IDS_STARTSEARCH_TITLE              30125
#define IDS_STARTSEARCH_SUBTITLE           30126
#define IDS_FAVORITES_TITLE                30127
#define IDS_FAVORITES_SUBTITLE             30128
#define IDS_SCREENS_TITLE                  30131
#define IDS_SCREENS_SUBTITLE               30132
#define IDS_SKU_TITLE                      30133
#define IDS_SKU_SUBTITLE                   30134
#define IDS_STARTMENU_TITLE                30135
#define IDS_STARTMENU_SUBTITLE             30136
#define IDS_OEMLINK_TITLE                  30137
#define IDS_OEMLINK_SUBTITLE               30138
#define IDS_ERROR_VERSION                  30139
#define IDS_PRODUCTKEY_TITLE               30142
#define IDS_PRODUCTKEY_SUBTITLE            30143
#define IDS_OPTCOMP_TITLE                  30144
#define IDS_OPTCOMP_SUBTITLE               30145




// Miscellaneous (100)
#define IDB_BANNER                         30300
#define IDB_WATERMARK                      30301
#define IDS_LARGEFONTNAME                  30302
#define IDS_LARGEFONTSIZE                  30303
#define IDS_DONTSPECIFYSETTING             30304
#define IDI_DOWN_ARROW                     30305
#define IDI_UP_ARROW                       30306
#define IDS_ERROR                          30308
#define IDS_ERROR_OUTOFMEMORY              30309
#define IDS_SMALLFONTNAME                  30310
#define IDS_SMALLFONTSIZE                  30311
#define IDS_WELCOME_TEXT_OEM               30312
#define IDS_WELCOME_TEXT_CORP              30313

// general purpose error strings (200)
#define IDS_ERR_CREATE_FOLDER              30400
#define IDS_ERR_DELETE_FOLDER              30401
#define IDS_ERR_COPY_FILE                  30402
#define IDS_ERR_DELETE_FILE                30403
#define IDS_ERR_ENTER_FILENAME             30404
#define IDS_ERR_CANNOT_COPY_PATH           30405
#define IDS_DELETE_FOLDER_CONFIRM          30406
#define IDS_DELETE_FILE_CONFIRM            30407
#define IDS_ERR_OUT_OF_MEMORY              30408

// error strings from 'common' code (200)
#define IDS_WARN_CANCEL_WIZARD             30600
#define IDS_ERR_CANNOT_FIND_ANSWER_FILE    30601
#define IDS_ERR_FILE_NOT_SETUPMGR          30602
#define IDS_ERR_SAVEFILE_NOT_SETUPMGR      30603
#define IDS_ERRORS_WRITING_ANSWER_FILE     30604
#define IDS_ERRORS_WRITING_UDF             30605
#define IDS_ERR_OPEN_SAMPLE_BAT            30606
#define IDS_FATAL_ERR_CREATE_PAGE          30607
#define IDS_ERR_BAD_SCRIPT_EXTENSION       30608
#define IDS_ERR_LOCATING_PRINTERS          30609
#define IDS_INSERT_CD                      30610
#define IDS_ERR_FILE_ALREADY_EXISTS        30611
#define IDS_USAGE                          30612

// error messages from 'main' pages (200)
#define IDS_ERR_NO_CDROM_DRIVE                  30800
#define IDS_ERR_INSERT_CD                       30801
#define IDS_ERR_ADDING_TVITEM                   30802
#define IDS_OPEN_CMDLINES_FAILED                30803
#define IDS_ERR_ENTER_SETUP_PATH                30804
#define IDS_WARN_COPY_CANCEL                    30805
#define IDS_ERR_INSUFICIENT_SPACE               30806
#define IDS_ERR_NOT_PRODUCT                     30807
#define IDS_ERR_CREATING_DISTFOLD               30808
#define IDS_ERR_FOLDER_IS_FILE                  30809
#define IDS_ERR_FOLDER_NOT_EXIST                30810
#define IDS_ERR_DISTFOLD_EXISTS                 30811
#define IDS_ERR_NOT_VALID_DISTFOLD              30812
#define IDS_ERR_ENTER_SHARENAME                 30813
#define IDS_ERR_SHARENAME_INUSE                 30814
#define IDS_ERR_ENABLE_SHARE                    30815
#define IDS_ERR_UNABLE_TO_COPY_SYSPREP_FILE     30816
#define IDS_ERR_SPECIFY_FILE                    30817
#define IDS_ERR_SPECIFY_LANG_PATH               30818
#define IDS_ERR_UNABLE_TO_COPY_LANG_DIR         30819
#define IDS_ERR_NOT_NT5_FILES                   30820
#define IDS_ERR_NOT_WORKSTATION_FILES           30821
#define IDS_ERR_NOT_SERVER_FILES                30822
#define IDS_ERR_CANNOT_DETERMINE_VERSION        30823
#define IDS_ERR_CANNOT_DETERMINE_PRODUCT        30824
#define IDS_ERR_ENTER_DIST_FOLDER               30825
#define IDS_ERR_UNABLE_TO_DETERMINE_FREE_SPACE  30826
#define IDS_ERR_CANNOT_GET_LOCAL_COMPNAME       30827
#define IDS_ERR_NO_PATH_CHOSEN                  30828
#define IDS_ERR_CANNOT_FIND_LANG_FILE           30829
#define IDS_ERR_NEED_DIST_FOLDER_FOR_FILES      30830
#define IDS_ERR_INS_FILE_NO_COPY                30831
#define IDS_ERR_NEED_SYSPREP_FOLDER_FOR_FILES   30832
#define IDS_ERR_MIGHT_NEED_SYSPREP_FOLDER_FOR_FILES 30833
#define IDS_ERR_PASSWORD_ENCRYPT_FAILED         30834
#define IDS_ERR_NOTWINDOWSCD                    30835
#define IDS_ERR_NOT_PERSONAL_FILES              30836
#define IDS_ERR_NOT_ENTERPRISE_FILES            30837
#define IDS_ERR_NOT_WEBBLADE_FILES              30838

// misc errors specific to base pages (200)
#define IDS_ERR_INVALID_COMPUTER_NAME          31000
#define IDS_ERR_MISMATCH_PASSWORD              31001
#define IDS_ERR_INVALID_PRINTER_NAME           31002
#define IDS_ERR_SPECIFY_TARGPATH               31003
#define IDS_ERR_CANNOT_LOAD_TIMEZONES          31004
#define IDS_ERR_REQUIRE_USERNAME               31005
#define IDS_ERR_REQUIRE_ORGNAME                31006
#define IDS_ERR_REQUIRE_PID                    31007
#define IDS_ERR_REQUIRE_COMPUTERNAME           31008
#define IDS_ERR_INVALID_COMPUTER_NAME_IN_FILE  31009
#define IDS_ERR_INVALID_TARGPATH               31010
#define IDS_ERR_DRIVE_IN_TARGPATH              31011
#define IDS_ERR_MUST_ACCEPT_EULA               31012
#define IDS_ERR_FULL_UNATTEND_REGION_SET       31013
#define IDS_ERR_SYSPREP_REQUIRE_COMPNAME       31014
#define IDS_WARN_NO_PASSWORD_AUTOLOGON         31015
#define IDS_ERR_USERNAME_INVALID               31016

// Display page
#define IDS_DISP_WINDOWS_DEFAULT           31200
#define IDS_DISP_NUM_COLORS                31201
#define IDS_DISP_HIGH_COLOR                31202
#define IDS_DISP_TRUE_COLOR                31203
#define IDS_DISP_HERTZ                     31204
#define IDS_INVALID_BITS_PER_PEL           31205
#define IDS_INVALID_X_RESOLUTION           31206
#define IDS_INVALID_Y_RESOLUTION           31207
#define IDS_INVALID_REFRESH_RATE           31208
#define IDS_INVALID_BITS_PER_PEL_HIGH      31209

// Additional Dirs page
#define IDS_OEMROOT_NAME                   31220
#define IDS_SYSDRIVE_NAME                  31221
#define IDS_SYSDIR_NAME                    31222
#define IDS_OTHERDRIVES_NAME               31223
#define IDS_PNPDRIVERS_NAME                31224
#define IDS_TEMPFILES_NAME                 31225
#define IDS_LANGFILES_NAME                 31226
#define IDS_SYSPREPFILES_NAME              31227
#define IDS_TEXTMODE_NAME                  31228
#define IDS_ADD_DESCR_ROOT                 31229
#define IDS_ADD_DESCR_SYSDRIVE             31230
#define IDS_ADD_DESCR_WINNT                31231
#define IDS_ADD_DESCR_OTHER                31232
#define IDS_ADD_DESCR_PNP                  31233
#define IDS_ADD_DESCR_TEMP                 31234
#define IDS_ADD_DESCR_LANG                 31235
#define IDS_ADD_DESCR_SYSPREP              31236
#define IDS_ADD_DESCR_TEXTMODE             31237
#define IDS_SELECT_FILE_OR_FOLDER          31238

// Runonce page
#define IDS_ADD_PRINTER                    31240

// Copyfil1 page
#define IDS_SERVER_CD_NAME                 31260
#define IDS_WORKSTATION_CD_NAME            31261

// Copyfiles page
#define IDS_COPYMSG1                       31280
#define IDS_COPYMSG2                       31281
#define IDS_FILE_ALREADY_EXISTS            31282
#define IDS_MODIFIED                       31283
#define IDS_BYTES                          31284

//  Networking (200)
#define IDS_CLIENT_FOR_MS_NETWORKS         31300
#define IDS_CLIENT_FOR_MS_NETWORKS_DESC    31301
#define IDS_CLIENT_FOR_NETWARE             31302
#define IDS_CLIENT_FOR_NETWARE_DESC        31303
#define IDS_FILE_AND_PRINT_SHARING         31304
#define IDS_FILE_AND_PRINT_SHARING_DESC    31305
#define IDS_PACKET_SCHEDULING_DRIVER       31306
#define IDS_PACKET_SCHEDULING_DRIVER_DESC  31307
#define IDS_APPLETALK_PROTOCOL             31308
#define IDS_APPLETALK_PROTOCOL_DESC        31309
#define IDS_TCPIP                          31310
#define IDS_TCPIP_DESC                     31311
#define IDS_NETWORK_MONITOR_AGENT          31312
#define IDS_NETWORK_MONITOR_AGENT_DESC     31313
#define IDS_IPX_PROTOCOL                   31314
#define IDS_IPX_PROTOCOL_DESC              31315
#define IDS_DLC_PROTOCOL                   31316
#define IDS_DLC_PROTOCOL_DESC              31317
#define IDS_NETBEUI_PROTOCOL               31318
#define IDS_NETBEUI_PROTOCOL_DESC          31319
#define IDS_GATEWAY_FOR_NETWARE            31320
#define IDS_GATEWAY_FOR_NETWARE_DESC       31321
#define IDS_SAP_AGENT                      31322
#define IDS_SAP_AGENT_DESC                 31323
#define IDS_TCPIP_TITLE                    31324
#define IDS_IPX_PROTOCOL_TITLE             31325
#define IDS_MSCLIENT_TITLE                 31326
#define IDS_APPLETALK_TITLE                31327

//  TimeZone page
#define IDS_SET_SAME_AS_SERVER             31500

// StandAlone page
#define IDS_STANDALONE_TEXT1               31520
#define IDS_STANDALONE_TEXT2               31521

// Unattend Mode page
#define IDS_UMODE_FULLUNATTEND             31540
#define IDS_UMODE_PROVIDE_DEFAULTS         31541
#define IDS_UMODE_DEFAULT_HIDE             31542
#define IDS_UMODE_READONLY                 31543
#define IDS_UMODE_GUI_ATTENDED             31544

// Sif Text page
#define IDS_SIF_DEFAULT_DESCRIPTION        31560
#define IDS_SIF_DEFAULT_HELP_TEXT          31561

// Network errors
#define IDS_ERR_NETWORK_BAD_DEVICE         31600       
#define IDS_ERR_NETWORK_NOT_CONNECTED      31601
#define IDS_ERR_NETWORK_CONNECTION_UNAVAIL 31602
#define IDS_ERR_NETWORK_NO_NETWORK         31603
#define IDS_ERR_NETWORK_EXTENDED_ERROR     31604
#define IDS_ERR_NETWORK_UNKNOWN_ERROR      31605
#define IDS_ERR_NETWORK_ACCESS_DENIED      31606

//
//  misc errors reported by 'oc' pages
//
#define IDS_ERR_BAD_AREA_CODE              31620
#define IDS_ERR_BAD_OUTSIDE_LINE           31621
#define IDS_ERR_FRIENDLY_NAME_BLANK        31622
#define IDS_ERR_URL_BLANK                  31623
#define IDS_ERR_INS_FILE_NOT_EXIST         31624

// Save screen page
#define IDS_WINNTSIF_TEXT                  31660

// Sysprep License page
#define IDS_SYSPREP_LICENSE_TEXT           31700

// Distribution Folder page
#define IDS_SELECT_DISTRIB_FOLDER          31740
#define IDS_WINDOWS_DISTRIB_FOLDER         31741

// Browse pop-up strings
#define IDS_TEXT_FILES                     31780
#define IDS_ALL_FILES                      31781
#define IDS_EXECUTABLE_FILES               31782
#define IDS_BITMAP_FILES                   31783
#define IDS_HAL_FILES                      31784
#define IDS_SCSI_FILES                     31785
#define IDS_REMOTE_BOOT_FILES              31786
#define IDS_SYSPREP_FILES                  31787

// Batch script strings
#define IDS_BATCH_SCRIPT_LINE1             31820
#define IDS_BATCH_SCRIPT_LINE2             31821

// Date strings
#define IDS_JANUARY                        31860
#define IDS_FEBRUARY                       31861
#define IDS_MARCH                          31862
#define IDS_APRIL                          31863
#define IDS_MAY                            31864
#define IDS_JUNE                           31865
#define IDS_JULY                           31866
#define IDS_AUGUST                         31867
#define IDS_SEPTEMBER                      31868
#define IDS_OCTOBER                        31869
#define IDS_NOVEMBER                       31870
#define IDS_DECEMBER                       31871
#define IDS_SUNDAY                         31872
#define IDS_MONDAY                         31873
#define IDS_TUESDAY                        31874
#define IDS_WEDNESDAY                      31875
#define IDS_THURSDAY                       31876
#define IDS_FRIDAY                         31877
#define IDS_SATURDAY                       31878

#define IDI_SETUPMGR                       100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\dlgprocs.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      dlgprocs.h
//
// Description:
//      This file contains the dialog proc prototypes for all the wizard pages
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgPlatformPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam );

INT_PTR CALLBACK DlgIePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgSysprepComputerNamePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgSysprepFolderPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgSysprepLicensePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgLicensePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgHalPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgScsiPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgIeAutoConfigPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgIeProxyPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgIeHomePagePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgIeBeginPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgOemDuplicatorStringPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam );

INT_PTR CALLBACK DlgSifTextSettingsPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgLangSettingsPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgRegionalSettingsPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgTapiPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgOemAdsPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgNumberNetCardsPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgLANWizardPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgProductPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgUnattendModePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgNameOrgPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgProductIdPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgSrvLicensePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgTargetPathPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgAdminPasswordPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgDisplayPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgComputerNamePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgRunOncePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgCommandLinesPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgAdditionalDirsPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgSaveScriptPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgCopyFilesPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgCopyFiles1Page(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgAdvanced1Page(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgWelcomePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgFinishPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgFinish2Page(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgEditOrNewPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgDistFolderPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgStandAlonePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgDomainJoinPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgPrintersPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DlgTimeZonePage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK WelcomeDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

#ifndef NO_LICENSE

INT_PTR CALLBACK LicenseDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

#endif

INT_PTR CALLBACK ConfigDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK LangDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK CreateDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

INT_PTR CALLBACK ModeDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK OemInfoDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

INT_PTR CALLBACK ProductKeyDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

INT_PTR CALLBACK LogoDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK ScreensDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

INT_PTR CALLBACK ScreensTwoDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);                                   


INT_PTR CALLBACK HelpCenterDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK AppInstallDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

#ifdef BRANDTITLE

INT_PTR CALLBACK BrandTitleDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

#endif


INT_PTR CALLBACK BToolbarsDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK FavoritesDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK StartSearchDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK IspDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK OobeCustDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK OobeUSBDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

#ifdef OEMCUST

INT_PTR CALLBACK OemCustDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

#endif

INT_PTR CALLBACK SkuDlgProc(
    IN HWND,
    IN UINT,
    IN WPARAM,
    IN LPARAM);                             


INT_PTR CALLBACK SaveAsDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK CompleteDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);

INT_PTR CALLBACK StartMenuDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK OemLinkDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK DeskFldrDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);


INT_PTR CALLBACK OptionalCompDlgProc(
    IN HWND, 
    IN UINT, 
    IN WPARAM, 
    IN LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\jcohen.h ===
/****************************************************************************\

    JCOHEN.H / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Contains common macros, defined values, and other stuff I use all the
    time.

    1/98 - Jason Cohen (JCOHEN)
        Originally created as a helper header file for all my projects.

    4/99 - Jason Cohen (JCOHEN)
        Added this new header file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


#ifndef _JCOHEN_H_
#define _JCOHEN_H_


//
// Include files
//

#include <windows.h>
#include <tchar.h>

#ifdef NULLSTR
#undef NULLSTR
#endif // NULLSTR
#define NULLSTR _T("\0")

#ifdef NULLCHR
#undef NULLCHR
#endif // NULLCHR
#define NULLCHR _T('\0')

//
// Macros.
//

// Memory managing macros.
//
#ifdef MALLOC
#undef MALLOC
#endif // MALLOC
#define MALLOC(cb)          HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)

#ifdef REALLOC
#undef REALLOC
#endif // REALLOC
#define REALLOC(lp, cb)     HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, lp, cb)

#ifdef FREE
#undef FREE
#endif // FREE
#define FREE(lp)            ( (lp != NULL) ? ( (HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, (LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )

#ifdef NETFREE
#undef NETFREE
#endif // NETFREE
#define NETFREE(lp)         ( (lp != NULL) ? ( (NetApiBufferFree((LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )

// Misc. macros.
//
#ifdef EXIST
#undef EXIST
#endif // EXIST
#define EXIST(lpFileName)   ( (GetFileAttributes(lpFileName) == 0xFFFFFFFF) ? (FALSE) : (TRUE) )

#ifdef ISNUM
#undef ISNUM
#endif // ISNUM
#define ISNUM(cChar)        ( ((cChar >= _T('0')) && (cChar <= _T('9'))) ? (TRUE) : (FALSE) )

#ifdef UPPER
#undef UPPER
#endif // UPPER
#define UPPER(x)            ( ( (x >= _T('a')) && (x <= _T('z')) ) ? (x + _T('A') - _T('a')) : (x) )

#ifdef RANDOM
#undef RANDOM
#endif // RANDOM
#define RANDOM(low, high)   ( (high - low + 1) ? (rand() % (high - low + 1) + low) : (0) )

#ifdef COMP
#undef COMP
#endif // COMP
#define COMP(x, y)          ( (UPPER(x) == UPPER(y)) ? (TRUE) : (FALSE) )

#ifdef STRSIZE
#undef STRSIZE
#endif // STRSIZE
#define STRSIZE(sz)         ( sizeof(sz) / sizeof(TCHAR) )

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif // ARRAYSIZE
#define ARRAYSIZE(a)         ( sizeof(a) / sizeof(a[0]) )


#endif // _JCOHEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\exe\wizard.c ===
/****************************************************************************\

    WIZARD.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Wizard source file for wizard functions used in the OPK Wizard.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include file(s)
//
#include "setupmgr.h"
#include "allres.h"
#include "sku.h"
#include "appver.h"

//
// Internal Function(s):
//

// TreeView Helper Functions
//
static void ShowTreeDialog(HWND, LPTREEDLG);
static void ShowSplashDialog(HWND, DWORD);
static void FillTreeDialog(HWND);
static void UpdateTreeVisibility(HWND);
static LPTREEDLG GetTreeItem(HWND, HTREEITEM);
static BOOL SelectTreeItem(HWND, HTREEITEM, UINT);
static BOOL SelectFirstMaintenanceDlg(HWND);

// Configuration/Profile Helper Functions
//
static BOOL CloseProfile(HWND, BOOL);
static void OpenProfile(HWND, BOOL);
static void SaveProfile(HWND);

// Miscellaneous Helper Functions
//
static void OnCommand(HWND, INT, HWND, UINT);
static void EnableControls(HWND);
void SetWizardButtons(HWND, DWORD);

BOOL CALLBACK AboutDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

//
// Page arrays: There are four total arrays
//      OEM/System Builder Pages
//          vdpOEMWizardDialogs - Starting Wizard Pages
//          vdpOEMTreeDialogs   - Tree Dialogs
//      Corporate Deployment
//          vdpCDWizardDialogs  - Starting Wizard Pages
//          vdpCDTreeDialogs    - Tree Dialogs
//
static WIZDLG vdpOEMWizardDialogs[]=
{
    {
        IDD_WELCOME,
        WelcomeDlgProc,
        0,
        0,
        PSP_DEFAULT | PSP_HIDEHEADER
    },

#ifndef NO_LICENSE
    {
        IDD_LICENSE,
        LicenseDlgProc,
        IDS_LICENSE_TITLE,
        IDS_LICENSE_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },
#endif  // NO_LICENSE   

    {
        IDD_CONFIG,
        ConfigDlgProc,
        IDS_CONFIG_TITLE,
        IDS_CONFIG_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_LANG,       	
        LangDlgProc,
        IDS_LANG_TITLE,
        IDS_LANG_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_CREATE,
        CreateDlgProc,
        IDS_CREATE_TITLE,
        IDS_CREATE_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_MODE,
        ModeDlgProc,
        IDS_MODE_TITLE,
        IDS_MODE_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_SKU,
        SkuDlgProc,
        IDS_SKU_TITLE,
        IDS_SKU_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_OEMINFO,
        OemInfoDlgProc,
        IDS_OEMINFO_TITLE,
        IDS_OEMINFO_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },
};

static WIZDLG vdpCDWizardDialogs[]=
{
    {
        IDD_WELCOME,
        DlgWelcomePage,
        0,
        0,
        PSP_DEFAULT | PSP_HIDEHEADER
    },

    {
        IDD_NEWOREDIT,
        DlgEditOrNewPage,
        IDS_NEWOREDIT_TITLE,
        IDS_NEWOREDIT_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_PRODUCT,
        DlgProductPage,
        IDS_PRODUCT_TITLE,
        IDS_PRODUCT_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    { 
        IDD_PLATFORM,
        DlgPlatformPage,
        IDS_PLATFORM_TITLE,
        IDS_PLATFORM_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_UNATTENDMODE,
        DlgUnattendModePage,
        IDS_UNATTENDMODE_TITLE,
        IDS_UNATTENDMODE_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_STANDALONE,
        DlgStandAlonePage,
        IDS_STANDALONE_TITLE,
        IDS_STANDALONE_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_COPYFILES1,
        DlgCopyFiles1Page,
        IDS_COPYFILES1_TITLE,
        IDS_COPYFILES1_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    { 
        IDD_DISTFOLDER,
        DlgDistFolderPage,
        IDS_DISTFOLD_TITLE,
        IDS_DISTFOLD_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_LICENSEAGREEMENT,
        DlgLicensePage,
        IDS_LICENSEAGREEMENT_TITLE,
        IDS_LICENSEAGREEMENT_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },

    {
        IDD_SYSPREPLICENSEAGREEMENT,
        DlgSysprepLicensePage,
        IDS_LICENSEAGREEMENT_TITLE,
        IDS_LICENSEAGREEMENT_SUBTITLE,
        DEFAULT_PAGE_FLAGS
    },
};

static TREEDLG vdpOEMTreeDialogs[] = 
{
    { 
        0,
        NULL,
        IDS_DLG_GENERAL,
        IDS_DLG_GENERAL,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_MODE,
        ModeDlgProc,
        IDS_MODE_TITLE,
        IDS_MODE_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_SKU,
        SkuDlgProc,
        IDS_SKU_TITLE,
        IDS_SKU_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    { 
        IDD_OEMINFO,
        OemInfoDlgProc,
        IDS_OEMINFO_TITLE,
        IDS_OEMINFO_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

        { 
        IDD_PRODUCTKEY,
        ProductKeyDlgProc,
        IDS_PRODUCTKEY_TITLE,
        IDS_PRODUCTKEY_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_APPINSTALL,
        AppInstallDlgProc,
        IDS_APPINSTALL_TITLE,
        IDS_APPINSTALL_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_LOGO,
        LogoDlgProc,
        IDS_LOGO_TITLE,
        IDS_LOGO_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    { 
        0,
        NULL,
        IDS_DLG_OOBE,
        IDS_DLG_OOBE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_OOBECUST,
        OobeCustDlgProc,
        IDS_OOBECUST_TITLE,
        IDS_OOBECUST_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_SCREENSTWO,
        ScreensTwoDlgProc,
        IDS_SCREENSTWO_TITLE,
        IDS_SCREENSTWO_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_SCREENS,
        ScreensDlgProc,
        IDS_SCREENS_TITLE,
        IDS_SCREENS_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },
        
    {
        IDD_OOBEUSB,
        OobeUSBDlgProc,
        IDS_OOBEUSB_TITLE,
        IDS_OOBEUSB_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_ISP,
        IspDlgProc,
        IDS_ISP_TITLE,
        IDS_ISP_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

#ifdef HELPCENTER
    {
        IDD_HELPCENT,
        HelpCenterDlgProc,
        IDS_HELPCENT_TITLE,
        IDS_HELPCENT_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },
#endif

    { 
        0,
        NULL,
        IDS_DLG_IEAK,
        IDS_DLG_IEAK,
        NULL,
        NULL,
        TRUE    
    },

#ifdef OEMCUST
    {
        IDD_OEMCUST,
        OemCustDlgProc,
        IDS_OEMCUST_TITLE,
        IDS_OEMCUST_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },
#endif // OEMCUST

#ifdef BRANDTITLE
    {
        IDD_BTITLE,
        BrandTitleDlgProc,
        IDS_BTITLE_TITLE,
        IDS_BTITLE_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },
#endif // BRANDTITLE

    {
        IDD_BTOOLBARS,
        BToolbarsDlgProc,
        IDS_BTOOLBARS_TITLE,
        IDS_BTOOLBARS_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_STARTSEARCH,
        StartSearchDlgProc,
        IDS_STARTSEARCH_TITLE,
        IDS_STARTSEARCH_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_FAVORITES,
        FavoritesDlgProc,
        IDS_FAVORITES_TITLE,
        IDS_FAVORITES_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        0,
        NULL,
        IDS_DLG_SHELLSETTINGS,
        IDS_DLG_SHELLSETTINGS,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_STARTMENU,
        StartMenuDlgProc,
        IDS_STARTMENU_TITLE,
        IDS_STARTMENU_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_OEMLINK,
        OemLinkDlgProc,
        IDS_OEMLINK_TITLE,
        IDS_OEMLINK_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },
    
};

static TREEDLG vdpCDTreeDialogs[] = 
{
    {
        0,
        NULL,
        IDS_DLG_GENERAL,
        IDS_DLG_GENERAL,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_NAMEORG,
        DlgNameOrgPage,
        IDS_NAMEORG_TITLE,
        IDS_NAMEORG_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_DISPLAY,
        DlgDisplayPage,
        IDS_DISPLAY_TITLE,
        IDS_DISPLAY_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_TIMEZONE,
        DlgTimeZonePage,
        IDS_TIMEZONE_TITLE,
        IDS_TIMEZONE_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_PID_CD,
        DlgProductIdPage,
        IDS_PID_TITLE,
        IDS_PID_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        0,
        NULL,
        IDS_DLG_NETWORK,
        IDS_DLG_NETWORK,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_SRVLICENSE,
        DlgSrvLicensePage,
        IDS_SRVLICENSE_TITLE,
        IDS_SRVLICENSE_SUBTITLE,
        NULL,
        NULL,
        FALSE
    },

    {
        IDD_COMPUTERNAME,
        DlgComputerNamePage,
        IDS_COMPNAME_TITLE,
        IDS_COMPNAME_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_SYSPREPCOMPUTERNAME,
        DlgSysprepComputerNamePage,
        IDS_SYSPREP_COMPNAME_TITLE,
        IDS_SYSPREP_COMPNAME_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_ADMINPASSWORD,
        DlgAdminPasswordPage,
        IDS_ADMINPASSWD_TITLE,
        IDS_ADMINPASSWD_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_LANWIZ_DLG,
        DlgLANWizardPage,
        IDS_LANWIZ_TITLE,
        IDS_LANWIZ_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_DOMAINJ,
        DlgDomainJoinPage,    
        IDS_DOMAINJ_TITLE,
        IDS_DOMAINJ_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        0,
        NULL,
        IDS_DLG_ADVANCED,
        IDS_DLG_ADVANCED,
        NULL,
        NULL,
        TRUE
    },

// If we define OPTCOMP we will display the optional components page otherwise this will be hidden.  This page was removed
// for ISSUE: 628520
//
#ifdef OPTCOMP
    {
        IDD_OPTCOMP,
        OptionalCompDlgProc,
        IDS_OPTCOMP_TITLE,
        IDS_OPTCOMP_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },
#endif


    {
        IDD_TAPI,
        DlgTapiPage,
        IDS_TAPI_TITLE,
        IDS_TAPI_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_REGIONALSETTINGS,
        DlgRegionalSettingsPage,
        IDS_REGIONAL_TITLE,
        IDS_REGIONAL_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_LANGUAGESETTINGS,
        DlgLangSettingsPage,
        IDS_LANGUAGES_TITLE,
        IDS_LANGUAGES_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_IE,
        DlgIePage,
        IDS_IE_TITLE,
        IDS_IE_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_TARGETPATH,
        DlgTargetPathPage,
        IDS_TARGETPATH_TITLE,
        IDS_TARGETPATH_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_PRINTERS,
        DlgPrintersPage,
        IDS_PRINTERS_TITLE,
        IDS_PRINTERS_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_RUNONCE,
        DlgRunOncePage,
        IDS_RUNONCE_TITLE,
        IDS_RUNONCE_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_CMDLINES,
        DlgCommandLinesPage,
        IDS_CMDLINES_TITLE,
        IDS_CMDLINES_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_SIFTEXT,
        DlgSifTextSettingsPage,
        IDS_SIF_TEXT_TITLE,
        IDS_SIF_TEXT_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },

    {
        IDD_OEMDUPSTRING,
        DlgOemDuplicatorStringPage,
        IDS_OEM_DUP_STRING_TITLE,
        IDS_OEM_DUP_STRING_SUBTITLE,
        NULL,
        NULL,
        TRUE
    },
    
};


static SPLASHDLG vdpSplashDialogs[] = 
{
    {
        IDD_COMPLETE,
        CompleteDlgProc,
        NULL
    },

    {
        IDD_FINISH,
        DlgFinishPage,
        NULL
    },

    
};


//
// Global Variable(s):
//
HWND    g_hCurrentDialog;       // Current dialog being displayed by the tree view
DWORD   g_dwWizardPages;        // Total number of wizard pages for initial wizard
DWORD   g_dwTreePages;          // Total number of pages for tree view control



//----------------------------------------------------------------------------
//
// Function: CreateWizard
//
// Purpose: This function is responsible for creating the initial wizard
//
//----------------------------------------------------------------------------
int CreateWizard(HINSTANCE hInstance, HWND hWndParent)
{    
    // Local variables.
    //
    PROPSHEETHEADER PropSheetHeader;
    PROPSHEETPAGE   PropPage;
    HPROPSHEETPAGE  *PageHandles;
    WIZDLG          *pPage;
    DWORD           nIndex  = 0;
    int             nReturn = 0;


    // Zero out this memory we are going to use
    //
    ZeroMemory(&PropSheetHeader, sizeof(PROPSHEETHEADER));
    ZeroMemory(&PropPage, sizeof(PROPSHEETPAGE));

    // Allocate the buffer for the handles to the wizard pages
    //
    if ((PageHandles = MALLOC(g_dwWizardPages * sizeof(HPROPSHEETPAGE))) != NULL )
    {
        // Setup all the property sheet pages.
        //
        for ( nIndex=0; nIndex<g_dwWizardPages; nIndex++ )
        {
            // Assign all the values for this property sheet.
            //
            pPage = (GET_FLAG(OPK_OEM) ?  &vdpOEMWizardDialogs[nIndex] : &vdpCDWizardDialogs[nIndex]);

            PropPage.dwSize              = sizeof(PROPSHEETPAGE);
            PropPage.hInstance           = hInstance;
            PropPage.pszTemplate         = MAKEINTRESOURCE(pPage->dwResource);
            PropPage.pszHeaderTitle      = MAKEINTRESOURCE(pPage->dwTitle);
            PropPage.pszHeaderSubTitle   = MAKEINTRESOURCE(pPage->dwSubTitle);
            PropPage.pfnDlgProc          = pPage->dlgWindowProc;
            PropPage.dwFlags             = pPage->dwFlags;

            // If there is no help file, don't show the help.
            //
            if ( !EXIST(g_App.szHelpFile) )
                PropPage.dwFlags &= ~PSP_HASHELP;

#ifndef USEHELP
            PropPage.dwFlags &= ~PSP_HASHELP;
#endif

            // Dynamically create the property sheet
            //
            PageHandles[nIndex] = CreatePropertySheetPage(&PropPage);
        }


        // Setup the property sheet header.
        //
        PropSheetHeader.dwSize         = sizeof(PROPSHEETHEADER);
        PropSheetHeader.dwFlags        = PSH_WIZARD97  |
                                         PSH_WATERMARK |
#ifdef USEHELP
                                         PSH_HASHELP   |   
#endif
                                         PSH_HEADER    |
                                         PSH_USEICONID |
                                         PSH_USECALLBACK;
        PropSheetHeader.hInstance      = hInstance;
        PropSheetHeader.hwndParent     = hWndParent;
        PropSheetHeader.pszCaption     = NULL;
        PropSheetHeader.phpage         = PageHandles;
        PropSheetHeader.nStartPage     = 0;
        PropSheetHeader.nPages         = g_dwWizardPages;
        PropSheetHeader.pszbmWatermark = MAKEINTRESOURCE(IDB_WATERMARK);
        PropSheetHeader.pszbmHeader    = MAKEINTRESOURCE(IDB_BANNER);
        PropSheetHeader.pszIcon        = MAKEINTRESOURCE(IDI_SETUPMGR);
        PropSheetHeader.pfnCallback    = WizardCallbackProc;

        // We are activating the wizard
        //
        SET_FLAG(OPK_ACTIVEWIZ, TRUE);

        // Run the wizard.
        //
        nReturn = (int) PropertySheet(&PropSheetHeader);

        // We are done with the wizard
        //
        SET_FLAG(OPK_ACTIVEWIZ, FALSE);

        // Clean up the allocated memory
        //
        FREE(PageHandles);


    }
    else
    {
        // We were unable to allocate memory
        //
        MsgBox(hWndParent, IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
    }

    return nReturn;
}


//----------------------------------------------------------------------------
//
// Function: CreateMaintenanceWizard
//
// Purpose: This function creates the maintenance dialog, the main dialog for 
//          Setup Manager
//
//----------------------------------------------------------------------------
int CreateMaintenanceWizard(HINSTANCE hInstance, HWND hWndParent)
{
    TCHAR                   szMessage[MAX_PATH] = NULLSTR;
    HWND                    hChild;
    INITCOMMONCONTROLSEX    icc;

    // ISSUE-2002/02/28-stelo- Both the parameters are not being used. ASSERT on Invalid Parameters if used.

    // Set the global wizard pages sizes based on OEM tag file
    //
    g_dwWizardPages = ((GET_FLAG(OPK_OEM) ? sizeof(vdpOEMWizardDialogs) : sizeof(vdpCDWizardDialogs)) / sizeof(WIZDLG));
    g_dwTreePages   = ((GET_FLAG(OPK_OEM) ? sizeof(vdpOEMTreeDialogs) : sizeof(vdpCDTreeDialogs)) / sizeof(TREEDLG));


    // Make sure the common controls are loaded and ready to use.
    //
    icc.dwSize = sizeof(icc);
    icc.dwICC  = ICC_WIN95_CLASSES; // loads most commonly used WIN95 classes.

    InitCommonControlsEx(&icc);

    return( (int) DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_MAINT), NULL, MaintDlgProc) );
}

int CALLBACK WizardCallbackProc(HWND hwnd, UINT uMsg, LPARAM lParam)
{
    if ( uMsg==PSCB_INITIALIZED )
        WizardSubWndProc(hwnd, WM_SUBWNDPROC, 0, 0L);

    return 1;
}

LONG CALLBACK WizardSubWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static FARPROC lpfnOldProc = NULL;

    switch ( msg )
    {
        case WM_SUBWNDPROC:
            lpfnOldProc = (FARPROC) GetWindowLongPtr(hwnd, GWLP_WNDPROC);
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) WizardSubWndProc);
            return 1;

        case WM_HELP:
            WIZ_HELP();
            break;
    }

    if ( lpfnOldProc )
        return (LONG) CallWindowProc((WNDPROC) lpfnOldProc, hwnd, msg, wParam, lParam);
    else
        return 0;
}

//----------------------------------------------------------------------------
//
// Function: MaintDlgProc
//
// Purpose: Main Dialog Proc for Setup Manager
//
//----------------------------------------------------------------------------
LRESULT CALLBACK MaintDlgProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    static HMENU        hMenu;

    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_CLOSE:
            {
                // Exit the maintenence wizard all together
                //
                if ( !GET_FLAG(OPK_CREATED) || CloseProfile(hwnd, TRUE) )
                    EndDialog(hwnd, 0);
                else
                    return TRUE;
            }
            break;

        case WM_INITDIALOG:

            {
                DWORD dwResult;
                RECT  rectHelp, rectCancel, rectBack, rectNext;

                // Load the menu for the maintenance dialog
                //
                if (hMenu = LoadMenu(g_App.hInstance, GET_FLAG(OPK_OEM) ? MAKEINTRESOURCE(IDR_MAIN_OEM) : MAKEINTRESOURCE(IDR_MAIN_CORP)))
                    SetMenu(hwnd, hMenu);

                if ( !EXIST(g_App.szHelpContentFile) )
                    EnableMenuItem(GetMenu(hwnd), ID_HELP_CONTENTS, MF_GRAYED);

                if ( !EXIST(g_App.szHelpFile) )
                    EnableWindow(GetDlgItem(hwnd, IDC_MAINT_HELP), FALSE);

#ifndef USEHELP

                // We are no longer using the help button, we should hide this and move the other controls over
                //
                EnableWindow(GetDlgItem(hwnd, IDC_MAINT_HELP), FALSE);
                ShowWindow(GetDlgItem(hwnd, IDC_MAINT_HELP), SW_HIDE);

                // Move the other buttons to the right
                //
                if ( GetWindowRect(GetDlgItem(hwnd, IDC_MAINT_HELP), &rectHelp) &&
                     GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectCancel) &&
                     GetWindowRect(GetDlgItem(hwnd, ID_MAINT_BACK), &rectBack) &&
                     GetWindowRect(GetDlgItem(hwnd, ID_MAINT_NEXT), &rectNext)
                   )
                {
                    LONG lDelta = 0;

                    // Map the coordinates to the screen
                    //
                    MapWindowPoints(NULL, hwnd, (LPPOINT) &rectHelp, 2);
                    MapWindowPoints(NULL, hwnd, (LPPOINT) &rectCancel, 2);
                    MapWindowPoints(NULL, hwnd, (LPPOINT) &rectBack, 2);
                    MapWindowPoints(NULL, hwnd, (LPPOINT) &rectNext, 2);

                    // Determine the delta
                    //
                    lDelta = rectHelp.left - rectCancel.left;

                    // Set the new window position
                    //
                    SetWindowPos(GetDlgItem(hwnd, IDCANCEL), NULL, rectCancel.left+lDelta, rectCancel.top, 0, 0, SWP_NOSIZE | SWP_NOOWNERZORDER);
                    SetWindowPos(GetDlgItem(hwnd, ID_MAINT_BACK), NULL, rectBack.left+lDelta, rectBack.top, 0, 0, SWP_NOSIZE | SWP_NOOWNERZORDER);
                    SetWindowPos(GetDlgItem(hwnd, ID_MAINT_NEXT), NULL, rectNext.left+lDelta, rectNext.top, 0, 0, SWP_NOSIZE | SWP_NOOWNERZORDER);
                }
#endif

                // Load the icon into the wizard window
                //
                SetClassLongPtr(hwnd, GCLP_HICON, (LONG_PTR) LoadIcon(g_App.hInstance, MAKEINTRESOURCE(IDI_OPKSETUP)));

                // Make the title text bold
                //
                SetWindowFont(GetDlgItem(hwnd, IDC_MAINT_TITLE), FixedGlobals.hBoldFont, TRUE);

                // Show the Maintenance Wizard
                //
                ShowWindow(hwnd, SW_SHOW);

                // Create the Wizard dialog
                //
                dwResult = CreateWizard(g_App.hInstance, hwnd);

                // Populate the tree dialog
                //
                FillTreeDialog(hwnd);

                if ( !dwResult )
                {
                    CloseProfile(hwnd, FALSE);
                    return FALSE;
                }

                // Enable the tree view
                //
                EnableWindow(GetDlgItem(hwnd, IDC_PAGES), TRUE);
                
                // Select the first child after the last wizard dialog
                //
                if ( !GET_FLAG(OPK_MAINTMODE) )
                    SelectFirstMaintenanceDlg(hwnd);

                // Set the focus to the maintenance wizard so we can use shortcuts
                //
                SetFocus(hwnd);
            }
            return FALSE;

        case WM_NOTIFY:
            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case TVN_SELCHANGING:
                    {
                        NMHDR       mhdr;
                        
                        // Create the notification message for the wizard page
                        //
                        mhdr.code = PSN_WIZNEXT;

                        // Send the notification message and if we return false, then do not change the page
                        //
                        if (SendMessage(g_hCurrentDialog, WM_NOTIFY, (WPARAM) 0, (LPARAM) &mhdr) == -1)
                            WIZ_RESULT(hwnd, TRUE);
                    }

                    return TRUE;

                case TVN_SELCHANGED:
                    {
                        HTREEITEM   hItem;
                        DWORD       dwIndex;
                        LPTREEDLG   lpWizard = (GET_FLAG(OPK_OEM) ? vdpOEMTreeDialogs : vdpCDTreeDialogs);

                        // Selection's been changed, now modify the buttons
                        //
                        EnableControls(hwnd);

                        // Get the current selection and display the dialog
                        //
                        if (hItem = TreeView_GetSelection(GetDlgItem(hwnd, IDC_PAGES)))
                        {
                            for(dwIndex=0;dwIndex < g_dwTreePages; dwIndex++, lpWizard++)
                            {
                                if ( lpWizard->hItem == hItem )
                                    ShowTreeDialog(hwnd, lpWizard);
                            }   
                        }
                    }
                case PSN_SETACTIVE:
                    if (g_hCurrentDialog)
                        SendMessage(g_hCurrentDialog, WM_NOTIFY, wParam, lParam);
                    break;
            }

        case WM_KEYDOWN:

            if ( wParam == 18225 )
                break;

            switch ( wParam )
            {
                case VK_F1:

                    {
                        DWORD   dwVal   = (DWORD) wParam,
                                dwVal2  = (DWORD) lParam;
                    }
            }
            break;

        case PSM_PRESSBUTTON:

            switch ( (int) wParam )
            {
                case PSBTN_FINISH:
                    break;

                case PSBTN_NEXT:

                    // Selects the Next button.
                    //
                    SendMessage(GetDlgItem(hwnd, ID_MAINT_NEXT), BM_CLICK, 0, 0L);
                    break;

                case PSBTN_BACK:

                    // Selects the Back button.
                    //
                    SendMessage(GetDlgItem(hwnd, ID_MAINT_BACK), BM_CLICK, 0, 0L);
                    break;

                case PSBTN_CANCEL:

                    // Selects the Cancel button.
                    //
                    SendMessage(GetDlgItem(hwnd, IDCANCEL), BM_CLICK, 0, 0L);
                    break;

                case PSBTN_HELP:

                    // Selects the Help button.
                    //
                    SendMessage(GetDlgItem(hwnd, IDC_MAINT_HELP), BM_CLICK, 0, 0L);
                    break;

                case PSBTN_OK:

                    // Selects the OK button.
                    //
                    break;

                case PSBTN_APPLYNOW:
                    
                    // Selects the Apply button.
                    //
                    break;
            }
            break;

        default:
            return FALSE;
    }

    return FALSE;
}


//----------------------------------------------------------------------------
//
// Function: TreeAddItem
//
// Purpose: Adds an item to the tree view returning a handle to that item
//
//----------------------------------------------------------------------------
static HTREEITEM TreeAddItem(HWND hwndTV, HTREEITEM hTreeParent, LPTSTR lpszItem)
{
    TVITEM          tvI;
    TVINSERTSTRUCT  tvIns;

    if ( !lpszItem )
        return NULL;

    ZeroMemory(&tvI, sizeof(TVITEM));
    tvI.pszText         = lpszItem;
    tvI.mask            = TVIF_TEXT;
    tvI.cchTextMax      = lstrlen(tvI.pszText);

    ZeroMemory(&tvIns, sizeof(TVINSERTSTRUCT));
    tvIns.item          = tvI;
    tvIns.hInsertAfter  = TVI_LAST;
    tvIns.hParent       = hTreeParent;

    // Insert the item into the tree.
    //
    return TreeView_InsertItem(hwndTV, &tvIns);
}


//----------------------------------------------------------------------------
//
// Function: OnCommand
//
// Purpose: Processes the Commands of the Main Dialog Proc
//
//----------------------------------------------------------------------------
static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    HTREEITEM hItem;

    switch ( id )
    {
        case ID_MAINT_NEXT:
        case ID_MAINT_BACK:
            {
                BOOL        bReturn = FALSE;
                LPTSTR      lpStringNext    = NULL;
                TCHAR       szStringButton[MAX_PATH];

                // Determine if the user has pressed the Finish button
                //
                if (    (id == ID_MAINT_NEXT) &&
                        (lpStringNext = AllocateString(NULL, IDS_FINISH)) &&
                        (GetDlgItemText(hwnd, ID_MAINT_NEXT, szStringButton, STRSIZE(szStringButton))))
                {
                   if(!lstrcmpi(lpStringNext, szStringButton))
                    {
                        SaveProfile(hwnd);
                        bReturn = TRUE;
                    }
                }

                // Free the allocated string
                //
                FREE(lpStringNext);

                // If the Finish button was not pressed, move to the next page
                //
                if ( !bReturn )
                    SelectTreeItem(hwnd, TreeView_GetSelection(GetDlgItem(hwnd, IDC_PAGES)), (id == ID_MAINT_NEXT ? TVGN_NEXTVISIBLE : TVGN_PREVIOUSVISIBLE) );
                    
                break;
            }

        case IDCANCEL:
            PostMessage(hwnd, WM_CLOSE, 0, 0L);
            break;

        case IDC_MAINT_HELP:
            WIZ_HELP();
            break;

        case ID_FILE_SAVE:
        case ID_FILE_SAVEAS:
            SaveProfile(hwnd);
            break;

        case ID_FILE_CLOSE:

            // We are going to close the config set but keep the maint wizard open
            //
            CloseProfile(hwnd, TRUE);
            break;

        case ID_FILE_NEW:
        case ID_FILE_OPEN:

            // We want to open the config set if:
            //      1) There is now current config set open
            //      2) There is a config set open and then closed
            if  ((!GET_FLAG(OPK_CREATED)) ||  
                (GET_FLAG(OPK_CREATED)  && CloseProfile(hwnd, TRUE)))
            {
                // We are going to open an existing config set
                //
                OpenProfile(hwnd, (id == ID_FILE_NEW ? TRUE : FALSE));
            }
            break;

        case ID_FILE_EXIT:
            SendMessage(hwnd, WM_CLOSE, (WPARAM) 0, (LPARAM) 0);
            break;

        case ID_TOOLS_SHARE:
            DistributionShareDialog(hwnd);
            break;

        case ID_TOOLS_SKUS:
            ManageLangSku(hwnd);
            break;

        case ID_HELP_ABOUT:
            DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_ABOUT), hwnd, (DLGPROC) AboutDlgProc);
            break;

        case ID_HELP_CONTENTS:
            HtmlHelp(hwnd, g_App.szHelpContentFile, HH_DISPLAY_TOC, 0);
            break;
    }
}


//----------------------------------------------------------------------------
//
// Function: ShowTreeDialog
//
// Purpose:  This function Creates a wizard dialog and places it on the maintenance page
//
//----------------------------------------------------------------------------
static void ShowTreeDialog(HWND hwnd, LPTREEDLG lpTreeDlg)
{
    RECT    rc;
    LPTSTR  lpTitle     = NULL,
            lpSubTitle  = NULL;
    NMHDR   mhdr;

    // Hide the current dialog
    //
    if ( g_hCurrentDialog ) {
        ShowWindow(g_hCurrentDialog, SW_HIDE);
        EnableWindow(g_hCurrentDialog, FALSE);
    }

    // Show the dialog if it exists or create/show if it does not
    //
    // ISSUE-2002/02/28-stelo- Check for the validity of LPTREEDLG variable 
    if ( lpTreeDlg->hWindow || (lpTreeDlg->hWindow = CreateDialog(g_App.hInstance, MAKEINTRESOURCE(lpTreeDlg->dwResource), hwnd, lpTreeDlg->dlgWindowProc )))
    {
        // Create the buffers for the title and subtitle
        //
        if ( (lpTitle = AllocateString(NULL, PtrToUint(MAKEINTRESOURCE(lpTreeDlg->dwTitle)))) != NULL &&
             (lpSubTitle = AllocateString(NULL, PtrToUint(MAKEINTRESOURCE(lpTreeDlg->dwSubTitle)))) != NULL ) 
        {
            // Set up the title and subtitle for this dialog
            //
            SetDlgItemText(hwnd, IDC_MAINT_TITLE, lpTitle);
            SetDlgItemText(hwnd, IDC_MAINT_SUBTITLE, lpSubTitle);
        }

        // Free the memory as we don't need it anymore
        //
        FREE(lpTitle);
        FREE(lpSubTitle);

        // Position the wizard dialog on the maintenance page and display it
        //
        GetWindowRect(GetDlgItem(hwnd, IDC_WIZARDFRAME) , &rc);
        MapWindowPoints(NULL, hwnd, (LPPOINT) &rc, 2);
        SetWindowPos(lpTreeDlg->hWindow, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOOWNERZORDER);

        ShowWindow( lpTreeDlg->hWindow, SW_SHOW );
        EnableWindow(lpTreeDlg->hWindow, TRUE);

        // We need to know what the current dialog is
        //
        g_hCurrentDialog = lpTreeDlg->hWindow;

        // Create the notification message for the wizard page
        //
        mhdr.code = PSN_SETACTIVE;

        // Send the notification message and if we return false, then do not change the page
        //
        if ( SendMessage(lpTreeDlg->hWindow, WM_NOTIFY, (WPARAM) 0, (LPARAM) &mhdr) == -1 )
        {
            // TODO: We should handle when we want to fail the set active.
            //
        }
    }
}


//----------------------------------------------------------------------------
//
// Function: FillTreeDialog
//
// Purpose:  Fills the Tree Dialog with the appropriate items
//
//----------------------------------------------------------------------------
static void FillTreeDialog(HWND hwnd)
{
    DWORD       dwPage, 
                dwResult,
                dwLastResource;
    HTREEITEM   hCurrentGroup = NULL;
    LPTSTR      lpHeader;
    HTREEITEM   hItem;
    HWND        hTreeView = GetDlgItem(hwnd, IDC_PAGES);
    LPTREEDLG   lpWizard = (GET_FLAG(OPK_OEM) ? vdpOEMTreeDialogs : vdpCDTreeDialogs);


    // Remove all items first
    //
    TreeView_DeleteAllItems(hTreeView);

    // Update the items that should and should not be visible
    //
    UpdateTreeVisibility(hwnd);
    
    // Loop through all the pages and add them to the tree view
    //
    for ( dwPage = 0; dwPage < g_dwTreePages; dwPage++, lpWizard++ )
    {
        if ( lpWizard->bVisible &&
             (lpHeader = AllocateString(NULL, lpWizard->dwTitle)) != NULL )
        {
            // If a resource exists then it is a dialog, otherwise it's a group header
            //
            if ( lpWizard->dwResource )
                lpWizard->hItem = TreeAddItem(hTreeView, hCurrentGroup,  lpHeader);
            else
                hCurrentGroup = TreeAddItem(hTreeView, NULL,  lpHeader);

            // Expand the current group
            //
            TreeView_Expand(hTreeView, hCurrentGroup, TVE_EXPAND);

            // Free the header, as it's no longer needed
            //
            FREE(lpHeader);
        }
    }
    
    // Select the first child
    //
    TreeView_SelectItem(hTreeView, (hItem = TreeView_GetFirstVisible(hTreeView)));
    TreeView_SelectItem(hTreeView, (hItem = TreeView_GetNextVisible(hTreeView, hItem)));

}

//----------------------------------------------------------------------------
//
// Function: UpdateTreeVisibility
//
// Purpose:  This function is used to update each item's bVisible property.  At
//           runtime certain variables may change that will change whether or not
//           a page is displayed.  This function handles those changes
//
//----------------------------------------------------------------------------
static void UpdateTreeVisibility(HWND hwnd)
{
    DWORD       dwPage;
    LPTREEDLG   lpWizard = (GET_FLAG(OPK_OEM) ? vdpOEMTreeDialogs : vdpCDTreeDialogs);

    for ( dwPage = 0; dwPage < g_dwTreePages; dwPage++, lpWizard++ )
    {
        switch ( lpWizard->dwResource )
        {
            // Dialogs should not be displayed if we are doing a remote install
            //
            case IDD_DOMAINJ:
                if ( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL )
                    lpWizard->bVisible = FALSE;
                else
                    lpWizard->bVisible = TRUE;

                break;

            // Dialogs should be displayed if we are doing a remote install
            //
            case IDD_SIFTEXT:
                if ( WizGlobals.iProductInstall != PRODUCT_REMOTEINSTALL )
                    lpWizard->bVisible = FALSE;
                else
                    lpWizard->bVisible = TRUE;

                break;

            // Dialogs should not be displayed if doing a sysprep install
            //
            case IDD_IE:
            case IDD_TARGETPATH:
                if ( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
                    lpWizard->bVisible = FALSE;
                else
                    lpWizard->bVisible = TRUE;

                break;
            
            // Dialogs should be displayed if doing a sysprep install
            //
            case IDD_OEMDUPSTRING:
                if ( WizGlobals.iProductInstall != PRODUCT_SYSPREP )
                    lpWizard->bVisible = FALSE;
                else
                    lpWizard->bVisible = TRUE;

                break;

            // Dialogs should be displayed if doing an unattended install
            //
            case IDD_COPYFILES1:
            case IDD_DISTFOLDER:
            case IDD_COMPUTERNAME:
            case IDD_SCSI:
            case IDD_HAL:
            case IDD_OPTCOMP:
                if ( WizGlobals.iProductInstall != PRODUCT_UNATTENDED_INSTALL )
                    lpWizard->bVisible = FALSE;
                else
                    lpWizard->bVisible = TRUE;

                break;

            // Dialogs should not be displayed if doing an unattended install
            //
            case IDD_SYSPREPCOMPUTERNAME:
                if ( WizGlobals.iProductInstall == PRODUCT_UNATTENDED_INSTALL )
                    lpWizard->bVisible = FALSE;
                else
                    lpWizard->bVisible = TRUE;

                break;

            // Dialogs that should be displayed for server installs
            //
            case IDD_SRVLICENSE:
                if ( PLATFORM_SERVERS & WizGlobals.iPlatform)
                    lpWizard->bVisible = TRUE;
                else
                    lpWizard->bVisible = FALSE;

                break;

            /* Always show this now that the mouse stuff is back.

            // If we are in DBCS mode, show the following screens
            //
            case IDD_SCREENS:
                if ( GET_FLAG(OPK_DBCS))
                    lpWizard->bVisible = TRUE;
                else
                    lpWizard->bVisible = FALSE;
            */

        }
    }
    
}


//----------------------------------------------------------------------------
//
// Function: GetTreeItem
//
// Purpose:  Given a handle to the TreeView item, this function returns the TREEDLG
//           struct that corresponds with that handle.
//
//----------------------------------------------------------------------------
static LPTREEDLG GetTreeItem(HWND hwnd, HTREEITEM hItem)
{
    DWORD       dwTreePages = 0,
                dwPage      = 0;
    BOOL        bFound      = FALSE;
    LPTREEDLG   lpTreeIndex = NULL;

    // The first two parameters are required, if any of them are NULL, we exit the fuction
    //
    if ( !hwnd || !hItem )
        return NULL;
    
    // Set the dialog to the first dialog in the array
    //
    lpTreeIndex    = (GET_FLAG(OPK_OEM) ? vdpOEMTreeDialogs : vdpCDTreeDialogs);

    // Determine the number of tree pages that we are going to iterate through
    //
    dwTreePages   = ((GET_FLAG(OPK_OEM) ? sizeof(vdpOEMTreeDialogs) : sizeof(vdpCDTreeDialogs)) / sizeof(TREEDLG));

    // Loop through all of the wizard pages, looking for the item
    //
    for(dwPage=0;(dwPage < dwTreePages) && !bFound; dwPage++)
    {
        if ( lpTreeIndex->hItem == hItem )
            bFound = TRUE;
        else
            lpTreeIndex++;
    }

    // If we did not find the item, return FALSE
    //
    if ( !bFound )
    {
        return NULL;
    }

    // We successfully found the item, returning it as lpTreeDialog
    //
    return lpTreeIndex;
}


//----------------------------------------------------------------------------
//
// Function: SelectTreeItem
//
// Purpose:  Selects the next/previous item relative to the supplied tree item
//
//----------------------------------------------------------------------------
static BOOL SelectTreeItem(HWND hwnd, HTREEITEM hItem, UINT uSelection)
{
    BOOL        bItemFound = FALSE;
    HWND        hwndTV     = GetDlgItem(hwnd, IDC_PAGES);
    LPTREEDLG   lpTreeDialog;

    // If we do not have the first two parameters or we can't get the TreeView handle then we exit the function
    //
    if ( !hwndTV || !hwnd || !hItem )
        return FALSE;

    // Verify that we have a valid selection
    //
    switch ( uSelection )
    {
        case TVGN_NEXTVISIBLE:
        case TVGN_PREVIOUSVISIBLE:
            break;
    
        default:
            return FALSE;
    }

    // While we have not found the item, or there are no more items in that direction, continue iterations
    //
    while ( !bItemFound && hItem )
    {
        // If we are able to get the "next" item and grab the dialog struct check to make sure we have a resource
        //
        if ( (hItem = TreeView_GetNextItem(hwndTV, hItem, uSelection)) && 
             (lpTreeDialog = GetTreeItem(hwnd, hItem)) &&
             (lpTreeDialog->dwResource)
           )
        {
            bItemFound = TRUE;
            TreeView_SelectItem(hwndTV, hItem);
        }
    }

    // Return whether or not the item was selected
    //
    return bItemFound;
}


static BOOL SelectFirstMaintenanceDlg(HWND hwnd)
{
    DWORD       dwTotalPages    = 0,
                dwPage          = 0;
    BOOL        bFound          = FALSE;
    LPTREEDLG   lpTreeIndex     = (GET_FLAG(OPK_OEM) ? vdpOEMTreeDialogs : vdpCDTreeDialogs);
    WIZDLG      WizardIndex;

    // Determine the number of wizard pages in the array
    //
    dwTotalPages = ((GET_FLAG(OPK_OEM) ? sizeof(vdpOEMWizardDialogs) : sizeof(vdpCDWizardDialogs)) / sizeof(WIZDLG));

    // Find the last dialog of the wizard
    //
    WizardIndex = (GET_FLAG(OPK_OEM) ? vdpOEMWizardDialogs[dwTotalPages - 1] : vdpCDWizardDialogs[dwTotalPages - 1]);

    // Determine the number of pages in the tree array
    //
    dwTotalPages = ((GET_FLAG(OPK_OEM) ? sizeof(vdpOEMTreeDialogs) : sizeof(vdpCDTreeDialogs)) / sizeof(WIZDLG));

    // Locate this dialog in the tree view
    //
    for(dwPage=0;(dwPage < ( dwTotalPages - 1 )) && !bFound; dwPage++)
    {
        if ( WizardIndex.dwResource == lpTreeIndex->dwResource )
        {
            bFound = TRUE;

            // If there is an Item, select it
            //
            if ( lpTreeIndex->hItem )
                SelectTreeItem(hwnd, lpTreeIndex->hItem, TVGN_NEXTVISIBLE );SelectTreeItem(hwnd, lpTreeIndex->hItem, TVGN_NEXTVISIBLE );
        }
        else
            lpTreeIndex++;
    }
        
    return bFound;
}

//----------------------------------------------------------------------------
//
// Function: CloseProfile
//
// Purpose:  This function closes an open profile but keeps the Maintenance Dialog
//           open.
//
//----------------------------------------------------------------------------
static BOOL CloseProfile(HWND hwnd, BOOL bUserGenerated)
{
    HWND        hwndTV  = GetDlgItem(hwnd, IDC_PAGES);
    DWORD       dwPage,
                dwReturn;
    LPTSTR      lpString;
    LPTREEDLG   lpWizard = (GET_FLAG(OPK_OEM) ? vdpOEMTreeDialogs : vdpCDTreeDialogs);

    // If this was user generated and the do not want to close it, return
    //
    if ( bUserGenerated )
    {
        dwReturn = MsgBox(GetParent(hwnd), IDS_USERCLOSE, IDS_APPNAME, MB_YESNOCANCEL | MB_DEFBUTTON1 );

        if ( dwReturn == IDYES )
        {
            SaveProfile(hwnd);
            return FALSE;
        }
        else if ( dwReturn == IDCANCEL )
            return FALSE;
    }

    // Set the tree handles back to null as they are of no use
    //
    for ( dwPage = 0; dwPage < g_dwTreePages; dwPage++, lpWizard++ )
    {

        // Destroy the window and set the array back to null
        //
        // ISSUE-2002/02/27-stelo,swamip - Need to check the window handle validity.
        DestroyWindow(lpWizard->hWindow);
        lpWizard->hWindow = NULL;
    }

    // Delete all the items from the list
    //
    if ( hwndTV )
        EnableWindow(hwndTV, FALSE);

    // Disable all the buttons, except Cancel
    //
    EnableWindow(GetDlgItem(hwnd, ID_MAINT_BACK), FALSE);
    EnableWindow(GetDlgItem(hwnd, ID_MAINT_NEXT), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_MAINT_HELP), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDCANCEL), TRUE);

    // Disable the menu items
    //
    EnableMenuItem(GetMenu(hwnd), ID_FILE_CLOSE, MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(GetMenu(hwnd), ID_FILE_SAVE, MF_BYCOMMAND | MF_GRAYED);

    // Hide the title, subtitle
    //
    ShowWindow(GetDlgItem(hwnd, IDC_MAINT_TITLE), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDC_MAINT_SUBTITLE), SW_HIDE);

    // Make sure there is no titles in there
    //
    SetDlgItemText(hwnd, IDC_MAINT_TITLE, _T(""));
    SetDlgItemText(hwnd, IDC_MAINT_SUBTITLE, _T(""));

    // Reset necessary global flags
    //                
    SET_FLAG(OPK_CREATED, FALSE);

    // Reset necessary global variables
    //
    if ( g_App.szTempDir[0] )
        DeletePath(g_App.szTempDir);
    g_App.szTempDir[0] = NULLCHR;
    g_App.szConfigName[0] = NULLCHR;
    g_hCurrentDialog = NULL;

    // Switch the button back to next
    //
    if ( lpString = AllocateString(NULL, IDS_NEXT))
    {
        SetDlgItemText(hwnd, ID_MAINT_NEXT, lpString);
        FREE(lpString);
    }

    // Reset the necessary global variables for the answer file
    //
    FixedGlobals.iLoadType = LOAD_UNDEFINED;
    FixedGlobals.ScriptName[0] = NULLCHR;
    FixedGlobals.UdfFileName[0] = NULLCHR;
    FixedGlobals.BatchFileName[0] = NULLCHR;

    SetFocus(GetDlgItem(hwnd,IDCANCEL));

    return TRUE;
}


//----------------------------------------------------------------------------
//
// Function: OpenProfile
//
// Purpose:  Brings the user to the open a new configuration/profile page, setting
//           the proper default based on whether the user selected a new/open existing
//           configuration.
//
//----------------------------------------------------------------------------
static void OpenProfile(HWND hwnd, BOOL bNewConfig)
{
    HWND    hwndTV  = GetDlgItem(hwnd, IDC_PAGES);

    // Enabled the menu items
    //
    EnableMenuItem(GetMenu(hwnd), ID_FILE_CLOSE, MF_BYCOMMAND | MF_ENABLED);
    EnableMenuItem(GetMenu(hwnd), ID_FILE_SAVE, MF_BYCOMMAND | MF_ENABLED);

    EnableWindow(GetDlgItem(hwnd, ID_MAINT_BACK), TRUE);
    EnableWindow(GetDlgItem(hwnd, ID_MAINT_NEXT), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDC_MAINT_HELP), TRUE);
    EnableWindow(GetDlgItem(hwnd, IDCANCEL), TRUE);

    // Enable the title and subtitle
    //
    ShowWindow(GetDlgItem(hwnd, IDC_MAINT_TITLE), SW_SHOW);
    ShowWindow(GetDlgItem(hwnd, IDC_MAINT_SUBTITLE), SW_SHOW);

    // Are we going to open a new config set
    //
    if ( !bNewConfig )
        SET_FLAG(OPK_OPENCONFIG, TRUE);

    // Hide the splash screen
    //
    ShowSplashDialog(hwnd, 0);

    SendMessage(hwnd, WM_INITDIALOG, (WPARAM) 0, (LPARAM) 0);
}


//----------------------------------------------------------------------------
//
// Function: SaveProfile
//
// Purpose:  Saves the currently open profile
//
//----------------------------------------------------------------------------
static void SaveProfile(HWND hwnd)
{
    DWORD       dwResult = 0;
    NMHDR       mhdr;
                        
    // Create the notification message for the wizard page
    //
    mhdr.code = TVN_SELCHANGING;

    // Send the notification message and if we return false, then do not change the page
    //
    if ( !SendMessage(hwnd, WM_NOTIFY, (WPARAM) 0, (LPARAM) &mhdr) )
    {

        // The user is in the oem/system builder mode
        //
        if (  GET_FLAG(OPK_OEM) )
        {
            if ( DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_SAVEAS), hwnd, SaveAsDlgProc) )
            {
                //
                // Now some last minute cleanup before we are totally finished.
                //
                g_App.szTempDir[0] = NULLCHR;
                
                // Show the complete splash screen
                //
                ShowSplashDialog(hwnd, IDD_COMPLETE);

                // Close the config set
                //
                CloseProfile(hwnd, FALSE);

                // Close if the auto run flag is set.
                //
                if ( GET_FLAG(OPK_AUTORUN) )
                    PostMessage(hwnd, WM_CLOSE, 0, 0L);
            }

        }
        else
        {
            if ( DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_SAVESCRIPT), hwnd, DlgSaveScriptPage) )
            {
                if  (    WizGlobals.bCreateNewDistFolder &&
                        !WizGlobals.bStandAloneScript &&
                        (WizGlobals.iProductInstall == PRODUCT_UNATTENDED_INSTALL) )
                {
                    COPYDIRDATA cdd;
                    DWORD       dwFileCount;
                    LPTSTR      lpBuffer;
                    TCHAR       szBuffer[MAX_PATH]  = NULLSTR;


                    // Clean up the memory before we use it
                    //
                    ZeroMemory(&cdd, sizeof(COPYDIRDATA));

                    // Fill in the COPYDIRDATA Structure
                    //
                    lstrcpyn(szBuffer, WizGlobals.bCopyFromPath ? WizGlobals.CopySourcePath : WizGlobals.CdSourcePath,AS(szBuffer));
                    AddPathN(szBuffer, _T(".."),AS(szBuffer));
                    GetFullPathName(szBuffer, AS(szBuffer), cdd.szSrc, &lpBuffer);
                    
                    lstrcpyn(cdd.szDst, WizGlobals.DistFolder,AS(cdd.szDst));

                    lstrcpyn(cdd.szInfFile, cdd.szSrc,AS(cdd.szInfFile));
                    AddPathN(cdd.szInfFile, WizGlobals.Architecture,AS(cdd.szInfFile));
                    AddPathN(cdd.szInfFile, FILE_DOSNET_INF,AS(cdd.szInfFile));
                    
                    dwFileCount = CopySkuFiles(NULL, NULL, cdd.szSrc, cdd.szDst, cdd.szInfFile);
                    cdd.dwFileCount = dwFileCount;

                    cdd.lpszEndSku = cdd.szDst + lstrlen(cdd.szDst);
                    
                    // Call the dialog box that copies the sources over
                    //
                    DialogBoxParam(g_App.hInstance, MAKEINTRESOURCE(IDD_PROGRESS), hwnd, ProgressDlgProc, (LPARAM) &cdd);
                }

                // Show the complete splash screen
                //
                ShowSplashDialog(hwnd, IDD_FINISH);

                CloseProfile(hwnd, FALSE);

                
            }
        }
    }
}


//----------------------------------------------------------------------------
//
// Function: EnableControls
//
// Purpose:  Enables the proper back/next buttons based on the selection in the
//           tree view
//
//----------------------------------------------------------------------------
static void EnableControls(HWND hwnd)
{
    HTREEITEM   hItem;
    HWND        hwndTV  = GetDlgItem(hwnd, IDC_PAGES);

    if (hwndTV &&
            (hItem = TreeView_GetSelection(hwndTV)))
    {
        // Enable the back button if we are not the first dialog
        //
        EnableWindow(GetDlgItem(hwnd, ID_MAINT_BACK), ( hItem == TreeView_GetFirstVisible(hwndTV) ? FALSE : TRUE) );

    }
    return;
}

void SetWizardButtons(HWND hwnd, DWORD dwButtons)
{
    LPTSTR lpString = NULL;

    // Set the buttons for the starting wizard
    //
    SendMessage(GetParent(hwnd), PSM_SETWIZBUTTONS, 0, (LPARAM) dwButtons);

    // Determine if we need to set the next button to the finish button
    //
    lpString = AllocateString(NULL, (dwButtons & PSWIZB_FINISH) ? IDS_FINISH : IDS_NEXT);

    // ISSUE-2002/02/27-stelo,swamip - Make sure Buffer has been allocated.
    SetDlgItemText(GetParent(hwnd), ID_MAINT_NEXT, lpString);

    // Clean up the allocated memory
    //
    FREE(lpString);
       

    // Set the maintenance mode buttons
    //
    EnableWindow(GetDlgItem(GetParent(hwnd), ID_MAINT_BACK), (dwButtons & PSWIZB_BACK));
    EnableWindow(GetDlgItem(GetParent(hwnd), ID_MAINT_NEXT), (dwButtons & PSWIZB_NEXT) || (dwButtons & PSWIZB_FINISH));
}

static void ShowSplashDialog(HWND hwnd, DWORD dwResource)
{
    DWORD dwIndex   = 0,
          dwDisplay = -1;
    BOOL  bFound    = FALSE;
    RECT  rc;

    // Loop through each dialog and hide any existing ones
    //
    for ( dwIndex = 0; dwIndex < AS(vdpSplashDialogs); dwIndex++)
    {
        // Hide existing windows
        //
        if ( vdpSplashDialogs[dwIndex].hWindow )
            EndDialog(vdpSplashDialogs[dwIndex].hWindow, 0);

        // Determine the one that we are going to display
        //
        if ( vdpSplashDialogs[dwIndex].dwResource == dwResource )
        {
            bFound = TRUE;
            dwDisplay = dwIndex;
        }
    }

    // We have been given a resource and we found it in the loop, display it
    //
    if ( dwResource && bFound)
    {
        if ( vdpSplashDialogs[dwDisplay].hWindow = CreateDialog(g_App.hInstance, MAKEINTRESOURCE(dwResource), hwnd, vdpSplashDialogs[dwDisplay].dlgWindowProc ))
        {
            ShowWindow(GetDlgItem(hwnd, IDC_MAINT_BAR), SW_HIDE);

            // Position the splash dialog on the splash frame
            //
            GetWindowRect(GetDlgItem(hwnd, IDC_SPLASHFRAME) , &rc);
            MapWindowPoints(NULL, hwnd, (LPPOINT) &rc, 2);
            SetWindowPos(vdpSplashDialogs[dwDisplay].hWindow, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOOWNERZORDER);
            ShowWindow( vdpSplashDialogs[dwDisplay].hWindow, SW_SHOW );
        }

    }
    else
        ShowWindow(GetDlgItem(hwnd, IDC_MAINT_BAR), SW_SHOW);
        
}

BOOL CALLBACK AboutDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            CHAR    szCompany[]     = VER_COMPANYNAME_STR,
                    szVersion[]     = VER_FILEVERSION_STR,
                    szCopyright[]   = VER_LEGALCOPYRIGHT_STR,
                    szDescription[] = VER_FILEDESCRIPTION_STR;

            SetDlgItemTextA(hwnd, IDC_ABOUT_COMPANY, szCompany);
            SetDlgItemTextA(hwnd, IDC_ABOUT_VERSION, szVersion);
            SetDlgItemTextA(hwnd, IDC_ABOUT_COPYRIGHT, szCopyright);
            SetDlgItemTextA(hwnd, IDC_ABOUT_DESCRIPTION, szDescription);

            return FALSE;
        }

        case WM_COMMAND:

            if ( LOWORD(wParam) == IDOK )
                EndDialog(hwnd, LOWORD(wParam));
            return FALSE;

        default:
            return FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\main.h ===
/****************************************************************************\

    MAIN.H / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Main header file for the OPK Wizard.

    3/99 - Jason Cohen (JCOHEN)
        Added this new main header file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


#ifndef _MAIN_H_
#define _MAIN_H_


//
// Include File(s):
//
#include "debugapi.h"
#include "miscapi.h"
#include "comres.h"
#include <winbom.h>
#include <strsafe.h>

//
// Defined Value(s):
//

// Do not display the license for the system builders
//
#define NO_LICENSE  // Comment this value if you want the license to appear during the wizard      
//#define BRANDTITLE  // Comment this value if you do not want the Browswer Title wizard page to be displayed
//#define HELPCENTER    // Comment this value if you do not want the help center wizard page to be displayed
//#define USEHELP       // Comment the value if you do not want to use help throughout the wizard

// App defined flags.
//
#define OPK_OEM                 0x00000008  // Set if the OEM tag file exists on startup.
#define OPK_DBCS                0x00000010  // Set if DBCS is defined when built.
#define OPK_MAINTMODE           0x00000020  // Set if the user chooses an existing config to open.
#define OPK_EXIT                0x00000040
#define OPK_CMDMM               0x00000080  // Set if the user chooses an existing config via the command line.
#define OPK_CREATED             0x00000100  // Set once the temp directory is created.
#define OPK_BATCHMODE           0x00000200  // Set if the user chooses to run the wizard in batch mode.
#define OPK_INSMODE             0x00000400  // Set if user wants to provide IE install file with batch mode
#define OPK_AUTORUN             0x00000800  // Set if user is running autorun mode
#define OPK_WELCOME             0x00002000  // Set if the user has already seen the welcome dialog
#define OPK_OPENCONFIG          0x00004000  // Set if the user has selected to open a config set
#define OPK_ACTIVEWIZ           0x00008000  // Set if the wizard is currently running

// OS version defines used when checking dwOsVer in the golbal data structure.
//
#define OS_NT4                  0x00040000
#define OS_NT4_SP1              0x00040001
#define OS_NT4_SP2              0x00040002
#define OS_NT4_SP3              0x00040003
#define OS_NT4_SP4              0x00040004
#define OS_NT4_SP5              0x00040005
#define OS_W2K                  0x00050000
#define OS_W2K_SP1              0x00050001
#define OS_W2K_SP2              0x00050002
#define OS_XP                   0x00050100

// Custom messages.
//
#define WM_SUBWNDPROC           WM_APP + 1
#define WM_SETSEL               WM_APP + 2
#define WM_FINISHED             WM_APP + 3
#define WM_APP_STARTCOPY        WM_APP + 4

// Used by IDD_SKU's dialog proc (SkuDlgProc) to tell when the progress
// is finished.  WPARAM contains the error code (1 for success or 0 for failure).
// LPARAM is always 0.
//
#define WM_COPYFINISHED         WM_APP + 5

#define KEY_ESC                 27

// Bufer sizes.
//
#define MAX_URL                 2048
#define MAX_ICON                MAX_PATH
#define MAX_STRING              512
#define MAX_SECTION             32767
#define INF_BUF_SIZE            16768
#define MAX_INFOLEN             82
#define MAX_KEY                 48
#define MAX_BTOOLBAR_TEXT       10

// Macros for getting/setting the flags.
//
#ifdef GET_FLAG
#undef GET_FLAG
#endif // GET_FLAG
#define GET_FLAG(b)             ( g_App.dwFlags & b )

#ifdef SET_FLAG
#undef SET_FLAG
#endif // SET_FLAG
#define SET_FLAG(b, f)          ( (f) ? (g_App.dwFlags |= b) : (g_App.dwFlags &= ~b) )

// Help ids.
//
#define IDH_DEFAULT             101
#define IDH_DETHELP             102   
#define IDH_DISKDUP             103
#define IDH_SCREENS             104
#define IDH_MEDIA               105
#define IDH_WELCOME             106
#define IDH_LOGO                107
#define IDH_FINISH              108        
#define IDH_OEMINFO             109       
#define IDH_APPINSTALL          110    
#define IDH_DEVCLASS            111      
#define IDH_CDNETW              112        
#define IDH_DISABLENET          113    
#define IDH_MODESEL             114       
#define IDH_REALMODE_INFO       115
#define IDH_REALMODE            116
#define IDH_LICENSE             117
#define IDH_FIRSTRUN            118
#define IDH_FAVORITES           119
#define IDH_IECUST              120
#define IDH_ISP                 121
#define IDH_USERREG             122
#define IDH_OEMCUST             123
#define IDH_SANDBOX             124
#define IDH_ACTIVEDESK          125
#define IDH_OEMCHAN             126
#define IDH_OOBEUSB             127
#define IDH_CONFIG              128
#define IDH_SCREENSTWO          129
#define IDH_BTITLE              130
#define IDH_BTOOLBAR            131
#define IDH_CHANNELS            132
#define IDH_COMPLETED           133
#define IDH_HELPCENT            134
#define IDH_STARTMENU_MFU       135
#define IDH_OEMFOLDER           136
#define IDH_TARGETLANG          137
#define IDH_TARGET              150

#define IDH_ANSW_FILE 	        400   //New or Existing Answer File 
#define IDH_PROD_INST 	        401   //Product to Install
#define IDH_CHZ_PLAT 	        402   //Platform
#define IDH_USER_INTER 	        403   //User Interaction Level
#define IDH_DIST_FLDR 	        404   //Distribution Folder
#define IDH_LOC_SETUP 	        405   //Location of Setup Files
#define IDH_CUST_SOFT 	        406   //Customize the Software, General Settings
#define IDH_DSIP_SETG 	        407   //Display Settings, General Settings
#define IDH_TIME_ZONE 	        408   //Time Zone, General Settings
#define IDH_LICE_MODE 	        409   //Licensing Mode, Network Settings
#define IDH_COMP_NAME 	        410   //Computer Name, Network Settings
#define IDH_COMP_NAMZ 	        411   //Computer Names, Network Settings
#define IDH_ADMN_PASS 	        412   //Administrator Password, Network Settings
#define IDH_NET_COMPS 	        413   //Networking Components, Network Settings
#define IDH_WKGP_DOMN 	        414   //Workgroup or Domain, Network Settings
#define IDH_TELE_PHNY 	        415   //Telephony, Advanced Settings
#define IDH_REGN_STGS 	        416   //Regional Settings, Advanced Settings
#define IDH_LANGS 	        417   //Languages, Advanced Settings
#define IDH_BROW_SHELL 	        418   //Browser and Shell Settings, Advanced Settings
#define IDH_INST_FLDR 	        419   //Installation Folder, Advanced Settings
#define IDH_INST_PRTR 	        420   //Install Printers, Advanced Settings
#define IDH_RUN_ONCE 	        421   //Run Once, Advanced Settings
#define IDH_ADDL_CMND 	        422   //Additional Commands, Advanced Settings
#define IDH_OEM_DUPE 	        423   //OEM Duplicator String, Advanced Settings
#define IDH_SIF_RIS 	        424   //Setup Information File Text, Advanced Settings
#define IDH_PROD_KEY            425   // Product Key
#define IDH_LIC_AGR 	        426   //License Agreement


//
// INI strings
//

// INI Sections
//
#define INI_SEC_CONFIGSET       _T("ConfigSet")
#define INI_SEC_OPTIONS         _T("Options")
#define INI_SEC_ADVANCED        _T("Advanced")
#define INI_SEC_TOOLBAR         _T("BrowserToolbars")
#define INI_SEC_STARTUP         _T("StartupOptions")
#define INI_SEC_SIGNUP          _T("Signup")
#define INI_SEC_ISPFOLDER       _T("ISPFolder")
#define INI_SEC_OEMCUST         _T("OemCust")
#define INI_SEC_GENERAL         _T("General")
#define INI_SEC_URL             _T("URL")
#define INI_SEC_CONFIG          _T("ConfigName")
#define INI_SEC_BRANDING        _T("Branding")
#define INI_SEC_VERSION         _T("Version")
#define INI_SEC_WINPE           _T("WinPE")
#define INI_SEC_MFULIST         _T("StartMenuMFUlist")
#define INI_SEC_OEMLINK         _T("OemLink")
#define INF_SEC_COPYFILES       _T("CopyFiles")

// INI Keys
//
#define INI_KEY_MANUFACT        _T("Manufacturer")
#define INI_KEY_FINISHED        _T("Finished")
#define INI_KEY_MOUSE           _T("MouseTutorial")
#define INI_KEY_HARDWARE        _T("OEMHWTutorial")
#define INI_KEY_ISPRET          _T("IspRetail")
#define INI_KEY_PRECONFIG       _T("IspPreconfigDir")
#define INI_KEY_STARTURL        _T("DesktopStartUrl")
#define INI_KEY_ISPSIGNUP       _T("ISPSignup")
#define INI_KEY_ISPPATH         _T("ISPPath")
#define INI_KEY_LOGO1           _T("Logo1")
#define INI_KEY_LOGO2           _T("Logo2")
#define INI_KEY_OEMCUST         _T("OEMCust")
#define INI_KEY_FILELINE        _T("Line%d")
#define INI_KEY_USBERRORFILES   _T("USBErrorFiles")
#define INI_KEY_IMETUT          _T("IMETutorial")
#define INI_KEY_IMECUSTDIR      _T("IMECustDir")
#define INI_KEY_CUSTMOUSE       _T("CustomMouse")
#define INI_KEY_HELP_CENTER     _T("HelpCenterDir")
#define INI_KEY_SUPPORT_CENTER  _T("HelpSupportDir")
#define INI_KEY_HELP_BRANDING   _T("HelpBrandingDir")
#define INI_KEY_WINPE_LANG      _T("Lang")
#define INI_KEY_WINPE_CFGSET    _T("ConfigSet")
#define INI_KEY_WINPE_SRCROOT   _T("SourceRoot")
#define INI_KEY_WINPE_USERNAME  _T("Username")
#define INI_KEY_WINPE_PASSWORD  _T("Password")
#define INI_KEY_MFULINK         _T("Link%d")
#define INI_KEY_WELCOME         _T("Welcome")
#define INI_KEY_APPCREDENTIALS  _T("FactoryCredentials")
#define INI_KEY_OEMLINK_LINKTEXT          _T("OemBrandLinkText")
#define INI_KEY_OEMLINK_INFOTIP           _T("OemBrandLinkInfotip")
#define INI_KEY_OEMLINK_ICON_ORIGINAL     _T("OriginalOemLinkIcon")
#define INI_KEY_OEMLINK_PATH_ORIGINAL     _T("OriginalLink")
#define INI_KEY_OEMLINK_ICON_LOCAL        _T("OemBrandIcon")
#define INI_KEY_OEMLINK_PATH_LOCAL        _T("OemBrandLink")
#define INI_KEY_DESKFLDR_ENABLE           _T("DesktopShortcutsCleanupEnabled")

// INI Values
//
#define INI_VAL_OFFLINE         _T("Offline")
#define INI_VAL_PRECONFIG       _T("Preconfig")
#define INI_VAL_DISABLE         _T("disable")
#define INI_VAL_DUMMY           _T("OPKWIZDUMMYLINE")
#define INI_VAL_WINPE_COMPNAME  _T("<SERVER_NAME>")
#define INI_VAL_WINPE_SHARENAME _T("<SHARE_NAME>")

// INI Other
//
#define GRAY                    _T("_Gray")

// Config files.
//
#define FILE_SETUPMGR_INI       _T("setupmgr.ini")
#define FILE_OPKWIZ_HLP         _T("setupmgr.chm")
#define FILE_OPKINPUT_INF       _T("opkinput.inf")
#define FILE_INSTALL_INS        _T("install.ins")
#define FILE_OPKWIZ_INI         _T("cfgbatch.txt")
#define FILE_OOBEINFO_INI       _T("oobeinfo.ini")
#define FILE_OEMAUDIT_INF       _T("oemaudit.inf")
#define FILE_OEMINFO_INI        _T("oeminfo.ini")
#define FILE_UNATTEND_TXT       _T("unattend.txt")
#define FILE_OEM_TAG            _T("oem.tag")

#define DIR_WIZARDFILES         _T("wizfiles")
#define DIR_OEM                 _T("$OEM$")
#define DIR_OEM_WINDOWS         DIR_OEM _T("\\$$")
#define DIR_OEM_SYSTEM32        DIR_OEM_WINDOWS _T("\\system32")
#define DIR_OEM_OOBE            DIR_OEM_SYSTEM32 _T("\\oobe")
#define DIR_IESIGNUP            DIR_OEM _T("\\$PROGS\\Internet Explorer\\Custom")

// Other strings.
//
#define STR_0                   _T("0")
#define STR_1                   _T("1")
#define STR_2                   _T("2")
#define STR_ZERO                STR_0
#define STR_ONE                 STR_1
#define STR_CRLF                _T("\r\n")
#define STR_SPACE               _T(" ")
#define CHR_BACKSLASH           _T('\\')
#define CHR_SPACE               _T(' ')
#define CHR_EQUAL               _T('=')
#define CHR_LINEFEED            _T('\n')
#define CHR_QUOTE               _T('\"')
#define CHR_STAR                _T('*')
#define STR_EQUAL               _T("=")
#define STR_CAB                 _T(".cab")
#define STR_OPEN                _T("open")


//
// Type Definition(s):
//

// Global app data.
//
typedef struct _GAPP
{
    HINSTANCE   hInstance;
    DWORD       dwFlags;
    TCHAR       szOpkDir[MAX_PATH];             // Full path to the root of the OPK directory where all the tools are installed.
    TCHAR       szWizardDir[MAX_PATH];          // Full path to the directory where the default configuration files are located.
    TCHAR       szConfigSetsDir[MAX_PATH];      // Full path to the directory where all the configuration sets are located.
    TCHAR       szLangDir[MAX_PATH];            // Full path to the root of language folder where all the specific lang directories are.
    TCHAR       szTempDir[MAX_PATH];            // Full path to the current location for all the configuration files.
    TCHAR       szLangName[MAX_PATH];           // Name of the language directory we are deploying (not a full path).
    TCHAR       szSkuName[MAX_PATH];            // Name of the sku directory we are deploying (not a full path).
    TCHAR       szConfigName[MAX_PATH];         // Name of the directory to use for the configuration set (not a full path).
    TCHAR       szBrowseFolder[MAX_PATH];       // Full path to the last folder browsed to.
    TCHAR       szOpkInputInfFile[MAX_PATH];
    TCHAR       szSetupMgrIniFile[MAX_PATH];    // Full path to the file were we store global SetupMgr settings (we don't use the registry).
    TCHAR       szHelpFile[MAX_PATH];
    TCHAR       szHelpContentFile[MAX_PATH];
    TCHAR       szInstallInsFile[MAX_PATH];
    TCHAR       szOpkWizIniFile[MAX_PATH];
    TCHAR       szOobeInfoIniFile[MAX_PATH];
    TCHAR       szOemInfoIniFile[MAX_PATH];
    TCHAR       szWinBomIniFile[MAX_PATH];
    TCHAR       szUnattendTxtFile[MAX_PATH];
    DWORD       dwCurrentHelp;
    HWND        hwndHelp;
    DWORD       dwOsVer;
    TCHAR       szManufacturer[MAX_PATH];
    TCHAR       szLastKnownBrowseFolder[MAX_PATH];

} GAPP, *PGAPP, *LPGAPP;

#undef LSTRCMPI
#define LSTRCMPI(x, y)        ( ( CompareString( MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, x, -1, y, -1 ) - CSTR_EQUAL ) )



//
// External Global Variable(s):
//

// Don't want to declare these again.
//
#ifndef _MAIN_C_
#define _MAIN_C_

extern GAPP g_App;

#endif // _MAIN_C_


//
// External Function Prototype(s);
//

// From MAIN.C
//
void SetConfigPath(LPCTSTR);

// From LANG.C
//
void SetupLangListBox(HWND hwndLB);
LPTSTR AllocateLangStr(HINSTANCE hInst, LPTSTR lpLangDir, LPTSTR * lplpLangDir);

// From LANGSKU.C
//
void ManageLangSku(HWND hwndParent);

// From SHARE.C
//
BOOL DistributionShareDialog(HWND hwndParent);
BOOL GetShareSettings(LPTSTR lpszPath, DWORD cbszPath, LPTSTR lpszUsername, DWORD cbszUserName, LPTSTR lpszPassword, DWORD cbszPassword);

// From SKU.C
//
void SetupSkuListBox(HWND hwndLB, LPTSTR lpLangDir);
void AddSku(HWND hwnd, HWND hwndLB, LPTSTR lpLangName);
void DelSku(HWND hwnd, HWND hwndLB, LPTSTR lpLangName);

// From WINPE.C
//
BOOL MakeWinpeFloppy(HWND hwndParent, LPTSTR lpConfigName, LPTSTR lpWinBom);

// Checks for batch mode
//
BOOL OpkWritePrivateProfileSection(LPCTSTR, LPCTSTR, LPCTSTR); 
BOOL OpkGetPrivateProfileSection(LPCTSTR, LPTSTR, INT, LPCTSTR);
BOOL OpkWritePrivateProfileString(LPCTSTR, LPCTSTR, LPCTSTR, LPCTSTR); 
BOOL OpkGetPrivateProfileString(LPCTSTR, LPCTSTR, LPCTSTR, LPTSTR, INT, LPCTSTR);   

#endif // _MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\debugapi.h ===
/*****************************************************************************\

    DEBUGAPI.H

    Confidential
    Copyright (c) Corporation 1998
    All rights reserved

    Debug API function prototypes and defined values.

    12/98 - Jason Cohen (JCOHEN)

  
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\*****************************************************************************/


// Only include this file once.
//
#ifndef _DEBUGAPI_H_
#define _DEBUGAPI_H_


#ifdef DBG


// Make sure both DEBUG and _DEBUG are defined.
//
#ifndef DBG
#define DBG
#endif // DEBUG

//
// Include File(s):
//

#include <windows.h>
#include <tchar.h>


//
// Defined Value(s):
//

#if defined(UNICODE) || defined(_UNICODE)
#define DebugOut    DebugOutW
#else // UNICODE || _UNICODE
#define DebugOut    DebugOutA
#endif // UNICODE || _UNICODE

#define ELSEDBG         else
#define ELSEDBGOUT      else DBGOUT
#define ELSEDBGMSGBOX   else MsgBoxStr
#define DBGMSGBOX       MsgBoxStr
#define DBGOUT          DebugOut
#define DBGOUTW         DebugOutW
#define DBGOUTA         DebugOutA
#define DBGLOG          _T("C:\\DEBUG.LOG")
#define DBGLOGW         L"C:\\DEBUG.LOG"
#define DBGLOGA         "C:\\DEBUG.LOG"


//
// External Function(s):
//

INT DebugOutW(LPCWSTR, LPCWSTR, ...);
INT DebugOutA(LPCSTR, LPCSTR, ...);


#else // DEBUG || _DEBUG


//
// Defined Value(s):
//

#define ELSEDBG
#define ELSEDBGOUT
#define ELSEDBGMSGBOX
#define DBGMSGBOX       { }
#define DBGOUT          { }
#define DBGOUTW         { }
#define DBGOUTA         { }
#define DBGLOG          NULL
#define DBGLOGW         NULL
#define DBGLOGA         NULL


#endif // DEBUG || _DEBUG


#endif // _DEBUGAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\oc.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// Module Name:
//
//    oc.h
//
// Abstract:
//
//    Common types, constants, and prototypes for the optional component pages
//
//----------------------------------------------------------------------------

#ifndef _OC_H_
#define _OC_H_

#include "setupmgr.h"



#define MAX_PHONE_LENGTH    127
#define MAX_KEYBOARD_LAYOUT 16 

#define MAX_LANGUAGE_LEN         64

// needs to be global for communication between the two regional settings pages
static TCHAR *StrSelectIndividualSettings;

TCHAR g_szDefaultLocale[MAX_LANGUAGE_LEN]; 

typedef struct languagegoup_node {
    struct languagegoup_node *next;
    TCHAR szLanguageGroupName[MAX_LANGUAGE_LEN];
    TCHAR szLanguageGroupId[MAX_LANGUAGE_LEN];
    TCHAR szLangFilePath[MAX_STRING_LEN];
} LANGUAGEGROUP_NODE;

typedef LANGUAGEGROUP_NODE LANGUAGEGROUP_LIST;

typedef struct languagelocale_node {
    struct languagelocale_node *next;
    LANGUAGEGROUP_LIST *pLanguageGroup;
    TCHAR szLanguageLocaleName[MAX_LANGUAGE_LEN];
    TCHAR szLanguageLocaleId[MAX_LANGUAGE_LEN];
    TCHAR szKeyboardLayout[MAX_LANGUAGE_LEN];
} LANGUAGELOCALE_NODE;

typedef LANGUAGELOCALE_NODE LANGUAGELOCALE_LIST;

typedef enum {

    TONE,
    PULSE,
    DONTSPECIFYSETTING

} DIAL_TYPE;

INT ShowBrowseFolder( IN     HWND   hwnd,
                      IN     TCHAR *szFileFilter,
                      IN     TCHAR *szFileExtension,
                      IN     DWORD  dwFlags,
                      IN     TCHAR *szStartingPath,
                      IN OUT TCHAR *szFileNameAndPath );

VOID CopyFileToDistShare( IN HWND hwnd, 
                          IN LPTSTR szSrcPath,
                          IN LPTSTR szSrcName,
                          IN LPTSTR szDestPath );



#endif  // _OC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\netshrd.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//    netshrd.h
//
// Description:
//    Common types, constants, and prototypes for the network pages
//
//----------------------------------------------------------------------------

#ifndef _NETSHRD_H_
#define _NETSHRD_H_

//
//  Constants
//
#define BITMAP_WIDTH                  16
#define BITMAP_HEIGHT                 16
#define MAX_ITEMLEN                   64
#define MAX_STRING_LEN                256
#define MAX_DESCRIPTION_LEN           1024
#define MAX_INTERNAL_NET_NUMBER_LEN   8
#define MAX_FRAMETYPE_LEN             4
#define MAX_NET_NUMBER_LEN            8
#define MAX_DNS_DOMAIN_LENGTH         255
#define MAX_PREFERRED_SERVER_LEN      255  // ISSUE-2002/02/28-stelo- verify this is the max length
#define MAX_DEFAULT_TREE_LEN          255  // ISSUE-2002/02/28-stelo- verify this is the max length
#define MAX_DEFAULT_CONTEXT_LEN       255  // ISSUE-2002/02/28-stelo verify this is the max length
#define MAX_NETRANGE_LEN              64

// IPSTRINGLENGTH = 12 spaces for all the digits plus 3 spaces for the periods
#define IPSTRINGLENGTH          15
#define SELECTED                 3
#define NOT_FOUND               -1

#define PERSONAL_INSTALL     0x00000001
#define WORKSTATION_INSTALL  0x00000002
#define SERVER_INSTALL       0x00000003

typedef enum MS_CLIENT_TAG {

    MS_CLIENT_WINDOWS_LOCATOR,
    MS_CLIENT_DCE_CELL_DIR_SERVICE

} MS_CLIENT;

//
//  Setup constants to identify components in the Net Components list
//
typedef enum NET_COMPONENT_POSITION_TAG {

    MS_CLIENT_POSITION,
    NETWARE_CLIENT_POSITION,
    FILE_AND_PRINT_SHARING_POSITION,
    PACKET_SCHEDULING_POSITION,
    APPLETALK_POSITION,
    TCPIP_POSITION,
    NETWORK_MONITOR_AGENT_POSITION,
    IPX_POSITION,
    DLC_POSITION,
    NETBEUI_POSITION,
    SAP_AGENT_POSITION,
    GATEWAY_FOR_NETWARE_POSITION

} NET_COMPONENT_POSITION;

typedef enum COMPONENT_TAG {CLIENT, SERVICE, PROTOCOL} COMPONENT_TYPE;

typedef struct network_component {
    struct network_component *next;
    TCHAR *StrComponentName;
    TCHAR *StrComponentDescription;
    NET_COMPONENT_POSITION iPosition;
    COMPONENT_TYPE ComponentType;
    BOOL bHasPropertiesTab;
    BOOL bInstalled;
    BOOL bSysprepSupport;
    DWORD dwPlatforms;
} NETWORK_COMPONENT;

//
//  Doubly Linked List
//
//  Contains variables that are network card specific
//
typedef struct network_adapter_node {

    struct network_adapter_node *next;
    struct network_adapter_node *previous;

    //
    //  used only when reading from the registry
    //  used to match registry settings with the appropriate netword adapter
    //
    GUID guid;

    //
    //  szPlugAndPlayID only valid if more than 1 network adapter is installed
    //
    TCHAR szPlugAndPlayID[MAX_STRING_LEN];

    //
    //  TCPIP variables
    //

    BOOL  bObtainIPAddressAutomatically;

    TCHAR szDNSDomainName[MAX_DNS_DOMAIN_LENGTH + 1];

    INT iNetBiosOption;

    NAMELIST Tcpip_IpAddresses;
    NAMELIST Tcpip_SubnetMaskAddresses;
    NAMELIST Tcpip_GatewayAddresses;
    NAMELIST Tcpip_DnsAddresses;
    NAMELIST Tcpip_WinsAddresses;

    //
    //  IPX variables
    //

    TCHAR szFrameType[MAX_FRAMETYPE_LEN + 1];
    TCHAR szNetworkNumber[MAX_NET_NUMBER_LEN + 1];


    //
    //  Appletalk variables
    //

    BOOL     bEnableSeedRouting;
    TCHAR    szNetworkRangeFrom[MAX_NETRANGE_LEN + 1];
    TCHAR    szNetworkRangeTo[MAX_NETRANGE_LEN + 1];
    NAMELIST ZoneList;

} NETWORK_ADAPTER_NODE;

TCHAR *g_StrTcpipTitle;
TCHAR *g_StrIpxProtocolTitle;
TCHAR *g_StrAppletalkProtocolTitle;
TCHAR *g_StrMsClientTitle;
TCHAR *g_StrAdvancedTcpipSettings;

//
//	Function Prototypes
//
BOOL Create_MSClient_PropertySheet( IN HWND hwndParent );

BOOL Create_MS_NWIPX_PropertySheet( IN HWND hwndParent );

BOOL Create_TCPIP_PropertySheet( IN HWND hwndParent );

BOOL Create_Appletalk_PropertySheet( IN HWND hwndParent );

INT_PTR CALLBACK
DlgNetwarePage( IN HWND     hwnd,
                IN UINT     uMsg,
                IN WPARAM   wParam,
                IN LPARAM   lParam);

BOOL GetSelectedItemFromListView( IN  HWND hwndDlg,
                                  IN  WORD controlID,
                                  OUT LV_ITEM* lvI );

VOID SetListViewSelection( IN HWND hDlg,
                           IN WORD controlID,
                           IN INT position );

BOOL InsertEntryIntoListView( IN HWND hListViewWnd,
                              IN LPARAM lParam  );

INT CALLBACK ListViewCompareFunc( IN LPARAM lParam1,
                                  IN LPARAM lParam2,
                                  IN LPARAM lParamSort );

VOID NamelistToCommaString( IN NAMELIST* pNamelist, OUT TCHAR *szBuffer, IN DWORD cbSize );

INT_PTR CALLBACK AddDeviceDlgProc( IN HWND   hDlg,
                                IN UINT   iMsg,
                                IN WPARAM wParam,
                                IN LPARAM lParam );

INT_PTR CALLBACK TCPIP_PropertiesDlgProc( IN HWND     hwnd,
                                      IN UINT     uMsg,
                                      IN WPARAM   wParam,
                                      IN LPARAM   lParam );

VOID AdjustNetworkCardMemory( IN INT NewNumberOfNetworkCards,
                              IN INT OldNumberOfNetworkCards );

VOID InstallDefaultNetComponents( VOID );

VOID CreateListWithDefaults( OUT NETWORK_ADAPTER_NODE *pNetworkComponentNode );

INT TcpipNameListInsertIdx( NAMELIST* TcpipNameList,
                            TCHAR*    pString,
                            UINT      idx );

EXTERN_C INT TcpipAddNameToNameList( NAMELIST* TcpipNameList,
                                     TCHAR*    pString );

EXTERN_C NETWORK_COMPONENT* FindNode( IN INT iPosition );

EXTERN_C VOID DeleteList( IN OUT NETWORK_ADAPTER_NODE *pNetworkAdapterList );

EXTERN_C VOID ResetNetworkAdapter( OUT NETWORK_ADAPTER_NODE *pNetworkCard );

EXTERN_C VOID ZeroOut( OUT NETWORK_ADAPTER_NODE *pNetworkNode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\supplib.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// Module Name:
//      supplib.h
//
// Description:
//      This file contains defs for the supplib exports, macros etc...
//      It is included by setupmgr.h.  Don't include this file directly.
//
//----------------------------------------------------------------------------

#define MAX_INILINE_LEN 1024        // Buffer length for line in answer file
#define MAX_ININAME_LEN 127         // Max chars for [SectionName] and KeyName

//
// Count of chars macro
//

#define StrBuffSize(x) ( sizeof(x) / sizeof(TCHAR) )

//
// Growing list of renamed C run-time functions.
//

#define lstrdup     _wcsdup
#define lstrlwr     _wcslwr
#define lstrchr     wcschr
#define lstrncmp    wcsncmp
#define lsprintf    _stprintf

//
// settngs.c
//
// The below routines are how setupmgr writes out it's settings to the
// answer file, the udf, etc.
//
// We queue up what to write to these files, and when all settings have
// been queued, we flush it to disk.  See supplib\settngs.c for details.
//

typedef enum {

    SETTING_QUEUE_ANSWERS,
    SETTING_QUEUE_UDF,
    SETTING_QUEUE_ORIG_ANSWERS,
    SETTING_QUEUE_ORIG_UDF,
    SETTING_QUEUE_TXTSETUP_OEM

} QUEUENUM;

BOOL SettingQueue_AddSetting(LPTSTR   lpSection,
                             LPTSTR   lpKey,
                             LPTSTR   lpValue,
                             QUEUENUM dwWhichQueue);

VOID SettingQueue_MarkVolatile(LPTSTR   lpSection,
                               QUEUENUM dwWhichQueue);

VOID SettingQueue_Empty(QUEUENUM dwWhichQueue);

BOOL SettingQueue_Flush(LPTSTR   lpFileName,
                        QUEUENUM dwWhichQueue);

VOID SettingQueue_Copy(QUEUENUM dwFrom, QUEUENUM dwTo);

VOID SettingQueue_RemoveSection( LPTSTR lpSection, QUEUENUM dwWhichQueue );

VOID
LoadOriginalSettingsLow(HWND     hwnd,
                        LPTSTR   lpFileName,
                        QUEUENUM dwWhichQueue);

//
// namelist.c
//
// Struct that stores "name lists".  These are useful for arbitrary
// length listboxes such as "computername" and "printers" dialog.
//
// Any NAMELIST declared must be initialized to { 0 } before use.
//

typedef struct {
    UINT  AllocedSize;    // private: how big is *Names? (malloced size)
    UINT  nEntries;       // private: how many entries
    TCHAR **Names;        // private: list of names
} NAMELIST, *PNAMELIST;

EXTERN_C VOID  ResetNameList(NAMELIST *pNameList);
EXTERN_C UINT  GetNameListSize(NAMELIST *pNameList);
EXTERN_C TCHAR *GetNameListName(NAMELIST *pNameList, UINT idx);
EXTERN_C BOOL  RemoveNameFromNameList(NAMELIST *pNameList, TCHAR *NameToRemove);
EXTERN_C VOID  RemoveNameFromNameListIdx(NAMELIST *pNameList, UINT idx);
EXTERN_C INT   FindNameInNameList(NAMELIST *pNameList, TCHAR *String);
EXTERN_C BOOL  AddNameToNameList(NAMELIST *pNameList, TCHAR *String);
EXTERN_C BOOL  AddNameToNameListIdx(NAMELIST *pNameList,
                                    TCHAR    *String,
                                    UINT      idx);
EXTERN_C BOOL AddNameToNameListNoDuplicates( NAMELIST *pNameList,
                                             TCHAR    *String );

//
// exports from fonts.c
//

VOID SetControlFont(
    IN HFONT    hFont,
    IN HWND     hwnd,
    IN INT      nId);

VOID SetupFonts(
    IN HINSTANCE    hInstance,
    IN HWND         hwnd,
    IN HFONT        *pBigBoldFont,
    IN HFONT        *pBoldFont);

VOID  DestroyFonts(
    IN HFONT        hBigBoldFont,
    IN HFONT        hBoldFont);


//
// exports from msg.c
//

//
// Assert macros.  Pass only ANSI strings (no unicode).
//

#if DBG

EXTERN_C VOID __cdecl SetupMgrAssert(char *pszFile, int iLine, char *pszFormat, ...);

#define Assert( exp ) \
    if (!(exp)) \
        SetupMgrAssert( __FILE__ , __LINE__ , #exp )

#define AssertMsg( exp, msg ) \
    if (!(exp)) \
        SetupMgrAssert( __FILE__ , __LINE__ , msg )

#define AssertMsg1( exp, msg, a1 ) \
    if (!(exp)) \
        SetupMgrAssert( __FILE__ , __LINE__ , msg, a1 )

#define AssertMsg2( exp, msg, a1, a2 ) \
    if (!(exp)) \
        SetupMgrAssert( __FILE__ , __LINE__ , msg, a1, a2 )

#else
#define Assert( exp )
#define AssertMsg( exp, msg )
#define AssertMsg1( exp, msg, a1 )
#define AssertMsg2( exp, msg, a1, a2 )
#endif // DBG


//
// Bit-flags for ReportError()
//
// Choose either:
//      MSGTYPE_ERR
//      MSGTYPE_WARN
//      MSGTYPE_YESNO
//      MSGTYPE_RETRYCANCEL
//
// These can be or'red in at will:
//      MSGTYPE_WIN32
//
// Notes:
//  - Don't fiddle with the actual values of these constants unless
//    you fiddle with the ReportError() function as well.
//
//  - 8 bits are reserved for the "MajorType".  Callers don't need to
//    worry about this.  If you're enhancing ReportError(), you do need
//    to worry about this.
//

#define MSGTYPE_ERR         0x01     // error icon + ok button
#define MSGTYPE_WARN        0x02     // warning icon + ok button
#define MSGTYPE_YESNO       0x04     // question icon + yes & no buttons
#define MSGTYPE_RETRYCANCEL 0x08     // erro icon + retry & cancel buttons

#define MSGTYPE_WIN32       0x100    // also report Win32 error msg

#if DBG

int
__cdecl
ReportError(
    HWND   hwnd,            // calling window
    DWORD  dwMsgType,       // combo of MSGTYPE_*
    LPTSTR lpMessageStr,    // passed to sprintf
    ...);

#endif // DBG

int
__cdecl
ReportErrorId(
    HWND   hwnd,            // calling window
    DWORD  dwMsgType,       // combo of MSGTYPE_*
    UINT   StringId,        // resource id, passed to sprintf
    ...);


//
// exports from pathsup.c
//

EXTERN_C BOOL __cdecl ConcatenatePaths(LPTSTR lpBuffer, ...);
LPTSTR ParseDriveLetterOrUnc(LPTSTR lpFileName);
LPTSTR MyGetFullPath(LPTSTR lpFileName);
VOID GetComputerNameFromUnc( IN TCHAR *szFullUncPath, OUT TCHAR *szComputerName, IN DWORD cbSize );
BOOL GetPathFromPathAndFilename( IN LPTSTR lpPathAndFileName, OUT TCHAR *szPath, IN DWORD cbSize );
LONGLONG MyGetDiskFreeSpace(LPTSTR Drive);
LONGLONG MySetupQuerySpaceRequiredOnDrive(HDSKSPC hDiskSpace, LPTSTR Drive);
BOOL IsPathOnLocalDiskDrive(LPCTSTR lpPath);
BOOL DoesFolderExist(LPTSTR lpFolder);
BOOL DoesFileExist(LPTSTR lpFileName);
BOOL DoesPathExist(LPTSTR lpPathName);
BOOL EnsureDirExists(LPTSTR lpDirName);
VOID ILFreePriv(LPITEMIDLIST pidl);
BOOL GetAnswerFileName(HWND hwnd, LPTSTR lpFileName, BOOL bSavingFile);
INT ShowBrowseFolder( IN     HWND   hwnd,
                      IN     TCHAR *szFileFilter,
                      IN     TCHAR *szFileExtension,
                      IN     DWORD  dwFlags,
                      IN     TCHAR *szStartingPath,
                      IN OUT TCHAR *szFileNameAndPath );
VOID GetPlatform( OUT TCHAR *pBuffer );

//
// exports from chknames.c
//

BOOL IsNetNameValid( LPTSTR NameToCheck );
BOOL IsValidComputerName( LPTSTR ComputerName );
BOOL IsValidNetShareName( LPTSTR NetShareName );
BOOL IsValidFileName8_3( LPTSTR FileName );
BOOL IsValidPathNameNoRoot8_3( LPTSTR PathName );

//
// string.c
//

LPTSTR MyLoadString(IN UINT StringId);
LPTSTR CleanLeadSpace(LPTSTR Buffer);
VOID   CleanTrailingSpace(TCHAR *pszBuffer);
LPTSTR CleanSpaceAndQuotes(LPTSTR Buffer);
VOID   ConvertQuestionsToNull( IN OUT TCHAR *pszString );
EXTERN_C TCHAR* lstrcatn( IN TCHAR *pszString1, IN const TCHAR *pszString2, IN INT iMaxLength );
VOID DoubleNullStringToNameList( TCHAR *szDoubleNullString, NAMELIST *pNameList );
EXTERN_C BOOL GetCommaDelimitedEntry( OUT TCHAR szIPString[], IN OUT TCHAR **pBuffer );
VOID StripQuotes( IN OUT TCHAR *);
BOOL DoesContainWhiteSpace( LPCTSTR p );


//
// Exports from & macros for fileio.c
//

FILE* My_fopen( LPWSTR FileName,
                LPWSTR Mode );

int My_fputs( LPWSTR Buffer,
              FILE*  fp );

LPWSTR My_fgets( LPWSTR Buffer,
                 int    MaxChars,
                 FILE*  fp );

#define My_fclose fclose

//
//  Export from chknames.c
//
extern LPTSTR IllegalNetNameChars;

//
//  listbox.c
//

VOID OnUpButtonPressed( IN HWND hwnd, IN WORD ListBoxControlID );

VOID OnDownButtonPressed( IN HWND hwnd, IN WORD ListBoxControlID );

VOID SetArrows( IN HWND hwnd,
                IN WORD ListBoxControlID,
                IN WORD UpButtonControlID,
                IN WORD DownButtonControlID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\optcomp.h ===
/****************************************************************************\

    OPTCOMP.H / Setup Manager

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2002
    All rights reserved

    Source file for the Setup Manager that contains the external and internal
    functions used by the "Windows Components" wizard page.

    01/02 - Stephen Lodwick (STELO)
        Added header file for OPTCOMP.C

\****************************************************************************/

//
// Internal Structure(s):
//
typedef struct _COMPONENT_GROUP
{
    DWORD   dwComponentsIndex;
    DWORD64 dwComponents;
    UINT    uId;
    DWORD   dwValidSkus;
    DWORD   dwDefaultSkus;

} COMPONENT_GROUP, *PCOMPONENT_GROUP, *LPCOMPONENT_GROUP;

typedef struct _COMPONENT
{
    DWORD64  dwComponent;
    LPTSTR   lpComponentString;
    UINT     uId;
}COMPONENT, *PCOMPONENT, *LPCOMPONENT;

//
// Internal Defined Value(s):
//

// Individual components that are installed
//
#define FLG_OCS_ACCE    0x0000000000000001  // Accessibility
#define FLG_OCS_CALC    0x0000000000000002  // Calculator
#define FLG_OCS_CHAR    0x0000000000000004  // Character Map
#define FLG_OCS_CLIP    0x0000000000000008  // Clipboard
#define FLG_OCS_DESK    0x0000000000000010  // Desktop Wallpaper
#define FLG_OCS_TEMP    0x0000000000000020  // Document Templates
#define FLG_OCS_MOUS    0x0000000000000040  // Mouse Pointers
#define FLG_OCS_PAIN    0x0000000000000080  // Paint
#define FLG_OCS_FREE    0x0000000000000100  // Freecell
#define FLG_OCS_HEAR    0x0000000000000200  // Hearts
#define FLG_OCS_ZONE    0x0000000000000400  // Internet Games
#define FLG_OCS_MINE    0x0000000000000800  // Minesweeper
#define FLG_OCS_SOLI    0x0000000000001000  // Solitaire
#define FLG_OCS_SPID    0x0000000000002000  // Spider
#define FLG_OCS_INDE    0x0000000000004000  // Index Server
#define FLG_OCS_MSNE    0x0000000000008000  // MSN Explorer
#define FLG_OCS_CERT    0x0000000000010000  // Certificate Server Components
#define FLG_OCS_CERC    0x0000000000020000  // Certificate Server Client
#define FLG_OCS_CERS    0x0000000000040000  // Certificate Server
#define FLG_OCS_IISW    0x0000000000080000  // World Wide Web
#define FLG_OCS_IISF    0x0000000000100000  // File Transfer Protocol
#define FLG_OCS_SMTP    0x0000000000200000  // SMTP Services
#define FLG_OCS_SMTD    0x0000000000400000  // SMTP Services Documentation
#define FLG_OCS_NNTP    0x0000000000800000  // NNTP Services
#define FLG_OCS_NNTD    0x0000000001000000  // NNTP Services Documentation
#define FLG_OCS_REMI    0x0000000002000000  // RIS Service
#define FLG_OCS_REST    0x0000000004000000  // Remote Storage
#define FLG_OCS_TERM    0x0000000008000000  // Terminal Services
#define FLG_OCS_WMSS    0x0000000010000000  // Windows Media Services Core
#define FLG_OCS_WASP    0x0000000020000000  // Windows Media Services ASP Console
#define FLG_OCS_WMMC    0x0000000040000000  // Windows Media Services MMC Console
#define FLG_OCS_WASS    0x0000000080000000  // Windows Media Services Components
#define FLG_OCS_CHAT    0x0000000100000000  // Windows Chat
#define FLG_OCS_DIAL    0x0000000200000000  // Windows Dialer
#define FLG_OCS_HYPE    0x0000000400000000  // Hyperterminal
#define FLG_OCS_CDPL    0x0000000800000000  // CD Player
#define FLG_OCS_MEDI    0x0000001000000000  // Windows Media Player
#define FLG_OCS_SAMP    0x0000002000000000  // Samples sounds
#define FLG_OCS_UTOP    0x0000004000000000  // Samples utopia sounds
#define FLG_OCS_RECO    0x0000008000000000  // Recorder Control
#define FLG_OCS_VOLU    0x0000010000000000  // Volume Control




// Groups of components that can be selected by user
//
#define VAL_OCS_ACCE    ( FLG_OCS_ACCE )                                                                                            // Accessibility group
#define VAL_OCS_ACSS    ( FLG_OCS_CALC | FLG_OCS_CHAR | FLG_OCS_CLIP | FLG_OCS_DESK | FLG_OCS_TEMP | FLG_OCS_MOUS | FLG_OCS_PAIN )  // Accessories group
#define VAL_OCS_GAME    ( FLG_OCS_FREE | FLG_OCS_HEAR | FLG_OCS_ZONE | FLG_OCS_MINE | FLG_OCS_SOLI | FLG_OCS_SPID )                 // Games group
#define VAL_OCS_INDE    ( FLG_OCS_INDE )                                                                                            // Index service group
#define VAL_OCS_MSNE    ( FLG_OCS_MSNE )                                                                                            // MSNExplorer group
#define VAL_OCS_CERT    ( FLG_OCS_CERT | FLG_OCS_CERC | FLG_OCS_CERS )                                                              // Certificate server group
#define VAL_OCS_IISW    ( FLG_OCS_IISW )                                                                                            // IIS - Web Services group
#define VAL_OCS_IISF    ( FLG_OCS_IISF )                                                                                            // IIS - FTP Services group
#define VAL_OCS_SMTP    ( FLG_OCS_SMTP | FLG_OCS_SMTD )                                                                             // IIS - SMTP Services group
#define VAL_OCS_NNTP    ( FLG_OCS_NNTP | FLG_OCS_NNTD )                                                                             // IIS - NNTP Service group
#define VAL_OCS_REMI    ( FLG_OCS_REMI )                                                                                            // Remote Installation Services (RIS)
#define VAL_OCS_REST    ( FLG_OCS_REST )                                                                                            // Remote Storage group
#define VAL_OCS_TERM    ( FLG_OCS_TERM )                                                                                            // Terminal Server group
#define VAL_OCS_WMSS    ( FLG_OCS_WMSS | FLG_OCS_WASP | FLG_OCS_WMMC | FLG_OCS_WASS )                                               // Windows media services group
#define VAL_OCS_COMM    ( FLG_OCS_CHAT | FLG_OCS_DIAL | FLG_OCS_HYPE )                                                              // Communications
#define VAL_OCS_MULT    ( FLG_OCS_CDPL | FLG_OCS_MEDI | FLG_OCS_SAMP | FLG_OCS_UTOP | FLG_OCS_RECO | FLG_OCS_VOLU )                 // Multimedia group

// Mapping for component so it can be written to unattend file
//
static COMPONENT s_cComponent[] =
{
    { FLG_OCS_ACCE,     _T("accessopt"),        IDS_CPT_ACCE    },
    { FLG_OCS_CALC,     _T("calc"),             IDS_CPT_CALC    },
    { FLG_OCS_CHAR,     _T("charmap"),          IDS_CPT_CHAR    },
    { FLG_OCS_CLIP,     _T("clipbook"),         IDS_CPT_CLIP    },
    { FLG_OCS_DESK,     _T("deskpaper"),        IDS_CPT_DESK    },
    { FLG_OCS_TEMP,     _T("templates"),        IDS_CPT_TEMP    },
    { FLG_OCS_MOUS,     _T("mousepoint"),       IDS_CPT_MOUS    },
    { FLG_OCS_PAIN,     _T("paint"),            IDS_CPT_PAIN    },
    { FLG_OCS_FREE,     _T("freecell"),         IDS_CPT_FREE    },
    { FLG_OCS_HEAR,     _T("hearts"),           IDS_CPT_HEAR    },
    { FLG_OCS_ZONE,     _T("zonegames"),        IDS_CPT_ZONE    },
    { FLG_OCS_MINE,     _T("minesweeper"),      IDS_CPT_MINE    },
    { FLG_OCS_SOLI,     _T("solitaire"),        IDS_CPT_SOLI    },
    { FLG_OCS_SPID,     _T("spider"),           IDS_CPT_SPID    },
    { FLG_OCS_INDE,     _T("indexsrv_system"),  IDS_CPT_INDE    },
    { FLG_OCS_MSNE,     _T("msnexplr"),         IDS_CPT_MSNE    },
    { FLG_OCS_CERT,     _T("certsrv"),          IDS_CPT_CERT    },
    { FLG_OCS_CERC,     _T("certsrv_client"),   IDS_CPT_CERC    },
    { FLG_OCS_CERS,     _T("certsrv_server"),   IDS_CPT_CERS    },
    { FLG_OCS_IISW,     _T("iis_www"),          IDS_CPT_IISW    },
    { FLG_OCS_IISF,     _T("iis_ftp"),          IDS_CPT_IISF    },
    { FLG_OCS_SMTP,     _T("iis_smtp"),         IDS_CPT_SMTP    },
    { FLG_OCS_SMTD,     _T("iis_smtp_docs"),    IDS_CPT_SMTD    },
    { FLG_OCS_NNTP,     _T("iis_nntp"),         IDS_CPT_NNTP    },
    { FLG_OCS_NNTD,     _T("iis_nntp_docs"),    IDS_CPT_NNTD    },
    { FLG_OCS_REMI,     _T("reminst"),          IDS_CPT_REMI    },
    { FLG_OCS_REST,     _T("rstorage"),         IDS_CPT_REST    },
    { FLG_OCS_TERM,     _T("TerminalServer"),   IDS_CPT_TERM    },
    { FLG_OCS_WMSS,     _T("wms"),              IDS_CPT_WMSS    },
    { FLG_OCS_WASP,     _T("wms_admin_asp"),    IDS_CPT_WASP    },
    { FLG_OCS_WMMC,     _T("wms_admin_mmc"),    IDS_CPT_WMMC    },
    { FLG_OCS_WASS,     _T("wms_server"),       IDS_CPT_WASS    },
    { FLG_OCS_CHAT,     _T("chat"),             IDS_CPT_CHAT    },
    { FLG_OCS_DIAL,     _T("dialer"),           IDS_CPT_DIAL    },
    { FLG_OCS_HYPE,     _T("hypertrm"),         IDS_CPT_HYPE    },
    { FLG_OCS_CDPL,     _T("cdplayer"),         IDS_CPT_CDPL    },
    { FLG_OCS_MEDI,     _T("mplay"),            IDS_CPT_MEDI    },
    { FLG_OCS_SAMP,     _T("media_clips"),      IDS_CPT_SAMP    },
    { FLG_OCS_UTOP,     _T("media_utopia"),     IDS_CPT_UTOP    },
    { FLG_OCS_RECO,     _T("rec"),              IDS_CPT_RECO    },
    { FLG_OCS_VOLU,     _T("vol"),              IDS_CPT_VOLU    },
};

// List of groups with their cooresponding friendly names
//
static COMPONENT_GROUP s_cgComponentNames[] =
{
    { 0,  VAL_OCS_ACCE, IDS_OCS_ACCE, PLATFORM_ALL,                             PLATFORM_ALL        },
    { 1,  VAL_OCS_ACSS, IDS_OCS_ACSS, PLATFORM_ALL,                             PLATFORM_ALL        },
    { 2,  VAL_OCS_GAME, IDS_OCS_GAME, PLATFORM_ALL,                             PLATFORM_USER       },
    { 3,  VAL_OCS_COMM, IDS_OCS_COMM, PLATFORM_ALL,                             PLATFORM_ALL        },
    { 4,  VAL_OCS_MULT, IDS_OCS_MULT, PLATFORM_ALL,                             PLATFORM_ALL        },
    { 5,  VAL_OCS_MSNE, IDS_OCS_MSNE, PLATFORM_ALL,                             PLATFORM_USER       },
    { 6,  VAL_OCS_INDE, IDS_OCS_INDE, PLATFORM_ALL,                             PLATFORM_ALL        },
    { 7,  VAL_OCS_CERT, IDS_OCS_CERT, PLATFORM_SERVER  | PLATFORM_ENTERPRISE,   PLATFORM_NONE       },
    { 8,  VAL_OCS_IISW, IDS_OCS_IISW, PLATFORM_SERVERS | PLATFORM_WORKSTATION,  PLATFORM_WEBBLADE   },
    { 9,  VAL_OCS_IISF, IDS_OCS_IISF, PLATFORM_SERVERS | PLATFORM_WORKSTATION,  PLATFORM_NONE       },
    { 10, VAL_OCS_SMTP, IDS_OCS_SMTP, PLATFORM_SERVERS | PLATFORM_WORKSTATION,  PLATFORM_WEBBLADE   },
    { 11, VAL_OCS_NNTP, IDS_OCS_NNTP, PLATFORM_SERVERS | PLATFORM_WORKSTATION,  PLATFORM_NONE       },
    { 12, VAL_OCS_REMI, IDS_OCS_REMI, PLATFORM_SERVER  | PLATFORM_ENTERPRISE,   PLATFORM_NONE       },
    { 13, VAL_OCS_REST, IDS_OCS_REST, PLATFORM_SERVER  | PLATFORM_ENTERPRISE,   PLATFORM_NONE       },
    { 14, VAL_OCS_TERM, IDS_OCS_TERM, PLATFORM_SERVER  | PLATFORM_ENTERPRISE,   PLATFORM_NONE       },
    { 15, VAL_OCS_WMSS, IDS_OCS_WMSS, PLATFORM_SERVER  | PLATFORM_ENTERPRISE,   PLATFORM_NONE       },
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\miscapi.h ===
/****************************************************************************\

	MISCAPI.H / OPK Wizard (OPKWIZ.EXE)

	Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

	Misc. API header file for the OPK Wizard.  Contains misc. API function
    prototypes.

	3/99 - Jason Cohen (JCOHEN)
        Added this new header file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/

#ifndef _MISCAPI_H_
#define _MISCAPI_H_


//
// External Function Prototype(s):
//

void CheckValidBrowseFolder(TCHAR[]);
void SetLastKnownBrowseFolder(TCHAR[]);
BOOL ValidURL(LPTSTR);
BOOL IsFolderShared(LPWSTR lpFolder, LPWSTR lpShare, DWORD cbShare);
BOOL CopyDirectoryDialog(HINSTANCE hInstance, HWND hwnd, LPTSTR lpSrc, LPTSTR lpDst);
BOOL CopyResetFileErr(HWND hwnd, LPCTSTR lpSource, LPCTSTR lpTarget);

// Install.ins specific
//
void ReadInstallInsKey(TCHAR[], TCHAR[], TCHAR[], INT, TCHAR[], BOOL*);
void WriteInstallInsKey(TCHAR[], TCHAR[], TCHAR[], TCHAR[], BOOL);


#endif // _MISCAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\setupmgr.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// Filename:
//    setupmgr.h
//
// Description:
//    This is the top-level include file for all setupmgr source files.
//
//----------------------------------------------------------------------------

#ifndef _SETUPMGR_H_
#define _SETUPMGR_H_

#include <opklib.h>
#include <windows.h>
#include <windowsx.h>
#include <prsht.h>
#include <stdlib.h>
#include <stdio.h>
#include <tchar.h>
#include <commdlg.h>
#include <setupapi.h>
#include <shlobj.h>
#include <shellapi.h>
#include "wizard.h"
#include "main.h"
#include "comres.h"
#include "supplib.h"
#include "netshrd.h"
#include "timezone.h"
#include "dlgprocs.h"
#include "oc.h"

//
// Global types & buffer dimensions for main pages
//

#define MAX_CMDLINE 1024

//
// Global types & buffer dimensions for base pages
//

#define MAX_PASSWORD                 127
#define MAX_NAMEORG_NAME             50
#define MAX_NAMEORG_ORG              50
#define MAX_COMPUTERNAME             63
#define MAX_PRINTERNAME              127         // arbitrarily chosen
#define MAX_SHARENAME                63          // arbitrarily chosen
#define MAX_TARGPATH                 63          // arbitrarily chosen
#define MAX_DIST_FOLDER              200
#define MAX_WORKGROUP_LENGTH         128
#define MAX_DOMAIN_LENGTH            128
#define MAX_USERNAME_LENGTH          31
#define MAX_DOMAIN_PASSWORD_LENGTH   255
#define MAX_NETWORK_ADDRESS_LENGTH   80
#define MAX_SIF_DESCRIPTION_LENGTH   65
#define MAX_SIF_HELP_TEXT_LENGTH     260
#define MAX_OEMDUPSTRING_LENGTH      255
#define MAX_HAL_NAME_LENGTH          MAX_INILINE_LEN
#define MAX_INS_LEN                  MAX_PATH
#define MAX_AUTOCONFIG_LEN           1024
#define MAX_PROXY_LEN                1024
#define MAX_PROXY_PORT_LEN           256
#define MAX_EXCEPTION_LEN            4096
#define MAX_HOMEPAGE_LEN             1024
#define MAX_HELPPAGE_LEN             1024
#define MAX_SEARCHPAGE_LEN           1024
#define MAX_ZONE_LEN                 256

#define MAX_PID_FIELD       5
#define NUM_PID_FIELDS      5

#define MIN_SERVER_CONNECTIONS  5

typedef TCHAR PRODUCT_ID_FIELD[MAX_PID_FIELD + 1];

//
// We identify a valid cd or netshare as having dosnet.inf.  Note, do not
// localize these strings.
//

#define OEM_TXTSETUP_NAME    _T("txtsetup.oem")

#define I386_DIR  _T("i386")
#define ALPHA_DIR _T("alpha")

#define DOSNET_INF _T("dosnet.inf")

#define I386_DOSNET  I386_DIR  _T("\\") DOSNET_INF
#define ALPHA_DOSNET ALPHA_DIR _T("\\") DOSNET_INF

typedef enum {

    LOAD_UNDEFINED,
    LOAD_NEWSCRIPT_DEFAULTS,
    LOAD_FROM_ANSWER_FILE,

} LOAD_TYPES;

typedef enum {

    PRODUCT_UNATTENDED_INSTALL,
    PRODUCT_REMOTEINSTALL,
    PRODUCT_SYSPREP

} PRODUCT_TYPES;

typedef enum {
    PLATFORM_WORKSTATION    = 0x0001,
    PLATFORM_SERVER         = 0x0002,
    PLATFORM_ENTERPRISE     = 0x0004,
    PLATFORM_WEBBLADE       = 0x0008,
    PLATFORM_PERSONAL       = 0x0010
} PLATFORM_TYPES;

// Groups of platforms
//
#define PLATFORM_NONE    (PLATFORM_SERVER)
#define PLATFORM_ALL     (PLATFORM_WORKSTATION | PLATFORM_SERVER | PLATFORM_ENTERPRISE | PLATFORM_WEBBLADE | PLATFORM_PERSONAL)
#define PLATFORM_SERVERS (PLATFORM_SERVER | PLATFORM_ENTERPRISE | PLATFORM_WEBBLADE)
#define PLATFORM_USER    (PLATFORM_WORKSTATION | PLATFORM_PERSONAL)


typedef enum {

    UMODE_GUI_ATTENDED,
    UMODE_PROVIDE_DEFAULT,
    UMODE_DEFAULT_HIDE,
    UMODE_READONLY,
    UMODE_FULL_UNATTENDED

} UMODE_TYPES;

typedef enum {

    TARGPATH_UNDEFINED,
    TARGPATH_WINNT,
    TARGPATH_AUTO,
    TARGPATH_SPECIFY

} TARGPATH_TYPES;

typedef enum {

    TYPICAL_NETWORKING,
    CUSTOM_NETWORKING,
    DONOTCHANGE_NETWORKING

} NETWORKING_TYPES;

typedef enum {

    IE_NO_CUSTOMIZATION,
    IE_USE_BRANDING_FILE,
    IE_SPECIFY_SETTINGS

} IE_CUSTOMIZATION_TYPES;

typedef enum {

    REGIONAL_SETTINGS_NOT_SPECIFIED,
    REGIONAL_SETTINGS_SKIP,
    REGIONAL_SETTINGS_DEFAULT,
    REGIONAL_SETTINGS_SPECIFY

} REGIONAL_SETTINGS_TYPES;

//
// "Fixed globals".  Setupmgr will never reset anything in this struct.
// (see load.c, newedit.c, scanreg.c)
//

typedef struct {

    HINSTANCE hInstance;

    HFONT hBigBoldFont;
    HFONT hBoldFont;

    LOAD_TYPES iLoadType;                     // new/edit page
    TCHAR      ScriptName[MAX_PATH + 1];      // new/edit page
    TCHAR      UdfFileName[MAX_PATH + 1];     // set by save page
    TCHAR      BatchFileName[MAX_PATH + 1];   // set by save page

    TIME_ZONE_LIST      *TimeZoneList;        // filled in at wizard init time
    LANGUAGELOCALE_LIST *LanguageLocaleList;  // filled in at wizard init time
    LANGUAGEGROUP_LIST  *LanguageGroupList;   // filled in at wizard init time
    NAMELIST *LangGroupAdditionalFiles;       // filled in at wizard init time

    TCHAR szSavePath[MAX_PATH + 1];         // save screen page

} FIXED_GLOBALS;

//
// Global data for the "main" wizard pages.
//

typedef struct {

    BOOL  bNewScript;                        // new/edit page

    BOOL  bStandAloneScript;                 // standalone page
    BOOL  bCreateNewDistFolder;              // distfolder page
    TCHAR DistFolder[MAX_DIST_FOLDER + 1];   // distfolder page
    TCHAR UncDistFolder[MAX_PATH];           // distfolder page
    TCHAR DistShareName[MAX_SHARENAME + 1];  // distfolder page

    TCHAR OemFilesPath[MAX_PATH];            // computed by distfolder.c
    TCHAR OemPnpDriversPath[MAX_PATH];       // computed by adddirs.c

    PRODUCT_TYPES  iProductInstall;          // unattended/RIS/sysprep page
    PLATFORM_TYPES iPlatform;                // platform page

    BOOL  bDoAdvancedPages;                  // advanced page

    BOOL  bCopyFromPath;                     // copyfiles1
    TCHAR CopySourcePath[MAX_PATH];          // copyfiles1
    TCHAR CdSourcePath[MAX_PATH];            // copyfiles1 (computed)
    TCHAR Architecture[MAX_PATH];            // copyfiles1 (computed)

} WIZGLOBALS;

//
// Type to hold settings for the general settings (base settings).
//

typedef struct {

    UMODE_TYPES iUnattendMode;                  // unattend mode page

    BOOL bSkipEulaAndWelcome;                   // Accept EULA page

    PRODUCT_ID_FIELD ProductId[NUM_PID_FIELDS]; // PID page(s)

    BOOL    bPerSeat;                           // srv licensing
    int     NumConnections;                     // srv licensing

    TCHAR   UserName[MAX_NAMEORG_NAME + 1];     // name/org page
    TCHAR   Organization[MAX_NAMEORG_ORG + 1];  // name/org page

    NAMELIST ComputerNames;                     // compname page
    BOOL     bAutoComputerName;                 // compname page

    NAMELIST RunOnceCmds;                       // runonce page

    NAMELIST PrinterNames;                      // printers page

    int      TimeZoneIdx;                       // timezone page

    TARGPATH_TYPES iTargetPath;                 // targpath page ISSUE-2002/02/28-stelo- verify max width
    TCHAR   TargetPath[MAX_TARGPATH + 1];       // targpath page

    BOOL    bSpecifyPassword;                   // admin passwd page
    TCHAR   AdminPassword[MAX_PASSWORD + 3];    // admin passwd page (+3 is for surrounding quotes and '\0')
    TCHAR   ConfirmPassword[MAX_PASSWORD + 1];  // admin passwd page
    BOOL    bEncryptAdminPassword;              // admin passwd page
    BOOL    bAutoLogon;                         // admin passwd page
    int     nAutoLogonCount;                    // admin passwd page

    int     DisplayColorBits;                   // display page
    int     DisplayXResolution;                 // display page
    int     DisplayYResolution;                 // display page
    int     DisplayRefreshRate;                 // display page

    TCHAR lpszLogoBitmap[MAX_PATH];             // OEM Ads page
    TCHAR lpszBackgroundBitmap[MAX_PATH];       // OEM Ads page

    DWORD dwCountryCode;                                // TAPI page
    INT   iDialingMethod;                               // TAPI page
    TCHAR szAreaCode[MAX_PHONE_LENGTH + 1];             // TAPI page
    TCHAR szOutsideLine[MAX_PHONE_LENGTH + 1];          // TAPI page
    
    BOOL     bSysprepLangFilesCopied;
    REGIONAL_SETTINGS_TYPES iRegionalSettings;           // Regional settings page
    BOOL     bUseCustomLocales;                          // Regional settings page
    NAMELIST LanguageGroups;                             // Regional settings page
    NAMELIST LanguageFilePaths;                          // Regional settings page
    TCHAR    szLanguage[MAX_LANGUAGE_LEN + 1];           // Regional settings page
    TCHAR    szMenuLanguage[MAX_LANGUAGE_LEN + 1];       // Regional settings page
    TCHAR    szNumberLanguage[MAX_LANGUAGE_LEN + 1];     // Regional settings page
    TCHAR    szKeyboardLayout[MAX_KEYBOARD_LAYOUT + 1];  // Regional settings page
    TCHAR    szLanguageLocaleId[MAX_LANGUAGE_LEN + 1];   // Regional settings page

    TCHAR szSifDescription[MAX_SIF_DESCRIPTION_LENGTH + 1];  // Sif text page
    TCHAR szSifHelpText[MAX_SIF_HELP_TEXT_LENGTH + 1];       // Sif text page

    BOOL bCreateSysprepFolder;                               // Sysprep folder page

    TCHAR szOemDuplicatorString[MAX_OEMDUPSTRING_LENGTH + 1];  // OEM Dup string page

    NAMELIST MassStorageDrivers;                         // SCSI drivers page
    NAMELIST OemScsiFiles;                               // SCSI drivers page

    TCHAR    szHalFriendlyName[MAX_INILINE_LEN];     // HAL page
    NAMELIST OemHalFiles;                            // HAL page

    IE_CUSTOMIZATION_TYPES  IeCustomizeMethod;                   // IE page
    TCHAR  szInsFile[MAX_INS_LEN + 1];                           // IE page
    BOOL   bUseAutoConfigScript;                                 // IE page
    TCHAR  szAutoConfigUrl[MAX_AUTOCONFIG_LEN + 1];              // IE page
    TCHAR  szAutoConfigUrlJscriptOrPac[MAX_AUTOCONFIG_LEN + 1];  // IE page
    BOOL   bUseProxyServer;                                      // IE page
    BOOL   bBypassProxyForLocalAddresses;                        // IE page
    TCHAR  szHttpProxyAddress[MAX_PROXY_LEN + 1];                // IE page
    TCHAR  szHttpProxyPort[MAX_PROXY_PORT_LEN + 1];              // IE page
    TCHAR  szSecureProxyAddress[MAX_PROXY_LEN + 1];              // IE page
    TCHAR  szSecureProxyPort[MAX_PROXY_PORT_LEN + 1];            // IE page
    TCHAR  szFtpProxyAddress[MAX_PROXY_LEN + 1];                 // IE page
    TCHAR  szFtpProxyPort[MAX_PROXY_PORT_LEN + 1];               // IE page
    TCHAR  szGopherProxyAddress[MAX_PROXY_LEN + 1];              // IE page 
    TCHAR  szGopherProxyPort[MAX_PROXY_PORT_LEN + 1];            // IE page
    TCHAR  szSocksProxyAddress[MAX_PROXY_LEN + 1];               // IE page
    TCHAR  szSocksProxyPort[MAX_PROXY_PORT_LEN + 1];             // IE page
    BOOL   bUseSameProxyForAllProtocols;                         // IE page
    TCHAR  szProxyExceptions[MAX_EXCEPTION_LEN + 1];             // IE page
    TCHAR  szHomePage[MAX_HOMEPAGE_LEN + 1];                     // IE page
    TCHAR  szHelpPage[MAX_HELPPAGE_LEN + 1];                     // IE page
    TCHAR  szSearchPage[MAX_SEARCHPAGE_LEN + 1];                 // IE page
    NAMELIST Favorites;                                          // IE page
    DWORD64 dwWindowsComponents;

} GENERAL_SETTINGS;

//
// Struct to hold the net settings
//
typedef struct {

    NETWORKING_TYPES iNetworkingMethod;

    BOOL  bCreateAccount;
    BOOL  bWorkgroup; // True if joining a workgroup, False if joining a domain

    TCHAR WorkGroupName[MAX_WORKGROUP_LENGTH + 1];
    TCHAR DomainName[MAX_DOMAIN_LENGTH + 1];
    TCHAR DomainAccount[MAX_USERNAME_LENGTH + 1];
    TCHAR DomainPassword[MAX_DOMAIN_PASSWORD_LENGTH + 1];
    TCHAR ConfirmPassword[MAX_DOMAIN_PASSWORD_LENGTH + 1];

	//
	//  TCPIP variables
    //
    BOOL  bObtainDNSServerAutomatically;
	NAMELIST TCPIP_DNS_Domains;

    BOOL bIncludeParentDomains;
    BOOL bEnableLMHosts;

	//
	//  IPX variables
    //
	TCHAR szInternalNetworkNumber[MAX_INTERNAL_NET_NUMBER_LEN + 1];
	
    //
    //  Appletalk variables
    //
    TCHAR szDefaultZone[MAX_ZONE_LEN + 1];

	//
	//  Client for MS Networks variables
    //
    MS_CLIENT NameServiceProvider;
	INT   iServiceProviderName;
	TCHAR szNetworkAddress[MAX_NETWORK_ADDRESS_LENGTH + 1];

    //
    //  Client Service for Netware
    //
    BOOL  bDefaultTreeContext;
    TCHAR szPreferredServer[MAX_PREFERRED_SERVER_LEN + 1];
    TCHAR szDefaultTree[MAX_DEFAULT_TREE_LEN + 1];
    TCHAR szDefaultContext[MAX_DEFAULT_CONTEXT_LEN + 1];
    BOOL  bNetwareLogonScript;

    INT iNumberOfNetworkCards;
    INT iCurrentNetworkCard;
    NETWORK_ADAPTER_NODE *pCurrentAdapter;

    //
    //  Initial 11, grows only when the user selects the "Have Disk" option
    //  and adds a new client, service, or protocol
    //  (the "Have Disk" feature is not currently implemented)
    //
    INT NumberOfNetComponents;

    NETWORK_COMPONENT *NetComponentsList;

    //
    //  List that contains one node for each network card in the system
    //
    NETWORK_ADAPTER_NODE *NetworkAdapterHead;

} NET_SETTINGS;



//
// Declare the global vars
//

#ifdef _SMGR_DECLARE_GLOBALS_

FIXED_GLOBALS    FixedGlobals = {0};
WIZGLOBALS       WizGlobals   = {0};
GENERAL_SETTINGS GenSettings  = {0};
NET_SETTINGS     NetSettings  = {0};
TCHAR *g_StrWizardTitle;

#else

EXTERN_C FIXED_GLOBALS    FixedGlobals;
EXTERN_C WIZGLOBALS       WizGlobals;
EXTERN_C GENERAL_SETTINGS GenSettings;
EXTERN_C NET_SETTINGS     NetSettings;
EXTERN_C TCHAR *g_StrWizardTitle;

#endif  // _SMGR_DECLARE_GLOBALS


//
// The exports from the common directory.  These are the basic operations
// of this wizard that effect all pages.
//

VOID InitTheWizard(VOID);
VOID StartTheWizard(HINSTANCE hInstance);
VOID CancelTheWizard(HWND hwnd);
VOID TerminateTheWizard(int  iErrorID);
BOOL SaveAllSettings(HWND hwnd);
BOOL LoadAllAnswers(HWND hwnd, LOAD_TYPES iOrigin);
int StartWizard(HINSTANCE, LPSTR);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\sku.h ===
/****************************************************************************\

    SKU.H / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Target SKU" wizard page.

    10/00 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard.  It includes the new
        ability to deploy mulitple product skus (per, pro, srv, ...) from one
        wizard.

    10/00 - Stephen Lodwick (STELO)
        Added header file for SKU.C so we could use the CopyDialogProgress
        throughout the project

\****************************************************************************/

#ifndef _SKU_H_
#define _SKU_H_

//
// Internal Defined Value(s):
//

#define DIR_SKU                 _T("sku")

#define DIR_ARCH_X86            _T("x86")
#define DIR_ARCH_IA64           _T("ia64")

#define STR_PLATFORM_X86        _T("i386")
#define STR_PLATFORM_IA64       DIR_ARCH_IA64

#define DIR_CD_X86              STR_PLATFORM_X86
#define DIR_CD_IA64             STR_PLATFORM_IA64

#define DIR_SKU_PRO             _T("pro")
#define DIR_SKU_SRV             _T("srv")
#define DIR_SKU_ADV             _T("ads")
#define DIR_SKU_DTC             _T("dtc")
#define DIR_SKU_PER             _T("per")
#define DIR_SKU_BLA             _T("bla")
#define DIR_SKU_SBS             _T("sbs")

#define FILE_DOSNET_INF         _T("dosnet.inf")
#define FILE_WINNT32            _T("winnt32.exe")

#define STR_SKUARCH             _T("%s (%s)")
#define STR_SKUSP               _T(" Service Pack %d")

#define INI_KEY_ARCH            _T("Arch")

#define INI_SEC_MISC            _T("Miscellaneous")
#define INI_KEY_PRODTYPE        _T("ProductType")
#define INI_KEY_PLATFORM        _T("DestinationPlatform")
#define INI_KEY_SERVICEPACK     _T("ServicePack")

#define INI_SEC_DIRS            _T("Directories")
#define INI_KEY_DIR             _T("d%d")

#define STR_EVENT_CANCEL        _T("OPKWIZ_EVENT_CANCEL")

#define PROGRESS_ERR_SUCCESS    0
#define PROGRESS_ERR_CANCEL     1
#define PROGRESS_ERR_COPYERR    2
#define PROGRESS_ERR_THREAD     3

#define NUM_FIRST_SOURCE_DX     1


//
// Internal Structure(s):
//

typedef struct _COPYDIRDATA
{
    HWND    hwndParent;
    TCHAR   szSrc[MAX_PATH];
    TCHAR   szDst[MAX_PATH];
    TCHAR   szInfFile[MAX_PATH];
    LPTSTR  lpszEndSku;
    DWORD   dwFileCount;
    HANDLE  hEvent;
} COPYDIRDATA, *PCOPYDIRDATA, *LPCOPYDIRDATA;


//
// External Function Prototype(s):
//
DWORD CopySkuFiles(HWND hwndProgress, HANDLE hEvent, LPTSTR lpszSrc, LPTSTR lpszDst, LPTSTR lpszInfFile);
LRESULT CALLBACK ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // _SKU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\timezone.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      timezone.h
//
// Description:
//      This file contains definitions for loading the timezone info
//      out of the registry and into internal data structs.
//
//----------------------------------------------------------------------------

#define TZ_IDX_GMT             0x55     // Idx of GMT
#define TZ_IDX_UNDEFINED       -1       // Idx for nothing being set
#define TZ_IDX_SETSAMEASSERVER -2       // Idx for Set Same As Server
#define TZ_IDX_DONOTSPECIFY    -3       // Idx for Do Not Specify this setting

#define TZNAME_SIZE 128                 // buffer size

//
// Registry key names for getting timezone info out of the registry.
//

#define REGKEY_TIMEZONES      \
        _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones")

#define REGVAL_TZ_DISPLAY     _T("Display")
#define REGVAL_TZ_INDEX       _T("Index")
#define REGVAL_TZ_STDNAME     _T("Std")

//
// This is where the timezone for the current machine lives.  We use
// this for the regload feature and strcmp CUR_STDNAME with the StdName
// of each entry.
//

#define REGKEY_CUR_TIMEZONE   \
        _T("System\\CurrentControlSet\\Control\\TimeZoneInformation")

#define REGVAL_CUR_STDNAME    _T("StandardName")


//
// For each valid timezone...
//
//      DisplayName e.g. (GMT-08:00) Pacific Time
//      StdName     e.g. Pacific Standard Time
//      Index       Timezone=xx in the unattend.txt
//
// All of this info is in REGKEY_TIMEZONES
//

typedef struct {

    TCHAR DisplayName[TZNAME_SIZE];
    TCHAR StdName[TZNAME_SIZE];
    int   Index;

} TIME_ZONE_ENTRY;

//
// An array of time zone entries ...
//

typedef struct {

    int              NumEntries;     // size of array
    TIME_ZONE_ENTRY *TimeZones;      // array of timezone entries

} TIME_ZONE_LIST;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\advance.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      advance.c
//
// Description:
//      This file contains the dlgproc for the IDD_ADVANCED1 page.  It
//      is a flow page that controls whether to show the user a whole
//      bunch more pages or not.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveAdvance
//
//  Purpose: Called at SETACTIVE time.  Init controls.
//
//----------------------------------------------------------------------------

VOID OnSetActiveAdvance(HWND hwnd)
{
    CheckRadioButton(hwnd,
                     IDC_ADVANCEDYES,
                     IDC_ADVANCEDNO,
                     WizGlobals.bDoAdvancedPages ? IDC_ADVANCEDYES
                                                 : IDC_ADVANCEDNO);

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnRadioButtonAdvance
//
//  Purpose: Called when one of the radio buttons is pushed.
//
//----------------------------------------------------------------------------

VOID OnRadioButtonAdvance(HWND hwnd, int nButtonId)
{
    CheckRadioButton(hwnd,
                     IDC_ADVANCEDYES,
                     IDC_ADVANCEDNO,
                     nButtonId);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextAdvance
//
//  Purpose: Called when NEXT button is pushed.
//
//----------------------------------------------------------------------------

VOID OnWizNextAdvance(HWND hwnd)
{
    WizGlobals.bDoAdvancedPages = IsDlgButtonChecked(hwnd, IDC_ADVANCEDYES);
}

//----------------------------------------------------------------------------
//
// Function: DlgAdvanced1Page
//
// Purpose: This is the dialog procedure the IDD_ADVANCED1 page.  It simply
//          asks if the user wants to deal with advanced features or not.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgAdvanced1Page(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_ADVANCEDYES:
                    case IDC_ADVANCEDNO:

                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRadioButtonAdvance(hwnd, LOWORD(wParam));
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        CancelTheWizard(hwnd);
                        break;

                    case PSN_SETACTIVE:
                        OnSetActiveAdvance(hwnd);
                        break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                        OnWizNextAdvance(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\adddirs.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      adddirs.c
//
// Description:
//      This file contains the dlgproc and friends of the additional
//      dirs page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//
// These are the names of our special roots in the tree-view.  They are
// loaded from the resource.
//

static TCHAR *StrOemRootName;
static TCHAR *StrSysDriveName;
static TCHAR *StrSysDirName;
static TCHAR *StrOtherDrivesName;
static TCHAR *StrPnpDriversName;
static TCHAR *StrTempFilesName;
static TCHAR *StrSysprepFilesName;
static TCHAR *StrTextmodeFilesName;

//
// The below types and vars support the extra data that we put on tree-view
// items (the lParam in a TVITEM).
//
// We ONLY put this data on our special keys.
//
// All other tree-view entries must have NULL for the lParam.
//
// This extra data on these special tree-view keys supports a number of
// activities.  It helps ComputeFullPathOfItem() figure out the diskpath.
// It helps OnSelectionChange() figure out whether to grey buttons (e.g.
// you can't delete "User Supplied Files", etc...)
//
// The on-disk pathname is computed at run-time (init-time) because we
// don't know where the dist folder is until run-time.
//

enum {
    KEY_OEMROOT,
    KEY_SYSDRIVE,
    KEY_SYSDIR,
    KEY_OTHERDRIVES,
    KEY_PNPDRIVERS,
    KEY_TEMPFILES,
    KEY_LANGFILES,
    KEY_SYSPREP,
    KEY_TEXTMODE
};

typedef struct {
    UINT  iSpecialKeyId;               // which special key?
    TCHAR OnDiskPathName[MAX_PATH];    // the disk-path the key maps to
    TCHAR *Description;                // description to display on the ui
} SPECIAL_KEY_DATA;

SPECIAL_KEY_DATA gOemRootData      = { KEY_OEMROOT,
                                       _T(""),
                                       _T("") };

SPECIAL_KEY_DATA gSysDriveData     = { KEY_SYSDRIVE,
                                       _T(""),
                                       _T("") };

SPECIAL_KEY_DATA gSysDirData       = { KEY_SYSDIR,
                                       _T(""),
                                       _T("") };

SPECIAL_KEY_DATA gOtherDrivesData  = { KEY_OTHERDRIVES,
                                       _T(""),
                                       _T("") };

SPECIAL_KEY_DATA gPnpDriversData   = { KEY_PNPDRIVERS,
                                       _T(""),
                                       _T("") };

SPECIAL_KEY_DATA gTempFilesData    = { KEY_TEMPFILES,
                                       _T(""),
                                       _T("") };

SPECIAL_KEY_DATA gSysprepData      = { KEY_SYSPREP,
                                       _T(""),
                                       _T("") };

SPECIAL_KEY_DATA gTextmodeData     = { KEY_TEXTMODE,
                                       _T(""),
                                       _T("") };

//
// The below variable is used to keep track of some info about the current
// selection on the tree-view.
//
// Each time the user changes the current selection, we update the below
// variable.  Later, when the user pushes the ADD or REMOVE buttons, these
// fields are read.  This isolates all of the goo about figuring out disk
// paths to the OnSelectionChange() event.
//
// We set a "Current Item" and a "Current Folder" derived from the current
// tree-view selection.  User deletes the current item, and copies go into
// the current folder.  CurrentItem == CurrentFolder if user selects a
// directory on the tree-view.
//

typedef struct {

    TCHAR     lpCurItemPath[MAX_PATH];
    TCHAR     lpCurFolderPath[MAX_PATH];
    HTREEITEM hCurItem;
    HTREEITEM hCurFolderItem;

} ADDDIRS_CURSEL_INF;

ADDDIRS_CURSEL_INF gCurSel;

//
// This type and the vars are used to cache info about the shell icons
// associated with files and dirents.
//
// As we walk directory trees, we query the shell to get the icons
// associated with that file or directory.  Since we don't know how many
// icons we need before-hand, we cache unique icons onto the linked list
// below.  When we're done walking trees, we make the Image_List and
// repaint the tree-view control.
//

typedef struct icon_info_tag {

    HIMAGELIST hSysImageList;
    int        iSysIdx;
    int        iOurIdx;
    HICON      hIcon;
    struct icon_info_tag *next;

} ICON_INFO;

static ICON_INFO *pHeadOfIconList = NULL;
static int gCurIconIdx = 0;

//
// This array is used by CreateSkeletonOemTree() to build an empty
// $oem$ tree.
//

TCHAR *DefaultOemTree[] = {
    _T("$$"),
    _T("$$\\system32"),
    _T("$1"),
    _T("$1\\drivers"),
    _T("C"),
    _T("D"),
    _T("Textmode")
};

//
//  Sysprep string constants
//
static TCHAR const SYSPREP_EXE[] = _T("sysprep.exe");
static TCHAR const SETUPCL_EXE[] = _T("setupcl.exe");

static TCHAR SYSPREP_FILE_EXTENSION[] =  _T("exe");

static TCHAR* StrExecutableFiles;
static TCHAR* StrAllFiles;
static TCHAR g_szSysprepFileFilter[MAX_PATH + 1];

static TCHAR* StrSelectFileOrFolderToCopy = NULL;

//
//  Variables to pass data between the SetupIterateCabinet function and its callback
//
static TCHAR szFileSearchingFor[MAX_PATH + 1];
static TCHAR szDestinationPath[MAX_PATH + 1];
static BOOL bFileCopiedFromCab = FALSE;

#define SIZE_DEFAULT_OEM_TREE ( sizeof(DefaultOemTree) / sizeof(TCHAR*) )

//
// The below type is needed for WalkTreeAndAddItems() which walks the
// distribution folder and populates the tree-view at init time.
//
// In the case of the TempFiles key, it maps to distfold\$oem$.  When
// we look at the disk to populate this tree we must not recurse down
// into $$ $1 C D ...  We only want the remainder.
//
// In the case of System Drive, we must not recurse down $oem$\$1\drivers
// because those files should appear under the special key PnPDrivers.
//
// The other special keys are safe and use INIT_NORMAL when calling
// WalkTreeAndAddItems().
//

typedef enum {

    INIT_NORMAL,
    INIT_SYSDRIVE,
    INIT_TEMPFILES

} INIT_FLAG;


//
//  Keeps track of what product they had chosen when they last got to
//  this page.  It is initialized to NO_PREVIOUS_PRODUCT_CHOSEN because the
//  first time they get to this page they were never here before.  This is
//  used to determine if we should redraw the entire tree or not.  The tree
//  view is different for NT work/serv than it is for Sysprep.
//
#define NO_PREVIOUS_PRODUCT_CHOSEN -1

static INT g_iLastProductInstall = NO_PREVIOUS_PRODUCT_CHOSEN;


//---------------------------------------------------------------------------
//
//  This section of code is the support for queuing icons.
//
//  Notes:
//      - Currently, there is only support for queueing icons obtained
//        from the shell.  Some engineering will be required to add
//        fixed IDI_* icons onto the list.  Please delete this comment
//        if you do this work.
//
//      - None of the icon routines report errors to the user.  The caller
//        should do that if they want to report errors.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Function: FindCachedIcon
//
//  Purpose: This is a support routine for cacheing icons.  Don't call it,
//           use LoadShellIcon().
//
//           This function searches our global list of shell icon info
//           and returns a pointer to that node.  If we have not yet
//           cached info about this icon, this function creates the node.
//
//  Arguments:
//      HIMAGELIST hSysImageList - the system image list where icon resides
//      int        SysIdx        - index on the give list of icon
//
//  Returns:
//      Pointer to ICON_INFO node or NULL if out of memory
//
//---------------------------------------------------------------------------

ICON_INFO *FindCachedIcon(HIMAGELIST hSysImageList,
                          int        SysIdx)
{
    ICON_INFO *p = pHeadOfIconList;

    //
    // See if we've ever seen this icon before.  We detect uniqueness
    // by the imagelist,idx pair.
    //

    while ( p ) {
        if ( p->hSysImageList == hSysImageList && p->iSysIdx == SysIdx )
            break;
        p = p->next;
    }

    //
    // If we haven't cached any info about this icon yet, do so now
    //

    if ( ! p ) {

        if ( (p = malloc(sizeof(ICON_INFO))) == NULL )
            return NULL;

        p->hSysImageList = hSysImageList;
        p->iSysIdx       = SysIdx;
        p->iOurIdx       = gCurIconIdx++;
        p->hIcon         = ImageList_GetIcon(hSysImageList, SysIdx, 0);
        p->next          = pHeadOfIconList;
        pHeadOfIconList  = p;
    }

    return p;
}

//---------------------------------------------------------------------------
//
//  Function: LoadShellIcon
//
//  Purpose: Given the full pathname of a file or directory, this function
//           will query the shell and find out the icon associatted with
//           that file or directory.
//
//  Arguments:
//      LPTSTR lpPath     - full path of item
//      UINT   iWhichIcon - pass either SHGFI_SMALLICON or SHGFI_OPENICON
//
//  Notes:
//      - Since we only make 1 image list, this routine will only work
//        to query small icons (either the normal or the open).  It won't
//        work for icons that are not 16X16.
//
//---------------------------------------------------------------------------

int LoadShellIcon(LPTSTR lpPath, UINT iWhichIcon)
{
    SHFILEINFO  FileInfo;
    ICON_INFO  *pIconInfo;
    HIMAGELIST  hSysImageList;

    hSysImageList =
        (HIMAGELIST) SHGetFileInfo(lpPath,
                                   0,
                                   &FileInfo,
                                   sizeof(FileInfo),
                                   SHGFI_SYSICONINDEX | iWhichIcon);

    if ( hSysImageList == NULL )
        return -1;

    pIconInfo = FindCachedIcon(hSysImageList, FileInfo.iIcon);

    if ( pIconInfo == NULL )
        return -1;

    return pIconInfo->iOurIdx;
}

//---------------------------------------------------------------------------
//
//  Function: SetOurImageList
//
//  Purpose: Whenever more items have been added to the tree, this function
//           is called to update the icon list.
//
//  Arguments:
//      HWND hTv - Handle to the tree-view control
//
//  Returns:
//      void
//
//---------------------------------------------------------------------------

void SetOurImageList(HWND hTv)
{
    HIMAGELIST hNewImageList, hCurImageList;
    ICON_INFO  *p = pHeadOfIconList;
    int        i;

    //
    // Make the image list now that we know how big it needs to be.
    //

    hNewImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                     GetSystemMetrics(SM_CYSMICON),
                                     ILC_MASK,
                                     gCurIconIdx,
                                     0);

    if ( hNewImageList == NULL )
        return;

    //
    // Add a dummy icon in each spot.  This is necessary becase
    // ImageList_ReplaceIcon() will only work if an icon has already been
    // added to the offset in question.
    //

    if ( p == NULL )
        return;

    for ( i=0; i<gCurIconIdx; i++ )
        ImageList_AddIcon(hNewImageList, p->hIcon);

    //
    // Now walk our list of unique icons and put them at the correct
    // offset in the image_list.
    //
    // Note that when we walked the tree, LoadShellIcon() returned the
    // index that each tree-view entry should use for it's icons.  Thus,
    // we must ensure that the correct icon is at the correct offset
    // in the tree-view's image_list.
    //

    for ( p=pHeadOfIconList; p; p=p->next )
        ImageList_ReplaceIcon(hNewImageList, p->iOurIdx, p->hIcon);

    //
    // If there is an old image_list on the tree-view, free it first
    //

    if ( (hCurImageList = TreeView_GetImageList(hTv, TVSIL_NORMAL)) != NULL )
        ImageList_Destroy(hCurImageList);

    TreeView_SetImageList(hTv, hNewImageList, TVSIL_NORMAL);
}


//---------------------------------------------------------------------------
//
//  This section of code is some miscellaneous low-level support.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Function: InsertSingleItem
//
//  Purpose: Adds a single item to the tree view.  It will be a child
//           of the given hParentItem.
//
//           This function lives only to support UpdateTreeViewDisplay()
//           and should not be called otherwise.
//
//  Arguments:
//      HWND             hwnd         - current window
//      LPTSTR           lpItemName   - name to display
//      int              SmallIconIdx - idx into the image_list
//      int              OpenIconIdx  - idx into the image_list
//      SPECIAL_KEY_DATA *lpExtraData - data to keep on the tree-view item
//      HTREEITEM        hParentItem  - parent on the display
//
//  Returns:
//      HTREEITEM, NULL if it fails
//
//  Notes:
//      - pass NULL for lpExtraData unless it is one of our pre-defined
//        special keys.
//
//---------------------------------------------------------------------------

HTREEITEM InsertSingleItem(HWND             hwnd,
                           LPTSTR           lpItemName,
                           int              SmallIconIdx,
                           int              OpenIconIdx,
                           SPECIAL_KEY_DATA *lpExtraData,
                           HTREEITEM        hParentItem)
{
    HTREEITEM      hItem;
    TVINSERTSTRUCT TvInsert;
    UINT           ItemMask = TVIF_TEXT | TVIF_PARAM;

    if ( SmallIconIdx >= 0 )
    {
        ItemMask |= TVIF_IMAGE;
    }

    if ( OpenIconIdx >= 0 )
    {
        ItemMask |= TVIF_SELECTEDIMAGE;
    }

    TvInsert.hParent              = hParentItem;
    TvInsert.hInsertAfter         = TVI_LAST;
    TvInsert.item.mask            = ItemMask;
    TvInsert.item.pszText         = lpItemName;
    TvInsert.item.iImage          = SmallIconIdx;
    TvInsert.item.iSelectedImage  = OpenIconIdx;
    TvInsert.item.lParam          = (LPARAM) lpExtraData;

    hItem = TreeView_InsertItem(GetDlgItem(hwnd, IDC_FILETREE), &TvInsert);

    if ( hItem == NULL ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_ADDING_TVITEM);
    }

    return hItem;
}

//---------------------------------------------------------------------------
//
//  Function: GetItemlParam
//
//  Purpose: Gets the lParam off a tree-view item.  In this app, it is
//           null unless it's one of our special keys.
//
//  Arguments:
//      HWND      hTv
//      HTREEITEM hItem
//
//  Returns:
//      Value of the lParam.  In this app, it is SPECIAL_KEY_DATA*.  It
//      is generally null except for our few special keys.
//
//---------------------------------------------------------------------------

SPECIAL_KEY_DATA *GetItemlParam(HWND hTv, HTREEITEM hItem)
{
    TVITEM TvItem;

    TvItem.hItem = hItem;
    TvItem.mask  = TVIF_PARAM;

    if ( ! TreeView_GetItem(hTv, &TvItem) )
        return NULL;

    return (SPECIAL_KEY_DATA*) TvItem.lParam;
}

//---------------------------------------------------------------------------
//
//  Function: GetItemName
//
//  Purpose: Retrieves the display name of a tree-view item given its handle.
//
//  Arguments:
//      HWND      hTv
//      HTREEITEM hItem
//      LPTSTR    NameBuffer - output
//
//  Returns: BOOL - success
//
//---------------------------------------------------------------------------

BOOL GetItemName(HWND hTv, HTREEITEM hItem, LPTSTR NameBuffer)
{
    TVITEM TvItem;

    TvItem.hItem      = hItem;
    TvItem.mask       = TVIF_TEXT;
    TvItem.pszText    = NameBuffer;
    TvItem.cchTextMax = MAX_PATH;

    return TreeView_GetItem(hTv, &TvItem);
}

//---------------------------------------------------------------------------
//
//  Function: FindItemByName
//
//  Purpose: Searches the children of a given tree-view item and returns
//           a handle to the one with the given name.
//
//  Arguments:
//      HWND      hTv
//      HTREEITEM hItem
//      LPTSTR    lpName
//
//  Returns:
//      HTREEITEM, null if not found
//
//---------------------------------------------------------------------------

HTREEITEM FindItemByName(HWND      hTv,
                         HTREEITEM hItem,
                         LPTSTR    lpName)
{
    HTREEITEM hChildItem;
    TCHAR     NameBuffer[MAX_PATH];

    hChildItem = TreeView_GetChild(hTv, hItem);

    while ( hChildItem != NULL ) {

        if ( ! GetItemName(hTv, hChildItem, NameBuffer) )
            return NULL;

        if ( lstrcmpi(NameBuffer, lpName) == 0 )
            break;

        hChildItem = TreeView_GetNextSibling(hTv, hChildItem);
    }

    return hChildItem;
}



//
// The below functions build the on-disk pathname for each of our special
// root names.
//
// SysDrive    maps to $oem$\$1
// SysDir      maps to $oem$\$$
// OtherDrives maps to $oem$\%c         (where %c is a fixed drive letter)
// PnpDrivers  maps to $oem$\$1\drivers
// TempFiles   maps to $oem$            (and must skip $$, $1, etc)
//

//----------------------------------------------------------------------------
//
// Function: MakeSysprepSetupFilesPath
//
// Purpose: Computes the path to where sysprep.exe and setupcl.exe are to be
//          copied.
//
// Arguments: TCHAR* szSysprepPath - returns the sysprep path, assumed to be
//       able to hold MAX_PATH chars
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
MakeSysprepSetupFilesPath( TCHAR* szSysprepPath )
{

    if (0 == ExpandEnvironmentStrings( _T("%SystemDrive%"),
                                       szSysprepPath,
                                       MAX_PATH ))
    {
        TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);
    }

    lstrcatn( szSysprepPath, _T("\\sysprep"), MAX_PATH );

}

//----------------------------------------------------------------------------
//
// Function: MakeSysprepPath
//
// Purpose: Computes the path to where the language files for sysprep are to
//          be copied.
//
// Arguments: TCHAR* szSysprepPath - returns the sysprep path
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeSysprepPath( TCHAR* szSysprepPath )
{

    MakeSysprepSetupFilesPath( szSysprepPath );

    lstrcatn( szSysprepPath, _T("\\i386"), MAX_PATH );

}

//----------------------------------------------------------------------------
//
// Function: MakeTempFilesName
//
// Purpose: Computes the path to where the temp files are to be copied.
//
// Arguments: TCHAR* Buffer - returns the temp files path
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeTempFilesName( TCHAR* Buffer )
{

    lstrcpyn( Buffer, 
             WizGlobals.OemFilesPath, AS(Buffer) );

}

//----------------------------------------------------------------------------
//
// Function: MakePnpDriversName
//
// Purpose: Computes the path to where the Plug and Play drivers are to be
//          copied.
//
// Arguments: TCHAR* Buffer - returns the path to where the PnP files go
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakePnpDriversName( TCHAR* Buffer )
{
    HRESULT hrPrintf;

    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {

        ExpandEnvironmentStrings( _T("%SystemDrive%"),
                                  Buffer,
                                  MAX_PATH );

        lstrcatn( Buffer, _T("\\drivers"), MAX_PATH );

    }
    else
    {
        hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
                  _T("%s\\$1\\drivers"),
                  WizGlobals.OemFilesPath );
    }

}

//----------------------------------------------------------------------------
//
// Function: MakeOemRootName
//
// Purpose: Computes the path to where the OEM files are to be copied.
//
// Arguments: TCHAR* Buffer - returns the path to where the OEM files go
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeOemRootName( TCHAR* Buffer )
{
    lstrcpyn( Buffer,
             WizGlobals.OemFilesPath, AS(Buffer) );
}

//----------------------------------------------------------------------------
//
// Function: MakeSysDriveName
//
// Purpose: Computes the path to the System drive files are to be copied
//
// Arguments: TCHAR* Buffer - returns the path to the where the System drive
//                            files are to be copied.
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeSysDriveName( TCHAR* Buffer )
{
    HRESULT hrPrintf;

    hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
              _T("%s\\$1"),
              WizGlobals.OemFilesPath );

}

//----------------------------------------------------------------------------
//
// Function: MakeSysDirName
//
// Purpose: Computes the path to the System Directory files are to be copied
//
// Arguments: TCHAR* Buffer - returns the path to the where the System
//                            Directory files are to be copied.
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeSysDirName( TCHAR* Buffer )
{
    HRESULT hrPrintf;

    hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
              _T("%s\\$$"),
              WizGlobals.OemFilesPath );

}

//----------------------------------------------------------------------------
//
// Function: MakeOtherDriveName
//
// Purpose: Computes the path to the Other Drive files are to be copied
//
// Arguments: TCHAR* Buffer - returns the path to the where the Other
//                            Drive files are to be copied.
//            TCHAR  c - the drive we are making the path for
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeOtherDriveName( TCHAR* Buffer, TCHAR c )
{
    HRESULT hrPrintf;

    hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
              c ? _T("%s\\%c") : _T("%s"),
              WizGlobals.OemFilesPath, c );

}

//----------------------------------------------------------------------------
//
// Function: MakeLangFilesName
//
// Purpose: Computes the path to where the language files are to be copied.
//
// Arguments: TCHAR* Buffer - returns the path to where the language files go
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeLangFilesName( TCHAR* Buffer )
{

    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {

        MakeSysprepPath( Buffer );

    }
    else
    {
        lstrcpyn( Buffer,
                 WizGlobals.OemFilesPath, AS(Buffer) );
    }

}

//----------------------------------------------------------------------------
//
// Function: MakeSysprepLangFilesGroupName
//
// Purpose: Computes the path to where the language dirs are to be copied for
//          the language groups.
//
// Arguments: TCHAR* Buffer - returns the path to where the language files go
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeSysprepLangFilesGroupName( TCHAR* Buffer )
{

    MakeSysprepPath( Buffer );

    lstrcatn( Buffer, _T("\\lang"), MAX_PATH );

}

//----------------------------------------------------------------------------
//
// Function: MakeTextmodeFilesName
//
// Purpose: Computes the path to where the OEM boot files are to be copied
//
// Arguments: TCHAR* Buffer - returns the path to the where the textmode
//                            (HAL and SCSI) files are to be copied.
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
MakeTextmodeFilesName( TCHAR* Buffer )
{
    HRESULT hrPrintf;

    hrPrintf=StringCchPrintf( Buffer, AS(Buffer),
              _T("%s\\Textmode"),
              WizGlobals.OemFilesPath );

}


//----------------------------------------------------------------------------
//
//  This section of code is for WM_INIT
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: CreateSkeletonOemTree
//
//  Purpose: This function creates a skeleton OEM tree.  The directories
//           created are based on the global array DefaultOemTree[].
//
//           If the tree already exists, this function becomes a no-op.
//
//           This is called at init-time and is a support routine for
//           the OnInit() routine.  Don't call it otherwise.
//
//  Returns:
//      TRUE  - no errors, proceed
//      FALSE - errors making tree
//
//  Notes:
//      - Errors are reported to the user.
//
//----------------------------------------------------------------------------

BOOL CreateSkeletonOemTree(HWND hwnd)
{
    int i;
    TCHAR PathBuffer[MAX_PATH];

    //
    // Ensure the $oem$ dir exists
    //

    if ( ! EnsureDirExists(WizGlobals.OemFilesPath) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERR_CREATE_FOLDER,
                      WizGlobals.OemFilesPath);

        return FALSE;
    }

    //
    // Now make all of the default sub-dirs in the $oem$ tree if it is not
    // a sysprep
    //

    if( WizGlobals.iProductInstall != PRODUCT_SYSPREP )
    {

        for ( i=0; i<SIZE_DEFAULT_OEM_TREE; i++ )
        {

            lstrcpyn(PathBuffer, WizGlobals.OemFilesPath, AS(PathBuffer));

            ConcatenatePaths(PathBuffer, DefaultOemTree[i], NULL);

            if ( ! EnsureDirExists(PathBuffer) )
            {
                ReportErrorId(hwnd,
                              MSGTYPE_ERR | MSGTYPE_WIN32,
                              IDS_ERR_CREATE_FOLDER,
                              PathBuffer);
                return FALSE;
            }
        }

    }

    return( TRUE );
}

//---------------------------------------------------------------------------
//
//  Function: WalkTreeAndAddItems
//
//  Purpose: This function walks a tree on the disk and inserts each
//           dirent and file found into the tree-view display.
//
//           The directory tree will become a child of the given tree-view
//           item as hParent.
//
//           This function supports OnInitAddDirs() and should not be
//           called otherwise.
//
//  Arguments:
//      HWND      hwnd       - parent window
//      LPTSTR    RootBuffer - tree to recurse down
//      HTREEITEM hParent    - the parent tree view item
//      BOOL      bTempFiles - special case for "Temp Files"
//
//  Returns: VOID
//
//  Notes:
//
//  - RootBuffer must be MAX_PATH wide.
//
//  - Any paths that this routine encounters that are >= MAX_PATH in
//    length are silently skipped.
//
//  - Always pass bTempFiles=FALSE except when filling in the TempFiles
//    root in the tree-view.  TempFiles maps to $oem$ on disk, but the
//    other special locations are sub-dirs of this.  Thus, this findfirst/
//    findnext loop must skip those special cases ($1, $$, etc...)
//
//---------------------------------------------------------------------------

VOID WalkTreeAndAddItems(HWND      hwnd,
                         LPTSTR    RootBuffer,
                         HTREEITEM hParent,
                         INIT_FLAG iInitFlag)
{
    LPTSTR          RootPathEnd = RootBuffer + lstrlen(RootBuffer);
    HANDLE          FindHandle;
    WIN32_FIND_DATA FindData;
    HTREEITEM       hItem;
    int             iSmallIcon;
    int             iOpenIcon;
    TCHAR           szOriginalPath[MAX_PATH]  = _T("");

    //
    //  Backup the original path so it can be restored later
    //
    lstrcpyn( szOriginalPath, RootBuffer, AS(szOriginalPath) );

    //
    // Look for * in this dir
    //

    if ( ! ConcatenatePaths(RootBuffer, _T("*"), NULL) ) {

        //
        //  Restore the original path before returning
        //
        lstrcpyn( RootBuffer, szOriginalPath, AS(RootBuffer) );

        return;
    }

    FindHandle = FindFirstFile(RootBuffer, &FindData);
    if ( FindHandle == INVALID_HANDLE_VALUE ) {

        //
        //  Restore the original path before returning
        //
        lstrcpyn( RootBuffer, szOriginalPath, AS(RootBuffer) );

        return;
    }

    do {

        *RootPathEnd = _T('\0');

        //
        // skip over the . and .. entries
        //

        if (0 == lstrcmp(FindData.cFileName, _T(".")) ||
            0 == lstrcmp(FindData.cFileName, _T("..")))
            continue;

        //
        // TempFiles maps to %distfold%\$oem$, but the others map to a
        // sub-directory of $oem$, (e.g. SysDrive maps to $oem$\$1).
        //
        // By definition, TempFiles is anything under $oem$ that is not
        // a special name.  So, in the case that we are building the
        // Temporary Files tree, be sure we don't recurse down into a
        // special $oem$ sub-dir.
        //
        // Note that we do this check based on fully qualified pathnames
        // else comparisons would be ambiguous.
        //

        if ( iInitFlag == INIT_TEMPFILES ) {

            TCHAR Buffer1[MAX_PATH], Buffer2[MAX_PATH], c;
            BOOL  bContinue;

            lstrcpyn(Buffer1, RootBuffer, AS(RootBuffer));
            if ( ! ConcatenatePaths(Buffer1, FindData.cFileName, NULL) )
                continue;

            //
            // skip %distfold%\$oem$\$1
            //

            MakeSysDriveName(Buffer2);
            if ( _wcsicmp(Buffer1, Buffer2) == 0 )
                continue;

            //
            // skip %distfold%\$oem$\$$
            //

            MakeSysDirName(Buffer2);
            if ( _wcsicmp(Buffer1, Buffer2) == 0 )
                continue;

            //
            // skip %distfold%\$oem$\textmode
            //

            MakeTextmodeFilesName(Buffer2);
            if ( _wcsicmp(Buffer1, Buffer2) == 0 )
                continue;

            //
            // skip %distfold%\$oem$\%c where %c is any drive letter
            //

            for ( bContinue=FALSE, c=_T('A'); c<=_T('Z'); c++ ) {
                MakeOtherDriveName(Buffer2, c);
                if ( _wcsicmp(Buffer1, Buffer2) == 0 ) {
                    bContinue = TRUE;
                    break;
                }
            }
            if ( bContinue )
                continue;
        }

        //
        // The other special case is SYSDRIVE which maps to $oem$\$1.
        //
        // Whe must skip $oem$\$1\drivers because that is the root for the
        // special key PnPDrivers.
        //

        else if ( iInitFlag == INIT_SYSDRIVE ) {

            TCHAR Buffer1[MAX_PATH], Buffer2[MAX_PATH];

            lstrcpyn(Buffer1, RootBuffer, AS(RootBuffer));
            if ( ! ConcatenatePaths(Buffer1, FindData.cFileName, NULL) )
                continue;

            //
            // Skip %distfold%\$oem$\$1\drivers
            //

            MakePnpDriversName(Buffer2);
            if ( _wcsicmp(Buffer1, Buffer2) == 0 )
                continue;
        }

        //
        // Build the full pathname, if >= MAX_PATH, skip it
        //

        if ( ! ConcatenatePaths(RootBuffer, FindData.cFileName, NULL) )
            continue;

        //
        // Get the shell icons associated with this file/dir
        //

        iSmallIcon = LoadShellIcon(RootBuffer, SHGFI_SMALLICON);
        iOpenIcon  = LoadShellIcon(RootBuffer, SHGFI_OPENICON);

        //
        // Add this item as a child of the given parent.
        //

        if ( (hItem = InsertSingleItem(hwnd,
                                       FindData.cFileName,
                                       iSmallIcon,
                                       iOpenIcon,
                                       NULL,
                                       hParent)) == NULL ) {
            continue;
        }

        //
        // If this is a dirent, recurse.
        //

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            WalkTreeAndAddItems(hwnd, RootBuffer, hItem, iInitFlag);

    } while ( FindNextFile(FindHandle, &FindData) );

    *RootPathEnd = _T('\0');
    FindClose(FindHandle);

    //
    //  Restore the original path
    //
    lstrcpyn( RootBuffer, szOriginalPath, AS(RootBuffer) );

}

//---------------------------------------------------------------------------
//
//  Function: OnInitAddDirs
//
//  Purpose: Called before the dialog first displays.  We ensure that
//           OemFilesPath and OemPnpDriversPath have good defaults and
//           that the skeleton OEM tree exists.
//
//---------------------------------------------------------------------------

VOID OnInitAddDirs(HWND hwnd)
{
   HRESULT hrPrintf;

    //
    // Create the $oem$, $oem$\$1, etc in %distfold%
    //
    // If there's any errors creating this skeleton distfolder tree, it's
    // hopeless.  CreateSkeletonOemTree() already reported an error, skip
    // this page.
    //

    //
    // ISSUE-2002/02/28-stelo- The fact that the user gets this error before we even
    //         initialize means there is no good context.  Currently,
    //         the error message is generic.
    //
    //         Go down this path by connecting to a share that you
    //         only have read access to.  This is a good edit scenario.
    //         OemFilesPath should get computed.  User could select
    //         Oem Branding files directly from a read-only dist folder.
    //         In that case, I think we no-op the copy.
    //
    //         It must be tested what EnsureDirExists() does in this
    //         context.
    //

    if ( ! CreateSkeletonOemTree(hwnd) ) {
        return;
    }

    //
    // Load the hard-coded special root names that you see initially
    // on the tree-view and their descriptions
    //

    StrOemRootName       = MyLoadString( IDS_OEMROOT_NAME      );
    StrSysDriveName      = MyLoadString( IDS_SYSDRIVE_NAME     );
    StrSysDirName        = MyLoadString( IDS_SYSDIR_NAME       );
    StrOtherDrivesName   = MyLoadString( IDS_OTHERDRIVES_NAME  );
    StrPnpDriversName    = MyLoadString( IDS_PNPDRIVERS_NAME   );
    StrTempFilesName     = MyLoadString( IDS_TEMPFILES_NAME    );
    StrSysprepFilesName  = MyLoadString( IDS_SYSPREPFILES_NAME );
    StrTextmodeFilesName = MyLoadString( IDS_TEXTMODE_NAME     );

    gOemRootData.Description      = MyLoadString( IDS_ADD_DESCR_ROOT     );
    gSysDriveData.Description     = MyLoadString( IDS_ADD_DESCR_SYSDRIVE );
    gSysDirData.Description       = MyLoadString( IDS_ADD_DESCR_WINNT    );
    gOtherDrivesData.Description  = MyLoadString( IDS_ADD_DESCR_OTHER    );
    gPnpDriversData.Description   = MyLoadString( IDS_ADD_DESCR_PNP      );
    gTempFilesData.Description    = MyLoadString( IDS_ADD_DESCR_TEMP     );
    gSysprepData.Description      = MyLoadString( IDS_ADD_DESCR_SYSPREP  );
    gTextmodeData.Description     = MyLoadString( IDS_ADD_DESCR_TEXTMODE );

    //
    // Compute the on-disk path names for each of our special keys.
    //

    MakeOemRootName( gOemRootData.OnDiskPathName );
    MakeSysDriveName( gSysDriveData.OnDiskPathName );
    MakeSysDirName( gSysDirData.OnDiskPathName );
    MakeOtherDriveName( gOtherDrivesData.OnDiskPathName, _T('\0') );


    //
    //  Load and tweak the browse strings
    //

    StrExecutableFiles = MyLoadString( IDS_EXECUTABLE_FILES );
    StrAllFiles = MyLoadString( IDS_ALL_FILES );

    //
    //  The question marks (?) are just placehoders for where the NULL char
    //  will be inserted.
    //

    hrPrintf=StringCchPrintf( g_szSysprepFileFilter, AS(g_szSysprepFileFilter),
               _T("%s (*.exe)?*.exe?%s (*.*)?*.*?"),
               StrExecutableFiles,
               StrAllFiles );

    ConvertQuestionsToNull( g_szSysprepFileFilter );

    //
    //  ISSUE-2002/02/28-stelo- leave this comment in, but move it to a more appropriate place
    //
    // Currently, all of our special keys use the shell folder icon
    // and the shell open_folder icon.  So load these icons now and
    // use the same idx for all of the special keys.
    //
    // Note that if we make our own IDI_* for these special keys,
    // you'll have to write a new routine in the icon_queing support
    // to load an IDI_ and you'll need to fiddle with the icon_info
    // type and call the new routine from here.  You'll need to fix
    // these comments too, (unless you're too much of a wimp to
    // delete things that should be deleted).
    //
    
}

//---------------------------------------------------------------------------
//
//  Function: DrawSysprepTreeView
//
//  Purpose:
//
//  Arguments:  HWND hwnd - handle to the dialog box
//
//  Returns: VOID
//
//
//---------------------------------------------------------------------------
VOID
DrawSysprepTreeView( IN HWND hwnd )
{

    HWND  hTv = GetDlgItem(hwnd, IDC_FILETREE);
    TCHAR c;
    INT iSmallIcon;
    INT iOpenIcon;
    TCHAR szLangFilesPath[MAX_PATH + 1];

    HTREEITEM hRoot,
              hPnpDrivers,
              hSysprepFiles,
              hLangFiles;

    //
    //  Delete the old tree so we can build it up fresh
    //
    TreeView_DeleteAllItems( hTv );

    //
    // Compute the on-disk path names for the special keys that change on
    // a sysprep tree view.
    //

    MakePnpDriversName(gPnpDriversData.OnDiskPathName);
    MakeSysprepSetupFilesPath(gSysprepData.OnDiskPathName);
    MakeSysprepLangFilesGroupName(szLangFilesPath);

    //
    //  Make sure the language files dir gets created
    //

    EnsureDirExists( szLangFilesPath );

    iSmallIcon = LoadShellIcon(gOemRootData.OnDiskPathName, SHGFI_SMALLICON);
    iOpenIcon  = LoadShellIcon(gOemRootData.OnDiskPathName, SHGFI_OPENICON);

    //
    //  The drivers dir is outside the rest of the tree so ensure it gets
    //  created here.
    //
    EnsureDirExists( gPnpDriversData.OnDiskPathName );

    //
    // Insert each of our special locations into the tree-view.
    //

    hRoot         = InsertSingleItem(hwnd,
                                     StrOemRootName,
                                     iSmallIcon,
                                     iOpenIcon,
                                     &gOemRootData,
                                     TVI_ROOT);

    hPnpDrivers   = InsertSingleItem(hwnd,
                                     StrPnpDriversName,
                                     iSmallIcon,
                                     iOpenIcon,
                                     &gPnpDriversData,
                                     hRoot);

    hSysprepFiles = InsertSingleItem(hwnd,
                                     StrSysprepFilesName,
                                     iSmallIcon,
                                     iOpenIcon,
                                     &gSysprepData,
                                     hRoot);


    //
    // Now go out and read from the disk and populate each of these
    // special trees.
    //
    // Note that there is nothing but special keys under OEM_ROOT,
    // so there is no tree walking to do for OEM_ROOT, we've already
    // added all of it's children above.
    //

    WalkTreeAndAddItems(hwnd,
                        gPnpDriversData.OnDiskPathName,
                        hPnpDrivers,
                        INIT_NORMAL);

    WalkTreeAndAddItems(hwnd,
                        gSysprepData.OnDiskPathName,
                        hSysprepFiles,
                        INIT_TEMPFILES);

    //
    // Set the imagelist (the icons on the tree-view)
    //

    SetOurImageList(GetDlgItem(hwnd, IDC_FILETREE));

    //
    // All buttons are grey to start with
    //

    EnableWindow(GetDlgItem(hwnd, IDC_REMOVEFILE), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_ADDFILE),    FALSE);

    //
    // Expand our special keys
    //

    TreeView_Expand(hTv, hRoot, TVE_EXPAND);

}

//---------------------------------------------------------------------------
//
//  Function: DrawStandardTreeView
//
//  Purpose:
//
//  Arguments:  HWND hwnd - handle to the dialog box
//
//  Returns: VOID
//
//
//---------------------------------------------------------------------------
VOID
DrawStandardTreeView( IN HWND hwnd )
{

    HWND  hTv = GetDlgItem(hwnd, IDC_FILETREE);
    TCHAR c;
    INT iSmallIcon;
    INT iOpenIcon;

    HTREEITEM hRoot,
              hSysDrive,
              hSysDir,
              hOtherDrives,
              hPnpDrivers,
              hTempFiles,
              hTextmodeFiles;

    //
    //  Delete the old tree so we can build it up fresh
    //
    TreeView_DeleteAllItems( hTv );

    //
    // Compute the on-disk path names for the special keys that change on
    // a standard tree view.
    //

    MakePnpDriversName(gPnpDriversData.OnDiskPathName);
    MakeTempFilesName(gTempFilesData.OnDiskPathName);
    MakeTextmodeFilesName(gTextmodeData.OnDiskPathName);

    iSmallIcon = LoadShellIcon(gOemRootData.OnDiskPathName, SHGFI_SMALLICON);
    iOpenIcon  = LoadShellIcon(gOemRootData.OnDiskPathName, SHGFI_OPENICON);

    //
    // Insert each of our special locations into the tree-view.
    //

    hRoot        = InsertSingleItem(hwnd,
                                    StrOemRootName,
                                    iSmallIcon,
                                    iOpenIcon,
                                    &gOemRootData,
                                    TVI_ROOT);

    hSysDrive    = InsertSingleItem(hwnd,
                                    StrSysDriveName,
                                    iSmallIcon,
                                    iOpenIcon,
                                    &gSysDriveData,
                                    hRoot);

    hSysDir      = InsertSingleItem(hwnd,
                                    StrSysDirName,
                                    iSmallIcon,
                                    iOpenIcon,
                                    &gSysDirData,
                                    hSysDrive);

    hOtherDrives = InsertSingleItem(hwnd,
                                    StrOtherDrivesName,
                                    iSmallIcon,
                                    iOpenIcon,
                                    &gOtherDrivesData,
                                    hRoot);

    hPnpDrivers  = InsertSingleItem(hwnd,
                                    StrPnpDriversName,
                                    iSmallIcon,
                                    iOpenIcon,
                                    &gPnpDriversData,
                                    hSysDrive);

    hTempFiles   = InsertSingleItem(hwnd,
                                    StrTempFilesName,
                                    iSmallIcon,
                                    iOpenIcon,
                                    &gTempFilesData,
                                    hRoot);

    hTextmodeFiles = InsertSingleItem(hwnd,
                                      StrTextmodeFilesName,
                                      iSmallIcon,
                                      iOpenIcon,
                                      &gTextmodeData,
                                      hTempFiles);

    //
    // Now go out and read from the disk and populate each of these
    // special trees.
    //
    // Note that there is nothing but special keys under OEM_ROOT,
    // so there is no tree walking to do for OEM_ROOT, we've already
    // added all of it's children above.
    //

    WalkTreeAndAddItems(hwnd,
                        gSysDriveData.OnDiskPathName,
                        hSysDrive,
                        INIT_SYSDRIVE);

    WalkTreeAndAddItems(hwnd,
                        gSysDirData.OnDiskPathName,
                        hSysDir,
                        INIT_NORMAL);

    for ( c=_T('A'); c<=_T('Z'); c++ ) {

        HTREEITEM hDrive;
        TCHAR     DriveLetterBuff[2];
        TCHAR     PathBuffer[MAX_PATH];
        HRESULT hrPrintf;

        MakeOtherDriveName(PathBuffer, c);

        if ( DoesFolderExist(PathBuffer) ) {

            hrPrintf=StringCchPrintf(DriveLetterBuff,AS(DriveLetterBuff), _T("%c"), c);

            hDrive = InsertSingleItem(hwnd,
                                      DriveLetterBuff,
                                      iSmallIcon,
                                      iOpenIcon,
                                      NULL,
                                      hOtherDrives);
            WalkTreeAndAddItems(hwnd,
                                PathBuffer,
                                hDrive,
                                INIT_NORMAL);
        }
    }

    WalkTreeAndAddItems(hwnd,
                        gPnpDriversData.OnDiskPathName,
                        hPnpDrivers,
                        INIT_NORMAL);

    WalkTreeAndAddItems(hwnd,
                        gTempFilesData.OnDiskPathName,
                        hTempFiles,
                        INIT_TEMPFILES);

    WalkTreeAndAddItems(hwnd,
                        gTextmodeData.OnDiskPathName,
                        hTextmodeFiles,
                        INIT_TEMPFILES);

    //
    // Set the imagelist (the icons on the tree-view)
    //

    SetOurImageList(GetDlgItem(hwnd, IDC_FILETREE));

    //
    // All buttons are grey to start with
    //

    EnableWindow(GetDlgItem(hwnd, IDC_REMOVEFILE), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_ADDFILE),    FALSE);

    //
    // Expand our special keys
    //

    TreeView_Expand(hTv, hRoot, TVE_EXPAND);

}

//---------------------------------------------------------------------------
//
//  Function: OnSetActiveAddDirs
//
//  Purpose:  Determines if the tree view needs to be redrawn and if it does,
//     redraws it.
//
//  Arguments: HWND hwnd - handle to the dialog box
//
//  Returns: VOID
//
//---------------------------------------------------------------------------
VOID
OnSetActiveAddDirs( IN HWND hwnd )
{

    if( g_iLastProductInstall == NO_PREVIOUS_PRODUCT_CHOSEN )
    {
        //
        //  This is their first time seeing this page, so draw the approprate
        //  tree view.
        //

        if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
        {
            DrawSysprepTreeView( hwnd );
        }
        else
        {
            DrawStandardTreeView( hwnd );
        }

    }
    else if( g_iLastProductInstall == PRODUCT_SYSPREP && WizGlobals.iProductInstall != PRODUCT_SYSPREP )
    {

        DrawStandardTreeView( hwnd );

    }
    else if( g_iLastProductInstall != PRODUCT_SYSPREP && WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {

        DrawSysprepTreeView( hwnd );

    }

    g_iLastProductInstall = WizGlobals.iProductInstall;

}


//----------------------------------------------------------------------------
//
//  This section of code implements OnTreeViewSelectionChange() which
//  is called whenever the user selects a different tree-view item.
//
//  On this event, we query the currently selected tree-view item and
//  do some processing to figure out where this tree-view item maps to
//  on disk storage.  Once we figure out all we want to know about the
//  current selection, we update all of the fields of gCurSel.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: ComputeFullPathOfItem
//
//  Purpose: We continually query the parent of the given tree view item
//           until we get to one of our specially defined roots.  Then
//           we fill in the buffer with the full path name of where
//           to copy files to.
//
//           This function supports OnTreeViewSelectionChange() and should
//           not be called otherwise.  That is, we only did this processing
//           when the user picks a new destination.  We scribble the info
//           we might need later into globals.
//
//  Arguments:
//      HTREEITEM hItem      - handle to tree item
//      LPTSTR    PathBuffer - output, caller must pass a MAX_PATH buffer
//      SPECIAL_KEY_DATA **SpecialRoot - output
//
//  Returns: VOID
//
//  Notes:
//      - check PathBuffer[0] == _T('\0') for success
//
//----------------------------------------------------------------------------

VOID
ComputeFullPathOfItem(IN  HWND               hwnd,
                      IN  HTREEITEM          hItem,
                      OUT LPTSTR             PathBuffer,
                      OUT SPECIAL_KEY_DATA **pSpecialRoot)
{
    TVITEM           TvItemData;
    HTREEITEM        hParent;
    TCHAR            ItemName[MAX_PATH], TempBuffer[MAX_PATH];
    int              NumCharsReplace;
    SPECIAL_KEY_DATA *pSpecialKeyData;


    PathBuffer[0] = _T('\0');

    //
    // The TvItemData is used to query the name of the hItem.  We
    // receive the name in ItemName[].   Set the fields that won't
    // change in the loop.
    //

    TvItemData.mask       = TVIF_TEXT | TVIF_PARAM;
    TvItemData.pszText    = ItemName;
    TvItemData.cchTextMax = MAX_PATH;

    //
    // Now continually query the name of the parent and keep prefixing
    // the parent's name to build the on-disk pathname.  Stop when we
    // get to one of our special root keys.
    //
    // We detect hitting a special key because the lParam will be
    // non-null.  Once we get there, we know the on-disk prefix.
    //

    do {

        TvItemData.hItem = hItem;
        TreeView_GetItem(GetDlgItem(hwnd, IDC_FILETREE), &TvItemData);

        if ( TvItemData.lParam != (LPARAM) NULL )
            break;

        TempBuffer[0] = _T('\0');
        ConcatenatePaths(TempBuffer, ItemName, PathBuffer, NULL);
        lstrcpyn(PathBuffer, TempBuffer, AS(PathBuffer));

        hParent = TreeView_GetParent(GetDlgItem(hwnd, IDC_FILETREE), hItem);

        if ( hParent == NULL )
            break;

        hItem = hParent;

    } while ( TRUE );

    //
    // The final item queried in the above loop should have a non-null
    // lParam i.e. the loop should only terminate when it encounters
    // a special key.
    //

    pSpecialKeyData = (SPECIAL_KEY_DATA*) TvItemData.lParam;

    Assert(pSpecialKeyData != NULL);

    //
    // Prefix the disk path of our special root key onto the PathBuffer
    // we computed in the loop above.
    //

    TempBuffer[0] = _T('\0');
    ConcatenatePaths(TempBuffer,
                     pSpecialKeyData->OnDiskPathName,
                     PathBuffer,
                     NULL);
    lstrcpyn(PathBuffer, TempBuffer, AS(PathBuffer));

    //
    // Give the caller the address of the special key data.  This is how
    // caller knows what description to display on the ui
    //

    (*pSpecialRoot) = pSpecialKeyData;
}

//----------------------------------------------------------------------------
//
//  Function: OnTreeViewSelectionChange
//
//  Purpose: This function is called when the user changes the file/dir
//           selected on the tree-view.
//
//           We compute the full path of the tree-view item now selected
//           and update the global gCurSel.
//
//----------------------------------------------------------------------------

VOID OnTreeViewSelectionChange(HWND hwnd)
{
    HWND      hTv =  GetDlgItem(hwnd, IDC_FILETREE);

    TCHAR     PathBuffer[MAX_PATH], *pEnd;
    HTREEITEM hItem;
    DWORD     dwAttribs;
    LPTSTR    lpFileNamePart;
    BOOL      bEnableCopy;

    SPECIAL_KEY_DATA *pCurItemlParam,
                     *pCurFolderlParam;

    SPECIAL_KEY_DATA *RootSpecialData = NULL;

    //
    // Get the currently selected item and figure out the on-disk pathname
    // for it and figure out which of the 6 special roots this item is under
    // (RootSpecialData, that is).
    //

    hItem = TreeView_GetSelection(hTv);

    ComputeFullPathOfItem(hwnd, hItem, PathBuffer, &RootSpecialData);

    //
    // Save this info in the global gCurSel
    //

    gCurSel.hCurItem = hItem;
    lstrcpyn(gCurSel.lpCurItemPath, PathBuffer, AS(gCurSel.lpCurItemPath));

    //
    // If the CurItem is a directory, the CurFolder should be the same.
    // If the CurItem is a file, the CurFolder should be the parent.
    //
    // Copy & NewFolder goes into the CurFolder, deletes use the CurItem.
    //

    lstrcpyn(gCurSel.lpCurFolderPath, gCurSel.lpCurItemPath,AS(gCurSel.lpCurFolderPath));
    gCurSel.hCurFolderItem = gCurSel.hCurItem;

    if ( DoesFileExist(gCurSel.lpCurItemPath) ) {

        lpFileNamePart = MyGetFullPath(gCurSel.lpCurFolderPath);

        if ( lpFileNamePart == NULL || *(lpFileNamePart-1) != _T('\\') )
        {
            AssertMsg(FALSE,
                      "Could not parse filename.  This should not happen.");
            TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);
        }

        *(lpFileNamePart-1) = _T('\0');

        gCurSel.hCurFolderItem =
            TreeView_GetParent(hTv, gCurSel.hCurFolderItem);
    }

    //
    // Grey/ungrey the buttons.
    //
    // If an lParam is non-null, then it's one of our special keys.
    //
    // User cannot delete any special keys.
    //
    // User can copy, unless the current dest folder is KEY_OEMROOT or
    // KEY_OTHERDRIVES.
    //

    pCurItemlParam   = GetItemlParam(hTv, gCurSel.hCurItem);
    pCurFolderlParam = GetItemlParam(hTv, gCurSel.hCurFolderItem);

    EnableWindow(GetDlgItem(hwnd, IDC_REMOVEFILE), pCurItemlParam == NULL);

    bEnableCopy = ( pCurFolderlParam == NULL ||
                  ( pCurFolderlParam->iSpecialKeyId != KEY_OEMROOT &&
                    pCurFolderlParam->iSpecialKeyId != KEY_OTHERDRIVES) );

    EnableWindow(GetDlgItem(hwnd, IDC_ADDFILE), bEnableCopy);

    //
    // Set the description on the ui.
    //

    Assert(RootSpecialData != NULL);

    SetDlgItemText(hwnd, IDC_ADDDIRS_DESCR, RootSpecialData->Description);
}


//---------------------------------------------------------------------------
//
//  This section of code implements OnAddFileDir() which is called when
//  the user pushes the ADD button.  We have to allow the user to Browse
//  for the source file/dir, then do the copy/tree-copy and update the
//  tree-view display.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
//  Function: BrowseForSourceDir
//
//  Purpose: This function pulls up the SHBrowseForFolder dialog and allows
//           the user to select a directory to copy NT binaries into.
//
//  Arguments:
//      HWND   hwnd       - owning window
//      LPTSTR PathBuffer - MAX_PATH buffer to receive results
//
//  Returns: BOOL - TRUE if the user entered a path
//                  FALSE if the user canceled out of the dialog
//
//  Notes:
//
//---------------------------------------------------------------------------
BOOL
BrowseForSourceDir(HWND hwnd, LPTSTR PathBuffer)
{
    BROWSEINFO   BrowseInf;
    UINT         ulFlags = BIF_BROWSEINCLUDEFILES |
                           BIF_RETURNONLYFSDIRS |
                           BIF_EDITBOX;
    LPITEMIDLIST lpIdList;


    if( StrSelectFileOrFolderToCopy == NULL )
    {
        StrSelectFileOrFolderToCopy = MyLoadString( IDS_SELECT_FILE_OR_FOLDER );
    }

    //
    // ISSUE-2002/02/28-stelo-
    //  - No initial root, should go back where it was last time
    //  - Need a callback to grey out root of drive
    //

    //
    // Go browse
    //

    BrowseInf.hwndOwner      = hwnd;
    BrowseInf.pidlRoot       = NULL;                // root == desktop
    BrowseInf.pszDisplayName = PathBuffer;          // output (useless)
    BrowseInf.lpszTitle      = StrSelectFileOrFolderToCopy;
    BrowseInf.ulFlags        = ulFlags;
    BrowseInf.lpfn           = NULL;                // no callback
    BrowseInf.lParam         = (LPARAM) 0;          // no callback
    BrowseInf.iImage         = 0;                   // no image

    lpIdList = SHBrowseForFolder(&BrowseInf);

    //
    // Get the pathname out of this idlist returned and free up the memory
    //

    if ( lpIdList == NULL )
    {
        PathBuffer[0] = _T('\0');

        return( FALSE );
    }
    else
    {
        SHGetPathFromIDList(lpIdList, PathBuffer);
        MyGetFullPath(PathBuffer);
        ILFreePriv(lpIdList);

        return( TRUE );
    }
}

//----------------------------------------------------------------------------
//
//  Function: AdditionalDirsCopyTree
//
//  Purpose: Copies a directory tree to the given folder.  The tree-view
//           display is not updated or anything of the sort.  It simply
//           copies the tree.
//
//           This is a support routine for OnAddFileDir() and should
//           not be called otherwise.
//
//  Arguements:
//      HWND      hwnd           - owning window
//      LPTSTR    lpSource       - MAX_PATH buffer
//      LPTSTR    lpDest         - MAX_PATH buffer
//      LPTSTR    lpFileNamePart - if d:\foo\bar, this should be "bar"
//      HTREEITEM hParentItem    - parent item on the display
//
//  Returns: VOID
//
//  Notes:
//      - Both lpSource and lpDest must be directories, and each must
//        be a MAX_PATH buffer.
//
//      - Any paths >= MAX_PATH in length are silently skipped.
//
//      - lpFileNamePart can point to any buffer anywhere, it does not
//        have to point into lpSource or lpDest buffers.  It just has to
//        have the right data.
//
//----------------------------------------------------------------------------

VOID AdditionalDirsCopyTree(HWND      hwnd,
                            LPTSTR    lpSource,
                            LPTSTR    lpDest,
                            LPTSTR    lpFileNamePart,
                            HTREEITEM hParentItem)
{
    LPTSTR          SrcPathEnd  = lpSource + lstrlen(lpSource);
    LPTSTR          DestPathEnd = lpDest   + lstrlen(lpDest);
    HANDLE          FindHandle;
    WIN32_FIND_DATA FindData;
    int             iSmallIcon, iOpenIcon;
    HTREEITEM       hItem;

    //
    // Create the folder
    //

    if ( ! CreateDirectory(lpDest, NULL) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERR_CREATE_FOLDER,
                      lpDest);
        return;
    }

    //
    // Add the tree-view item for this folder
    //

    iSmallIcon = LoadShellIcon(lpSource, SHGFI_SMALLICON);
    iOpenIcon  = LoadShellIcon(lpSource, SHGFI_OPENICON);

    if ( (hItem = InsertSingleItem(hwnd,
                                   lpFileNamePart,
                                   iSmallIcon,
                                   iOpenIcon,
                                   NULL,
                                   hParentItem)) == NULL ) {
        return;
    }

    //
    // loop over lpSource\*
    //

    if ( ! ConcatenatePaths(lpSource, _T("*"), NULL) )
        return;

    FindHandle = FindFirstFile(lpSource, &FindData);
    if ( FindHandle == INVALID_HANDLE_VALUE )
        return;

    do {

        *SrcPathEnd  = _T('\0');
        *DestPathEnd = _T('\0');

        //
        // skip over the . and .. entries
        //

        if (0 == lstrcmp(FindData.cFileName, _T(".")) ||
            0 == lstrcmp(FindData.cFileName, _T("..")))
            continue;

        //
        // Build the new source and dest names
        //

        if ( ! ConcatenatePaths(lpSource, FindData.cFileName, NULL) ||
             ! ConcatenatePaths(lpDest, FindData.cFileName, NULL) )
            continue;

        //
        // If the source is a file, copy it.  If it's a directory, create
        // the directory at the destination and recurse.
        //

        if ( ! (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            if ( ! CopyFile(lpSource, lpDest, TRUE) ) {
                ReportErrorId(hwnd,
                              MSGTYPE_ERR | MSGTYPE_WIN32,
                              IDS_ERR_COPY_FILE,
                              lpSource, lpDest);
                continue;
            }

            SetFileAttributes(lpDest, FILE_ATTRIBUTE_NORMAL);

            //
            // Add the tree-view item for this file
            //

            iSmallIcon = LoadShellIcon(lpSource, SHGFI_SMALLICON);
            iOpenIcon  = LoadShellIcon(lpSource, SHGFI_OPENICON);

            if ( InsertSingleItem(hwnd,
                                  FindData.cFileName,
                                  iSmallIcon,
                                  iOpenIcon,
                                  NULL,
                                  hItem) == NULL ) {
                continue;
            }
        }

        else {

            AdditionalDirsCopyTree(hwnd,
                                   lpSource,
                                   lpDest,
                                   FindData.cFileName,
                                   hItem);
        }

    } while ( FindNextFile(FindHandle, &FindData) );

    *SrcPathEnd  = _T('\0');
    *DestPathEnd = _T('\0');
    FindClose(FindHandle);
}

//----------------------------------------------------------------------------
//
//  Function: OnAddFileDir
//
//  Purpose: This function is called when the AddFile button is pushed.
//
//  Arguments:
//      HWND hwnd - owning window
//
//  Returns: VOID
//
//----------------------------------------------------------------------------

VOID OnAddFileDir(HWND hwnd)
{
    TCHAR     SrcPathBuffer[MAX_PATH];
    TCHAR     DestPathBuffer[MAX_PATH];
    HTREEITEM hItem;
    TCHAR     *lpFileNamePart;
    BOOL      bSrcIsDir;

    //
    // Browse for the source path.  User can cancel on the source, so
    // be sure to check.
    //

    BrowseForSourceDir(hwnd, SrcPathBuffer);
    if ( SrcPathBuffer[0] == _T('\0') )
        return;

    //
    // Get the simple filename out of the src. e.g. d:\foo\bar, we want
    // the "bar".
    //
    // Note:
    //
    // If there's no "bar" there, then the user probably selected the
    // root of a drive (c:\ or d:\ etc.)  In that case we'll give a
    // generic stop message "Setup Manager cannot copy path %s".  We
    // can't assume in the error text that it was the root the user
    // tried to copy. (although I don't know of another cause, there
    // might be one).
    //
    // ISSUE-2002/02/28-stelo- Turn this into an assert when SHBrowseForFolder call is fixed.
    //

    lpFileNamePart = MyGetFullPath(SrcPathBuffer);

    if ( lpFileNamePart == NULL ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR,
                      IDS_ERR_CANNOT_COPY_PATH,
                      SrcPathBuffer);
        return;
    }

    //
    // We will always copy into the current folder, cat the simple name
    // of source onto the destination folder.
    //

    lstrcpyn(DestPathBuffer, gCurSel.lpCurFolderPath, AS(DestPathBuffer));
    if ( ! ConcatenatePaths(DestPathBuffer, lpFileNamePart, NULL) )
        return;

    //
    // Copy it
    //

    if ( DoesFolderExist(SrcPathBuffer) ) {
        AdditionalDirsCopyTree(hwnd,
                               SrcPathBuffer,
                               DestPathBuffer,
                               lpFileNamePart,
                               gCurSel.hCurFolderItem);
    }

    else {

        int iSmallIcon = LoadShellIcon(SrcPathBuffer, SHGFI_SMALLICON);
        int iOpenIcon  = LoadShellIcon(SrcPathBuffer, SHGFI_OPENICON);

        if ( ! CopyFile(SrcPathBuffer, DestPathBuffer, TRUE) ) {

            ReportErrorId(hwnd,
                          MSGTYPE_ERR | MSGTYPE_WIN32,
                          IDS_ERR_COPY_FILE,
                          SrcPathBuffer, DestPathBuffer);
            return;
        }

        SetFileAttributes(DestPathBuffer, FILE_ATTRIBUTE_NORMAL);

        if ( (hItem = InsertSingleItem(hwnd,
                                       lpFileNamePart,
                                       iSmallIcon,
                                       iOpenIcon,
                                       NULL,
                                       gCurSel.hCurFolderItem)) == NULL ) {
            return;
        }
    }

    //
    // We have to update the tree-view's image list because we added
    // files and we may have encountered icons we haven't seen before.
    //

    SetOurImageList(GetDlgItem(hwnd, IDC_FILETREE));
}


//----------------------------------------------------------------------------
//
//  This section of code implements OnRemoveFileDir() which is called
//  when the user pushes the REMOVE button.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: AddDirsDeleteNode
//
//  Purpose: Function to delete a node from a disk.  This function is
//           support for OnRemoveFileDir() and should not be called
//           otherwise.
//
//  Arguments:
//      HWND      hwnd           - owning window
//      LPTSTR    lpRoot         - fully qualified root path
//      LPTSTR    lpFileNamePart - if lpRoot==d:\foo\bar, pass "bar"
//      HTREEITEM hItem          - item for lpRoot
//
//  Returns:
//      VOID
//
//  Notes:
//      - lpRoot must be a buffer MAX_PATH wide
//      - Paths >= MAX_PATH in length are silently skipped
//
//----------------------------------------------------------------------------

VOID AddDirsDeleteNode(HWND      hwnd,
                       LPTSTR    lpRoot,
                       LPTSTR    lpFileNamePart,
                       HTREEITEM hItem)
{
    LPTSTR          lpRootEnd  = lpRoot + lstrlen(lpRoot);
    HWND            hTv = GetDlgItem(hwnd, IDC_FILETREE);
    HANDLE          FindHandle;
    WIN32_FIND_DATA FindData;
    HTREEITEM       hCurItem;

    //
    // loop over lpRoot\*
    //

    if ( ! ConcatenatePaths(lpRoot, _T("*"), NULL) )
        return;

    FindHandle = FindFirstFile(lpRoot, &FindData);
    if ( FindHandle == INVALID_HANDLE_VALUE )
        return;

    do {

        *lpRootEnd  = _T('\0');

        //
        // skip over the . and .. entries
        //

        if (0 == lstrcmp(FindData.cFileName, _T(".")) ||
            0 == lstrcmp(FindData.cFileName, _T("..")))
            continue;

        //
        // Build the new path name
        //

        if ( ! ConcatenatePaths(lpRoot, FindData.cFileName, NULL) )
            continue;

        //
        // Find the corresponding tree-view item for this file/dir
        //

        hCurItem = FindItemByName(hTv, hItem, FindData.cFileName);

        //
        // If the source is a file, delete it, else recurse.
        //

        if ( ! (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            if ( ! DeleteFile(lpRoot) ) {
                ReportErrorId(hwnd,
                              MSGTYPE_ERR | MSGTYPE_WIN32,
                              IDS_ERR_DELETE_FILE,
                              lpRoot);
                continue;
            }

            if ( hCurItem != NULL )
                TreeView_DeleteItem(hTv, hCurItem);
        }

        else {
            AddDirsDeleteNode(hwnd, lpRoot, FindData.cFileName, hCurItem);
        }

    } while ( FindNextFile(FindHandle, &FindData) );

    *lpRootEnd  = _T('\0');
    FindClose(FindHandle);

    //
    // Remove the root directory
    //

    if ( ! RemoveDirectory(lpRoot) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERR_DELETE_FOLDER,
                      lpRoot);
        return;
    }

    //
    // Only delete the tree-view entry if there are no children left.
    //
    // There could be children left in this dir because a DeleteFile()
    // could have failed on a recursive call.  e.g. a read-only file.
    //

    if ( TreeView_GetChild(hTv, hItem) == NULL )
        TreeView_DeleteItem(hTv, hItem);
}

//----------------------------------------------------------------------------
//
//  Function: OnRemoveFileDir
//
//  Purpose: This function is called when the RemoveFile button is pushed.
//
//----------------------------------------------------------------------------

VOID OnRemoveFileDir(HWND hwnd)
{
    LPTSTR    lpPath = gCurSel.lpCurItemPath;
    HTREEITEM hItem  = gCurSel.hCurItem;
    HWND      hTv    = GetDlgItem(hwnd, IDC_FILETREE);
    int       iRet;

    //
    // Look at the current selection, and delete the file or delete
    // the node.
    //

    if ( DoesFolderExist(lpPath) ) {

        iRet = ReportErrorId(hwnd,
                             MSGTYPE_YESNO,
                             IDS_DELETE_FOLDER_CONFIRM,
                             lpPath);

        if ( iRet == IDYES ) {
            AddDirsDeleteNode(hwnd,
                              lpPath,
                              MyGetFullPath(lpPath),
                              hItem);
        }
    }

    else {

        iRet = ReportErrorId(hwnd,
                             MSGTYPE_YESNO,
                             IDS_DELETE_FILE_CONFIRM,
                             lpPath);

        if ( iRet == IDYES ) {

            if ( ! DeleteFile(lpPath) ) {
                ReportErrorId(hwnd,
                              MSGTYPE_ERR | MSGTYPE_WIN32,
                              IDS_ERR_DELETE_FILE,
                              lpPath);
            }

            TreeView_DeleteItem(hTv, hItem);
        }
    }
}


//----------------------------------------------------------------------------
//
//  This section of code is for Sysprep functions
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Function: CopySysprepFileLow
//
// Purpose:  Copies one file to the destination specified.  Handles any errors
//   that occur during the copy.
//
// Arguments:
//   HWND hwnd - handle to the dialog box
//   TCHAR *szSysprepPathandFileNameSrc - path and file name of source file to copy
//   TCHAR *szSysprepPathandFileNameDest - path and file name of where to copy the file
//   TCHAR *szSysprepPath - the path to the sysprep dir
//   TCHAR *szDirectory - directory to begin the search for the file
//   TCHAR const * const szFileName - the file name to copy
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
CopySysprepFileLow( IN HWND   hwnd,
                    IN TCHAR *szSysprepPathandFileNameSrc,
                    IN TCHAR *szSysprepPathandFileNameDest,
                    IN TCHAR *szSysprepPath,
                    IN TCHAR *szDirectory,
                    IN TCHAR const * const szFileName )
{
    BOOL  bCopyRetVal = FALSE;
    INT   iRetVal;

    //
    //  Only do the copy if the file isn't already there
    //
    if( ! DoesFileExist( szSysprepPathandFileNameDest ) )
    {

        //
        //  If the file is in the current dir, just copy it,
        //  else prompt the user for the location
        //
        if( DoesFileExist( szSysprepPathandFileNameSrc ) )
        {

            bCopyRetVal = CopyFile( szSysprepPathandFileNameSrc,
                                    szSysprepPathandFileNameDest,
                                    TRUE );

        }
        else
        {

            BOOL bCopyCompleted = FALSE;

            do
            {

                ReportErrorId( hwnd,
                               MSGTYPE_ERR,
                               IDS_ERR_SPECIFY_FILE,
                               szFileName );

                iRetVal = ShowBrowseFolder( hwnd,
                                            g_szSysprepFileFilter,
                                            SYSPREP_FILE_EXTENSION,
                                            OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                                            szDirectory,
                                            szSysprepPathandFileNameSrc );

                if( ! iRetVal )
                {                // user pressed cancel on the Browse dialog
                    ReportErrorId( hwnd,
                                   MSGTYPE_ERR,
                                   IDS_ERR_UNABLE_TO_COPY_SYSPREP_FILE,
                                   szFileName,
                                   szSysprepPath );

                    break;
                }

                if( szSysprepPathandFileNameSrc && ( lstrcmpi( MyGetFullPath( szSysprepPathandFileNameSrc ), szFileName ) == 0 ) )
                {

                    bCopyRetVal = CopyFile( szSysprepPathandFileNameSrc,
                                            szSysprepPathandFileNameDest,
                                            TRUE );

                    bCopyCompleted = TRUE;

                }

            } while( ! bCopyCompleted );

        }

        if( ! bCopyRetVal && iRetVal )
        {

            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ERR_UNABLE_TO_COPY_SYSPREP_FILE,
                           szFileName,
                           szSysprepPath );

        }

        SetFileAttributes( szSysprepPathandFileNameDest,
                           FILE_ATTRIBUTE_NORMAL );
    }

}

//----------------------------------------------------------------------------
//
// Function: CopySysprepFiles
//
// Purpose:  Copies sysprep.exe and setupcl.exe to the sysprep dir on the
//   system drive.  Handles any errors that occur during the copy.
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
CopySysprepFiles( IN HWND hwnd )
{

    BOOL  bCancel;
    TCHAR szSysprepPath[MAX_PATH]                = _T("");
    TCHAR szCurrentDirectory[MAX_PATH+1]           = _T("");
    TCHAR szSysprepPathandFileNameSrc[MAX_PATH]  = _T("");
    TCHAR szSysprepPathandFileNameDest[MAX_PATH] = _T("");

    MakeSysprepSetupFilesPath( szSysprepPath );

    EnsureDirExists( szSysprepPath );

    // GetModuleFileName may not terminate path if path is truncated in the case
    // of the file spec using the //?/ format and exceeding MAX_PATH.  This should
    // never happen in our case, but we will make the check and NULL terminate
    if (GetModuleFileName( NULL, szCurrentDirectory, MAX_PATH) >= MAX_PATH)
    	 szCurrentDirectory[MAX_PATH]='\0';

    //
    //  Copy sysprep.exe to the sysprep dir
    //

    ConcatenatePaths( szSysprepPathandFileNameSrc,
                      szCurrentDirectory,
                      SYSPREP_EXE,
                      NULL );

    ConcatenatePaths( szSysprepPathandFileNameDest,
                      szSysprepPath,
                      SYSPREP_EXE,
                      NULL );

    CopySysprepFileLow( hwnd,
                        szSysprepPathandFileNameSrc,
                        szSysprepPathandFileNameDest,
                        szSysprepPath,
                        szCurrentDirectory,
                        SYSPREP_EXE );

    //
    //  Store the path where the 1st file was found
    //

    GetPathFromPathAndFilename( szSysprepPathandFileNameSrc,
                                szCurrentDirectory,
                                AS(szCurrentDirectory));

    //
    //  Copy setupcl.exe to the sysprep dir
    //

    szSysprepPathandFileNameSrc[0]  =  _T('\0');
    szSysprepPathandFileNameDest[0] =  _T('\0');

    ConcatenatePaths( szSysprepPathandFileNameSrc,
                      szCurrentDirectory,
                      SETUPCL_EXE,
                      NULL );

    ConcatenatePaths( szSysprepPathandFileNameDest,
                      szSysprepPath,
                      SETUPCL_EXE,
                      NULL );

    CopySysprepFileLow( hwnd,
                        szSysprepPathandFileNameSrc,
                        szSysprepPathandFileNameDest,
                        szSysprepPath,
                        szCurrentDirectory,
                        SETUPCL_EXE );

}

//----------------------------------------------------------------------------
//
// Function: CopyAllFilesInDir
//
// Purpose:
//
// Arguments:  HWND hwnd - handle to the dialog box
//             TCHAR *szSrcDir - dir of all the files to copy
//             TCHAR *szDestDir - dest where the files are to be copied to
//
// Returns:  BOOL
//     TRUE -  if all the files in the dir were successfully copied
//     FALSE - if there were errors during the copy
//
//----------------------------------------------------------------------------
static BOOL
CopyAllFilesInDir( IN HWND hwnd, IN TCHAR *szSrcDir, IN TCHAR *szDestDir )
{

    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    TCHAR szSrcRootPath[MAX_PATH];
    TCHAR szDestRootPath[MAX_PATH];
    TCHAR szDirectoryWithTheFiles[MAX_PATH] = _T("");

    lstrcpyn( szDirectoryWithTheFiles, szSrcDir, AS(szDirectoryWithTheFiles) );

    lstrcatn( szDirectoryWithTheFiles, _T("\\*"), MAX_PATH );

    FindHandle = FindFirstFile( szDirectoryWithTheFiles, &FindData );

    // ISSUE-2002/02/28-stelo- on the returns should I signal an error?

    // ISSUE-2002/02/28-stelo- test to make sure this will copy a subdirectory if one exists

    if ( FindHandle == INVALID_HANDLE_VALUE )
        return( FALSE );

    do {

        szSrcRootPath[0]  = _T('\0');
        szDestRootPath[0] = _T('\0');

        if( lstrcmp( FindData.cFileName, _T(".")  ) == 0 ||
            lstrcmp( FindData.cFileName, _T("..") ) == 0 )
            continue;

        if( ! ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) ) {

            BOOL test;

            ConcatenatePaths( szSrcRootPath,
                              szSrcDir,
                              FindData.cFileName,
                              NULL );

            ConcatenatePaths( szDestRootPath,
                              szDestDir,
                              FindData.cFileName,
                              NULL );

            CopyFile( szSrcRootPath, szDestRootPath, FALSE );

            SetFileAttributes( szDestRootPath, FILE_ATTRIBUTE_NORMAL );

        } else {

            //
            // Create the dir and recurse
            //

            if ( ! EnsureDirExists( szDestDir ) ) {

                UINT iRet;

                iRet = ReportErrorId( hwnd,
                                      MSGTYPE_RETRYCANCEL | MSGTYPE_WIN32,
                                      IDS_ERR_CREATE_FOLDER,
                                      szDestDir );

                return( FALSE );

            }

            if ( ! CopyAllFilesInDir( hwnd, szSrcRootPath, szDestDir ) ) {
                return( FALSE );
            }
        }

    } while ( FindNextFile( FindHandle, &FindData ) );

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: FindFileInWindowsSourceFiles
//
// Purpose:  To look through the windows source files for a particular file.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//             IN TCHAR *pszFile - the file to search for
//             IN TCHAR *pszSourcePath - path to the Windows source files
//             OUT TCHAR *pszFoundPath - path to the found file, if found
//
// pszFoundPath is assumed to be able to hold a string of MAX_PATH chars
//
// Returns:  BOOL - TRUE if the file is found, FALSE if not
//
//----------------------------------------------------------------------------
static BOOL
FindFileInWindowsSourceFiles( IN HWND hwnd,
                              IN TCHAR *pszFile,
                              IN TCHAR *pszSourcePath,
                              OUT TCHAR *pszFoundPath  )
{

    HANDLE          FindHandle;
    WIN32_FIND_DATA FindData;
    TCHAR szOriginalPath[MAX_PATH + 1];
    TCHAR szPossiblePath[MAX_PATH + 1]              = _T("");
    TCHAR szPossiblePathAndFileName[MAX_PATH + 1]   = _T("");

    ConcatenatePaths( szPossiblePathAndFileName,
                      pszSourcePath,
                      pszFile,
                      NULL );

    if( DoesFileExist( szPossiblePathAndFileName ) )
    {

        lstrcpyn( pszFoundPath, pszSourcePath, MAX_PATH );

        return( TRUE );

    }

    //
    //  Look through the sub-directories for it
    //

    //
    //  Save the original path so it can be restored later
    //

    lstrcpyn( szOriginalPath, pszSourcePath, AS(szOriginalPath) );

    //
    // Look for * in this dir
    //

    if ( ! ConcatenatePaths( pszSourcePath, _T("*"), NULL ) )
    {

        //
        //  Restore the original path before returning
        //

        lstrcpyn( pszSourcePath, szOriginalPath, MAX_PATH );

        return( FALSE );
    }

    FindHandle = FindFirstFile( pszSourcePath, &FindData );

    if( FindHandle == INVALID_HANDLE_VALUE )
    {
        return( FALSE );
    }

    do {

        //
        // skip over the . and .. entries
        //

        if (0 == lstrcmp(FindData.cFileName, _T(".")) ||
            0 == lstrcmp(FindData.cFileName, _T("..")))
        {
            continue;
        }

        //
        // If this is a dirent, recurse.
        //

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {

            BOOL bFoundStatus;

            pszSourcePath[0] = _T('\0');

            if ( ! ConcatenatePaths( pszSourcePath, szOriginalPath, FindData.cFileName, NULL ) )
                continue;

            bFoundStatus = FindFileInWindowsSourceFiles( hwnd,
                                                         pszFile,
                                                         pszSourcePath,
                                                         pszFoundPath );

            if( bFoundStatus )
            {
                return( TRUE );
            }

        }

    } while( FindNextFile( FindHandle, &FindData ) );

    FindClose( FindHandle );

    //
    //  Restore the original path
    //
    lstrcpyn( pszSourcePath, szOriginalPath, MAX_PATH );

    lstrcpyn( pszFoundPath, _T(""), MAX_PATH );

    return( FALSE );

}

//----------------------------------------------------------------------------
//
// Function: CabinetCallback
//
// Purpose:
//
// Arguments:
//
// Returns:  LRESULT
//
//----------------------------------------------------------------------------
UINT WINAPI
CabinetCallback( IN PVOID pMyInstallData,
                 IN UINT Notification,
                 IN UINT_PTR Param1,
                 IN UINT_PTR Param2 )
{

    UINT lRetVal = NO_ERROR;
    FILE_IN_CABINET_INFO *pInfo = NULL;

    switch( Notification )
    {
        case SPFILENOTIFY_FILEINCABINET:

            pInfo = (FILE_IN_CABINET_INFO *) Param1;

            lstrcpyn( pInfo->FullTargetName, szDestinationPath, AS(pInfo->FullTargetName) );

            if( lstrcmpi( szFileSearchingFor, pInfo->NameInCabinet) == 0 )
            {
                lRetVal = FILEOP_DOIT;  // Extract the file.

                bFileCopiedFromCab = TRUE;
            }
            else
            {
                lRetVal = FILEOP_SKIP;
            }


            break;

        default:
            lRetVal = NO_ERROR;
            break;


    }

    return( lRetVal );

}


//----------------------------------------------------------------------------
//
// Function: CopyFromDriverCab
//
// Purpose:
//
// Arguments:
//
// Returns:  BOOL
//
//----------------------------------------------------------------------------
static BOOL
CopyFromDriverCab( TCHAR *pszCabPathAndFileName, TCHAR* pszFileName, TCHAR* pszDest )
{

    lstrcpyn( szFileSearchingFor, pszFileName, AS(szFileSearchingFor) );

    lstrcpyn( szDestinationPath, pszDest, AS(szDestinationPath) );

    if( ! SetupIterateCabinet( pszCabPathAndFileName, 0, CabinetCallback, 0 ) )
    {
        return( FALSE );
    }

    //
    //  See if the file was actually found and copied.
    //

    if( bFileCopiedFromCab )
    {
        bFileCopiedFromCab = FALSE;

        return( TRUE );
    }
    else
    {
        return( FALSE );
    }

}

//----------------------------------------------------------------------------
//
// Function: AddCompressedFileUnderscore
//
// Purpose:  Given a filename it converts it to its compressed name.
//
// Arguments:
//    IN OUT TCHAR *pszFileName - the file name to change into its
//                                compressed file name
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
AddCompressedFileUnderscore( IN OUT TCHAR *pszFileName )
{

    TCHAR *pCurrentChar;

    pCurrentChar = pszFileName;

    while( *pCurrentChar != _T('\0') && *pCurrentChar != _T('.') )
    {
        pCurrentChar++;
    }

    if( *pCurrentChar == _T('\0') )
    {
        AssertMsg( FALSE,
                   "Filename does not contain a period(.)." );

    }
    else
    {
        pCurrentChar = pCurrentChar + 3;

        *pCurrentChar = _T('_');

        *(pCurrentChar + 1) = _T('\0');
    }

}

//----------------------------------------------------------------------------
//
// Function: CopyAdditionalLangFiles
//
// Purpose:  Copies the additional lang files that are specified in the
//           intl.inf for the language groups being installed.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//                    IN TCHAR *pszSourcePath - source path - must be at least size MAX_PATH
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
CopyAdditionalLangFiles( IN HWND hwnd, IN TCHAR *pszSourcePath )
{

    INT   i;
    INT   j;
    INT   nEntries;
    TCHAR *pszLangGroup;
    INT   nLangGroup;
    INT   nNumFilesToCopy;
    TCHAR szOriginalPath[MAX_PATH + 1];
    TCHAR szLangBaseDir[MAX_PATH + 1]  = _T("");
    TCHAR szSrc[MAX_PATH + 1]          = _T("");
    TCHAR szDest[MAX_PATH + 1]         = _T("");
    TCHAR *pFileName;
    BOOL  bFoundFile;

    //
    //  Save the original path so it can be restored later
    //
    lstrcpyn( szOriginalPath, pszSourcePath, AS(szOriginalPath) );

    MakeLangFilesName( szLangBaseDir );

    if( ! EnsureDirExists( szLangBaseDir ) )
    {
        // ISSUE-2002/02/28-stelo- report an error
    }


    nEntries = GetNameListSize( &GenSettings.LanguageGroups );

    for( i = 0; i < nEntries; i++ )
    {

        pszLangGroup = GetNameListName( &GenSettings.LanguageGroups, i );

        nLangGroup = _ttoi( pszLangGroup );

        nNumFilesToCopy = GetNameListSize( &FixedGlobals.LangGroupAdditionalFiles[ nLangGroup - 1 ] );

        AssertMsg( nNumFilesToCopy >= 0,
                   "Bad value for the number of lang files to copy." );

        for( j = 0; j < nNumFilesToCopy; j++ )
        {

            szSrc[0]  = _T('\0');
            szDest[0] = _T('\0');

            //
            //  Restore the original path as it might have changed on the last iteration
            //

            lstrcpyn( pszSourcePath, szOriginalPath, MAX_PATH );

            pFileName = GetNameListName( &FixedGlobals.LangGroupAdditionalFiles[ nLangGroup - 1 ], j );

            ConcatenatePaths( szDest,
                              szLangBaseDir,
                              pFileName,
                              NULL );

            bFoundFile = FindFileInWindowsSourceFiles( hwnd,
                                                       pFileName,
                                                       pszSourcePath,
                                                       szSrc );

            ConcatenatePaths( szSrc, pFileName, NULL );

            if( ! bFoundFile )
            {

                TCHAR szFileName[MAX_PATH + 1];

                //
                //  If the file doesn't exist, look for the compressed form
                //

                lstrcpyn( szFileName, pFileName, AS(szFileName) );

                AddCompressedFileUnderscore( szFileName );

                bFoundFile = FindFileInWindowsSourceFiles( hwnd,
                                                           szFileName,
                                                           pszSourcePath,
                                                           szSrc );

                if( bFoundFile )
                {
                    TCHAR *pszFileName;

                    ConcatenatePaths( szSrc, szFileName, NULL );

                    pszFileName = MyGetFullPath( szDest );

                    AddCompressedFileUnderscore( pszFileName );
                }
                else
                {


                    TCHAR szCabPathAndFileName[MAX_PATH + 1] = _T("");

                    ConcatenatePaths( szCabPathAndFileName,
                                      pszSourcePath,
                                      _T("driver.cab"),
                                      NULL );

                    if( ! CopyFromDriverCab( szCabPathAndFileName, pFileName, szDest ) )
                    {

                        //
                        //  If the compressed form isn't found either, print an error
                        //  message and move on to the next file
                        //

                        ConcatenatePaths( szSrc,
                                          pszSourcePath,
                                          pFileName,
                                          NULL );

                        ReportErrorId( hwnd,
                                       MSGTYPE_ERR,
                                       IDS_ERR_CANNOT_FIND_LANG_FILE,
                                       szSrc );
                    }

                    continue;

                }

            }

            CopyFile( szSrc, szDest, FALSE );

            SetFileAttributes( szDest, FILE_ATTRIBUTE_NORMAL );

        }

    }

    //
    //  Restore the original path
    //

    lstrcpyn( pszSourcePath, szOriginalPath, MAX_PATH );

}

//----------------------------------------------------------------------------
//
// Function: CopyLanguageFiles
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  BOOL - TRUE if a path was specified to the Windows Setup files
//                  FALSE if not path was specifed, the user canceled the dialog
//
//----------------------------------------------------------------------------
static BOOL
CopyLanguageFiles( IN HWND hwnd )
{

    INT   iLangCount;
    INT   iNumLangsToInstall;
    INT   iCurrentLang = 0;
    BOOL  bCopySuccessful;
    TCHAR *pszLangPartialPath;
    TCHAR PathBuffer[MAX_PATH + 1];
    TCHAR WindowsSetupPath[MAX_PATH + 1];
    TCHAR szLangBaseDir[MAX_PATH + 1]            = _T("");
    TCHAR szLangPathAndFilesSrc[MAX_PATH + 1]  = _T("");
    TCHAR szLangPathAndFilesDest[MAX_PATH + 1] = _T("");

    MakeLangFilesName( szLangBaseDir );

    // ISSUE-2002/02/28-stelo- what if they copied they lang files by hand, then I don't
    // want any pop-ups here

    iNumLangsToInstall = GetNameListSize( &GenSettings.LanguageGroups );

    //
    //  See if they are any lang files to copy
    //

    if( iNumLangsToInstall == 0 )
    {
        return( TRUE );
    }

    if( ! EnsureDirExists( szLangBaseDir ) )
    {
        // ISSUE-2002-02-28-stelo- report an error
    }

    do
    {

        BOOL bUserProvidedPath;

        PathBuffer[0]               = _T('\0');
        WindowsSetupPath[0]         = _T('\0');

        ReportErrorId( hwnd,
                       MSGTYPE_ERR,
                       IDS_ERR_SPECIFY_LANG_PATH );

        bUserProvidedPath = BrowseForSourceDir( hwnd, PathBuffer );

        if( ! bUserProvidedPath )
        {
            return( FALSE );
        }

        ConcatenatePaths( WindowsSetupPath,
                          PathBuffer,
                          DOSNET_INF,
                          NULL );

    } while( ! DoesFileExist( WindowsSetupPath ) );



    //
    //  Copy the language files needed but that are not in each language groups sub-dir
    //

    CopyAdditionalLangFiles( hwnd, PathBuffer );


    iLangCount = GetNameListSize( &GenSettings.LanguageFilePaths );

    //
    //  Advance until we find a language that we need to copy files over for or
    //  we run out of languages
    //
    for( iCurrentLang = 0;
         iCurrentLang < iLangCount;
         iCurrentLang++ )
    {

        pszLangPartialPath = GetNameListName( &GenSettings.LanguageFilePaths,
                                              iCurrentLang );

        //
        //  If there is actually a lang sub-dir to copy
        //

        if( lstrcmp( pszLangPartialPath, _T("") ) != 0 )
        {

            szLangPathAndFilesSrc[0]  = _T('\0');
            szLangPathAndFilesDest[0] = _T('\0');

            ConcatenatePaths( szLangPathAndFilesSrc,
                              PathBuffer,
                              pszLangPartialPath,
                              NULL );

            ConcatenatePaths( szLangPathAndFilesDest,
                              szLangBaseDir,
                              pszLangPartialPath,
                              NULL );

            //
            //  Copy the lang files over
            //

            EnsureDirExists( szLangPathAndFilesDest );

            bCopySuccessful = CopyAllFilesInDir( hwnd,
                                                 szLangPathAndFilesSrc,
                                                 szLangPathAndFilesDest );

            if( ! bCopySuccessful )
            {
                ReportErrorId( hwnd,
                               MSGTYPE_ERR,
                               IDS_ERR_UNABLE_TO_COPY_LANG_DIR,
                               szLangPathAndFilesSrc,
                               szLangPathAndFilesDest );
            }

        }

    }

    return( TRUE );

}


//----------------------------------------------------------------------------
//
//  This section of code supports the WIZ_NEXT event
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function: ComputePnpDriverPathR
//
//  Purpose: This is support to compute OemPnpDriversPath.  Every dir in
//           $oem$\$1\drivers that we find a .inf file in, we add it to the
//           OemPnPDriversPath.
//
//           ComputePnpDriverPath() is the real entry, not this one.
//
//----------------------------------------------------------------------------

VOID ComputePnpDriverPathR(HWND hwnd, LPTSTR lpRoot)
{
    LPTSTR          lpRootEnd  = lpRoot + lstrlen(lpRoot);
    HANDLE          FindHandle;
    WIN32_FIND_DATA FindData;
    BOOL            bAddToSearchPath = FALSE;
    HRESULT hrCat;

    //
    // loop over lpRoot\*
    //

    if ( ! ConcatenatePaths(lpRoot, _T("*"), NULL) )
        return;

    FindHandle = FindFirstFile(lpRoot, &FindData);
    if ( FindHandle == INVALID_HANDLE_VALUE )
        return;

    //
    //  If it is a sysprep
    //
    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP ) {


    }

    do {

        *lpRootEnd = _T('\0');

        //
        // skip over the . and .. entries
        //

        if (0 == lstrcmp(FindData.cFileName, _T(".")) ||
            0 == lstrcmp(FindData.cFileName, _T("..")))
            continue;

        //
        // Build the new path name
        //

        if ( ! ConcatenatePaths(lpRoot, FindData.cFileName, NULL) )
            continue;

        //
        // If we have a .inf file, mark this directory to be included
        // in the search path.
        //

        {
            int len = lstrlen(FindData.cFileName);

            if ( ( len > 4 ) &&
                 ( LSTRCMPI( &FindData.cFileName[len - 4], _T(".inf") ) == 0 ) )
            {
                bAddToSearchPath = TRUE;
            }
        }

        //
        // If a dirent, recurse.
        //

        if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

            ComputePnpDriverPathR(hwnd, lpRoot);
        }

    } while ( FindNextFile(FindHandle, &FindData) );

    *lpRootEnd = _T('\0');
    FindClose(FindHandle);

    //
    // If we found a .inf in this dir, add it to the PnpDriver search path
    //
    // Note, we don't want c:\win2000dist\$oem$\$1\drivers\foo.  We only want
    // part of it.  We want \drivers\foo.  So jump past the SysDrive portion.
    //
    // Note that this code assumes that \drivers is a sub-dir of the SysDir.
    //

    if ( bAddToSearchPath ) {

        TCHAR Buffer[MAX_PATH];
        int len;

        if ( WizGlobals.OemPnpDriversPath[0] != _T('\0') )
            hrCat=StringCchCat(WizGlobals.OemPnpDriversPath, AS(WizGlobals.OemPnpDriversPath), _T(";"));

        MakeSysDriveName(Buffer);
        len = lstrlen(Buffer);

        hrCat=StringCchCat(WizGlobals.OemPnpDriversPath,AS(WizGlobals.OemPnpDriversPath), lpRoot + len);
    }
}

//----------------------------------------------------------------------------
//
//  Function: ComputeSysprepPnpPath
//
//  Purpose:  Determines the path to the sysprep PnP drivers.
//
//  The path will always be %systemdrive%\drivers so all we have to do is
//  check to see if there are any files there.  If there are set the path, if
//  not, then do not set the path.
//
//----------------------------------------------------------------------------
VOID
ComputeSysprepPnpPath( TCHAR* Buffer )
{

    HANDLE           FindHandle;
    WIN32_FIND_DATA  FindData;
    INT              iFileCount = 0;
    TCHAR            szDriverFiles[MAX_PATH]  = _T("");

    if ( ! ConcatenatePaths(szDriverFiles, Buffer, _T("*"), NULL) )
        return;

    FindHandle = FindFirstFile(szDriverFiles, &FindData);
    if( FindHandle == INVALID_HANDLE_VALUE )
    {
        return;
    }

    do
    {
        iFileCount++;
    } while( FindNextFile( FindHandle, &FindData ) && iFileCount < 3 );

    //
    //  every directory contains 2 files, "." and "..", so we have to check
    //  for 3 or more to determine if there are any real files there.
    //
    if( iFileCount >= 3)
    {
        lstrcpyn( WizGlobals.OemPnpDriversPath, Buffer, AS(WizGlobals.OemPnpDriversPath) );
    }

}

//----------------------------------------------------------------------------
//
//  Function: ComputePnpDriverPath
//
//  Purpose: When user hits the NEXT button, we compute the OemPnpDriversPath
//           based on what we find in $oem$\$1\drivers.
//
//           Every sub-dir that has a .inf in it, gets put on the path.
//
//----------------------------------------------------------------------------

VOID ComputePnpDriverPath(HWND hwnd)
{
    TCHAR Buffer[MAX_PATH] = NULLSTR;
    
    WizGlobals.OemPnpDriversPath[0] = _T('\0');
    MakePnpDriversName(Buffer);

    //
    //  If it is a sysprep, then we know the drivers are in %systemdrive%\drivers.
    //  Just check to see if there are any files there.
    //  If it is not a sysprep, then we need to cat together the paths to the
    //  driver directories.
    //
    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {
        ComputeSysprepPnpPath( Buffer );
    }
    else
    {
        ComputePnpDriverPathR(hwnd, Buffer);
    }
}

//----------------------------------------------------------------------------
//
// Function: OnWizNextAddDirs
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog box
//
// Returns: VOID
//
//----------------------------------------------------------------------------
BOOL
OnWizNextAddDirs( IN HWND hwnd )
{

    BOOL bUserCanceled = TRUE;

    ComputePnpDriverPath(hwnd);

    //
    //  If it is a sysprep, make sure the sysprep directory exists
    //  and the appropriate files are copied
    //
    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {

        TCHAR szBuffer[MAX_PATH + 1] = _T("");

        //
        //  Make the necessary sysprep directories
        //
        MakeLangFilesName( szBuffer );
        
        if ( szBuffer[0] )
        {
            CreateDirectory( szBuffer, NULL );

            MakePnpDriversName( szBuffer );
            CreateDirectory( szBuffer, NULL );

            CopySysprepFiles( hwnd );

            bUserCanceled = CopyLanguageFiles( hwnd );
        }

    }

    //
    //  See if we need to copy the IE Branding file and if we do then copy it.
    //

    if( ( GenSettings.IeCustomizeMethod == IE_USE_BRANDING_FILE ) &&
        ( GenSettings.szInsFile[0] != _T('\0') ) )
    {

        if( DoesFileExist( GenSettings.szInsFile ) )
        {
            TCHAR szDestPathAndFileName[MAX_PATH + 1] = _T("");
            TCHAR *pszFileName = NULL;

            pszFileName = MyGetFullPath( GenSettings.szInsFile );

            ConcatenatePaths( szDestPathAndFileName,
                              WizGlobals.OemFilesPath,
                              pszFileName,
                              NULL );

            CopyFile( GenSettings.szInsFile, szDestPathAndFileName, FALSE );
        }
        else
        {
            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ERR_INS_FILE_NO_COPY,
                           WizGlobals.OemFilesPath );
        }

    }
    else
    {
    }

    //
    // Route the wizard
    //

    return (!bUserCanceled);

}


//----------------------------------------------------------------------------
//
//  This section of code is the skeleton of a dialog procedure for
//  this page.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Function: DlgAdditionalDirsPage
//
// Purpose: This is the dialog procedure the additional dirs page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgAdditionalDirsPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnInitAddDirs(hwnd);
            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_ADDFILE:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnAddFileDir(hwnd);
                        break;

                    case IDC_REMOVEFILE:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRemoveFileDir(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR        pnmh    = (LPNMHDR)        lParam;
                LPNMTREEVIEW   pnmtv   = (LPNMTREEVIEW)   lParam;
                LPNMTVDISPINFO pnmdisp = (LPNMTVDISPINFO) lParam;
                LPNMTVKEYDOWN  pnmkey  = (LPNMTVKEYDOWN)  lParam;

                if ( pnmh->idFrom == IDC_FILETREE ) {

                    switch( pnmh->code ) {

                        case TVN_SELCHANGED:
                            OnTreeViewSelectionChange(hwnd);
                            break;

                        default:
                            bStatus = FALSE;
                            break;
                    }
                }

                else {

                    switch( pnmh->code ) {

                        case PSN_QUERYCANCEL:
                            CancelTheWizard(hwnd);
                            break;

                        case PSN_SETACTIVE:

                            OnSetActiveAddDirs( hwnd );

                            PropSheet_SetWizButtons(GetParent(hwnd),
                                                    PSWIZB_BACK | PSWIZB_NEXT);
                            break;

                        case PSN_WIZBACK:
                            break;

                        case PSN_WIZNEXT:

                            if ( !OnWizNextAddDirs( hwnd ) )
                                WIZ_FAIL(hwnd);

                            break;

                        default:
                            bStatus = FALSE;
                            break;
                    }
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\copyfil1.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      copyfil1.c
//
// Description:
//      This file has the dlgproc for the CopyFiles1 page.  This is the
//      page just before the gas-guage.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "sku.h"

static TCHAR *StrServerCdName;
static TCHAR *StrWorkStationCdName;

static NAMELIST DosnetPaths;
TCHAR  szDosnetPath[MAX_PATH + 1];

#define WORKSTATION 0
#define SERVER      1
#define ENTERPRISE  2
#define PERSONAL    4
#define WEBBLADE    5

static LPTSTR s_lpSourceDirs[] =
{
    DIR_CD_IA64,    // Must be before x86 because ia64 has both dirs.
    DIR_CD_X86,     // Should always be last in the list.
};

//----------------------------------------------------------------------------
//
// Function: OnMultipleDosnetInitDialog
//
// Purpose:  Fill the dosnet list box with the possible path choices for
//           the user.
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnMultipleDosnetInitDialog( IN HWND hwnd )
{

    INT i;
    INT nEntries;
    TCHAR *pDosnetPath;

    nEntries = GetNameListSize( &DosnetPaths );

    for( i = 0; i < nEntries; i++ )
    {

        pDosnetPath = GetNameListName( &DosnetPaths, i );

        SendDlgItemMessage( hwnd,
                            IDC_LB_DOSNET_PATHS,
                            LB_ADDSTRING,
                            (WPARAM) 0,
                            (LPARAM) pDosnetPath );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnMultipleDosnetOk
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: BOOL - TRUE if safe to close the pop-up, FALSE to keep the pop-up
//                 open
//
//----------------------------------------------------------------------------
static BOOL
OnMultipleDosnetOk( IN HWND hwnd )
{

    INT_PTR iRetVal;

    iRetVal = SendDlgItemMessage( hwnd,
                                  IDC_LB_DOSNET_PATHS,
                                  LB_GETCURSEL,
                                  0,
                                  0 );

    if( iRetVal == LB_ERR )
    {
        ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_NO_PATH_CHOSEN );

        return( FALSE );
    }
    else
    {

        SendDlgItemMessage( hwnd,
                            IDC_LB_DOSNET_PATHS,
                            LB_GETTEXT,
                            (WPARAM) iRetVal,
                            (LPARAM) szDosnetPath );

        return( TRUE );

    }

}

//----------------------------------------------------------------------------
//
// Function: MultipleDosnetDlg
//
// Purpose:  Dialog procedure for the user to select what windows source file
//           dir they want to tree copy.
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
MultipleDosnetDlg( IN HWND     hwnd,
                   IN UINT     uMsg,
                   IN WPARAM   wParam,
                   IN LPARAM   lParam )
{

    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnMultipleDosnetInitDialog( hwnd );

            break;

        case WM_COMMAND: {

            int nButtonId;

            switch ( nButtonId = LOWORD (wParam ) ) {

                case IDOK:
                {

                    BOOL bSelectionMade;

                    bSelectionMade = OnMultipleDosnetOk( hwnd );

                    if( bSelectionMade )
                    {
                        EndDialog( hwnd, TRUE );
                    }

                    break;

                }

                case IDCANCEL:

                    EndDialog( hwnd, FALSE );

                    break;

            }

        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
//  Function: GreyUnGreyCopyFile1
//
//  Purpose: Called to grey/ungrey the controls.  Call this routine each
//           time a radio button is clicked or set.
//
//----------------------------------------------------------------------------

VOID GreyUnGreyCopyFile1(HWND hwnd)
{
    BOOL bUnGrey = IsDlgButtonChecked(hwnd, IDC_COPYFROMPATH);

    EnableWindow(GetDlgItem(hwnd, IDT_SOURCEPATH), bUnGrey);
    EnableWindow(GetDlgItem(hwnd, IDC_BROWSE),     bUnGrey);
    EnableWindow(GetDlgItem(hwnd, IDC_GREYTEXT),   bUnGrey);
}

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveCopyFiles1
//
//  Purpose: Called at SETACTIVE time
//
//----------------------------------------------------------------------------

VOID OnSetActiveCopyFiles1(HWND hwnd)
{
    CheckRadioButton(hwnd,
                     IDC_COPYFROMCD,
                     IDC_COPYFROMPATH,
                     WizGlobals.bCopyFromPath ? IDC_COPYFROMPATH
                                              : IDC_COPYFROMCD);

    GreyUnGreyCopyFile1(hwnd);

    ZeroMemory( &DosnetPaths, sizeof(NAMELIST) );

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnRadioButtonCopyFiles1
//
//  Purpose: Called when a radio button is pushed.  We must grey/ungrey
//           controls when this happens.
//
//----------------------------------------------------------------------------

VOID OnRadioButtonCopyFiles1(HWND hwnd, int nButtonId)
{
    CheckRadioButton(hwnd,
                     IDC_COPYFROMCD,
                     IDC_COPYFROMPATH,
                     nButtonId);

    GreyUnGreyCopyFile1(hwnd);
}

//----------------------------------------------------------------------------
//
//  Function: OnBrowseCopyFiles1
//
//  Purpose: Called when user pushes the BROWSE button
//
//----------------------------------------------------------------------------

VOID OnBrowseCopyFiles1(HWND hwnd)
{
    BOOL bGoodSource = FALSE;


    while (!bGoodSource && BrowseForFolder(hwnd, IDS_BROWSEFOLDER, WizGlobals.CopySourcePath, BIF_DONTGOBELOWDOMAIN | BIF_RETURNONLYFSDIRS | BIF_EDITBOX | BIF_VALIDATE))
    {
        TCHAR   szPath[MAX_PATH] = NULLSTR;
        LPTSTR  lpEnd,
                lpEnd2;

        // Make our own copy of the path we got back.
        //
        lstrcpyn(szPath, WizGlobals.CopySourcePath,AS(szPath));

        // First check and see if we have the inf we need right here.
        //
        lpEnd = szPath + lstrlen(szPath);
        AddPathN(szPath, FILE_DOSNET_INF, AS(szPath));
        if ( !(bGoodSource = FileExists(szPath)) )
        {
            DWORD dwSearch;

            // Search for all the possible source directories that could be on the CD.
            //
            for ( dwSearch = 0; !bGoodSource && ( dwSearch < AS(s_lpSourceDirs) ); dwSearch++ )
            {
                // First test for the directory.
                //
                *lpEnd = NULLCHR;
                AddPathN(szPath, s_lpSourceDirs[dwSearch],AS(szPath));
                if ( DirectoryExists(szPath) )
                {
                    // Also make sure that the inf file we need is there.
                    //
                    lpEnd2 = szPath + lstrlen(szPath);
                    AddPathN(szPath, FILE_DOSNET_INF,AS(szPath));
                    if ( bGoodSource = FileExists(szPath) )
                        lpEnd = lpEnd2;
                }
            }
        }


        // Let the user know that they have a bad source
        //
        if ( !bGoodSource)
        {
            MsgBox(GetParent(hwnd), IDS_ERR_BADSOURCE, IDS_APPNAME, MB_ERRORBOX);
        }

    }
    

    // Set the source in the dialog only if the source was good
    //
    if ( bGoodSource )
    {
        SetDlgItemText(hwnd, IDT_SOURCEPATH, WizGlobals.CopySourcePath);
    }
}

//----------------------------------------------------------------------------
//
//  Function: CanConnectToNetworkShare
//
//  Purpose:  To determine if the currently logged in user has permission to
//            access the UNC path given.
//
//  Arguments:
//       TCHAR *szSourceFilesPath - path to the source files that contains the
//                 UNC path to see if we can connect
//
//  Returns:
//      TRUE if user has permission to access the network share
//      FALSE if not
//
//----------------------------------------------------------------------------
static BOOL
CanConnectToNetworkShare( IN TCHAR *pszSourceFilesPath )
{

    TCHAR *pPathEnd;
    TCHAR  szUncPath[MAX_PATH + 1];
    INT    nBackSlashCount = 0;
    DWORD  dwResult;
    NETRESOURCE NetResource;

    //
    //  Verify it is a UNC path.
    //

    AssertMsg( ( pszSourceFilesPath[0] == _T('\\') && pszSourceFilesPath[1] == _T('\\') ),
               "This is not a UNC path." );


    //  ISSUE-2002/02/28-stelo- in the next release it would be nice to prompt the user for a
    //          name and password to connect to the network share




    lstrcpyn( szUncPath, pszSourceFilesPath, AS(szUncPath) );

    //
    //  Strip off the extra dir info so we are just left with \\computername\sharename
    //

    pPathEnd = szUncPath;

    //
    //  Advance past the 2 leading backslashes
    //

    pPathEnd = pPathEnd + 2;

    while( *pPathEnd != _T('\0') )
    {

        if( *pPathEnd == _T('\\') )
        {

            if( nBackSlashCount == 0 )
            {

                //
                //  Found the backslash that separates the computername and sharename
                //

                nBackSlashCount++;

            }
            else //  nBackSlashCount >= 1
            {

                //
                //  Found the end of the sharename
                //

                *pPathEnd = _T('\0');

                break;

            }

        }

        pPathEnd++;

    }

    //
    // Assign values to the NETRESOURCE structure.
    //

    NetResource.dwType       = RESOURCETYPE_ANY;
    NetResource.lpLocalName  = NULL;
    NetResource.lpRemoteName = (LPTSTR) szUncPath;
    NetResource.lpProvider   = NULL;

    //
    //  Try to connect as the local user
    //

    dwResult = WNetAddConnection2( &NetResource, NULL, NULL, FALSE );

    switch( dwResult )
    {
        case NO_ERROR:
        case ERROR_ALREADY_ASSIGNED:
            return( TRUE );
            break;

        case ERROR_ACCESS_DENIED:
        case ERROR_LOGON_FAILURE:

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_ACCESS_DENIED,
                           szUncPath );

            return( FALSE );
            break;

        case ERROR_NO_NETWORK:

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_NO_NETWORK,
                           szUncPath );

            return( FALSE );
            break;

        default:
            //
            // some other error
            //

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_UNKNOWN_ERROR,
                           szUncPath );

            return( FALSE );
            break;

    }

}

//----------------------------------------------------------------------------
//
//  Function: IsCorrectNtVersion
//
//  Purpose:  Checks the txtsetup.sif to make sure the files are at least NT5
//            and that it is the correct version (workstation or server).
//
//  Arguments:
//       TCHAR *szSourceFilesPath - path to the source files to validate
//
//  Returns:
//      TRUE if NT version info is correct
//      FALSE if not the correct version
//
//----------------------------------------------------------------------------
BOOL
IsCorrectNtVersion( IN HWND hwnd, IN TCHAR *szSourceFilesPath )
{

    HINF       hTxtsetupSif;
    INFCONTEXT TxtsetupSifContext;
    TCHAR      szTempBuffer[MAX_INILINE_LEN];
    INT        iMajorVersion;
    INT        iPlatformType;
    TCHAR      szMajorVersionNumber[MAX_STRING_LEN];
    TCHAR      szPlatformType[MAX_STRING_LEN];
    TCHAR      szTxtsetupSif[MAX_PATH]  = _T("");

    BOOL bKeepReading       = TRUE;
    BOOL bFoundVersion      = FALSE;
    BOOL bFoundProductType  = FALSE;
    HRESULT hrCat;

    lstrcpyn( szTxtsetupSif, szSourceFilesPath, AS(szTxtsetupSif) );

    hrCat=StringCchCat( szTxtsetupSif,AS(szTxtsetupSif), _T("\\txtsetup.sif") );

    hTxtsetupSif = SetupOpenInfFile( szTxtsetupSif,
                                     NULL,
                                     INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                     NULL );

    if( hTxtsetupSif == INVALID_HANDLE_VALUE ) {

        // ISSUE-2002/02/28-stelo- alert an error that we couldn't open the file or just
        //         skip over in this case?

        return( FALSE );

    }

    TxtsetupSifContext.Inf = hTxtsetupSif;
    TxtsetupSifContext.CurrentInf = hTxtsetupSif;

    bKeepReading = SetupFindFirstLine( hTxtsetupSif,
                                       _T("SetupData"),
                                       NULL,
                                       &TxtsetupSifContext );

    //
    //  Look for the ProductType key and the MajorVersion key
    //
    while( bKeepReading && ( ! bFoundVersion || ! bFoundProductType ) ) {

        SetupGetStringField( &TxtsetupSifContext,
                             0,
                             szTempBuffer,
                             MAX_INILINE_LEN,
                             NULL );

        if( LSTRCMPI( szTempBuffer, _T("ProductType") ) == 0 ) {

            SetupGetStringField( &TxtsetupSifContext,
                                 1,
                                 szPlatformType,
                                 MAX_STRING_LEN,
                                 NULL );

            bFoundProductType = TRUE;

        }

        if( LSTRCMPI( szTempBuffer, _T("MajorVersion") ) == 0 ) {

            SetupGetStringField( &TxtsetupSifContext,
                                 1,
                                 szMajorVersionNumber,
                                 MAX_STRING_LEN,
                                 NULL );

            bFoundVersion = TRUE;

        }

        //
        // move to the next line of the answer file
        //
        bKeepReading = SetupFindNextLine( &TxtsetupSifContext, &TxtsetupSifContext );

    }

    SetupCloseInfFile( hTxtsetupSif );

    //
    //  Convert the NT version number and product type from a string to an int
    //
    iMajorVersion = _wtoi( szMajorVersionNumber );

    iPlatformType = _wtoi( szPlatformType );

    //
    //  Make sure it is at least NT5 (Windows 2000) files
    //
    if( bFoundVersion ) {

        if( iMajorVersion < 5 ) {

            ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_NOT_NT5_FILES );

            return( FALSE );

        }

    }
    else {

        INT iRet;

        iRet = ReportErrorId( hwnd,
                              MSGTYPE_YESNO,
                              IDS_ERR_CANNOT_DETERMINE_VERSION );

        if( iRet == IDNO ) {

            return( FALSE );

        }

    }

    //
    //  Make sure they are actually giving us workstation files, if they
    //  specified workstation or server files if they specified server.
    //
    if( bFoundVersion ) {
        if( WizGlobals.iPlatform == PLATFORM_PERSONAL ) {

            if( iPlatformType != PERSONAL ) {

                ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_NOT_PERSONAL_FILES );

                return( FALSE );

            }

        }    
        else if( WizGlobals.iPlatform == PLATFORM_WORKSTATION ) {

            if( iPlatformType != WORKSTATION ) {

                ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_NOT_WORKSTATION_FILES );

                return( FALSE );

            }

        }
        else if( WizGlobals.iPlatform == PLATFORM_SERVER ) {

            if( iPlatformType != SERVER ) {

                ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_NOT_SERVER_FILES );

                return( FALSE );

            }

        }
        else if( WizGlobals.iPlatform == PLATFORM_WEBBLADE ) {

            if( iPlatformType != WEBBLADE ) {

                ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_NOT_WEBBLADE_FILES );

                return( FALSE );

            }

        }
        else if( WizGlobals.iPlatform == PLATFORM_ENTERPRISE ) {

            if( iPlatformType != ENTERPRISE ) {

                ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_NOT_ENTERPRISE_FILES );

                return( FALSE );

            }

        }
        else {

            //
            //  If we get to this page, the product install type has to be either
            //  workstation or server.
            //
            AssertMsg( FALSE, "Bad product install type." );

        }

    }
    else {

        INT iRet;

        iRet = ReportErrorId( hwnd,
                              MSGTYPE_YESNO,
                              IDS_ERR_CANNOT_DETERMINE_PRODUCT );

        if( iRet == IDNO ) {

            return( FALSE );

        }

    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
//  Function: RecurseDirectories
//
//  Purpose:
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------
static VOID
RecurseDirectories( IN HWND hwnd, IN OUT LPTSTR RootBuffer, IN DWORD cbSize )
{

    LPTSTR          RootPathEnd = RootBuffer + lstrlen( RootBuffer );
    HANDLE          FindHandle;
    WIN32_FIND_DATA FindData;
    TCHAR           szOriginalPath[MAX_PATH + 1] = _T("");

    //
    //  Backup the original path so it can be restored later
    //

    lstrcpyn( szOriginalPath, RootBuffer, AS(szOriginalPath) );

    //
    // Look for * in this dir
    //

    if( ! ConcatenatePaths( RootBuffer, _T("*") , NULL) )
    {

        //
        //  Restore the original path before returning
        //

        lstrcpyn( RootBuffer, szOriginalPath, cbSize );

        return;
    }

    FindHandle = FindFirstFile( RootBuffer, &FindData );

    if( FindHandle == INVALID_HANDLE_VALUE )
    {

        //
        //  Restore the original path before returning
        //
        lstrcpyn( RootBuffer, szOriginalPath, cbSize );

        return;
    }

    do {

        *RootPathEnd = _T('\0');

        //
        // skip over the . and .. entries
        //

        if( 0 == lstrcmp( FindData.cFileName, _T("." ) ) ||
            0 == lstrcmp( FindData.cFileName, _T("..") ) )
        {
           continue;
        }

        if( LSTRCMPI( FindData.cFileName, _T("dosnet.inf") ) == 0 )
        {

            AddNameToNameList( &DosnetPaths, RootBuffer );

        }
        else if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {
            //
            // If this is a dirent, recurse.
            //

            if( ! ConcatenatePaths( RootBuffer, FindData.cFileName, NULL ) )
            {
                continue;
            }

            RecurseDirectories( hwnd, RootBuffer,  cbSize);
        }

    } while ( FindNextFile( FindHandle, &FindData ) );


    *RootPathEnd = _T('\0');

    FindClose( FindHandle );

    //
    //  Restore the original path
    //

    lstrcpyn( RootBuffer, szOriginalPath, cbSize );

}

//----------------------------------------------------------------------------
//
//  Function: FindWindowsSourceFilesPaths
//
//  Purpose:  Find all the dirs on the CD that contain dosnet.inf.  If there
//    is more than one pop-up a dialog and have the user pick one.
//
//  Arguments:
//
//  Returns:
//
//----------------------------------------------------------------------------
static BOOL
FindWindowsSourceFilesPaths( IN HWND hwnd, LPTSTR PathBuffer, DWORD cbSize )
{

    TCHAR *pDosnetPath;

    RecurseDirectories( hwnd, PathBuffer, cbSize );

    if( GetNameListSize( &DosnetPaths ) > 1 )
    {

        if( DialogBox( FixedGlobals.hInstance,
                       MAKEINTRESOURCE( IDD_MULTIPLE_DOSNET_POPUP ),
                       hwnd,
                       MultipleDosnetDlg ) )
        {
            lstrcpyn( PathBuffer, szDosnetPath, cbSize );

            return( TRUE );
        }
        else
        {
            return( FALSE );
        }

    }
    else
    {
        pDosnetPath = GetNameListName( &DosnetPaths, 0 );

        lstrcpyn( PathBuffer, pDosnetPath, cbSize );

        if ( PathBuffer[0] )
            return(TRUE);
        else
            return(FALSE);

    }

}

//----------------------------------------------------------------------------
//
//  Function: GetCdPath
//
//  Purpose: Figures out the full pathname of the NT source files on the CD.
//
//  Arguments:
//      HWND   hwnd - current dialog
//
//  Returns:
//      TRUE if all is ok
//      FALSE if errors, Don't let wizard proceed
//
//      WizGlobals.CdSourcePath will contain the valid path to the source
//      files on success.
//
//      Note, we don't override CopySourcePath because it displays to the
//      user.  He shouldn't see a CD path appear in this edit field when
//      choosing to "Copy from CD".
//
//  Notes:
//      - We look only at the 1st cd drive we find
//      - We figure out i386 or alpha based on what is in the drive
//
//----------------------------------------------------------------------------

BOOL GetCdPath(HWND hwnd)
{
    TCHAR DriveLetters[MAX_PATH], *p, *pEnd, PathBuffer[MAX_PATH + 1];
    int   i;
    TCHAR *pProductName;

    if( WizGlobals.iPlatform == PLATFORM_SERVER )
        pProductName = StrServerCdName;
    else
        pProductName = StrWorkStationCdName;

    //
    // Find the CD-ROM
    //
    // GetLogicalDriveStrings() fills in the DriveLetters buffer, and it
    // looks like:
    //
    //      c:\(null)d:\(null)x:\(null)(null)
    //
    // (i.e. double-null at the end)
    //


    // ISSUE-2002/02/28-stelo- only checks the first CD-ROM drive on this machine
    if ( ! GetLogicalDriveStrings(MAX_PATH, DriveLetters) )
        DriveLetters[0] = _T('\0');

    p = DriveLetters;

    while ( *p ) {

        if ( GetDriveType(p) == DRIVE_CDROM ) {
            lstrcpyn(PathBuffer, p, AS(PathBuffer));
            break;
        }

        while ( *p++ );
    }

    //
    // No cd-rom drive on this machine
    //
    // ISSUE-2002/02/28-stelo- We should check this earlier and grey out the choice
    //         if there isn't a CD-ROM drive on the machine.  And btw,
    //         what happens if I connect to a CD over the net???
    //

    if ( PathBuffer[0] == _T('\0') ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_NO_CDROM_DRIVE);
        return FALSE;
    }

    /*
    //
    // We now have D:\ (or E:\ etc) in PathBuffer.
    //
    // We need to look for and find either:
    //      d:\i386\dosnet.inf
    //      d:\alpha\dosnet.inf
    //
    // Look for both of these files and stop when you find one.
    //

    pEnd = PathBuffer + lstrlen(PathBuffer);

    for ( i=0; i<2; i++ ) {

        if ( i == 0 )
            lstrcpy(pEnd, I386_DOSNET);
        else
            lstrcpy(pEnd, ALPHA_DOSNET);

        if ( GetFileAttributes(PathBuffer) != (DWORD) -1 )
            break;
    }

    //
    //  Add the platform
    //

    if ( i == 0 ) {
        lstrcpy(pEnd, I386_DIR);
    }
    else if ( i == 1 ) {
        lstrcpy(pEnd, ALPHA_DIR);
    }
    else {
        ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_INSERT_CD, pProductName );

        return( FALSE );
    }
    */

    if( ! FindWindowsSourceFilesPaths( hwnd, PathBuffer, AS(PathBuffer) ) )
    {

        ReportErrorId(hwnd,
                          MSGTYPE_ERR,
                          IDS_ERR_NOTWINDOWSCD);
        return( FALSE );
    }

    lstrcpyn( WizGlobals.CdSourcePath, PathBuffer, AS(WizGlobals.CdSourcePath) );

    return( TRUE );
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextCopyFiles1
//
//  Purpose: Called when user pushes the NEXT button.
//
//----------------------------------------------------------------------------

BOOL OnWizNextCopyFiles1(HWND hwnd)
{
    TCHAR PathBuffer[MAX_PATH];
    TCHAR szFilesPath[MAX_PATH] = _T("");
    BOOL  bStayHere = FALSE;
    TCHAR *lpszArchitecture = NULL;

    //
    // Get the control settings
    //

    WizGlobals.bCopyFromPath = IsDlgButtonChecked(hwnd, IDC_COPYFROMPATH);

    SendDlgItemMessage(hwnd,
                       IDT_SOURCEPATH,
                       WM_GETTEXT,
                       (WPARAM) MAX_PATH,
                       (LPARAM) WizGlobals.CopySourcePath);

    //
    // If dosnet.inf doesn't exist, this isn't a good path to the source files
    //

    if ( WizGlobals.bCopyFromPath ) {

        if ( WizGlobals.CopySourcePath[0] == _T('\0') ) {
            ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_ENTER_SETUP_PATH);
            bStayHere = TRUE;
            goto FinishUp;
        }

        //
        //  If it is a UNC path, prepend \\?\UNC\ to the front of the path
        //

        if( WizGlobals.CopySourcePath[0] == _T('\\') &&
            WizGlobals.CopySourcePath[1] == _T('\\') )
        {

            lstrcpyn( szFilesPath, _T("\\\\?\\UNC\\"), AS(szFilesPath) );

            //
            //  Make sure user has access to the share by attempting to
            //  connect to it
            //

            if( ! CanConnectToNetworkShare( WizGlobals.CopySourcePath ) )
            {

                bStayHere = TRUE;
                goto FinishUp;

            }

        }

        ConcatenatePaths( szFilesPath, WizGlobals.CopySourcePath, NULL );

        lstrcpyn( PathBuffer, szFilesPath, AS(PathBuffer) );

        ConcatenatePaths( PathBuffer, _T("dosnet.inf"), NULL );

        if ( ! DoesFileExist(PathBuffer) ) {

            ReportErrorId(hwnd,
                          MSGTYPE_ERR,
                          IDS_ERR_NOT_PRODUCT,
                          WizGlobals.CopySourcePath);
            bStayHere = TRUE;
            goto FinishUp;
        }

    } else {

        if ( ! GetCdPath(hwnd) ) {
            bStayHere = TRUE;
            goto FinishUp;
        }

        lstrcpyn( szFilesPath, WizGlobals.CdSourcePath, AS(szFilesPath) );

    }

    if( ! IsCorrectNtVersion( hwnd, szFilesPath ) )
    {
        bStayHere = TRUE;
        goto FinishUp;
    }

FinishUp:
    // Figure out the architecture (i.e. i386 or alpha) from the SrcPath
    // The SrcPath will be something like d:\i386, or \\net\share\foo\bar\i386
    // so we just need to strip off the last part of the path string, and append
    // it to the dest path
    lpszArchitecture = szFilesPath + lstrlen(szFilesPath) - 1;
    while ((lpszArchitecture >= szFilesPath) && (*lpszArchitecture != _T('\\')) )
        lpszArchitecture--;
    // Move forward 1, to get to the next char after the backslash
    lpszArchitecture++;
    
    lstrcpyn (WizGlobals.Architecture, lpszArchitecture, AS(WizGlobals.Architecture));

    //
    //  Free the memory in the DosnetPaths namelist
    //

    ResetNameList( &DosnetPaths );

    return ( !bStayHere );

}

//----------------------------------------------------------------------------
//
// Function: DlgCopyFile1Page
//
// Purpose: Dialog procedure for the IDD_COPYFILES1 page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgCopyFiles1Page(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;
    BOOL bStayHere = FALSE;

    switch (uMsg) {

        case WM_INITDIALOG:
            StrServerCdName      = MyLoadString(IDS_SERVER_CD_NAME);
            StrWorkStationCdName = MyLoadString(IDS_WORKSTATION_CD_NAME);
            break;

        case WM_COMMAND:
            {
                int nButtonId=LOWORD(wParam);

                switch ( nButtonId ) {

                    case IDC_COPYFROMCD:
                    case IDC_COPYFROMPATH:

                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRadioButtonCopyFiles1(hwnd, nButtonId);
                        break;

                    case IDC_BROWSE:

                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnBrowseCopyFiles1(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_LOC_SETUP;

                        if ( (WizGlobals.iProductInstall != PRODUCT_UNATTENDED_INSTALL) ||
                              WizGlobals.bStandAloneScript )
                            WIZ_SKIP( hwnd );
                        else
                            OnSetActiveCopyFiles1(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextCopyFiles1(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\copyfile.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      copyfile.c
//
// Description:
//      This file has the dlgproc for the copy files page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define DAYS_IN_A_WEEK   7
#define MONTHS_IN_A_YEAR 12

//
// This struct and is used to pack the input args passed to the tree
// copy thread.
//

typedef struct {
    TCHAR lpSourceBuffer[MAX_PATH];
    TCHAR lpDestBuffer[MAX_PATH];
    HWND  hwnd;
} COPY_THREAD_PARAMS;

//
// String constants loaded from resource
//

static TCHAR *StrBuildingList;
static TCHAR *StrCopyingFiles;
static TCHAR *StrFileAlreadyExists;
static TCHAR *StrModified;
static TCHAR *StrBytes;

static TCHAR *StrJanuary;
static TCHAR *StrFebruary;
static TCHAR *StrMarch;
static TCHAR *StrApril;
static TCHAR *StrMay;
static TCHAR *StrJune;
static TCHAR *StrJuly;
static TCHAR *StrAugust;
static TCHAR *StrSeptember;
static TCHAR *StrOctober;
static TCHAR *StrNovember;
static TCHAR *StrDecember;

static TCHAR *StrSunday;
static TCHAR *StrMonday;
static TCHAR *StrTuesday;
static TCHAR *StrWednesday;
static TCHAR *StrThursday;
static TCHAR *StrFriday;
static TCHAR *StrSaturday;

static TCHAR *rgMonthsOfYear[MONTHS_IN_A_YEAR];
static TCHAR *rgDaysOfWeek[DAYS_IN_A_WEEK + 1];

//
// Messages for the dialog procedure
//

#define WMX_BEGINCOPYING (WM_USER+1)
#define WMX_FILECOPIED   (WM_USER+2)
#define WMX_ENDCOPYING   (WM_USER+3)

//
// Global counters
//

HDSKSPC ghDiskSpaceList;
int gnFilesCopied = 0;
int gnTotalFiles  = 0;

//
// Misc constants
//

#define ONE_MEG ( 1024 * 1024 )

//
//  Confirm File replace constants
//
#define YES       1
#define YESTOALL  2
#define NO        3
#define NOTOALL   4
#define CANCEL    5

#define MAX_DAY_OF_WEEK_LEN     64
#define MAX_MONTHS_OF_YEAR_LEN  64

static TCHAR g_szFileAlreadyExistsText[MAX_STRING_LEN] = _T("");
static TCHAR g_szSrcFileDate[MAX_STRING_LEN]  = _T("");
static TCHAR g_szDestFileDate[MAX_STRING_LEN] = _T("");
static TCHAR g_szSrcFileSize[MAX_STRING_LEN]  = _T("");
static TCHAR g_szDestFileSize[MAX_STRING_LEN] = _T("");
static BOOL  g_SetFocusYes;

//
//  Dialog proc that runs in the copying thread's context
//
INT_PTR CALLBACK
ConfirmFileReplaceDlgProc( IN HWND     hwnd,
                           IN UINT     uMsg,
                           IN WPARAM   wParam,
                           IN LPARAM   lParam);


//---------------------------------------------------------------------------
//
// This section of code runs in the context of a spawned thread.  We do the
// NT source copy work in a separate thread so that the dialog repaints
// and such.
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//
// Function: CountSpaceNeeded
//
// Purpose: Routine that walks a tree and counts how many files there are
//          and how much diskspace is needed at the dest drive.
//
// Returns: VOID
//
//---------------------------------------------------------------------------

VOID CountSpaceNeeded(HWND    hwnd,
                      LPTSTR  SrcRootPath,
                      LPTSTR  DestRootPath)
{
    LPTSTR SrcRootPathEnd  = SrcRootPath  + lstrlen(SrcRootPath);
    LPTSTR DestRootPathEnd = DestRootPath + lstrlen(DestRootPath);

    LONGLONG llFileSize;
    HANDLE   FindHandle;

    WIN32_FIND_DATA FindData;

    //
    // Look for * in this dir
    //
    if ( ! ConcatenatePaths(SrcRootPath, _T("*"), NULL) )
        return;

    FindHandle = FindFirstFile(SrcRootPath, &FindData);

    if ( FindHandle == INVALID_HANDLE_VALUE )
        return;

    do {

        *SrcRootPathEnd  = _T('\0');
        *DestRootPathEnd = _T('\0');

        if (lstrcmp(FindData.cFileName, _T(".") )  == 0 ||
            lstrcmp(FindData.cFileName, _T("..") ) == 0 )
            continue;

        if ( ! ConcatenatePaths(SrcRootPath,  FindData.cFileName, NULL) ||
             ! ConcatenatePaths(DestRootPath, FindData.cFileName, NULL) )
            continue;

        //
        // If a file, increment space and TotalFile counters else
        // recurse down
        //
        if ( ! (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            llFileSize = (((LONGLONG) FindData.nFileSizeHigh) << 32) |
                                      FindData.nFileSizeLow;

            SetupAddToDiskSpaceList(ghDiskSpaceList,
                                    DestRootPath,
                                    llFileSize,
                                    FILEOP_COPY,
                                    NULL,
                                    0);

            gnTotalFiles++;

        } else {

            CountSpaceNeeded(hwnd,
                             SrcRootPath,
                             DestRootPath);
        }

    } while ( FindNextFile(FindHandle, &FindData) );

    *SrcRootPathEnd  = _T('\0');
    *DestRootPathEnd = _T('\0');

    FindClose(FindHandle);
}

//---------------------------------------------------------------------------
//
//  Function: BuildTimeString
//
//  Purpose:
//
//  Arguments:
//
//  Returns:
//
//---------------------------------------------------------------------------
VOID
BuildTimeString( IN FILETIME *FileTime, OUT TCHAR *szTimeString, IN DWORD cbSize )
{

    // ISSUE-2002/02/28-stelo- should probably strip all of this low-level Time stuff out of here
    //  and put in supplib

    FILETIME   LocalTime;
    SYSTEMTIME LastWriteSystemTime;
    HRESULT hrPrintf;

    FileTimeToLocalFileTime( FileTime, &LocalTime);

    FileTimeToSystemTime( &LocalTime, &LastWriteSystemTime );

    hrPrintf=StringCchPrintf( szTimeString, cbSize,
              _T("%s: %s, %s %d, %d, %d:%.2d:%.2d"),
              StrModified,
              rgDaysOfWeek[LastWriteSystemTime.wDayOfWeek],
              rgMonthsOfYear[LastWriteSystemTime.wMonth-1],
              LastWriteSystemTime.wDay,
              LastWriteSystemTime.wYear,
              LastWriteSystemTime.wHour,
              LastWriteSystemTime.wMinute,
              LastWriteSystemTime.wSecond );

}

//---------------------------------------------------------------------------
//
//  Function: CheckIfCancel
//
//  Purpose: Ask user "You sure you want to cancel the file copy"?
//           And if user says YES, jump the wizard to the unsucessful
//           completion page.
//
//  Returns:
//      TRUE  - wizard is now canceled, quit copying files
//      FALSE - user wants to keep trying
//
//---------------------------------------------------------------------------

BOOL CheckIfCancel(HWND hwnd)
{
    UINT iRet;

    iRet = ReportErrorId(hwnd, MSGTYPE_YESNO, IDS_WARN_COPY_CANCEL);

    if ( iRet == IDYES ) {
        PostMessage(GetParent(hwnd),
                    PSM_SETCURSELID,
                    (WPARAM) 0,
                    (LPARAM) IDD_FINISH2);
        return TRUE;
    }

    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Function: CopySingleFile
//
//  Purpose: Copies a file, does all error reporting and interacting with
//           the user.
//
//           If there are copy errors and the user cancels, this routine
//           cancels the whole wizard by jumping to the cancel page.  In
//           that case it returns FALSE.
//
//           After a file is successfully copied, gnFilesCopied will be
//           incremented and the gas-guage dlgproc will be notified.
//
//           Note that this code runs in the spawned thread.
//
//  Returns:
//      TRUE  if file was copied
//      FALSE if file was not copied (user canceled)
//
//---------------------------------------------------------------------------

BOOL CopySingleFile(HWND hwnd, LPTSTR Src, LPTSTR Dest)
{
    BOOL bRetry    = TRUE;
    UINT iRet, iRet2;
    static iOverwriteFiles = YES;
    HRESULT hrPrintf;

    // ISSUE-2002/02/28-stelo- I think this is actually going to have to be resolved so
    //  it doesn't mess up copies on an edit, when a distrib folder is
    //  already there, they just want to add files to it.

    //
    // ISSUE-2002/02/28-stelo- POSTPONED
    //
    // When we CopyFile from the CD, the readonly attribute is set on the
    // dest.  So we call SetFileAttributes and reset it.  If the user has
    // to redo the copy, he doesn't get a 1000 "Access Denied" errors.
    //
    // If the user cancels on the main wizard page, that thread jumps to
    // IDD_FINISH2.  This thread keeps running.
    //
    // When the user finally clicks the Finish button, this thread gets
    // terminated the hard way because WinMain() in thread0 exits.
    //
    // Due to this, there will frequently be a file at the dest that still
    // has the readonly bit set when user cancels on the main wizard page.
    //
    // To fix this, we would need to synchronize with the wizard having
    // been canceled and back out gracefully (before the user has time to
    // push the Finish button).
    //
    // Note that when the wizard is canceled because a copy error already
    // ocurred, thread1 (this thread) does the popping up and it is this
    // thread that jumps to IDD_FINISH2.  In this case we do back out
    // gracefully.  This bug only happens when the user presses Cancel
    // on the wizard page while the gas-guage is happily painting.
    //

    // ISSUE-2002/02/28-stelo- this function needs to be cleaned up.  To many if statements
    // scattered.  Don't make if conditional so long.
    if( iOverwriteFiles != YESTOALL )
    {

        if( DoesFileExist( Dest ) )
        {

            INT_PTR iRetVal;
            HANDLE hSrcFile;
            HANDLE hDestFile;
            DWORD dwSrcSize;
            DWORD dwDestSize;
            FILETIME LastWriteTimeSrc;
            FILETIME LastWriteTimeDest;
            SYSTEMTIME LastWriteSystemTime;

            if( iOverwriteFiles == NOTOALL )
            {

                //
                //  Give the illusion the file was copied
                //
                SendMessage( hwnd,
                             WMX_FILECOPIED,
                             (WPARAM) 0,
                             (LPARAM) 0 );

                gnFilesCopied++;

                return( TRUE );

            }

            hrPrintf=StringCchPrintf( g_szFileAlreadyExistsText, AS(g_szFileAlreadyExistsText),
                      StrFileAlreadyExists,
                      MyGetFullPath( Dest ) );

            //
            //  Open the files
            //
            hDestFile = CreateFile( Dest, GENERIC_READ, FILE_SHARE_READ, NULL,
                                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

            hSrcFile = CreateFile( Src, GENERIC_READ, FILE_SHARE_READ, NULL,
                                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

            GetFileTime( hSrcFile, NULL, NULL, &LastWriteTimeSrc );
            GetFileTime( hDestFile, NULL, NULL, &LastWriteTimeDest );

            // ISSUE-2002/02/28-stelo- need to display AM or PM, but what about other countries
            BuildTimeString( &LastWriteTimeSrc, g_szSrcFileDate, AS(g_szSrcFileDate) );
            BuildTimeString( &LastWriteTimeDest, g_szDestFileDate, AS(g_szSrcFileDate) );

            //
            //  Default to NO if file times are equal
            //
            if( CompareFileTime( &LastWriteTimeSrc, &LastWriteTimeDest ) < 0 )
            {
                g_SetFocusYes = FALSE;
            }
            else
            {
                g_SetFocusYes = TRUE;
            }

            // ISSUE-2002/02/28-stelo- doesn't handle file sized > 2^32 bytes, need to catch
            //   2nd parameter value
            dwSrcSize  = GetFileSize( hSrcFile, NULL );
            dwDestSize = GetFileSize( hDestFile, NULL );

            // ISSUE-2002/02/28-stelo- need to insert commas into size so it looks pretty
            hrPrintf=StringCchPrintf( g_szSrcFileSize,AS(g_szSrcFileSize), _T("%d %s"), dwSrcSize, StrBytes );
            hrPrintf=StringCchPrintf( g_szDestFileSize,AS(g_szDestFileSize), _T("%d %s"), dwDestSize, StrBytes );

            CloseHandle( hSrcFile  );
            CloseHandle( hDestFile );

            iRetVal = DialogBox( FixedGlobals.hInstance,
                                 (LPCTSTR) IDD_CONFIRM_FILE_REPLACE,
                                 hwnd,
                                 ConfirmFileReplaceDlgProc );

            if( iRetVal == NO )
            {

                //
                //  Give the illusion the file was copied
                //
                SendMessage( hwnd,
                             WMX_FILECOPIED,
                             (WPARAM) 0,
                             (LPARAM) 0 );

                gnFilesCopied++;

                return( TRUE );

            }
            else if( iRetVal == YESTOALL )
            {

                iOverwriteFiles = YESTOALL;

            }
            else if( iRetVal == NOTOALL )
            {

                iOverwriteFiles = NOTOALL;
            }
            else if( iRetVal == CANCEL )
            {

                return( FALSE );

            }
            //
            //  Not handling the YES case because that is the default, let this
            //  function proceed and overwrite the file.
            //

        }

    }

    do
    {

        if ( CopyFile( Src, Dest, FALSE ) )
        {

            SetFileAttributes(Dest, FILE_ATTRIBUTE_NORMAL);

            SendMessage(hwnd,
                        WMX_FILECOPIED,
                        (WPARAM) 0,
                        (LPARAM) 0);

            gnFilesCopied++;

            bRetry = FALSE;

        }
        else
        {

            iRet = ReportErrorId(hwnd,
                                 MSGTYPE_RETRYCANCEL | MSGTYPE_WIN32,
                                 IDS_ERR_COPY_FILE,
                                 Src, Dest);

            if ( iRet != IDRETRY ) {
                if ( CheckIfCancel(hwnd) )
                    return FALSE;
            }
        }

    } while ( bRetry );

    return TRUE;
}

//---------------------------------------------------------------------------
//
//  Function: CopyTheFiles
//
//  Purpose: Recursive routine to oversee the copying of the bits.
//
//  Returns:
//      TRUE if the whole tree was copied,
//      FALSE if user bailed on the tree copy
//
//      Note that in the FALSE case CopySingleFile would have caused
//      thread0 to the FINISH2 wizard page (unsuccessful completion)
//      and thread1 (this code) will back out without further copies.
//
//---------------------------------------------------------------------------

BOOL CopyTheFiles(HWND   hwnd,
                  LPTSTR SrcRootPath,
                  LPTSTR DestRootPath)
{
    LPTSTR SrcRootPathEnd  = SrcRootPath  + lstrlen(SrcRootPath);
    LPTSTR DestRootPathEnd = DestRootPath + lstrlen(DestRootPath);
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;
    BOOL bRet = TRUE;

    //
    // Look for * in this dir
    //

    if ( ! ConcatenatePaths(SrcRootPath, _T("*"), NULL) )
        return bRet;

    FindHandle = FindFirstFile(SrcRootPath, &FindData);

    if ( FindHandle == INVALID_HANDLE_VALUE )
        return bRet;

    do {

        *SrcRootPathEnd  = _T('\0');
        *DestRootPathEnd = _T('\0');

        //
        //  Don't copy the . and .. files (obviously)
        //  If we run across an unattend.txt, don't copy it
        //
        if ( ( lstrcmp(FindData.cFileName, _T(".") )  == 0 ) ||
             ( lstrcmp(FindData.cFileName, _T("..") ) == 0 ) ||
             ( LSTRCMPI( FindData.cFileName, _T("unattend.txt") ) == 0 ) )
            continue;

        if ( ! ConcatenatePaths(SrcRootPath,  FindData.cFileName, NULL) ||
             ! ConcatenatePaths(DestRootPath, FindData.cFileName, NULL) )
            continue;

        if ( ! (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ) {

            if ( ! CopySingleFile(hwnd, SrcRootPath, DestRootPath) ) {
                bRet = FALSE;
                goto CleanupAndReturn;
            }

        } else {

            //
            // Create the dir and recurse
            //

            if ( ! EnsureDirExists(DestRootPath) ) {

                UINT iRet;

                iRet = ReportErrorId(
                            hwnd,
                            MSGTYPE_RETRYCANCEL | MSGTYPE_WIN32,
                            IDS_ERR_CREATE_FOLDER,
                            DestRootPath);

                if ( iRet != IDRETRY ) {
                    if ( CheckIfCancel(hwnd) ) {
                        bRet = FALSE;
                        goto CleanupAndReturn;
                    }
                }
            }

            if ( ! CopyTheFiles(hwnd, SrcRootPath, DestRootPath) ) {
                bRet = FALSE;
                goto CleanupAndReturn;
            }
        }

    } while ( FindNextFile(FindHandle, &FindData) );

CleanupAndReturn:
    *SrcRootPathEnd  = _T('\0');
    *DestRootPathEnd = _T('\0');
    FindClose(FindHandle);

    return bRet;
}

//----------------------------------------------------------------------------
//
//  Function: AsyncTreeCopy
//
//  Purpose: The real thread entry
//
//  Args: VOID *Args - really COPY_THREAD_PARAMS *
//
//  Returns: 0
//
//----------------------------------------------------------------------------

UINT AsyncTreeCopy(VOID* Args)
{
    COPY_THREAD_PARAMS *InputArgs = (COPY_THREAD_PARAMS*) Args;

    TCHAR *CopySrc  = InputArgs->lpSourceBuffer;
    TCHAR *CopyDest = InputArgs->lpDestBuffer;
    HWND  hwnd      = InputArgs->hwnd;

    BOOL bRet;
    LONGLONG llSpaceNeeded, llSpaceAvail;

    //
    // Figure out how much disk space is needed to copy the CD.
    //

    ghDiskSpaceList = SetupCreateDiskSpaceList(0, 0, 0);
    if (ghDiskSpaceList == NULL)
    {
        TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);
    }
    
    CountSpaceNeeded(hwnd, CopySrc, CopyDest);

    //
    // Is there enough free space?
    //
    // NOTE:
    //
    // We give the user a retry_cancel, hopefully user can free up space
    // on the drive.
    //
    // We could popup and let them change the destpath.  However, we may
    // have copied files on the AdditionalDirs page.  So allowing them to
    // change the path means you need to check diskspace requirements for
    // OemFilesPath and treecopy it as well.  If we ever allow changing
    // OemFilesPath, then the script would have to be updated as well,
    // and it has already been written out.
    //
    // We could check way back on the DistFolder page.  But then we
    // would have to find the SourcePath before we know if it's a CD
    // or netpath and we couldn't know how much they might copy on the
    // AdditionalDirs page.
    //

    llSpaceNeeded =
            MySetupQuerySpaceRequiredOnDrive(ghDiskSpaceList, CopyDest);

    llSpaceAvail = MyGetDiskFreeSpace(CopyDest);

    if ( llSpaceAvail < llSpaceNeeded ) {

        UINT iRet;

        iRet = ReportErrorId(
                    hwnd,
                    MSGTYPE_RETRYCANCEL,
                    IDS_ERR_INSUFICIENT_SPACE,
                    CopyDest,                   // ISSUE-2002-02-28-stelo-
                    (UINT) (llSpaceNeeded / ONE_MEG),
                    (UINT) (llSpaceAvail  / ONE_MEG));

        if ( iRet != IDRETRY ) {
            if ( CheckIfCancel(hwnd) )
                goto CleanupAndReturn;
        }
    }

    //
    // Update the message on the wizard page and start copying the files
    //

    SetDlgItemText(hwnd, IDC_TEXT, StrCopyingFiles);

    if ( CopyTheFiles(hwnd, CopySrc, CopyDest) ) {
        SendMessage(hwnd, WMX_ENDCOPYING, (WPARAM) 0, (LPARAM) 0);
    }

    //
    // Cleanup and return
    //

CleanupAndReturn:
    SetupDestroyDiskSpaceList(ghDiskSpaceList);
    return 0;
}


//----------------------------------------------------------------------------
//
//  This section of code runs in thread0.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Function: TreeCopyNtSources
//
// Purpose: Entry point for copying the NT sources (either from CD or
//          a net path).
//
//          The dialog proc calls this one, and it takes care of the
//          details of spawning the thread.
//
// Arguments:
//      HWND hwnd       - window to receive copy notifications (the dlgproc)
//      UINT Message    - message to send on copy notifications (to dlgproc)
//      LPTSTR lpSource - root of copy source
//      LPTSTR lpDest   - root of copy dest
//
// Returns: void
//
// Notes:
//  - Input strings will not be modified.
//
//----------------------------------------------------------------------------

VOID TreeCopyNtSources(HWND   hwnd,
                       LPTSTR lpSource,
                       LPTSTR lpDest)
{
    DWORD    dwThreadId;
    HANDLE   hCopyThread;

    static COPY_THREAD_PARAMS ThreadParams;

    //
    // Fill in the ThreadParams and spawn it
    //
    
    // NTRAID#NTBUG9-551874-2002/02/27-stelo,swamip - CreateDistFolder, ShareTheDistFolder should use the code from OEM mode, reduce attack surface
    lstrcpyn(ThreadParams.lpSourceBuffer, lpSource,AS(ThreadParams.lpSourceBuffer));
    lstrcpyn(ThreadParams.lpDestBuffer,   lpDest, AS(ThreadParams.lpDestBuffer));

    MyGetFullPath(ThreadParams.lpSourceBuffer);
    MyGetFullPath(ThreadParams.lpDestBuffer);

    ThreadParams.hwnd = hwnd;

    hCopyThread = CreateThread(NULL,
                               0,
                               AsyncTreeCopy,
                               &ThreadParams,
                               0,
                               &dwThreadId);
}

//----------------------------------------------------------------------------
//
// Function: BuildCopyDestPath
//
// Purpose:
//
//     DestPath is assumed to be of MAX_PATH length
//
// Arguments:
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
BuildCopyDestPath( IN TCHAR *DestPath, IN DWORD cbSize )
{
    HRESULT hrCat;

    //
    //  If the dist folder begins with a drive letter, just use that
    //  If it is a UNC, then build the computer and share name and use that
    //
    if( WizGlobals.UncDistFolder[0] != _T('\\') )
    {

        lstrcpyn( DestPath, WizGlobals.UncDistFolder, cbSize );

    }
    else
    {

        GetComputerNameFromUnc( WizGlobals.UncDistFolder, DestPath, cbSize  );

        hrCat=StringCchCat( DestPath, cbSize, _T("\\") );
        hrCat=StringCchCat( DestPath, cbSize, WizGlobals.DistShareName );

    }
    
    hrCat=StringCchCat( DestPath, cbSize, _T("\\") );
    hrCat=StringCchCat( DestPath, cbSize, WizGlobals.Architecture );
}

//----------------------------------------------------------------------------
//
// Function: OnCopyFilesInitDialog
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnCopyFilesInitDialog( IN HWND hwnd )
{
    StrBuildingList = MyLoadString( IDS_COPYMSG1 );

    StrCopyingFiles = MyLoadString( IDS_COPYMSG2 );

    StrFileAlreadyExists = MyLoadString( IDS_FILE_ALREADY_EXISTS );

    StrModified = MyLoadString( IDS_MODIFIED );

    StrBytes = MyLoadString( IDS_BYTES );

    SetDlgItemText(hwnd, IDC_TEXT, StrBuildingList);

    //
    //  Load Months
    //

    StrJanuary   = MyLoadString( IDS_JANUARY );
    StrFebruary  = MyLoadString( IDS_FEBRUARY );
    StrMarch     = MyLoadString( IDS_MARCH );
    StrApril     = MyLoadString( IDS_APRIL );
    StrMay       = MyLoadString( IDS_MAY );
    StrJune      = MyLoadString( IDS_JUNE );
    StrJuly      = MyLoadString( IDS_JULY );
    StrAugust    = MyLoadString( IDS_AUGUST );
    StrSeptember = MyLoadString( IDS_SEPTEMBER );
    StrOctober   = MyLoadString( IDS_OCTOBER );
    StrNovember  = MyLoadString( IDS_NOVEMBER );
    StrDecember  = MyLoadString( IDS_DECEMBER );

    rgMonthsOfYear[0] = StrJanuary;
    rgMonthsOfYear[1] = StrFebruary;
    rgMonthsOfYear[2] = StrMarch;
    rgMonthsOfYear[3] = StrApril;
    rgMonthsOfYear[4] = StrMay;
    rgMonthsOfYear[5] = StrJune;
    rgMonthsOfYear[6] = StrJuly;
    rgMonthsOfYear[7] = StrAugust;
    rgMonthsOfYear[8] = StrSeptember;
    rgMonthsOfYear[9] = StrOctober;
    rgMonthsOfYear[10] = StrNovember;
    rgMonthsOfYear[11] = StrDecember;

    //
    //  Load Days of Week
    //

    StrSunday    = MyLoadString( IDS_SUNDAY );
    StrMonday    = MyLoadString( IDS_MONDAY );
    StrTuesday   = MyLoadString( IDS_TUESDAY );
    StrWednesday = MyLoadString( IDS_WEDNESDAY );
    StrThursday  = MyLoadString( IDS_THURSDAY );
    StrFriday    = MyLoadString( IDS_FRIDAY );
    StrSaturday  = MyLoadString( IDS_SATURDAY );

    rgDaysOfWeek[0] = StrSunday;
    rgDaysOfWeek[1] = StrMonday;
    rgDaysOfWeek[2] = StrTuesday;
    rgDaysOfWeek[3] = StrWednesday;
    rgDaysOfWeek[4] = StrThursday;
    rgDaysOfWeek[5] = StrFriday;
    rgDaysOfWeek[6] = StrSaturday;
    rgDaysOfWeek[7] = StrSunday;

}

//----------------------------------------------------------------------------
//
// Function: DlgCopyFilesPage
//
// Purpose: This is the dialog procedure the copy files page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgCopyFilesPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    UINT nPercent;
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnCopyFilesInitDialog( hwnd );

            break;

        case WMX_BEGINCOPYING:
            {
                TCHAR *SrcPath;
                TCHAR DestPath[MAX_PATH + 1];

                if ( WizGlobals.bCopyFromPath )
                    SrcPath = WizGlobals.CopySourcePath;
                else
                    SrcPath = WizGlobals.CdSourcePath;

                SendDlgItemMessage(hwnd,
                                   IDC_PROGRESS1,
                                   PBM_SETPOS,
                                   0,
                                   0);

                BuildCopyDestPath( DestPath, AS(DestPath) );

                TreeCopyNtSources(hwnd,
                                  SrcPath,
                                  DestPath);
            }
            break;

        case WMX_ENDCOPYING:

            SendDlgItemMessage(hwnd,
                               IDC_PROGRESS1,
                               PBM_SETPOS,
                               (WPARAM) 100,
                               0);

            PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_NEXT);

            //
            //  The CD is done copying so Auto-Advance to the next page
            //

            // ISSUE-2002/02/28-stelo- this works, but I should really go through
            //  RouteToProperPage or send a NEXT message but neither work
            PostMessage( GetParent(hwnd),
                         PSM_SETCURSELID,
                         (WPARAM) 0,
                         (LPARAM) IDD_FINISH );

            break;

        case WMX_FILECOPIED:
            nPercent = (gnFilesCopied * 100) / gnTotalFiles;
            SendDlgItemMessage(hwnd,
                               IDC_PROGRESS1,
                               PBM_SETPOS,
                               (WPARAM) nPercent,
                               0);
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        CancelTheWizard(hwnd);
                        break;

                    case PSN_SETACTIVE:
                        PropSheet_SetWizButtons(GetParent(hwnd), 0);
                        PostMessage(hwnd, WMX_BEGINCOPYING, 0, 0);
                        break;

                    // Can't go back in the wizard from here
                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}

//----------------------------------------------------------------------------
//
// Function: ConfirmFileReplaceDlgProc
//
// Purpose: Confirm file replace dialog proc.  Allows the user to chose to
//   overwrite the file, overwrite all files, do not overwrite or cancel the
//   copy all together. Runs in the copying thread's context
//
// Arguments: standard Win32 dialog proc arguments
//
// Returns:  the button the user pressed(Yes, Yes to All, No, Cancel)
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
ConfirmFileReplaceDlgProc( IN HWND     hwnd,
                           IN UINT     uMsg,
                           IN WPARAM   wParam,
                           IN LPARAM   lParam ) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            SetWindowText( GetDlgItem( hwnd, IDC_REPLACE_FILE_TEXT),
                           g_szFileAlreadyExistsText );

            SetWindowText( GetDlgItem( hwnd, IDC_SRC_FILE_DATE),
                           g_szSrcFileDate );

            SetWindowText( GetDlgItem( hwnd, IDC_SRC_FILE_SIZE),
                           g_szSrcFileSize );

            SetWindowText( GetDlgItem( hwnd, IDC_DEST_FILE_DATE),
                           g_szDestFileDate );

            SetWindowText( GetDlgItem( hwnd, IDC_DEST_FILE_SIZE),
                           g_szDestFileSize );

            if( g_SetFocusYes ) {
                SetFocus( GetDlgItem( hwnd, IDC_YES_BUTTON ) );
            }
            else {
                SetFocus( GetDlgItem( hwnd, IDC_NO_BUTTON ) );
            }

            break;

        }

        case WM_COMMAND: {

            int nButtonId = LOWORD( wParam );

            switch ( nButtonId ) {

                case IDC_YES_BUTTON:
                {
                    EndDialog( hwnd, YES );

                    break;
                }

                case IDC_YESTOALL:
                {
                    EndDialog( hwnd, YESTOALL );

                    break;
                }

                case IDC_NO_BUTTON:
                {
                    EndDialog( hwnd, NO );

                    break;
                }

                case IDC_NOTOALL:
                {
                    EndDialog( hwnd, NOTOALL );

                    break;
                }

                case IDCANCEL:
                {
                    if( CheckIfCancel( hwnd ) )
                    {
                        EndDialog( hwnd, CANCEL );
                    }

                    break;
                }

            }

        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\cmdlines.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      cmdlines.c
//
// Description:
//      Dialog proc for the cmdlines.txt page
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define MAX_CMDLINE  1024
#define CMD_FILENAME _T("cmdlines.txt")

static NAMELIST CmdLinesList = { 0 };

//----------------------------------------------------------------------------
//
// Function: SetPathToCmdlines
//
// Purpose:  Determines the path to the cmdlines.txt and set PathBuffer to it.
//           PathBuffer is assumed to be MAX_PATH long
//
// Arguments:  OUT TCHAR *PathBuffer - path to cmdlines.txt
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
SetPathToCmdlines( OUT TCHAR *PathBuffer, DWORD cbPath )
{

    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {
        TCHAR szDrive[MAX_PATH];
        TCHAR szSysprepPath[MAX_PATH] = _T("");

        ExpandEnvironmentStrings( _T("%SystemDrive%"),
                                  szDrive,
                                  MAX_PATH );

        ConcatenatePaths( szSysprepPath,
                          szDrive,
                          _T("\\sysprep\\i386\\$oem$"),
                          NULL );

        EnsureDirExists( szSysprepPath );

        lstrcpyn( PathBuffer, szSysprepPath, cbPath );
    }
    else
    {
        lstrcpyn( PathBuffer, WizGlobals.OemFilesPath, cbPath );
    }

}

//----------------------------------------------------------------------------
//
//  Function: LoadCmdLinesFile
//
//  Purpose: Loads the contents of cmdlines.txt into memory.
//
//----------------------------------------------------------------------------

VOID LoadCmdLinesFile(HWND hwnd)
{
    FILE  *fp;
    TCHAR CmdLineBuffer[MAX_CMDLINE + 1];
    TCHAR PathBuffer[MAX_PATH];

    ResetNameList(&CmdLinesList);

    SetPathToCmdlines( PathBuffer, AS(PathBuffer) );

    ConcatenatePaths(PathBuffer, CMD_FILENAME, NULL);

    if ( (fp = My_fopen(PathBuffer, _T("r") )) == NULL )
        return;

    //
    //  Add all the entries to the namelist except for the [Commands] line
    //

    while( My_fgets(CmdLineBuffer, MAX_CMDLINE, fp) != NULL ) {

        if( _tcsstr( CmdLineBuffer, _T("[Commands]") ) == NULL ) {

            AddNameToNameList( &CmdLinesList,
                               CleanSpaceAndQuotes( CmdLineBuffer ) );

        }

    }

    My_fclose(fp);
}

//----------------------------------------------------------------------------
//
//  Function: WriteCmdLinesFile
//
//  Purpose: Writes the contents of our in-memory cmdlines to disk.
//
//----------------------------------------------------------------------------

VOID WriteCmdLinesFile(HWND hwnd)
{
    UINT  i, nNames;
    UINT  iNumCmdLinesEntries;
    FILE  *fp;
    TCHAR PathBuffer[MAX_PATH], *pCommand;

    //
    //  If there are no command lines to write then don't create the
    //  cmdlines.txt file.
    //
    iNumCmdLinesEntries = GetNameListSize( &CmdLinesList );

    if( iNumCmdLinesEntries == 0 ) {
        return;
    }

    //
    // Keep trying to open cmdlines.txt until it's open or until the
    // user gives up
    //

    SetPathToCmdlines( PathBuffer, AS(PathBuffer) );

    ConcatenatePaths(PathBuffer, CMD_FILENAME, NULL);

    do {
        if ( (fp = My_fopen(PathBuffer, _T("w") )) == NULL ) {
            UINT iRet = ReportErrorId(
                            hwnd,
                            MSGTYPE_RETRYCANCEL | MSGTYPE_WIN32,
                            IDS_OPEN_CMDLINES_FAILED,
                            PathBuffer);
            if ( iRet != IDRETRY )
                return;
        } else
            break;

    } while ( TRUE );

    //
    // ISSUE-2002/02/28-stelo- Check return value from fputs
    //

    My_fputs( _T("[Commands]\n"), fp );

    //
    // Write out each command in CmdLinesList
    //

    for ( i = 0, nNames = GetNameListSize(&CmdLinesList);
          i < nNames;
          i++ ) {

        pCommand = GetNameListName(&CmdLinesList, i);
        My_fputs( _T("\""), fp );
        My_fputs(pCommand, fp);
        My_fputs( _T("\"\n"), fp );
    }

    My_fclose(fp);
}

//----------------------------------------------------------------------------
//
//  Function: GreyCmdLinesPage
//
//  Purpose: Greys out the remove button if nothing selected
//
//----------------------------------------------------------------------------

VOID GreyCmdLinesPage(HWND hwnd)
{
    INT_PTR  idx;
    HWND hCtrl = GetDlgItem(hwnd, IDC_REMOVECMD);

    idx = SendDlgItemMessage(hwnd,
                             IDC_CMDLIST,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    //
    // Grey the remove button unless something is selected
    //

    EnableWindow(hCtrl, idx != LB_ERR);
}

//----------------------------------------------------------------------------
//
//  Function: OnSelChangeCmdLines
//
//  Purpose: Called when user selects an item on the cmd list.  We need
//           to ungrey the remove button
//
//----------------------------------------------------------------------------

VOID OnCmdLinesSelChange(HWND hwnd)
{

    SetArrows( hwnd,
               IDC_CMDLIST,
               IDC_BUT_MOVE_UP,
               IDC_BUT_MOVE_DOWN );

    GreyCmdLinesPage(hwnd);

}

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveCmdLines
//
//  Purpose: Called at SETACTIVE time.  We load the current contents
//           of cmdline.txt into memory and display it.  We read the
//           file at SETACTIVE time so that the user has a way of
//           refreshing the display.
//
//----------------------------------------------------------------------------

VOID OnSetActiveCmdLines(HWND hwnd)
{
    UINT i, nNames;
    LPTSTR pNextName;

    //
    // Load cmdlines.txt into memory
    //

    LoadCmdLinesFile(hwnd);

    //
    // Reset the display to match what is in memory
    //

    SendDlgItemMessage(hwnd,
                       IDC_CMDLIST,
                       LB_RESETCONTENT,
                       (WPARAM) 0,
                       (LPARAM) 0);


    for ( i = 0, nNames = GetNameListSize(&CmdLinesList);
          i < nNames;
          i++ ) {

        pNextName = GetNameListName(&CmdLinesList, i);

        SendDlgItemMessage(hwnd,
                           IDC_CMDLIST,
                           LB_ADDSTRING,
                           (WPARAM) 0,
                           (LPARAM) pNextName);
    }

    GreyCmdLinesPage(hwnd);
}

//----------------------------------------------------------------------------
//
//  Function: OnAddCmdLine
//
//  Purpose: Called when user pushes ADD button.  Get command from
//           edit field and add it to the in-memory list.
//
//----------------------------------------------------------------------------

VOID OnAddCmdLine(HWND hwnd)
{
    TCHAR CmdBuffer[MAX_CMDLINE + 1];

    //
    // get the command the user typed in
    //

    GetDlgItemText(hwnd, IDT_CMDLINE, CmdBuffer, MAX_CMDLINE);

    //
    //  Don't add a blank command
    //

    if( CmdBuffer[0] == _T('\0') )
    {
        return;
    }

    //
    // display what the user typed-in in the listbox
    // and clear out the name the user typed
    //

    SendDlgItemMessage(hwnd,
                       IDC_CMDLIST,
                       LB_ADDSTRING,
                       (WPARAM) 0,
                       (LPARAM) CmdBuffer);

    SetArrows( hwnd,
               IDC_CMDLIST,
               IDC_BUT_MOVE_UP,
               IDC_BUT_MOVE_DOWN );

    SetDlgItemText( hwnd, IDT_CMDLINE, _T("") );

    SetFocus(GetDlgItem(hwnd, IDT_CMDLINE));
}

//----------------------------------------------------------------------------
//
//  Function: OnRemoveCmdLine
//
//  Purpose: Called when user pushes REMOVE button.  Get selected command
//           and remove it from display and memory.
//
//----------------------------------------------------------------------------

VOID OnRemoveCmdLine(HWND hwnd)
{
    TCHAR CmdBuffer[MAX_CMDLINE + 1];
    INT_PTR   idx, Count;

    //
    // Get users selection of the command to remove
    //

    idx = SendDlgItemMessage(hwnd,
                             IDC_CMDLIST,
                             LB_GETCURSEL,
                             (WPARAM) 0,
                             (LPARAM) 0);

    if ( idx == LB_ERR )
        return;

    //
    // Retrieve the name to remove from listbox
    //

    SendDlgItemMessage(hwnd,
                       IDC_CMDLIST,
                       LB_GETTEXT,
                       (WPARAM) idx,
                       (LPARAM) CmdBuffer);

    //
    // Remove it from the listbox display
    //

    SendDlgItemMessage(hwnd,
                       IDC_CMDLIST,
                       LB_DELETESTRING,
                       (WPARAM) idx,
                       (LPARAM) 0);

    //
    // Have to set a new selection.
    //

    Count = SendDlgItemMessage(hwnd,
                               IDC_CMDLIST,
                               LB_GETCOUNT,
                               (WPARAM) 0,
                               (LPARAM) 0);
    if ( Count ) {
        if ( idx >= Count )
            idx--;
        SendDlgItemMessage(hwnd,
                           IDC_CMDLIST,
                           LB_SETCURSEL,
                           (WPARAM) idx,
                           (LPARAM) 0);
    }

    SetArrows( hwnd,
               IDC_CMDLIST,
               IDC_BUT_MOVE_UP,
               IDC_BUT_MOVE_DOWN );

    //
    // There might be nothing selected now
    //

    GreyCmdLinesPage(hwnd);
}

//----------------------------------------------------------------------------
//
// Function: OnCommandLinesInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnCommandLinesInitDialog( IN HWND hwnd )
{

    //
    //  Set text limit
    //

    SendDlgItemMessage(hwnd,
                       IDT_CMDLINE,
                       EM_LIMITTEXT,
                       (WPARAM) MAX_CMDLINE,
                       (LPARAM) 0);

    SetArrows( hwnd,
               IDC_CMDLIST,
               IDC_BUT_MOVE_UP,
               IDC_BUT_MOVE_DOWN );

}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextCmdLines
//
//  Purpose: Called when user pushes NEXT button.  Write the file out.
//
//----------------------------------------------------------------------------

VOID OnWizNextCmdLines(HWND hwnd)
{
    INT_PTR i;
    INT_PTR iRetVal;
    INT_PTR iNumItems;
    TCHAR CmdBuffer[MAX_CMDLINE + 1];
    BOOL  bStayHere = FALSE;

    //
    // If the user typed something into the command field but failed to
    // ADD it, auto-add it
    //

    GetDlgItemText(hwnd, IDT_CMDLINE, CmdBuffer, MAX_CMDLINE + 1);

    if ( CmdBuffer[0] != _T('\0') )
        OnAddCmdLine(hwnd);


    //
    //  Store all the entries in the list box into the Command Lines namelist
    //

    iNumItems = SendDlgItemMessage( hwnd,
                                    IDC_CMDLIST,
                                    LB_GETCOUNT,
                                    (WPARAM) 0,
                                    (LPARAM) 0 );

    ResetNameList( &CmdLinesList );

    for( i = 0; i < iNumItems; i++ )
    {

        iRetVal = SendDlgItemMessage( hwnd,
                                      IDC_CMDLIST,
                                      LB_GETTEXT,
                                      (WPARAM) i,
                                      (LPARAM) CmdBuffer );

        if( iRetVal == LB_ERR )
        {
            AssertMsg( FALSE,
                       "Error adding items to namelist." );

            break;
        }

        AddNameToNameList(&CmdLinesList, CmdBuffer);

    }

    //
    // Write the cmd lines file and move the wizard on
    //

    WriteCmdLinesFile(hwnd);
}

//----------------------------------------------------------------------------
//
//  Function: DlgCommandLinesPage
//
//  Purpose: Dlg proc.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgCommandLinesPage(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnCommandLinesInitDialog( hwnd );
            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_ADDCMD:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnAddCmdLine(hwnd);
                        break;

                    case IDC_REMOVECMD:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRemoveCmdLine(hwnd);
                        break;

                    case IDC_CMDLIST:
                        if ( HIWORD(wParam) == LBN_SELCHANGE )
                            OnCmdLinesSelChange(hwnd);
                        break;

                    case IDC_BUT_MOVE_UP:

                        OnUpButtonPressed( hwnd, IDC_CMDLIST );

                        SetArrows( hwnd,
                                   IDC_CMDLIST,
                                   IDC_BUT_MOVE_UP,
                                   IDC_BUT_MOVE_DOWN );

                        break;


                    case IDC_BUT_MOVE_DOWN:

                        OnDownButtonPressed( hwnd, IDC_CMDLIST );

                        SetArrows( hwnd,
                                   IDC_CMDLIST,
                                   IDC_BUT_MOVE_UP,
                                   IDC_BUT_MOVE_DOWN );
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_ADDL_CMND;

                        if ( WizGlobals.iProductInstall == PRODUCT_UNATTENDED_INSTALL )
                            WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_FINISH);
                        else
                            WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                        OnSetActiveCmdLines(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        OnWizNextCmdLines(hwnd);
                        bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\distfold.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      distfold.c
//
// Description:
//      This file contains the dialog proc for the IDD_DISTFOLD page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include <lm.h>
#include <winnetwk.h>

static TCHAR *StrSelectDistFolder;
static TCHAR *StrWindowsDistibFolder;

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveDistFolder
//
//  Purpose: Called when the page is about to display.
//
//----------------------------------------------------------------------------

VOID
OnSetActiveDistFolder(HWND hwnd)
{
    SetDlgItemText(hwnd, IDT_DISTFOLDER, WizGlobals.DistFolder);
    SetDlgItemText(hwnd, IDT_SHARENAME,  WizGlobals.DistShareName);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}


//----------------------------------------------------------------------------
//
//  Function: ConvertRelativePathToUncPath
//
//  Purpose:  If the path is a local path or a network path, it is converted
//            to its UNC equivalent.  If the path is already a UNC path then
//            it is just copied and returned.  The output variable
//            UncDistFolder is assumed to be of MAX_PATH length.
//
//  Arguments:

//
//  Returns:  BOOL
//            TRUE -  on success,
//            FALSE - on failure
//
//----------------------------------------------------------------------------
BOOL
ConvertRelativePathToUncPath( IN const TCHAR *szRelativePath, 
                              OUT TCHAR *UncDistFolder,
                              IN DWORD cbSize) {
    
    TCHAR szLocalName[MAX_PATH];
    TCHAR szDistribFolderDirPath[MAX_PATH];
    TCHAR szUncPath[MAX_PATH];
    const TCHAR *pDirString;
    DWORD dwReturnValue;
    DWORD dwSize;
    HRESULT hrPrintf;

    //
    //  Check and see if it is already a UNC Path, just checking to see if it
    //  begins with a \
    //
    if( szRelativePath[0] == _T('\\') ) {

        lstrcpyn( UncDistFolder, szRelativePath, cbSize );

        return( TRUE );

    }

    if( IsPathOnLocalDiskDrive( szRelativePath ) )
    {

        const TCHAR *pDirPath;
        TCHAR szLocalComputerName[MAX_COMPUTERNAME_LENGTH + 1];
        HRESULT hrCat;

        dwSize = MAX_COMPUTERNAME_LENGTH + 1;

        if( ! GetComputerName( szLocalComputerName, &dwSize ) )
        {
            ReportErrorId( NULL,
                           MSGTYPE_ERR | MSGTYPE_WIN32,
                           IDS_ERR_CANNOT_GET_LOCAL_COMPNAME );
            
            return( FALSE );
        }

        hrPrintf=StringCchPrintf( UncDistFolder, cbSize, _T("\\\\%s\\"), szLocalComputerName );

        pDirPath = szRelativePath;

        //
        //  Set the dir path to just past the first \
        //
        pDirPath = pDirPath + 3;

        hrCat=StringCchCat( UncDistFolder, cbSize, pDirPath );

        return( TRUE );

    }
    else
    {

        hrPrintf=StringCchPrintf( szLocalName, AS(szLocalName), _T("%c:"), szRelativePath[0] );

        pDirString = szRelativePath + 3;

        lstrcpyn( szDistribFolderDirPath, pDirString, AS(szDistribFolderDirPath) );

        dwSize = StrBuffSize( szUncPath );

        dwReturnValue = WNetGetConnection( szLocalName, szUncPath, &dwSize );


        if( dwReturnValue == NO_ERROR ) {

            lstrcpyn( UncDistFolder, szUncPath, cbSize );

            // Note:ConcatenatePaths will truncate to avoid buffer overrun
            ConcatenatePaths( UncDistFolder,
                              szDistribFolderDirPath,
                              NULL );

            return( TRUE );

        }
        else if( dwReturnValue == ERROR_BAD_DEVICE ) {

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_BAD_DEVICE );

        }
        else if( dwReturnValue == ERROR_NOT_CONNECTED ) {

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_NOT_CONNECTED );

        }
        else if( dwReturnValue == ERROR_CONNECTION_UNAVAIL ) {

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_CONNECTION_UNAVAIL );

        }
        else if( dwReturnValue == ERROR_NO_NETWORK ) {

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_NO_NETWORK );

        }
        else if( dwReturnValue == ERROR_NO_NET_OR_BAD_PATH ) {

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_NO_NETWORK );

        }
        else if( dwReturnValue == ERROR_EXTENDED_ERROR ) {

            TCHAR szErrorString[MAX_STRING_LEN];
            TCHAR szProviderName[MAX_STRING_LEN];
            TCHAR szErrorCode[MAX_STRING_LEN];
            DWORD dwErrorCode;        
            DWORD dwErrorSize    = StrBuffSize( szErrorString );
            DWORD dwProviderSize = StrBuffSize( szProviderName );

            WNetGetLastError( &dwErrorCode,
                              szErrorString,
                              dwErrorSize,
                              szProviderName,
                              dwProviderSize );

            _itot( dwErrorCode, szErrorCode, 10 );

            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_EXTENDED_ERROR,
                           szProviderName,
                           szErrorCode,
                           szErrorString );

        }
        else {

            //
            //  Unknown error
            //
            ReportErrorId( NULL,
                           MSGTYPE_ERR,
                           IDS_ERR_NETWORK_UNKNOWN_ERROR );


        }

        return( FALSE );

    }

}

// NTRAID#NTBUG9-551874-2002/02/27-stelo,swamip - CreateDistFolder, ShareTheDistFolder should use the code from OEM mode, reduce attack surface
//

//----------------------------------------------------------------------------
//
//  Function: CreateDistFolder
//
//  Purpose: Creates the distribution folder and reports any error.
//
//  Arguments:
//      HWND hwnd - current window
//
//  Returns:
//      TRUE  - all is ok
//      FALSE - the error was reported, stay on this page
//
//----------------------------------------------------------------------------

BOOL
CreateDistFolder(HWND hwnd)
{
    //
    // Don't just CreateDir in case user says d:\foo\bar\fud and 'foo'
    // doesn't exist.  We want to make foo and bar and fud for the user.
    //
    // On the other hand, if d:\foo\bar\fud already exists, we want to
    // report an error, because the user explicitly said "New Folder"
    // on the dialog.
    //
    // So, check if it's there first, then just go silently make everything
    // needed if it doesn't exist.  EnsureDirExists() will be silent in
    // the case that d:\foo\bar\fud already exists.
    //

    if ( DoesPathExist(WizGlobals.DistFolder) ) {

        UINT iRet;

        iRet = ReportErrorId(hwnd,
                             MSGTYPE_YESNO,
                             IDS_ERR_DISTFOLD_EXISTS,
                             WizGlobals.DistFolder);

        if ( iRet != IDYES )
            return FALSE;
    }

    if ( ! EnsureDirExists(WizGlobals.DistFolder) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERR_CREATING_DISTFOLD,
                      WizGlobals.DistFolder);
        return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function: CheckDistFolder
//
//  Purpose: This function is called only by OnWizNextDistFolder.  It
//           assumes that WizGlobals.DistFolder is up to date.  We
//           create a folder or check if one exists as the user asks.
//
//  Returns:
//      FALSE - Problems, don't let wizard proceed
//      TRUE  - All is cool, go to the next page
//
//  Notes:
//      - This routine directly reports any errors and prompts the
//        user as needed.
//
//----------------------------------------------------------------------------

BOOL
CheckDistFolder(HWND hwnd)
{

    TCHAR PathBuffer[MAX_PATH];

    //
    // If user selected a file instead of a folder, trap that now, (just
    // for a more informative error message).
    //

    if ( DoesFileExist(WizGlobals.DistFolder) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR,
                      IDS_ERR_FOLDER_IS_FILE,
                      WizGlobals.DistFolder);
        return FALSE;
    }

    if ( ! WizGlobals.bCreateNewDistFolder ) {

        //
        // We're trying to edit an existing distfolder.  Popup if
        //
        // 1. It doesn't exist OR
        // 2. Can't find dosnet.inf
        //
        // In the case of #1, make user change path or radio button.
        // In the case of #2, let user edit it anyway via YES/NO popup.
        //

        if ( ! DoesFolderExist(WizGlobals.DistFolder) ) {
            ReportErrorId(hwnd,
                          MSGTYPE_ERR,
                          IDS_ERR_FOLDER_NOT_EXIST,
                          WizGlobals.DistFolder);
            return FALSE;
        }

        //
        // If dosnet.inf doesn't exist, this isn't a distribution folder.
        // Note, this is a really minimal check.
        //

        lstrcpyn(PathBuffer, WizGlobals.DistFolder, AS(PathBuffer));
        ConcatenatePaths(PathBuffer, WizGlobals.Architecture, _T("dosnet.inf"), NULL);

        if ( ! DoesFileExist(PathBuffer) ) {

            UINT iRet;

            iRet = ReportErrorId(
                        hwnd,
                        MSGTYPE_YESNO,
                        IDS_ERR_NOT_VALID_DISTFOLD,
                        WizGlobals.DistFolder);

            if ( iRet != IDYES )
                return FALSE;
        }

    } else {

        //
        // We're creating a new distfolder.  Go do the work.
        //

        if ( ! CreateDistFolder(hwnd) )
            return FALSE;
    }

    return TRUE;
}

//--------------------------------------------------------------------------
//
//  Function: ShareTheDistFolder
//
//  Purpose: Called by the Next procedure to put up the share.
//
//--------------------------------------------------------------------------

BOOL
ShareTheDistFolder(HWND hwnd, TCHAR *UncDistFolder)
{
    LPTSTR pszServerPath;
    TCHAR  szServerName[MAX_PATH];
    NET_API_STATUS nas;
    SHARE_INFO_502 si502, *psi502;
    BOOL bStatus = TRUE;

    //
    // Query this computer for info about the sharename the user
    // just typed in.
    //

    nas = NetShareGetInfo(
                NULL,                       // this computer
                WizGlobals.DistShareName,   // shrname
                502,                        // amount of info
                (LPBYTE*) &psi502);         // the info (output)

    //
    // If this sharename is in use, we have to look at the directory that
    // is being shared.
    //

    if ( nas == NERR_Success ) {

        TCHAR szUncPath[MAX_PATH + 1];

        //
        // All is ok if this sharename is for the DistFolder
        // We have to check both the relative and the UNC path
        //

        if( ! ConvertRelativePathToUncPath( psi502->shi502_path, 
                                            szUncPath,
                                            AS(szUncPath)) )
        {
            lstrcpyn( szUncPath, psi502->shi502_path, AS(szUncPath) );
        }

        if ( lstrcmpi(WizGlobals.DistFolder, psi502->shi502_path) == 0 ||
             lstrcmpi(WizGlobals.DistFolder, szUncPath) == 0 ) {

            NetApiBufferFree(psi502);
            return TRUE;

        }

        //
        // The sharename is in use, however, it's being used by a
        // different directory.  Report an error telling user to enter
        // a different sharename.
        //

        ReportErrorId(hwnd,
                      MSGTYPE_ERR,
                      IDS_ERR_SHARENAME_INUSE,
                      WizGlobals.DistShareName);
        NetApiBufferFree(psi502);
        return FALSE;
    }

    //
    // Put up the share
    //

    si502.shi502_netname      = WizGlobals.DistShareName;
    si502.shi502_type         = STYPE_DISKTREE;
    si502.shi502_remark       = StrWindowsDistibFolder;
    si502.shi502_permissions  = 0;
    si502.shi502_max_uses     = SHI_USES_UNLIMITED;
    si502.shi502_current_uses = 0;
    si502.shi502_path         = WizGlobals.DistFolder;
    si502.shi502_passwd       = NULL;
    si502.shi502_reserved     = 0;
    si502.shi502_security_descriptor = NULL;

    //
    //  Set the server path to NULL if it is on the local machine, or the 
    //  computer name if it is on a remote machine
    //
    if( IsPathOnLocalDiskDrive(WizGlobals.DistFolder) ) {
        pszServerPath = NULL;
    }
    else {
        GetComputerNameFromUnc( UncDistFolder, 
                                szServerName,
                                AS(szServerName));

        pszServerPath = szServerName;
    }

    nas = NetShareAdd(pszServerPath,             
                      502,              // info-level
                      (LPBYTE) &si502,  // info-buffer
                      NULL);            // don't bother with parm

    //
    // If the NetShareAdd fails for some reason, report the error code
    // to the user and give the user a chance to continue the wizard
    // without enabling the share.  The user might not have privelege
    // to do this.
    //

    //
    // ISSUE-2002/02/27-stelo - The Net apis don't set GetLastError().  So how is one
    //         supposed to report the error message to the user, like
    //         'access denied'???
    //
    //         Run this test: Logon to an account without admin privelege.
    //         Now try to put up the share.  I bet the error message is
    //         useless.  This is a common scenario and should be addressed.
    //

    if ( nas != NERR_Success ) {

        UINT iRet;
        iRet = ReportErrorId(hwnd, MSGTYPE_YESNO, IDS_ERR_ENABLE_SHARE, nas);

        if ( iRet != IDYES )
            return FALSE;
    }

    return TRUE;
}

//----------------------------------------------------------------------------
//
// Function: OnDistFolderInitDialog
//
// Purpose:  
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnDistFolderInitDialog( IN HWND hwnd )
{

    //
    //  Load text strings
    //

    StrSelectDistFolder = MyLoadString( IDS_SELECT_DISTRIB_FOLDER );

    StrWindowsDistibFolder = MyLoadString( IDS_WINDOWS_DISTRIB_FOLDER );

    //
    //  Set the text limit on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDT_DISTFOLDER,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_DIST_FOLDER,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDT_SHARENAME,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_SHARENAME,
                        (LPARAM) 0 );

}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextDistFolder
//
//  Purpose: Called when user pushes the NEXT button
//
//----------------------------------------------------------------------------

BOOL
OnWizNextDistFolder(HWND hwnd)
{
    BOOL bResult     = TRUE;

    //
    // Get the control settings
    //

    GetDlgItemText(hwnd, IDT_DISTFOLDER, WizGlobals.DistFolder, MAX_DIST_FOLDER + 1);

    GetDlgItemText(hwnd,
                   IDT_SHARENAME,
                   WizGlobals.DistShareName,
                   MAX_SHARENAME + 1);

    //  ISSUE-2002/02/27-stelo - need to check they entered a valid distrib folder here, i.e. that it is a valid path (local or UNC)
    //  which of these are valid?
    //
    //     c
    //     c:
    //     c:\
    //     c\sdjf
    //     \somedir
    //     //somename
    //     asfdj
    //

    MyGetFullPath(WizGlobals.DistFolder);

    //
    //  Make sure they filled in the edit boxes
    //
    if( WizGlobals.DistFolder[0] == _T('\0') ) {
        ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_ENTER_DIST_FOLDER );

        bResult = FALSE;
    }
    if( WizGlobals.DistShareName[0] == _T('\0') ) {
        ReportErrorId( hwnd, MSGTYPE_ERR, IDS_ERR_ENTER_SHARENAME );

        bResult = FALSE;
    }

    if( !bResult ) {
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);

        return bResult;
    }

    // ISSUE-2002/02/27-stelo - if they specified a network path, it may take a while for the
    // connection to restore if they haven't used it in a while, we should probably
    // do a pop-up here to tell them we are looking for it

    //
    // Do some checking for the dist fold, create it if necessary, etc...
    //

    if ( ! CheckDistFolder(hwnd) )
        bResult = FALSE;

    if( ! ConvertRelativePathToUncPath( WizGlobals.DistFolder, 
                                        WizGlobals.UncDistFolder,
                                        AS(WizGlobals.UncDistFolder)) )
    {
        lstrcpyn( WizGlobals.UncDistFolder, WizGlobals.DistFolder, AS(WizGlobals.UncDistFolder) );
    }

    //
    // Share it out if we haven't already reported an error
    //

    if ( bResult ) {

        if ( ! ShareTheDistFolder( hwnd, WizGlobals.UncDistFolder ) ) {

            bResult = FALSE;

        }

    }

    //
    // If OemFilesPath doesn't have a value, give it one.
    //

    if ( bResult && WizGlobals.OemFilesPath[0] == _T('\0') ) {

        lstrcpyn( WizGlobals.OemFilesPath, WizGlobals.DistFolder, AS(WizGlobals.OemFilesPath) );


        //Note:ConcatenatePaths truncates to avoid buffer overrun
        ConcatenatePaths( WizGlobals.OemFilesPath,
                          WizGlobals.Architecture,
                          _T("$oem$"),
                          NULL );
    }

    //
    // Force creation of the $oem$ dir (if it doesn't exist already)
    //

    if ( bResult && ! EnsureDirExists(WizGlobals.OemFilesPath) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERR_CREATE_FOLDER,
                      WizGlobals.OemFilesPath);

        bResult = FALSE;
    }

    //
    // Route to the next wizard page
    //

    return bResult;
}

//---------------------------------------------------------------------------
//
//  Function: BrowseForDistFolder
//
//  Purpose: Calls SHBrowseForFolder to allow user to browse for a
//           distribution folder.
//
//  Arguments:
//      HWND   hwnd       - owning window
//      LPTSTR PathBuffer - MAX_PATH buffer to receive results
//
//  Returns: BOOL - success
//
//---------------------------------------------------------------------------

BOOL
BrowseForDistFolder(HWND hwnd, LPTSTR PathBuffer)
{
    BROWSEINFO   BrowseInf;
    LPITEMIDLIST lpIdList;
    UINT         ulFlags = BIF_EDITBOX  |
                           BIF_RETURNONLYFSDIRS;

    BrowseInf.hwndOwner      = hwnd; 
    BrowseInf.pidlRoot       = NULL;                // no initial root
    BrowseInf.pszDisplayName = PathBuffer;          // output
    BrowseInf.lpszTitle      = StrSelectDistFolder; 
    BrowseInf.ulFlags        = ulFlags; 
    BrowseInf.lpfn           = NULL;
    BrowseInf.lParam         = (LPARAM) 0;
    BrowseInf.iImage         = 0;                   // no image

    lpIdList = SHBrowseForFolder(&BrowseInf);

    //
    // Get the pathname out of this idlist returned and free up the memory
    //

    if ( lpIdList == NULL )
        return FALSE;

    SHGetPathFromIDList(lpIdList, PathBuffer);
    ILFreePriv(lpIdList);
    return TRUE;
}

//---------------------------------------------------------------------------
//
//  Function: OnBrowseDistFolder
//
//  Purpose: Called when user pushes the BROWSE button
//
//---------------------------------------------------------------------------

VOID
OnBrowseDistFolder(HWND hwnd)
{

    //
    // NTRAID#NTBUG9-551874-2002/02/27-stelo,swamip - CreateDistFolder, ShareTheDistFolder should use the code from OEM mode, reduce attack surface
    //
    if ( BrowseForDistFolder(hwnd, WizGlobals.DistFolder) ) {
        SendDlgItemMessage(hwnd,
                           IDT_DISTFOLDER,
                           WM_SETTEXT,
                           (WPARAM) MAX_PATH,
                           (LPARAM) WizGlobals.DistFolder);
    }
}

//----------------------------------------------------------------------------
//
// Function: DlgDistFolderPage
//
// Purpose: This is the dialog procedure IDD_DISTFOLDER.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK
DlgDistFolderPage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
           
            OnDistFolderInitDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId=LOWORD(wParam);

                switch ( nButtonId ) {

                    case IDC_BROWSE:

                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnBrowseDistFolder(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                // ISSUE-2002/02/27-stelo,swamip - should check for valid pointer (possible dereference)
                //
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_DIST_FLDR;

                        if ( (WizGlobals.iProductInstall != PRODUCT_UNATTENDED_INSTALL) ||
                              WizGlobals.bStandAloneScript)
                            WIZ_SKIP( hwnd );
                        else
                            OnSetActiveDistFolder(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextDistFolder(hwnd) )
                            WIZ_SKIP(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\maindlgs.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      maindlgs.c
//
// Description:
//      This file has dialog procedures for welcome and finish pages.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: OnWelcomeInitDialog
//
// Purpose:  
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
OnWelcomeInitDialog( IN HWND hwnd ) {

    LPWSTR  szCommandLineArguments;
    INT     argc;
    LPWSTR *argv;
    RECT    rc;
    LPTSTR  lpWelcomeText = NULL;

    SetWindowFont( GetDlgItem(hwnd, IDC_BIGBOLDTITLE),
                   FixedGlobals.hBigBoldFont,
                   TRUE );

    // Set the welcome text
    //
    if (lpWelcomeText = AllocateString(NULL, IDS_WELCOME_TEXT_CORP))
    {
        SetDlgItemText(hwnd, IDC_WELCOME_TEXT, lpWelcomeText);
        FREE(lpWelcomeText);
    }

    FixedGlobals.ScriptName[0] = _T('\0');

    szCommandLineArguments = GetCommandLine();

    argv = CommandLineToArgvW( szCommandLineArguments, &argc );

    if( argv == NULL ) {

        //
        //  If I can't get the command line, then do nothing
        //
        return;

    }

    //
    //  If they passed an answerfile on the command line, then jump to the
    //  load wizard page
    //

    if( argc > 1 ) {

        lstrcpyn( FixedGlobals.ScriptName, argv[1], AS(FixedGlobals.ScriptName) );

        PostMessage( GetParent( hwnd ),
                     PSM_SETCURSELID,
                     (WPARAM) 0,
                     (LPARAM) IDD_NEWOREDIT );

    }

    // Center the wizard.
    //
    if ( GetWindowRect(GetParent(hwnd), &rc) )
        SetWindowPos(GetParent(hwnd), NULL, ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2), ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2), 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);

}

//----------------------------------------------------------------------------
//
// Function: DlgWelcomePage
//
// Purpose: Dialog procedure for the welcome page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgWelcomePage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            // Not sure how to enable this on corp mode w/o the setupmgr.ini file,
            // so just don't give the option for now.
            //
            ShowWindow(GetDlgItem(hwnd, IDC_HIDE), SW_HIDE);

            if ( GET_FLAG(OPK_WELCOME) )
                WIZ_PRESS(hwnd, PSBTN_NEXT);
            else
            {
                SET_FLAG(OPK_WELCOME, TRUE);
                OnWelcomeInitDialog( hwnd );
            }

            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:
                        WIZ_BUTTONS(hwnd, PSWIZB_NEXT);

                        break;

                    case PSN_WIZNEXT:
                        bStatus = FALSE;
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}

#define NTEXTFIELDS 3

VOID
OnInitFinishPage(IN HWND hwnd)
{
    TCHAR *FileNames[NTEXTFIELDS], *p;
    int i,j;

    SetWindowFont(GetDlgItem(hwnd, IDC_BIGBOLDTITLE),
        FixedGlobals.hBigBoldFont,
        TRUE);

    //
    // Put the filenames we want to display into an array and squish out
    // the null strings
    //

    FileNames[0] = FixedGlobals.ScriptName;
    FileNames[1] = FixedGlobals.UdfFileName;
    FileNames[2] = FixedGlobals.BatchFileName;

    for ( i=0; i<NTEXTFIELDS; i++ ) {
        if ( FileNames[i] == NULL || FileNames[i][0] == _T('\0') ) {
            for ( j=i; j<NTEXTFIELDS-1; j++ ) {
                FileNames[j] = FileNames[j+1];
            }
            FileNames[j] = NULL;
        }
    }

    SetDlgItemText( hwnd, IDC_FILENAME1, (p = FileNames[0]) ? p : _T("") );
    SetDlgItemText( hwnd, IDC_FILENAME2, (p = FileNames[1]) ? p : _T("") );
    SetDlgItemText( hwnd, IDC_FILENAME3, (p = FileNames[2]) ? p : _T("") );

    // Show the batch example message if we have a batch file
    //
    ShowWindow(GetDlgItem(hwnd, IDC_BATCHTEXT), FixedGlobals.BatchFileName[0] ? SW_SHOW : SW_HIDE);
        
    //
    // ISSUE-2002/02/28-stelo- In the case of remote boot, we need to change the text
    //         message at the bottom of this page about the batch script
    //         Need to tell them to use the ris admin tool to enable
    //         the answer file.
    //

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_FINISH);
}

//----------------------------------------------------------------------------
//
// Function: DlgFinishPage
//
// Purpose: Dialog procedure for the finish page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgFinishPage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnInitFinishPage(hwnd);
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    //
                    // ISSUE-2002/02/28-stelo- A cancel button on the successful completion
                    //         page doesn't make alot of sense either.
                    //         What do other good wizards do???
                    //

                    case PSN_QUERYCANCEL:
                        CancelTheWizard(hwnd);
                        break;

                    case PSN_SETACTIVE:
                        break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZFINISH:
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}

//----------------------------------------------------------------------------
//
// Function: DlgFinish2Page
//
// Purpose: Unsuccessful completion page
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgFinish2Page(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            SetWindowFont(GetDlgItem(hwnd, IDC_BIGBOLDTITLE),
                          FixedGlobals.hBigBoldFont,
                          TRUE);
            break;

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    //
                    // ISSUE-2002/02/28-stelo- What is the proper thing to do here?
                    //         Disable the cancel button?
                    //         Find out what other wizards do on the
                    //         unsuccessful completion page.
                    //

                    case PSN_QUERYCANCEL:
                        break;

                    case PSN_SETACTIVE:
                        PropSheet_SetWizButtons( 
                                GetParent(hwnd),
                                PSWIZB_FINISH );
                        break;

                    case PSN_WIZFINISH:
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\include\wizard.h ===
/****************************************************************************\

	WIZARD.H / OPK Wizard (OPKWIZ.EXE)

	Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

	Wizard header file for the OPK Wizard.  Contains the functions for
    creating the wizard.

	3/99 - Jason Cohen (JCOHEN)
        Added this new header file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


#ifndef _WIZARD_H_
#define _WIZARD_H_


//
// Include File(s):
//
#include <htmlhelp.h>
#include <commctrl.h>
#include "jcohen.h"


//
// External Macros:
//

#define WIZ_RESULT(hwnd, result) \
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result)

#define WIZ_SKIP(hwnd) \
            WIZ_RESULT(hwnd, -1)

#define WIZ_FAIL(hwnd) \
            WIZ_SKIP(hwnd)

#define WIZ_BUTTONS(hwnd, lparam) \
            SetWizardButtons(hwnd, lparam)

#define WIZ_CANCEL(hwnd) \
            ( ( (GET_FLAG(OPK_EXIT)) || (MsgBox(GetParent(hwnd), IDS_WARN_CANCEL_WIZARD, IDS_WIZARD_TITLE, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2 ) == IDYES) ) ? \
            ( (WIZ_RESULT(hwnd, 0)) ? TRUE : TRUE ) : \
            ( (WIZ_RESULT(hwnd, -1)) ? FALSE : FALSE ) )

#define WIZ_PRESS(hwnd, msg) \
            PostMessage(GetParent(hwnd), PSM_PRESSBUTTON, msg, 0L)

#define WIZ_EXIT(hwnd) \
            { \
                SET_FLAG(OPK_EXIT, TRUE); \
                WIZ_PRESS(hwnd, PSBTN_CANCEL); \
            }

#define WIZ_HELP() \
            g_App.hwndHelp = HtmlHelp(NULL, g_App.szHelpFile, HH_HELP_CONTEXT, GET_FLAG(OPK_OEM) ? g_App.dwCurrentHelp+200 : g_App.dwCurrentHelp)

#define WIZ_NEXTONAUTO(hwnd, msg) \
            { \
                if(GET_FLAG(OPK_AUTORUN))\
                {\
                    WIZ_PRESS(hwnd, msg);\
                }\
            }

#define DEFAULT_PAGE_FLAGS ( PSP_DEFAULT        | \
                             PSP_HASHELP        | \
                             PSP_USEHEADERTITLE | \
                             PSP_USEHEADERSUBTITLE )

//
// Type definitions
//

// Structure needed for Tree Dilogs
//
typedef struct _TREEDLG
{
    DWORD       dwResource;
    DLGPROC     dlgWindowProc;
    DWORD       dwTitle;
    DWORD       dwSubTitle;
    HWND        hWindow;
    HTREEITEM   hItem;
    BOOL        bVisible;
} TREEDLG, *PTREEDLG, *LPTREEDLG;


// Structure needed for Wizard Dilogs
//
typedef struct _WIZDLG
{
    DWORD       dwResource;
    DLGPROC     dlgWindowProc;
    DWORD       dwTitle;
    DWORD       dwSubTitle;
    DWORD       dwFlags;
} WIZDLG, *PWIZDLG, *LPWIZDLG;

// Structure needed for Wizard Dilogs
//
typedef struct _SPLASHDLG
{
    DWORD       dwResource;
    DLGPROC     dlgWindowProc;
    HWND        hWindow;
} SPLASHDLG, *PSPLASHDLG, *LPSPLASHDLG;

//
// External Function Prototype(s):
//

int CreateWizard(HINSTANCE, HWND);
int CreateMaintenanceWizard(HINSTANCE, HWND);
int CALLBACK WizardCallbackProc(HWND, UINT, LPARAM);
LONG CALLBACK WizardSubWndProc(HWND , UINT , WPARAM , LPARAM );
LRESULT CALLBACK MaintDlgProc(HWND, UINT, WPARAM, LPARAM);
static HTREEITEM TreeAddItem(HWND, HTREEITEM, LPTSTR);
void SetWizardButtons(HWND hwnd, DWORD dwButtons);


#endif // _WIZARD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\pch.h ===
#include "setupmgr.h"
#include "allres.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\platform.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      platform.c
//
// Description:  
//      This file contains the dialog procedure for the platform choice 
//      (IDD_WKS_OR_SRV).
//      
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "optcomp.h"

static PLATFORM_TYPES iBeginPlatform;

//----------------------------------------------------------------------------
//
// Function: AdjustNetSettingsForPlatform
//
// Purpose:  
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
AdjustNetSettingsForPlatform( VOID )
{

    NETWORK_COMPONENT *pNetComponent;
    NETWORK_COMPONENT *pNetwareClientComponent  = NULL;
    NETWORK_COMPONENT *pGatewayComponent        = NULL;

    //
    //  Only adjust the net settings if the platform changed while the user
    //  was on this page.
    //

    if( iBeginPlatform != WizGlobals.iPlatform )
    {
        for( pNetComponent = NetSettings.NetComponentsList;
             pNetComponent;
             pNetComponent = pNetComponent->next )
        {
            if( pNetComponent->iPosition == NETWARE_CLIENT_POSITION )
            {
                pNetwareClientComponent = pNetComponent;
            }

            if( pNetComponent->iPosition == GATEWAY_FOR_NETWARE_POSITION )
            {
                pGatewayComponent = pNetComponent;
            }

        }
        
        if( pNetwareClientComponent && pGatewayComponent )
        {

            if( WizGlobals.iPlatform == PLATFORM_WORKSTATION || WizGlobals.iPlatform == PLATFORM_PERSONAL)
            {
                pNetwareClientComponent->bInstalled = pGatewayComponent->bInstalled;
            }
            else if( WizGlobals.iPlatform == PLATFORM_SERVER || WizGlobals.iPlatform == PLATFORM_ENTERPRISE || WizGlobals.iPlatform == PLATFORM_WEBBLADE)
            {
                pGatewayComponent->bInstalled = pNetwareClientComponent->bInstalled;
            }
            else
            {
                AssertMsg( FALSE,
                           "Bad platform case");
            }
        }

    }

}

//----------------------------------------------------------------------------
//
// Function: OnPlatformSetActive
//
// Purpose:  
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
OnPlatformSetActive( IN HWND hwnd )
{

    int nButtonId = IDC_WORKSTATION;

    iBeginPlatform = WizGlobals.iPlatform;



    //
    //  Select the proper radio button
    //
    switch( WizGlobals.iPlatform ) {
        case PLATFORM_PERSONAL:
            nButtonId = IDC_PERSONAL;
            break;

        case PLATFORM_WORKSTATION:
            nButtonId = IDC_WORKSTATION;
            break;

        case PLATFORM_SERVER:
            nButtonId = IDC_SERVER;
            break;

        case PLATFORM_ENTERPRISE:
            nButtonId = IDC_ENTERPRISE;
            break;

        case PLATFORM_WEBBLADE:
            nButtonId = IDC_WEBBLADE;
            break;

        default:
            AssertMsg( FALSE,
                       "Invalid value for WizGlobals.iProductInstall" );
            break;
    }

    CheckRadioButton( hwnd,
                      IDC_WORKSTATION,
                      IDC_WEBBLADE,
                      nButtonId );

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextPlatform
//
// Purpose:  
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
OnWizNextPlatform( IN HWND hwnd ) {

    DWORD       dwCompItem          = 0,
                dwCompGroup         = 0;
    TCHAR       szAnswer[MAX_PATH]  = NULLSTR;
            

    if( IsDlgButtonChecked(hwnd, IDC_PERSONAL) )
    {
        WizGlobals.iPlatform = PLATFORM_PERSONAL;
    }
    else if( IsDlgButtonChecked(hwnd, IDC_WORKSTATION) )
    {
        WizGlobals.iPlatform = PLATFORM_WORKSTATION;
    }
    else if( IsDlgButtonChecked(hwnd, IDC_SERVER) )
    {
        WizGlobals.iPlatform = PLATFORM_SERVER;
    }
        else if( IsDlgButtonChecked(hwnd, IDC_ENTERPRISE) )
    {
        WizGlobals.iPlatform = PLATFORM_ENTERPRISE;
    }
    else if( IsDlgButtonChecked(hwnd, IDC_WEBBLADE) )
    {
        WizGlobals.iPlatform = PLATFORM_WEBBLADE;
    }
    else
    {
        WizGlobals.iPlatform = PLATFORM_WORKSTATION;
    }


    AdjustNetSettingsForPlatform();

#ifdef OPTCOMP
    //
    // Adjust defaults for windows components (only for unattended installations)
    //

    // Iterate through each of the components themselves
    //
    if ( WizGlobals.iProductInstall == PRODUCT_UNATTENDED_INSTALL )
    {

        // Iterate through each group to determine if this component is part of it
        //
        for(dwCompGroup=0;dwCompGroup<AS(s_cgComponentNames);dwCompGroup++)
        {
            // Check to see if this component is the correct platform, set it to true
            //
            if (s_cgComponentNames[dwCompGroup].dwDefaultSkus & WizGlobals.iPlatform)
            {
                // Set this component as a default
                //
                GenSettings.dwWindowsComponents |= s_cgComponentNames[dwCompGroup].dwComponents;
            }
        }


        // Iterate through each of the components
        //
        for(dwCompItem=0;dwCompItem<AS(s_cComponent);dwCompItem++)
        {
                   
            // We read in a script during the load process, let's write back the components that were specified in the file
            //
            if ( FixedGlobals.ScriptName[0] )
            {
                // Attemp to grab this component from the file
                //
                GetPrivateProfileString(_T("Components"), s_cComponent[dwCompItem].lpComponentString, NULLSTR, szAnswer, AS(szAnswer), FixedGlobals.ScriptName);
            
                // Do we have a component?
                //
                if ( szAnswer[0] )
                {
                    // User did not want to install component
                    //
                    if ( LSTRCMPI(szAnswer, _T("On")) == 0 )
                    {
                        GenSettings.dwWindowsComponents |= s_cComponent[dwCompItem].dwComponent; 
                    }
                    else if ( LSTRCMPI(szAnswer, _T("Off")) == 0 ) 
                    {
                        GenSettings.dwWindowsComponents &= ~s_cComponent[dwCompItem].dwComponent; 

                    }
                }
            }
        }
    }
#endif
    
}

//----------------------------------------------------------------------------
//
// Function: DlgPlatformPage
//
// Purpose:  
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK 
DlgPlatformPage( IN HWND     hwnd,    
                 IN UINT     uMsg,        
                 IN WPARAM   wParam,    
                 IN LPARAM   lParam )
{   

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            // Set the default platform
            //
            if ( !WizGlobals.iPlatform )
                WizGlobals.iPlatform = PLATFORM_WORKSTATION;

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd);
                    
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_CHZ_PLAT;

                    OnPlatformSetActive( hwnd );

                    break;

                }
                case PSN_WIZBACK:
                    bStatus = FALSE;
                    break;

                case PSN_WIZNEXT:

                    OnWizNextPlatform( hwnd );
                    bStatus = FALSE;
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:

                    break;
            }


            break;
        }
            
        default: 
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\product.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      product.c
//
// Description:
//      This is the dlgproc for the Product page IDD_PRODUCT.  It asks
//      if your installing unattended/remote_install etc...
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: SetDistFolderNames
//
// Purpose:  Sets the values for the distribution folder name and share name
//           in the global variables depending on the product selection.
//
// Arguments: INT nProductToInstall
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
SetDistFolderNames( INT nProductToInstall ) {

    INT   iNumberOfCharsCopied;
    TCHAR chSystemDrive;
    TCHAR szWindowsPath[MAX_PATH]      =  _T("");
    TCHAR szDistFolderPath[MAX_PATH]   =  _T("");
    HRESULT hrCat;

    iNumberOfCharsCopied = GetWindowsDirectory( szWindowsPath, MAX_PATH );

    if( iNumberOfCharsCopied != 0 ) {
        szDistFolderPath[0] = szWindowsPath[0];
        szDistFolderPath[1] = _T('\0');
    }
    else {
        //
        //  Just guess it is the C drive if the GetWindowsDirectory function
        //  failed
        //
        szDistFolderPath[0] = _T('C');
        szDistFolderPath[1] = _T('\0');
    }

    if( nProductToInstall == PRODUCT_SYSPREP )
    {
        hrCat=StringCchCat( szDistFolderPath, AS(szDistFolderPath),  _T(":\\sysprep\\i386") );
    }
    else {
        hrCat=StringCchCat( szDistFolderPath, AS(szDistFolderPath), _T(":\\windist") );
    }

    //
    //  Only set the dist folders if they haven't been already set, like on an
    //  edit on an unattend.txt
    //
    if( WizGlobals.DistFolder[0] == _T('\0') ) {
        lstrcpyn( WizGlobals.DistFolder, szDistFolderPath, AS(WizGlobals.DistFolder) );
    }

    if( WizGlobals.DistShareName[0] == _T('\0') ) {
        lstrcpyn( WizGlobals.DistShareName,  _T("windist"), AS(WizGlobals.DistShareName) );
    }

}

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveProduct
//
//  Purpose: Called at SETACTIVE time.
//
//----------------------------------------------------------------------------

VOID OnSetActiveProduct(HWND hwnd)
{
    int nButtonId = IDC_UNATTENED_INSTALL;

    //
    //  Select the proper radio button
    //
    switch( WizGlobals.iProductInstall ) {

        case PRODUCT_UNATTENDED_INSTALL:
            nButtonId = IDC_UNATTENED_INSTALL;
            break;

        case PRODUCT_SYSPREP:
            nButtonId = IDC_SYSPREP;
            break;

        case PRODUCT_REMOTEINSTALL:
            nButtonId = IDC_REMOTEINSTALL;
            break;

        default:
            AssertMsg( FALSE,
                       "Invalid value for WizGlobals.iProductInstall" );
            break;
    }

    CheckRadioButton( hwnd,
                      IDC_UNATTENED_INSTALL,
                      IDC_SYSPREP,
                      nButtonId );

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextProduct
//
//  Purpose: Store the radio button setting in the appropriate global variable
//           and set the dist folder path depending on the option they chose.
//
//----------------------------------------------------------------------------
VOID 
OnWizNextProduct( HWND hwnd ) {

    INT iNewProductInstall;

    if( IsDlgButtonChecked(hwnd, IDC_UNATTENED_INSTALL) )
    {
        iNewProductInstall = PRODUCT_UNATTENDED_INSTALL;
    }
    else if( IsDlgButtonChecked(hwnd, IDC_SYSPREP) )
    {
        iNewProductInstall = PRODUCT_SYSPREP;
    }
    else if( IsDlgButtonChecked(hwnd, IDC_REMOTEINSTALL) )
    {
        iNewProductInstall = PRODUCT_REMOTEINSTALL;
    }
    else
    {
        iNewProductInstall = IDC_UNATTENED_INSTALL;
    }

    //
    //  If they picked a new product and the new product is sysprep then we
    //  have to delete all the computer names because sysprep only supports
    //  one computer name.
    //

    if( WizGlobals.iProductInstall != iNewProductInstall )
    {

        if( iNewProductInstall == PRODUCT_SYSPREP )
        {
            ResetNameList( &GenSettings.ComputerNames );
        }

    }

    WizGlobals.iProductInstall = iNewProductInstall;

    //
    //  Set the dist folder names based on product selection
    //
    SetDistFolderNames( WizGlobals.iProductInstall );

}

//----------------------------------------------------------------------------
//
//  Function: OnRadioButtonProduct
//
//  Purpose: Called when a radio button is pushed.
//
//----------------------------------------------------------------------------

VOID OnRadioButtonProduct(HWND hwnd, int nButtonId)
{
    CheckRadioButton(hwnd,
                     IDC_UNATTENED_INSTALL,
                     IDC_SYSPREP,
                     nButtonId);
}

//----------------------------------------------------------------------------
//
// Function: DlgProductPage
//
// Purpose: This is the dialog procedure the Product page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgProductPage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_UNATTENED_INSTALL:
                    case IDC_REMOTEINSTALL:
                    case IDC_SYSPREP:

                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRadioButtonProduct(hwnd, LOWORD(wParam));
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_PROD_INST;

                        // Set this flag so we get a prompt when user wants to cancel
                        //
                        SET_FLAG(OPK_EXIT, FALSE);
                        SET_FLAG(OPK_CREATED, TRUE);

                        OnSetActiveProduct(hwnd);
                        break;

                    case PSN_WIZNEXT:

                        OnWizNextProduct( hwnd );

                        bStatus = FALSE;

                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by main.rc
//
#define IDD_WELCOME                     2000
#define IDD_NEWOREDIT                   2001
#define IDD_PRODUCT                     2002
#define IDD_ADVANCED                    2003
#define IDD_STANDALONE                  2004
#define IDD_DISTFOLDER                  2005
#define IDD_ADDDIRS                     2006
#define IDD_CMDLINES                    2007
#define IDD_SAVESCRIPT                  2008
#define IDD_COPYFILES1                  2009
#define IDD_COPYFILES                   2010
#define IDD_FINISH                      2011
#define IDD_FINISH2                     2012
#define IDD_CONFIRM_FILE_REPLACE        2013
#define IDD_COPYING_LANG_FILES          2014
#define IDD_MULTIPLE_DOSNET_POPUP       2015
#define IDD_PLATFORM                    2016
#define IDC_TEXT                        2100
#define IDC_GREYTEXT                    2101
#define IDC_BROWSE                      2102
#define IDC_BIGBOLDTITLE                2200
#define IDC_BOLDTITLE                   2201
#define IDC_NEWSCRIPT                   2220
#define IDC_EDITSCRIPT                  2222
#define IDC_UNATTENED_INSTALL           2241
#define IDC_REMOTEINSTALL               2242
#define IDC_SYSPREP                     2243
#define IDC_ADVANCEDYES                 2260
#define IDC_ADVANCEDNO                  2261
#define IDC_DODISTFOLD                  2280
#define IDC_NODISTFOLD                  2281
#define IDC_MODDISTFOLD                 2282
#define IDT_DISTFOLDER                  2300
#define IDT_SHARENAME                   2301
#define IDC_NEWDISTFOLD                 2302
#define IDC_STANDALONE                  2304
#define IDC_DISTFOLD_TEXT               2305
#define IDC_FILETREE                    2320
#define IDC_ADDFILE                     2321
#define IDC_REMOVEFILE                  2322
#define IDC_ADDDIRS_DESCR               2323
#define IDT_CMDLINE                     2340
#define IDC_ADDCMD                      2341
#define IDC_REMOVECMD                   2342
#define IDC_CMDLIST                     2343
#define IDC_BUT_MOVE_UP                 2344
#define IDC_BUT_MOVE_DOWN               2345
#define IDT_SCRIPTNAME                  2360
#define IDT_SOURCEPATH                  2380
#define IDC_COPYFROMCD                  2381
#define IDC_COPYFROMPATH                2382
#define IDC_PROGRESS1                   2400
#define IDC_FILENAME1                   2420
#define IDC_FILENAME2                   2421
#define IDC_FILENAME3                   2422
#define IDC_BATCHTEXT                   2423
#define IDC_YES_BUTTON                  2440
#define IDC_YESTOALL                    2441
#define IDC_NO_BUTTON                   2442
#define IDC_NOTOALL                     2443
#define IDC_REPLACE_FILE_TEXT           2444
#define IDC_SRC_FILE_DATE               2445
#define IDC_DEST_FILE_DATE              2446
#define IDC_SRC_FILE_SIZE               2447
#define IDC_DEST_FILE_SIZE              2448
#define IDC_LB_DOSNET_PATHS             2460
#define IDC_WORKSTATION                 2500
#define IDC_SERVER                      2501
#define IDC_PERSONAL                    2502
#define IDC_ENTERPRISE                  2503
#define IDC_WEBBLADE                    2504
#define IDC_WELCOME_TEXT                2504
#define IDC_HIDE                        2505
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2505
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\newedit.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      newedit.c
//
// Description:
//      This file has the dialog proc for the New Or Edit Script page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
//  Function: GreyUnGreyNewEdit
//
//  Purpose: Greys/ungreys controls on this page.
//
//----------------------------------------------------------------------------

VOID GreyUnGreyNewEdit(HWND hwnd)
{
    BOOL bUnGrey = IsDlgButtonChecked(hwnd, IDC_EDITSCRIPT);

    EnableWindow(GetDlgItem(hwnd, IDT_SCRIPTNAME), bUnGrey);
    EnableWindow(GetDlgItem(hwnd, IDC_BROWSE),     bUnGrey);
    EnableWindow(GetDlgItem(hwnd, IDC_GREYTEXT),   bUnGrey);
}

//----------------------------------------------------------------------------
//
// Function: OnEditOrNewInitDialog
//
// Purpose:  
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
OnEditOrNewInitDialog( IN HWND hwnd ) {

    //
    //  If they specifed an answer file on the command line, then pre-fill
    //  this page with it
    //
    if( lstrcmp( FixedGlobals.ScriptName, _T("") ) != 0 ) {

        FixedGlobals.iLoadType = LOAD_FROM_ANSWER_FILE;

    }

}

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveNewOrEdit
//
//  Purpose: Called at SETACTIVE time.  Fill in the controls.
//
//----------------------------------------------------------------------------

VOID OnSetActiveNewOrEdit(HWND hwnd)
{
    int nButtonId = IDC_NEWSCRIPT;

    //
    // Map the current load type to a radio button
    //

    switch ( FixedGlobals.iLoadType ) {

        case LOAD_UNDEFINED:
        case LOAD_NEWSCRIPT_DEFAULTS:
            nButtonId = IDC_NEWSCRIPT;
            break;

        case LOAD_FROM_ANSWER_FILE:
            nButtonId = IDC_EDITSCRIPT;
            
            SetWindowText( GetDlgItem( hwnd, IDT_SCRIPTNAME ), 
                           FixedGlobals.ScriptName );
            
            break;

        default:
            AssertMsg(FALSE, "Bad case OnSetActiveNewEdit");
            break;
    }

    CheckRadioButton(hwnd,
                     IDC_NEWSCRIPT,
                     IDC_EDITSCRIPT,
                     nButtonId);

    GreyUnGreyNewEdit(hwnd);

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnRadioButtonNewOrEdit
//
//  Purpose: Called when a radio button is pushed.  Update
//           FixedGlobals.bEditScript & Grey/ungrey controls.
//
//----------------------------------------------------------------------------

VOID OnRadioButtonNewOrEdit(HWND hwnd, int nButtonId)
{
    CheckRadioButton(hwnd,
                     IDC_NEWSCRIPT,
                     IDC_EDITSCRIPT,
                     nButtonId);

    GreyUnGreyNewEdit(hwnd);
}

//----------------------------------------------------------------------------
//
//  Function: OnBrowseNewOrEdit
//
//  Purpose: Called when the browse button is pushed.
//
//----------------------------------------------------------------------------

VOID OnBrowseNewOrEdit(HWND hwnd)
{
    GetAnswerFileName(hwnd, FixedGlobals.ScriptName, FALSE);

    SendDlgItemMessage(hwnd,
                       IDT_SCRIPTNAME,
                       WM_SETTEXT,
                       (WPARAM) MAX_PATH,
                       (LPARAM) FixedGlobals.ScriptName);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextNewOrEdit
//
//  Purpose: Called when the Next button is pushed.  Retrieve the settings
//           of the controls and validate.
//
//----------------------------------------------------------------------------

BOOL OnWizNextNewOrEdit(HWND hwnd)
{

    BOOL bNewScript;
    BOOL bReturn  = TRUE;
    LOAD_TYPES NewLoadType;

    //
    // Figure out where the user wants to load answers from
    //

    if ( IsDlgButtonChecked(hwnd, IDC_NEWSCRIPT) )
    {
        NewLoadType = LOAD_NEWSCRIPT_DEFAULTS;

        bNewScript = TRUE;
    }
    else
    {
        NewLoadType = LOAD_FROM_ANSWER_FILE;

        bNewScript = FALSE;
    }

    //
    // If we're loading from an answer file, retrieve the filename.
    //

    if ( NewLoadType == LOAD_FROM_ANSWER_FILE ) {

        SendDlgItemMessage(hwnd,
                           IDT_SCRIPTNAME,
                           WM_GETTEXT,
                           (WPARAM) MAX_PATH,
                           (LPARAM) FixedGlobals.ScriptName);

        MyGetFullPath(FixedGlobals.ScriptName);

        if ( FixedGlobals.ScriptName[0] == _T('\0') ) {
            ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_ENTER_FILENAME);
            bReturn = FALSE;
        }
        
        if( bReturn )
        {

            INT nStrLen;
            TCHAR *pFileExtension;

            lstrcpyn( FixedGlobals.UdfFileName, FixedGlobals.ScriptName, AS(FixedGlobals.UdfFileName) );

            nStrLen = lstrlen( FixedGlobals.UdfFileName );

            pFileExtension = FixedGlobals.UdfFileName + ( nStrLen - 3 );

            lstrcpyn( pFileExtension, _T("udf"), AS(FixedGlobals.UdfFileName)-nStrLen+3);

        }

    }

    //
    // Load the answers
    //

    if ( bReturn ) {

        if ( ! LoadAllAnswers(hwnd, NewLoadType) )
        {
            bReturn = FALSE;
        }
        
    }

    FixedGlobals.iLoadType = NewLoadType;

    WizGlobals.bNewScript = bNewScript;

    return ( bReturn );
}

//----------------------------------------------------------------------------
//
// Function: DlgEditOrNewPage
//
// Purpose: Dialog procedure for the edit or new script page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgEditOrNewPage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch(uMsg) {

        case WM_INITDIALOG:

            OnEditOrNewInitDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId=LOWORD(wParam);

                switch ( nButtonId ) {

                    case IDC_NEWSCRIPT:
                    case IDC_EDITSCRIPT:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRadioButtonNewOrEdit(hwnd, nButtonId);
                        break;

                    case IDC_BROWSE:
                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnBrowseNewOrEdit(hwnd);
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_ANSW_FILE;

                        // Set this flag so we don't get a prompt when user wants to cancel
                        //
                        SET_FLAG(OPK_EXIT, TRUE);
                        SET_FLAG(OPK_CREATED, FALSE);

                        WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                        OnSetActiveNewOrEdit(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextNewOrEdit(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\stdalone.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      stdalone.c
//
// Description:
//      This file contains the dlgproc for the IDD_STANDALONE page.  This
//      is a simple YES/NO flow page.  If user says NO, we skip all of the
//      pages that edit a distribution folder.
//
//      Note the title of this page is "Distribution Folder", but internally,
//      it is IDD_STANDALONE.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

VOID
OnInitStandAlone(HWND hwnd)
{
    TCHAR *pText1, *pText2, *p;
    int nBytes, len;

    pText1 = MyLoadString(IDS_STANDALONE_TEXT1);
    pText2 = MyLoadString(IDS_STANDALONE_TEXT2);

    nBytes = ((len=lstrlen(pText1)) + lstrlen(pText2) + 1) * sizeof(TCHAR);

    if ( (p = malloc(nBytes)) == NULL )
        return;

    lstrcpyn(p,     pText1, (nBytes/sizeof(TCHAR)));
    lstrcpyn(p+len, pText2, ((nBytes/sizeof(TCHAR))-len));

    free(pText1);
    free(pText2);

    SetDlgItemText(hwnd, IDC_TEXT, p);
}

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveStandAlone
//
//  Purpose: Called at SETACTIVE time.  Init controls.
//
//----------------------------------------------------------------------------

VOID OnSetActiveStandAlone(HWND hwnd)
{
    int nButtonId = WizGlobals.bStandAloneScript ? IDC_NODISTFOLD
                                                 : IDC_DODISTFOLD;
    CheckRadioButton(hwnd,
                     IDC_DODISTFOLD,
                     IDC_MODDISTFOLD,
                     nButtonId);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnRadioButtonStandAlone
//
//  Purpose: Called when one of the radio buttons is pushed.
//
//----------------------------------------------------------------------------

VOID OnRadioButtonStandAlone(HWND hwnd, int nButtonId)
{
    CheckRadioButton(hwnd,
                     IDC_DODISTFOLD,
                     IDC_MODDISTFOLD,
                     nButtonId);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextStandAlone
//
//  Purpose: Called when NEXT button is pushed.
//
//----------------------------------------------------------------------------

BOOL OnWizNextStandAlone(HWND hwnd)
{

    WizGlobals.bStandAloneScript = IsDlgButtonChecked( hwnd, IDC_NODISTFOLD );
    WizGlobals.bCreateNewDistFolder = IsDlgButtonChecked(hwnd, IDC_DODISTFOLD);

    //
    //  Warn the user that if they have already picked files that need a
    //  distribution folder but then here have chosen not to create a distrib
    //  folder.
    //

    if( WizGlobals.bStandAloneScript )
    {

        INT iCount = GetNameListSize( &GenSettings.LanguageGroups );

        if( ( ( GenSettings.IeCustomizeMethod == IE_USE_BRANDING_FILE ) &&
                GenSettings.szInsFile[0] != _T('\0') ) ||
            ( iCount != 0 ) )
        {

            INT iRet;

            iRet = ReportErrorId( hwnd,
                                  MSGTYPE_YESNO,
                                  IDS_ERR_NEED_DIST_FOLDER_FOR_FILES  );

            if( iRet == IDNO )
            {
                return FALSE;
            }

        }

    }

    return TRUE;

}

//----------------------------------------------------------------------------
//
// Function: DlgStandAlonePage
//
// Purpose: This is the dialog procedure the IDD_ADVANCED1 page.  It simply
//          asks if the user wants to deal with advanced features or not.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgStandAlonePage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnInitStandAlone(hwnd);
            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {

                    case IDC_DODISTFOLD:
                    case IDC_MODDISTFOLD:
                    case IDC_NODISTFOLD:

                        if ( HIWORD(wParam) == BN_CLICKED )
                            OnRadioButtonStandAlone(hwnd, LOWORD(wParam));
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_DIST_FLDR;

                        if ( WizGlobals.iProductInstall != PRODUCT_UNATTENDED_INSTALL )
                            WIZ_SKIP( hwnd );
                        else
                            OnSetActiveStandAlone(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextStandAlone(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\appletlk.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      appletlk.c
//
// Description:
//      This file contains the property sheet and page procedures for the
//      Appletalk protocol property sheet.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define MAX_NETWORKNUMBER_LENGTH 8

PROPSHEETHEADER AppleTalk_pshead;
PROPSHEETPAGE   AppleTalk_pspage;

UINT CALLBACK
Appletalk_PropertiesPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );

int CALLBACK Appletalk_PropertySheetProc( IN HWND hwndDlg,
                                          IN UINT uMsg,
                                          IN LPARAM lParam );

INT_PTR CALLBACK Appletalk_PropertiesDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

//----------------------------------------------------------------------------
//
// Function: Appletalk_PropertySheetProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
int CALLBACK Appletalk_PropertySheetProc( IN HWND hwndDlg,
                                          IN UINT uMsg,
                                          IN LPARAM lParam )
{

    switch( uMsg )
    {

          case PSCB_INITIALIZED:
               // Process PSCB_INITIALIZED
               break;

          case PSCB_PRECREATE:
               // Process PSCB_PRECREATE
               break;

          default:
               // Unknown message
               break;

    }

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: Create_Appletalk_PropertySheet
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
BOOL
Create_Appletalk_PropertySheet( IN HWND hwndParent )
{

    // Initialize property sheet HEADER data
    ZeroMemory( &AppleTalk_pshead, sizeof( PROPSHEETHEADER ) );
    AppleTalk_pshead.dwSize  = sizeof( PROPSHEETHEADER );
    AppleTalk_pshead.dwFlags =  PSH_PROPSHEETPAGE    |
                                PSH_USECALLBACK      |
                                PSH_USEHICON         |
                                PSH_NOAPPLYNOW;
    AppleTalk_pshead.hwndParent  = hwndParent;
    AppleTalk_pshead.hInstance   = FixedGlobals.hInstance;
    AppleTalk_pshead.pszCaption  = g_StrAppletalkProtocolTitle;
    AppleTalk_pshead.nPages      = 1;
    AppleTalk_pshead.nStartPage  = 0;
    AppleTalk_pshead.ppsp        = &AppleTalk_pspage;
    AppleTalk_pshead.pfnCallback = Appletalk_PropertySheetProc;

    // Zero out property PAGE data
    ZeroMemory (&AppleTalk_pspage, 1 * sizeof( PROPSHEETPAGE) );

    AppleTalk_pspage.dwSize      = sizeof( PROPSHEETPAGE );
    AppleTalk_pspage.dwFlags     = PSP_USECALLBACK;
    AppleTalk_pspage.hInstance   = FixedGlobals.hInstance;
    AppleTalk_pspage.pszTemplate = MAKEINTRESOURCE(IDD_APPLETALK_GENERAL);
    AppleTalk_pspage.pfnDlgProc  = Appletalk_PropertiesDlgProc;
    AppleTalk_pspage.pfnCallback = Appletalk_PropertiesPageProc;

     // --------- Create & display property sheet ---------
     return PropertySheet( &AppleTalk_pshead ) ? TRUE : FALSE;
}

//----------------------------------------------------------------------------
//
// Function: Appletalk_PropertiesPageProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
UINT CALLBACK
Appletalk_PropertiesPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp )
{

    switch( uMsg )
    {

          case PSPCB_CREATE:
               return( 1 );

          case PSPCB_RELEASE:
               return( 0 );
    }

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: OnAppleTalkInitDialog
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog box
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnAppleTalkInitDialog( IN HWND hwnd )
{

    INT i;
    INT iZoneCount;
    INT_PTR iDefaultZoneIndex;
    TCHAR *pszZone;

    //
    //  Set the text limit on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_EB_NETWORKRANGE_FROM,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_NETRANGE_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_NETWORKRANGE_TO,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_NETRANGE_LEN,
                        (LPARAM) 0 );

    if( NetSettings.pCurrentAdapter->bEnableSeedRouting )
    {
        CheckDlgButton( hwnd, IDC_CB_ENABLESEEDING, BST_CHECKED );
    }
    else
    {
        CheckDlgButton( hwnd, IDC_CB_ENABLESEEDING, BST_UNCHECKED );
    }


    SetWindowText( GetDlgItem( hwnd, IDC_EB_NETWORKRANGE_FROM ),
                   NetSettings.pCurrentAdapter->szNetworkRangeFrom );

    SetWindowText( GetDlgItem( hwnd, IDC_EB_NETWORKRANGE_TO ),
                   NetSettings.pCurrentAdapter->szNetworkRangeTo );


    iZoneCount = GetNameListSize( &(NetSettings.pCurrentAdapter->ZoneList) );

    for( i = 0; i < iZoneCount; i++ )
    {

        pszZone = GetNameListName( &(NetSettings.pCurrentAdapter->ZoneList), i );

        SendDlgItemMessage( hwnd,
                            IDC_CB_DEFAULTZONE,
                            CB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pszZone );

        SendDlgItemMessage( hwnd,
                            IDC_LB_ZONELIST,
                            LB_INSERTSTRING,
                            (WPARAM) -1,
                            (LPARAM) pszZone );
    }

    iDefaultZoneIndex = SendDlgItemMessage( hwnd,
                                            IDC_CB_DEFAULTZONE,
                                            CB_FINDSTRING,
                                            (WPARAM) -1,
                                            (LPARAM) NetSettings.szDefaultZone );

    if( iDefaultZoneIndex != CB_ERR )
    {

        SendDlgItemMessage( hwnd,
                            IDC_CB_DEFAULTZONE,
                            CB_SETCURSEL,
                            iDefaultZoneIndex,
                            0 );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnAppleTalkApply
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog box
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnAppleTalkApply( IN HWND hwnd )
{

    INT i;
    INT_PTR iEntries;
    INT_PTR iDefaultZoneIndex;
    TCHAR szZone[MAX_ZONE_LEN + 1];

    if( IsDlgButtonChecked( hwnd, IDC_CB_ENABLESEEDING ) )
    {
        NetSettings.pCurrentAdapter->bEnableSeedRouting = TRUE;
    }
    else
    {
        NetSettings.pCurrentAdapter->bEnableSeedRouting = FALSE;
    }

    GetWindowText( GetDlgItem( hwnd, IDC_EB_NETWORKRANGE_FROM ),
                   NetSettings.pCurrentAdapter->szNetworkRangeFrom,
                   MAX_NETRANGE_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EB_NETWORKRANGE_TO ),
                   NetSettings.pCurrentAdapter->szNetworkRangeTo,
                   MAX_NETRANGE_LEN + 1 );


    iDefaultZoneIndex = SendDlgItemMessage( hwnd,
                                            IDC_CB_DEFAULTZONE,
                                            CB_GETCURSEL,
                                            0,
                                            0 );

    if( iDefaultZoneIndex != LB_ERR )
    {

        SendDlgItemMessage( hwnd,
                            IDC_CB_DEFAULTZONE,
                            CB_GETLBTEXT,
                            (WPARAM) iDefaultZoneIndex,
                            (LPARAM) NetSettings.szDefaultZone );


    }

    iEntries = SendDlgItemMessage( hwnd,
                                   IDC_LB_ZONELIST,
                                   LB_GETCOUNT,
                                   0,
                                   0 );

    if( iEntries == LB_ERR )
    {
        return;
    }

    for( i = 0; i < iEntries; i++ )
    {
        SendDlgItemMessage( hwnd,
                            IDC_LB_ZONELIST,
                            LB_GETTEXT,
                            (WPARAM) i,
                            (LPARAM) szZone );

        AddNameToNameList( &(NetSettings.pCurrentAdapter->ZoneList), szZone );
    }

}

//----------------------------------------------------------------------------
//
// Function: Appletalk_PropertiesDlgProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK Appletalk_PropertiesDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnAppleTalkInitDialog( hwnd );

            break;
        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch( pnmh->code ) {

                case PSN_APPLY: {

                    OnAppleTalkApply( hwnd );


                }

            }

            break;

        }    // end case WM_NOTIFY

        case WM_COMMAND: {

            WORD wNotifyCode = HIWORD( wParam ) ;
            WORD wButtonId   = LOWORD( wParam ) ;


            break;

        }

        default:

            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\main\savescr.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      savescr.c
//
// Description:
//      This is the dialog proc for the Save Script page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define DEFAULT_SCRIPT_NAME       _T("unattend.txt")
#define DEFAULT_REMBOOT_NAME      _T("remboot.sif")
#define DEFAULT_SYSPREP_NAME      _T("sysprep.inf")
#define DEFAULT_SYSPREP_BAT_NAME  _T("sysprep.bat")

static TCHAR *StrWinntSifText;

//----------------------------------------------------------------------------
//
// Function: AddEntryToRenameFile
//
// Purpose:  
//
// Arguments: 
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
AddEntryToRenameFile( const TCHAR *pszDirPath, 
                      const TCHAR *pszShortName, 
                      const TCHAR *pszLongName )
{

    TCHAR szQuotedLongName[MAX_PATH + 1];
    TCHAR szFullRenamePath[MAX_PATH + 1] = _T("");
    HRESULT hrPrintf;

    //
    //  Quote the long file name
    hrPrintf=StringCchPrintf( szQuotedLongName, AS(szQuotedLongName),
               _T("\"%s\""),
               pszLongName );
    //
    // Note:ConcatenatePaths truncates to avoid buffer overrun

    if( ! ConcatenatePaths( szFullRenamePath,
                            pszDirPath,
                            _T("$$Rename.txt"),
                            NULL ) )
    {
        return;
    }

    WritePrivateProfileString( pszDirPath, 
                               pszShortName, 
                               szQuotedLongName, 
                               szFullRenamePath );

}

//----------------------------------------------------------------------------
//
// Function: CreateRenameFiles
//
// Purpose:  Walk all the dirs of the given path and lower.  If there are any
//           long file names, put them in the $$Rename.txt file.
//
// Arguments: IN const TCHAR *pszDirPath - sub-dir to search for long filenames
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
CreateRenameFiles( IN const TCHAR *pszDirPath )
{

    HANDLE          FindHandle;
    WIN32_FIND_DATA FindData;
    TCHAR           *pszShortName;
    TCHAR           szLongPathAndFilename[MAX_PATH + 1];
    TCHAR           szShortPathAndFilename[MAX_PATH + 1];
    TCHAR           szAllFiles[MAX_PATH + 1]  = _T("");
    TCHAR           szNewPath[MAX_PATH + 1]   = _T("");

   // Note: ConcatenatePaths truncates to avoid buffer overrun
    if( ! ConcatenatePaths( szAllFiles, 
                            pszDirPath, 
                            _T("*"), 
                            NULL ) )
    {
        return;
    }

    //
    // Look for * in this dir
    //

    // ISSUE-2002/02/27-stelo,swamip - Clean up the FindFirstFile Logic
    FindHandle = FindFirstFile( szAllFiles, &FindData );

    if( FindHandle == INVALID_HANDLE_VALUE ) {

        return;

    }

    do {

        //
        // skip over the . and .. entries
        //
   
        if( 0 == lstrcmp( FindData.cFileName, _T(".") ) ||
            0 == lstrcmp( FindData.cFileName, _T("..") ) )
        {
            continue;
        }

        szLongPathAndFilename[0] = _T('\0');

        if( ! ConcatenatePaths( szLongPathAndFilename, 
                                pszDirPath, 
                                FindData.cFileName, 
                                NULL ) )
        {
            continue;
        }   

        if( ! GetShortPathName( szLongPathAndFilename, szShortPathAndFilename, MAX_PATH ) )
        {

            ReportErrorId(NULL,
                          MSGTYPE_ERR | MSGTYPE_WIN32,
                          IDS_DONTSPECIFYSETTING);

            continue;
        }

        pszShortName = MyGetFullPath( szShortPathAndFilename );
        
        //
        //  If the LFN and the short name are different, then add it to the
        //  rename file
        //
        if( pszShortName && ( lstrcmpi( FindData.cFileName, pszShortName ) != 0 ) )
        {
            AddEntryToRenameFile( pszDirPath, pszShortName, FindData.cFileName );
        }

        //
        // If this is a dir entry, recurse.
        //

        if( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        {

            //
            // Build the full pathname, if >= MAX_PATH, skip it
            //

            // Note: ConcatenatePaths truncates to avoid buffer overrun
            if( ! ConcatenatePaths( szNewPath, 
                                    pszDirPath, 
                                    FindData.cFileName, 
                                    NULL ) )
            {
                continue;
            }

            CreateRenameFiles( szNewPath );

            szNewPath[0] = _T('\0');

        }

    } while ( FindNextFile( FindHandle, &FindData ) );

    FindClose( FindHandle );

}

//----------------------------------------------------------------------------
//
//  Function: OnSetActiveSaveScript
//
//  Purpose: Init's the controls.
//
//----------------------------------------------------------------------------

VOID
OnSetActiveSaveScript(HWND hwnd)
{
    //
    // If there is no script name at all.  Put a default into the field
    // that includes the path to the current directory
    //

    if ( FixedGlobals.ScriptName[0] == _T('\0') ) {

        LPTSTR lpPath;
        LPTSTR lpFileName;

        if ( WizGlobals.iProductInstall == PRODUCT_REMOTEINSTALL ) {

            lpFileName = DEFAULT_REMBOOT_NAME;

        }
        else if( WizGlobals.iProductInstall == PRODUCT_SYSPREP ) {

            lpFileName = DEFAULT_SYSPREP_NAME;

        }
        else {

            lpFileName = DEFAULT_SCRIPT_NAME;

        }

        if( WizGlobals.bStandAloneScript ||
            ( ! WizGlobals.bStandAloneScript && WizGlobals.iProductInstall == PRODUCT_SYSPREP ) )
        {
            lpPath = FixedGlobals.szSavePath;
        }
        else
        {
            lpPath = WizGlobals.DistFolder;
        }

        // Note: ConcatenatePaths truncates to avoid buffer overrun
        ConcatenatePaths(FixedGlobals.ScriptName, lpPath, lpFileName, NULL);
    }

    //
    // Set the controls
    //

    SetDlgItemText(hwnd, IDT_SCRIPTNAME, FixedGlobals.ScriptName);

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
//  Function: OnWizNext
//
//  Purpose: Get user's input and validate
//
//----------------------------------------------------------------------------

BOOL
OnWizNextSaveScript(HWND hwnd)
{
    BOOL bResult = TRUE;

    //
    // Retrieve the pathname
    //

    GetDlgItemText(hwnd, IDT_SCRIPTNAME, FixedGlobals.ScriptName, MAX_PATH);

    //
    // Can't be empty
    //

    if ( FixedGlobals.ScriptName[0] == _T('\0') ) {
        ReportErrorId(hwnd, MSGTYPE_ERR, IDS_ERR_ENTER_FILENAME);
        bResult = FALSE;
    }

    //
    // Lookin' good, go try save the file(s) now
    //

    else {

        TCHAR   szFullPath[MAX_PATH]    = NULLSTR;
        LPTSTR  lpFind                  = NULL;

        //
        // ISSUE-2002/02/27-stelo,swamip - Investigate the call below. Seems to be not using the return value.
        // 
        MyGetFullPath(FixedGlobals.ScriptName);

        // We should create the path before we try and save the script file
        //
        if (GetFullPathName(FixedGlobals.ScriptName, AS(szFullPath), szFullPath, &lpFind) && szFullPath[0] && lpFind)
        {
            // Chop off the file part of the buffer
            //
            *lpFind = NULLCHR;

            // If the path does not exist, attempt to create the path
            //
            if ( !DirectoryExists(szFullPath) )
            {
            	  // 
            	  // ISSUE-2002/02/27-stelo,swamip - Need to chech the return value of CreatePath
            	  //
                CreatePath(szFullPath);
            }

        }

        if ( ! SaveAllSettings(hwnd) ) 
        {
            if (ERROR_CANCELLED == GetLastError())
            {
                PostMessage(GetParent(hwnd),
                            PSM_SETCURSELID,
                            (WPARAM) 0,
                            (LPARAM) IDD_FINISH2);
                return TRUE;            
            }
            else
            {
                bResult = FALSE;
            }            
        }
    }

    //
    //  If it is a sysprep, place a copy of the inf and batch files in the
    //  %systemdrive%\sysprep dir (most likely c:\sysprep)
    //
    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP ) {

        TCHAR szSysprepPath[MAX_PATH]             = _T("");
        TCHAR szSysprepPathAndFileName[MAX_PATH]  = _T("");

        ExpandEnvironmentStrings( _T("%SystemDrive%"), 
                                  szSysprepPath, 
                                  MAX_PATH );

        lstrcatn( szSysprepPath, _T("\\sysprep"), MAX_PATH );

        // Note: ConcatenatePaths truncates to avoid buffer overrun
        ConcatenatePaths( szSysprepPathAndFileName,
                          szSysprepPath,
                          DEFAULT_SYSPREP_NAME,
                          NULL );

        CopyFile( FixedGlobals.ScriptName, szSysprepPathAndFileName, FALSE );

        szSysprepPathAndFileName[0] = _T('\0');

        // Note: ConcatenatePaths truncates to avoid buffer overrun
        ConcatenatePaths( szSysprepPathAndFileName,
                          szSysprepPath,
                          DEFAULT_SYSPREP_BAT_NAME,
                          NULL );

        CopyFile( FixedGlobals.BatchFileName, szSysprepPathAndFileName, FALSE );

    }

    //
    //  Add the $$Rename.txt files where necessary
    //

    if( ! WizGlobals.bStandAloneScript && 
          WizGlobals.OemFilesPath[0] != _T('\0') )
    {
        CreateRenameFiles( WizGlobals.OemFilesPath );
    }

    return ( bResult );
}

//----------------------------------------------------------------------------
//
//  Function: OnBrowseSaveScript
//
//  Purpose: Takes care of the Browse... button push
//
//----------------------------------------------------------------------------

VOID OnBrowseSaveScript(HWND hwnd)
{
    //
    // Let user browse for a filename, then update the display with
    // the filename.
    //

    GetAnswerFileName(hwnd, FixedGlobals.ScriptName, TRUE);

    SendDlgItemMessage(hwnd,
                       IDT_SCRIPTNAME,
                       WM_SETTEXT,
                       (WPARAM) MAX_PATH,
                       (LPARAM) FixedGlobals.ScriptName);
}

//----------------------------------------------------------------------------
//
// Function: DlgSaveScriptPage
//
// Purpose: This is the dialog procedure the save script page.
//
//----------------------------------------------------------------------------

INT_PTR
CALLBACK
DlgSaveScriptPage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            // Activate the dialog
            //
            OnSetActiveSaveScript(hwnd);
	        
            //
            // ISSUE-2002/02/27-stelo,swamip - Never gets Freed 
            //
            StrWinntSifText = MyLoadString( IDS_WINNTSIF_TEXT );

            break;

        case WM_COMMAND:

            switch ( LOWORD(wParam) ) {

                case IDC_BROWSE:
                    if ( HIWORD(wParam) == BN_CLICKED )
                        OnBrowseSaveScript(hwnd);
                    break;


                case IDOK:
                    if ( OnWizNextSaveScript(hwnd) )
                        EndDialog(hwnd, TRUE);
                    break;

                case IDCANCEL:

                    EndDialog(hwnd, FALSE);
                    break;

                default:
                    bStatus = FALSE;
                    break;
            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;

                // ISSUE-2002/02/27-stelo,swamip - should check for valid pointer (possible dereference)
                //
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:
                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:
                        OnSetActiveSaveScript(hwnd);
                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:
                        if ( !OnWizNextSaveScript(hwnd) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\addevice.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      addevice.c
//
// Description:
//      This file contains the dialog proc for the add network component pop-up,
//      "Select Network Component Type" (IDD_LAN_COMPONENT_ADD).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define NUMBER_OF_TYPES_OF_COMPONENTS 3

//
//  prototypes
//

INT_PTR CALLBACK
SelectNetworkClientDlgProc( IN HWND     hwnd,
                            IN UINT     uMsg,
                            IN WPARAM   wParam,
                            IN LPARAM   lParam );

INT_PTR CALLBACK
SelectNetworkServiceDlgProc( IN HWND     hwnd,
                             IN UINT     uMsg,
                             IN WPARAM   wParam,
                             IN LPARAM   lParam );

INT_PTR CALLBACK
SelectNetworkProtocolDlgProc( IN HWND     hwnd,
                              IN UINT     uMsg,
                              IN WPARAM   wParam,
                              IN LPARAM   lParam );

static COMPONENT_TYPE CurrentSelection;        // holds the current selection in the list view

static NETWORK_COMPONENT rgListViewAddEntries[NUMBER_OF_TYPES_OF_COMPONENTS];

//----------------------------------------------------------------------------
//
// Function:  InitAddListView
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
BOOL
InitAddListView( HWND hDlg, HINSTANCE hInst )
{

    LV_ITEM lvI;                    // list view item structure
    HICON hIcon1, hIcon2, hIcon3;      // handles to icons
    HIMAGELIST hSmall;                // handle to image list for small icons
    HWND hListViewWnd;              // handle to list view window
    int index;

    hListViewWnd = GetDlgItem( hDlg, IDC_LVW_LAN_COMPONENTS );

    // Initialize the list view window
    // First initialize the image lists you will need:
    // create image list for the small icons
    hSmall = ImageList_Create(BITMAP_WIDTH, BITMAP_HEIGHT, ILC_MASK, 3, 0 );

     // Load the icons and add them to the image list
    hIcon1 = LoadIcon(hInst, MAKEINTRESOURCE(IDI_CLIENT));
    hIcon2 = LoadIcon(hInst, MAKEINTRESOURCE(IDI_SERVICE));
    hIcon3 = LoadIcon(hInst, MAKEINTRESOURCE(IDI_PROTOCOL));

    if (ImageList_AddIcon(hSmall, hIcon1) == -1)
        return FALSE ;
    if (ImageList_AddIcon(hSmall, hIcon2) == -1)
        return FALSE ;
    if (ImageList_AddIcon(hSmall, hIcon3) == -1)
        return FALSE ;


    // Be sure that all the icons were added
    if (ImageList_GetImageCount(hSmall) < 3)
        return FALSE ;

    // Associate the image list with the list view control
    ListView_SetImageList(hListViewWnd, hSmall, LVSIL_SMALL);

    // Finally, add the actual items to the control
    // Fill out the LV_ITEM structure for each of the items to add to the list
    // The mask specifies the the pszText, iImage, lParam and state
    // members of the LV_ITEM structure are valid
    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;

    for (index = 0; index < 3; index++) {
        lvI.iItem = index;
        lvI.iSubItem = 0;
        lvI.iImage = index;
        // The parent window is responsible for storing the text
        // The list view control will send an LVN_GETDISPINFO
        // when it needs the text to display
        lvI.pszText = LPSTR_TEXTCALLBACK;
        lvI.cchTextMax = MAX_ITEMLEN;
        lvI.lParam = (LPARAM)&rgListViewAddEntries[index];

        // Select the first item
        if (index == 0)
        {
            lvI.state = lvI.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
        }
        else  // leave the others unselected
        {
            lvI.state = lvI.stateMask = 0;
        }

        if (ListView_InsertItem(hListViewWnd, &lvI) == -1)
            return FALSE ;

    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function:  OnAddDeviceInitDialog
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnAddDeviceInitDialog( IN HWND hwnd )
{

    //
    //  Initialize the array for the list view by loading the string
    //  resources the properties field nor the installed flag is valid
    //  for this screen so just set it to a value
    //
    rgListViewAddEntries[0].StrComponentName = MyLoadString( IDS_CLIENT );
    rgListViewAddEntries[0].StrComponentDescription = MyLoadString( IDS_CLIENT_DESCRIPTION );
    rgListViewAddEntries[0].ComponentType = CLIENT;
    rgListViewAddEntries[0].bHasPropertiesTab = FALSE;
    rgListViewAddEntries[0].bInstalled = FALSE;

    rgListViewAddEntries[1].StrComponentName = MyLoadString( IDS_SERVICE );
    rgListViewAddEntries[1].StrComponentDescription = MyLoadString( IDS_SERVICE_DESCRIPTION );
    rgListViewAddEntries[1].ComponentType = SERVICE;
    rgListViewAddEntries[1].bHasPropertiesTab = FALSE;
    rgListViewAddEntries[1].bInstalled = FALSE;

    rgListViewAddEntries[2].StrComponentName = MyLoadString( IDS_PROTOCOL );
    rgListViewAddEntries[2].StrComponentDescription = MyLoadString( IDS_PROTOCOL_DESCRIPTION );
    rgListViewAddEntries[2].ComponentType = PROTOCOL;
    rgListViewAddEntries[2].bHasPropertiesTab = FALSE;
    rgListViewAddEntries[2].bInstalled = FALSE;

    InitAddListView(hwnd, FixedGlobals.hInstance);

    CurrentSelection = CLIENT;    // initialize the list view to the first one being selected

    // TODO: design issue, should there be a default description and if there is, should
    // the corresponding list view entry already be selected
    // Set the default description
    SetWindowText( GetDlgItem( hwnd, IDC_TXT_COMPONENT_DESC ),
                   rgListViewAddEntries[0].StrComponentDescription);

}

//----------------------------------------------------------------------------
//
// Function:  OnAddButtonClicked
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnAddButtonClicked( IN HWND hwnd )
{

    switch( CurrentSelection ) {

        INT_PTR iReturnValue;

        //
        // for each case it pops-up the appropriate dialog box and then passes
        // the return value back to the main LAN wizard page
        //
        case CLIENT: {

            iReturnValue = DialogBox( FixedGlobals.hInstance,
                                      (LPCTSTR)IDD_SELECT_CLIENT,
                                      hwnd,
                                      SelectNetworkClientDlgProc );

            EndDialog( hwnd, iReturnValue );

            break;

        }

        case SERVICE: {

            iReturnValue = DialogBox( FixedGlobals.hInstance,
                                      (LPCTSTR)IDD_SELECT_SERVICE,
                                      hwnd,
                                      SelectNetworkServiceDlgProc );

            EndDialog( hwnd, iReturnValue );

            break;

        }
        case PROTOCOL: {

            iReturnValue = DialogBox( FixedGlobals.hInstance,
                                      (LPCTSTR)IDD_SELECT_PROTOCOL,
                                      hwnd,
                                      SelectNetworkProtocolDlgProc );

            EndDialog( hwnd, iReturnValue );

            break;

        }

    }

}

//----------------------------------------------------------------------------
//
// Function:  NotifyHandler
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//            IN WPARAM wParam -
//            IN LPARAM lParam -
//
// Returns:  BOOL - whether the message was handled or not
//
//----------------------------------------------------------------------------
static BOOL
NotifyHandler( IN HWND hwnd, IN WPARAM wParam, IN LPARAM lParam )
{

    LPNMHDR pnmh = (LPNMHDR)lParam;
    LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
    NETWORK_COMPONENT *pListViewString = (NETWORK_COMPONENT *)(pLvdi->item.lParam);
    HWND hwndComponentDescription;
    HWND hButton;
    BOOL bStatus = TRUE;

    if( wParam == IDC_LVW_LAN_COMPONENTS )
    {

        switch(pLvdi->hdr.code)
        {
            case LVN_GETDISPINFO:
                pLvdi->item.pszText = pListViewString->StrComponentName;
                break;
        }

        switch(pNm->hdr.code)
        {
            case LVN_ITEMCHANGED:

                if( pNm->uNewState == SELECTED )  // test to see if a new item in the list has been selected
                {
                    CurrentSelection = pNm->iItem;

                    hwndComponentDescription = GetDlgItem( hwnd, IDC_TXT_COMPONENT_DESC );

                    SetWindowText( hwndComponentDescription,
                                   rgListViewAddEntries[CurrentSelection].StrComponentDescription );

                }

                break;

            case NM_DBLCLK:
            {

                NMITEMACTIVATE *pNmItemActivate = (NMITEMACTIVATE *) lParam;

                //
                // see if the user has double clicked inside the list view
                //

                if( pNm->hdr.idFrom == IDC_LVW_LAN_COMPONENTS )
                {

                    //
                    //  Make sure they actually clicked on an item and not just
                    //  empty space
                    //

                    if( pNmItemActivate->iItem != -1 )
                    {
                        OnAddButtonClicked( hwnd );
                    }

                }

                break;

            }

            default:

                bStatus = FALSE;

                break;

        }

    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
// Function:  AddDeviceDlgProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
AddDeviceDlgProc( IN HWND     hwnd,
                  IN UINT     uMsg,
                  IN WPARAM   wParam,
                  IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnAddDeviceInitDialog( hwnd );

            break;
        }

        case WM_COMMAND:
        {
            int nButtonId;

            switch ( nButtonId = LOWORD(wParam) ) {

                case IDC_PSB_COMPONENT_ADD:
                    OnAddButtonClicked( hwnd );
                    break;

                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;

                default:
                    bStatus = FALSE;
                    break;
            }
            break;
        }

        case WM_NOTIFY:

            bStatus = NotifyHandler( hwnd, wParam, lParam );

            break;

        default:

            bStatus = FALSE;

            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\domain.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      domain.c
//
// Description:
//      This file contains the dialog procedure for the domain join
//      page (IDD_DOMAINJ).      
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"



//----------------------------------------------------------------------------
//
// Function: DlgDomainJoinPage
//           DomainPageChangeAccount
//           DomainPageChangeWorkgroup
//
// Purpose: These are the dialog procedure and friends for the domain
//          join page
//
//----------------------------------------------------------------------------


//-------------------------------------------------------------------------
//
// Function: DomainPageChangeAccount
//
// Purpose: This function exists only to support the Domain Join page.
//          It is called whenever the user decides to create a computer
//          account (or not to).  This function handles checking
//          the box and all of the (un)greying activities that must occur.
//
//-------------------------------------------------------------------------

static VOID DomainPageChangeAccount(HWND hwnd, BOOL bCreateAccount)
{
    EnableWindow( GetDlgItem( hwnd, IDC_DOMAINACCT),       bCreateAccount );
    EnableWindow( GetDlgItem( hwnd, IDC_DOMAINPASSWD),     bCreateAccount );
    EnableWindow( GetDlgItem( hwnd, IDC_USERACCOUNTLABEL), bCreateAccount );
    EnableWindow( GetDlgItem( hwnd, IDC_ACCTNAMELABEL),    bCreateAccount );
    EnableWindow( GetDlgItem( hwnd, IDC_ACCTPSWDLABEL),    bCreateAccount );
    EnableWindow( GetDlgItem( hwnd, IDC_CONFIRMLABEL),     bCreateAccount );
    EnableWindow( GetDlgItem (hwnd, IDC_CONFIRMPASSWORD),  bCreateAccount );

    CheckDlgButton( hwnd,
                    IDC_CREATEACCT,
                    bCreateAccount ? BST_CHECKED : BST_UNCHECKED );
}

//-------------------------------------------------------------------------
//
// Function: DomainPageChangeWorkgroup
//
// Purpose: This function exists only to support the Domain Join page.
//          It is called whenever the user selectes DOMAIN instead of
//          workgroup and vice versa.  This function handles checking
//          the radio button and all of the (un)greying activities
//          that must occur.
//
//-------------------------------------------------------------------------

static VOID DomainPageChangeWorkGroup(HWND hwnd,
                                      BOOL bWorkGroup,
                                      BOOL bCreateAccount)
{
    BOOL bGreyAccountFields = FALSE;

    //
    // If workgroup is to be selected do the following:
    //      1. check the radio button
    //      2. ungrey the edit box for WORKGROUP
    //      3. grey the edit box for DOMAIN
    //      4. grey the check box for CREATE_ACCT
    //
    // If workgroup is not selected, then DOMAIN is.  In this case,
    // do the oppositte.
    //

    CheckRadioButton(hwnd,
                     IDC_RAD_WORKGROUP,
                     IDC_RAD_DOMAIN,
                     bWorkGroup ? IDC_RAD_WORKGROUP : IDC_RAD_DOMAIN);

    EnableWindow(GetDlgItem(hwnd, IDC_WORKGROUP),  bWorkGroup);
    EnableWindow(GetDlgItem(hwnd, IDC_DOMAIN),     !bWorkGroup);
    EnableWindow(GetDlgItem(hwnd, IDC_CREATEACCT), !bWorkGroup);

    //
    // The edit fields for the admin domain acct and passwd must be greyed
    // in the following cases:
    //      1. if workgroup is selected
    //      2. if domain is selected AND bCreateAccount checkbox is on.
    //
    // In other words, grey these always if workgroup is selected.  If
    // workgroup is not selected, grey or un-grey them depending on whether
    // that bCreateAccount check-box is on or not.
    //
    // Note that if !bWorkgroup, then the DOMAIN name has been selected.
    //

    if ( bWorkGroup || !bCreateAccount )
        bGreyAccountFields = TRUE;

    DomainPageChangeAccount(hwnd, !bGreyAccountFields);
}

//----------------------------------------------------------------------------
//
// Function:  OnDomainJoinInitDialog
//
// Purpose: 
//
// Arguments: 
//
// Returns: 
//
//----------------------------------------------------------------------------
VOID 
OnDomainJoinInitDialog( IN HWND hwnd ) {

    //
    //  Set the text limits on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_WORKGROUP,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_WORKGROUP_LENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_DOMAIN,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_DOMAIN_LENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_DOMAINACCT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_USERNAME_LENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_DOMAINPASSWD,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_DOMAIN_PASSWORD_LENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_CONFIRMPASSWORD,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_DOMAIN_PASSWORD_LENGTH,
                        (LPARAM) 0 );

}

//----------------------------------------------------------------------------
//
// Function:  OnDomainJoinSetActive
//
// Purpose: 
//
// Arguments: 
//
// Returns: 
//
//----------------------------------------------------------------------------
VOID 
OnDomainJoinSetActive( IN HWND hwnd ) {

    //
    //  Make sure the right radio button is checked and controls are greyed out
    //  properly
    //
    if( NetSettings.bWorkgroup ) {

        CheckRadioButton( hwnd, 
                          IDC_RAD_WORKGROUP, 
                          IDC_RAD_DOMAIN, 
                          IDC_RAD_WORKGROUP );

        DomainPageChangeWorkGroup( hwnd,
                                   TRUE,
                                   NetSettings.bCreateAccount );

    }
    else {

        CheckRadioButton( hwnd, 
                          IDC_RAD_WORKGROUP, 
                          IDC_RAD_DOMAIN, 
                          IDC_RAD_DOMAIN );

        DomainPageChangeWorkGroup( hwnd,
                                   FALSE,
                                   NetSettings.bCreateAccount );

    }

    //
    //  Always re-fill the edit controls with the proper data here because
    //  they might have reset or loaded from a new answer file
    //

    SendDlgItemMessage( hwnd,
                        IDC_WORKGROUP,
                        WM_SETTEXT,
                        (WPARAM) MAX_WORKGROUP_LENGTH,
                        (LPARAM) NetSettings.WorkGroupName );

    SendDlgItemMessage( hwnd,
                        IDC_DOMAIN,
                        WM_SETTEXT,
                        (WPARAM) MAX_DOMAIN_LENGTH,
                        (LPARAM) NetSettings.DomainName );

    SendDlgItemMessage( hwnd,
                        IDC_DOMAINACCT,
                        WM_SETTEXT,
                        (WPARAM) MAX_USERNAME_LENGTH,
                        (LPARAM) NetSettings.DomainAccount );

    SendDlgItemMessage( hwnd,
                        IDC_DOMAINPASSWD,
                        WM_SETTEXT,
                        (WPARAM) MAX_DOMAIN_PASSWORD_LENGTH,
                        (LPARAM) NetSettings.DomainPassword );

    SendDlgItemMessage( hwnd,
                        IDC_CONFIRMPASSWORD,
                        WM_SETTEXT,
                        (WPARAM) MAX_DOMAIN_PASSWORD_LENGTH,
                        (LPARAM) NetSettings.ConfirmPassword );

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT );

}

//----------------------------------------------------------------------------
//
// Function:  OnWizNextDomainPage
//
// Purpose: 
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  BOOL
//
//----------------------------------------------------------------------------
BOOL 
OnWizNextDomainPage( IN HWND hwnd ) {

    //
    // Retrieve all of the settings on this dialog but only
    // if they are valid
    //
    
    TCHAR szWorkgroupName[MAX_WORKGROUP_LENGTH + 1]          = _T("");
    TCHAR szDomainName[MAX_DOMAIN_LENGTH + 1]                = _T("");
    TCHAR szUsername[MAX_USERNAME_LENGTH + 1]                = _T("");
    TCHAR szDomainPassword[MAX_DOMAIN_PASSWORD_LENGTH + 1]   = _T("");
    TCHAR szConfirmPassword[MAX_DOMAIN_PASSWORD_LENGTH + 1]  = _T("");

    BOOL bResult = TRUE;

    // ISSUE-2002/02/28-stelo- the only error checking done now is to
    // make sure none of the valid fields are empty, when I do more rigourous
    // error checking, try to clean up this code
    if( IsDlgButtonChecked( hwnd, IDC_RAD_WORKGROUP ) ) {
    
        //  user selected to Join a Workgroup
        NetSettings.bWorkgroup = TRUE;
        
        //
        //  Get the Workgroup string
        //
        SendDlgItemMessage( hwnd,
                            IDC_WORKGROUP,
                            WM_GETTEXT,
                            (WPARAM) AS(szWorkgroupName),
                            (LPARAM) szWorkgroupName );
        
        //
        //  see if the string in szPassword is a valid Workgroup name
        //
        
        if( szWorkgroupName[0] != _T('\0') ) {
            
            lstrcpyn( NetSettings.WorkGroupName, szWorkgroupName, AS(NetSettings.WorkGroupName) );
            
        }
        else if( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED ) {  
        
            //
            // only report an error on fully unattended
            //
            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ENTERWORKGROUP ) ;
            
            bResult = FALSE;
            
        }
        else {
        
            lstrcpyn( NetSettings.WorkGroupName, _T(""), AS(NetSettings.WorkGroupName) );

        }
                        
    }
    else {
          
        //  user selected to Join a Domain
        NetSettings.bWorkgroup = FALSE;

        //
        //  Get the Domain string
        //
        SendDlgItemMessage( hwnd,
                            IDC_DOMAIN,
                            WM_GETTEXT,
                            (WPARAM) AS(szDomainName),
                            (LPARAM) szDomainName );
                            
        //
        //  see if the string in szBuffer is a valid Domain name
        //

        if( szDomainName[0] != _T('\0') ) {

            lstrcpyn( NetSettings.DomainName, szDomainName, AS(NetSettings.DomainName) );
            
        }
        else if( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED ) {  
            
            //
            // only report an error on fully unattended
            //
            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ENTERNTDOMAIN );
            
            bResult = FALSE;
            
        }
        else {

            lstrcpyn( NetSettings.DomainName, _T(""), AS(NetSettings.DomainName) );

        }
        
        if( IsDlgButtonChecked( hwnd, IDC_CREATEACCT ) ) {
        
            SendDlgItemMessage( hwnd,
                                IDC_DOMAINACCT,
                                WM_GETTEXT,
                                (WPARAM) AS(szUsername),
                                (LPARAM) szUsername );
            
            if( szUsername[0] != _T('\0') ) {

                lstrcpyn( NetSettings.DomainAccount, szUsername, AS(NetSettings.DomainAccount) );
                
            }
            else {
            
                //  don't print this error if we've already printed an error
                if( bResult ) {

                    ReportErrorId( hwnd,
                                   MSGTYPE_ERR,
                                   IDS_ENTERUSERNAME );
                
                    bResult = FALSE;

                }
                
            }

            SendDlgItemMessage( hwnd,
                                IDC_DOMAINPASSWD,
                                WM_GETTEXT,
                                (WPARAM) AS(szDomainPassword),
                                (LPARAM) szDomainPassword );
           
            SendDlgItemMessage( hwnd,
                                IDC_CONFIRMPASSWORD,
                                WM_GETTEXT,
                                (WPARAM) AS(szConfirmPassword),
                                (LPARAM) szConfirmPassword );

            if( lstrcmp( szDomainPassword, szConfirmPassword ) != 0 ) {

                //  don't print this error if we've already printed an error
                if(  bResult ) {

                    ReportErrorId( hwnd,
                                   MSGTYPE_ERR,
                                   IDS_PASSWORDS_DONT_MATCH ) ;
                
                    bResult = FALSE;

                }

            }
            else {
            
                //
                //  The only reason why we are saving the confirm password is so that
                //  the confirm edit box is cleared with the other boxes on a Reset
                //
                lstrcpyn( NetSettings.DomainPassword, szDomainPassword, AS(NetSettings.DomainPassword) );
                lstrcpyn( NetSettings.ConfirmPassword, szConfirmPassword, AS(NetSettings.ConfirmPassword) );
                
            }
 
        }
        
    }
    
    return ( bResult );

}

INT_PTR CALLBACK DlgDomainJoinPage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
        {

            OnDomainJoinInitDialog( hwnd );

            break;

        }

        case WM_COMMAND:
            {
                int nButtonId=LOWORD(wParam);

                switch ( nButtonId ) {

                    case IDC_RAD_WORKGROUP:

                        if ( HIWORD(wParam) == BN_CLICKED ) {

                            DomainPageChangeWorkGroup(
                                            hwnd,
                                            TRUE,
                                            NetSettings.bCreateAccount);
                        }
                        break;

                    case IDC_RAD_DOMAIN:

                        if ( HIWORD(wParam) == BN_CLICKED ) {

                            DomainPageChangeWorkGroup(
                                            hwnd,
                                            FALSE,
                                            NetSettings.bCreateAccount);
                        }
                        break;

                    case IDC_CREATEACCT:

                        if ( HIWORD(wParam) == BN_CLICKED ) {

                            NetSettings.bCreateAccount =
                                    IsDlgButtonChecked(hwnd, IDC_CREATEACCT);

                            DomainPageChangeAccount(
                                            hwnd,
                                            NetSettings.bCreateAccount);
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:

                        WIZ_CANCEL(hwnd);
                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_WKGP_DOMN;

                        OnDomainJoinSetActive( hwnd );

                        break;

                    case PSN_WIZBACK:
                        bStatus = FALSE;
                        break;

                    case PSN_WIZNEXT:

                        if ( !OnWizNextDomainPage( hwnd ) )
                            WIZ_FAIL(hwnd);
                        else
                            bStatus = FALSE;
                        break;
                   
                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\pch.h ===
#include "setupmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\msclient.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      msclient.c
//
// Description:
//
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

static TCHAR *StrWindowsNtLocator;
static TCHAR *StrDceDirectoryService;

PROPSHEETHEADER MSClient_pshead ;
PROPSHEETPAGE   MSClient_pspage ;

UINT CALLBACK
MSClient_PropertiesPageProc (HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
INT_PTR CALLBACK MSClient_PropertiesDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

//----------------------------------------------------------------------------
//
// Function: MSClient_PropertySheetProc
//
// Purpose:
//
//----------------------------------------------------------------------------
int CALLBACK MSClient_PropertySheetProc(HWND hwndDlg, UINT uMsg, LPARAM lParam)
     {
     switch (uMsg)
          {
          case PSCB_INITIALIZED :
               // Process PSCB_INITIALIZED
               break ;

          case PSCB_PRECREATE :
               // Process PSCB_PRECREATE
               break ;

          default :
               // Unknown message
               break ;
          }

     return 0 ;
     }

//----------------------------------------------------------------------------
//
// Function: Create_MSClient_PropertySheet
//
// Purpose:
//
//----------------------------------------------------------------------------
BOOL Create_MSClient_PropertySheet(HWND hwndParent) {

    // Initialize property sheet HEADER data
    ZeroMemory(&MSClient_pshead, sizeof (PROPSHEETHEADER));
    MSClient_pshead.dwSize  = sizeof (PROPSHEETHEADER);
    MSClient_pshead.dwFlags = PSH_PROPSHEETPAGE    |
                              PSH_USECALLBACK      |
                              PSH_USEHICON         |
                              PSH_NOAPPLYNOW;
    MSClient_pshead.hwndParent  = hwndParent;
    MSClient_pshead.hInstance   = FixedGlobals.hInstance;
    MSClient_pshead.pszCaption  = g_StrMsClientTitle;
    MSClient_pshead.nPages      = 1;
    MSClient_pshead.nStartPage  = 0;
    MSClient_pshead.ppsp        = &MSClient_pspage;
    MSClient_pshead.pfnCallback = MSClient_PropertySheetProc;

    // Zero out property PAGE data
    ZeroMemory(&MSClient_pspage, 1 * sizeof (PROPSHEETPAGE));

    MSClient_pspage.dwSize      = sizeof (PROPSHEETPAGE);
    MSClient_pspage.dwFlags     = PSP_USECALLBACK;
    MSClient_pspage.hInstance   = FixedGlobals.hInstance;
    MSClient_pspage.pszTemplate = MAKEINTRESOURCE(IDD_DLG_RPCCONFIG);
    MSClient_pspage.pfnDlgProc  = MSClient_PropertiesDlgProc;
    MSClient_pspage.pfnCallback = MSClient_PropertiesPageProc;

     // --------- Create & display property sheet ---------
     return( PropertySheet(&MSClient_pshead) ? TRUE : FALSE );
}

//----------------------------------------------------------------------------
//
// Function: MSClient_PropertiesPageProc
//
// Purpose:
//
//----------------------------------------------------------------------------
UINT CALLBACK
MSClient_PropertiesPageProc (HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
     {
     switch (uMsg)
          {
          case PSPCB_CREATE :
               return 1 ;

          case PSPCB_RELEASE :
               return 0;
          }

     return 0 ;
}

//----------------------------------------------------------------------------
//
// Function: OnMsClientInitDialog
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnMsClientInitDialog( IN HWND hwnd )
{

    INT  iIndex;
    BOOL bGreyNetworkAddress;

    //
    //  Load strings from resources
    //

    StrWindowsNtLocator    = MyLoadString( IDS_WINDOWS_NT_LOCATOR );
    StrDceDirectoryService = MyLoadString( IDS_DCE_DIR_SERVICE );

    //
    //    Fill Combo box with initial values
    //

    SendDlgItemMessage( hwnd,
                        IDC_CMB_NAMESERVICE,
                        CB_ADDSTRING,
                        (WPARAM) 0,
                        (LPARAM) StrWindowsNtLocator );

    SendDlgItemMessage( hwnd,
                        IDC_CMB_NAMESERVICE,
                        CB_ADDSTRING,
                        (WPARAM) 0,
                        (LPARAM) StrDceDirectoryService );


    if( NetSettings.NameServiceProvider == MS_CLIENT_WINDOWS_LOCATOR )
    {
        iIndex = 0;

        bGreyNetworkAddress = FALSE;
    }
    else if( NetSettings.NameServiceProvider == MS_CLIENT_DCE_CELL_DIR_SERVICE )
    {
        iIndex = 1;

        SetWindowText( GetDlgItem( hwnd, IDC_EDT_NETADDRESS ),
                       NetSettings.szNetworkAddress );

        bGreyNetworkAddress = TRUE;
    }
    else
    {
        AssertMsg( FALSE,
                   "Invalid case for NameServiceProvider" );

        iIndex = 0;

        bGreyNetworkAddress = FALSE;
    }

    SendDlgItemMessage( hwnd,
                        IDC_CMB_NAMESERVICE,
                        CB_SETCURSEL,
                        (WPARAM) iIndex,
                        (LPARAM) 0 );

    EnableWindow( GetDlgItem( hwnd, IDC_EDT_NETADDRESS ), bGreyNetworkAddress );

}

//----------------------------------------------------------------------------
//
// Function: OnSelChangeNameServiceProvider
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnSelChangeNameServiceProvider( IN HWND hwnd )
{

    INT_PTR  iIndex;
    HWND hNetworkAddressEditBox = GetDlgItem( hwnd, IDC_EDT_NETADDRESS );

    //
    // get the current selection from the combo box
    //

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_CMB_NAMESERVICE,
                                 CB_GETCURSEL,
                                 (WPARAM) 0,
                                 (LPARAM) 0 );

    // infer the settings from the index since there are only 2 to work from
    if(iIndex == 0) {    // if "Windows NT Locator" is selected then do not let user edit the Network address
        EnableWindow(hNetworkAddressEditBox, FALSE);
    }
    else {    // else DCE Cell Directory Service is selected so let user edit Network address
        EnableWindow(hNetworkAddressEditBox, TRUE);
    }

}

//----------------------------------------------------------------------------
//
// Function: OnMsClientApply
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
static VOID
OnMsClientApply( IN HWND hwnd )
{

    INT_PTR iIndex;

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_CMB_NAMESERVICE,
                                 CB_GETCURSEL,
                                 (WPARAM) 0,
                                 (LPARAM) 0 );

    if( iIndex == 0 )
    {
        NetSettings.NameServiceProvider = MS_CLIENT_WINDOWS_LOCATOR;
    }
    else if( iIndex == 1 )
    {
        NetSettings.NameServiceProvider = MS_CLIENT_DCE_CELL_DIR_SERVICE;
    }
    else
    {
        AssertMsg( FALSE,
                   "Invalid result from Network Service Provider combo box." );

        NetSettings.NameServiceProvider = MS_CLIENT_WINDOWS_LOCATOR;

    }


    GetWindowText( GetDlgItem( hwnd, IDC_EDT_NETADDRESS ),
                   NetSettings.szNetworkAddress,
                   MAX_NETWORK_ADDRESS_LENGTH + 1 );

}

//----------------------------------------------------------------------------
//
// Function: MSClient_PropertiesDlgProc
//
// Purpose:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK MSClient_PropertiesDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnMsClientInitDialog( hwnd );
            break;

        case WM_NOTIFY: {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch( pnmh->code )
            {
                case PSN_APPLY:
                    OnMsClientApply( hwnd );
                    break;

            }

            break;

        }    // end case WM_NOTIFY

        case WM_COMMAND: {
            WORD wNotifyCode = HIWORD (wParam);
            WORD wButtonId   = LOWORD (wParam);

            if(wNotifyCode == CBN_SELCHANGE)
            {
                if(wButtonId == IDC_CMB_NAMESERVICE)
                {
                    OnSelChangeNameServiceProvider( hwnd );
                }
            }
        }

        break;

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\client.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      client.c
//
// Description:
//
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: AddComponentToListView
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog
//             NETWORK_COMPONENT *pNetComponent - pointer to the component to
//                  be added to the list view
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
AddComponentToListView( IN HWND hwnd, IN NETWORK_COMPONENT *pNetComponent )
{

    HWND hClientListView = GetDlgItem( hwnd, IDC_SELECT_CLIENT_LIST );

    if ( WizGlobals.iPlatform == PLATFORM_PERSONAL )
    {
        if( pNetComponent->dwPlatforms & PERSONAL_INSTALL )
        {

            InsertEntryIntoListView( hClientListView,
                                     (LPARAM) pNetComponent );

        }
    }
    else if( WizGlobals.iPlatform == PLATFORM_WORKSTATION )
    {

        if( pNetComponent->dwPlatforms & WORKSTATION_INSTALL )
        {

            InsertEntryIntoListView( hClientListView,
                                     (LPARAM) pNetComponent );

        }
    }
    else
    {

        if( pNetComponent->dwPlatforms & SERVER_INSTALL )
        {

            InsertEntryIntoListView( hClientListView,
                                     (LPARAM) pNetComponent );

        }
    }
}

//----------------------------------------------------------------------------
//
// Function: InitSelectClientListView
//
// Purpose:
//
//----------------------------------------------------------------------------
VOID
InitSelectClientListView( HWND hwnd, HINSTANCE hInst )
{

    LV_ITEM lvI;
    NETWORK_COMPONENT *pNetComponent;

    for( pNetComponent = NetSettings.NetComponentsList;
         pNetComponent;
         pNetComponent = pNetComponent->next )
    {

        if( pNetComponent->bInstalled == FALSE &&
            pNetComponent->ComponentType == CLIENT )
        {

            //
            //  If it is not a sysprep then just go ahead and add it to the
            //  list view.  If we are doing a sysprep, check to see if this
            //  component is supported by sysprep to see if we should add it
            //  or not
            //
            if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
            {
                if( pNetComponent->bSysprepSupport )
                {
                    AddComponentToListView( hwnd, pNetComponent );
                }
            }
            else
            {

                AddComponentToListView( hwnd, pNetComponent );

            }

        }

    }

    SetListViewSelection( hwnd, IDC_SELECT_CLIENT_LIST, 0 );

}

//----------------------------------------------------------------------------
//
// Function:  OnClientOk
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnClientOk( IN HWND hwnd )
{

    LV_ITEM lvI;

    // ISSUE-2002/02/28-stelo- if there is no item selected and the user clicks OK the dialog should NOT close

    //
    // see if there is an item selected
    //

    if(GetSelectedItemFromListView(hwnd, IDC_SELECT_CLIENT_LIST, &lvI)) {

        NETWORK_COMPONENT *pEntry = (NETWORK_COMPONENT *)lvI.lParam;

        pEntry->bInstalled = TRUE;

        //
        // return a 1 to show an item was actually added
        //

        EndDialog(hwnd, 1);

    }
    else {

        //
        // return a 0 to show no items were added because the list is empty
        //

        EndDialog(hwnd, 0);

    }

}

//----------------------------------------------------------------------------
//
// Function:  NotifyHandler
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//            IN WPARAM wParam -
//            IN LPARAM lParam -
//
// Returns:  BOOL - whether the message was handled or not
//
//----------------------------------------------------------------------------
static BOOL
NotifyHandler( IN HWND hwnd, IN WPARAM wParam, IN LPARAM lParam )
{

    LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
    NETWORK_COMPONENT *pListViewString = (NETWORK_COMPONENT *)(pLvdi->item.lParam);
    BOOL bStatus = TRUE;

    if( wParam == IDC_SELECT_CLIENT_LIST )
    {

        switch( pLvdi->hdr.code )
        {
            case LVN_GETDISPINFO:
                pLvdi->item.pszText = pListViewString->StrComponentName;
                break;
        }


        switch( pNm->hdr.code )
        {

            case NM_DBLCLK:
            {

                NMITEMACTIVATE *pNmItemActivate = (NMITEMACTIVATE *) lParam;

                //
                // see if the user has double clicked inside the list view
                //

                if( pNm->hdr.idFrom == IDC_SELECT_CLIENT_LIST )
                {

                    //
                    //  Make sure they actually clicked on an item and not just
                    //  empty space
                    //

                    if( pNmItemActivate->iItem != -1 )
                    {
                        OnClientOk( hwnd );
                    }

                }
                break;

            }

            default:
                bStatus = FALSE;
                break;

        }


    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
// Function: SelectNetworkClientDlgProc
//
// Purpose:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK SelectNetworkClientDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_DESTROY:
            // do nothing
            break;

        case WM_INITDIALOG:
            InitSelectClientListView(hwnd, FixedGlobals.hInstance);
            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {
                    case IDOK:
                        OnClientOk( hwnd );
                        break;

                    case IDCANCEL:
                        // return a 0 to show no items were added
                        EndDialog(hwnd, 0);
                        break;

                    case IDC_HAVEDISK:
                        //  ISSUE-2002/02/28-stelo- this needs to be implemented
                        AssertMsg(FALSE,
                                  "This button has not been implemented yet.");
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
                break;
            }
        case WM_NOTIFY:
            NotifyHandler( hwnd, wParam, lParam );
            break;

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\netware.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      netware.c
//
// Description:
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: GreyNetwarePage
//
// Purpose:  Greys the controls on the page appropriately depending on what
//           radio box is selected.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
GreyNetwarePage( IN HWND hwnd ) {

    BOOL bPrefferedServer = IsDlgButtonChecked( hwnd, RB_PREFERRED_SERVER );

    EnableWindow( GetDlgItem(hwnd, IDC_PREFERREDSERVER),   bPrefferedServer );

    EnableWindow( GetDlgItem(hwnd, SLE_DEFAULT_TREE),    ! bPrefferedServer );
    EnableWindow( GetDlgItem(hwnd, SLE_DEFAULT_CONTEXT), ! bPrefferedServer );

}

//----------------------------------------------------------------------------
//
// Function: OnNetwareInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnNetwareInitDialog( IN HWND hwnd ) {

    //
    //  Set the text limits on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_PREFERREDSERVER,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PREFERRED_SERVER_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        SLE_DEFAULT_TREE,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_DEFAULT_TREE_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        SLE_DEFAULT_CONTEXT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_DEFAULT_CONTEXT_LEN,
                        (LPARAM) 0 );

    //
    //  Set the initial state of the radio buttons
    //
    if( NetSettings.bDefaultTreeContext ) {

        CheckRadioButton( hwnd,
                          RB_PREFERRED_SERVER,
                          RB_DEFAULT_CONTEXT,
                          RB_DEFAULT_CONTEXT );

    }
    else {

        CheckRadioButton( hwnd,
                          RB_PREFERRED_SERVER,
                          RB_DEFAULT_CONTEXT,
                          RB_PREFERRED_SERVER );
    }

    GreyNetwarePage( hwnd );

    //
    //  Fill the controls with the values from the global variables
    //
    SetWindowText( GetDlgItem( hwnd, IDC_PREFERREDSERVER ),
                   NetSettings.szPreferredServer );

    SetWindowText( GetDlgItem( hwnd, SLE_DEFAULT_TREE ),
                   NetSettings.szDefaultTree );

    SetWindowText( GetDlgItem( hwnd, SLE_DEFAULT_CONTEXT ),
                   NetSettings.szDefaultContext );

    if( NetSettings.bNetwareLogonScript ) {

        CheckDlgButton( hwnd, CHKBOX_LOGONSCRIPT, BST_CHECKED );

    }
    else {

        CheckDlgButton( hwnd, CHKBOX_LOGONSCRIPT, BST_UNCHECKED );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnNetwareOK
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnNetwareOK( IN HWND hwnd ) {

    if( IsDlgButtonChecked( hwnd, RB_DEFAULT_CONTEXT ) == BST_CHECKED ) {

        NetSettings.bDefaultTreeContext = TRUE;

    }
    else {

        NetSettings.bDefaultTreeContext = FALSE;

    }

    GetWindowText( GetDlgItem( hwnd, IDC_PREFERREDSERVER ),
                   NetSettings.szPreferredServer,
                   MAX_PREFERRED_SERVER_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, SLE_DEFAULT_TREE ),
                   NetSettings.szDefaultTree,
                   MAX_DEFAULT_TREE_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, SLE_DEFAULT_CONTEXT ),
                   NetSettings.szDefaultContext,
                   MAX_DEFAULT_CONTEXT_LEN + 1 );

    if( IsDlgButtonChecked( hwnd, CHKBOX_LOGONSCRIPT ) == BST_CHECKED ) {

        NetSettings.bNetwareLogonScript = TRUE;

    }
    else {

        NetSettings.bNetwareLogonScript = FALSE;

    }

    EndDialog( hwnd, 1 );

}

//----------------------------------------------------------------------------
//
// Function: DlgNetwarePage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgNetwarePage( IN HWND     hwnd,
                IN UINT     uMsg,
                IN WPARAM   wParam,
                IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnNetwareInitDialog( hwnd );

            break;

        }

        case WM_CREATE: {


            break;
        }

        case WM_COMMAND: {

            int nButtonId = LOWORD( wParam );

            switch ( nButtonId ) {

                case RB_PREFERRED_SERVER:
                case RB_DEFAULT_CONTEXT:

                    CheckRadioButton( hwnd,
                                      RB_PREFERRED_SERVER,
                                      RB_DEFAULT_CONTEXT,
                                      nButtonId );

                    GreyNetwarePage( hwnd );

                    break;

                case IDOK: {

                    OnNetwareOK( hwnd );

                    break;

                }

                case IDCANCEL: {

                    EndDialog( hwnd, 0 );

                    break;

                }

            }

        }

        default:
            bStatus = FALSE;
            break;

    }

    return bStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\lanwiz.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      lanwiz.c
//
// Description:
//      This file contains the dialog procedure for the custom networking
//      page (IDD_LANWIZ_DLG).
//
//      This is the primary page for custom networking, all other networking
//      pages come initially from this page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

static UINT iCurrentSelection;
static TCHAR *StrNetworkCardNumber;

//----------------------------------------------------------------------------
//
// Function: UpdateListView
//
// Purpose: clears all the entries in the list view and adds the items
//  in the Network Component List that have the installed flag on
//
// Arguments: IN HWND hwnd - handle to the dialog box
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
UpdateListView( IN HWND hwnd ) {

    NETWORK_COMPONENT *pNetComponent;

    SendDlgItemMessage( hwnd,
                        IDC_LVW_COMPLIST,
                        LVM_DELETEALLITEMS,
                        (WPARAM) 0,
                        (LPARAM) 0 );

    for( pNetComponent = NetSettings.NetComponentsList;
         pNetComponent;
         pNetComponent = pNetComponent->next )
    {

        if( pNetComponent->bInstalled == TRUE )
        {

            //
            //  Make sure we are installing workstation and server components
            //  correctly.  If this isn't one that should be added, continue
            //  on to the next one.
            //
            if( WizGlobals.iPlatform == PLATFORM_PERSONAL )
            {
                if( ! (pNetComponent->dwPlatforms & PERSONAL_INSTALL) )
                {
                    continue;
                }
            }
            else if( WizGlobals.iPlatform == PLATFORM_WORKSTATION )
            {
                if( ! (pNetComponent->dwPlatforms & WORKSTATION_INSTALL) )
                {
                    continue;
                }
            }
            else if( WizGlobals.iPlatform == PLATFORM_SERVER  || WizGlobals.iPlatform == PLATFORM_ENTERPRISE || WizGlobals.iPlatform == PLATFORM_WEBBLADE)
            {
                if( ! (pNetComponent->dwPlatforms & SERVER_INSTALL) )
                {
                    continue;
                }
            }
            else
            {
                AssertMsg( FALSE,
                            "Invalid platform type." );
            }


            //
            //  If it is not a sysprep then just go ahead and add it to the
            //  list view.  If we are doing a sysprep, check to see if this
            //  component is supported by sysprep to see if we should add it
            //  or not
            //
            if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
            {
                if( pNetComponent->bSysprepSupport )
                {
                    InsertEntryIntoListView( GetDlgItem( hwnd, IDC_LVW_COMPLIST ),
                                             (LPARAM) pNetComponent );
                }
                else
                {
                    //
                    // If it is not supported by sysprep, then don't install it
                    //
                    pNetComponent->bInstalled = FALSE;
                }
            }
            else
            {

                InsertEntryIntoListView( GetDlgItem( hwnd, IDC_LVW_COMPLIST ),
                                         (LPARAM) pNetComponent );

            }

        }

    }

}

//----------------------------------------------------------------------------
//
// Function:  GetListViewIndex
//
// Purpose:  returns the entry in the list view with the controlID specified by
//           the index
//
// Arguments: IN HWND hwnd - handle to the dialog the list view is in
//            IN WORD controlID - resource ID of the list view
//            IN INT  index - index in the list view of the item to grab
//
// Returns:  a pointer to the item in the list view at the location specified by
//           the IN parameter index
//
//----------------------------------------------------------------------------
NETWORK_COMPONENT*
GetListViewIndex( IN HWND hwnd,
                  IN WORD controlID,
                  IN INT  index ) {

    LVITEM lvI;

    memset( &lvI, 0, sizeof(LVITEM) );

    lvI.iItem = index;
    lvI.mask = LVIF_PARAM;

    SendDlgItemMessage( hwnd,
                        controlID,
                        LVM_GETITEM,
                        (WPARAM) 0,
                        (LPARAM) &lvI );

    return (NETWORK_COMPONENT *)lvI.lParam ;

}


//----------------------------------------------------------------------------
//
// Function: SetListViewSelection
//
// Purpose: sets the selection in the list view (specified by controlID) to
//          the position specified
//
// Arguments: IN HWND hDlg -
//            IN WORD controlID -
//            IN INT  position -
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
SetListViewSelection( IN HWND hDlg, IN WORD controlID, IN INT position ) {

    HWND hListViewWnd;

    // get a handle to the list view window
    hListViewWnd = GetDlgItem( hDlg, controlID );

    ListView_SetItemState( hListViewWnd,
                           position,
                           LVIS_SELECTED | LVIS_FOCUSED,
                           LVIS_SELECTED | LVIS_FOCUSED ) ;

}

//----------------------------------------------------------------------------
//
// Function: SetDescription
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
VOID
SetDescription( HWND hwnd, INT index ) {

    INT_PTR iListViewCount;
    NETWORK_COMPONENT* tempEntry;

    tempEntry = GetListViewIndex( hwnd, IDC_LVW_COMPLIST, index );

    iListViewCount = SendDlgItemMessage( hwnd,
                                         IDC_LVW_COMPLIST,
                                         LVM_GETITEMCOUNT,
                                         0,
                                         0 );

    //
    //  if there are no entries, then clear the description box
    //  else display the description
    //
    if( iListViewCount == 0 ) {

        SendDlgItemMessage( hwnd,
                            IDC_TXT_COMPDESC,
                            WM_SETTEXT,
                            (WPARAM) 0,
                            (LPARAM) _T("") );

    }
    else {

        SendDlgItemMessage( hwnd,
                            IDC_TXT_COMPDESC,
                            WM_SETTEXT,
                            (WPARAM) 0,
                            (LPARAM) tempEntry->StrComponentDescription );

    }
}


//----------------------------------------------------------------------------
//
// Function: GetSelectedItemFromListView
//
// Purpose:  searches through the List View specified by controlID
//            returns the found item in the lvI parameter
//
// Arguments:
//
// Returns: function returns TRUE if there was an item selected and it
//          found it,
//          FALSE if there was no item selected
//
//----------------------------------------------------------------------------
BOOL
GetSelectedItemFromListView( HWND hwndDlg, WORD controlID, LVITEM* lvI )
{

    INT  i;
    INT  iCount;
    HWND hListView = GetDlgItem( hwndDlg, controlID );
    UINT uMask = LVIS_SELECTED | LVIS_FOCUSED;
    UINT uState;
    BOOL bSelectedItemFound = FALSE;

    iCount = ListView_GetItemCount( hListView );

    //
    // cycle through the list until the selected item is found
    //

    i = 0;

    while( !bSelectedItemFound && i < iCount )
    {

        uState = ListView_GetItemState( hListView, i, uMask );

        if( uState == uMask )
        {

            //
            // found the selected item
            //

            bSelectedItemFound = TRUE;

            memset( lvI, 0, sizeof( LVITEM ) );

            lvI->iItem = i;
            lvI->mask = LVIF_PARAM;

            ListView_GetItem( hListView, lvI );

            return( TRUE );

        }

        i++;

    }

    return( FALSE );

}

//----------------------------------------------------------------------------
//
// Function: InsertEntryIntoListView
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
BOOL
InsertEntryIntoListView( HWND hListViewWnd,
                         LPARAM lParam )
{

    LVITEM lvI;
    NETWORK_COMPONENT *pListViewEntry = (NETWORK_COMPONENT *)lParam;

    lvI.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;

    lvI.iItem = 0;
    lvI.iSubItem = 0;
    lvI.pszText = LPSTR_TEXTCALLBACK;
    lvI.cchTextMax = MAX_ITEMLEN;
    lvI.lParam = lParam;
    lvI.state = LVIS_SELECTED | LVIS_FOCUSED;
    lvI.stateMask = LVIS_SELECTED | LVIS_FOCUSED;


    lvI.iImage = 0;

    switch( pListViewEntry->ComponentType ) {

        case CLIENT:    lvI.iImage = 0; break;
        case SERVICE:   lvI.iImage = 1; break;
        case PROTOCOL:  lvI.iImage = 2; break;

    }

    if ( ListView_InsertItem( hListViewWnd, &lvI ) == -1 )
        return( FALSE );

    ListView_SortItems( hListViewWnd, ListViewCompareFunc, (LPARAM)NULL );

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: InitListView
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
BOOL
InitListView( HWND hDlg, HINSTANCE hInst ) {

    HICON      hIcon1, hIcon2, hIcon3;  // handles to icons
    HIMAGELIST hSmall;                  // handle to image list for small icons
    LVCOLUMN   lvCol;
    RECT       rect;

    //
    // Initialize the list view window
    // First initialize the image lists you will need:
    // create image list for the small icons
    //

    hSmall = ImageList_Create( BITMAP_WIDTH, BITMAP_HEIGHT, ILC_MASK, 3, 0 );

    //
    // Load the icons and add them to the image list
    //

    hIcon1 = LoadIcon( hInst, MAKEINTRESOURCE(IDI_CLIENT)   );
    hIcon2 = LoadIcon( hInst, MAKEINTRESOURCE(IDI_SERVICE)  );
    hIcon3 = LoadIcon( hInst, MAKEINTRESOURCE(IDI_PROTOCOL) );

    if( ImageList_AddIcon(hSmall, hIcon1) == -1 )
        return( FALSE );
    if( ImageList_AddIcon(hSmall, hIcon2) == -1 )
        return( FALSE );
    if( ImageList_AddIcon(hSmall, hIcon3) == -1 )
        return( FALSE );

    // Be sure that all the icons were added
    if ( ImageList_GetImageCount( hSmall ) < 3 )
        return( FALSE );

    // Associate the image list with the list view control
    SendDlgItemMessage( hDlg,
                        IDC_LVW_COMPLIST,
                        LVM_SETIMAGELIST,
                        (WPARAM) LVSIL_SMALL,
                        (LPARAM) hSmall );

    //
    //  Using a "Report" list view so make it 1 column that is the width of
    //  the list view
    //

    GetClientRect( GetDlgItem( hDlg, IDC_LVW_COMPLIST ),
                   &rect );

    SendDlgItemMessage( hDlg,
                        IDC_LVW_COMPLIST,
                        LVM_SETCOLUMNWIDTH,
                        (WPARAM) 0,
                        (LPARAM) rect.right );

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvCol.fmt  = LVCFMT_LEFT;     // left-align column
    lvCol.cx   = rect.right;       // width of column in pixels

    SendDlgItemMessage( hDlg,
                        IDC_LVW_COMPLIST,
                        LVM_INSERTCOLUMN,
                        (WPARAM) 0,
                        (LPARAM) &lvCol );

    iCurrentSelection = 0;

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: SetNetworkNumberText
//
// Purpose:  Changes the caption of Network card # text so the user knows what
//           network card he is currently changing settings for
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
VOID
SetNetworkNumberText( IN HWND hwnd, IN INT iCmdShow )
{

    HWND  hNumNetworkCards;
    TCHAR szNetNumber[3];    // 3 so it holds up to a 2 digit string
    TCHAR szTempString[MAX_STRING_LEN];
    HRESULT hrCat;

    hNumNetworkCards = GetDlgItem( hwnd, IDC_NETWORKCARDNUM );

    //
    //  Convert network card int to string
    //
    _itow( NetSettings.iCurrentNetworkCard, szNetNumber, 10 );

    //
    // copy "Network Adapter #" string into szTempString
    // szTempString is the string being built up that will be displayed
    // as the new caption
    //
    lstrcpyn( szTempString, StrNetworkCardNumber, AS(szTempString) );

    //
    //  concat the current network card number to the rest of the string
    //
    hrCat=StringCchCat( szTempString, AS(szTempString), szNetNumber );

    SetWindowText( hNumNetworkCards, szTempString );

    ShowWindow( hNumNetworkCards, iCmdShow );

}

//----------------------------------------------------------------------------
//
// Function: ShowPlugAndPlay
//
// Purpose:  Displays Plug and Play box, if necessary
//           if the box is displayed then it fills it with the proper data
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
static VOID
ShowPlugAndPlay( IN HWND hwnd,
                 IN BOOL bShowNetworkText,
                 IN BOOL bShowEditBox )
{

    HWND hPlugAndPlayText    = GetDlgItem( hwnd, IDC_PLUGANDPLAYTEXT );
    HWND hPlugAndPlayEditBox = GetDlgItem( hwnd, IDC_PLUGANDPLAY_ID );

    AssertMsg( NetSettings.pCurrentAdapter != NULL,
               "The current network card is null but there are more network cards left." );

    //
    //  Show or hide the Network adapter text and make sure it is displaying
    //  the right number for the network card.
    //

    if( bShowNetworkText )
    {
        //
        //  change the text to display which network card the user is
        //  currently on
        //

        SetNetworkNumberText( hwnd , SW_SHOW );

        SetWindowText( hPlugAndPlayEditBox,
                       NetSettings.pCurrentAdapter->szPlugAndPlayID );
    }
    else
    {
        SetNetworkNumberText( hwnd, SW_HIDE );
    }

    //
    //  Show or hide the static Plug and Play text and edit box
    //

    if( bShowEditBox )
    {
        ShowWindow(hPlugAndPlayText, SW_SHOW );

        ShowWindow(hPlugAndPlayEditBox, SW_SHOW );
    }
    else
    {
        ShowWindow( hPlugAndPlayText, SW_HIDE );

        ShowWindow( hPlugAndPlayEditBox, SW_HIDE );
    }

}

//----------------------------------------------------------------------------
//
// Function:  FindNode
//
// Purpose:  iterate throught the global net component list until the Node
//           where the component position matches the iPosition parameter
//           return a pointer to this node
//           if the node is not found, return NULL
//
// Arguments: INT iPosition - position to return a pointer to in the list
//
// Returns: Pointer to the NETWORK_COMPONENT if found
//          NULL if not found
//
//----------------------------------------------------------------------------
NETWORK_COMPONENT*
FindNode( IN INT iPosition )
{

    NETWORK_COMPONENT *pNetComponent;

    for( pNetComponent = NetSettings.NetComponentsList;
         pNetComponent;
         pNetComponent = pNetComponent->next )
    {

        if( pNetComponent->iPosition == iPosition )
        {

            return( pNetComponent );

        }

    }

    return( NULL );

}

//----------------------------------------------------------------------------
//
// Function:  PropertiesHandler
//
// Purpose:  called to handle when either the properties button is pushed or
//           an item in the list view is double clicked
//
// Arguments:
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
PropertiesHandler( IN HWND hDlg )
{

    LVITEM lvI;
    NETWORK_COMPONENT *entry;

    if( GetSelectedItemFromListView( hDlg, IDC_LVW_COMPLIST, &lvI ) ) {

        entry = (NETWORK_COMPONENT *)lvI.lParam;

        // if the dialog box has properties, find the right dialog to pop-up
        if( entry->bHasPropertiesTab ) {

            switch( entry->iPosition ) {

                case TCPIP_POSITION:

                    Create_TCPIP_PropertySheet( hDlg ); break;

                case MS_CLIENT_POSITION:

                    Create_MSClient_PropertySheet( hDlg ); break;

                case IPX_POSITION:

                    Create_MS_NWIPX_PropertySheet( hDlg ); break;

                case APPLETALK_POSITION:

                    Create_Appletalk_PropertySheet( hDlg ); break;

                case NETWARE_CLIENT_POSITION:
                case GATEWAY_FOR_NETWARE_POSITION:

                    DialogBox( FixedGlobals.hInstance,
                               (LPCTSTR) IDD_NWC_WINNT_DLG,
                               hDlg,
                               DlgNetwarePage );
                    break;

                default:

                    AssertMsg( FALSE,
                               "Bad Switch Case: Entry has Properties but no corresponding Property Sheet" );

                    break;

            }

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: ListViewHandler
//
// Purpose:
//
// Arguments:
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
ListViewHandler( IN HWND hwnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam )
{

    LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
    NETWORK_COMPONENT *pListViewEntry;
    HWND hPropertiesButton;

    pListViewEntry = (NETWORK_COMPONENT *)(pLvdi->item.lParam);

    switch( pLvdi->hdr.code )
    {

        case LVN_GETDISPINFO:
        {

            pLvdi->item.pszText = pListViewEntry->StrComponentName;

            break;

        }

    }

    switch( pNm->hdr.code )
    {

        case NM_DBLCLK:
        {

            NMITEMACTIVATE *pNmItemActivate = (NMITEMACTIVATE *) lParam;

            //
            // see if the user has double clicked inside the list view
            //

            if( pNm->hdr.idFrom == IDC_LVW_COMPLIST )
            {

                //
                //  Make sure they actually clicked on an item and not just
                //  empty space
                //

                if( pNmItemActivate->iItem != -1 )
                {
                    PropertiesHandler( hwnd );
                }

            }
            break;

        }

        case LVN_ITEMCHANGED:

            // test to see if a new item in the list has been selected
            if( pNm->uNewState == SELECTED )
            {

                LVITEM lvI;
                NETWORK_COMPONENT* currentEntry;

                if( ! GetSelectedItemFromListView( hwnd,
                                                   IDC_LVW_COMPLIST,
                                                   &lvI ) )
                {
                    return;
                }

                currentEntry = (NETWORK_COMPONENT *)lvI.lParam;

                iCurrentSelection = lvI.iItem;

                SetDescription( hwnd, lvI.iItem );

                //  enable or disable the properties button based on their
                //  selection in the list view
                hPropertiesButton = GetDlgItem( hwnd, IDC_PSH_PROPERTIES );

                if( currentEntry->bHasPropertiesTab )
                {
                    EnableWindow( hPropertiesButton, TRUE );
                }
                else
                {
                    EnableWindow( hPropertiesButton, FALSE );
                }

            }

            break;

    }

}

//----------------------------------------------------------------------------
//
// Function: OnLANWizNext
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLANWizNext( IN HWND hwnd )
{
    if ( IsDlgButtonChecked(hwnd, IDC_CUSTOMNET) == BST_CHECKED )
        NetSettings.iNetworkingMethod = CUSTOM_NETWORKING;
    else
        NetSettings.iNetworkingMethod = TYPICAL_NETWORKING;
}

//----------------------------------------------------------------------------
//
// Function: EnableWindows
//
// Purpose:  Enable/Disable windows based on the current selection
//
//
// Arguments:  handle to the main window
//
// Returns:  none
//
//----------------------------------------------------------------------------
EnableControls( IN HWND hwnd )
{
    BOOL fEnable = ( IsDlgButtonChecked(hwnd, IDC_CUSTOMNET) == BST_CHECKED );

    EnableWindow(GetDlgItem(hwnd, IDC_LVW_COMPLIST), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_PSH_ADD), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_PSH_REMOVE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_PSH_PROPERTIES), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_TXT_COMPDESC), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_DESCRIPTION), fEnable);
}

//----------------------------------------------------------------------------
//
// Function: OnLANWizSetActive
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLANWizSetActive( IN HWND hwnd )
{

    UpdateListView( hwnd );

    //
    //  set the selection in the list view to the first item
    //
    SetListViewSelection( hwnd, IDC_LVW_COMPLIST, 0 );

    //
    //  set the description because it might have changed with the new item
    //  being added
    //
    SetDescription( hwnd, 0 );

    // Check to proper default button
    //
    if ( NetSettings.iNetworkingMethod == CUSTOM_NETWORKING )
        CheckRadioButton( hwnd, IDC_TYPICALNET, IDC_CUSTOMNET, IDC_CUSTOMNET );
    else
        CheckRadioButton( hwnd, IDC_TYPICALNET, IDC_CUSTOMNET, IDC_TYPICALNET );

    // Enable the controls
    //
    EnableControls(hwnd);

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT );

}

//----------------------------------------------------------------------------
//
// Function: ListViewCompareFunc
//
// Purpose:  sorts the list view by component type first
//           (Client < Service < Protocol) and within each component type,
//           sorts alphabetically
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT CALLBACK
ListViewCompareFunc( LPARAM lParam1,
                     LPARAM lParam2,
                     LPARAM lParamSort ) {

    NETWORK_COMPONENT *pEntry1 = (NETWORK_COMPONENT *)lParam1;
    NETWORK_COMPONENT *pEntry2 = (NETWORK_COMPONENT *)lParam2;

    //
    // sort by ComponentType first, and then alphabetically
    //
    if( pEntry1->ComponentType < pEntry2->ComponentType ) {

        return(-1);

    }
    else if( pEntry1->ComponentType > pEntry2->ComponentType ) {

        return(1);

    }
    // Component Types are equal so sort alphabetically
    else {

        return lstrcmpi( pEntry1->StrComponentName, pEntry2->StrComponentName ) ;

    }

}

//----------------------------------------------------------------------------
//
// Function: OnLANWizAdd
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments, passed through from the
//             Dialog proc
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLANWizAdd( IN HWND    hwnd,
             IN UINT    uMsg,
             IN WPARAM  wParam,
             IN LPARAM  lParam ) {

    if ( HIWORD( wParam ) == BN_CLICKED )
    {

        //
        // pop-up the new dialog box and if they actual add
        // an item make sure the Uninstall button is enabled
        //

        if( DialogBox( FixedGlobals.hInstance,
                       (LPCTSTR) IDD_LAN_COMPONENT_ADD,
                       hwnd,
                       AddDeviceDlgProc) )
        {

            HWND hUninstallButton = GetDlgItem( hwnd, IDC_PSH_REMOVE );

            EnableWindow( hUninstallButton, TRUE );

            UpdateListView( hwnd );

            // set the selection in the list view
            // to the first item
            SetListViewSelection( hwnd, IDC_LVW_COMPLIST, 0 );

            // set the description because it might have
            // changed with the new item being added
            SetDescription( hwnd, 0 );

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: OnLANWizRemove
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments, passed through from the
//             Dialog proc
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLANWizRemove( IN HWND    hwnd,
                IN UINT    uMsg,
                IN WPARAM  wParam,
                IN LPARAM  lParam ) {

    INT_PTR iListViewCount;

    if ( HIWORD( wParam ) == BN_CLICKED ) {
        //
        // remove the currently selected item from the list view
        //
        LVITEM lvI;
        NETWORK_COMPONENT* pNode;

        if( GetSelectedItemFromListView( hwnd,
                                         IDC_LVW_COMPLIST, &lvI ) ) {

            pNode = (NETWORK_COMPONENT *)lvI.lParam;

            pNode->bInstalled = FALSE;

            //
            //  Update the list view to show the removed
            //  component is gone
            //
            UpdateListView( hwnd );

            SetListViewSelection( hwnd, IDC_LVW_COMPLIST, 1 );

            SetDescription( hwnd, 0 );

        }

        iListViewCount = SendDlgItemMessage( hwnd,
                                             IDC_LVW_COMPLIST,
                                             LVM_GETITEMCOUNT,
                                             (WPARAM) 0,
                                             (LPARAM) 0 );

        // if there are no more items in the list view then grey out
        // the uninstall and properties button
        if( iListViewCount == 0 ) {

            HWND hUninstallButton  = GetDlgItem( hwnd, IDC_PSH_REMOVE );
            HWND hPropertiesButton = GetDlgItem( hwnd, IDC_PSH_PROPERTIES );

            EnableWindow( hUninstallButton,  FALSE );
            EnableWindow( hPropertiesButton, FALSE );

        }

    }

}

//----------------------------------------------------------------------------
//
// Function:  OnLANWizProperties
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments, passed through from the
//             Dialog proc
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLANWizProperties( IN HWND    hwnd,
                    IN UINT    uMsg,
                    IN WPARAM  wParam,
                    IN LPARAM  lParam ) {

    if ( HIWORD( wParam ) == BN_CLICKED ) {

        PropertiesHandler( hwnd );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnLANWizInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLANWizInitDialog( IN HWND hwnd ) {

    INITCOMMONCONTROLSEX CommonControlsStruct;

    CommonControlsStruct.dwICC = ICC_INTERNET_CLASSES | ICC_LISTVIEW_CLASSES;
    CommonControlsStruct.dwSize = sizeof( INITCOMMONCONTROLSEX );

    //  Ensure that the common control DLL has loaded the window classes
    //  for the IP control and the ListView control
    InitCommonControlsEx( &CommonControlsStruct );

    //
    //  Load strings from resources
    //

    StrNetworkCardNumber = MyLoadString( IDS_NETADAPTERNUMBER );

    InitListView( hwnd, FixedGlobals.hInstance );

    // Set the default description
    SetDescription( hwnd, 0 );

}

//----------------------------------------------------------------------------
//
// Function: DlgLANWizardPage
//
// Purpose:  Dialog procedure for the LAN Wizard page.  (The one that shows
//     what Client, Services, and Protocols are to be installed)
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK DlgLANWizardPage( IN HWND     hwnd,
                               IN UINT     uMsg,
                               IN WPARAM   wParam,
                               IN LPARAM   lParam )
{

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnLANWizInitDialog( hwnd );

            break;
        }

        case WM_COMMAND: {

            switch ( LOWORD(wParam) ) {
                case IDC_TYPICALNET:
                case IDC_CUSTOMNET:
                    EnableControls(hwnd);
                    break;

                case IDC_PSH_ADD:

                    OnLANWizAdd( hwnd, uMsg, wParam, lParam );

                    break;

                case IDC_PSH_REMOVE:

                    OnLANWizRemove( hwnd, uMsg, wParam, lParam );

                    break;

                case IDC_PSH_PROPERTIES:

                    OnLANWizProperties( hwnd, uMsg, wParam, lParam );

                    break;

            }

            break;  // WM_COMMAND

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;
            HWND hwndComponentDescription;

            if( wParam == IDC_LVW_COMPLIST ) {

                ListViewHandler( hwnd, uMsg, wParam, lParam );

            }
            else {
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:

                        WIZ_CANCEL(hwnd);

                        break;

                    case PSN_SETACTIVE:

                        g_App.dwCurrentHelp = IDH_NET_COMPS;

                        OnLANWizSetActive( hwnd );

                        break;

                    case PSN_WIZBACK:
                        break;
                    case PSN_WIZNEXT:
                        OnLANWizNext( hwnd );
                        bStatus = FALSE;
                        break;
                        
                    case PSN_HELP:
                        WIZ_HELP();
                        break;

                }

            }

            break;

        }

        default: {

            bStatus = FALSE;

            break;

        }

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\msnwipx.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      msnwipx.c
//
// Description:
//      This file contains the property sheet and page procedures for the
//      IPX protocol property sheet.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define MAX_NETWORKNUMBER_LENGTH 8

static TCHAR *StrIpxDescription;

static TCHAR *StrAutoDetect;
static TCHAR *StrEthernet_802_2;
static TCHAR *StrEthernet_802_3;
static TCHAR *StrEthernet_II;
static TCHAR *StrEthernetSnap;

PROPSHEETHEADER MS_NWIPX_pshead ;
PROPSHEETPAGE   MS_NWIPX_pspage ;

UINT CALLBACK
MS_NWIPX_PropertiesPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp );

int CALLBACK MS_NWIPX_PropertySheetProc( IN HWND hwndDlg,
                                         IN UINT uMsg,
                                         IN LPARAM lParam );

INT_PTR CALLBACK MS_NWIPX_PropertiesDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

//----------------------------------------------------------------------------
//
// Function: MS_NWIPX_PropertySheetProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
int CALLBACK MS_NWIPX_PropertySheetProc( IN HWND hwndDlg,
                                         IN UINT uMsg,
                                         IN LPARAM lParam ) {

    switch( uMsg ) {

          case PSCB_INITIALIZED:
               // Process PSCB_INITIALIZED
               break;

          case PSCB_PRECREATE:
               // Process PSCB_PRECREATE
               break;

          default:
               // Unknown message
               break;

    }

    return 0 ;

}

//----------------------------------------------------------------------------
//
// Function: Create_MS_NWIPX_PropertySheet
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
BOOL Create_MS_NWIPX_PropertySheet( HWND hwndParent ) {

    // Initialize property sheet HEADER data
    ZeroMemory( &MS_NWIPX_pshead, sizeof( PROPSHEETHEADER ) ) ;
    MS_NWIPX_pshead.dwSize  = sizeof( PROPSHEETHEADER ) ;
    MS_NWIPX_pshead.dwFlags =    PSH_PROPSHEETPAGE    |
                                PSH_USECALLBACK        |
                                PSH_USEHICON        |
                                PSH_NOAPPLYNOW;
    MS_NWIPX_pshead.hwndParent  = hwndParent ;
    MS_NWIPX_pshead.hInstance   = FixedGlobals.hInstance;
    MS_NWIPX_pshead.pszCaption  = g_StrIpxProtocolTitle;
    MS_NWIPX_pshead.nPages      = 1 ;
    MS_NWIPX_pshead.nStartPage  = 0 ;
    MS_NWIPX_pshead.ppsp        = &MS_NWIPX_pspage ;
    MS_NWIPX_pshead.pfnCallback = MS_NWIPX_PropertySheetProc ;

    // Zero out property PAGE data
    ZeroMemory (&MS_NWIPX_pspage, 1 * sizeof( PROPSHEETPAGE) ) ;

    MS_NWIPX_pspage.dwSize      = sizeof( PROPSHEETPAGE ) ;
    MS_NWIPX_pspage.dwFlags     = PSP_USECALLBACK ;
    MS_NWIPX_pspage.hInstance   = FixedGlobals.hInstance;
    MS_NWIPX_pspage.pszTemplate = MAKEINTRESOURCE(IDD_IPX_CONFIG) ;
    MS_NWIPX_pspage.pfnDlgProc  = MS_NWIPX_PropertiesDlgProc ;
    MS_NWIPX_pspage.pfnCallback = MS_NWIPX_PropertiesPageProc ;

     // --------- Create & display property sheet ---------
     return PropertySheet( &MS_NWIPX_pshead ) ? TRUE : FALSE ;
}

//----------------------------------------------------------------------------
//
// Function: MS_NWIPX_PropertiesPageProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
UINT CALLBACK
MS_NWIPX_PropertiesPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp ) {

    switch( uMsg ) {

          case PSPCB_CREATE :
               return 1 ;

          case PSPCB_RELEASE :
               return 0;
    }

    return 0 ;

}

//----------------------------------------------------------------------------
//
// Function: MS_NWIPX_PropertiesDlgProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK MS_NWIPX_PropertiesDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            HWND hInternalNetworkNumberEditBox = GetDlgItem( hwnd,
                                IDC_EDT_IPXAS_INTERNAL );
            HWND hNetworkNumberEditBox = GetDlgItem( hwnd,
                                IDC_EDT_IPXPP_NETWORKNUMBER );

            StrIpxDescription    = MyLoadString( IDS_IPX_DESCRIPTION );

            StrAutoDetect        = MyLoadString( IDS_AUTO_DETECT );
            StrEthernet_802_2    = MyLoadString( IDS_ETHERNET_802_2 );
            StrEthernet_802_3    = MyLoadString( IDS_ETHERNET_802_3 );
            StrEthernet_II       = MyLoadString( IDS_ETHERNET_II );
            StrEthernetSnap      = MyLoadString( IDS_ETHERNET_SNAP );

            SetWindowText(
                GetDlgItem( hwnd, IDC_IPXPP_TEXT ), StrIpxDescription );


            //
            //  Set the text limit on the edit boxes to MAX_NETWORKNUMBER_LENGTH
            //
            SendDlgItemMessage( hwnd,
                                IDC_EDT_IPXAS_INTERNAL,
                                EM_LIMITTEXT,
                                (WPARAM) MAX_NETWORKNUMBER_LENGTH,
                                (LPARAM) 0 );

            SendDlgItemMessage( hwnd,
                                IDC_EDT_IPXPP_NETWORKNUMBER,
                                EM_LIMITTEXT,
                                (WPARAM) MAX_NETWORKNUMBER_LENGTH,
                                (LPARAM) 0 );

            //
            //    Fill Combo box with initial values
            //
            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPXPP_FRAMETYPE,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrAutoDetect );

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPXPP_FRAMETYPE,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrEthernet_802_2 );

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPXPP_FRAMETYPE,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrEthernet_802_3);

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPXPP_FRAMETYPE,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrEthernet_II );

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPXPP_FRAMETYPE,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrEthernetSnap );

            SetWindowText( hInternalNetworkNumberEditBox,
                           NetSettings.szInternalNetworkNumber );

            //
            //  Make the default selection in the combo box whatever
            //  NetSettings.szFrameType is
            //
            if( lstrcmp( NetSettings.pCurrentAdapter->szFrameType,
                         _T("0xFF") ) == 0 ) {

                SendDlgItemMessage( hwnd,
                                    IDC_CMB_IPXPP_FRAMETYPE,
                                    CB_SETCURSEL,
                                    (WPARAM) 0,
                                    (LPARAM) 0 );

            }
            else if( lstrcmp( NetSettings.pCurrentAdapter->szFrameType,
                              _T("0x2") ) == 0 ) {

                SendDlgItemMessage( hwnd,
                                    IDC_CMB_IPXPP_FRAMETYPE,
                                    CB_SETCURSEL,
                                    (WPARAM) 1,
                                    (LPARAM) 0 );

            }
            else if( lstrcmp( NetSettings.pCurrentAdapter->szFrameType,
                              _T("0x1") ) == 0 ) {

                SendDlgItemMessage( hwnd,
                                    IDC_CMB_IPXPP_FRAMETYPE,
                                    CB_SETCURSEL,
                                    (WPARAM) 2,
                                    (LPARAM) 0 );

            }
            else if( lstrcmp( NetSettings.pCurrentAdapter->szFrameType,
                              _T("0x0") ) == 0 ) {

                SendDlgItemMessage( hwnd,
                                    IDC_CMB_IPXPP_FRAMETYPE,
                                    CB_SETCURSEL,
                                    (WPARAM) 3,
                                    (LPARAM) 0 );

            }
            else if( lstrcmp( NetSettings.pCurrentAdapter->szFrameType,
                              _T("0x3") ) == 0 ) {

                SendDlgItemMessage( hwnd,
                                    IDC_CMB_IPXPP_FRAMETYPE,
                                    CB_SETCURSEL,
                                    (WPARAM) 4,
                                    (LPARAM) 0 );

            }

            if( lstrcmp( NetSettings.pCurrentAdapter->szFrameType,
                         _T("0xFF") ) == 0 ) {

                EnableWindow( GetDlgItem( hwnd, IDC_STATIC_NETNUM ), FALSE );
                EnableWindow( GetDlgItem( hwnd, IDC_EDT_IPXPP_NETWORKNUMBER ), FALSE );

            }
            else {

                SetWindowText( hInternalNetworkNumberEditBox,
                               NetSettings.szInternalNetworkNumber );

                SetWindowText( hNetworkNumberEditBox,
                     NetSettings.pCurrentAdapter->szNetworkNumber );

            }

            break;
        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch( pnmh->code ) {

                case PSN_APPLY: {

                    TCHAR szFrameTypeBuffer[MAX_STRING_LEN];

                    // user clicked the OK button on the property sheet
                    HWND hInternalNetworkNumberEditBox = GetDlgItem( hwnd, IDC_EDT_IPXAS_INTERNAL );
                    HWND hNetworkNumberEditBox = GetDlgItem( hwnd, IDC_EDT_IPXPP_NETWORKNUMBER );
                    HWND hFrameTypeComboBox = GetDlgItem( hwnd, IDC_CMB_IPXPP_FRAMETYPE );

                    // 8+1 because only want to take the first 8 characters +1 for the null
                    GetWindowText( hInternalNetworkNumberEditBox, NetSettings.szInternalNetworkNumber, 8+1 );
                    GetWindowText( hNetworkNumberEditBox, NetSettings.pCurrentAdapter->szNetworkNumber, 8+1 );

                    //
                    //  Map Combo Box names to the appropriate string for the answer file
                    //
                    GetWindowText( hFrameTypeComboBox, szFrameTypeBuffer, MAX_STRING_LEN );

                    if( lstrcmp( szFrameTypeBuffer, StrAutoDetect ) == 0 ) {

                        lstrcpyn( NetSettings.pCurrentAdapter->szFrameType, _T("0xFF"), AS(NetSettings.pCurrentAdapter->szFrameType) );

                    }
                    else if( lstrcmp( szFrameTypeBuffer, StrEthernet_802_2 ) == 0 ) {

                        lstrcpyn( NetSettings.pCurrentAdapter->szFrameType, _T("0x2"), AS(NetSettings.pCurrentAdapter->szFrameType) );

                    }
                    else if( lstrcmp( szFrameTypeBuffer, StrEthernet_802_3 ) == 0 ) {

                        lstrcpyn( NetSettings.pCurrentAdapter->szFrameType, _T("0x1"), AS(NetSettings.pCurrentAdapter->szFrameType) );

                    }
                    else if( lstrcmp( szFrameTypeBuffer, StrEthernet_II ) == 0 ) {

                        lstrcpyn( NetSettings.pCurrentAdapter->szFrameType, _T("0x0"), AS(NetSettings.pCurrentAdapter->szFrameType) );

                    }
                    else if( lstrcmp( szFrameTypeBuffer, StrEthernetSnap ) == 0 ) {

                        lstrcpyn( NetSettings.pCurrentAdapter->szFrameType, _T("0x3"), AS(NetSettings.pCurrentAdapter->szFrameType) );

                    }

                }

            }

            break;

        }    // end case WM_NOTIFY

        case WM_COMMAND: {

            WORD wNotifyCode = HIWORD( wParam ) ;
            WORD wButtonId   = LOWORD( wParam ) ;

            if( wNotifyCode == CBN_SELCHANGE ) {

                if( wButtonId == IDC_CMB_IPXPP_FRAMETYPE ) {

                    INT_PTR iIndex;
                    HWND hNetworkNumberEditBox = GetDlgItem( hwnd, IDC_EDT_IPXPP_NETWORKNUMBER );

                    // get the current selection from the combo box
                    iIndex = SendDlgItemMessage( hwnd,
                                                 IDC_CMB_IPXPP_FRAMETYPE,
                                                 CB_GETCURSEL,
                                                 (WPARAM) 0,
                                                 (LPARAM) 0 ) ;

                    // infer the settings from the index since they they added in a fixed order
                    if( iIndex == 0 ) {    // if "Auto Detect" is selected then do not let user edit the Network Number

                        EnableWindow( GetDlgItem( hwnd, IDC_STATIC_NETNUM ), FALSE );
                        EnableWindow( hNetworkNumberEditBox, FALSE );
                        SetWindowText( hNetworkNumberEditBox, _T("") );

                    }
                    else {    // else let user edit Network Number

                        EnableWindow( GetDlgItem( hwnd, IDC_STATIC_NETNUM ), TRUE );
                        EnableWindow( hNetworkNumberEditBox, TRUE );

                    }

                }

            }

            break;

        }

        default:

            bStatus = FALSE;
            break;

    }

    return bStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\protocol.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      protocol.c
//
// Description:
//
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

int CALLBACK ListViewCompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

//----------------------------------------------------------------------------
//
// Function: InitSelectProtocolListView
//
// Purpose:
//
//----------------------------------------------------------------------------
VOID InitSelectProtocolListView( HWND hDlg, HINSTANCE hInst )
{

    LV_ITEM lvI;                    // list view item structure
    HWND hProtocolListView;          // handle to list view window
    NETWORK_COMPONENT *pNetComponent;

    hProtocolListView = GetDlgItem( hDlg, IDC_SELECT_PROTOCOL_LIST );

    for( pNetComponent = NetSettings.NetComponentsList;
         pNetComponent;
         pNetComponent = pNetComponent->next )
    {

        if( pNetComponent->bInstalled == FALSE &&
            pNetComponent->ComponentType == PROTOCOL )
        {

            //
            //  If it is not a sysprep then just go ahead and add it to the
            //  list view.  If we are doing a sysprep, check to see if this
            //  component is supported by sysprep to see if we should add it
            //  or not
            //
            if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
            {
                if( pNetComponent->bSysprepSupport )
                {
                    InsertEntryIntoListView( hProtocolListView,
                                             (LPARAM) pNetComponent );
                }
            }
            else
            {

                InsertEntryIntoListView( hProtocolListView,
                                         (LPARAM) pNetComponent );

            }

        }

    }

    SetListViewSelection( hDlg, IDC_SELECT_PROTOCOL_LIST, 0 );

}

//----------------------------------------------------------------------------
//
// Function:  OnProtocolOk
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnProtocolOk( IN HWND hwnd )
{

    LV_ITEM lvI;

    // ISSUE-2002/02/28-stelo- if there is no item selected and the user clicks OK the dialog should NOT close

    // see if there is an item selected
    if( GetSelectedItemFromListView( hwnd, IDC_SELECT_PROTOCOL_LIST, &lvI ) )
    {

        NETWORK_COMPONENT *pEntry = (NETWORK_COMPONENT *)lvI.lParam;

        pEntry->bInstalled = TRUE;

        // return a 1 to show an item was actually added
        EndDialog(hwnd, 1);
    }
    else
    {
        // return a 0 to show no items were added because the list is empty
        EndDialog(hwnd, 0);
    }

}

//----------------------------------------------------------------------------
//
// Function:  NotifyHandler
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//            IN WPARAM wParam -
//            IN LPARAM lParam -
//
// Returns:  BOOL - whether the message was handled or not
//
//----------------------------------------------------------------------------
static BOOL
NotifyHandler( IN HWND hwnd, IN WPARAM wParam, IN LPARAM lParam )
{

    LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
    NETWORK_COMPONENT *pListViewString = (NETWORK_COMPONENT *)(pLvdi->item.lParam);
    BOOL bStatus = TRUE;

    if( wParam == IDC_SELECT_PROTOCOL_LIST )
    {

        switch( pLvdi->hdr.code )
        {
            case LVN_GETDISPINFO:
                pLvdi->item.pszText = pListViewString->StrComponentName;
                break;
        }


        switch( pNm->hdr.code )
        {

            case NM_DBLCLK:
            {

                NMITEMACTIVATE *pNmItemActivate = (NMITEMACTIVATE *) lParam;

                //
                // see if the user has double clicked inside the list view
                //

                if( pNm->hdr.idFrom == IDC_SELECT_PROTOCOL_LIST )
                {

                    //
                    //  Make sure they actually clicked on an item and not just
                    //  empty space
                    //

                    if( pNmItemActivate->iItem != -1 )
                    {
                        OnProtocolOk( hwnd );
                    }

                }
                break;

            }

            default:

                bStatus = FALSE;

                break;

        }

    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
// Function: SelectNetworkProtocolDlgProc
//
// Purpose:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK SelectNetworkProtocolDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch (uMsg) {
        case WM_DESTROY:
            // do nothing
            break;

        case WM_INITDIALOG:
            InitSelectProtocolListView(hwnd, FixedGlobals.hInstance);
            break;

        case WM_COMMAND:
        {
            int nButtonId;

            switch ( nButtonId = LOWORD(wParam) ) {
                case IDOK:

                    OnProtocolOk( hwnd );

                    break;

                case IDCANCEL:
                    // return a 0 to show no items were added
                    EndDialog(hwnd, 0);
                    break;

                case IDC_HAVEDISK:
                    //  ISSUE-2002/02/28-stelo- this needs to be implemented
                    AssertMsg(FALSE,
                              "This button has not been implemented yet.");
                    break;

                default:
                    bStatus = FALSE;
                    break;

            }
            break;
        }

        case WM_NOTIFY:

            NotifyHandler( hwnd, wParam, lParam );

            break;

        default:

            bStatus = FALSE;

            break;

    }

    return( bStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by net.rc
//
#define IDD_LANWIZ_DLG                  10000
#define IDD_LAN_COMPONENT_ADD           10001
#define IDD_NETWORKING                  10002
#define IDD_DOMAINJ                     10003
#define IDD_TCP_IPADDR                  10004
#define IDD_IPADDR_ADV                  10005
#define IDD_TCP_DNS                     10006
#define IDD_TCP_OPTIONS                 10007
#define IDD_TCP_WINS                    10008
#define IDD_SELECT_CLIENT               10009
#define IDD_SELECT_SERVICE              10010
#define IDD_SELECT_PROTOCOL             10011
#define IDD_DNS_SERVER                  10012
#define IDD_IPADDR_ADV_CHANGEGATE       10013
#define IDD_IPADDR_ADV_CHANGEIP         10014
#define IDD_WINS_SERVER                 10015
#define IDD_DNS_SUFFIX                  10016
#define IDD_DLG_RPCCONFIG               10017
#define IDD_IPX_CONFIG                  10018
#define IDD_NUMBERNETCARDS              10019
#define IDD_REGIONALSETTINGS_DLG        10020
#define IDD_OEMADS_DLG                  10021
#define IDD_LANG_SPECIFIC_SETTINGS_DLG  10022
#define IDD_DHCP_CLSID                  10023
#define IDD_IPSEC                       10024
#define IDD_APPLETALK_GENERAL           10025
#define IDD_TCPIP_FILTER                10026
#define IDD_TCPIP_FILTER_ADD            10027
#define IDD_NWC_WINNT_DLG               10028
#define IDI_SERVICE                     10101
#define IDI_PROTOCOL                    10102
#define IDI_LAN                         10103
#define IDI_CLIENT                      10104
#define IDI_ADAPTER                     10105
#define IDS_NETADAPTERNUMBER            10200
#define IDS_ERROR_MISSINGPNP            10201
#define IDS_CLIENT                      10202
#define IDS_CLIENT_DESCRIPTION          10203
#define IDS_SERVICE                     10204
#define IDS_SERVICE_DESCRIPTION         10205
#define IDS_PROTOCOL                    10206
#define IDS_PROTOCOL_DESCRIPTION        10207
#define IDS_ENTERWORKGROUP              10208
#define IDS_ENTERNTDOMAIN               10209
#define IDS_ENTERUSERNAME               10210
#define IDS_ENTERUSERPASSWORD           10211
#define IDS_WINDOWS_NT_LOCATOR          10212
#define IDS_DCE_DIR_SERVICE             10213
#define IDS_IPX_DESCRIPTION             10214
#define IDS_SECURE_INITIATOR            10215
#define IDS_SECURE_INITIATOR_DESC       10216
#define IDS_SECURE_RESPONDER            10217
#define IDS_SECURE_RESPONDER_DESC       10218
#define IDS_LOCKDOWN                    10221
#define IDS_LOCKDOWN_DESC               10222
#define IDS_DHCP_ENABLED                10223
#define IDS_ADVANCED_TCPIP_SETTINGS     10224
#define IDS_IP_ADDRESS                  10225
#define IDS_SUBNET_MASK                 10226
#define IDS_ERROR_INVALID_IP_ADDRESS    10227
#define IDS_ERROR_INVALID_SUBNET_MASK   10228
#define IDS_ERROR_INVALID_GATEWAY       10229
#define IDS_ERROR_INVALID_PRIMARY_DNS   10230
#define IDS_ERROR_INVALID_SECONDARY_DNS 10231
#define IDS_AUTO_DETECT                 10232
#define IDS_ETHERNET_802_2              10233
#define IDS_ETHERNET_802_3              10234
#define IDS_ETHERNET_II                 10235
#define IDS_ETHERNET_SNAP               10236
#define IDS_TCPIP_FILTERING             10237
#define IDS_TCPIP_FILTERING_DESC        10238
#define IDS_IP_SEC                      10239
#define IDS_IP_SEC_DESC                 10240
#define IDS_PASSWORDS_DONT_MATCH        10241
#define IDS_WORKGROUP_DEFAULT_TEXT      10242
#define IDS_DOMAIN_DEFAULT_TEXT         10243
#define IDS_ERROR_NEED_IP_ADDRESS       10244
#define IDS_ERROR_NEED_SUB_ADDRESS      10245
#define IDC_DOMAIN                      10400
#define IDC_HAVEDISK                    10401
#define IDC_TYPICALNET                  10440
#define IDC_CUSTOMNET                   10441
#define IDC_ONENETWORKADAPTER           10460
#define IDC_MULTIPLENETWORKADPTERS      10461
#define IDC_NETWORKCARDNUM              10462
#define IDC_NUM_CONNECT                 10463
#define IDC_NUMBERNETADAPTERS_SPIN      10464
#define IDC_HOWMANY_STATIC              10465
#define IDC_NETWORK_ADD                 10466
#define IDC_NETWORK_EDIT                10467
#define IDC_NETWORK_DELETE              10468
#define IDC_NETWORKCARDS                10469
#define IDC_NETWORK_TEXT                10470
#define IDC_LVW_COMPLIST                10480
#define IDC_PSH_ADD                     10481
#define IDC_PSH_REMOVE                  10482
#define IDC_PSH_PROPERTIES              10483
#define IDC_TXT_COMPDESC                10484
#define IDC_PLUGANDPLAYTEXT             10485
#define IDC_PLUGANDPLAY_ID              10486
#define IDC_LVW_LAN_COMPONENTS          10500
#define IDC_TXT_COMPONENT_DESC          10501
#define IDC_PSB_COMPONENT_ADD           10502
#define IDC_SELECT_CLIENT_LIST          10520
#define IDC_SELECT_SERVICE_LIST         10540
#define IDC_SELECT_PROTOCOL_LIST        10560
#define IDC_CREATEACCT                  10580
#define IDC_DOMAINACCT                  10581
#define IDC_DOMAINPASSWD                10582
#define IDC_ACCTNAMELABEL               10583
#define IDC_ACCTPSWDLABEL               10584
#define IDC_USERACCOUNTLABEL            10585
#define IDC_RAD_WORKGROUP               10586
#define IDC_WORKGROUP                   10587
#define IDC_RAD_DOMAIN                  10588
#define IDC_CONFIRMPASSWORD             10589
#define IDC_CONFIRMLABEL                10590
#define IDC_TXT_NETADDRESS              10600
#define IDC_CMB_NAMESERVICE             10601
#define IDC_EDT_NETADDRESS              10602
#define IDC_IPXPP_TEXT                  10620
#define IDC_EDT_IPXAS_INTERNAL          10621
#define IDC_CMB_IPXPP_FRAMETYPE         10622
#define IDC_STATIC_NETNUM               10623
#define IDC_EDT_IPXPP_NETWORKNUMBER     10624
#define IDC_CB_ENABLESEEDING            10640
#define IDC_EB_NETWORKRANGE_FROM        10641
#define IDC_EB_NETWORKRANGE_TO          10642
#define IDC_CB_DEFAULTZONE              10643
#define IDC_LB_ZONELIST                 10644
#define IDC_BUT_NEWZONE                 10645
#define IDC_BUT_DELETE                  10646
#define IDC_IP_DHCP                     10660
#define IDC_IP_FIXED                    10661
#define IDC_IPADDR_IPTEXT               10662
#define IDC_IPADDR_IP                   10663
#define IDC_IPADDR_SUBTEXT              10664
#define IDC_IPADDR_SUB                  10665
#define IDC_IPADDR_GATETEXT             10666
#define IDC_IPADDR_GATE                 10667
#define IDC_DNS_DHCP                    10668
#define IDC_DNS_FIXED                   10669
#define IDC_DNS_PRIMARY_TEXT            10670
#define IDC_DNS_PRIMARY                 10671
#define IDC_DNS_SECONDARY_TEXT          10672
#define IDC_DNS_SECONDARY               10673
#define IDC_IPADDR_TEXT                 10674
#define IDC_IPADDR_ADVANCED             10675
#define IDC_IPADDR_ADVIP                10700
#define IDC_IPADDR_EDITIP               10701
#define IDC_IPADDR_REMOVEIP             10702
#define IDC_IPADDR_ADDIP                10703
#define IDC_IPADDR_ADDGATE              10704
#define IDC_IPADDR_EDITGATE             10705
#define IDC_IPADDR_REMOVEGATE           10706
#define IDC_IPADDR_UP                   10707
#define IDC_IPADDR_DOWN                 10708
#define IDC_IPADDR_ADV_CHANGE_GATEWAY   10709
#define IDC_IPADDR_ADV_CHANGEIP_IP      10740
#define IDC_IPADDR_ADV_CHANGEIP_SUB     10741
#define IDC_DNS_SERVER_ADD              10760
#define IDC_DNS_SERVER_EDIT             10761
#define IDC_DNS_SERVER_REMOVE           10762
#define IDC_DNS_SERVER_UP               10763
#define IDC_DNS_SERVER_DOWN             10764
#define IDC_DNS_DOMAIN                  10765
#define IDC_DNS_SEARCH_DOMAIN           10766
#define IDC_DNS_SEARCH_PARENT_DOMAIN    10767
#define IDC_DNS_USE_SUFFIX_LIST         10768
#define IDC_DNS_SUFFIX_LIST             10769
#define IDC_DNS_SUFFIX_ADD              10770
#define IDC_DNS_SUFFIX_EDIT             10771
#define IDC_DNS_SUFFIX_REMOVE           10772
#define IDC_DNS_SUFFIX_UP               10773
#define IDC_DNS_SUFFIX_DOWN             10774
#define IDC_DNS_SERVER_LIST             10775
#define IDC_DNS_CHANGE_SERVER           10800
#define IDC_DNS_CHANGE_SUFFIX           10820
#define IDC_WINS_SERVER_LIST            10840
#define IDC_WINS_ADD                    10841
#define IDC_WINS_EDIT                   10842
#define IDC_WINS_REMOVE                 10843
#define IDC_WINS_UP                     10844
#define IDC_WINS_DOWN                   10845
#define IDC_WINS_LOOKUP                 10846
#define IDC_WINS_LMHOST                 10847
#define IDC_RAD_ENABLE_NETBT            10848
#define IDC_RAD_DISABLE_NETBT           10849
#define IDC_RAD_UNSET_NETBT             10850
#define IDC_WINS_CHANGE_SERVER          10880
#define IDC_LVW_OPTIONS                 10900
#define IDC_OPT_PROPERTIES              10901
#define IDC_OPT_DESC                    10902
#define IDC_RAD_USE_DEFAULT             10920
#define IDC_RAD_USE_EXIST               10921
#define IDC_RAD_ENTER_NEW               10922
#define IDC_EDT_NEW_CLSID               10923
#define IDC_CMB_CLSID                   10924
#define IDC_RAD_IPSEC_NOIPSEC           10940
#define IDC_RAD_IPSEC_CUSTOM            10941
#define IDC_CMB_IPSEC_POLICY_LIST       10942
#define IDC_EDT_POLICY_DESC             10943
#define IDC_FILTERING_ENABLE            10960
#define IDC_FILTERING_FILTER_TCP        10961
#define IDC_FILTERING_FILTER_TCP_SEL    10962
#define IDC_FILTERING_TCP               10963
#define IDC_FILTERING_TCP_ADD           10964
#define IDC_FILTERING_TCP_REMOVE        10965
#define IDC_FILTERING_FILTER_UDP        10966
#define IDC_FILTERING_FILTER_UDP_SEL    10967
#define IDC_FILTERING_UDP               10968
#define IDC_FILTERING_UDP_ADD           10969
#define IDC_FILTERING_UDP_REMOVE        10970
#define IDC_FILTERING_FILTER_IP         10971
#define IDC_FILTERING_FILTER_IP_SEL     10972
#define IDC_FILTERING_IP                10973
#define IDC_FILTERING_IP_ADD            10974
#define IDC_FILTERING_IP_REMOVE         10975
#define IDC_FILTERING_TEXT              10976
#define IDC_FILTERING_ADD_EDIT          10977
#define RB_PREFERRED_SERVER             11000
#define IDC_PREFERREDSERVER             11001
#define RB_DEFAULT_CONTEXT              11002
#define SLE_DEFAULT_TREE                11003
#define SLE_DEFAULT_CONTEXT             11004
#define CHKBOX_LOGONSCRIPT              11005
#define IDC_DESCRIPTION                 11009
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         11010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\numcards.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      numcards.c
//
// Description:  
//      This file contains the dialog procedure for the number of network
//      cards page (IDD_NUMBERNETCARDS).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define NET_SPIN_CONTROL_MIN 2
#define NET_SPIN_CONTROL_MAX 20


//----------------------------------------------------------------------------
//
// Function: DeleteList
//
// Purpose: 
//
// Arguments: 
//
// Returns:  
//
//----------------------------------------------------------------------------
VOID
DeleteList( IN OUT NETWORK_ADAPTER_NODE *pNetworkAdapterList ) {

    NETWORK_ADAPTER_NODE *head;

    head = pNetworkAdapterList;

    while( head != NULL ) {

        pNetworkAdapterList = pNetworkAdapterList->next;

        free( head );

        head = pNetworkAdapterList;

    }

    pNetworkAdapterList = NULL;

}

//----------------------------------------------------------------------------
//
// Function: InstallDefaultNetComponents
//
// Purpose:  Marks these three network components as installed and all other
//           network components as NOT installed
//               1. Client for MS networks
//               2. File and Print Sharing
//               3. TCP/IP protocol
//
// Arguments: VOID
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
InstallDefaultNetComponents( VOID ) {

    NETWORK_COMPONENT *pNetComponent;

    for( pNetComponent = NetSettings.NetComponentsList;
         pNetComponent;
         pNetComponent = pNetComponent->next )
    {

        if( pNetComponent->iPosition == MS_CLIENT_POSITION ||
            pNetComponent->iPosition == FILE_AND_PRINT_SHARING_POSITION  ||
            pNetComponent->iPosition == TCPIP_POSITION )
        {
            pNetComponent->bInstalled = TRUE;
        }
        else
        {
            pNetComponent->bInstalled = FALSE;
        }

    }

}

//----------------------------------------------------------------------------
//
// Function: ResetNetworkAdapter
//
// Purpose:  Sets all network card (specified by the formal argument) settings
//           to their default values
//
// Arguments: 
//
// Returns:  
//
//----------------------------------------------------------------------------
VOID 
ResetNetworkAdapter( OUT NETWORK_ADAPTER_NODE *pNetworkCard )
{

    // ISSUE-2002/02/28-stelo- make sure every network card var is reset here
    if( pNetworkCard != NULL ) {

        pNetworkCard->next = NULL;
        pNetworkCard->previous = NULL;

        pNetworkCard->szPlugAndPlayID[0] = _T('\0');

        pNetworkCard->bObtainIPAddressAutomatically = TRUE;

        pNetworkCard->szDNSDomainName[0] = _T('\0');

        // initialize NetBIOS to "Use value generated by DHCP" option
        pNetworkCard->iNetBiosOption = 0;      

        ResetNameList( &pNetworkCard->Tcpip_IpAddresses );
        ResetNameList( &pNetworkCard->Tcpip_SubnetMaskAddresses );
        ResetNameList( &pNetworkCard->Tcpip_GatewayAddresses );
        ResetNameList( &pNetworkCard->Tcpip_DnsAddresses );
        ResetNameList( &pNetworkCard->Tcpip_WinsAddresses );

        lstrcpyn( pNetworkCard->szFrameType, _T("0xFF"), AS(pNetworkCard->szFrameType) );
        lstrcpyn( pNetworkCard->szNetworkNumber, _T("00000000"), AS(pNetworkCard->szNetworkNumber) );

    }

}

//----------------------------------------------------------------------------
//
// Function: CreateListWithDefaults
//
// Purpose:  
//
// Arguments: 
//
// Returns:  
//
//----------------------------------------------------------------------------
VOID
CreateListWithDefaults( OUT NETWORK_ADAPTER_NODE *pNetworkAdapter )
{

    NETWORK_COMPONENT *pNetComponent;

    //
    //  Initialize all the namelists to 0s
    //
    ZeroOut( pNetworkAdapter );

    ResetNetworkAdapter( pNetworkAdapter );

    //
    //  Initialize the entire list to be NOT installed
    //
    for( pNetComponent = NetSettings.NetComponentsList;
         pNetComponent;
         pNetComponent = pNetComponent->next )
    {

        pNetComponent->bInstalled = FALSE;

    }

}


//----------------------------------------------------------------------------
//
// Function: ZeroOut
//
// Purpose:  fill the namelists with zero's
//           this is necessary to do on namelists before they are used
//
// Arguments: OUT NETWORK_ADAPTER_NODE *pNetworkNode - the node that contains
//     the namelists to be Zeroed
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID 
ZeroOut( OUT NETWORK_ADAPTER_NODE *pNetworkNode) {

    ZeroMemory( &pNetworkNode->Tcpip_IpAddresses,
                sizeof( NAMELIST ) );

    ZeroMemory( &pNetworkNode->Tcpip_SubnetMaskAddresses,
                sizeof( NAMELIST ) );

    ZeroMemory( &pNetworkNode->Tcpip_GatewayAddresses,
                sizeof( NAMELIST ) );

    ZeroMemory( &pNetworkNode->Tcpip_DnsAddresses,
                sizeof( NAMELIST ) );

    ZeroMemory( &pNetworkNode->Tcpip_WinsAddresses,
                sizeof( NAMELIST ) );

}

//----------------------------------------------------------------------------
//
// Function: AddNewNetworkAdapterNode
//
// Purpose:  Adds a new Network Adapter Node (initialized to its default values)
//           onto the list given as the input arg
//
//           This function only adds to the end of a list.  If you do not pass
//           it the end of the list, the result is undefined.
//
// Arguments: IN OUT NETWORK_ADAPTER_NODE *pCurrentAdapter - node to add the
//                   new node to
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
AddNewNetworkAdapterNode( IN OUT NETWORK_ADAPTER_NODE *pCurrentAdapter ) {

    pCurrentAdapter->next = malloc( sizeof( NETWORK_ADAPTER_NODE ) );
    if (pCurrentAdapter->next == NULL)
    {
        TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);
    }
    CreateListWithDefaults( pCurrentAdapter->next );

    InstallDefaultNetComponents();

    pCurrentAdapter->next->next = NULL;
    pCurrentAdapter->next->previous = pCurrentAdapter;

}

//----------------------------------------------------------------------------
//
// Function: AdjustNetworkCardMemory
//
// Purpose: examines the Global list NetSettings.NetworkCardList
//          if more network cards are necessary, it allocates more lists
//          if fewer network cards are necessary, it deallocates the 
//            appropriate number of lists
//          if they are equal, then do nothing
//          Therefore, when the function returns, the length of 
//          NetSettings.NetworkCardList is equal to the new number of
//          network cards
//
// Arguments: IN int NewNumberOfNetworkCards - 
//            IN int OldNumberOfNetworkCards - 
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
AdjustNetworkCardMemory( IN int NewNumberOfNetworkCards,
                         IN int OldNumberOfNetworkCards ) {

    INT i;

    NetSettings.pCurrentAdapter = NetSettings.NetworkAdapterHead;

    if( NewNumberOfNetworkCards > OldNumberOfNetworkCards ) {

        //
        //  NewNumberOfNetworkCards-1, the -1 because there is always
        //  at least 1 network adapter list
        //
        for( i = 0; i < NewNumberOfNetworkCards-1; i++ ) {

            //
            //  Allocate more lists, if necessary
            //

            if( NetSettings.pCurrentAdapter->next == NULL ) {

                AddNewNetworkAdapterNode( NetSettings.pCurrentAdapter );

            }

            //
            //  Advance to the next node
            //

            NetSettings.pCurrentAdapter = NetSettings.pCurrentAdapter->next;

        }

    }
    else if( NewNumberOfNetworkCards < OldNumberOfNetworkCards ) {

        NETWORK_ADAPTER_NODE* pTempNode;  // used to hold the current position
        NETWORK_ADAPTER_NODE* pTempNode2; // used delete the list

        //
        //  Advance to the last network list we are keeping and delete all 
        //  the ones after that
        //
        for( i = 0;
             i < (NewNumberOfNetworkCards - 1);
             i++ ) {

            NetSettings.pCurrentAdapter = NetSettings.pCurrentAdapter->next;

        }

        //
        //  save the pointer to the rest of the list
        //

        pTempNode = NetSettings.pCurrentAdapter->next;
            
        NetSettings.pCurrentAdapter->next = NULL;
            
        for( ;
             i < NewNumberOfNetworkCards;
             i++ ) {


             pTempNode2 = pTempNode;

             pTempNode = pTempNode->next;

             //
             // deallocate the rest of the list
             //

             DeleteList( pTempNode2 );

        }

    }

    //
    //  Reset NetSettings.pCurrentNetworkList to the first node in the list
    //

    NetSettings.pCurrentAdapter = NetSettings.NetworkAdapterHead;

}

//----------------------------------------------------------------------------
//
// Function: EnableNetCardControls
//
// Purpose:  Greys or ungreys the 3 controls that let the user change the
//           number of network cards installed
//
// Arguments: 
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID 
EnableNetCardControls( IN HWND hwnd, IN BOOL bState ) {

    //
    //  Grab handles to each of the controls
    //
    HWND hHowManyText  = GetDlgItem( hwnd, IDC_HOWMANY_STATIC );
    HWND hCountEditBox = GetDlgItem( hwnd, IDC_NUM_CONNECT );
    HWND hSpinControl  = GetDlgItem( hwnd, IDC_NUMBERNETADAPTERS_SPIN );

    //
    //  Grey or ungrey them appropriately
    //
    EnableWindow( hHowManyText, bState );
    EnableWindow( hCountEditBox, bState );
    EnableWindow( hSpinControl, bState );

    //
    //  Set the initial value of the spin control
    //
    if( bState && NetSettings.iNumberOfNetworkCards > 1 ) {
        TCHAR szNumberOfNetCards[3];

        _itow( NetSettings.iNumberOfNetworkCards, szNumberOfNetCards, 10 );

        SetWindowText( hCountEditBox, szNumberOfNetCards );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnNumCardsInitDialog
//
// Purpose: 
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
OnNumCardsInitDialog( IN HWND hwnd ) {

    //
    //  Set the range on the spin control: NET_SPIN_CONTROL_MIN to
    //  NET_SPIN_CONTROL_MAX
    //

    SendDlgItemMessage( hwnd,
                        IDC_NUMBERNETADAPTERS_SPIN,
                        UDM_SETRANGE32,
                        NET_SPIN_CONTROL_MIN,
                        NET_SPIN_CONTROL_MAX );

    //
    //  Set the default value for the spin control
    //

    SendDlgItemMessage( hwnd,
                        IDC_NUMBERNETADAPTERS_SPIN,
                        UDM_SETPOS,
                        0,
                        NET_SPIN_CONTROL_MIN );

}

//----------------------------------------------------------------------------
//
// Function: OnNumberNetCardsSetActive
//
// Purpose: 
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnNumberNetCardsSetActive( IN HWND hwnd ) {

    if( NetSettings.iNumberOfNetworkCards < 2 ) {
        //
        //  One network adapter radio button chosen
        //
        CheckRadioButton( hwnd,
                          IDC_ONENETWORKADAPTER,
                          IDC_MULTIPLENETWORKADPTERS,
                          IDC_ONENETWORKADAPTER );

        //
        //  The controls under the multiple adapters greyed-out
        //
        EnableNetCardControls( hwnd, FALSE );

    }
    else {
        //
        //  We are in the multiple adapter case
        //

        //
        //  Multiple network adapter radio button chosen
        //
        CheckRadioButton( hwnd,
                          IDC_ONENETWORKADAPTER,
                          IDC_MULTIPLENETWORKADPTERS,
                          IDC_MULTIPLENETWORKADPTERS );

        //
        //  The controls under the multiple adapters enabled
        //
        EnableNetCardControls( hwnd, TRUE );

    }

    PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT );

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextNumCards
//
// Purpose: 
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
OnWizNextNumCards( IN HWND hwnd ) {

    if( IsDlgButtonChecked( hwnd, IDC_ONENETWORKADAPTER ) == BST_CHECKED ) {
        //
        //  Single network adapter case
        //

        NetSettings.iNumberOfNetworkCards = 1;

    }
    else {

        //
        //  Multiple network adapter case
        //
 
        TCHAR szNumber[3];
        INT NewNumberOfNetworkCards;

        //
        //  Convert the string number to an int
        //
        GetWindowText( GetDlgItem( hwnd, IDC_NUM_CONNECT ), szNumber, 3 );
                            
        NewNumberOfNetworkCards = _ttoi( szNumber );

        //
        //  Ensure the number of network cards stays within its appropriate
        //  range
        //
        if( NewNumberOfNetworkCards < NET_SPIN_CONTROL_MIN ) {

            NewNumberOfNetworkCards = NET_SPIN_CONTROL_MIN;

        }
        else if( NewNumberOfNetworkCards > NET_SPIN_CONTROL_MAX ) {

            NewNumberOfNetworkCards = NET_SPIN_CONTROL_MAX;

        }

        //
        //  Adjust memory for the network lists accordingly
        //
        AdjustNetworkCardMemory( NewNumberOfNetworkCards,
                                 NetSettings.iNumberOfNetworkCards );

        NetSettings.iNumberOfNetworkCards = NewNumberOfNetworkCards;

    }

}

//----------------------------------------------------------------------------
//
// Function: DlgNumberNetCardsPage
//
// Purpose: 
//
// Arguments: standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK DlgNumberNetCardsPage( IN HWND     hwnd,    
                                    IN UINT     uMsg,        
                                    IN WPARAM   wParam,    
                                    IN LPARAM   lParam) {   

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnNumCardsInitDialog( hwnd );

            break;

        }

        case WM_COMMAND: {
            switch ( LOWORD(wParam) ) {

                case IDC_ONENETWORKADAPTER:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        EnableNetCardControls( hwnd, FALSE );

                    }

                    break;
                
                case IDC_MULTIPLENETWORKADPTERS:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        EnableNetCardControls( hwnd, TRUE );

                    }

                    break;

            }
  
            break;

        }        

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    CancelTheWizard(hwnd); break;

                case PSN_SETACTIVE:

                    OnNumberNetCardsSetActive( hwnd );

                    break;

                case PSN_WIZBACK:

                    bStatus = FALSE; break;

                case PSN_WIZNEXT: 
                    
                    OnWizNextNumCards( hwnd );

                    break;

                default:

                    break;
            }


            break;
        }
            
        default: 
            bStatus = FALSE;
            break;

    }

    return bStatus;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\service.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      service.c
//
// Description:
//
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: InitSelectServiceListView
//
// Purpose:
//
//----------------------------------------------------------------------------
VOID
InitSelectServiceListView( HWND hDlg, HINSTANCE hInst )
{

    LV_ITEM lvI;                    // list view item structure
    HWND hServiceListView;          // handle to list view window
    NETWORK_COMPONENT *pNetComponent;

    hServiceListView = GetDlgItem( hDlg, IDC_SELECT_SERVICE_LIST );

    for( pNetComponent = NetSettings.NetComponentsList;
         pNetComponent;
         pNetComponent = pNetComponent->next )
    {

        if( pNetComponent->bInstalled == FALSE &&
            pNetComponent->ComponentType == SERVICE )
        {

            //
            //  If it is not a sysprep then just go ahead and add it to the
            //  list view.  If we are doing a sysprep, check to see if this
            //  component is supported by sysprep to see if we should add it
            //  or not
            //
            if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
            {
                if( pNetComponent->bSysprepSupport )
                {
                    InsertEntryIntoListView( hServiceListView,
                                             (LPARAM) pNetComponent );
                }
            }
            else
            {

                InsertEntryIntoListView( hServiceListView,
                                         (LPARAM) pNetComponent );

            }

        }

    }

    SetListViewSelection( hDlg, IDC_SELECT_SERVICE_LIST, 0 );

}

//----------------------------------------------------------------------------
//
// Function:  OnServiceOk
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnServiceOk( IN HWND hwnd )
{

    LV_ITEM lvI;

    // ISSUE-2002/02/28-stelo- if there is no item selected and the user clicks OK the dialog should NOT close

    // see if there is an item selected
    if(GetSelectedItemFromListView(hwnd, IDC_SELECT_SERVICE_LIST, &lvI)) {

        NETWORK_COMPONENT *pEntry = (NETWORK_COMPONENT *)lvI.lParam;

        pEntry->bInstalled = TRUE;

        // return a 1 to show an item was actually added
        EndDialog(hwnd, 1);
    }
    else {
        // return a 0 to show no items were added because the list is empty
        EndDialog(hwnd, 0);
    }

}

//----------------------------------------------------------------------------
//
// Function:  NotifyHandler
//
// Purpose:
//
// Arguments: IN HWND hwnd - handle to the dialog
//            IN WPARAM wParam -
//            IN LPARAM lParam -
//
// Returns:  BOOL - whether the message was handled or not
//
//----------------------------------------------------------------------------
static BOOL
NotifyHandler( IN HWND hwnd, IN WPARAM wParam, IN LPARAM lParam )
{

    LV_DISPINFO *pLvdi = (LV_DISPINFO *)lParam;
    NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
    NETWORK_COMPONENT *pListViewString = (NETWORK_COMPONENT *)(pLvdi->item.lParam);
    BOOL bStatus = TRUE;

    if( wParam == IDC_SELECT_SERVICE_LIST )
    {
        switch( pLvdi->hdr.code )
        {
            case LVN_GETDISPINFO:
                pLvdi->item.pszText = pListViewString->StrComponentName;
                break;
        }

        switch( pNm->hdr.code )
        {

            case NM_DBLCLK:
            {

                NMITEMACTIVATE *pNmItemActivate = (NMITEMACTIVATE *) lParam;

                //
                // see if the user has double clicked inside the list view
                //

                if( pNm->hdr.idFrom == IDC_SELECT_SERVICE_LIST )
                {

                    //
                    //  Make sure they actually clicked on an item and not just
                    //  empty space
                    //

                    if( pNmItemActivate->iItem != -1 )
                    {
                        OnServiceOk( hwnd );
                    }

                }
                break;

            }

            default:

                bStatus = FALSE;

                break;

        }


    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
// Function: SelectNetworkServiceDlgProc
//
// Purpose:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK SelectNetworkServiceDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch (uMsg) {
        case WM_DESTROY:
            // do nothing
            break;

        case WM_INITDIALOG:
            InitSelectServiceListView(hwnd, FixedGlobals.hInstance);
            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) ) {
                    case IDOK:
                        OnServiceOk( hwnd );
                        break;

                    case IDCANCEL:
                        // return a 0 to show no items were added
                        EndDialog(hwnd, 0);
                        break;

                    case IDC_HAVEDISK:
                        //  ISSUE-2002/02/28-stelo- this needs to be implemented
                        AssertMsg(FALSE,
                                  "This button has not been implemented yet.");
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
                break;
            }
        case WM_NOTIFY:
            NotifyHandler( hwnd, wParam, lParam );
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\tcpip.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      tcpip.c
//
// Description:
//      This file contains the dialog procedure for the base TCP/IP page
//      (IDD_TCP_IPADDR).  Let's the user set DHCP or specific IPs or go to
//      Advanced TCP/IP settings.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

BOOL Create_TCPIPProp_PropertySheet( HWND hwndParent );

BOOL ValidateIPAddress( IN TCHAR szIPAddress[] );

BOOL ValidateSubnetMask( IN TCHAR szIPAddress[] );

UINT CALLBACK TCPIP_PropertiesPageProc( HWND hwnd,
                                        UINT uMsg,
                                        LPPROPSHEETPAGE ppsp );

INT_PTR CALLBACK TCPIP_PropertiesDlgProc( IN HWND     hwnd,
                                      IN UINT     uMsg,
                                      IN WPARAM   wParam,
                                      IN LPARAM   lParam );

static PROPSHEETHEADER pshead;
static PROPSHEETPAGE   pspage;

static const TCHAR Period = _T('.');

//----------------------------------------------------------------------------
//
// Function: ValidatePage
//
// Purpose:  tests to see if the contents of the TCP/IP page are valid ( to
//           see if it is safe to move off this page )
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: BOOL - TRUE if all fields are valid
//                 False if some are not valid
//
//----------------------------------------------------------------------------
BOOL
ValidatePage( IN HWND hwnd )
{

    INT_PTR iNumBlankFields;
    DWORD dwIpValue;

    //
    //  If using DHCP, then no need to check any of the settings
    //

    if( IsDlgButtonChecked( hwnd, IDC_IP_DHCP ) )
    {

        return( TRUE );

    }
    else
    {

        //
        //  Check that the IP and Subnet mask fields are completely
        //  filled-out.  I only check these 2 fields because that is all the
        //  system checks to get off this dialog.
        //

        iNumBlankFields = 4 - SendDlgItemMessage( hwnd,
                                                  IDC_IPADDR_IP,
                                                  IPM_GETADDRESS,
                                                  (WPARAM) 0,
                                                  (LPARAM) &dwIpValue );

        if( iNumBlankFields > 0 )
        {

            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ERROR_NEED_IP_ADDRESS );

            return( FALSE );


        }

        iNumBlankFields = 4 - SendDlgItemMessage( hwnd,
                                                  IDC_IPADDR_SUB,
                                                  IPM_GETADDRESS,
                                                  (WPARAM) 0,
                                                  (LPARAM) &dwIpValue );

        if( iNumBlankFields > 0 )
        {

            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ERROR_NEED_SUB_ADDRESS );

            return( FALSE );


        }


    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: StoreIPSettings
//
// Purpose: takes the values currently in the IP edit boxes and stores them
//          into the NetSettings global variable
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: BOOL - TRUE if all the IP address are valid and they get stored
//                 FALSE if there was an error
//
//----------------------------------------------------------------------------
BOOL
StoreIPSettings( IN HWND hwnd )
{

    INT_PTR iIsBlank;
    INT iFoundStatus;

    if( IsDlgButtonChecked( hwnd, IDC_IP_DHCP ) == BST_CHECKED )
    {

        NetSettings.pCurrentAdapter->bObtainIPAddressAutomatically = TRUE;

    }
    else
    {

        TCHAR szIpBuffer[IPSTRINGLENGTH + 1];

        HWND hIPEditBox      = GetDlgItem( hwnd, IDC_IPADDR_IP   );
        HWND hSubnetEditBox  = GetDlgItem( hwnd, IDC_IPADDR_SUB  );
        HWND hGatewayEditBox = GetDlgItem( hwnd, IDC_IPADDR_GATE );


        NetSettings.pCurrentAdapter->bObtainIPAddressAutomatically = FALSE;

        //
        //  Only store the data if the IP isn't blank
        //      - if it's not blank then grab it and store it in a buffer
        //      - if the IP is not already in the list then add it to the front
        //      - if it is already in the list, remove it and add it to the front
        //

        iIsBlank = SendMessage( hIPEditBox, IPM_ISBLANK, 0, 0 );

        if( ! iIsBlank )
        {

            GetWindowText( hIPEditBox,
                           szIpBuffer,
                           IPSTRINGLENGTH + 1 );    // +1 for null character

            iFoundStatus = FindNameInNameList( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses,
                                               szIpBuffer );

            if( iFoundStatus != NOT_FOUND )
            {

                RemoveNameFromNameListIdx( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses,
                                           iFoundStatus );

                RemoveNameFromNameListIdx( &NetSettings.pCurrentAdapter->Tcpip_SubnetMaskAddresses,
                                           iFoundStatus );

            }

            AddNameToNameListIdx( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses,
                                  szIpBuffer,
                                  0 );

        }

        iIsBlank = SendMessage( hSubnetEditBox, IPM_ISBLANK, 0, 0 );

        if( ! iIsBlank )
        {

            GetWindowText( hSubnetEditBox,
                           szIpBuffer,
                           IPSTRINGLENGTH + 1 );    // +1 for null character

            AddNameToNameListIdx( &NetSettings.pCurrentAdapter->Tcpip_SubnetMaskAddresses,
                                  szIpBuffer,
                                  0 );

        }

        iIsBlank = SendMessage( hGatewayEditBox, IPM_ISBLANK, 0, 0 );

        if( ! iIsBlank )
        {

            GetWindowText( hGatewayEditBox,
                           szIpBuffer,
                           IPSTRINGLENGTH + 1 );  // +1 for null character

            iFoundStatus = FindNameInNameList( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses,
                                               szIpBuffer );

            if( iFoundStatus != NOT_FOUND )
            {

                RemoveNameFromNameListIdx( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses,
                                           iFoundStatus );

            }

            AddNameToNameListIdx( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses,
                                  szIpBuffer,
                                  0 );

        }

    }

    if( IsDlgButtonChecked(hwnd, IDC_DNS_DHCP) == BST_CHECKED )
    {

        NetSettings.bObtainDNSServerAutomatically = TRUE;

    }
    else
    {

        TCHAR szDnsBuffer[IPSTRINGLENGTH + 1];
        HWND hPrimaryDNSEditBox   = GetDlgItem( hwnd, IDC_DNS_PRIMARY   );
        HWND hSecondaryDNSEditBox = GetDlgItem( hwnd, IDC_DNS_SECONDARY );

        NetSettings.bObtainDNSServerAutomatically = FALSE;

        //
        //  Only store the data if the IP isn't blank
        //

        iIsBlank = SendMessage( hSecondaryDNSEditBox, IPM_ISBLANK, 0, 0 );

        if( ! iIsBlank )
        {

            GetWindowText( hSecondaryDNSEditBox,
                           szDnsBuffer,
                           IPSTRINGLENGTH + 1 );   // +1 for null character

            TcpipNameListInsertIdx( &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses,
                                    szDnsBuffer,
                                    0 );

        }

        iIsBlank = SendMessage( hPrimaryDNSEditBox, IPM_ISBLANK, 0, 0 );

        if( ! iIsBlank )
        {

            GetWindowText( hPrimaryDNSEditBox,
                           szDnsBuffer,
                           IPSTRINGLENGTH + 1 );     // +1 for null character

            TcpipNameListInsertIdx( &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses,
                                    szDnsBuffer,
                                    0 );

        }

    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: EnableIPAddressControls
//
// Purpose:  Greys or ungreys the IP Address text and edit boxes
//
// Arguments:  IN HWND hwnd - handle to the dialog
//             IN BOOL bVisible - TRUE to enable the IP address controls
//                                FALSE to grey them
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
EnableIPAddressControls( IN HWND hwnd, IN BOOL bVisible )
{

    EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_IPTEXT ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_SUBTEXT ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_GATETEXT ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_IP ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_SUB ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_GATE ),
                  bVisible );

}

//----------------------------------------------------------------------------
//
// Function: EnableServerAddressControls
//
// Purpose:  Greys or ungreys the Server Address text and edit boxes
//
// Arguments:  IN HWND hwnd - handle to the dialog
//             IN BOOL bVisible - TRUE to enable the Server address controls
//                                FALSE to grey them
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
EnableServerAddressControls( IN HWND hwnd, IN BOOL bVisible )
{

    EnableWindow( GetDlgItem( hwnd, IDC_DNS_PRIMARY_TEXT ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_DNS_SECONDARY_TEXT ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_DNS_PRIMARY ),
                  bVisible );

    EnableWindow( GetDlgItem( hwnd, IDC_DNS_SECONDARY ),
                  bVisible );

}

//----------------------------------------------------------------------------
//
// Function: SetTCPIPControls
//
// Purpose:  uses settings in global variable NetSettings to set the TCP/IP
//           window states appropriately and fill the edit boxes with data
//           where appropriate
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
SetTCPIPControls( IN HWND hwnd )
{

    //
    //  Set the button and window states for IP
    //

    if( NetSettings.pCurrentAdapter->bObtainIPAddressAutomatically )
    {

        CheckRadioButton( hwnd, IDC_IP_DHCP, IDC_IP_FIXED, IDC_IP_DHCP );

        //
        // Gray out the IP address strings and boxes
        //

        EnableIPAddressControls( hwnd, FALSE );

    }
    else
    {

        CheckRadioButton( hwnd, IDC_IP_DHCP, IDC_IP_FIXED, IDC_IP_FIXED );

        //
        //    Fill in the IP, Subnet Mask and Gateway data
        //

        SetWindowText( GetDlgItem( hwnd, IDC_IPADDR_IP ),
                       GetNameListName( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses, 0 ) );

        SetWindowText( GetDlgItem( hwnd, IDC_IPADDR_SUB ),
                       GetNameListName( &NetSettings.pCurrentAdapter->Tcpip_SubnetMaskAddresses, 0 ) );

        SetWindowText( GetDlgItem( hwnd, IDC_IPADDR_GATE ),
                       GetNameListName( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses, 0 ) );


    }

    //
    //  Set the button and window states for DNS
    //

    if( NetSettings.bObtainDNSServerAutomatically )
    {

        CheckRadioButton( hwnd, IDC_DNS_DHCP, IDC_DNS_FIXED, IDC_DNS_DHCP );

        //
        //  Gray out the IP address strings and boxes
        //

        EnableServerAddressControls( hwnd, FALSE );

    }
    else
    {

        TCHAR *szDns;

        CheckRadioButton( hwnd, IDC_DNS_DHCP, IDC_DNS_FIXED, IDC_DNS_FIXED );

        //
        //  Ensure the controls are visible and fill in the strings for
        //  Primary and Secondary DNS
        //

        EnableServerAddressControls( hwnd, TRUE );


        szDns = GetNameListName( &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses,
                                 0 );

        SetWindowText( GetDlgItem( hwnd, IDC_DNS_PRIMARY ), szDns );


        szDns = GetNameListName( &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses,
                                 1 );

        SetWindowText( GetDlgItem( hwnd, IDC_DNS_SECONDARY ), szDns );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnAdvancedClicked
//
// Purpose:  Creates the Advanced TCP/IP property sheet for the user to specify
//           additional TCP/IP settings.
//
// Arguments: standard Win32 dialog proc arguments passed through from the
//            dialog proc
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
OnAdvancedClicked( IN HWND     hwnd,
                   IN UINT     uMsg,
                   IN WPARAM   wParam,
                   IN LPARAM   lParam )
{

    HWND hGatewayEditBox = GetDlgItem( hwnd, IDC_IPADDR_GATE );

    //
    //  store the IP settings in the NetSettings global variable so the
    //  advanced pages can access data in it
    //

    StoreIPSettings( hwnd );

    Create_TCPIPProp_PropertySheet( hwnd );

    //
    //  Fill boxes with (potentially) new data from the TCP/IP Advanced screens
    //

    SetTCPIPControls( hwnd );

    //
    //  always set the gateway because a user can still set this even if they
    //  have DHCP enabled
    //

    SetWindowText( hGatewayEditBox,
                   GetNameListName( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses, 0 ) );

}

//----------------------------------------------------------------------------
//
// Function: OnDNSRadioButtonsClicked
//
// Purpose:  Grey/Ungrey the DNS controls appropriately and clear DNS entries,
//           as necessary.
//
// Arguments:  standard Win32 dialog proc arguments passed through from the
//             dialog proc
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnDNSRadioButtonsClicked( IN HWND     hwnd,
                          IN UINT     uMsg,
                          IN WPARAM   wParam,
                          IN LPARAM   lParam )
{

    INT nButtonId = LOWORD( wParam );

    if ( HIWORD( wParam ) == BN_CLICKED )
    {

        CheckRadioButton( hwnd, IDC_DNS_DHCP, IDC_DNS_FIXED, nButtonId );

        if( nButtonId == IDC_DNS_FIXED )
        {

            //
            //  User clicked the radio button to have fixed DNS servers so
            //  Un-grey the DNS strings and boxes so the user can
            //  edit them
            //

            EnableServerAddressControls( hwnd, TRUE );

        }
        else
        {

            //
            //  User clicked the radio button to have assigned DNS servers so
            //  Grey the DNS strings and boxes so the user can not
            //  edit them
            //
            EnableServerAddressControls( hwnd, FALSE );

            //
            //  clear the DNS Address list
            //

            ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses );

            //
            //  clear the contents of the Primary and Secondary edit boxes
            //

            SetWindowText( GetDlgItem( hwnd, IDC_DNS_PRIMARY ), _T("") );

            SetWindowText( GetDlgItem( hwnd, IDC_DNS_SECONDARY ), _T("") );

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: OnIPRadioButtonsClicked
//
// Purpose:  Grey/Ungrey the IP controls appropriately and clear the IP data
//           structures, as necessary.
//
// Arguments:  standard Win32 dialog proc arguments passed through from the
//             dialog proc
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnIPRadioButtonsClicked( IN HWND     hwnd,
                         IN UINT     uMsg,
                         IN WPARAM   wParam,
                         IN LPARAM   lParam )
{

    INT nButtonId = LOWORD(wParam);

    if ( HIWORD(wParam) == BN_CLICKED )
    {

        CheckRadioButton( hwnd,
                          IDC_IP_DHCP,
                          IDC_IP_FIXED,
                          nButtonId );

        if ( nButtonId == IDC_IP_FIXED )
        {

            //
            //  User chose the radio button to specify and IP, Subnet Mask
            //  and Gateway
            //
            //  Un-grey the IP address strings and boxes
            //  so the user can specify them
            //

            EnableIPAddressControls( hwnd, TRUE );

            //
            //  If the user is going to specify their IP addresses then
            //  they must specify their DNS server addresses so force
            //  the manual radio box to be checked and un-grey the boxes
            //

            CheckRadioButton( hwnd,
                              IDC_DNS_DHCP,
                              IDC_DNS_FIXED,
                              IDC_DNS_FIXED );

            EnableServerAddressControls( hwnd, TRUE );

            //
            //  clear the list to avoid the string "DHCP enabled" from being
            //  placed in the IP edit box
            //

            ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses );


            //
            //  Don't allow user to click the 'obtain DNS server automatically'
            //

            EnableWindow( GetDlgItem( hwnd, IDC_DNS_DHCP ),
                          FALSE );


        }
        else
        {

            //
            //  User to chose DHCP (have an IP assigned automatically)
            //
            //  Grey out the IP address strings and boxes because they are
            //  using DHCP
            //

            EnableIPAddressControls( hwnd, FALSE );

            //
            //  clear the contents of the IP, Subnet and Gateway edit boxes
            //  because using DHCP
            //

            SetWindowText( GetDlgItem( hwnd, IDC_IPADDR_IP ),   _T("") );

            SetWindowText( GetDlgItem( hwnd, IDC_IPADDR_SUB ),  _T("") );

            SetWindowText( GetDlgItem( hwnd, IDC_IPADDR_GATE ), _T("") );

            //
            //  Clear the lists that contain the IP, Subnet and
            //  Gateway data
            //

            ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses );

            ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_SubnetMaskAddresses );

            ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses );

            //
            //  Allow the user to be able to select 'obtain DNS server
            //  automatically'
            //

            EnableWindow( GetDlgItem( hwnd, IDC_DNS_DHCP ), TRUE );

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: OnTcpipInitDialog
//
// Purpose:  Sets the text limits on the edit boxes and fills in initial data
//           and greys controls appropriately.
//
// Arguments: IN HWND hwnd - handle to the dialog box
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
OnTcpipInitDialog( IN HWND hwnd )
{

    //
    //  Set the text limit on the edit boxes to IPSTRINGLENGTH
    //

    SendDlgItemMessage( hwnd,
                        IDC_IPADDR_IP,
                        EM_LIMITTEXT,
                        (WPARAM) IPSTRINGLENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_IPADDR_SUB,
                        EM_LIMITTEXT,
                        (WPARAM) IPSTRINGLENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_IPADDR_GATE,
                        EM_LIMITTEXT,
                        (WPARAM) IPSTRINGLENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_DNS_PRIMARY,
                        EM_LIMITTEXT,
                        (WPARAM) IPSTRINGLENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_DNS_SECONDARY,
                        EM_LIMITTEXT,
                        (WPARAM) IPSTRINGLENGTH,
                        (LPARAM) 0 );

    SetTCPIPControls( hwnd );

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_PropertiesDlgProc
//
// Purpose:
//
// Arguments: standard Win32 dialog proc arguments
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
TCPIP_PropertiesDlgProc( IN HWND     hwnd,
                         IN UINT     uMsg,
                         IN WPARAM   wParam,
                         IN LPARAM   lParam )
{

    BOOL bStatus = TRUE;

    switch( uMsg )
    {

        case WM_INITDIALOG:

            OnTcpipInitDialog( hwnd );

            break;

        case WM_NOTIFY:
        {

            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch( pnmh->code )
            {

                case PSN_APPLY:
                {

                    //
                    // store the IP settings in the NetSettings global variable
                    //
                    if( ValidatePage( hwnd ) )
                    {

                        StoreIPSettings( hwnd );

                    }
                    else
                    {

                        //
                        //  if the validation fails then stay on this page
                        //

                        SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );

                        return( PSNRET_INVALID_NOCHANGEPAGE );

                    }

                }

            }

        }    // end case WM_NOTIFY

        case WM_COMMAND:
        {
            int nButtonId;

            switch ( nButtonId = LOWORD(wParam) )
            {

                case IDC_IP_DHCP:
                case IDC_IP_FIXED:

                    OnIPRadioButtonsClicked( hwnd,
                                             uMsg,
                                             wParam,
                                             lParam );

                    break;

                case IDC_DNS_DHCP:
                case IDC_DNS_FIXED:

                    OnDNSRadioButtonsClicked( hwnd,
                                              uMsg,
                                              wParam,
                                              lParam );

                    break;

                case IDC_IPADDR_ADVANCED:
                {

                    OnAdvancedClicked( hwnd,
                                       uMsg,
                                       wParam,
                                       lParam );

                    break;

                }
                default:

                    bStatus = FALSE;

                    break;

                }

                break;

            }

        default:

            bStatus = FALSE;

            break;

    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_PropertySheetProc
//
// Purpose:  Standard Property Sheet dialog proc.  Very boring.
//
//----------------------------------------------------------------------------
int CALLBACK
TCPIP_PropertySheetProc( HWND hwndDlg, UINT uMsg, LPARAM lParam )
{

     switch( uMsg ) {

          case PSCB_INITIALIZED :
               // Process PSCB_INITIALIZED
               break;

          case PSCB_PRECREATE :
               // Process PSCB_PRECREATE
               break;

          default :
               // Unknown message
               break;

    }

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_PropertiesPageProc
//
// Purpose:  Standard Property Page dialog proc.
//
//----------------------------------------------------------------------------
UINT CALLBACK
TCPIP_PropertiesPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp )
{

    switch( uMsg ) {

          case PSPCB_CREATE :
               return( TRUE );

          case PSPCB_RELEASE :
               return( 0 );
    }

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: Create_TCPIP_PropertySheet
//
// Purpose:  Sets up settings for the property sheet and the TCP/IP page (in
//           this case the property sheet is just 1 page).  Lastly, calls the
//           PropertySheet function to display the property sheet, the return
//           value of this function is what is passed back as the return value
//
// Arguments: IN HWND hwndParent - handle to the dialog that is spawning the
//                                 property sheet
//
// Returns: BOOL - the returned value from the Property Sheet
//
//----------------------------------------------------------------------------
BOOL
Create_TCPIP_PropertySheet( IN HWND hwndParent )
{

    INT i;

    // Initialize property sheet HEADER data
    ZeroMemory (&pshead, sizeof (PROPSHEETHEADER)) ;
    pshead.dwSize  = sizeof (PROPSHEETHEADER) ;
    pshead.dwFlags = PSH_PROPSHEETPAGE |
                     PSH_USECALLBACK   |
                     PSH_USEHICON      |
                     PSH_NOAPPLYNOW;
    pshead.hwndParent  = hwndParent ;
    pshead.hInstance   = FixedGlobals.hInstance;
    pshead.pszCaption  = g_StrTcpipTitle;
    pshead.nPages      = 1 ;
    pshead.nStartPage  = 0 ;
    pshead.ppsp        = &pspage ;
    pshead.pfnCallback = TCPIP_PropertySheetProc ;

    // Zero out property PAGE data
    ZeroMemory (&pspage, 1 * sizeof (PROPSHEETPAGE)) ;

    pspage.dwSize      = sizeof (PROPSHEETPAGE) ;
    pspage.dwFlags     = PSP_USECALLBACK ;
    pspage.hInstance   = FixedGlobals.hInstance;
    pspage.pszTemplate = MAKEINTRESOURCE(IDD_TCP_IPADDR) ;
    pspage.pfnDlgProc  = TCPIP_PropertiesDlgProc ;
    pspage.pfnCallback = TCPIP_PropertiesPageProc ;

    // --------- Create & display property sheet ---------
    return( PropertySheet( &pshead ) ? TRUE : FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\tcpip.h ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//    tcpip.h
//
// Description:
//
//----------------------------------------------------------------------------

#ifndef _TCPIP_H_
#define _TCPIP_H_

#define cIPSettingsColumns  2
#define cTCPIPPropertyPages 3

#define MAX_IP_LENGTH  255

//
// Constants for Edit Boxes
//

// ISSUE-2002/02/28-stelo- change to enum
#define GATEWAY_EDITBOX       1
#define DNS_SERVER_EDITBOX    2
#define DNS_SUFFIX_EDITBOX    3
#define WINS_EDITBOX          4

//
//    Function Prototypes
//
UINT CALLBACK TCPIP_IPSettingsPageProc (HWND  hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
INT_PTR CALLBACK TCPIP_IPSettingsDlgProc (HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

UINT CALLBACK TCPIP_DNSPageProc (HWND  hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
INT_PTR CALLBACK TCPIP_DNSDlgProc (HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

UINT CALLBACK TCPIP_WINSPageProc (HWND  hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
INT_PTR CALLBACK TCPIP_WINSDlgProc (HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

UINT CALLBACK TCPIP_OptionsPageProc (HWND  hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);
INT_PTR CALLBACK TCPIP_OptionsDlgProc (HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam);

VOID OnAddButtonPressed(HWND hwnd, WORD ListBoxControlID,
                        WORD EditButtonControlID, WORD RemoveButtonControlID,
                        LPCTSTR Dialog, DLGPROC DialogProc);
VOID OnEditButtonPressed(HWND hwnd, WORD ListBoxControlID, LPCTSTR Dialog, DLGPROC DialogProc);
VOID OnRemoveButtonPressed(HWND hwnd, WORD ListBoxControlID, WORD EditButtonControlID, WORD RemoveButtonControlID);
VOID OnUpButtonPressed(HWND hwnd, WORD ListBoxControlID);
VOID OnDownButtonPressed(HWND hwnd, WORD ListBoxControlID);
VOID SetArrows(HWND hwnd, WORD ListBoxControlID, WORD UpButtonControlID, WORD DownButtonControlID);
VOID SetButtons( HWND hListBox, HWND hEditButton, HWND hRemoveButton );
BOOL InsertItemIntoTcpipListView( HWND hListView,
                                  LPARAM lParam,
                                  UINT position );

INT_PTR CALLBACK GenericIPDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK ChangeIPDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK DhcpClassIdDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

INT_PTR CALLBACK IpSecurityDlgProc(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam);

VOID AddValuesToListBox(HWND hListBox, NAMELIST* pNameList, int iPosition);

// struct used for IP List View
typedef struct {
    TCHAR szIPString[IPSTRINGLENGTH+1];
    TCHAR szSubnetMask[IPSTRINGLENGTH+1];
} IP_STRUCT;


//  ISSUE-2002/02/28-stelo-
//  Try and make as many of these static as possible (cut down the scope)
//
PROPSHEETHEADER TCPIPProp_pshead ;
PROPSHEETPAGE   TCPIPProp_pspage[cTCPIPPropertyPages] ;
HICON   g_hIconUpArrow;
HICON   g_hIconDownArrow;

TCHAR *StrSecureInitiator;
TCHAR *StrSecureInitiatorDesc;

TCHAR *StrSecureResponder;
TCHAR *StrSecureResponderDesc;

TCHAR *StrSecureL2TPOnly;
TCHAR *StrSecureL2TPOnlyDesc;

TCHAR *StrLockdown;
TCHAR *StrLockdownDesc;

TCHAR *StrDhcpEnabled;
TCHAR *StrAdvancedTcpipSettings;

TCHAR *StrIpAddress;
TCHAR *StrSubnetMask;

//  used to store which edit box to bring up when the user clicks the add button
int g_CurrentEditBox;

//  used to pass data IP addresses between dialogs, +1 for the null character
TCHAR szIPString[MAX_IP_LENGTH+1];

//  used to pass data for the subnet mask between dialogs,
//  +1 for the null character
TCHAR szSubnetMask[IPSTRINGLENGTH+1];

//  used for the IP and subnet mask list view
IP_STRUCT *IPStruct;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\tcpipcom.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//     tcpipcom.c
//
// Description:  Functions common to all the Advanced TCP/IP pages
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "tcpip.h"

//----------------------------------------------------------------------------
//
// Function: TcpipNameListInsertIdx
//
// Purpose:  Whenever a TCP/IP item needs to inserted into a specific position
//   in a list this function needs to be called.  It checks for a duplicate.
//   If one exists, it removes it and then does the insertion.  Subnet masks
//   should not use this function because duplicates are allowed for them.
//
// Arguments:
//      IN OUT NAMELIST* TcpipNameList - namelist to add to
//      IN TCHAR*  pString   - string to add (input)
//      IN UINT    idx   - 0-based index on where to do the insertion
//
// Returns: if a duplicate was removed the index where the duplicate was,
//          -1 if there was no duplicate
//
//----------------------------------------------------------------------------
INT
TcpipNameListInsertIdx( IN OUT NAMELIST* TcpipNameList,
                        IN TCHAR*  pString,
                        IN UINT    idx )
{

    INT iFound = -1;

    iFound = FindNameInNameList( TcpipNameList, pString );

    //
    //  if it is already in the list, then remove it
    //
    if( iFound != NOT_FOUND )
    {

        RemoveNameFromNameListIdx( TcpipNameList, iFound );

    }

    AddNameToNameListIdx( TcpipNameList, pString, idx );

    return( iFound );

}

//----------------------------------------------------------------------------
//
// Function: TcpipAddNameToNameList
//
// Purpose:  Whenever a TCP/IP item needs to inserted at the end of a list
//   this function needs to be called.  It checks for a duplicate.  If one
//   exists, it removes it and then does the insertion.  Subnet masks should
//   not use this function because duplicates are allowed for them.
//
// Arguments:
//      IN OUT NAMELIST* TcpipNameList - namelist to add to
//      IN TCHAR*        pString       - string to add (input)
//
// Returns: if a duplicate was removed the index where the duplicate was,
//          -1 if there was no duplicate
//
//----------------------------------------------------------------------------
INT
TcpipAddNameToNameList( IN OUT NAMELIST* TcpipNameList,
                        IN TCHAR*    pString )
{

    return( TcpipNameListInsertIdx( TcpipNameList,
                                    pString,
                                    TcpipNameList->nEntries ) );

}



//----------------------------------------------------------------------------
//
// Function: OnAddButtonPressed
//
// Purpose:  Generic procedure called whenever a user clicks the Add button on
//           any of the property pages
//
//           this function displays the appropriate dialog box, gets the data
//           from the user and then inserts the data into the list box
//
// Arguments:
//      IN HWND hwnd - handle to the dialog
//      IN WORD ListBoxControlID - the list box to add the entry to
//      IN WORD EditButtonControlID   - the edit button associated with the
//                                      list box
//      IN WORD RemoveButtonControlID - the remove button associated with the
//                                      list box
//      IN LPCTSTR Dialog - the dialog control ID as a string
//      IN DLGPROC DialogProc - the dialog procedure for the add button behavior
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnAddButtonPressed( IN HWND hwnd,
                    IN WORD ListBoxControlID,
                    IN WORD EditButtonControlID,
                    IN WORD RemoveButtonControlID,
                    IN LPCTSTR Dialog,
                    IN DLGPROC DialogProc )
{

    //
    // make the string blank since we will be adding a new IP address
    //
    szIPString[0] = _T('\0');

    if( DialogBox( FixedGlobals.hInstance, Dialog, hwnd, DialogProc ) )
    {

        HWND hListBox      = GetDlgItem( hwnd, ListBoxControlID      );
        HWND hEditButton   = GetDlgItem( hwnd, EditButtonControlID   );
        HWND hRemoveButton = GetDlgItem( hwnd, RemoveButtonControlID );

        //
        // Add the string to the list box and make it the current selection
        //
        SendMessage( hListBox,
                     LB_ADDSTRING,
                     0,
                     (LPARAM) szIPString );

        SendMessage( hListBox,
                     LB_SELECTSTRING,
                     -1,
                     (LPARAM) szIPString );

        //
        //  an entry was just added so make sure the edit and remove buttons
        //  are enabled
        //
        EnableWindow( hEditButton, TRUE );
        EnableWindow( hRemoveButton, TRUE );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnEditButtonPressed
//
// Purpose:  Generic procedure called whenever a user clicks the Edit button
//           on any of the property pages
//
//           this function displays the appropriate dialog box, gets the data
//           from the user and then deletes the old string and reinserts the
//           new string into the list box
//
// Arguments:
//      IN HWND hwnd - handle to the dialog
//      IN WORD ListBoxControlID - the list box to in which to edit the entry
//      IN LPCTSTR Dialog - the dialog control ID as a string
//      IN DLGPROC DialogProc - the dialog procedure for the edit button
//                              behavior
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnEditButtonPressed( IN HWND hwnd,
                     IN WORD ListBoxControlID,
                     IN LPCTSTR Dialog,
                     IN DLGPROC DialogProc )
{

    INT_PTR  iIndex;
    HWND hListBox = GetDlgItem( hwnd, ListBoxControlID );

    iIndex = SendMessage( hListBox, LB_GETCURSEL, 0, 0 );

    SendMessage( hListBox, LB_GETTEXT, iIndex, (LPARAM)szIPString );

    if( DialogBox( FixedGlobals.hInstance, Dialog, hwnd, DialogProc ) )
    {
        //
        //  Remove the old one and insert the new one
        //
        SendMessage( hListBox, LB_DELETESTRING, iIndex, 0 );

        SendMessage( hListBox, LB_INSERTSTRING, iIndex, (LPARAM) szIPString );

        SendMessage( hListBox, LB_SETCURSEL, iIndex, 0 );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnRemoveButtonPressed
//
// Purpose:  Generic procedure called whenever a user clicks the Remove button
//           on any of the property pages
//
//           this function determines which entry is currently selected in the
//           list box and deletes that item
//
// Arguments:
//      IN HWND hwnd - handle to the dialog
//      IN WORD ListBoxControlID - the list box to remove the entry from
//      IN WORD EditButtonControlID   - the edit button associated with the
//                                      list box
//      IN WORD RemoveButtonControlID - the remove button associated with the
//                                      list box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnRemoveButtonPressed( IN HWND hwnd,
                       IN WORD ListBoxControlID,
                       IN WORD EditButtonControlID,
                       IN WORD RemoveButtonControlID )
{
    INT_PTR iIndex;
    INT_PTR iCount;

    HWND hListBox      = GetDlgItem( hwnd, ListBoxControlID      );
    HWND hEditButton   = GetDlgItem( hwnd, EditButtonControlID   );
    HWND hRemoveButton = GetDlgItem( hwnd, RemoveButtonControlID );

    //
    // Remove the item from the list box by finding the index of the currently
    // selected item and deleting
    //
    iIndex = SendMessage( hListBox, LB_GETCURSEL, 0, 0 );

    SendMessage( hListBox, LB_DELETESTRING, iIndex, 0 );

    //
    // if there are no more items in the list box then grey-out the edit and remove buttons
    //
    iCount = SendMessage( hListBox, LB_GETCOUNT, 0, 0 );

    if( iCount == 0 )
    {

        EnableWindow( hEditButton, FALSE );

        EnableWindow( hRemoveButton, FALSE );

    }
    else  // else select the first item
    {

        SendMessage( hListBox, LB_SETCURSEL, 0, 0 );

    }

}

//----------------------------------------------------------------------------
//
// Function: GenericIPDlgProc
//
// Purpose:  Generic Dialog Procedure called to handle a dialog box where a
//           user can enter an IP address and then press OK or Cancel
//             - the switch at the beginning determines which Dialog Box to
//               display so every dialog box that calls this function will need
//               a case inside this switch statement
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
GenericIPDlgProc( IN HWND     hwnd,
                  IN UINT     uMsg,
                  IN WPARAM   wParam,
                  IN LPARAM   lParam )
{

    HWND hEditbox;
    BOOL bStatus = TRUE;

    //
    //    Determine which dialog box to display
    //

    switch( g_CurrentEditBox )
    {

        case GATEWAY_EDITBOX:

            hEditbox = GetDlgItem( hwnd, IDC_IPADDR_ADV_CHANGE_GATEWAY );

            break;

        case DNS_SERVER_EDITBOX:

            hEditbox = GetDlgItem( hwnd, IDC_DNS_CHANGE_SERVER );

            break;

        case DNS_SUFFIX_EDITBOX:

            hEditbox = GetDlgItem( hwnd, IDC_DNS_CHANGE_SUFFIX );

            break;

        case WINS_EDITBOX:

            hEditbox = GetDlgItem( hwnd, IDC_WINS_CHANGE_SERVER );

            break;

    }

    switch( uMsg )
    {

        case WM_INITDIALOG:
        {

            SetWindowText( hEditbox, szIPString );

            SetFocus( hEditbox );

            bStatus = FALSE;  // return FALSE, we set the keyboard focus

            break;

        }

        case WM_COMMAND:
        {

            int nButtonId = LOWORD( wParam );

            switch ( nButtonId )
            {

                case IDOK:
                {

                    //
                    // return a 1 to show an IP was added
                    //

                    GetWindowText( hEditbox, szIPString, MAX_IP_LENGTH + 1 );

                    EndDialog( hwnd, 1 );

                    break;
                }

                case IDCANCEL:
                {

                    //
                    // return a 0 to show no IP was added
                    //

                    EndDialog( hwnd, 0 );

                    break;
                }

            }

        }

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}


//----------------------------------------------------------------------------
//
// Function: SetButtons
//
// Purpose:  Sets the windows states for the Edit and Remove buttons
//
// Arguments:  IN HWND hListBox - the list box the edit and remove buttons are
//                                associated with
//             IN HWND hEditButton - handle to the Edit button
//             IN HWND hRemoveButton - handle to the Remove button
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
SetButtons( IN HWND hListBox, IN HWND hEditButton, IN HWND hRemoveButton )
{
    INT_PTR iCount;

    iCount = SendMessage( hListBox, LB_GETCOUNT, 0, 0 );

    if( iCount > 0 )
    {

        EnableWindow( hEditButton, TRUE );

        EnableWindow( hRemoveButton, TRUE );

    }
    else
    {

        EnableWindow( hEditButton, FALSE );

        EnableWindow( hRemoveButton, FALSE );

    }

}

//----------------------------------------------------------------------------
//
// Function: AddValuesToListBox
//
// Purpose:  Uses the contents of a Namelist to populate a list box, then
//           selects the first entry.
//
// Arguments:  IN HWND hListBox  - list box the data is to be added to
//             IN NAMELIST* pNameList - namelist to extract the data from
//             IN INT iPosition - position in the list to start taking names
//                                from
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
AddValuesToListBox( IN HWND hListBox, IN NAMELIST* pNameList, IN INT iPosition )
{

    INT i;
    INT nEntries;
    LPTSTR pszIPAddressString;

    nEntries = GetNameListSize( pNameList );

    for( i = iPosition; i < nEntries; i++ ) {

        pszIPAddressString = GetNameListName( pNameList, i );

        SendMessage( hListBox, LB_INSERTSTRING, i, (LPARAM) pszIPAddressString );

    }

    //
    // select the first entry
    //

    SendMessage( hListBox, LB_SETCURSEL, 0, 0 );

}

//----------------------------------------------------------------------------
//
// Function: TCPIPProp_PropertySheetProc
//
// Purpose:  Standard Property Sheet dialog proc.
//
//----------------------------------------------------------------------------
int CALLBACK
TCPIPProp_PropertySheetProc( HWND hwndDlg,
                             UINT uMsg,
                             LPARAM lParam )
{

     switch (uMsg) {
          case PSCB_INITIALIZED :
               // Process PSCB_INITIALIZED
               break ;

          case PSCB_PRECREATE :
               // Process PSCB_PRECREATE
               break ;

          default :
               // Unknown message
               break ;
    }

    return( 0 );

}

//----------------------------------------------------------------------------
//
// Function: Create_TCPIPProp_PropertySheet
//
// Purpose:  Sets up settings for the entire property sheet and each
//           individual page.  Lastly, calls the PropertySheet function to
//           display the property sheet, the return value of this function is
//           what is passed back as the return value
//
// Arguments:  HWND hwndParent - handle to the dialog that will be spawning
//                               the property sheet
//
// Returns:  BOOL - the return value from the property sheet
//
//----------------------------------------------------------------------------
BOOL
Create_TCPIPProp_PropertySheet( HWND hwndParent )
{

    INT i;

    // Initialize property sheet HEADER data
    ZeroMemory( &TCPIPProp_pshead, sizeof( PROPSHEETHEADER ) );

    TCPIPProp_pshead.dwSize  = sizeof( PROPSHEETHEADER );
    TCPIPProp_pshead.dwFlags = PSH_PROPSHEETPAGE |
                               PSH_USECALLBACK   |
                               PSH_USEHICON      |
                               PSH_NOAPPLYNOW;
    TCPIPProp_pshead.hwndParent  = hwndParent;
    TCPIPProp_pshead.hInstance   = FixedGlobals.hInstance;
    TCPIPProp_pshead.pszCaption  = g_StrAdvancedTcpipSettings;
    TCPIPProp_pshead.nPages      = cTCPIPPropertyPages;
    TCPIPProp_pshead.nStartPage  = 0;
    TCPIPProp_pshead.ppsp        = TCPIPProp_pspage;
    TCPIPProp_pshead.pfnCallback = TCPIPProp_PropertySheetProc;

    // Zero out property PAGE data
    ZeroMemory( &TCPIPProp_pspage, cTCPIPPropertyPages * sizeof(PROPSHEETPAGE) );

    for( i = 0; i < cTCPIPPropertyPages; i++ ) {

        TCPIPProp_pspage[i].dwSize      = sizeof(PROPSHEETPAGE);
        TCPIPProp_pspage[i].dwFlags     = PSP_USECALLBACK;
        TCPIPProp_pspage[i].hInstance   = FixedGlobals.hInstance;

    }

    // PAGE 1 -- IP settings page
    TCPIPProp_pspage[0].pszTemplate = MAKEINTRESOURCE (IDD_IPADDR_ADV);
    TCPIPProp_pspage[0].pfnDlgProc  = TCPIP_IPSettingsDlgProc;
    TCPIPProp_pspage[0].pfnCallback = TCPIP_IPSettingsPageProc;

    // PAGE 2 -- DNS page
    TCPIPProp_pspage[1].pszTemplate = MAKEINTRESOURCE (IDD_TCP_DNS);
    TCPIPProp_pspage[1].pfnDlgProc  = TCPIP_DNSDlgProc;
    TCPIPProp_pspage[1].pfnCallback = TCPIP_DNSPageProc;

    // PAGE 3 -- WINS page
    TCPIPProp_pspage[2].pszTemplate = MAKEINTRESOURCE (IDD_TCP_WINS);
    TCPIPProp_pspage[2].pfnDlgProc  = TCPIP_WINSDlgProc;
    TCPIPProp_pspage[2].pfnCallback = TCPIP_WINSPageProc;

    /*

    // ISSUE-2002/02/28-stelo- There are currently no unattend settings for IPSEC or TCP/IP
    //          filter so do not display this page of the property sheet.


    // PAGE 4 -- Options page
    TCPIPProp_pspage[3].pszTemplate = MAKEINTRESOURCE (IDD_TCP_OPTIONS);
    TCPIPProp_pspage[3].pfnDlgProc  = TCPIP_OptionsDlgProc;
    TCPIPProp_pspage[3].pfnCallback = TCPIP_OptionsPageProc;
    */

    // --------- Create & display property sheet ---------
    if( PropertySheet( &TCPIPProp_pshead ) )
        return( TRUE );        // pass back return value from PropertySheet
    else
        return( FALSE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\hal.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      hal.c
//
// Description:
//      This file contains the dialog procedure for the hal files.
//      (IDD_HAL).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define HAL_FILE_EXTENSION   _T("oem")

static TCHAR* StrHalFiles;
static TCHAR* StrAllFiles;
static TCHAR  g_szHalFileFilter[MAX_PATH + 1];

//
//  This var keeps track of the path to the txtsetup.oem
//
static TCHAR szTxtSetupOemLocation[MAX_PATH];

static BOOL bHasLoadedTxtSetupOem = FALSE;

VOID LoadOriginalSettingsLowHalScsi(HWND     hwnd,
                                    LPTSTR   lpFileName,
                                    QUEUENUM dwWhichQueue);

static VOID
LoadHalFromTxtsetupOem( IN HWND  hwnd,
                        IN TCHAR *szTxtSetupOemPath );


//----------------------------------------------------------------------------
//
// Function: OnHalInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnHalInitDialog( IN HWND hwnd )
{
    HRESULT hrPrintf;

    //
    //  Load the resource strings
    //

    StrHalFiles = MyLoadString( IDS_HAL_FILES );

    StrAllFiles  = MyLoadString( IDS_ALL_FILES  );

    //
    //  Build the text file filter string
    //

    //
    //  The question marks (?) are just placehoders for where the NULL char
    //  will be inserted.
    //

    hrPrintf=StringCchPrintf( g_szHalFileFilter, AS(g_szHalFileFilter),
               _T("%s (*.oem)?*.oem?%s (*.*)?*.*?"),
               StrHalFiles,
               StrAllFiles );

    ConvertQuestionsToNull( g_szHalFileFilter );

}

//----------------------------------------------------------------------------
//
// Function: OnHalSetActive
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnHalSetActive( IN HWND hwnd )
{

    INT_PTR   i;
    INT_PTR   iListBoxCount;
    TCHAR szListBoxEntryText[MAX_STRING_LEN];

    //
    //  If we are editing a script and haven't loaded the txtsetup.oem, then
    //  populate the list box with the entries in the txtsetup.oem
    //
    if( ! WizGlobals.bNewScript && ! bHasLoadedTxtSetupOem ) {

        //
        //  The OEM files path must be valid if we are going to use it to
        //  read files.
        //
        AssertMsg( WizGlobals.OemFilesPath[0] != _T('\0'),
                   "OEM files path is blank");

        //
        //  Populate the list box with the HAL entries in txtsetup.oem
        //

        ConcatenatePaths( szTxtSetupOemLocation,
                          WizGlobals.OemFilesPath,
                          _T("Textmode"),
                          NULL );

        LoadHalFromTxtsetupOem( hwnd, szTxtSetupOemLocation );

        //
        //  Select the HAL
        //

        iListBoxCount = SendDlgItemMessage( hwnd,
                                            IDC_LB_HAL,
                                            LB_GETCOUNT,
                                            0,
                                            0 );

        //
        //  Search the list box for the HAL to select
        //
        for( i = 0; i < iListBoxCount; i++ ) {

            SendDlgItemMessage( hwnd,
                                IDC_LB_HAL,
                                LB_GETTEXT,
                                i,
                                (LPARAM) szListBoxEntryText );

            if( lstrcmpi( szListBoxEntryText,
                          GenSettings.szHalFriendlyName ) == 0 ) {

                SendDlgItemMessage( hwnd,
                                    IDC_LB_HAL,
                                    LB_SETCURSEL,
                                    i,
                                    0 );

                break;


            }

        }

    }

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);

}

//----------------------------------------------------------------------------
//
// Function: ClearHalListBox
//
// Purpose:  Deallocates memory for all the elements in the HAL list box and
//    clears it.
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
ClearHalListBox( IN HWND hwnd ) {

    INT_PTR i;
    INT_PTR iListBoxCount;
    TCHAR *pData;

    iListBoxCount = SendDlgItemMessage( hwnd,
                                        IDC_LB_HAL,
                                        LB_GETCOUNT,
                                        0,
                                        0 );

    for( i = 0; i < iListBoxCount; i++ ) {

        pData = (TCHAR *) SendDlgItemMessage( hwnd,
                                              IDC_LB_HAL,
                                              LB_GETITEMDATA,
                                              i,
                                              0 );

        if( pData ) {

            free( pData );

        }

    }

    SendDlgItemMessage( hwnd,
                        IDC_LB_HAL,
                        LB_RESETCONTENT,
                        0,
                        0 );

}

//----------------------------------------------------------------------------
//
// Function: OnBrowseLoadHal
//
// Purpose:  Creates a browse window for the user to select a txtsetup.oem
//     file and populate the list box.
//
//     NOTE: the malloc call in here is arguably a bug (memory leak).  I
//     malloc the memory but never free it.  Every malloc they do will be
//     <= MAX_PATH and realistically they won't do that many.  Once they do
//     a load, if they do another load, I free the old memory (see
//     ClearHalListBox) and allocate new memory.  So, for the last load
//     they do, the memory never gets freed. To do it right,
//     we would free the memory at the end of the program but NT does this for
//     us anyways when the process gets killed.  (so no need to free)
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnBrowseLoadHal( IN HWND hwnd ) {

    TCHAR  PathBuffer[MAX_PATH];
    INT    iRet;
    LPTSTR pFileName;
    BOOL   bFileNotFound    = TRUE;
    TCHAR  szTxtSetupOemLocationAndFilename[MAX_PATH] = _T("");

    GetCurrentDirectory( MAX_PATH, PathBuffer );

    ConcatenatePaths( szTxtSetupOemLocationAndFilename,
                      szTxtSetupOemLocation,
                      OEM_TXTSETUP_NAME,
                      NULL );

    //
    //  Keep asking for a file until we either get a txtsetup.oem or the user
    //  presses cancel.
    //
    while( bFileNotFound ) {

        iRet = ShowBrowseFolder( hwnd,
                                 g_szHalFileFilter,
                                 HAL_FILE_EXTENSION,
                                 OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                                 PathBuffer,
                                 szTxtSetupOemLocationAndFilename );

        if ( ! iRet )
            return;  // user pressed cancel on the dialog

        pFileName = MyGetFullPath( szTxtSetupOemLocationAndFilename );

        if( pFileName && (LSTRCMPI( pFileName, OEM_TXTSETUP_NAME ) == 0) ) {

            bFileNotFound = FALSE;  // we have found the file

        }
        else {

            // ISSUE-2002/02/28-stelo-
            /*
            ReportErrorId(hwnd,
                          MSGTYPE_ERR | MSGTYPE_WIN32,
                          ,
                          GenSettings.lpszLogoBitmap, szLogoDestination);
                          */

        }

    }

    ClearHalListBox( hwnd );

    //
    //  Trim the file name off szTxtSetupOemLocation so it only provides
    //  the path to the txtsetup.oem
    //
    {

        TCHAR *p = szTxtSetupOemLocationAndFilename;

        while( p != pFileName )
        {
            p++;
        }

        *p = _T('\0');

    }

    lstrcpyn( szTxtSetupOemLocation, szTxtSetupOemLocationAndFilename, AS(szTxtSetupOemLocation) );

    //
    //  Read in from the file OEM file they specified in the browse box and
    //  add the friendly-name entries to the list box
    //
    LoadHalFromTxtsetupOem( hwnd, szTxtSetupOemLocation );

}


//----------------------------------------------------------------------------
//
// Function: LoadHalFromTxtsetupOem
//
// Purpose:  Reads the txtsetup.oem in the specified parameter and load the
//           HAL choices into the list box.
//
// Arguments: hwnd - handle to the dialog box
//            szTxtSetupOemPath - path to the txtsetup.oem
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
LoadHalFromTxtsetupOem( IN HWND  hwnd,
                        IN TCHAR *szTxtSetupOemPath ) {

    INT_PTR   iIndex;
    BOOL  bKeepReading;
    HINF  hHalOem            = NULL;
    INFCONTEXT HalOemContext = { 0 };
    TCHAR szTxtSetupOemPathAndFilename[MAX_PATH]  = _T("");
    TCHAR szHalFriendlyName[MAX_HAL_NAME_LENGTH]  = _T("");

    ConcatenatePaths( szTxtSetupOemPathAndFilename,
                      szTxtSetupOemPath,
                      OEM_TXTSETUP_NAME,
                      NULL );

    hHalOem = SetupOpenInfFile( szTxtSetupOemPathAndFilename,
                                NULL,
                                INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                NULL );

    if( hHalOem == INVALID_HANDLE_VALUE ) {

        // ISSUE-2002/02/28-stelo- alert an error that we couldn't open the file
        return;

    }

    //
    //  Store the path to txtsetup.oem
    //
    GetCurrentDirectory( MAX_PATH, szTxtSetupOemPath );

    HalOemContext.Inf = hHalOem;
    HalOemContext.CurrentInf = hHalOem;

    bKeepReading = SetupFindFirstLine( hHalOem,
                                       _T("Computer"),
                                       NULL,
                                       &HalOemContext );
    //
    //  For each HAL entry, add its friendly-name to the list box
    //

    while( bKeepReading ) {

        TCHAR szHalName[MAX_HAL_NAME_LENGTH];
        TCHAR *pHalName;

        SetupGetStringField( &HalOemContext,
                             0,
                             szHalName,
                             MAX_HAL_NAME_LENGTH,
                             NULL );

        SetupGetStringField( &HalOemContext,
                             1,
                             szHalFriendlyName,
                             MAX_HAL_NAME_LENGTH,
                             NULL );

        //
        //  Don't allow the adding of a blank name (protection against a bad input file)
        //
        if( szHalFriendlyName[0] != _T('\0') ) {

            iIndex = SendDlgItemMessage( hwnd,
                                         IDC_LB_HAL,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM) szHalFriendlyName );

            pHalName = (TCHAR*) malloc( sizeof(szHalName) );
            if (pHalName == NULL)
                TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);

            lstrcpyn( pHalName, szHalName, MAX_HAL_NAME_LENGTH );

            SendDlgItemMessage( hwnd,
                                IDC_LB_HAL,
                                LB_SETITEMDATA,
                                iIndex,
                                (LPARAM) pHalName );

        }

        //
        // move to the next line of the .oem file
        //
        bKeepReading = SetupFindNextLine( &HalOemContext, &HalOemContext );

    }

    SetupCloseInfFile( hHalOem );

    bHasLoadedTxtSetupOem = TRUE;

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextHal
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnWizNextHal( IN HWND hwnd ) {

    INT_PTR  iItemSelected;
    INT  iFound;
    HINF hHalOem;
    INFCONTEXT HalOemContext;

    TCHAR *pHalName;
    TCHAR  szHalName[MAX_HAL_NAME_LENGTH];
    TCHAR  szHalSectionName[MAX_INILINE_LEN];
    TCHAR  szTextmodePath[MAX_PATH]        = _T("");
    TCHAR  szOemFilePathAndName[MAX_PATH]  = _T("");

    iItemSelected = SendDlgItemMessage( hwnd,
                                        IDC_LB_HAL,
                                        LB_GETCURSEL,
                                        0,
                                        0 );

    //
    //  If there is no HAL selected just move to the next page
    //
    if( iItemSelected == LB_ERR ) {
        return;
    }

    //
    //  If the user has not loaded a txtsetup.oem by clicking the browse
    //  button (it was filled in because this is an edit) then don't copy
    //  any files
    //
    if( bHasLoadedTxtSetupOem == FALSE ) {
        return;
    }

    //
    //  Prepare to add the new drivers
    //
    GenSettings.szHalFriendlyName[0] = _T('\0');

    ResetNameList( &GenSettings.OemHalFiles );

    ConcatenatePaths( szTextmodePath,
                      WizGlobals.OemFilesPath,
                      _T("Textmode"),
                      NULL );

    if ( ! EnsureDirExists( szTextmodePath ) )
    {
        ReportErrorId( hwnd,
                       MSGTYPE_ERR | MSGTYPE_WIN32,
                       IDS_ERR_CREATE_FOLDER,
                       szTextmodePath );

        return;
    }

    ConcatenatePaths( szOemFilePathAndName,
                      szTxtSetupOemLocation,
                      OEM_TXTSETUP_NAME,
                      NULL );

    //
    //  Read the txtsetup.oem file into the txtsetup queue
    //

    LoadOriginalSettingsLowHalScsi(hwnd,
                                   szOemFilePathAndName,
                                   SETTING_QUEUE_TXTSETUP_OEM);

    hHalOem = SetupOpenInfFile( szOemFilePathAndName,
                                NULL,
                                INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                NULL );

    if( hHalOem == INVALID_HANDLE_VALUE ) {

        // ISSUE-2002/02/28-stelo- need to somehow alert an error
        return;

    }

    SendDlgItemMessage( hwnd,
                        IDC_LB_HAL,
                        LB_GETTEXT,
                        iItemSelected,
                        (LPARAM) GenSettings.szHalFriendlyName );

    HalOemContext.Inf = hHalOem;
    HalOemContext.CurrentInf = hHalOem;

    pHalName = (TCHAR *) SendDlgItemMessage( hwnd,
                                             IDC_LB_HAL,
                                             LB_GETITEMDATA,
                                             iItemSelected,
                                             0 );

    //
    //  Build up the section name
    //
    lstrcpyn( szHalSectionName, _T("Files.computer."), AS(szHalSectionName) );

    lstrcatn( szHalSectionName, pHalName, MAX_INILINE_LEN );

    iFound = SetupFindFirstLine( hHalOem,
                                 szHalSectionName,
                                 NULL,
                                 &HalOemContext );

    if( iFound ) {

        SetupGetStringField( &HalOemContext,
                             2,
                             szHalName,
                             MAX_HAL_NAME_LENGTH,
                             NULL );

        //
        //  Don't allow the adding of a blank name (protection against a bad
        //  input file)
        //
        if( szHalName[0] != _T('\0') ) {

            AddNameToNameList( &GenSettings.OemHalFiles, szHalName );

            CopyFileToDistShare( hwnd,
                                 szTxtSetupOemLocation,
                                 szHalName,
                                 szTextmodePath );

        }

    }

    SetupCloseInfFile( hHalOem );

}

//----------------------------------------------------------------------------
//
// Function: DlgHalPage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgHalPage( IN HWND     hwnd,
            IN UINT     uMsg,
            IN WPARAM   wParam,
            IN LPARAM   lParam ) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG:
        {
            OnHalInitDialog( hwnd );
            break;
        }

        case WM_COMMAND: {

            switch ( LOWORD(wParam) ) {

                case IDC_BUT_LOAD_HAL:

                    if ( HIWORD(wParam) == BN_CLICKED )
                        OnBrowseLoadHal( hwnd );

                    break;

                default:

                    bStatus = FALSE;
                    break;

            }

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    CancelTheWizard(hwnd); break;

                case PSN_SETACTIVE: {

                    OnHalSetActive( hwnd );

                    break;

                }
                case PSN_WIZBACK:

                    break;

                case PSN_WIZNEXT:

                    OnWizNextHal( hwnd );

                    break;

                default:

                    break;
            }


            break;
        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\tcpipip.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      tcpipip.c
//
// Description:
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "tcpip.h"

//----------------------------------------------------------------------------
//
// Function: ChangeIPDlgProc
//
// Purpose:  Dialog procedure for allowing the user to add or edit an IP and Subnet Mask
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
ChangeIPDlgProc( IN HWND     hwnd,
                 IN UINT     uMsg,
                 IN WPARAM   wParam,
                 IN LPARAM   lParam) {

    BOOL bStatus = TRUE;
    HWND hIPEditBox = GetDlgItem( hwnd, IDC_IPADDR_ADV_CHANGEIP_IP );
    HWND hSubnetEditBox = GetDlgItem( hwnd, IDC_IPADDR_ADV_CHANGEIP_SUB );

    switch( uMsg ) {

        case WM_INITDIALOG: {

            SetWindowText( hIPEditBox, szIPString );

            SetWindowText( hSubnetEditBox, szSubnetMask );

            SetFocus( hIPEditBox );

            bStatus = FALSE;  // return FALSE, we set the keyboard focus

            break;

        }

        case WM_COMMAND: {

            int nButtonId = LOWORD( wParam );

            switch ( nButtonId ) {

                case IDOK: {

                    // return a 1 to show an IP was added
                    GetWindowText( hIPEditBox, szIPString, IPSTRINGLENGTH+1 );

                    GetWindowText( hSubnetEditBox, szSubnetMask, IPSTRINGLENGTH+1 );

                    EndDialog( hwnd, 1 );

                    break;

                }

                case IDCANCEL: {

                    // return a 0 to show no IP was added
                    EndDialog( hwnd, 0 );

                    break;
                }

            }

        }

        default:
            bStatus = FALSE;
            break;

    }

    return bStatus;

}

//----------------------------------------------------------------------------
//
// Function: SetGatewayInitialValues
//
// Purpose:  To set the initial contents of the Gateway list box
//
// Arguments:  IN HWND hwnd - handle to the dialog
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
SetGatewayInitialValues( IN HWND hwnd ) {

    INT i;
    INT nEntries;
    TCHAR *pString;

    nEntries = GetNameListSize( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses );

    //
    //  Iterate over the Gateway namelist adding each one to the Gateway List box
    //
    for( i = 0; i < nEntries; i++ ) {

        pString = GetNameListName( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses, i );

        SendDlgItemMessage( hwnd,
                            IDC_IPADDR_GATE,
                            LB_ADDSTRING,
                            0,
                            (LPARAM) pString );

    }

    //
    // select the first entry
    //
    SendDlgItemMessage( hwnd,
                        IDC_IPADDR_GATE,
                        LB_SETCURSEL,
                        0,
                        0 );

}

//----------------------------------------------------------------------------
//
// Function: InsertItemIntoTcpipListView
//
// Purpose:  hListView is the handle to the list view the IPStruct is to be
//           added to
//           position designates the position in the list view the item is to
//           be inserted in
//
// Arguments:
//
// Returns:  TRUE if the insert succeeded,
//           FALSE if it failed
//
//----------------------------------------------------------------------------
// ISSUE-2002/02/28-stelo- move this to tcpipcom.c because optional uses it too.  Should also be
//    renamed??
BOOL
InsertItemIntoTcpipListView( HWND hListView,
                             LPARAM lParam,
                             UINT position ) {

    LVITEM lvI;

    lvI.mask = LVIF_TEXT | LVIF_PARAM;

    lvI.iItem = position;
    lvI.iSubItem = 0;
    lvI.pszText = LPSTR_TEXTCALLBACK;
    lvI.cchTextMax = MAX_ITEMLEN;
    lvI.lParam = lParam;

    //
    // if ListView_InsertItem returns a non-negative value then it succeeded
    //
    if( ListView_InsertItem( hListView, &lvI ) >= 0 )
        return( TRUE ) ;

    // insertion failed
    return( FALSE ) ;

}

//----------------------------------------------------------------------------
//
// Function: SetIPandSubnetMaskInitialValues
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
VOID
SetIPandSubnetMaskInitialValues( IN HWND hwnd ) {

    INT i;
    INT nEntries;
    LPTSTR pszIPAddress;
    LPTSTR pszSubnetMask;
    HWND hTcpipListView;

    hTcpipListView = GetDlgItem( hwnd, IDC_IPADDR_ADVIP );

    if( NetSettings.pCurrentAdapter->bObtainIPAddressAutomatically == TRUE ) {

        //
        //  allocate space for the IP struct
        //
        IPStruct = malloc( sizeof(IP_STRUCT) );
        if (IPStruct == NULL)
        {
            TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);
        }
        lstrcpyn( IPStruct->szIPString, StrDhcpEnabled, AS(IPStruct->szIPString) );

        //  force the subnet mask field to be blank
        lstrcpyn( IPStruct->szSubnetMask, _T(""), AS(IPStruct->szSubnetMask) );

        //
        //  use an IP_STRUCT to pass the data, the name is somewhat misleading
        //  because we are not passing in an IP address in this case
        //
        InsertItemIntoTcpipListView( hTcpipListView,
                                     (LPARAM) IPStruct, 0 );

        //
        //  Grey-out the Add, Edit and Remove buttons since none of these are
        //  available to the user when DHCP is enabled
        //
        EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_ADDIP ), FALSE );
        EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_EDITIP ), FALSE );
        EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_REMOVEIP ), FALSE );

    }
    else {

        nEntries = GetNameListSize( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses );

        if( nEntries == 0 ) {

            //
            //  Grey-out the Edit and Remove buttons since these are not
            //  available when there are no items in the ListView
            //
            EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_EDITIP ), FALSE );
            EnableWindow( GetDlgItem( hwnd, IDC_IPADDR_REMOVEIP ), FALSE );

        }

        for( i = 0; i < nEntries; i = i++ ) {

            // allocate space for the IP struct
            IPStruct = malloc( sizeof(IP_STRUCT) );
            if ( IPStruct == NULL ) {
	        TerminateTheWizard( IDS_ERROR_OUTOFMEMORY );
            }

            pszIPAddress = GetNameListName(
                &NetSettings.pCurrentAdapter->Tcpip_IpAddresses, i );

            lstrcpyn( IPStruct->szIPString, pszIPAddress, AS(IPStruct->szIPString) );

            pszSubnetMask = GetNameListName(
                &NetSettings.pCurrentAdapter->Tcpip_SubnetMaskAddresses, i );

            lstrcpyn( IPStruct->szSubnetMask, pszSubnetMask, AS(IPStruct->szSubnetMask) );

            InsertItemIntoTcpipListView( hTcpipListView, (LPARAM) IPStruct, i );

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: OnTcpipIpInitDialog
//
// Purpose:  loads button bitmaps from resources and initializes the list view
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnTcpipIpInitDialog( IN HWND hwnd ) {

    LV_COLUMN lvCol;        // list view column structure
    INT iIndex;
    INT iNewItem;
    INT nEntries;
    INT colWidth;
    RECT rect;
    HWND hGatewayEditButton;
    HWND hGatewayRemoveButton;
    HWND hTcpipListView;

    //
    //  Load strings from resources
    //

    StrDhcpEnabled = MyLoadString( IDS_DHCP_ENABLED );

    StrIpAddress = MyLoadString( IDS_IP_ADDRESS );
    StrSubnetMask = MyLoadString( IDS_SUBNET_MASK );

    hTcpipListView = GetDlgItem( hwnd, IDC_IPADDR_ADVIP );

    //
    //    This will always be the first page of the property sheet
    //  displayed so load the up and down icons and store the handles
    //  in global variables
    //
    if ( ! g_hIconUpArrow && ! g_hIconDownArrow ) {

        g_hIconUpArrow = (HICON)LoadImage(FixedGlobals.hInstance,
                                      MAKEINTRESOURCE(IDI_UP_ARROW),
                                      IMAGE_ICON, 16, 16, 0);

        g_hIconDownArrow = (HICON)LoadImage(FixedGlobals.hInstance,
                                      MAKEINTRESOURCE(IDI_DOWN_ARROW),
                                      IMAGE_ICON, 16, 16, 0);

    }

    // Place up/down arrow icons on buttons
    SendDlgItemMessage( hwnd,
                        IDC_IPADDR_UP,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM)g_hIconUpArrow );

    SendDlgItemMessage( hwnd,
                        IDC_IPADDR_DOWN,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM)g_hIconDownArrow );

    // Calculate column width
    GetClientRect( hTcpipListView, &rect );

    colWidth = ( rect.right / cIPSettingsColumns );

    for( iIndex = 0; iIndex < cIPSettingsColumns; iIndex++ ) {

        ListView_SetColumnWidth( hTcpipListView, iIndex, colWidth );

    }

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = colWidth;       // width of column in pixels

    //  Add the two columns and header text
    for( iIndex = 0; iIndex < cIPSettingsColumns; iIndex++ ) {

        //  column header text
        if ( iIndex == 0 ) // first column
            lvCol.pszText = (LPTSTR) StrIpAddress;
        else
            lvCol.pszText = (LPTSTR) StrSubnetMask;

        iNewItem = ListView_InsertColumn( hTcpipListView, iIndex, &lvCol );

    }

    //  fill the IP and Subnet mask list box with the appropriate
    //  initial value(s)
    SetIPandSubnetMaskInitialValues( hwnd );

    //  fill the gateway list box with the appropriate initial value(s)
    SetGatewayInitialValues( hwnd );

    hGatewayEditButton = GetDlgItem( hwnd, IDC_IPADDR_EDITGATE );
    hGatewayRemoveButton = GetDlgItem( hwnd, IDC_IPADDR_REMOVEGATE );

    SetButtons( GetDlgItem( hwnd, IDC_IPADDR_GATE ),
                hGatewayEditButton,
                hGatewayRemoveButton );

    SetArrows( hwnd,
               IDC_IPADDR_GATE,
               IDC_IPADDR_UP,
               IDC_IPADDR_DOWN );

}

//----------------------------------------------------------------------------
//
// Function: OnTcpipIpApply
//
// Purpose:  stores the contents on the TCP/IP advanced IP address page into
//           the global variables
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnTcpipIpApply( IN HWND hwnd ) {

    INT_PTR i;
    INT_PTR iCount;
    LV_ITEM lvI;
    TCHAR szIP[IPSTRINGLENGTH + 1];

    //
    //  delete any old settings in the Namelists
    //
    ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses );

    ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_SubnetMaskAddresses );

    iCount = ListView_GetItemCount( GetDlgItem( hwnd, IDC_IPADDR_ADVIP ) );

    for( i = 0; i < iCount; i++ ) {

        memset( &lvI, 0, sizeof(LV_ITEM) );

        lvI.iItem = (int)i;
        lvI.mask = LVIF_PARAM;

        ListView_GetItem( GetDlgItem( hwnd, IDC_IPADDR_ADVIP ), &lvI );

        IPStruct = (IP_STRUCT*) lvI.lParam;

        //  store the IP string into the Namelist
          TcpipAddNameToNameList( &NetSettings.pCurrentAdapter->Tcpip_IpAddresses,
                                IPStruct->szIPString);

        //  store the Subnet Mask string into the Namelist
          TcpipAddNameToNameList( &NetSettings.pCurrentAdapter->Tcpip_SubnetMaskAddresses,
                                IPStruct->szSubnetMask );

    }

    ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses );

    //
    //  pull the IP address out of the Gateway list box and put them in the
    //  Gateway Namelist
    //
    iCount = SendDlgItemMessage( hwnd,
                                 IDC_IPADDR_GATE,
                                 LB_GETCOUNT,
                                 0,
                                 0 );

    for( i = 0; i < iCount; i++ ) {

        //
        // get the IP string from the list box
        //
        SendDlgItemMessage( hwnd,
                            IDC_IPADDR_GATE,
                            LB_GETTEXT,
                            i,
                            (LPARAM) szIP );

        //
        // store the IP string in to the Namelist
        //
        TcpipAddNameToNameList( &NetSettings.pCurrentAdapter->Tcpip_GatewayAddresses, szIP );

    }

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_IPSettingsPageProc
//
// Purpose:  Required function for the property sheet page to function properly.
//             The important thing is to give the return value of 1 to the
//           message PSPCB_CREATE and 0 for PSPCB_RELEASE
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
UINT CALLBACK
TCPIP_IPSettingsPageProc( HWND  hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp ) {

    switch ( uMsg ) {

        case PSPCB_CREATE :
            return 1 ;  // needed for property sheet page to initialize correctly

        case PSPCB_RELEASE :
            return 0;

        default:
            return -1;

    }

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_IPSettingsDlgProc
//
// Purpose:  Dialog procedure for the IP Settings page of the property sheet
//             handles all the messages sent to this window
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
TCPIP_IPSettingsDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam ) {

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnTcpipIpInitDialog( hwndDlg );

            return TRUE ;

        }

        case WM_DESTROY: {

            // deallocate space for all items still in the List View
            INT i;
            INT iCount;
            LV_ITEM lvI;

            //
            //  iterate through the ListView getting each item and
            //  deallocating the space for it
            //
            iCount = ListView_GetItemCount( GetDlgItem( hwndDlg, IDC_IPADDR_ADVIP ) );
            for( i = 0; i < iCount; i++ ) {

                memset( &lvI, 0, sizeof(LV_ITEM) );

                lvI.iItem = i;
                lvI.mask = LVIF_PARAM;

                ListView_GetItem( GetDlgItem( hwndDlg, IDC_IPADDR_ADVIP ),
                                  &lvI );

                free( (IP_STRUCT*) lvI.lParam );

            }

            return TRUE ;

        }

        case WM_COMMAND: {

            WORD wNotifyCode = HIWORD( wParam ) ;
            WORD wButtonId = LOWORD( wParam ) ;

            if( wNotifyCode == LBN_SELCHANGE ) {

                SetArrows( hwndDlg,
                           IDC_IPADDR_GATE,
                           IDC_IPADDR_UP,
                           IDC_IPADDR_DOWN );

            }

            switch ( wButtonId ) {

                //
                //  IP Address Buttons
                //
                case IDC_IPADDR_ADDIP: {

                    //  make the string blank since we will be adding a
                    //  new IP address
                    szIPString[0] = _T('\0');
                    //  and a new subnet mask
                    szSubnetMask[0] = _T('\0');

                    if( DialogBox( FixedGlobals.hInstance,
                                   (LPCTSTR) IDD_IPADDR_ADV_CHANGEIP,
                                   hwndDlg,
                                   ChangeIPDlgProc ) ) {

                        HWND hEditButton = GetDlgItem( hwndDlg,
                                                       IDC_IPADDR_EDITIP );

                        HWND hRemoveButton = GetDlgItem( hwndDlg,
                                                         IDC_IPADDR_REMOVEIP );

                        //  allocate space for the IP struct
                        IPStruct = malloc( sizeof(IP_STRUCT) );
                        if (IPStruct == NULL)
                        {
                            TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);
                        }


                        //  copy the strings that the user entered from the Dialog
                        //  Box into the IP struct so it can be added to
                        //  the list view
                        lstrcpyn( IPStruct->szIPString, szIPString, AS(IPStruct->szIPString) );
                        lstrcpyn( IPStruct->szSubnetMask, szSubnetMask, AS(IPStruct->szSubnetMask) );

                        InsertItemIntoTcpipListView( GetDlgItem( hwndDlg, IDC_IPADDR_ADVIP ),
                                                     (LPARAM) IPStruct,
                                                     0 );

                        // an entry was just added so make sure the edit and remove buttons are enabled
                        EnableWindow( hEditButton, TRUE );
                        EnableWindow( hRemoveButton, TRUE );

                    }

                    return TRUE ;

                }

                case IDC_IPADDR_EDITIP: {

                    LV_ITEM lvI;
                    BOOL bIsItemSelected = FALSE;

                    bIsItemSelected = GetSelectedItemFromListView( hwndDlg,
                                                               IDC_IPADDR_ADVIP,
                                                               &lvI );

                    if( bIsItemSelected ) {
                        IPStruct = (IP_STRUCT*) lvI.lParam;

                        lstrcpyn( szIPString, IPStruct->szIPString, AS(szIPString) );

                        lstrcpyn( szSubnetMask, IPStruct->szSubnetMask, AS(szSubnetMask) );

                        if( DialogBox( FixedGlobals.hInstance,
                                       (LPCTSTR) IDD_IPADDR_ADV_CHANGEIP,
                                       hwndDlg,
                                       ChangeIPDlgProc ) ) {

                            lstrcpyn( IPStruct->szIPString, szIPString, AS(IPStruct->szIPString) );
                            lstrcpyn( IPStruct->szSubnetMask, szSubnetMask, AS(IPStruct->szSubnetMask) );

                            // delete the old item and insert the new one
                            ListView_DeleteItem( GetDlgItem( hwndDlg, IDC_IPADDR_ADVIP ),
                                                 lvI.iItem );

                            InsertItemIntoTcpipListView( GetDlgItem( hwndDlg, IDC_IPADDR_ADVIP ),
                                                         (LPARAM) IPStruct, lvI.iItem );

                        }

                    }

                    return TRUE ;

                }

                case IDC_IPADDR_REMOVEIP: {

                    LV_ITEM lvI;
                    BOOL bIsItemSelected = FALSE;

                    bIsItemSelected = GetSelectedItemFromListView( hwndDlg,
                                                                   IDC_IPADDR_ADVIP,
                                                                   &lvI );

                    //
                    //    if there is an item selected, then free its memory and
                    //  delete the item from the ListView
                    //
                    if( bIsItemSelected ) {

                        free( (IP_STRUCT*) lvI.lParam );

                        ListView_DeleteItem( GetDlgItem( hwndDlg, IDC_IPADDR_ADVIP ),
                                             lvI.iItem );

                    }

                    return TRUE ;

                }

                //
                //  Gateway Buttons
                //
                case IDC_IPADDR_ADDGATE:

                    g_CurrentEditBox = GATEWAY_EDITBOX;

                    OnAddButtonPressed( hwndDlg,
                                        IDC_IPADDR_GATE,
                                        IDC_IPADDR_EDITGATE,
                                        IDC_IPADDR_REMOVEGATE,
                                        (LPCTSTR) IDD_IPADDR_ADV_CHANGEGATE,
                                        GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_IPADDR_GATE,
                               IDC_IPADDR_UP,
                               IDC_IPADDR_DOWN );

                    return TRUE ;

                case IDC_IPADDR_EDITGATE:

                    g_CurrentEditBox = GATEWAY_EDITBOX;

                    OnEditButtonPressed( hwndDlg,
                                         IDC_IPADDR_GATE,
                                        (LPCTSTR) IDD_IPADDR_ADV_CHANGEGATE,
                                       GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_IPADDR_GATE,
                               IDC_IPADDR_UP,
                               IDC_IPADDR_DOWN );

                    return TRUE ;

                case IDC_IPADDR_REMOVEGATE:

                    OnRemoveButtonPressed( hwndDlg,
                                           IDC_IPADDR_GATE,
                                           IDC_IPADDR_EDITGATE,
                                           IDC_IPADDR_REMOVEGATE );

                    SetArrows( hwndDlg,
                               IDC_IPADDR_GATE,
                               IDC_IPADDR_UP,
                               IDC_IPADDR_DOWN );

                    return TRUE ;

                case IDC_IPADDR_UP:

                    OnUpButtonPressed( hwndDlg, IDC_IPADDR_GATE );

                    SetArrows( hwndDlg,
                               IDC_IPADDR_GATE,
                               IDC_IPADDR_UP,
                               IDC_IPADDR_DOWN );

                    return TRUE ;

                case IDC_IPADDR_DOWN:

                    OnDownButtonPressed( hwndDlg, IDC_IPADDR_GATE );

                    SetArrows( hwndDlg,
                               IDC_IPADDR_GATE,
                               IDC_IPADDR_UP,
                               IDC_IPADDR_DOWN );

                    return TRUE ;

            }  // end switch

            return FALSE ;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR) lParam;
            LV_DISPINFO *pLvdi = (LV_DISPINFO *) lParam;
            IP_STRUCT *pListViewEntry = (IP_STRUCT *) (pLvdi->item.lParam);

            if( wParam == IDC_IPADDR_ADVIP ) {

                if( pLvdi->hdr.code == LVN_GETDISPINFO ) {

                    switch( pLvdi->item.iSubItem ) {

                        case 0:
                            pLvdi->item.pszText = pListViewEntry->szIPString;
                            break;
                        case 1:
                            pLvdi->item.pszText = pListViewEntry->szSubnetMask;
                            break;

                    }

                }

            }

            switch( pnmh->code ) {

                case PSN_APPLY: {

                    //
                    //  user clicked the OK button on the property sheet
                    //
                    OnTcpipIpApply( hwndDlg );

                    return TRUE ;

                }

            }

            default :
                return FALSE ;

        }

    }

}

//
//  ISSUE-2002/02/28-stelo- this function is for debugging purposes only, remove for final product
//   it is meant to be called from the debugger to show what the contents of a
//   namelist is
//
VOID DumpNameList( NAMELIST *pNameList ) {

#if DBG

    INT i;
    INT nEntries;
    TCHAR *szNameListEntry;

    nEntries = GetNameListSize( pNameList );

    for(i = 0; i < nEntries; i++ ) {

        szNameListEntry = GetNameListName( pNameList, i );

        OutputDebugString( szNameListEntry );

    }

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\tcpipdns.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      tcpipdns.c
//
// Description:  ISSUE-2002/02/28-stelo- fill description
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "tcpip.h"

//----------------------------------------------------------------------------
//
// Function: OnTcpipDnsInitDialog
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
VOID
OnTcpipDnsInitDialog( IN HWND hwnd )
{

    HWND hServerEditButton, hServerRemoveButton;
    HWND hSuffixAddButton, hSuffixEditButton, hSuffixRemoveButton;

    //
    // Place up/down arrow icons on buttons
    //

    SendDlgItemMessage( hwnd,
                        IDC_DNS_SERVER_UP,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM) g_hIconUpArrow );

    SendDlgItemMessage( hwnd,
                        IDC_DNS_SERVER_DOWN,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM) g_hIconDownArrow );

    SendDlgItemMessage( hwnd,
                        IDC_DNS_SUFFIX_UP,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM) g_hIconUpArrow );

    SendDlgItemMessage( hwnd,
                        IDC_DNS_SUFFIX_DOWN,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM) g_hIconDownArrow );

    hServerEditButton   = GetDlgItem( hwnd, IDC_DNS_SERVER_EDIT );
    hServerRemoveButton = GetDlgItem( hwnd, IDC_DNS_SERVER_REMOVE );

    hSuffixAddButton    = GetDlgItem( hwnd, IDC_DNS_SUFFIX_ADD );
    hSuffixEditButton   = GetDlgItem( hwnd, IDC_DNS_SUFFIX_EDIT );
    hSuffixRemoveButton = GetDlgItem( hwnd, IDC_DNS_SUFFIX_REMOVE );

    SetWindowText( GetDlgItem( hwnd, IDC_DNS_DOMAIN ),
                   NetSettings.pCurrentAdapter->szDNSDomainName );

    //
    //  fill the DNS Server list box with the appropriate initial value(s)
    //

    AddValuesToListBox( GetDlgItem( hwnd, IDC_DNS_SERVER_LIST ),
                        &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses,
                        0 );

    //
    // select the first entry in the DNS Server list box
    //

    SendDlgItemMessage( hwnd,
                        IDC_DNS_SERVER_LIST,
                        LB_SETCURSEL,
                        0,
                        0 );

    //
    //  initialize the Edit and Remove buttons to the proper states
    //

    SetButtons( GetDlgItem( hwnd, IDC_DNS_SERVER_LIST ),
                hServerEditButton,
                hServerRemoveButton );

    //
    //  Have to "figure out" what DNS radio button to set
    //

    if( NetSettings.bIncludeParentDomains )
    {

        CheckRadioButton( hwnd,
                          IDC_DNS_SEARCH_DOMAIN,
                          IDC_DNS_USE_SUFFIX_LIST,
                          IDC_DNS_SEARCH_DOMAIN );

        EnableWindow( hSuffixAddButton, FALSE );

        CheckDlgButton( hwnd, IDC_DNS_SEARCH_PARENT_DOMAIN, BST_CHECKED );

    }
    else if( GetNameListSize( &NetSettings.TCPIP_DNS_Domains ) > 0 )
    {

        CheckRadioButton( hwnd,
                          IDC_DNS_SEARCH_DOMAIN,
                          IDC_DNS_USE_SUFFIX_LIST,
                          IDC_DNS_USE_SUFFIX_LIST );

        EnableWindow( hSuffixAddButton, TRUE );

        EnableWindow( GetDlgItem( hwnd, IDC_DNS_SEARCH_PARENT_DOMAIN),
                      FALSE );

        //
        //  fill the DNS Suffix list box with the appropriate initial value(s)
        //

        AddValuesToListBox( GetDlgItem( hwnd, IDC_DNS_SUFFIX_LIST ),
                            &NetSettings.TCPIP_DNS_Domains,
                            0 );

    }
    else {

        CheckRadioButton( hwnd,
                          IDC_DNS_SEARCH_DOMAIN,
                          IDC_DNS_USE_SUFFIX_LIST,
                          IDC_DNS_SEARCH_DOMAIN );

        EnableWindow( hSuffixAddButton, FALSE );

    }

    //
    //  initialize the Edit and Remove buttons to the proper states
    //

    SetButtons( GetDlgItem( hwnd, IDC_DNS_SUFFIX_LIST ),
                hSuffixEditButton,
                hSuffixRemoveButton );

    SetArrows( hwnd,
               IDC_DNS_SERVER_LIST,
               IDC_DNS_SERVER_UP,
               IDC_DNS_SERVER_DOWN );

    SetArrows( hwnd,
               IDC_DNS_SUFFIX_LIST,
               IDC_DNS_SUFFIX_UP,
               IDC_DNS_SUFFIX_DOWN );

}

//----------------------------------------------------------------------------
//
// Function: OnTcpipDnsApply
//
// Purpose:  stores the contents on the TCP/IP advanced DNS page into
//           the global variables
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnTcpipDnsApply( IN HWND hwnd )
{

    INT_PTR i;
    INT_PTR iCount;
    TCHAR szDns[IPSTRINGLENGTH + 1];

    //
    // delete any old settings in the Namelists
    //

    ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses );

    //
    //  pull the IP address out of the DNS list box and put them in the
    //  DNS Namelist
    //

    iCount = SendDlgItemMessage( hwnd,
                                 IDC_DNS_SERVER_LIST,
                                 LB_GETCOUNT,
                                 0,
                                 0 );

    for( i = 0; i < iCount; i++ )
    {

        //
        // get the DNS string from the list box
        //

        SendDlgItemMessage( hwnd,
                            IDC_DNS_SERVER_LIST,
                            LB_GETTEXT,
                            i,
                            (LPARAM) szDns );

        //
        // store the DNS string in to the Namelist
        //

        TcpipAddNameToNameList( &NetSettings.pCurrentAdapter->Tcpip_DnsAddresses, szDns );

    }

    ResetNameList( &NetSettings.TCPIP_DNS_Domains );

    iCount = SendDlgItemMessage( hwnd,
                                 IDC_DNS_SUFFIX_LIST,
                                 LB_GETCOUNT,
                                 0,
                                 0 );

    for( i = 0; i < iCount; i++ )
    {

        // ISSUE-2002/02/28-stelo- DNS suffix is going to get truncated
        // because szIPString is a short string so fix this

        //
        // get the IP string from the list box
        //

        SendDlgItemMessage( hwnd,
                            IDC_DNS_SUFFIX_LIST,
                            LB_GETTEXT,
                            i,
                            (LPARAM)szIPString );

        //
        // store the IP string in to the Namelist
        //

        AddNameToNameList( &NetSettings.TCPIP_DNS_Domains,
                           szIPString );

    }

    GetWindowText( GetDlgItem( hwnd, IDC_DNS_DOMAIN ),
                   NetSettings.pCurrentAdapter->szDNSDomainName,
                   MAX_STRING_LEN );

    if( IsDlgButtonChecked( hwnd, IDC_DNS_SEARCH_PARENT_DOMAIN ) )
    {

        NetSettings.bIncludeParentDomains = TRUE;

    }
    else
    {

        NetSettings.bIncludeParentDomains = FALSE;

    }


}

//----------------------------------------------------------------------------
//
// Function: TCPIP_DNSPageProc
//
// Purpose:  Required function for the property sheet page to function properly.
//             The important thing is to give the return value of 1 to the
//           message PSPCB_CREATE and 0 for PSPCB_RELEASE
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
UINT CALLBACK
TCPIP_DNSPageProc( HWND  hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp ) {

    switch( uMsg ) {

        case PSPCB_CREATE:
            return( 1 );    // needed for property sheet page to initialize correctly

        case PSPCB_RELEASE:
            return( 0 );

        default:
            return( -1 );

    }

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_DNSDlgProc
//
// Purpose:  Dialog procedure for the DNS page of the property sheet
//             handles all the messages sent to this window
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
TCPIP_DNSDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{

    switch( uMsg )
    {

        case WM_INITDIALOG:
        {

            OnTcpipDnsInitDialog( hwndDlg );

            return( TRUE );

        }

        case WM_COMMAND:
        {

            WORD wNotifyCode = HIWORD( wParam );
            WORD wButtonId = LOWORD( wParam );

            if( wNotifyCode == LBN_SELCHANGE )
            {

                if( wButtonId == IDC_DNS_SERVER_LIST )
                {

                    SetArrows( hwndDlg,
                               IDC_DNS_SERVER_LIST,
                               IDC_DNS_SERVER_UP,
                               IDC_DNS_SERVER_DOWN );

                }
                else
                {

                    SetArrows( hwndDlg,
                               IDC_DNS_SUFFIX_LIST,
                               IDC_DNS_SUFFIX_UP,
                               IDC_DNS_SUFFIX_DOWN );

                }

            }

            switch ( wButtonId )
            {

                case IDC_DNS_SEARCH_DOMAIN:

                    if( wNotifyCode == BN_CLICKED )
                    {

                        CheckRadioButton( hwndDlg,
                                          IDC_DNS_SEARCH_DOMAIN,
                                          IDC_DNS_USE_SUFFIX_LIST,
                                          IDC_DNS_SEARCH_DOMAIN );

                        EnableWindow( GetDlgItem( hwndDlg, IDC_DNS_SEARCH_PARENT_DOMAIN ),
                                      TRUE );

                        EnableWindow( GetDlgItem( hwndDlg, IDC_DNS_SUFFIX_ADD ),
                                      FALSE );

                        SetArrows( hwndDlg,
                                   IDC_DNS_SUFFIX_LIST,
                                   IDC_DNS_SUFFIX_UP,
                                   IDC_DNS_SUFFIX_DOWN );

                    }

                    return( TRUE );

                case IDC_DNS_USE_SUFFIX_LIST:

                    if( wNotifyCode == BN_CLICKED )
                    {

                        CheckRadioButton( hwndDlg,
                                          IDC_DNS_SEARCH_DOMAIN,
                                          IDC_DNS_USE_SUFFIX_LIST,
                                          IDC_DNS_USE_SUFFIX_LIST );

                        EnableWindow( GetDlgItem( hwndDlg, IDC_DNS_SEARCH_PARENT_DOMAIN ),
                                      FALSE );

                        EnableWindow( GetDlgItem( hwndDlg, IDC_DNS_SUFFIX_ADD),
                                      TRUE );

                    }

                    return( TRUE );

                //
                //  DNS Server Buttons
                //

                case IDC_DNS_SERVER_ADD:

                    g_CurrentEditBox = DNS_SERVER_EDITBOX;

                    OnAddButtonPressed( hwndDlg,
                                        IDC_DNS_SERVER_LIST,
                                        IDC_DNS_SERVER_EDIT,
                                        IDC_DNS_SERVER_REMOVE,
                                        (LPCTSTR) IDD_DNS_SERVER,
                                        GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_DNS_SERVER_LIST,
                               IDC_DNS_SERVER_UP,
                               IDC_DNS_SERVER_DOWN );

                    return( TRUE );

                case IDC_DNS_SERVER_EDIT:

                    g_CurrentEditBox = DNS_SERVER_EDITBOX;

                    OnEditButtonPressed( hwndDlg,
                                         IDC_DNS_SERVER_LIST,
                                         (LPCTSTR) IDD_DNS_SERVER,
                                         GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_DNS_SERVER_LIST,
                               IDC_DNS_SERVER_UP,
                               IDC_DNS_SERVER_DOWN );

                    return( TRUE );

                case IDC_DNS_SERVER_REMOVE:

                    OnRemoveButtonPressed( hwndDlg,
                                           IDC_DNS_SERVER_LIST,
                                           IDC_DNS_SERVER_EDIT,
                                           IDC_DNS_SERVER_REMOVE );

                    SetArrows( hwndDlg,
                               IDC_DNS_SERVER_LIST,
                               IDC_DNS_SERVER_UP,
                               IDC_DNS_SERVER_DOWN );

                    return( TRUE );

                case IDC_DNS_SERVER_UP:

                    OnUpButtonPressed( hwndDlg, IDC_DNS_SERVER_LIST );

                    SetArrows( hwndDlg,
                               IDC_DNS_SERVER_LIST,
                               IDC_DNS_SERVER_UP,
                               IDC_DNS_SERVER_DOWN );

                    return( TRUE );

                case IDC_DNS_SERVER_DOWN:

                    OnDownButtonPressed( hwndDlg, IDC_DNS_SERVER_LIST );

                    SetArrows( hwndDlg,
                               IDC_DNS_SERVER_LIST,
                               IDC_DNS_SERVER_UP,
                               IDC_DNS_SERVER_DOWN );

                    return( TRUE );

                //
                //  DNS Suffix Buttons
                //
                case IDC_DNS_SUFFIX_ADD:

                    g_CurrentEditBox = DNS_SUFFIX_EDITBOX;

                    OnAddButtonPressed( hwndDlg,
                                        IDC_DNS_SUFFIX_LIST,
                                        IDC_DNS_SUFFIX_EDIT,
                                        IDC_DNS_SUFFIX_REMOVE,
                                        (LPCTSTR) IDD_DNS_SUFFIX,
                                        GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_DNS_SUFFIX_LIST,
                               IDC_DNS_SUFFIX_UP,
                               IDC_DNS_SUFFIX_DOWN );

                    return( TRUE );

                case IDC_DNS_SUFFIX_EDIT:

                    g_CurrentEditBox = DNS_SUFFIX_EDITBOX;

                    OnEditButtonPressed( hwndDlg,
                                         IDC_DNS_SUFFIX_LIST,
                                         (LPCTSTR) IDD_DNS_SUFFIX,
                                         GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_DNS_SUFFIX_LIST,
                               IDC_DNS_SUFFIX_UP,
                               IDC_DNS_SUFFIX_DOWN );

                    return( TRUE );

                case IDC_DNS_SUFFIX_REMOVE:

                    OnRemoveButtonPressed( hwndDlg,
                                           IDC_DNS_SUFFIX_LIST,
                                           IDC_DNS_SUFFIX_EDIT,
                                           IDC_DNS_SUFFIX_REMOVE );

                    SetArrows( hwndDlg,
                               IDC_DNS_SUFFIX_LIST,
                               IDC_DNS_SUFFIX_UP,
                               IDC_DNS_SUFFIX_DOWN );

                    return( TRUE );

                case IDC_DNS_SUFFIX_UP:

                    OnUpButtonPressed( hwndDlg, IDC_DNS_SUFFIX_LIST );

                    SetArrows( hwndDlg,
                               IDC_DNS_SUFFIX_LIST,
                               IDC_DNS_SUFFIX_UP,
                               IDC_DNS_SUFFIX_DOWN );

                    return( TRUE );

                case IDC_DNS_SUFFIX_DOWN:

                    OnDownButtonPressed( hwndDlg, IDC_DNS_SUFFIX_LIST );

                    SetArrows( hwndDlg,
                               IDC_DNS_SUFFIX_LIST,
                               IDC_DNS_SUFFIX_UP,
                               IDC_DNS_SUFFIX_DOWN );

                    return( TRUE );

            }  // end switch

            return( FALSE );

        }

        case WM_NOTIFY:
        {

            LPNMHDR pnmh = (LPNMHDR) lParam ;

            switch( pnmh->code )
            {

                case PSN_APPLY:
                {

                    //
                    // user clicked the OK button on the property sheet
                    //
                    OnTcpipDnsApply( hwndDlg );

                    return( TRUE );

                }


            default:
               return( FALSE );

            }

        }

        default:
            return( FALSE );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\tcpipopt.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:  tcpipopt.c
//
// Description:
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "tcpip.h"

typedef struct {
    TCHAR *szName;
    TCHAR *szDescription;
    BOOL bInstalled;
} TCPIP_Options_Entry_Struct;

#define NUMBER_OF_TCPIP_OPTIONS 2

// ISSUE-2002/02/28-stelo- make these an enum
#define IP_SECURITY   0
#define TCPIP_FILTERING   1

static TCPIP_Options_Entry_Struct TCPIP_Options_Entries[NUMBER_OF_TCPIP_OPTIONS];

//----------------------------------------------------------------------------
//
// Function: EnableIpSecurityControls
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
VOID
EnableIpSecurityControls( IN HWND hwnd, IN BOOL bState ) {

    //
    //  Grab handles to each of the controls
    //
    HWND hPolicyComboBox = GetDlgItem( hwnd, IDC_CMB_IPSEC_POLICY_LIST );
    HWND hPolicyDescBox  = GetDlgItem( hwnd, IDC_EDT_POLICY_DESC );

    //
    //  Grey or ungrey them appropriately
    //
    EnableWindow( hPolicyComboBox, bState );
    EnableWindow( hPolicyDescBox, bState );

}


//----------------------------------------------------------------------------
//
// Function: IpSecurityDlgProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
IpSecurityDlgProc( IN HWND     hwnd,
                   IN UINT     uMsg,
                   IN WPARAM   wParam,
                   IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            HWND hDescriptionBox = GetDlgItem( hwnd, IDC_EDT_POLICY_DESC );

            //
            //  Load strings from resources
            //
            StrSecureInitiator = MyLoadString( IDS_SECURE_INITIATOR );
            StrSecureInitiatorDesc = MyLoadString( IDS_SECURE_INITIATOR_DESC );

            StrSecureResponder = MyLoadString( IDS_SECURE_RESPONDER );
            StrSecureResponderDesc = MyLoadString( IDS_SECURE_RESPONDER_DESC );

            StrLockdown = MyLoadString( IDS_LOCKDOWN );
            StrLockdownDesc = MyLoadString( IDS_LOCKDOWN_DESC );

            CheckRadioButton( hwnd,
                              IDC_RAD_IPSEC_NOIPSEC,
                              IDC_RAD_IPSEC_CUSTOM,
                              IDC_RAD_IPSEC_NOIPSEC );

            EnableIpSecurityControls( hwnd, FALSE );

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPSEC_POLICY_LIST,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrSecureInitiator );

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPSEC_POLICY_LIST,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrSecureResponder );

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPSEC_POLICY_LIST,
                                CB_ADDSTRING,
                                (WPARAM) 0,
                                (LPARAM) StrLockdown );

            //
            //  Set the combo box selection and description
            //

            // ISSUE-2002/02/28-stelo- this eventually needs to be fixed once I know
            //    what the security answerfile settings will be

            SendDlgItemMessage( hwnd,
                                IDC_CMB_IPSEC_POLICY_LIST,
                                CB_SETCURSEL,
                                (WPARAM) 0,
                                (LPARAM) 0 );

            SetWindowText( hDescriptionBox, StrSecureInitiatorDesc );

            break;

        }

        case WM_COMMAND: {

            int nButtonId = LOWORD( wParam );

            switch ( nButtonId ) {

                case IDC_CMB_IPSEC_POLICY_LIST: {

                    if( HIWORD( wParam ) == CBN_SELCHANGE ) {

                        INT_PTR iIndex;
                        HWND hDescriptionBox = GetDlgItem( hwnd,
                                                           IDC_EDT_POLICY_DESC );

                        // get the current selection from the combo box
                        iIndex = SendDlgItemMessage( hwnd,
                                                     IDC_CMB_IPSEC_POLICY_LIST,
                                                     CB_GETCURSEL,
                                                     (WPARAM) 0,
                                                     (LPARAM) 0 );

                        switch( iIndex ) {

                            case 0:  SetWindowText( hDescriptionBox,
                                                    StrSecureInitiatorDesc );
                                break;
                            case 1:  SetWindowText( hDescriptionBox,
                                                    StrSecureResponderDesc );
                                break;
                            case 2:  SetWindowText( hDescriptionBox,
                                                    StrLockdownDesc );
                                break;

                            default:
                                AssertMsg(FALSE,
                                          "Bad case in TCPIP switch statement.");


                        }

                    }

                    break;

                }

                case IDC_RAD_IPSEC_NOIPSEC:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        EnableIpSecurityControls( hwnd, FALSE );

                    }

                    break;

                case IDC_RAD_IPSEC_CUSTOM:

                    if ( HIWORD(wParam) == BN_CLICKED ) {

                        EnableIpSecurityControls( hwnd, TRUE );

                    }

                    break;

                case IDOK: {



                    EndDialog( hwnd, 1 );

                    break;

                }

                case IDCANCEL: {

                    EndDialog( hwnd, 0 );

                    break;
                }

            }

        }

        default:
            bStatus = FALSE;
            break;

    }

    return bStatus;

}

//----------------------------------------------------------------------------
//
// Function: TcpipFilteringDlgProc
//
// Purpose:
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
TcpipFilteringDlgProc( IN HWND     hwnd,
                       IN UINT     uMsg,
                       IN WPARAM   wParam,
                       IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {


            break;

        }

        case WM_COMMAND: {

            int nButtonId = LOWORD( wParam );

            switch ( nButtonId ) {

                case IDOK: {



                    EndDialog( hwnd, 1 );

                    break;

                }

                case IDCANCEL: {

                    EndDialog( hwnd, 0 );

                    break;
                }

            }

        }

        default:
            bStatus = FALSE;
            break;

    }

    return bStatus;

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_OptionsPageProc
//
// Purpose:  Required function for the property sheet page to function properly.
//             The important thing is to give the return value of 1 to the message PSPCB_CREATE and
//             0 for PSPCB_RELEASE
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
UINT CALLBACK
TCPIP_OptionsPageProc( HWND  hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp ) {

    switch( uMsg ) {

        case PSPCB_CREATE :
            return 1 ;    // needed for property sheet page to initialize correctly

        case PSPCB_RELEASE :
            return 0;

        default:
            return -1;

    }

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_OptionsDlgProc
//
// Purpose:  Dialog procedure for the Options page of the property sheet
//             handles all the messages sent to this window
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
TCPIP_OptionsDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam ) {

    switch( uMsg ) {

        case WM_INITDIALOG: {

            int i;

            HWND hOptionsListView = GetDlgItem( hwndDlg,
                             IDC_LVW_OPTIONS );

            TCPIP_Options_Entries[IP_SECURITY].szName = MyLoadString( IDS_IP_SEC );
            TCPIP_Options_Entries[IP_SECURITY].szDescription = MyLoadString( IDS_IP_SEC_DESC );
            TCPIP_Options_Entries[IP_SECURITY].bInstalled = TRUE;

            TCPIP_Options_Entries[TCPIP_FILTERING].szName = MyLoadString( IDS_TCPIP_FILTERING );
            TCPIP_Options_Entries[TCPIP_FILTERING].szDescription = MyLoadString( IDS_TCPIP_FILTERING_DESC );
            TCPIP_Options_Entries[TCPIP_FILTERING].bInstalled = TRUE;



            // ISSUE-2002/02/28-stelo- Are there anymore settings that can be added to
            //                this list view
            //                Under what conditions are these visible? Only
            //                when DHCP is enabled?

            //
            //  Insert DHCP class ID and IP Security into the list view
            //
            for( i = 0; i < 2; i++ ) {

                InsertItemIntoTcpipListView( hOptionsListView,
                                             (LPARAM) &TCPIP_Options_Entries[i],
                                             1 );

            }

            SetListViewSelection( hwndDlg, IDC_LVW_OPTIONS, 1 );

            //
            //  Set the description
            //
            SetWindowText( GetDlgItem( hwndDlg, IDC_OPT_DESC ),
                           TCPIP_Options_Entries[0].szDescription );

            return TRUE ;

        }

        case WM_COMMAND: {

            WORD wNotifyCode = HIWORD( wParam );
            WORD wButtonId = LOWORD( wParam );

            switch( wButtonId ) {

                case IDC_OPT_PROPERTIES: {

                    INT iItemSelected;
                    HWND hOptionsListView = GetDlgItem( hwndDlg, IDC_LVW_OPTIONS );

                    iItemSelected = ListView_GetSelectionMark( hOptionsListView );

                    if( iItemSelected == TCPIP_FILTERING ) {

                        if( DialogBox( FixedGlobals.hInstance,
                                       (LPCTSTR) IDD_TCPIP_FILTER,
                                       hwndDlg,
                                       TcpipFilteringDlgProc ) ) {
                        }

                    }
                    else if( iItemSelected == IP_SECURITY ) {

                        if( DialogBox( FixedGlobals.hInstance,
                                       (LPCTSTR) IDD_IPSEC,
                                       hwndDlg,
                                       IpSecurityDlgProc ) ) {



                        }

                    }

                    break;

                }

            }  // end switch

            break;

        }

        case WM_NOTIFY: {

            LV_DISPINFO *pLvdi = (LV_DISPINFO *) lParam;
            NM_LISTVIEW *pNm = (NM_LISTVIEW *)lParam;
            TCPIP_Options_Entry_Struct *pListViewEntry = (TCPIP_Options_Entry_Struct *) (pLvdi->item.lParam);

            if( wParam == IDC_LVW_OPTIONS ) {

                switch( pLvdi->hdr.code ) {

                    case LVN_GETDISPINFO:

                        pLvdi->item.pszText = pListViewEntry->szName;

                        break;
                }

                switch( pNm->hdr.code ) {

                    case LVN_ITEMCHANGED:

                        // test to see if a new item in the list has been selected
                        if( pNm->uNewState == SELECTED ) {

                            LV_ITEM lvI;
                            TCPIP_Options_Entry_Struct *currentEntry;

                            if( !GetSelectedItemFromListView( hwndDlg,
                                                              IDC_LVW_OPTIONS,
                                                              &lvI ) ) {
                                return TRUE ;

                            }

                            currentEntry = (TCPIP_Options_Entry_Struct *) lvI.lParam;

                            //
                            //  Set the description
                            //
                            SetWindowText( GetDlgItem( hwndDlg, IDC_OPT_DESC ),
                                           currentEntry->szDescription );

                        }

                        break;
                }

            }

        }

        default:

            return FALSE ;

    }

    //
    //  Message was handled so return TRUE
    //
    return TRUE ;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\net\tcpipwin.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      tcpipwin.c
//
// Description:
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"
#include "tcpip.h"

//----------------------------------------------------------------------------
//
// Function: OnTcpipWinsInitDialog
//
// Purpose:  loads button bitmaps from resources and initializes the list view
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnTcpipWinsInitDialog( IN HWND hwnd ) {

    HWND hWINSEditButton      = GetDlgItem( hwnd, IDC_WINS_EDIT );
    HWND hWINSRemoveButton    = GetDlgItem( hwnd, IDC_WINS_REMOVE );
    HWND hEnableLMHostsButton = GetDlgItem( hwnd, IDC_WINS_LOOKUP );

    // fill the WINS list box with the appropriate initial value(s)
    AddValuesToListBox( GetDlgItem( hwnd, IDC_WINS_SERVER_LIST ),
                        &NetSettings.pCurrentAdapter->Tcpip_WinsAddresses,
                        0 );

    SetButtons( GetDlgItem( hwnd, IDC_WINS_SERVER_LIST ),
                hWINSEditButton,
                hWINSRemoveButton );

    SetArrows( hwnd,
               IDC_WINS_SERVER_LIST,
               IDC_WINS_UP,
               IDC_WINS_DOWN );

    // set the starting state for the LMHosts check box
    if( NetSettings.bEnableLMHosts ) {

        SendMessage( hEnableLMHostsButton, BM_SETCHECK, 1, 0 );

    }
    else {

        SendMessage( hEnableLMHostsButton, BM_SETCHECK, 0, 0 );

    }

    // set the starting state for the NetBIOS radio button
    switch( NetSettings.pCurrentAdapter->iNetBiosOption ) {

        case 0:
            CheckRadioButton( hwnd,
                              IDC_RAD_ENABLE_NETBT,
                              IDC_RAD_UNSET_NETBT,
                              IDC_RAD_UNSET_NETBT );
            break;

        case 1:
            CheckRadioButton( hwnd,
                              IDC_RAD_ENABLE_NETBT,
                              IDC_RAD_UNSET_NETBT,
                              IDC_RAD_ENABLE_NETBT );
            break;

        case 2:
            CheckRadioButton( hwnd,
                              IDC_RAD_ENABLE_NETBT,
                              IDC_RAD_UNSET_NETBT,
                              IDC_RAD_DISABLE_NETBT );
            break;

    }

    // Place up/down arrow icons on buttons
    SendDlgItemMessage( hwnd,
                        IDC_WINS_UP,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM)g_hIconUpArrow );

    SendDlgItemMessage( hwnd,
                        IDC_WINS_DOWN,
                        BM_SETIMAGE,
                        (WPARAM)IMAGE_ICON,
                        (LPARAM)g_hIconDownArrow );

}

//----------------------------------------------------------------------------
//
// Function: OnTcpipWinsApply
//
// Purpose:  stores the contents on the TCP/IP advanced WINS page into
//           the global variables
//
// Arguments: IN HWND hwnd - handle to the dialog
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnTcpipWinsApply( IN HWND hwnd ) {

    // user clicked the OK button on the property sheet
    INT_PTR iCount;
    INT_PTR i;

    HWND hEnableLMHostsCheckBox = GetDlgItem( hwnd,
                                              IDC_WINS_LOOKUP );

    // delete any old settings in the Namelist
    ResetNameList( &NetSettings.pCurrentAdapter->Tcpip_WinsAddresses );

    iCount = SendDlgItemMessage( hwnd,
                                 IDC_WINS_SERVER_LIST,
                                 LB_GETCOUNT,
                                 0,
                                 0 );

    for( i = 0; i < iCount; i++ ) {

        // get the IP string from the list box
        SendDlgItemMessage( hwnd,
                            IDC_WINS_SERVER_LIST,
                            LB_GETTEXT,
                            i,
                            (LPARAM)szIPString );

        // store the IP string in to the Namelist
        TcpipNameListInsertIdx( &NetSettings.pCurrentAdapter->Tcpip_WinsAddresses,
                                szIPString,
                                (int)i );

    }

    NetSettings.bEnableLMHosts =
                   (int)SendMessage( hEnableLMHostsCheckBox,
                                BM_GETCHECK,
                                0,
                                0 );

    if( IsDlgButtonChecked( hwnd,
                  IDC_RAD_ENABLE_NETBT ) == BST_CHECKED ) {

        NetSettings.pCurrentAdapter->iNetBiosOption = 1;

    }
    else if( IsDlgButtonChecked( hwnd,
                  IDC_RAD_DISABLE_NETBT ) == BST_CHECKED ) {

        NetSettings.pCurrentAdapter->iNetBiosOption = 2;

    }
    else {

        NetSettings.pCurrentAdapter->iNetBiosOption = 0;

    }


}

//----------------------------------------------------------------------------
//
// Function: TCPIP_WINSPageProc
//
// Purpose:  Required function for the property sheet page to function properly.
//             The important thing is to give the return value of 1 to the message PSPCB_CREATE and
//             0 for PSPCB_RELEASE
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
UINT CALLBACK
TCPIP_WINSPageProc( HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp ) {

    switch( uMsg ) {

        case PSPCB_CREATE :
            return 1 ;    // needed for property sheet page to initialize correctly

        case PSPCB_RELEASE :
            return 0;

        default:
            return -1;

    }

}

//----------------------------------------------------------------------------
//
// Function: TCPIP_WINSDlgProc
//
// Purpose:  Dialog procedure for the WINS page of the property sheet
//             handles all the messages sent to this window
//
// Arguments:
//
// Returns:
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
TCPIP_WINSDlgProc( HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam ) {

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnTcpipWinsInitDialog( hwndDlg );

            return TRUE ;

        }

        case WM_COMMAND: {

            WORD wNotifyCode = HIWORD( wParam );
            WORD wButtonId = LOWORD( wParam );

            if( wNotifyCode == LBN_SELCHANGE ) {

                SetArrows( hwndDlg,
                           IDC_WINS_SERVER_LIST,
                           IDC_WINS_UP,
                           IDC_WINS_DOWN );

            }

            switch ( wButtonId ) {

                case IDC_RAD_ENABLE_NETBT:

                    if( wNotifyCode == BN_CLICKED ) {

                        CheckRadioButton( hwndDlg,
                                          IDC_RAD_ENABLE_NETBT,
                                          IDC_RAD_UNSET_NETBT,
                                          IDC_RAD_ENABLE_NETBT );

                    }

                    return TRUE ;

                case IDC_RAD_DISABLE_NETBT:

                    if( wNotifyCode == BN_CLICKED ) {

                        CheckRadioButton( hwndDlg,
                                          IDC_RAD_ENABLE_NETBT,
                                          IDC_RAD_UNSET_NETBT,
                                          IDC_RAD_DISABLE_NETBT );

                    }

                    return TRUE ;

                case IDC_RAD_UNSET_NETBT:

                    if( wNotifyCode == BN_CLICKED ) {

                        CheckRadioButton( hwndDlg,
                                          IDC_RAD_ENABLE_NETBT,
                                          IDC_RAD_UNSET_NETBT,
                                          IDC_RAD_UNSET_NETBT );

                    }

                    return TRUE ;

                case IDC_WINS_ADD:

                    g_CurrentEditBox = WINS_EDITBOX;

                    OnAddButtonPressed( hwndDlg,
                                        IDC_WINS_SERVER_LIST,
                                        IDC_WINS_EDIT,
                                        IDC_WINS_REMOVE,
                                        (LPCTSTR) IDD_WINS_SERVER,
                                        GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_WINS_SERVER_LIST,
                               IDC_WINS_UP,
                               IDC_WINS_DOWN );

                    return TRUE ;

                case IDC_WINS_EDIT:

                    g_CurrentEditBox = WINS_EDITBOX;

                    OnEditButtonPressed( hwndDlg,
                                         IDC_WINS_SERVER_LIST,
                                         (LPCTSTR) IDD_WINS_SERVER,
                                         GenericIPDlgProc );

                    SetArrows( hwndDlg,
                               IDC_WINS_SERVER_LIST,
                               IDC_WINS_UP,
                               IDC_WINS_DOWN );

                    return TRUE ;

                case IDC_WINS_REMOVE:

                    OnRemoveButtonPressed( hwndDlg,
                                           IDC_WINS_SERVER_LIST,
                                           IDC_WINS_EDIT,
                                           IDC_WINS_REMOVE );

                    SetArrows( hwndDlg,
                               IDC_WINS_SERVER_LIST,
                               IDC_WINS_UP,
                               IDC_WINS_DOWN );

                    return TRUE ;

                case IDC_WINS_UP:

                    OnUpButtonPressed( hwndDlg, IDC_WINS_SERVER_LIST );

                    SetArrows( hwndDlg,
                               IDC_WINS_SERVER_LIST,
                               IDC_WINS_UP,
                               IDC_WINS_DOWN );

                    return TRUE ;

                case IDC_WINS_DOWN:

                    OnDownButtonPressed( hwndDlg, IDC_WINS_SERVER_LIST );

                    SetArrows( hwndDlg,
                               IDC_WINS_SERVER_LIST,
                               IDC_WINS_UP,
                               IDC_WINS_DOWN );

                    return TRUE ;

                case IDC_WINS_LMHOST:

                    // ISSUE-2002/02/28-stelo- this either needs to be removed or implemented
                    AssertMsg(FALSE,
                              "This button has not been implemented yet.");

                    return TRUE ;

            }  // end switch

            return FALSE;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR) lParam ;

            switch( pnmh->code ) {

                case PSN_APPLY: {

                    OnTcpipWinsApply( hwndDlg );

                    return TRUE ;

                }

            }

        default:
            return FALSE ;

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\iecustom.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      iecustom.c
//
// Description:
//      This file contains the dialog procedures for the IE customy settings
//      pop-up.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: OnAutoConfigCheckBox
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnAutoConfigCheckBox( IN HWND hwnd )
{

    BOOL bGrey = IsDlgButtonChecked( hwnd, IDC_CB_AUTOCONFIG );

    EnableWindow( GetDlgItem( hwnd, IDC_AUTOCONFIG_TEXT ),         bGrey );
    EnableWindow( GetDlgItem( hwnd, IDC_EB_AUTOCONFIG_URL ),       bGrey );
    EnableWindow( GetDlgItem( hwnd, IDC_AUTOCONFIG_JSCRIPT_TEXT ), bGrey );
    EnableWindow( GetDlgItem( hwnd, IDC_EB_AUTOCONFIG_URL_PAC ),   bGrey );

}

//----------------------------------------------------------------------------
//
// Function: OnInitCustomSettingsDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnInitCustomSettingsDialog( IN HWND hwnd )
{

    //
    //  Set the text limit on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_EB_INS_FILE,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_INS_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_AUTOCONFIG_URL,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_AUTOCONFIG_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_AUTOCONFIG_URL_PAC,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_AUTOCONFIG_LEN,
                        (LPARAM) 0 );

    //
    //  Set the initial values
    //

    SetWindowText( GetDlgItem( hwnd, IDC_EB_INS_FILE ),
                   GenSettings.szInsFile );

    if( GenSettings.bUseAutoConfigScript )
    {
        CheckDlgButton( hwnd, IDC_CB_AUTOCONFIG, BST_CHECKED );
    }
    else
    {
        CheckDlgButton( hwnd, IDC_CB_AUTOCONFIG, BST_UNCHECKED );
    }

    SetWindowText( GetDlgItem( hwnd, IDC_EB_AUTOCONFIG_URL ),
                   GenSettings.szAutoConfigUrl );

    SetWindowText( GetDlgItem( hwnd, IDC_EB_AUTOCONFIG_URL_PAC ),
                   GenSettings.szAutoConfigUrlJscriptOrPac );

    //
    //  Grey/Ungrey the page appropriately
    //

    OnAutoConfigCheckBox( hwnd );

}

//----------------------------------------------------------------------------
//
// Function: StoreCustomSettings
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  BOOL - TRUE if the dialog should close, FALSE if it should stay
//                  open
//
//----------------------------------------------------------------------------
static BOOL
StoreCustomSettings( IN HWND hwnd )
{

    GetWindowText( GetDlgItem( hwnd, IDC_EB_INS_FILE ),
                   GenSettings.szInsFile,
                   MAX_INS_LEN + 1 );

    GenSettings.bUseAutoConfigScript = IsDlgButtonChecked( hwnd, IDC_CB_AUTOCONFIG );

    GetWindowText( GetDlgItem( hwnd, IDC_EB_AUTOCONFIG_URL ),
                   GenSettings.szAutoConfigUrl,
                   MAX_AUTOCONFIG_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EB_AUTOCONFIG_URL_PAC ),
                   GenSettings.szAutoConfigUrlJscriptOrPac,
                   MAX_AUTOCONFIG_LEN + 1 );

    if( ! DoesFileExist( GenSettings.szInsFile ) )
    {
        INT iRet;

        iRet = ReportErrorId( hwnd, MSGTYPE_YESNO, IDS_ERR_INS_FILE_NOT_EXIST );

        if( iRet == IDNO )
        {
            return( FALSE );
        }

    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: CustomSettingsDlg
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK CustomSettingsDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam )
{
    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG:

            OnInitCustomSettingsDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) )
                {

                    case IDOK:
                        // ISSUE-2002/02/28-stelo- do I need to validate proxy addresses?
                        if( HIWORD( wParam ) == BN_CLICKED ) {

                            BOOL bCloseDialog;

                            bCloseDialog = StoreCustomSettings( hwnd );

                            if( bCloseDialog )
                            {
                                EndDialog( hwnd, TRUE );
                            }

                        }
                        break;

                    case IDCANCEL:
                        if( HIWORD( wParam ) == BN_CLICKED ) {
                            EndDialog( hwnd, FALSE );
                        }
                        break;

                    case IDC_CB_AUTOCONFIG:
                        if( HIWORD( wParam ) == BN_CLICKED ) {
                            OnAutoConfigCheckBox( hwnd );
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }

            break;

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\ie.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      tapi.c
//
// Description:
//      This file contains the dialog procedure for the Internet Explorer page.
//      (IDD_IE).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"


//
//  Prototype for the dialog procs that launch from the buttons on the IE page.
//

INT_PTR CALLBACK CustomSettingsDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam );

INT_PTR CALLBACK ProxySettingsDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam );

INT_PTR CALLBACK BrowserSettingsDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam );

//----------------------------------------------------------------------------
//
// Function: GreyUnGreyIe
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
GreyUnGreyIe( IN HWND hwnd )
{

    BOOL bGreyCustom;
    BOOL bGreySpecify;

    if( IsDlgButtonChecked( hwnd, IDC_RAD_DEFAULT_IE ) )
    {
        bGreyCustom = FALSE;

        bGreySpecify = FALSE;
    }
    else if( IsDlgButtonChecked( hwnd, IDC_RAD_AUTOCONFIG ) )
    {
        bGreyCustom = TRUE;

        bGreySpecify = FALSE;
    }
    else if( IsDlgButtonChecked( hwnd, IDC_RAD_SPECIFY ) )
    {
        bGreyCustom = FALSE;

        bGreySpecify = TRUE;
    }
    else
    {
        bGreyCustom = FALSE;

        bGreySpecify = FALSE;
    }

    EnableWindow( GetDlgItem( hwnd, IDC_CUSTOMIZE_TEXT ),      bGreyCustom );
    EnableWindow( GetDlgItem( hwnd, IDC_BUT_CUSTOM_SETTINGS ), bGreyCustom );

    EnableWindow( GetDlgItem( hwnd, IDC_PROXY_TEXT ),           bGreySpecify );
    EnableWindow( GetDlgItem( hwnd, IDC_BUT_PROXY_SETTINGS ),   bGreySpecify );
    EnableWindow( GetDlgItem( hwnd, IDC_HOMEPAGE_TEXT ),        bGreySpecify );
    EnableWindow( GetDlgItem( hwnd, IDC_BUT_BROWSER_SETTINGS ), bGreySpecify );

}

//----------------------------------------------------------------------------
//
// Function: OnRadioButtonIe
//
// Purpose: Called when a radio button is pushed.  Grey/ungrey controls.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//             IN INT nButtonId - the radio button to check
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnRadioButtonIe( IN HWND hwnd, IN INT nButtonId )
{
    CheckRadioButton( hwnd,
                      IDC_RAD_DEFAULT_IE,
                      IDC_RAD_SPECIFY,
                      nButtonId );

    GreyUnGreyIe( hwnd );
}

//----------------------------------------------------------------------------
//
// Function: OnCustomIe
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnCustomIe( IN HWND hwnd )
{

    DialogBox( FixedGlobals.hInstance,
               MAKEINTRESOURCE(IDD_IE_CUSTOM),
               hwnd,
               CustomSettingsDlg );

}

//----------------------------------------------------------------------------
//
// Function: OnProxyIe
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnProxyIe( IN HWND hwnd )
{

    DialogBox( FixedGlobals.hInstance,
               MAKEINTRESOURCE(IDD_IE_PROXY),
               hwnd,
               ProxySettingsDlg );

}

//----------------------------------------------------------------------------
//
// Function: OnBrowserIe
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnBrowserIe( IN HWND hwnd )
{
    //
    // If user hits ok, store the proxy settings the user entered
    //
    if( DialogBox( FixedGlobals.hInstance,
                   MAKEINTRESOURCE(IDD_IE_BROWSER),
                   hwnd,
                   BrowserSettingsDlg ) )
    {
        // StoreBrowserSettings( hwnd );
    }
}

//----------------------------------------------------------------------------
//
// Function: OnIeInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnIeInitDialog( IN HWND hwnd )
{



}

//----------------------------------------------------------------------------
//
// Function: OnIeSetActive
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnIeSetActive( IN HWND hwnd )
{

    int nButtonId;

    if( GenSettings.IeCustomizeMethod == IE_NO_CUSTOMIZATION )
    {
        nButtonId = IDC_RAD_DEFAULT_IE;
    }
    else if( GenSettings.IeCustomizeMethod == IE_USE_BRANDING_FILE )
    {
        nButtonId = IDC_RAD_AUTOCONFIG;
    }
    else if( GenSettings.IeCustomizeMethod == IE_SPECIFY_SETTINGS )
    {
        nButtonId = IDC_RAD_SPECIFY;
    }
    else
    {
        nButtonId = IDC_RAD_DEFAULT_IE;
    }

    CheckRadioButton( hwnd,
                      IDC_RAD_DEFAULT_IE,
                      IDC_RAD_SPECIFY,
                      nButtonId );

    GreyUnGreyIe( hwnd );

    WIZ_BUTTONS(hwnd , PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
// Function: OnWizNextIe
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnWizNextIe( IN HWND hwnd )
{

    if( IsDlgButtonChecked( hwnd, IDC_RAD_DEFAULT_IE ) )
    {
        GenSettings.IeCustomizeMethod = IE_NO_CUSTOMIZATION;
    }
    else if( IsDlgButtonChecked( hwnd, IDC_RAD_AUTOCONFIG ) )
    {
        GenSettings.IeCustomizeMethod = IE_USE_BRANDING_FILE;
    }
    else if( IsDlgButtonChecked( hwnd, IDC_RAD_SPECIFY ) )
    {
        GenSettings.IeCustomizeMethod = IE_SPECIFY_SETTINGS;
    }
    else
    {
        GenSettings.IeCustomizeMethod = IE_NO_CUSTOMIZATION;
    }
}

//----------------------------------------------------------------------------
//
// Function: DlgIePage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgIePage( IN HWND     hwnd,
           IN UINT     uMsg,
           IN WPARAM   wParam,
           IN LPARAM   lParam)
{

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnIeInitDialog( hwnd );

            break;

        }

        case WM_COMMAND:
        {
            int nButtonId=LOWORD(wParam);

            switch ( nButtonId ) {

                case IDC_RAD_AUTOCONFIG:
                case IDC_RAD_DEFAULT_IE:
                case IDC_RAD_SPECIFY:
                    if( HIWORD( wParam ) == BN_CLICKED )
                        OnRadioButtonIe( hwnd, nButtonId );
                    break;

                case IDC_BUT_CUSTOM_SETTINGS:
                    if( HIWORD(wParam) == BN_CLICKED )
                        OnCustomIe(hwnd);
                    break;

                case IDC_BUT_PROXY_SETTINGS:
                    if( HIWORD(wParam) == BN_CLICKED )
                        OnProxyIe(hwnd);
                    break;

                case IDC_BUT_BROWSER_SETTINGS:
                    if( HIWORD(wParam) == BN_CLICKED )
                        OnBrowserIe(hwnd);
                    break;

                default:
                    bStatus = FALSE;
                    break;
            }

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_BROW_SHELL;

                    OnIeSetActive( hwnd );

                    break;

                }
                case PSN_WIZBACK:

                    bStatus = FALSE; 
                    break;

                case PSN_WIZNEXT:

                    OnWizNextIe( hwnd );
                    bStatus = FALSE;

                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:

                    break;
            }


            break;
        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\pch.h ===
#include "setupmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\iebrowse.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      iebrowse.c
//
// Description:
//      This file contains the dialog procedures for the IE browser settings
//      pop-ups.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define MAX_FAVORITE_LEN  1024

static TCHAR *StrFriendlyName;
static TCHAR *StrUrl;

//----------------------------------------------------------------------------
//
// Function: InsertEntryIntoFavorites
//
// Purpose:
//
// Arguments:
//
// Returns:  TRUE  if the item was added,
//           FALSE if it was not
//
//----------------------------------------------------------------------------
static BOOL
InsertEntryIntoFavorites( IN HWND hwnd, TCHAR *pszFriendlyName, TCHAR *pszURL )
{

    LVITEM LvItem;
    HWND hFavorites;
    INT iPosition;
    BOOL bSuccess = TRUE;

    hFavorites = GetDlgItem( hwnd, IDC_LV_FAVORITES );

    iPosition = ListView_GetItemCount( hFavorites );

    ZeroMemory( &LvItem, sizeof(LVITEM) );

    LvItem.mask = LVIF_TEXT;

    LvItem.iItem      = iPosition;
    LvItem.iSubItem   = 0;
    LvItem.pszText    = pszFriendlyName;
    LvItem.cchTextMax = MAX_FAVORITE_LEN;

    //
    // if ListView_InsertItem returns a non-negative value then it succeeded
    //

    if( ListView_InsertItem( hFavorites, &LvItem ) < 0 )
    {
        bSuccess = FALSE;
    }

    ListView_SetItemText( hFavorites, iPosition, 1, pszURL );

    return( bSuccess );

}

//----------------------------------------------------------------------------
//
// Function: OnInitFavoritesDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnInitFavoritesDialog( IN HWND hwnd )
{

    RECT rect;
    INT iColWidth;
    INT iRetVal;
    INT iIndex;
    INT iEntries;
    LV_COLUMN lvCol;
    TCHAR *pFriendlyName;
    TCHAR *pUrl;
    HWND hFavoritesListView;
    INT iCount = 0;

    //
    //  Set the text limit on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_EB_FRIENDLYNAME,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_FAVORITE_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_URL,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_FAVORITE_LEN,
                        (LPARAM) 0 );

    //
    //  Initialize the list box
    //

    StrFriendlyName = MyLoadString( IDS_FRIENDLY_NAME );

    StrUrl = MyLoadString( IDS_URL );


    hFavoritesListView = GetDlgItem( hwnd, IDC_LV_FAVORITES );

    GetClientRect( hFavoritesListView, &rect );

    iColWidth = ( rect.right / 2 );

    ListView_SetColumnWidth( hFavoritesListView, 0, iColWidth );

    ListView_SetColumnWidth( hFavoritesListView, 1, iColWidth );



    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT;
    lvCol.fmt =  LVCFMT_LEFT;
    lvCol.cx =   iColWidth;

    //
    //  Add the two columns and header text
    //

    for( iIndex = 0; iIndex < 2; iIndex++ ) {

        if ( iIndex == 0 )
            lvCol.pszText = (LPTSTR) StrFriendlyName;
        else
            lvCol.pszText = (LPTSTR) StrUrl;

        iRetVal = ListView_InsertColumn( hFavoritesListView, iIndex, &lvCol );

        if( iRetVal == -1 )
        {
            // ISSUE-2002/02/28-stelo- we got a problem if we get here, can't make the column headers
        }

    }

    //
    //  Populate the favorites dialog
    //

    iEntries = GetNameListSize( &GenSettings.Favorites );

    for( iIndex = 0; iIndex < iEntries; iIndex = iIndex + 2 )
    {

        pFriendlyName = GetNameListName( &GenSettings.Favorites, iIndex );

        pUrl = GetNameListName( &GenSettings.Favorites, iIndex + 1 );

        if( *pFriendlyName != _T('\0') && *pUrl != _T('\0') )
        {
            InsertEntryIntoFavorites( hwnd, pFriendlyName, pUrl );
        }

    }

    iCount = ListView_GetItemCount( hFavoritesListView );

    if( iCount > 0 )
    {
        EnableWindow( GetDlgItem( hwnd, IDC_BUT_REMOVE ), TRUE );
    }
    else
    {
        EnableWindow( GetDlgItem( hwnd, IDC_BUT_REMOVE ), FALSE );
    }

}

//----------------------------------------------------------------------------
//
// Function: OnAddFavorites
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnAddFavorites( IN HWND hwnd )
{

    TCHAR szFriendlyName[MAX_FAVORITE_LEN + 1];
    TCHAR szURL[MAX_FAVORITE_LEN + 1];

    GetWindowText( GetDlgItem( hwnd, IDC_EB_FRIENDLYNAME ),
                   szFriendlyName,
                   MAX_FAVORITE_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EB_URL ),
                   szURL,
                   MAX_FAVORITE_LEN + 1 );

    if( lstrcmp( szFriendlyName, _T("") ) == 0)
    {
        ReportErrorId( hwnd,
                       MSGTYPE_ERR,
                       IDS_ERR_FRIENDLY_NAME_BLANK );

        return;
    }
    else if( lstrcmp( szURL, _T("") ) == 0)
    {
        ReportErrorId( hwnd,
                       MSGTYPE_ERR,
                       IDS_ERR_URL_BLANK );

        return;
    }

    if( InsertEntryIntoFavorites( hwnd, szFriendlyName, szURL ) )
    {
        SetWindowText( GetDlgItem( hwnd, IDC_EB_FRIENDLYNAME ),
                       _T("") );

        SetWindowText( GetDlgItem( hwnd, IDC_EB_URL ),
                       _T("") );

        EnableWindow( GetDlgItem( hwnd, IDC_BUT_REMOVE ), TRUE );
    }

}

//----------------------------------------------------------------------------
//
// Function: OnRemoveFavorites
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnRemoveFavorites( IN HWND hwnd )
{

    HWND hFavorites;
    INT iSelectedItem;
    INT iCount;

    hFavorites = GetDlgItem( hwnd, IDC_LV_FAVORITES );

    iSelectedItem = ListView_GetSelectionMark( hFavorites );

    //
    //  see if nothing was selected
    //

    if( iSelectedItem == -1 )
    {
        return;
    }

    ListView_DeleteItem( hFavorites, iSelectedItem );

    //
    //  Set the state of the remove button appropriately
    //

    iCount = ListView_GetItemCount( hFavorites );

    if( iCount > 0 )
    {
        EnableWindow( GetDlgItem( hwnd, IDC_BUT_REMOVE ), TRUE );
    }
    else
    {
        EnableWindow( GetDlgItem( hwnd, IDC_BUT_REMOVE ), FALSE );
    }

}

//----------------------------------------------------------------------------
//
// Function: StoreFavorites
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
StoreFavorites( IN HWND hwnd )
{

    INT    i;
    INT    iEntries;
    LVITEM FriendlyNameItem;
    LVITEM UrlItem;
    HWND   hFavorites;
    TCHAR  szFriendlyName[MAX_FAVORITE_LEN + 1];
    TCHAR  szURL[MAX_FAVORITE_LEN + 1];

    hFavorites = GetDlgItem( hwnd, IDC_LV_FAVORITES );

    ZeroMemory( &FriendlyNameItem, sizeof(LVITEM) );
    ZeroMemory( &UrlItem, sizeof(LVITEM) );

    ResetNameList( &GenSettings.Favorites );

    FriendlyNameItem.mask       = LVIF_TEXT;
    FriendlyNameItem.pszText    = szFriendlyName;
    FriendlyNameItem.cchTextMax = MAX_FAVORITE_LEN;
    FriendlyNameItem.iSubItem   = 0;

    UrlItem.mask       = LVIF_TEXT;
    UrlItem.pszText    = szURL;
    UrlItem.cchTextMax = MAX_FAVORITE_LEN;
    UrlItem.iSubItem   = 1;

    iEntries = ListView_GetItemCount( hFavorites );

    for( i = 0; i < iEntries; i++ )
    {

        FriendlyNameItem.iItem = i;
        UrlItem.iItem          = i;

        if( ListView_GetItem( hFavorites, &FriendlyNameItem ) &&
            ListView_GetItem( hFavorites, &UrlItem ) )
        {

            if( szFriendlyName[0] != _T('\0') && szURL[0] != _T('\0') )
            {
                AddNameToNameList( &GenSettings.Favorites,
                                   szFriendlyName );

                AddNameToNameList( &GenSettings.Favorites,
                                   szURL );
            }

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: FavoritesDlg
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK FavoritesDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam )
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnInitFavoritesDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) )
                {

                    case IDOK:

                        // ISSUE-2002/02/28-stelo- do I need to validate proxy addresses?
                        if( HIWORD( wParam ) == BN_CLICKED ) {

                            StoreFavorites( hwnd );

                            EndDialog( hwnd, TRUE );

                        }
                        break;

                    case IDCANCEL:
                        if( HIWORD( wParam ) == BN_CLICKED ) {
                            EndDialog( hwnd, FALSE );
                        }
                        break;

                    case IDC_BUT_ADD:
                        if( HIWORD( wParam ) == BN_CLICKED ) {
                            OnAddFavorites( hwnd );
                        }
                        break;

                    case IDC_BUT_REMOVE:
                        if( HIWORD( wParam ) == BN_CLICKED ) {
                            OnRemoveFavorites( hwnd );
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }

            break;

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
// Function: OnInitBrowserSettingsDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnInitBrowserSettingsDialog( IN HWND hwnd )
{

    //
    //  Set the text limit on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_EB_HOMEPAGE,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_HOMEPAGE_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_HELPPAGE,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_HELPPAGE_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_SEARCHPAGE,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_SEARCHPAGE_LEN,
                        (LPARAM) 0 );

    //
    //  Set the initial values
    //

    SetWindowText( GetDlgItem( hwnd, IDC_EB_HOMEPAGE ),
                   GenSettings.szHomePage );

    SetWindowText( GetDlgItem( hwnd, IDC_EB_HELPPAGE ),
                   GenSettings.szHelpPage );

    SetWindowText( GetDlgItem( hwnd, IDC_EB_SEARCHPAGE ),
                   GenSettings.szSearchPage );

}

//----------------------------------------------------------------------------
//
// Function: OnDestroyBrowserSettings
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnDestroyBrowserSettings( IN HWND hwnd )
{

    //
    //  Free the strings that were allocated for this page
    //

    free( StrFriendlyName );

    free( StrUrl );

}

//----------------------------------------------------------------------------
//
// Function: StoreBrowserSettings
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
StoreBrowserSettings( IN HWND hwnd )
{

    GetWindowText( GetDlgItem( hwnd, IDC_EB_HOMEPAGE ),
                   GenSettings.szHomePage,
                   MAX_HOMEPAGE_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EB_HELPPAGE ),
                   GenSettings.szHelpPage,
                   MAX_HELPPAGE_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EB_SEARCHPAGE ),
                   GenSettings.szSearchPage,
                   MAX_SEARCHPAGE_LEN + 1 );

}

//----------------------------------------------------------------------------
//
// Function: OnAddFavoritesClicked
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnAddFavoritesClicked( IN HWND hwnd )
{

    DialogBox( FixedGlobals.hInstance,
               MAKEINTRESOURCE(IDD_IE_FAVORITES),
               hwnd,
               FavoritesDlg );

}

//----------------------------------------------------------------------------
//
// Function: BrowserSettingsDlg
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK BrowserSettingsDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam )
{
    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnInitBrowserSettingsDialog( hwnd );

            break;

        case WM_DESTROY:

            OnDestroyBrowserSettings( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) )
                {

                    case IDOK:
                        // ISSUE-2002/02/28-stelo- do I need to validate proxy addresses?
                        if( HIWORD( wParam ) == BN_CLICKED ) {

                            StoreBrowserSettings( hwnd );

                            EndDialog( hwnd, TRUE );
                        }
                        break;

                    case IDCANCEL:
                        if( HIWORD( wParam ) == BN_CLICKED ) {
                            EndDialog( hwnd, FALSE );
                        }
                        break;

                    case IDC_BUT_FAVORITES:
                        if( HIWORD(wParam) == BN_CLICKED )
                            OnAddFavoritesClicked( hwnd );
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }

            break;

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\ieproxy.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      ieproxy.c
//
// Description:
//      This file contains the dialog procedures for the IE proxy and advanced
//      proxy settings pop-ups.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//----------------------------------------------------------------------------
//
// Function: OnUseSameProxyCheckBox
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnUseSameProxyCheckBox( IN HWND hwnd )
{

    TCHAR szAddressBuffer[MAX_PROXY_LEN + 1];
    TCHAR szPortBuffer[MAX_PROXY_PORT_LEN + 1];
    BOOL bUseSameProxy = IsDlgButtonChecked( hwnd, IDC_CB_USE_SAME_PROXY );

    EnableWindow( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY ),      ! bUseSameProxy );
    EnableWindow( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY_PORT ), ! bUseSameProxy );
    EnableWindow( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY ),         ! bUseSameProxy );
    EnableWindow( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY_PORT ),    ! bUseSameProxy );
    EnableWindow( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY ),      ! bUseSameProxy );
    EnableWindow( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY_PORT ), ! bUseSameProxy );
    EnableWindow( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY ),       ! bUseSameProxy );
    EnableWindow( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY_PORT ),  ! bUseSameProxy );

    //
    //  Copy the HTTP proxy address to all the other proxy server edit boxes.
    //

    if( bUseSameProxy )
    {

        GetWindowText( GetDlgItem( hwnd, IDC_EDT_HTTP_PROXY ),
                       szAddressBuffer,
                       MAX_PROXY_LEN + 1 );

        GetWindowText( GetDlgItem( hwnd, IDC_EDT_HTTP_PROXY_PORT ),
                       szPortBuffer,
                       MAX_PROXY_PORT_LEN + 1 );

        SetWindowText( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY ),      szAddressBuffer );
        SetWindowText( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY_PORT ), szPortBuffer );

        SetWindowText( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY ),         szAddressBuffer );
        SetWindowText( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY_PORT ),    szPortBuffer );

        SetWindowText( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY ),      szAddressBuffer );
        SetWindowText( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY_PORT ), szPortBuffer );

        SetWindowText( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY ),       szAddressBuffer );
        SetWindowText( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY_PORT ),  szPortBuffer );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnInitAdvancedProxySettingsDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnInitAdvancedProxySettingsDialog( IN HWND hwnd )
{

    //
    //  Set the text limit on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_EDT_HTTP_PROXY,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_HTTP_PROXY_PORT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_PORT_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_SECURE_PROXY,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_SECURE_PROXY_PORT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_PORT_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_FTP_PROXY,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_FTP_PROXY_PORT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_PORT_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_GOPHER_PROXY,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_GOPHER_PROXY_PORT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_PORT_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_SOCKS_PROXY,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EDT_SOCKS_PROXY_PORT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_PORT_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_EXCEPTIONS,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_EXCEPTION_LEN,
                        (LPARAM) 0 );

    //
    //  Set the initial values
    //

    if( GenSettings.bUseSameProxyForAllProtocols )
    {
        CheckDlgButton( hwnd, IDC_CB_USE_SAME_PROXY, BST_CHECKED );
    }
    else
    {
        CheckDlgButton( hwnd, IDC_CB_USE_SAME_PROXY, BST_UNCHECKED );
    }

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_HTTP_PROXY ),
                   GenSettings.szHttpProxyAddress );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_HTTP_PROXY_PORT ),
                   GenSettings.szHttpProxyPort );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY ),
                   GenSettings.szSecureProxyAddress );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY_PORT ),
                   GenSettings.szSecureProxyPort );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY ),
                   GenSettings.szFtpProxyAddress );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY_PORT ),
                   GenSettings.szFtpProxyPort );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY ),
                   GenSettings.szGopherProxyAddress );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY_PORT ),
                   GenSettings.szGopherProxyPort );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY ),
                   GenSettings.szSocksProxyAddress );

    SetWindowText( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY_PORT ),
                   GenSettings.szSocksProxyPort );

    SetWindowText( GetDlgItem( hwnd, IDC_EB_EXCEPTIONS ),
                   GenSettings.szProxyExceptions );

    //
    //  Grey/Ungrey the page appropriately
    //

    OnUseSameProxyCheckBox( hwnd );

}

//----------------------------------------------------------------------------
//
// Function: StoreAdvancedProxySettings
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
StoreAdvancedProxySettings( IN HWND hwnd )
{

    GenSettings.bUseSameProxyForAllProtocols = IsDlgButtonChecked( hwnd, IDC_CB_USE_SAME_PROXY );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_HTTP_PROXY ),
                   GenSettings.szHttpProxyAddress,
                   MAX_PROXY_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_HTTP_PROXY_PORT ),
                   GenSettings.szHttpProxyPort,
                   MAX_PROXY_PORT_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY ),
                   GenSettings.szSecureProxyAddress,
                   MAX_PROXY_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_SECURE_PROXY_PORT ),
                   GenSettings.szSecureProxyPort,
                   MAX_PROXY_PORT_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY ),
                   GenSettings.szFtpProxyAddress,
                   MAX_PROXY_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_FTP_PROXY_PORT ),
                   GenSettings.szFtpProxyPort,
                   MAX_PROXY_PORT_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY ),
                   GenSettings.szGopherProxyAddress,
                   MAX_PROXY_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_GOPHER_PROXY_PORT ),
                   GenSettings.szGopherProxyPort,
                   MAX_PROXY_PORT_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY ),
                   GenSettings.szSocksProxyAddress,
                   MAX_PROXY_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EDT_SOCKS_PROXY_PORT ),
                   GenSettings.szSocksProxyPort,
                   MAX_PROXY_PORT_LEN + 1 );

    GetWindowText( GetDlgItem( hwnd, IDC_EB_EXCEPTIONS ),
                   GenSettings.szProxyExceptions,
                   MAX_EXCEPTION_LEN + 1 );

}

//----------------------------------------------------------------------------
//
// Function: AdvancedProxySettingsDlg
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK AdvancedProxySettingsDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam )
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {

        case WM_INITDIALOG:

            OnInitAdvancedProxySettingsDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch ( nButtonId = LOWORD(wParam) )
                {

                    case IDOK:
                        if( HIWORD( wParam ) == BN_CLICKED )
                        {
                            StoreAdvancedProxySettings( hwnd );

                            EndDialog( hwnd, TRUE );
                        }
                        break;

                    case IDCANCEL:
                        if( HIWORD( wParam ) == BN_CLICKED )
                        {
                            EndDialog( hwnd, FALSE );
                        }
                        break;

                    case IDC_CB_USE_SAME_PROXY:
                        if( HIWORD( wParam ) == BN_CLICKED )
                        {
                            OnUseSameProxyCheckBox( hwnd );
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }

            break;

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}

//----------------------------------------------------------------------------
//
// Function: GreyProxyPage
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
GreyProxyPage( IN HWND hwnd )
{

    BOOL bUseProxy = IsDlgButtonChecked( hwnd, IDC_CB_USE_PROXY );


    if( bUseProxy )
    {
        EnableWindow( GetDlgItem( hwnd, IDC_ADDRESS_TEXT ),
                      GenSettings.bUseSameProxyForAllProtocols );

        EnableWindow( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                      GenSettings.bUseSameProxyForAllProtocols );

        EnableWindow( GetDlgItem( hwnd, IDC_PORT_TEXT ),
                      GenSettings.bUseSameProxyForAllProtocols );

        EnableWindow( GetDlgItem( hwnd, IDC_EB_PORT ),
                      GenSettings.bUseSameProxyForAllProtocols );

    }
    else
    {
        EnableWindow( GetDlgItem( hwnd, IDC_ADDRESS_TEXT ),
                      FALSE );

        EnableWindow( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                      FALSE );

        EnableWindow( GetDlgItem( hwnd, IDC_PORT_TEXT ),
                      FALSE );

        EnableWindow( GetDlgItem( hwnd, IDC_EB_PORT ),
                      FALSE );

    }

    EnableWindow( GetDlgItem( hwnd, IDC_CB_LOCAL_BYPASS_PROXY ),
                  bUseProxy );

    EnableWindow( GetDlgItem( hwnd, IDC_BUT_ADVANCED ),
                  bUseProxy );


}

//----------------------------------------------------------------------------
//
// Function: GreyProxyPage
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
FillProxyBoxes( IN HWND hwnd )
{

    if( GenSettings.bUseSameProxyForAllProtocols )
    {
        SetWindowText( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                       GenSettings.szHttpProxyAddress );

        SetWindowText( GetDlgItem( hwnd, IDC_EB_PORT ),
                       GenSettings.szHttpProxyPort );
    }
    else
    {
        SetWindowText( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                       _T("") );

        SetWindowText( GetDlgItem( hwnd, IDC_EB_PORT ),
                       _T("") );
    }

}

//----------------------------------------------------------------------------
//
// Function: OnInitProxySettingsDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnInitProxySettingsDialog( IN HWND hwnd )
{

    //
    //  Set the text limit on the edit boxes
    //

    SendDlgItemMessage( hwnd,
                        IDC_EB_ADDRESS,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_LEN,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_EB_PORT,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PROXY_PORT_LEN,
                        (LPARAM) 0 );

    //
    //  Set the initial values
    //

    if( GenSettings.bUseProxyServer )
    {
        CheckDlgButton( hwnd, IDC_CB_USE_PROXY, BST_CHECKED );

        if( GenSettings.bUseSameProxyForAllProtocols )
        {
            SetWindowText( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                           GenSettings.szHttpProxyAddress );

            SetWindowText( GetDlgItem( hwnd, IDC_EB_PORT ),
                           GenSettings.szHttpProxyPort );
        }
        else
        {
            SetWindowText( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                           _T("") );

            SetWindowText( GetDlgItem( hwnd, IDC_EB_PORT ),
                           _T("") );
        }

    }
    else
    {
        CheckDlgButton( hwnd, IDC_CB_USE_PROXY, BST_UNCHECKED );
    }

    if( GenSettings.bBypassProxyForLocalAddresses )
    {
        CheckDlgButton( hwnd, IDC_CB_LOCAL_BYPASS_PROXY, BST_CHECKED );
    }
    else
    {
        CheckDlgButton( hwnd, IDC_CB_LOCAL_BYPASS_PROXY, BST_UNCHECKED );
    }

    GreyProxyPage( hwnd );

}

//----------------------------------------------------------------------------
//
// Function: StoreProxySettings
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
StoreProxySettings( IN HWND hwnd )
{

    GenSettings.bUseProxyServer = IsDlgButtonChecked( hwnd, IDC_CB_USE_PROXY );

    if( GenSettings.bUseSameProxyForAllProtocols )
    {
        GetWindowText( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                       GenSettings.szHttpProxyAddress,
                       MAX_PROXY_LEN + 1 );

        GetWindowText( GetDlgItem( hwnd, IDC_EB_PORT ),
                       GenSettings.szHttpProxyPort,
                       MAX_PROXY_PORT_LEN + 1 );
    }

    GenSettings.bBypassProxyForLocalAddresses = IsDlgButtonChecked( hwnd, IDC_CB_LOCAL_BYPASS_PROXY );

}

//----------------------------------------------------------------------------
//
// Function: OnAdvancedProxyClicked
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnAdvancedProxyClicked( IN HWND hwnd )
{

    if( GenSettings.bUseSameProxyForAllProtocols )
    {
        GetWindowText( GetDlgItem( hwnd, IDC_EB_ADDRESS ),
                       GenSettings.szHttpProxyAddress,
                       MAX_PROXY_LEN + 1 );

        GetWindowText( GetDlgItem( hwnd, IDC_EB_PORT ),
                       GenSettings.szHttpProxyPort,
                       MAX_PROXY_PORT_LEN + 1 );
    }

    DialogBox( FixedGlobals.hInstance,
               MAKEINTRESOURCE(IDD_IE_ADVANCED_PROXY),
               hwnd,
               AdvancedProxySettingsDlg );

}

//----------------------------------------------------------------------------
//
// Function: ProxySettingsDlg
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK ProxySettingsDlg(
    IN HWND     hwnd,
    IN UINT     uMsg,
    IN WPARAM   wParam,
    IN LPARAM   lParam )
{
    BOOL bStatus = TRUE;

    switch( uMsg )
    {

        case WM_INITDIALOG:

            OnInitProxySettingsDialog( hwnd );

            break;

        case WM_COMMAND:
            {
                int nButtonId;

                switch( nButtonId = LOWORD(wParam) )
                {

                    case IDOK:
                        if( HIWORD( wParam ) == BN_CLICKED )
                        {
                            StoreProxySettings( hwnd );

                            EndDialog( hwnd, TRUE );
                        }
                        break;

                    case IDCANCEL:
                        if( HIWORD( wParam ) == BN_CLICKED )
                        {
                            EndDialog( hwnd, FALSE );
                        }
                        break;

                    case IDC_BUT_ADVANCED:
                        if( HIWORD(wParam) == BN_CLICKED )
                        {
                            OnAdvancedProxyClicked( hwnd );

                            GreyProxyPage( hwnd );

                            FillProxyBoxes( hwnd );

                        }
                        break;

                    case IDC_CB_USE_PROXY:
                        if( HIWORD(wParam) == BN_CLICKED )
                        {
                            GreyProxyPage( hwnd );
                        }
                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }

            break;

        default:
            bStatus = FALSE;
            break;
    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oc.rc
//
#define IDC_OPTCOMP                     1000
#define IDD_TAPI                        14000
#define IDD_REGIONALSETTINGS            14001
#define IDD_LANGUAGESETTINGS            14002
#define IDD_OEMADS                      14003
#define IDD_HAL                         14008
#define IDD_SCSI                        14009
#define IDD_REGIONALSETTINGS_POPUP      14010
#define IDD_CREATESYSPREPFOLDER         14011
#define IDD_IE                          14012
#define IDD_IE_PROXY                    14013
#define IDD_IE_ADVANCED_PROXY           14014
#define IDD_IE_BROWSER                  14015
#define IDD_IE_FAVORITES                14016
#define IDD_IE_CUSTOM                   14017
#define IDD_OPTCOMP                     14018
#define IDC_LOGOBITMAP                  14100
#define IDC_BACKGROUNDBITMAP            14101
#define IDC_LOGOBITMAPBROWSE            14102
#define IDC_BACKGROUNDBITMAPBROWSE      14103
#define IDC_OUTSIDELINE                 14120
#define IDC_COUNTRYCODE                 14121
#define IDC_AREACODE                    14122
#define IDC_CB_TONEPULSE                14123
#define IDS_TONE                        14124
#define IDS_PULSE                       14125
#define IDC_RB_SKIP                     14140
#define IDC_RB_USE_DEFAULT              14141
#define IDC_RB_SPECIFY                  14142
#define IDC_BUT_CUSTOM                  14143
#define IDC_LANG_TEXT                   14144
#define IDC_CB_LANGUAGE_LOCALE          14145
#define IDC_CHB_CUSTOMIZE               14146
#define IDC_LANGUAGES                   14160
#define IDS_United_States_of_America    14180
#define IDS_Anguilla                    14181
#define IDS_Antigua                     14182
#define IDS_Bahamas                     14183
#define IDS_Barbados                    14184
#define IDS_Bermuda                     14185
#define IDS_British_Virgin_Islands      14186
#define IDS_Canada                      14187
#define IDS_Cayman_Islands              14188
#define IDS_Dominica                    14189
#define IDS_Dominican_Republic          14190
#define IDS_Grenada                     14191
#define IDS_Jamaica                     14192
#define IDS_Montserrat                  14193
#define IDS_Nevis                       14194
#define IDS_St__Kitts                   14195
#define IDS_St__Vincent_Grenadines      14196
#define IDS_Trinidad_and_Tobago         14197
#define IDS_Turks_and_Caicos_Islands    14198
#define IDS_Barbuda                     14199
#define IDS_Puerto_Rico                 14200
#define IDS_Saint_Lucia                 14201
#define IDS_United_States_Virgin_Is     14202
#define IDS_Egypt                       14203
#define IDS_Morocco                     14204
#define IDS_Algeria                     14205
#define IDS_Tunisia                     14206
#define IDS_Libya                       14207
#define IDS_Gambia                      14208
#define IDS_Senegal                     14209
#define IDS_Mauritania                  14210
#define IDS_Mali                        14211
#define IDS_Guinea                      14212
#define IDS_Cote_d_Ivoire               14213
#define IDS_Burkina_Faso                14214
#define IDS_Niger                       14215
#define IDS_Togo                        14216
#define IDS_Benin                       14217
#define IDS_Mauritius                   14218
#define IDS_Liberia                     14219
#define IDS_Sierra_Leone                14220
#define IDS_Ghana                       14221
#define IDS_Nigeria                     14222
#define IDS_Chad                        14223
#define IDS_Central_African_Rep         14224
#define IDS_Cameroon                    14225
#define IDS_Cape_Verde                  14226
#define IDS_Sao_Tome_and_Principe       14227
#define IDS_Equatorial_Guinea           14228
#define IDS_Gabon                       14229
#define IDS_Congo                       14230
#define IDS_Dem_Rep_of_the_Congo        14231
#define IDS_Angola                      14232
#define IDS_Guinea_Bissau               14233
#define IDS_Diego_Garcia                14234
#define IDS_Ascension_Island            14235
#define IDS_Seychelles                  14236
#define IDS_Sudan                       14237
#define IDS_Rwanda                      14238
#define IDS_Ethiopia                    14239
#define IDS_Somalia                     14240
#define IDS_Djibouti                    14241
#define IDS_Kenya                       14242
#define IDS_Tanzania                    14243
#define IDS_Uganda                      14244
#define IDS_Burundi                     14245
#define IDS_Mozambique                  14246
#define IDS_Zambia                      14247
#define IDS_Madagascar                  14248
#define IDS_Reunion_Island              14249
#define IDS_Zimbabwe                    14250
#define IDS_Namibia                     14251
#define IDS_Malawi                      14252
#define IDS_Lesotho                     14253
#define IDS_Botswana                    14254
#define IDS_Swaziland                   14255
#define IDS_Mayotte_Island              14256
#define IDS_Comoros                     14257
#define IDS_South_Africa                14258
#define IDS_St__Helena                  14259
#define IDS_Eritrea                     14260
#define IDS_Aruba                       14261
#define IDS_Faeroe_Islands              14262
#define IDS_Greenland                   14263
#define IDS_Greece                      14264
#define IDS_Netherlands                 14265
#define IDS_Belgium                     14266
#define IDS_France                      14267
#define IDS_Monaco                      14268
#define IDS_Spain                       14269
#define IDS_Gibraltar                   14270
#define IDS_Portugal                    14271
#define IDS_Luxembourg                  14272
#define IDS_Ireland                     14273
#define IDS_Iceland                     14274
#define IDS_Albania                     14275
#define IDS_Malta                       14276
#define IDS_Cyprus                      14277
#define IDS_Finland                     14278
#define IDS_Bulgaria                    14279
#define IDS_Hungary                     14280
#define IDS_Lithuania                   14281
#define IDS_Latvia                      14282
#define IDS_Estonia                     14283
#define IDS_Moldova                     14284
#define IDS_Armenia                     14285
#define IDS_Belarus                     14286
#define IDS_Andorra                     14287
#define IDS_San_Marino                  14288
#define IDS_Vatican_City                14289
#define IDS_Ukraine                     14290
#define IDS_Yugoslavia                  14291
#define IDS_Croatia                     14292
#define IDS_Slovenia                    14293
#define IDS_Bosnia_and_Herzegovina      14294
#define IDS_Former_Yugo_Rep_of_Macedonia 14295
#define IDS_Italy                       14296
#define IDS_Romania                     14297
#define IDS_Switzerland                 14298
#define IDS_Liechtenstein               14299
#define IDS_Czech_Republic              14300
#define IDS_Slovakia                    14301
#define IDS_Austria                     14302
#define IDS_United_Kingdom              14303
#define IDS_Denmark                     14304
#define IDS_Sweden                      14305
#define IDS_Norway                      14306
#define IDS_Poland                      14307
#define IDS_Germany                     14308
#define IDS_Falkland_Islands            14309
#define IDS_Belize                      14310
#define IDS_Guatemala                   14311
#define IDS_El_Salvador                 14312
#define IDS_Honduras                    14313
#define IDS_Nicaragua                   14314
#define IDS_Costa_Rica                  14315
#define IDS_Panama                      14316
#define IDS_St__Pierre_and_Miquelon     14317
#define IDS_Haiti                       14318
#define IDS_Peru                        14319
#define IDS_Mexico                      14320
#define IDS_Cuba                        14321
#define IDS_Guantanamo_Bay              14322
#define IDS_Argentina                   14323
#define IDS_Brazil                      14324
#define IDS_Chile                       14325
#define IDS_Colombia                    14326
#define IDS_Venezuela                   14327
#define IDS_Guadeloupe                  14328
#define IDS_French_Antilles             14329
#define IDS_Bolivia                     14330
#define IDS_Guyana                      14331
#define IDS_Ecuador                     14332
#define IDS_French_Guiana               14333
#define IDS_Paraguay                    14334
#define IDS_Martinique                  14335
#define IDS_Suriname                    14336
#define IDS_Uruguay                     14337
#define IDS_Netherlands_Antilles        14338
#define IDS_Malaysia                    14339
#define IDS_Australia                   14340
#define IDS_Cocos_Keeling_Islands       14341
#define IDS_Indonesia                   14342
#define IDS_Philippines                 14343
#define IDS_New_Zealand                 14344
#define IDS_Singapore                   14345
#define IDS_Thailand                    14346
#define IDS_Saipan_Island               14347
#define IDS_Rota_Island                 14348
#define IDS_Tinian_Island               14349
#define IDS_Guam                        14350
#define IDS_Christmas_Island            14351
#define IDS_Australian_Antarctic_Territory 14352
#define IDS_Norfolk_Island              14353
#define IDS_Brunei                      14354
#define IDS_Nauru                       14355
#define IDS_Papua_New_Guinea            14356
#define IDS_Tonga                       14357
#define IDS_Solomon_Islands             14358
#define IDS_Vanuatu                     14359
#define IDS_Fiji                        14360
#define IDS_Palau                       14361
#define IDS_Wallis_and_Futuna_Islands   14362
#define IDS_Cook_Islands                14363
#define IDS_Niue                        14364
#define IDS_American_Samoa              14365
#define IDS_Samoa                       14366
#define IDS_Kiribati                    14367
#define IDS_New_Caledonia               14368
#define IDS_Tuvalu                      14369
#define IDS_French_Polynesia            14370
#define IDS_Tokelau                     14371
#define IDS_Micronesia__Fed_States_of   14372
#define IDS_Marshall_Islands            14373
#define IDS_Russia                      14374
#define IDS_Kazakhstan                  14375
#define IDS_Kyrgyzstan                  14376
#define IDS_Tajikistan                  14377
#define IDS_Turkmenistan                14378
#define IDS_Uzbekistan                  14379
#define IDS_Japan                       14380
#define IDS_Korea__Republic_of          14381
#define IDS_Vietnam                     14382
#define IDS_Korea__North_               14383
#define IDS_Hong_Kong                   14384
#define IDS_Macau                       14385
#define IDS_Cambodia                    14386
#define IDS_Laos                        14387
#define IDS_China                       14388
#define IDS_INMARSAT__Atlantic_East_    14389
#define IDS_INMARSAT__Pacific_          14390
#define IDS_INMARSAT__Indian_           14391
#define IDS_INMARSAT__Atlantic_West_    14392
#define IDS_Bangladesh                  14393
#define IDS_Taiwan                      14394
#define IDS_Turkey                      14395
#define IDS_India                       14396
#define IDS_Pakistan                    14397
#define IDS_Afghanistan                 14398
#define IDS_Sri_Lanka                   14399
#define IDS_Myanmar                     14400
#define IDS_Maldives                    14401
#define IDS_Lebanon                     14402
#define IDS_Jordan                      14403
#define IDS_Syria                       14404
#define IDS_Iraq                        14405
#define IDS_Kuwait                      14406
#define IDS_Saudi_Arabia                14407
#define IDS_Yemen                       14408
#define IDS_Oman                        14409
#define IDS_United_Arab_Emirates        14410
#define IDS_Israel                      14411
#define IDS_Bahrain                     14412
#define IDS_Qatar                       14413
#define IDS_Bhutan                      14414
#define IDS_Mongolia                    14415
#define IDS_Nepal                       14416
#define IDS_Iran                        14417
#define IDS_Azerbaijan                  14418
#define IDS_Georgia                     14419
#define IDS_Intl_Freephone_Service      14420
#define IDS_INMARSAT                    14421
#define IDC_LB_HAL                      14800
#define IDC_BUT_LOAD_HAL                14801
#define IDC_LB_SCSI                     14820
#define IDC_BUT_LOAD_DRIVER             14821
#define IDC_CB_MENUS                    14840
#define IDC_CB_UNITS                    14841
#define IDC_CB_KEYBOARD_LAYOUT          14842
#define IDC_YES_SYSPREP_FOLDER          14860
#define IDC_NO_SYSPREP_FOLDER           14861
#define IDC_RAD_DEFAULT_IE              14900
#define IDC_RAD_AUTOCONFIG              14901
#define IDC_RAD_SPECIFY                 14902
#define IDC_BUT_CUSTOM_SETTINGS         14903
#define IDC_BUT_PROXY_SETTINGS          14904
#define IDC_BUT_BROWSER_SETTINGS        14905
#define IDC_CUSTOMIZE_TEXT              14906
#define IDC_PROXY_TEXT                  14907
#define IDC_HOMEPAGE_TEXT               14908
#define IDC_CB_USE_PROXY                14940
#define IDC_ADDRESS_TEXT                14941
#define IDC_PORT_TEXT                   14942
#define IDC_EB_ADDRESS                  14943
#define IDC_EB_PORT                     14944
#define IDC_BUT_ADVANCED                14945
#define IDC_CB_LOCAL_BYPASS_PROXY       14946
#define IDC_EDT_HTTP_PROXY              14980
#define IDC_EDT_HTTP_PROXY_PORT         14981
#define IDC_EDT_SECURE_PROXY            14982
#define IDC_EDT_SECURE_PROXY_PORT       14983
#define IDC_EDT_FTP_PROXY               14984
#define IDC_EDT_FTP_PROXY_PORT          14985
#define IDC_EDT_GOPHER_PROXY            14986
#define IDC_EDT_GOPHER_PROXY_PORT       14987
#define IDC_EDT_SOCKS_PROXY             14988
#define IDC_EDT_SOCKS_PROXY_PORT        14989
#define IDC_CB_USE_SAME_PROXY           14990
#define IDC_EB_EXCEPTIONS               14991
#define IDC_EB_HOMEPAGE                 15020
#define IDC_EB_HELPPAGE                 15021
#define IDC_EB_SEARCHPAGE               15022
#define IDC_BUT_FAVORITES               15023
#define IDC_EB_FRIENDLYNAME             15040
#define IDC_EB_URL                      15041
#define IDC_BUT_ADD                     15042
#define IDC_LV_FAVORITES                15043
#define IDC_BUT_REMOVE                  15044
#define IDS_FRIENDLY_NAME               15045
#define IDS_URL                         15046
#define IDS_OCS_ACCE                    15047
#define IDS_OCS_ACSS                    15048
#define IDS_OCS_GAME                    15049
#define IDS_OCS_INDE                    15050
#define IDS_OCS_MSNE                    15051
#define IDS_OCS_CERT                    15052
#define IDS_OCS_IISW                    15053
#define IDS_OCS_IISF                    15054
#define IDS_OCS_SMTP                    15055
#define IDS_OCS_NNTP                    15056
#define IDS_OCS_REMI                    15057
#define IDS_OCS_REST                    15058
#define IDS_OCS_TERM                    15059
#define IDS_OCS_WMSS                    15060
#define IDS_OCS_COMM                    15061
#define IDS_OCS_MULT                    15062
#define IDS_OCS_POPM                    15063
#define IDC_CB_AUTOCONFIG               15080
#define IDC_EB_AUTOCONFIG_URL           15081
#define IDC_EB_AUTOCONFIG_URL_PAC       15082
#define IDC_EB_INS_FILE                 15083
#define IDC_AUTOCONFIG_TEXT             15084
#define IDC_AUTOCONFIG_JSCRIPT_TEXT     15085
#define IDS_CPT_ACCE                    15086
#define IDS_CPT_CALC                    15087
#define IDS_CPT_CHAR                    15088
#define IDS_CPT_CLIP                    15089
#define IDS_CPT_DESK                    15090
#define IDS_CPT_TEMP                    15091
#define IDS_CPT_MOUS                    15092
#define IDS_CPT_PAIN                    15093
#define IDS_CPT_FREE                    15094
#define IDS_CPT_HEAR                    15095
#define IDS_CPT_ZONE                    15096
#define IDS_CPT_MINE                    15097
#define IDS_CPT_SOLI                    15098
#define IDS_CPT_SPID                    15099
#define IDS_CPT_INDE                    15100
#define IDS_CPT_MSNE                    15101
#define IDS_CPT_CERT                    15102
#define IDS_CPT_CERC                    15103
#define IDS_CPT_CERS                    15104
#define IDS_CPT_IISW                    15105
#define IDS_CPT_IISF                    15106
#define IDS_CPT_SMTP                    15107
#define IDS_CPT_SMTD                    15108
#define IDS_CPT_NNTP                    15109
#define IDS_CPT_NNTD                    15110
#define IDS_CPT_REMI                    15111
#define IDS_CPT_REST                    15112
#define IDS_CPT_TERM                    15113
#define IDS_CPT_WMSS                    15114
#define IDS_CPT_WASP                    15115
#define IDS_CPT_WMMC                    15116
#define IDS_CPT_WASS                    15117
#define IDS_CPT_CHAT                    15118
#define IDS_CPT_DIAL                    15119
#define IDS_CPT_HYPE                    15120
#define IDS_CPT_CDPL                    15121
#define IDS_CPT_MEDI                    15122
#define IDS_CPT_SAMP                    15123
#define IDS_CPT_UTOP                    15124
#define IDS_CPT_RECO                    15125
#define IDS_CPT_VOLU                    15126
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\rgseting.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      rgseting.c
//
// Description:
//      This file contains the dialog procedure for the regional settings
//      page (IDD_REGIONALSETTINGS).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

//
//  Explanation of the var GenSettings.szLanguageLocaleId
//
//  This var is to keep track of the locale id for the keyboard layout selected.
//  If the user ever leaves the custom dialog and comes back to it, this var
//  determines what locale to select for the keyboard layout.  I can't just use
//  they keyboard layout they selected because many locales have the same
//  keyboard layout so I wouldn't know which one to select.
//
//  static TCHAR g_szLanguageLocaleId[MAX_LANGUAGE_LEN] = _T("");

INT_PTR CALLBACK RegionalCustomDisplayDlg( IN HWND     hwnd,
                                       IN UINT     uMsg,
                                       IN WPARAM   wParam,
                                       IN LPARAM   lParam);

// *************************************************************************
//
//  Dialog proc and helper functions for the regional settings Pop-Up
//
// *************************************************************************

//----------------------------------------------------------------------------
//
// Function: OnRegionalCustomButton
//
// Purpose:  Pop-up the custom regional settings window
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnRegionalCustomButton( IN HWND hwnd ) {

    DialogBox( FixedGlobals.hInstance,
               MAKEINTRESOURCE( IDD_REGIONALSETTINGS_POPUP ),
               hwnd,
               RegionalCustomDisplayDlg );

}

//----------------------------------------------------------------------------
//
// Function: FindAndSelectInComboBox
//
// Purpose:  Searches a combo box for a particular string and selects.  If the
//           string is not found than the first item is selected.
//
// Arguments:  IN TCHAR *pString - the string to select
//             IN HWND hwnd - handle to the dialog box
//             IN INT iControlId - the resource Id of the combo box to search in
//             IN BOOL bKeyboardLayout - TRUE if this is the keyboard layout
//                    combo box, FALSE if it is not
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
FindAndSelectInComboBox( IN TCHAR *pString,
                         IN HWND hwnd,
                         IN INT iControlId )
{

    INT_PTR i;
    INT_PTR iComboBoxCount;
    LANGUAGELOCALE_NODE *pLocaleEntry;

    iComboBoxCount = SendDlgItemMessage( hwnd,
                                         iControlId,
                                         CB_GETCOUNT,
                                         0,
                                         (LPARAM) pString );

    for( i = 0; i < iComboBoxCount; i++ ) {

        pLocaleEntry = (LANGUAGELOCALE_NODE *) SendDlgItemMessage( hwnd,
                                                                   iControlId,
                                                                   CB_GETITEMDATA,
                                                                   i,
                                                                   0 );

        if( lstrcmp( pString, pLocaleEntry->szLanguageLocaleId ) == 0 )
        {

            SendDlgItemMessage( hwnd,
                                iControlId,
                                CB_SETCURSEL,
                                i,
                                0 );

            return;

        }

    }

    //
    //  If we get to this point, then no match was found so just pick the
    //  first one
    //

    AssertMsg( FALSE, "No matching string found." );

    SendDlgItemMessage( hwnd,
                        iControlId,
                        CB_SETCURSEL,
                        0,
                        0 );

}

//----------------------------------------------------------------------------
//
// Function: SelectDefaultLocale
//
// Purpose:  Selects the default locale in a combo box.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//             IN INT ControlId - the resource Id of the combo box to select
//                 the default locale in
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
SelectDefaultLocale( IN HWND hwnd, IN INT ControlId ) {

    INT_PTR i;
    INT_PTR iComboBoxCount;
    LANGUAGELOCALE_NODE *pLocale;

    iComboBoxCount = SendDlgItemMessage( hwnd,
                                         ControlId,
                                         CB_GETCOUNT,
                                         0,
                                         0 );

    for( i = 0; i < iComboBoxCount; i++ ) {

        pLocale = (LANGUAGELOCALE_NODE *) SendDlgItemMessage( hwnd,
                                                  ControlId,
                                                  CB_GETITEMDATA,
                                                  i,
                                                  0 );

        //
        //  Check and see if we found it
        //
        if( lstrcmp( g_szDefaultLocale, pLocale->szLanguageLocaleId ) == 0 ) {

            SendDlgItemMessage( hwnd,
                                ControlId,
                                CB_SETCURSEL,
                                i,
                                0 );
            break;

        }

    }

    //
    //  If for some reason we couldn't find the default just select the first one
    //
    if( i >= iComboBoxCount ) {

        AssertMsg( FALSE, "The default language locale was not found." );

        SendDlgItemMessage( hwnd,
                            ControlId,
                            CB_SETCURSEL,
                            0,
                            0 );

    }

}

//----------------------------------------------------------------------------
//
// Function: StoreLanguageLocales
//
// Purpose:  Stores the locales the user specified in to their global
//           variables.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
StoreLanguageLocales( IN HWND hwnd ) {

    INT_PTR iComboBoxIndex;
    LANGUAGELOCALE_NODE *pLocaleEntry;

    //
    //  Grab the language locale id from the Menus combo box and store
    //  it in the proper global
    //
    iComboBoxIndex = SendDlgItemMessage( hwnd,
                                         IDC_CB_MENUS,
                                         CB_GETCURSEL,
                                         0,
                                         0 );

    pLocaleEntry = (LANGUAGELOCALE_NODE *) SendDlgItemMessage( hwnd,
                                                               IDC_CB_MENUS,
                                                               CB_GETITEMDATA,
                                                               iComboBoxIndex,
                                                               0 );

    lstrcpyn( GenSettings.szMenuLanguage, pLocaleEntry->szLanguageLocaleId, AS(GenSettings.szMenuLanguage) );

    //
    //  Grab the language locale id from the Units combo box and store
    //  it in the proper global
    //
    iComboBoxIndex = SendDlgItemMessage( hwnd,
                                         IDC_CB_UNITS,
                                         CB_GETCURSEL,
                                         0,
                                         0 );

    pLocaleEntry = (LANGUAGELOCALE_NODE *) SendDlgItemMessage( hwnd,
                                                               IDC_CB_UNITS,
                                                               CB_GETITEMDATA,
                                                               iComboBoxIndex,
                                                               0 );

    lstrcpyn( GenSettings.szNumberLanguage, pLocaleEntry->szLanguageLocaleId, AS(GenSettings.szNumberLanguage) );

    //
    //  Grab the language locale id from the Keyboard layout combo box and
    //  store it in the proper global
    //
    iComboBoxIndex = SendDlgItemMessage( hwnd,
                                         IDC_CB_KEYBOARD_LAYOUT,
                                         CB_GETCURSEL,
                                         0,
                                         0 );

    pLocaleEntry = (LANGUAGELOCALE_NODE *) SendDlgItemMessage( hwnd,
                                                               IDC_CB_KEYBOARD_LAYOUT,
                                                               CB_GETITEMDATA,
                                                               iComboBoxIndex,
                                                               0 );

    lstrcpyn( GenSettings.szKeyboardLayout, pLocaleEntry->szKeyboardLayout, AS(GenSettings.szKeyboardLayout) );

    lstrcpyn( GenSettings.szLanguageLocaleId, pLocaleEntry->szLanguageLocaleId, AS(GenSettings.szLanguageLocaleId) );

}

//----------------------------------------------------------------------------
//
// Function: LoadRegionalSettingsComboBoxes
//
// Purpose:  Loads the menu, units and keybaord layout locale combo boxes
//           with the locale strings.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
LoadRegionalSettingsComboBoxes( IN HWND hwnd ) {

    INT_PTR iComboBoxIndex;
    LANGUAGELOCALE_NODE *CurrentLocale = NULL;

    //
    //  Add the valid locals to the combo boxes
    //
    for( CurrentLocale = FixedGlobals.LanguageLocaleList;
         CurrentLocale != NULL;
         CurrentLocale = CurrentLocale->next ) {

        //
        //  Add it to the System combo box
        //
        iComboBoxIndex = SendDlgItemMessage( hwnd,
                                             IDC_CB_MENUS,
                                             CB_ADDSTRING,
                                             0,
                                             (LPARAM) CurrentLocale->szLanguageLocaleName );

        //
        //  Associate the Language Locale ID with its entry in the System combo box
        //
        SendDlgItemMessage( hwnd,
                            IDC_CB_MENUS,
                            CB_SETITEMDATA,
                            iComboBoxIndex,
                            (LPARAM) CurrentLocale );

        //
        //  Add it to the User combo box
        //
        iComboBoxIndex = SendDlgItemMessage( hwnd,
                                             IDC_CB_UNITS,
                                             CB_ADDSTRING,
                                             0,
                                             (LPARAM) CurrentLocale->szLanguageLocaleName );

        //
        //  Associate the Language Locale ID with its entry in the User combo box
        //
        SendDlgItemMessage( hwnd,
                            IDC_CB_UNITS,
                            CB_SETITEMDATA,
                            iComboBoxIndex,
                            (LPARAM) CurrentLocale );

        //
        //  Add it to the Keyboard combo box
        //
        iComboBoxIndex = SendDlgItemMessage( hwnd,
                                             IDC_CB_KEYBOARD_LAYOUT,
                                             CB_ADDSTRING,
                                             0,
                                             (LPARAM) CurrentLocale->szLanguageLocaleName );

        //
        //  Associate the Language Locale ID with its entry in the Keyboard combo box
        //
        SendDlgItemMessage( hwnd,
                            IDC_CB_KEYBOARD_LAYOUT,
                            CB_SETITEMDATA,
                            iComboBoxIndex,
                            (LPARAM) CurrentLocale );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnRegionalCustomInitDialog
//
// Purpose:  Populates the locale combo boxes and selects the proper entry.
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnRegionalCustomInitDialog( IN HWND hwnd ) {

    LoadRegionalSettingsComboBoxes( hwnd );

    //
    //  Set the initial selections for each combo box
    //
    if( GenSettings.szMenuLanguage[0] != '\0' ) {

        FindAndSelectInComboBox( GenSettings.szMenuLanguage,
                                 hwnd,
                                 IDC_CB_MENUS );

    }
    else {

        //
        //  Select the default locale
        //
        SelectDefaultLocale( hwnd, IDC_CB_MENUS );

    }

    if( GenSettings.szNumberLanguage[0] != '\0' ) {

        FindAndSelectInComboBox( GenSettings.szNumberLanguage,
                                 hwnd,
                                 IDC_CB_UNITS );

    }
    else {

        //
        //  Select the default locale
        //
        SelectDefaultLocale( hwnd, IDC_CB_UNITS );

    }

    if( GenSettings.szLanguageLocaleId[0] != '\0' ) {

        FindAndSelectInComboBox( GenSettings.szLanguageLocaleId,
                                 hwnd,
                                 IDC_CB_KEYBOARD_LAYOUT );

    }
    else {

        //
        //  Select the default locale
        //
        SelectDefaultLocale( hwnd, IDC_CB_KEYBOARD_LAYOUT );

    }

}

//----------------------------------------------------------------------------
//
// Function: RegionalCustomDisplayDlg
//
// Purpose:  Dialog procedure for specify individual regional settings
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
RegionalCustomDisplayDlg( IN HWND     hwnd,
                          IN UINT     uMsg,
                          IN WPARAM   wParam,
                          IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:

            OnRegionalCustomInitDialog( hwnd );

            break;

        case WM_COMMAND: {

            int nButtonId;

            switch ( nButtonId = LOWORD (wParam ) ) {

                case IDOK:

                    StoreLanguageLocales( hwnd );

                    EndDialog( hwnd, TRUE );

                    break;

                case IDCANCEL:

                    EndDialog( hwnd, FALSE );

                    break;

            }

        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}

// *************************************************************************
//
//  Dialog proc and helper functions for the Regional Settings Wizard page
//
// *************************************************************************

//----------------------------------------------------------------------------
//
// Function: OnCustomizeCheckBox
//
// Purpose:  Greys and ungreys controls appropriately depending on if the
//           customize check box is checked or not.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnCustomizeCheckBox( IN HWND hwnd ) {

    if( IsDlgButtonChecked( hwnd, IDC_CHB_CUSTOMIZE ) ) {

        EnableWindow( GetDlgItem( hwnd, IDC_LANG_TEXT ), FALSE );
        EnableWindow( GetDlgItem( hwnd, IDC_CB_LANGUAGE_LOCALE ), FALSE );
        EnableWindow( GetDlgItem( hwnd, IDC_BUT_CUSTOM ), TRUE );

    }
    else {

        EnableWindow( GetDlgItem( hwnd, IDC_LANG_TEXT ), TRUE );
        EnableWindow( GetDlgItem( hwnd, IDC_CB_LANGUAGE_LOCALE ), TRUE );
        EnableWindow( GetDlgItem( hwnd, IDC_BUT_CUSTOM ), FALSE );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnRadioButtonRegionalSettings
//
// Purpose:  Greys and ungreys controls appropriately depending on what radio
//           button is selected
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//             IN INT  nButtonId - resource Id of the button that was clicked
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnRadioButtonRegionalSettings( IN HWND hwnd,
                               IN INT  nButtonId ) {

    if( nButtonId == IDC_RB_SPECIFY ) {

        EnableWindow( GetDlgItem( hwnd, IDC_CHB_CUSTOMIZE ), TRUE );

        OnCustomizeCheckBox( hwnd );

    }
    else {

        EnableWindow( GetDlgItem( hwnd, IDC_LANG_TEXT ), FALSE );
        EnableWindow( GetDlgItem( hwnd, IDC_CB_LANGUAGE_LOCALE ), FALSE );
        EnableWindow( GetDlgItem( hwnd, IDC_CHB_CUSTOMIZE ), FALSE );
        EnableWindow( GetDlgItem( hwnd, IDC_BUT_CUSTOM ), FALSE );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnRegionalSettingsInitDialog
//
// Purpose:  Loads the locale combo box with the locale strings and selects
//           the default entry.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnRegionalSettingsInitDialog( IN HWND hwnd ) {

    INT_PTR iComboBoxIndex;
    LANGUAGELOCALE_NODE *CurrentLocale;

    CheckRadioButton( hwnd,
                      IDC_RB_SKIP,
                      IDC_RB_SPECIFY,
                      IDC_RB_SKIP );

    //
    //  Set the initial controls that are greyed/ungreyed
    //
    OnRadioButtonRegionalSettings( hwnd, IDC_RB_USE_DEFAULT );

    //
    //  Add the language locals to the combo box
    //
    for( CurrentLocale = FixedGlobals.LanguageLocaleList;
         CurrentLocale != NULL;
         CurrentLocale = CurrentLocale->next ) {

        //
        //  Add the locale to the combo box
        //
        iComboBoxIndex = SendDlgItemMessage( hwnd,
                                             IDC_CB_LANGUAGE_LOCALE,
                                             CB_ADDSTRING,
                                             0,
                                             (LPARAM) CurrentLocale->szLanguageLocaleName );

        //
        //  Associate the Language Locale ID with its entry in the combo box
        //
        SendDlgItemMessage( hwnd,
                            IDC_CB_LANGUAGE_LOCALE,
                            CB_SETITEMDATA,
                            iComboBoxIndex,
                            (LPARAM) CurrentLocale );

    }

    //
    //  Select the default locale
    //
    SelectDefaultLocale( hwnd, IDC_CB_LANGUAGE_LOCALE );

}

//----------------------------------------------------------------------------
//
// Function: OnRegionalSettingsSetActive
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnRegionalSettingsSetActive( IN HWND hwnd )
{

    if( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED )
    {
        EnableWindow( GetDlgItem( hwnd, IDC_RB_SKIP ), FALSE );
    }
    else
    {
        EnableWindow( GetDlgItem( hwnd, IDC_RB_SKIP ), TRUE );
    }

    switch( GenSettings.iRegionalSettings ) {

        case REGIONAL_SETTINGS_SKIP:

            if( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED )
            {
                CheckRadioButton( hwnd,
                                  IDC_RB_SKIP,
                                  IDC_RB_SPECIFY,
                                  IDC_RB_USE_DEFAULT );

            }
            else
            {
                CheckRadioButton( hwnd,
                                  IDC_RB_SKIP,
                                  IDC_RB_SPECIFY,
                                  IDC_RB_SKIP );
            }

            OnRadioButtonRegionalSettings( hwnd, IDC_RB_SKIP );

            break;

        case REGIONAL_SETTINGS_NOT_SPECIFIED:
        case REGIONAL_SETTINGS_DEFAULT:

            CheckRadioButton( hwnd,
                              IDC_RB_SKIP,
                              IDC_RB_SPECIFY,
                              IDC_RB_USE_DEFAULT );

            OnRadioButtonRegionalSettings( hwnd, IDC_RB_USE_DEFAULT );

            break;

        case REGIONAL_SETTINGS_SPECIFY:

            CheckRadioButton( hwnd,
                              IDC_RB_SKIP,
                              IDC_RB_SPECIFY,
                              IDC_RB_SPECIFY );

            OnRadioButtonRegionalSettings( hwnd, IDC_RB_SPECIFY );

            if( GenSettings.bUseCustomLocales ) {

                CheckDlgButton( hwnd, IDC_CHB_CUSTOMIZE, BST_CHECKED );

                OnCustomizeCheckBox( hwnd );

            }
            else {

                FindAndSelectInComboBox( GenSettings.szLanguage,
                                         hwnd,
                                         IDC_CB_LANGUAGE_LOCALE );

                CheckDlgButton( hwnd, IDC_CHB_CUSTOMIZE, BST_UNCHECKED );

                OnCustomizeCheckBox( hwnd );

            }
            break;

        default:
            AssertMsg(FALSE, "Bad case for Regional Settings");
            break;
    }

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextRegionalSettings
//
// Purpose:  Store the radio button choice that was made and the language
//           locale, if necessary.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  BOOL
//
//----------------------------------------------------------------------------
BOOL
OnWizNextRegionalSettings( IN HWND hwnd ) {

    BOOL bResult = TRUE;

    if( IsDlgButtonChecked( hwnd, IDC_RB_SKIP ) ) {

        if( GenSettings.iUnattendMode == UMODE_FULL_UNATTENDED ) {

            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ERR_FULL_UNATTEND_REGION_SET );

            bResult = FALSE;

        }
        else {

            GenSettings.iRegionalSettings = REGIONAL_SETTINGS_SKIP;

        }

    }
    else if( IsDlgButtonChecked( hwnd, IDC_RB_USE_DEFAULT ) ) {

        GenSettings.iRegionalSettings = REGIONAL_SETTINGS_DEFAULT;

    }
    else {

        GenSettings.iRegionalSettings = REGIONAL_SETTINGS_SPECIFY;

        if( IsDlgButtonChecked( hwnd, IDC_CHB_CUSTOMIZE ) ) {

            GenSettings.bUseCustomLocales = TRUE;

        }
        else {

            INT_PTR iComboBoxIndex;
            LANGUAGELOCALE_NODE *pLocaleEntry;

            GenSettings.bUseCustomLocales = FALSE;

            //
            //  Grab the language locale
            //

            iComboBoxIndex = SendDlgItemMessage( hwnd,
                                                 IDC_CB_LANGUAGE_LOCALE,
                                                 CB_GETCURSEL,
                                                 0,
                                                 0 );

            pLocaleEntry = (LANGUAGELOCALE_NODE *) SendDlgItemMessage( hwnd,
                                                                       IDC_CB_LANGUAGE_LOCALE,
                                                                       CB_GETITEMDATA,
                                                                       iComboBoxIndex,
                                                                       0 );

            lstrcpyn( GenSettings.szLanguage,
                     pLocaleEntry->szLanguageLocaleId, AS(GenSettings.szLanguage) );


        }

    }

    return ( bResult );

}

//----------------------------------------------------------------------------
//
// Function: DlgRegionalSettingsPage
//
// Purpose:  Dialog procedure for the Regional Settings page
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgRegionalSettingsPage( IN HWND     hwnd,
                         IN UINT     uMsg,
                         IN WPARAM   wParam,
                         IN LPARAM   lParam ) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnRegionalSettingsInitDialog( hwnd );

            break;

        }

        case WM_COMMAND: {

            int nButtonId;

            switch ( nButtonId = LOWORD(wParam) ) {

                case IDC_BUT_CUSTOM:

                    if( HIWORD( wParam ) == BN_CLICKED ) {
                        OnRegionalCustomButton( hwnd );
                    }
                    break;

                case IDC_CHB_CUSTOMIZE:

                    if( HIWORD( wParam ) == BN_CLICKED ) {
                        OnCustomizeCheckBox( hwnd );
                    }
                    break;

                case IDC_RB_SKIP:
                case IDC_RB_USE_DEFAULT:
                case IDC_RB_SPECIFY:
                    if( HIWORD( wParam ) == BN_CLICKED )
                        OnRadioButtonRegionalSettings( hwnd, nButtonId );
                    break;

                default:
                    bStatus = FALSE;
                    break;
            }

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_REGN_STGS;

                    OnRegionalSettingsSetActive( hwnd );

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    break;

                }
                case PSN_WIZBACK:

                    bStatus = FALSE; 
                    break;

                case PSN_WIZNEXT: {

                    if ( !OnWizNextRegionalSettings( hwnd ) )
                        WIZ_FAIL(hwnd);
                    else
                        bStatus = FALSE;
            
                }
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:

                    break;
            }

            break;

        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\scsi.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      scsi.c
//
// Description:
//      This file contains the dialog procedure for the SCSI files.
//      (IDD_SCSI).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define MAX_SCSI_SELECTIONS  1024
#define MAX_SCSI_NAME_LEN    256

#define SCSI_FILE_EXTENSION   _T("oem")
#define ALL_FILE_EXTENSION   _T("*")

static TCHAR* StrScsiFiles;
static TCHAR* StrAllFiles;
static TCHAR g_szScsiFileFilter[MAX_PATH + 1];
static TCHAR g_szAllFileFilter[MAX_PATH + 1];

//
//  This var keeps track of the path to the txtsetup.oem
//
static TCHAR szTxtSetupOemLocation[MAX_PATH];

//
//  This var keeps track of if the user has loaded a new txtsetup.oem so we
//  know when we need to copy more files over.
//
static BOOL bHasLoadedTxtSetupOem = FALSE;

VOID LoadOriginalSettingsLowHalScsi(HWND     hwnd,
                                    LPTSTR   lpFileName,
                                    QUEUENUM dwWhichQueue);

static VOID LoadScsiFromTxtsetupOem( IN HWND  hwnd,
                                     IN TCHAR *szTxtSetupOemPath );

//----------------------------------------------------------------------------
//
// Function: OnScsiInitDialog
//
// Purpose:
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnScsiInitDialog( IN HWND hwnd )
{
    HRESULT hrPrintf;

    //
    //  Load the resource strings
    //

    StrScsiFiles = MyLoadString( IDS_SCSI_FILES );

    StrAllFiles  = MyLoadString( IDS_ALL_FILES  );

    //
    //  Build the text file filter string
    //

    //
    //  The question marks (?) are just placehoders for where the NULL char
    //  will be inserted.
    //

    hrPrintf=StringCchPrintf( g_szScsiFileFilter,AS(g_szScsiFileFilter),
               _T("%s (*.oem)?*.oem?%s (*.*)?*.*?"),
               StrScsiFiles,
               StrAllFiles );

    ConvertQuestionsToNull( g_szScsiFileFilter );

    hrPrintf=StringCchPrintf( g_szAllFileFilter, AS(g_szAllFileFilter),
               _T("%s (*.*)?*.*?"),
               StrAllFiles );

    ConvertQuestionsToNull( g_szAllFileFilter );

}

//----------------------------------------------------------------------------
//
// Function: OnScsiSetActive
//
// Purpose:
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnScsiSetActive( IN HWND hwnd ) {

    INT_PTR   i;
    INT_PTR   iListBoxCount;
    TCHAR szListBoxEntryText[MAX_STRING_LEN];

    //
    //  If we are editing a script and haven't loaded the txtsetup.oem, then
    //  populate the list box with the entries in the txtsetup.oem
    //
    if( ! WizGlobals.bNewScript && ! bHasLoadedTxtSetupOem ) {

        //
        //  The OEM files path must be valid if we are going to use it to
        //  read files.
        //
        AssertMsg( WizGlobals.OemFilesPath[0] != _T('\0'),
                   "OEM files path is blank");

        //
        //  Populate the list box with the SCSI entries in txtsetup.oem
        //

        ConcatenatePaths( szTxtSetupOemLocation,
                          WizGlobals.OemFilesPath,
                          _T("Textmode"),
                          NULL );

        LoadScsiFromTxtsetupOem( hwnd, szTxtSetupOemLocation );

        //
        //  Select those entries in the MassStorageDrivers namelist
        //

        iListBoxCount = SendDlgItemMessage( hwnd,
                                            IDC_LB_SCSI,
                                            LB_GETCOUNT,
                                            0,
                                            0 );

        //
        //  For each entry in the list box, see if its name is in the namelist
        //  and if it is, then select it.
        //
        for( i = 0; i < iListBoxCount; i++ ) {

            SendDlgItemMessage( hwnd,
                                IDC_LB_SCSI,
                                LB_GETTEXT,
                                i,
                                (LPARAM) szListBoxEntryText );

            if( FindNameInNameList( &GenSettings.MassStorageDrivers,
                                    szListBoxEntryText ) != -1 ) {

                SendDlgItemMessage( hwnd,
                                    IDC_LB_SCSI,
                                    LB_SETSEL,
                                    TRUE,
                                    i );


            }

        }

    }

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);

}

//----------------------------------------------------------------------------
//
// Function: LoadScsiFromTxtsetupOem
//
// Purpose:  Reads the txtsetup.oem in the specified parameter and load the
//           SCSI choices into the list box.
//
// Arguments: hwnd - handle to the dialog box
//            szTxtSetupOemPath - path to the txtsetup.oem
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
LoadScsiFromTxtsetupOem( IN HWND  hwnd,
                         IN TCHAR *szTxtSetupOemPath ) {

    INT_PTR   iIndex;
    BOOL  bKeepReading;
    TCHAR szTxtSetupOemPathAndFilename[MAX_PATH] = _T("");
    TCHAR szScsiDriverName[MAX_SCSI_NAME_LEN]    = _T("");
    TCHAR szScsiFriendlyName[MAX_SCSI_NAME_LEN]  = _T("");

    HINF hScsiOem;
    INFCONTEXT ScsiOemContext = { 0 };

    ConcatenatePaths( szTxtSetupOemPathAndFilename,
                      szTxtSetupOemPath,
                      OEM_TXTSETUP_NAME,
                      NULL );

    hScsiOem = SetupOpenInfFile( szTxtSetupOemPathAndFilename,
                                 NULL,
                                 INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                 NULL );

    if( hScsiOem == INVALID_HANDLE_VALUE ) {

        // ISSUE-2002/02/28-stelo- alert an error that we couldn't open the file
        return;

    }

    ScsiOemContext.Inf = hScsiOem;
    ScsiOemContext.CurrentInf = hScsiOem;

    bKeepReading = SetupFindFirstLine( hScsiOem,
                                       _T("SCSI"),
                                       NULL,
                                       &ScsiOemContext );
    //
    //  For each SCSI entry, add its friendly-name to the list box
    //

    while( bKeepReading ) {

        TCHAR *pScsiDriverName;

        SetupGetStringField( &ScsiOemContext,
                             0,
                             szScsiDriverName,
                             MAX_SCSI_NAME_LEN,
                             NULL );

        SetupGetStringField( &ScsiOemContext,
                             1,
                             szScsiFriendlyName,
                             MAX_SCSI_NAME_LEN,
                             NULL );

        //
        //  Don't allow the adding of a blank name (protection against a bad input file)
        //
        if( szScsiFriendlyName[0] != _T('\0') ) {

            iIndex = SendDlgItemMessage( hwnd,
                                         IDC_LB_SCSI,
                                         LB_ADDSTRING,
                                         0,
                                         (LPARAM) szScsiFriendlyName );

            pScsiDriverName = (TCHAR*) malloc( sizeof(szScsiDriverName) );
            if (pScsiDriverName == NULL)
                TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);

            lstrcpyn( pScsiDriverName, szScsiDriverName, AS(szScsiDriverName));

            SendDlgItemMessage( hwnd,
                                IDC_LB_SCSI,
                                LB_SETITEMDATA,
                                iIndex,
                                (LPARAM) pScsiDriverName );

        }

        //
        // move to the next line of the .oem file
        //
        bKeepReading = SetupFindNextLine( &ScsiOemContext, &ScsiOemContext );

    }

    SetupCloseInfFile( hScsiOem );

    bHasLoadedTxtSetupOem = TRUE;

}

//----------------------------------------------------------------------------
//
// Function: ClearScsiListBox
//
// Purpose:  Deallocates memory for all the elements in the SCSI list box and
//    clears it.
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
ClearScsiListBox( IN HWND hwnd ) {

    INT_PTR i;
    INT_PTR iListBoxCount;
    TCHAR *pData;

    iListBoxCount = SendDlgItemMessage( hwnd,
                                        IDC_LB_SCSI,
                                        LB_GETCOUNT,
                                        0,
                                        0 );

    for( i = 0; i < iListBoxCount; i++ ) {

        pData = (TCHAR *) SendDlgItemMessage( hwnd,
                                              IDC_LB_SCSI,
                                              LB_GETITEMDATA,
                                              i,
                                              0 );

        if( pData ) {

            free( pData );

        }

    }

    SendDlgItemMessage( hwnd,
                        IDC_LB_SCSI,
                        LB_RESETCONTENT,
                        0,
                        0 );

}

//----------------------------------------------------------------------------
//
// Function: OnBrowseLoadDriver
//
// Purpose:  Creates a browse window for the user to select an OEM driver and
//     populates the SCSI list box with the appropriate values
//
//     NOTE: the malloc call in here is arguably a bug (memory leak).  I
//     malloc the memory but never free it.  Every malloc they do will be
//     <= MAX_PATH and realistically they won't do that many.  Once they do
//     a load, if they do another load, I free the old memory (see
//     ClearScsiListBox) and allocate new memory.  So, for the last load
//     they do, the memory never gets freed. To do it right,
//     we would free the memory at the end of the program but NT does this for
//     us anyways when the process gets killed.  (so no need to free)
//
// Arguments:  HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static VOID
OnBrowseLoadDriver( IN HWND hwnd ) {

    INT   iIndex;
    BOOL  bKeepReading;
    BOOL  bFileNotFound                              = TRUE;
    TCHAR szTxtSetupOemLocationAndFilename[MAX_PATH] = _T("");
    TCHAR szScsiFriendlyName[MAX_SCSI_NAME_LEN]      = _T("");
    HINF  hScsiOem                                   = NULL;
    INFCONTEXT ScsiOemContext                        = { 0 };

    TCHAR  PathBuffer[MAX_PATH];
    INT    iRet;
    LPTSTR pFileName;

    GetCurrentDirectory( MAX_PATH, PathBuffer );

    ConcatenatePaths( szTxtSetupOemLocationAndFilename,
                      szTxtSetupOemLocation,
                      OEM_TXTSETUP_NAME,
                      NULL );

    //
    //  Keep asking for a file until we either get a txtsetup.oem or the user
    //  presses cancel.
    //
    while( bFileNotFound ) {

        iRet = ShowBrowseFolder( hwnd,
                                 g_szScsiFileFilter,
                                 SCSI_FILE_EXTENSION,
                                 OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                                 PathBuffer,
                                 szTxtSetupOemLocationAndFilename );

        if ( ! iRet )
            return;  // user pressed cancel on the dialog

        pFileName = MyGetFullPath( szTxtSetupOemLocationAndFilename );

        if( pFileName && (LSTRCMPI( pFileName, OEM_TXTSETUP_NAME ) == 0) ) {

            bFileNotFound = FALSE;  // we have found the file

        }
        else {

            // ISSUE-2002/02/28-stelo-
            /*
            ReportErrorId(hwnd,
                          MSGTYPE_ERR | MSGTYPE_WIN32,
                          ,
                          GenSettings.lpszLogoBitmap, szLogoDestination);
                          */

        }

    }

    ClearScsiListBox( hwnd );

    //
    //  Trim the file name off szTxtSetupOemLocationAndFilename so it only
    //  provides the path to the txtsetup.oem
    //
    {

        TCHAR *p = szTxtSetupOemLocationAndFilename;

        while( p != pFileName )
        {
            p++;
        }

        *p = _T('\0');

    }

    lstrcpyn( szTxtSetupOemLocation, szTxtSetupOemLocationAndFilename, AS(szTxtSetupOemLocation) );

    //
    //  Read in from the file OEM file they specified in the browse box and
    //  add the friendly-name entries to the list box
    //

    LoadScsiFromTxtsetupOem( hwnd, szTxtSetupOemLocation );

}

//----------------------------------------------------------------------------
//
// Function: CopyFileToDistShare
//
// Purpose:  Given a path and file name to one file, it copies that file to
//    the given destination path.  If the file already exists on the
//    destination, then do not make the copy.  If the source file name does
//    not exist then Browse for it.
//
// Arguments:
//     HWND hwnd - handle to the dialog box
//     LPTSTR szSrcPath - path file to copy
//     LPTSTR szSrcFileName - filename to copy
//     LPTSTR szDestPath - path of where file is to be copied
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
CopyFileToDistShare( IN HWND hwnd,
                     IN LPTSTR szSrcPath,
                     IN LPTSTR szSrcFileName,
                     IN LPTSTR szDestPath ) {

    INT   iRet;
    TCHAR szSrcPathAndName[MAX_PATH]  = _T("");
    TCHAR szDestPathAndName[MAX_PATH] = _T("");

    ConcatenatePaths( szSrcPathAndName,
                      szSrcPath,
                      szSrcFileName,
                      NULL );

    ConcatenatePaths( szDestPathAndName,
                      szDestPath,
                      szSrcFileName,
                      NULL );

    if( ! DoesFileExist( szSrcPathAndName ) )
    {

        TCHAR* pFileName;
        BOOL   bFileFound = FALSE;

        do
        {

            ReportErrorId( hwnd,
                           MSGTYPE_ERR,
                           IDS_ERR_SPECIFY_FILE,
                           szSrcFileName );

            iRet = ShowBrowseFolder( hwnd,
                                     g_szAllFileFilter,
                                     ALL_FILE_EXTENSION,
                                     OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                                     szSrcPath,
                                     szSrcPathAndName );

            // ISSUE-2002/02/28-stelo- if they press cancel should I warn them that they have to
            //  copy the file manually?
            if ( ! iRet )
                return;  // user pressed cancel on the dialog

            pFileName = MyGetFullPath( szSrcPathAndName );

            if( pFileName && ( lstrcmpi( pFileName, szSrcFileName ) == 0 ) ) {

                bFileFound = TRUE;  // we have found the file

            }

        } while( ! bFileFound );

    }

    CopyFile( szSrcPathAndName, szDestPathAndName, TRUE );

    SetFileAttributes( szDestPathAndName, FILE_ATTRIBUTE_NORMAL );

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextScsi
//
// Purpose:  For every selection in the SCSI list box, copy the files over to
//    the distribution share and stores the driver and filenames so they can
//    be written out.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnWizNextScsi( IN HWND hwnd ) {

    INT_PTR    i;
    INT_PTR    iNumberSelected;
    BOOL   bKeepReading;
    UINT   rgiScsiSelections[MAX_SCSI_SELECTIONS];
    TCHAR *pDriverName;
    TCHAR  szDriverSectionName[MAX_INILINE_LEN];
    TCHAR  szScsiDriverName[MAX_SCSI_NAME_LEN];
    TCHAR  szTextmodePath[MAX_PATH]       = _T("");
    TCHAR  szOemFilePathAndName[MAX_PATH] = _T("");

    HINF hScsiOem;
    INFCONTEXT ScsiOemContext = { 0 };

    //
    //  If they never loaded a txtsetup.oem, then there is no work to do
    //
    if( bHasLoadedTxtSetupOem == FALSE ) {
        return;
    }

    iNumberSelected = SendDlgItemMessage( hwnd,
                                          IDC_LB_SCSI,
                                          LB_GETSELITEMS,
                                          MAX_SCSI_SELECTIONS,
                                          (LPARAM) rgiScsiSelections );

    //
    //  Prepare to add the new drivers
    //
    ResetNameList( &GenSettings.MassStorageDrivers );

    ConcatenatePaths( szTextmodePath,
                      WizGlobals.OemFilesPath,
                      _T("Textmode"),
                      NULL );

    if ( ! EnsureDirExists( szTextmodePath ) )
    {
        ReportErrorId( hwnd,
                       MSGTYPE_ERR | MSGTYPE_WIN32,
                       IDS_ERR_CREATE_FOLDER,
                       szTextmodePath );

        return;
    }

    ConcatenatePaths( szOemFilePathAndName,
                      szTxtSetupOemLocation,
                      OEM_TXTSETUP_NAME,
                      NULL );

    //
    //  Read the txtsetup.oem file into the txtsetup queue
    //

    LoadOriginalSettingsLowHalScsi(hwnd,
                                   szOemFilePathAndName,
                                   SETTING_QUEUE_TXTSETUP_OEM);

    hScsiOem = SetupOpenInfFile( szOemFilePathAndName,
                                 NULL,
                                 INF_STYLE_OLDNT | INF_STYLE_WIN4,
                                 NULL );

    if( hScsiOem == INVALID_HANDLE_VALUE ) {

        // ISSUE-2002/02/28-stelo- need to somehow alert an error
        return;

    }

    for( i = 0; i < iNumberSelected; i++ ) {

        SendDlgItemMessage( hwnd,
                            IDC_LB_SCSI,
                            LB_GETTEXT,
                            rgiScsiSelections[i],
                            (LPARAM) szScsiDriverName );

        AddNameToNameList( &GenSettings.MassStorageDrivers,
                           szScsiDriverName );

        ScsiOemContext.Inf = hScsiOem;
        ScsiOemContext.CurrentInf = hScsiOem;

        pDriverName = (TCHAR *) SendDlgItemMessage( hwnd,
                                                    IDC_LB_SCSI,
                                                    LB_GETITEMDATA,
                                                    rgiScsiSelections[i],
                                                    0 );

        //
        //  Build up the section name
        //
        lstrcpyn( szDriverSectionName, _T("Files.SCSI."), AS(szDriverSectionName));

        lstrcatn( szDriverSectionName, pDriverName, MAX_INILINE_LEN );

        bKeepReading = SetupFindFirstLine( hScsiOem,
                                           szDriverSectionName,
                                           NULL,
                                           &ScsiOemContext );
        //
        //  For the [File.SCSI.x] entry, add its filenames to the OemScsiFiles
        //  namelist and copy the files to the $oem$ dir
        //

        while( bKeepReading ) {

            SetupGetStringField( &ScsiOemContext,
                                 2,
                                 szScsiDriverName,
                                 MAX_SCSI_NAME_LEN,
                                 NULL );

            //
            //  Don't allow the adding of a blank name (protection against a bad
            //  input file)
            //
            if( szScsiDriverName[0] != _T('\0') ) {

                //
                //  Only copy the file if we haven't copied it already, this
                //  could happen if 2 friendly-name drivers are selected and they
                //  both use the same file.
                //
                if( FindNameInNameList( &GenSettings.OemScsiFiles,
                                         szScsiDriverName ) == NOT_FOUND ) {

                    AddNameToNameList( &GenSettings.OemScsiFiles,
                                       szScsiDriverName );

                    CopyFileToDistShare( hwnd,
                                         szTxtSetupOemLocation,
                                         szScsiDriverName,
                                         szTextmodePath );

                }

            }

            //
            // move to the next line of the .oem file
            //
            bKeepReading = SetupFindNextLine( &ScsiOemContext, &ScsiOemContext );

        }

    }

    SetupCloseInfFile( hScsiOem );

}

//----------------------------------------------------------------------------
//
// Function: DlgScsiPage
//
// Purpose:  Dialog procedure for the SCSI driver page (Mass Storage devices).
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgScsiPage( IN HWND     hwnd,
             IN UINT     uMsg,
             IN WPARAM   wParam,
             IN LPARAM   lParam )
{

    BOOL bStatus = TRUE;

    switch( uMsg )
    {

        case WM_INITDIALOG:
        {
            OnScsiInitDialog( hwnd );

            break;
        }

        case WM_COMMAND: {

            switch ( LOWORD(wParam) )
            {

                case IDC_BUT_LOAD_DRIVER:

                    if ( HIWORD(wParam) == BN_CLICKED )
                        OnBrowseLoadDriver( hwnd );

                    break;

                default:

                    bStatus = FALSE;
                    break;

            }

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    CancelTheWizard(hwnd); break;

                case PSN_SETACTIVE: {

                    OnScsiSetActive( hwnd );

                    break;

                }
                case PSN_WIZBACK:

                    break;

                case PSN_WIZNEXT:

                    OnWizNextScsi( hwnd );

                    break;

                default:

                    break;
            }

            break;

        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\lang.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      lang.c
//
// Description:
//      This file contains the dialog procedure for language settings page.
//      (IDD_LANGUAGE_SETTINGS)
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define MAX_SELECTIONS  20

//
//  This variable determines whether the user just moved here from another
//  page or has remained on this page
//
static bHasMovedOffThisPage = TRUE;

//----------------------------------------------------------------------------
//
// Function: GetLangGroupFromLocale
//
// Purpose:  Takes a locale string Id and finds the language group node that
//           corresponds to that locale.
//
// Arguments:  IN LPTSTR lpLocaleId- the locale Id to find the language
//                group of
//
// Returns:  LANGUAGEGROUP_NODE* - language group node the locale corresponds to
//
//----------------------------------------------------------------------------
LANGUAGEGROUP_NODE*
GetLangGroupFromLocale( IN LPTSTR lpLocaleId ) {

    LANGUAGELOCALE_NODE *CurrentLocale;

    //
    //  Sweep through the local list until the locale is found and return
    //  the language group
    //
    for( CurrentLocale = FixedGlobals.LanguageLocaleList;
         CurrentLocale != NULL;
         CurrentLocale = CurrentLocale->next )
    {

        if( lstrcmp( lpLocaleId, CurrentLocale->szLanguageLocaleId ) == 0 )
        {

            return( CurrentLocale->pLanguageGroup );

        }

    }

    //
    //  If we get to here, then the locale was not found
    //
    AssertMsg( FALSE, "The locale was not found." );

    //
    //  return the first language group so there is at least something to return
    //
    return( FixedGlobals.LanguageLocaleList->pLanguageGroup );

}

//----------------------------------------------------------------------------
//
// Function: GetLangGroupFromKeyboardLayout
//
// Purpose:  Takes a keyboard layout string Id and finds the language group
//           node that corresponds to that keyboard layout.
//
// Arguments:  IN LPTSTR lpKeyboardLayoutId- the keyboard layout Id to find
//                the language group of
//
// Returns:  LANGUAGEGROUP_NODE* - language group node the keyboard layout
//                                 corresponds to
//
//----------------------------------------------------------------------------
LANGUAGEGROUP_NODE*
GetLangGroupFromKeyboardLayout( IN LPTSTR lpKeyboardLayoutId )
{

    return( GetLangGroupFromLocale( lpKeyboardLayoutId ) );

}

//----------------------------------------------------------------------------
//
// Function: AddLocalesLangGroup
//
// Purpose:  Takes the a locale and finds its corresponding language group
//           and adds it to the language group list.
//
// Arguments: IN LPTSTR pLocale - the locale to find and add the language
//               group of
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
AddLocalesLangGroup( IN LPTSTR pLocale ) {

    LANGUAGEGROUP_NODE *pLangGroup;

    pLangGroup = GetLangGroupFromLocale( pLocale );

    AddNameToNameListNoDuplicates( &GenSettings.LanguageGroups,
                                   pLangGroup->szLanguageGroupId );

    AddNameToNameListNoDuplicates( &GenSettings.LanguageFilePaths,
                                   pLangGroup->szLangFilePath );

}

//----------------------------------------------------------------------------
//
// Function: AddKeyboardLocaleLangGroup
//
// Purpose:  Takes the a keyboard layoutand finds its corresponding language
//           group and adds it to the language group list.
//
// Arguments: IN LPTSTR pLocale - the locale to find and add the language
//               group of
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
AddKeyboardLocaleLangGroup( IN LPTSTR pKeyboardLocale )
{

    LANGUAGEGROUP_NODE *pLangGroup;

    pLangGroup = GetLangGroupFromKeyboardLayout( pKeyboardLocale );

    AddNameToNameListNoDuplicates( &GenSettings.LanguageGroups,
                                   pLangGroup->szLanguageGroupId );

    AddNameToNameListNoDuplicates( &GenSettings.LanguageFilePaths,
                                   pLangGroup->szLangFilePath );

}

//----------------------------------------------------------------------------
//
// Function: OnLanguageSettingsInitDialog
//
// Purpose:  Fills the Language Group box with the languages.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLanguageSettingsInitDialog( IN HWND hwnd ) {

    INT_PTR iListBoxIndex;
    LANGUAGEGROUP_NODE *pLangEntry;

    //
    //  Fill the list box with the data from the Language Group list
    //

    for( pLangEntry = FixedGlobals.LanguageGroupList;
         pLangEntry != NULL;
         pLangEntry = pLangEntry->next ) {

        //
        //  Add language group to the list box
        //
        iListBoxIndex = SendDlgItemMessage( hwnd,
                                            IDC_LANGUAGES,
                                            LB_ADDSTRING,
                                            0,
                                            (LPARAM) pLangEntry->szLanguageGroupName );
        //
        //  Associate the Language Group struct with its entry in the list box
        //
        SendDlgItemMessage( hwnd,
                            IDC_LANGUAGES,
                            LB_SETITEMDATA,
                            iListBoxIndex,
                            (LPARAM) pLangEntry );

    }

}

//----------------------------------------------------------------------------
//
// Function: OnLanguageSettingsSetActive
//
// Purpose:  If they just moved here from another page, it makes sure for the
//           locales they have selected that there corresponding language
//           groups are selected.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnLanguageSettingsSetActive( IN HWND hwnd ) {

    INT i;
    INT_PTR iListBoxCount;
    BOOL bIsAnAdditionLangGroup;
    BOOL bIsAnUserChosenLangGroup;
    LANGUAGEGROUP_NODE *pLangEntry;

    //
    //  The variable AdditionalLangGroups holds those language groups that need
    //  to be installed because the user has already picked a locale that needs
    //  it.  We need to force those Language groups to automatically be
    //  installed so we auto-select them.
    //

    NAMELIST AdditionalLangGroups = { 0 };

    //
    //  Make sure language groups are selected for the locals they chose on the
    //  regional settings page but only do this if they moved from another page
    //  onto this page.  If this is just another SetActive message but they
    //  haven't left the page then do nothing.
    //
    if( bHasMovedOffThisPage )
    {

        bHasMovedOffThisPage = FALSE;

        //
        //  Find out what language groups we have to install
        //
        if( GenSettings.iRegionalSettings == REGIONAL_SETTINGS_SPECIFY )
        {

            if( GenSettings.bUseCustomLocales )
            {

                pLangEntry = GetLangGroupFromLocale( GenSettings.szMenuLanguage );

                AddNameToNameListNoDuplicates( &AdditionalLangGroups,
                                               pLangEntry->szLanguageGroupId );

                pLangEntry = GetLangGroupFromLocale( GenSettings.szNumberLanguage );

                AddNameToNameListNoDuplicates( &AdditionalLangGroups,
                                               pLangEntry->szLanguageGroupId );

                pLangEntry = GetLangGroupFromKeyboardLayout( GenSettings.szLanguageLocaleId );

                AddNameToNameListNoDuplicates( &AdditionalLangGroups,
                                               pLangEntry->szLanguageGroupId );

            }
            else
            {

                pLangEntry = GetLangGroupFromLocale( GenSettings.szLanguage );

                AddNameToNameListNoDuplicates( &AdditionalLangGroups,
                                               pLangEntry->szLanguageGroupId );

            }

        }

        //
        //  Select the language groups in the AdditionalLangGroups list
        //
        iListBoxCount = SendDlgItemMessage( hwnd,
                                            IDC_LANGUAGES,
                                            LB_GETCOUNT,
                                            0,
                                            0 );

        for( i = 0; i < iListBoxCount; i++ )
        {

            pLangEntry = (LANGUAGEGROUP_NODE *) SendDlgItemMessage( hwnd,
                                                                    IDC_LANGUAGES,
                                                                    LB_GETITEMDATA,
                                                                    i,
                                                                    0 );

            if( FindNameInNameList( &GenSettings.LanguageGroups,
                                    pLangEntry->szLanguageGroupId ) != -1 )
            {
                bIsAnUserChosenLangGroup = TRUE;
            }
            else
            {
                bIsAnUserChosenLangGroup = FALSE;
            }

            if( FindNameInNameList( &AdditionalLangGroups,
                                    pLangEntry->szLanguageGroupId ) != -1 )
            {
                bIsAnAdditionLangGroup = TRUE;
            }
            else {
                bIsAnAdditionLangGroup = FALSE;
            }

            if( bIsAnUserChosenLangGroup || bIsAnAdditionLangGroup )
            {

                SendDlgItemMessage( hwnd,
                                    IDC_LANGUAGES,
                                    LB_SETSEL,
                                    TRUE,
                                    i );

            }

        }

    }

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextLanguageSettings
//
// Purpose:  Stores the language groups that are selected.  Also, stores the
//           the language groups that are not selected but are needed by one
//           of the locales they chose.
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnWizNextLanguageSettings( IN HWND hwnd ) {

    INT_PTR  i;
    INT_PTR  iNumberSelected;
    UINT rgiCurrentSelections[MAX_SELECTIONS];
    LANGUAGEGROUP_NODE *pLangGroupEntry;

    // ISSUE-2002/02/28-stelo- going to have to force whatever locale choices they made on the
    // previous page for the those language groups to automatically get
    // installed

    iNumberSelected = SendDlgItemMessage( hwnd,
                                          IDC_LANGUAGES,
                                          LB_GETSELITEMS,
                                          MAX_SELECTIONS,
                                          (LPARAM) rgiCurrentSelections );

    ResetNameList( &GenSettings.LanguageGroups );
    ResetNameList( &GenSettings.LanguageFilePaths );

    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP ) {
        //
        //  Set this to true so we know to write out the key to specify the path
        //  to the language files
        //
        GenSettings.bSysprepLangFilesCopied = TRUE;
    }

    for( i = 0; i < iNumberSelected; i++ ) {

        pLangGroupEntry = (LANGUAGEGROUP_NODE *) SendDlgItemMessage( hwnd,
                                                     IDC_LANGUAGES,
                                                     LB_GETITEMDATA,
                                                     rgiCurrentSelections[i],
                                                     0 );

        //
        //  store the language group ID in the namelist
        //
        AddNameToNameList( &GenSettings.LanguageGroups,
                           pLangGroupEntry->szLanguageGroupId );

        //
        //  store the path to the language files
        //
        AddNameToNameList( &GenSettings.LanguageFilePaths,
                           pLangGroupEntry->szLangFilePath );

    }

    //
    //  Force whatever language groups to be installed that are needed for the
    //  locales they chose
    //
    if( GenSettings.iRegionalSettings == REGIONAL_SETTINGS_SPECIFY ) {

        if( GenSettings.bUseCustomLocales ) {

            AddLocalesLangGroup( GenSettings.szMenuLanguage );

            AddLocalesLangGroup( GenSettings.szNumberLanguage );

            AddKeyboardLocaleLangGroup( GenSettings.szLanguageLocaleId );

        }
        else {

            AddLocalesLangGroup( GenSettings.szLanguage );

        }

    }

}

//----------------------------------------------------------------------------
//
// Function: DlgLangSettingsPage
//
// Purpose:  Dialog procedure for the Language Settings page
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgLangSettingsPage( IN HWND     hwnd,
                     IN UINT     uMsg,
                     IN WPARAM   wParam,
                     IN LPARAM   lParam ) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG:
        {
            OnLanguageSettingsInitDialog( hwnd );

            break;
        }

        case WM_NOTIFY:
        {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code )
            {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE:
                {
                    g_App.dwCurrentHelp = IDH_LANGS;

                    OnLanguageSettingsSetActive( hwnd );

                    break;

                }
                case PSN_WIZBACK:

                    bHasMovedOffThisPage = TRUE;

                    bStatus = FALSE; 
                    break;

                case PSN_WIZNEXT:
                {

                    OnWizNextLanguageSettings( hwnd );

                    bStatus = FALSE;
                    break;

                }

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:

                    break;
            }

            break;

        }

        default:
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\oemads.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      oemads.c
//
// Description:
//      This is the dialog proc for the OEM Ads page.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

const TCHAR TEXT_EXTENSION[]   = _T("bmp");

static TCHAR *StrBitmapFiles;
static TCHAR *StrAllFiles;
static TCHAR g_szTextFileFilter[MAX_PATH + 1];

//---------------------------------------------------------------------------
//
//  Function: OnOemAdsInitDialog
//
//  Purpose: 
//
//  Arguments:  IN HWND hwnd - handle to the dialog
//
//  Returns:  VOID  
//
//---------------------------------------------------------------------------
static VOID
OnOemAdsInitDialog( IN HWND hwnd )
{
    HRESULT hrPrintf;

    //
    //  Load the resource strings
    //

    StrBitmapFiles = MyLoadString( IDS_BITMAP_FILES );

    StrAllFiles  = MyLoadString( IDS_ALL_FILES  );

    //
    //  Build the text file filter string
    //

    //
    //  The question marks (?) are just placehoders for where the NULL char
    //  will be inserted.
    //

    hrPrintf=StringCchPrintf( g_szTextFileFilter, AS(g_szTextFileFilter),
               _T("%s(*.bmp)?*.bmp?%s(*.*)?*.*?"),
               StrBitmapFiles,
               StrAllFiles );

    ConvertQuestionsToNull( g_szTextFileFilter );

}

//---------------------------------------------------------------------------
//
//  Function: OnSetActiveOemAds
//
//  Purpose: 
//
//  Arguments:  IN HWND hwnd - handle to the dialog
//
//  Returns:  VOID  
//
//---------------------------------------------------------------------------
static VOID
OnSetActiveOemAds( IN HWND hwnd)
{

    //
    //  Set the window text for Logo Bitmap and Background Bitmap
    //
    SendDlgItemMessage(hwnd,
                       IDC_LOGOBITMAP,
                       WM_SETTEXT,
                       (WPARAM) MAX_PATH,
                       (LPARAM) GenSettings.lpszLogoBitmap);

    SendDlgItemMessage(hwnd,
                       IDC_BACKGROUNDBITMAP,
                       WM_SETTEXT,
                       (WPARAM) MAX_PATH,
                       (LPARAM) GenSettings.lpszBackgroundBitmap);

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
// Function: OnBrowseLoadBitmap
//
// Purpose: Creates a browse window for the user to select a bitmap and
//   stores the path in the appropriate string (logo or background)
//
//----------------------------------------------------------------------------
VOID
OnBrowseLoadBitmap( IN HWND hwnd, IN WORD wControlID ) {

    TCHAR szBitmapString[MAX_PATH] = _T("");

    OPENFILENAME ofn;
    DWORD  dwFlags;
    TCHAR  PathBuffer[MAX_PATH];
    INT    iRet;

    dwFlags = OFN_HIDEREADONLY  |
              OFN_PATHMUSTEXIST;

    GetCurrentDirectory(MAX_PATH, PathBuffer);

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = g_szTextFileFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0L;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szBitmapString;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = PathBuffer;
    ofn.lpstrTitle        = NULL;
    ofn.Flags             = dwFlags;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = TEXT_EXTENSION;

    iRet = GetOpenFileName(&ofn);

    if ( ! iRet )
        return;  // user pressed cancel on the dialog

    //
    //  Now that we have the bitmap, store it in the proper string and fill
    //  the appropriate edit field
    //

    if( wControlID == IDC_LOGOBITMAP ) {

        SendDlgItemMessage(hwnd,
                           IDC_LOGOBITMAP,
                           WM_SETTEXT,
                           (WPARAM) MAX_PATH,
                           (LPARAM) szBitmapString);

    }
    else {

        SendDlgItemMessage(hwnd,
                           IDC_BACKGROUNDBITMAP,
                           WM_SETTEXT,
                           (WPARAM) MAX_PATH,
                           (LPARAM) szBitmapString);

    }

}

//----------------------------------------------------------------------------
//
//  Function: OnWizNextOemAds
//
//  Purpose: Called when the Next button is pushed.  Copies the bitmaps, if
//    any chosen to the distribution share
//
//----------------------------------------------------------------------------
BOOL OnWizNextOemAds( IN HWND hwnd ) {

    TCHAR szLogoDestination[MAX_PATH + 1]       = _T("");
    TCHAR szBackgroundDestination[MAX_PATH + 1] = _T("");
    TCHAR szBitmapDestPath[MAX_PATH + 1]        = _T("");
    TCHAR szBackSlash[] = _T("\\");
    BOOL  bStayHere = FALSE;

    DWORD dwReturnValue;

    //
    // If OemFilesPath doesn't have a value, give it one.
    //

    if ( WizGlobals.OemFilesPath[0] == _T('\0') ) {

        ConcatenatePaths( WizGlobals.OemFilesPath,
                          WizGlobals.DistFolder,
                          _T("$oem$"),
                          NULL );
    }

    //
    // Force creation of the $oem$ dir (if it doesn't exist already)
    //

    if ( ! EnsureDirExists(WizGlobals.OemFilesPath) ) {
        ReportErrorId(hwnd,
                      MSGTYPE_ERR | MSGTYPE_WIN32,
                      IDS_ERR_CREATE_FOLDER,
                      WizGlobals.OemFilesPath);
    }

    //
    //  Fill the global structs with the edit box data
    //
    SendDlgItemMessage(hwnd,
                       IDC_LOGOBITMAP,
                       WM_GETTEXT,
                       (WPARAM) MAX_PATH,
                       (LPARAM) GenSettings.lpszLogoBitmap);

    SendDlgItemMessage(hwnd,
                       IDC_BACKGROUNDBITMAP,
                       WM_GETTEXT,
                       (WPARAM) MAX_PATH,
                       (LPARAM) GenSettings.lpszBackgroundBitmap);

    //
    //  Set the path where the bitmaps are to be copied to
    //     On a sysprep they go into the sysprep dir
    //     On a regular install they go to the $OEM$ dir
    //
    
    if( WizGlobals.iProductInstall == PRODUCT_SYSPREP )
    {

        ExpandEnvironmentStrings( _T("%SystemDrive%"), 
                                  szBitmapDestPath, 
                                  MAX_PATH );

        lstrcatn( szBitmapDestPath, _T("\\sysprep"), MAX_PATH );

    }
    else
    {
        lstrcpyn( szBitmapDestPath, WizGlobals.OemFilesPath, MAX_PATH + 1 );
    }


    if( GenSettings.lpszLogoBitmap[0] != _T('\0') ) {

        //
        //  Build up the destination path
        //
        ConcatenatePaths( szLogoDestination,
                          szBitmapDestPath,
                          MyGetFullPath( GenSettings.lpszLogoBitmap ),
                          NULL );

        if( ! DoesFileExist( szLogoDestination ) ) {

            if ( ! CopyFile(GenSettings.lpszLogoBitmap, szLogoDestination, TRUE) ) {

                ReportErrorId(hwnd,
                              MSGTYPE_ERR | MSGTYPE_WIN32,
                              IDS_ERR_COPY_FILE,
                              GenSettings.lpszLogoBitmap, szLogoDestination);

                bStayHere = TRUE;

            }

        }

    }

    if( GenSettings.lpszBackgroundBitmap[0] != _T('\0') ) {

        //
        //  Build up the destination path
        //
        ConcatenatePaths( szBackgroundDestination,
                          szBitmapDestPath,
                          MyGetFullPath( GenSettings.lpszBackgroundBitmap ),
                          NULL);

        if( ! DoesFileExist( szBackgroundDestination ) ) {

            if ( ! CopyFile( GenSettings.lpszBackgroundBitmap, 
                             szBackgroundDestination,
                             TRUE ) ) {

                ReportErrorId(hwnd,
                              MSGTYPE_ERR | MSGTYPE_WIN32,
                              IDS_ERR_COPY_FILE,
                              GenSettings.lpszBackgroundBitmap,
                              szBackgroundDestination);

                bStayHere = TRUE;

            }

        }

    }

    //
    // Route the wizard
    //
    return (!bStayHere );
}

//----------------------------------------------------------------------------
//
// Function: DlgOemAdsPage
//
// Purpose: This is the dialog procedure for the OEM Ads page.
//
//----------------------------------------------------------------------------

INT_PTR CALLBACK DlgOemAdsPage(
    IN HWND     hwnd,    
    IN UINT     uMsg,        
    IN WPARAM   wParam,    
    IN LPARAM   lParam)
{   

    BOOL bStatus = TRUE;

    switch (uMsg) {

        case WM_INITDIALOG:
            OnOemAdsInitDialog( hwnd );
            break;

        case WM_COMMAND:

            switch ( LOWORD(wParam) ) {

                case IDC_LOGOBITMAPBROWSE:

                    if ( HIWORD(wParam) == BN_CLICKED )
                        OnBrowseLoadBitmap( hwnd, IDC_LOGOBITMAP );

                    break;

                case IDC_BACKGROUNDBITMAPBROWSE:

                    if ( HIWORD(wParam) == BN_CLICKED )
                        OnBrowseLoadBitmap( hwnd, IDC_BACKGROUNDBITMAP );

                    break;

                default:

                    bStatus = FALSE;
                    break;

            }
            break;                

        case WM_NOTIFY:
            {
                LPNMHDR pnmh = (LPNMHDR)lParam;
                switch( pnmh->code ) {

                    case PSN_QUERYCANCEL:

                        CancelTheWizard( hwnd );

                        break;

                    case PSN_SETACTIVE:

                        OnSetActiveOemAds( hwnd );

                        break;

                    case PSN_WIZBACK:
                        break;

                    case PSN_WIZNEXT:

                        if ( !OnWizNextOemAds( hwnd ))
                            WIZ_FAIL(hwnd);

                        break;

                    default:
                        bStatus = FALSE;
                        break;
                }
            }
            break;

        default:
            bStatus = FALSE;
            break;
    }
    return bStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\optcomp.c ===
/****************************************************************************\

    OPTCOMP.C / Setup Manager

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001-2002
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Optional Component" wizard page.
        
    01/2002 - Stephen Lodwick (STELO)
        Initial creation

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"
#include "optcomp.h"

//
// Internal Defined Value(s):
//

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void SaveData(HWND);
static void OnListViewNotify(HWND, UINT, WPARAM, NMLVDISPINFO*);

//
// External Function(s):
//
INT_PTR CALLBACK OptionalCompDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        
        case WM_NOTIFY:

            switch ( wParam )
            {
                case IDC_OPTCOMP:

                // Notification to list view, lets handle below
                //
                OnListViewNotify(hwnd, uMsg, wParam, (NMLVDISPINFO*) lParam);    
                break;
                
                default:

                    switch ( ((NMHDR FAR *) lParam)->code )
                    {
                        case PSN_KILLACTIVE:
                        case PSN_RESET:
                        case PSN_WIZBACK:
                        case PSN_WIZFINISH:

                            break;

                        case PSN_WIZNEXT:

                            SaveData(hwnd);
                            break;

                        case PSN_QUERYCANCEL:

                            WIZ_CANCEL(hwnd);
                            break;

                        case PSN_HELP:

                            WIZ_HELP();
                            break;

                        case PSN_SETACTIVE:

                            WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
                            break;
                    }

                    break;
            }

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//
static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    LVITEM      lvItem;
    LPTSTR      lpItemText = NULL;
    LVCOLUMN    lvCol;
    DWORD       dwPosition = ListView_GetItemCount( GetDlgItem(hwnd, IDC_OPTCOMP) );
    RECT        rect;
    INT         index;
    DWORD64     dwComponents;
    HWND        lvHandle        = GetDlgItem(hwnd, IDC_OPTCOMP);

    // Add check boxes to each of the items
    //
    ListView_SetExtendedListViewStyle(lvHandle, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    // Believe it or not we must add the column (even though it's hidden)
    //
    GetClientRect( lvHandle, &rect );
    
    lvCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvCol.fmt  = LVCFMT_LEFT;
    lvCol.cx   = rect.right;

    ListView_InsertColumn(lvHandle, 0, &lvCol);
    ListView_SetColumnWidth(lvHandle, 0, rect.right);

    // Go through all of the known components and add them to the list box
    //
    for (index=0;index<AS(s_cgComponentNames);index++)
    {
        // Is this platform allowed to have this component
        //
        if ( s_cgComponentNames[index].dwValidSkus & WizGlobals.iPlatform)
        {
            DWORD dwItem = ListView_GetItemCount(lvHandle);
            BOOL  bReturn = FALSE;

            // We are allowed to add this string
            //
            lpItemText = AllocateString(NULL, s_cgComponentNames[index].uId);

            ZeroMemory(&lvItem, sizeof(LVITEM));
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.state = 0;
            lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
            lvItem.iItem = dwItem;
            lvItem.lParam = s_cgComponentNames[index].dwComponentsIndex;
            lvItem.iSubItem = 0;
            lvItem.pszText = lpItemText;

            ListView_InsertItem(lvHandle, &lvItem);

            // Determine if all of the necessary components are installed
            //
            bReturn = ((GenSettings.dwWindowsComponents & s_cgComponentNames[index].dwComponents) == s_cgComponentNames[index].dwComponents) ? TRUE : FALSE;

            // Check the item depending on the default value set in the platform page
            //
            ListView_SetCheckState(lvHandle, dwItem, bReturn)


            FREE(lpItemText);
        }

    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void SaveData(HWND hwnd)
{
    DWORD   dwItemCount     = 0,
            dwIndex         = 0;
    HWND    lvHandle        = GetDlgItem(hwnd, IDC_OPTCOMP);
    BOOL    bChecked        = FALSE;
    LVITEM  lvItem;
    DWORD64 dwComponents    = 0;
    BOOL    bAddComponent   = FALSE;

    // Check to make sure we have a valid handle and that there's atleast one item in the list
    //
    if ( ( lvHandle ) &&
         (dwItemCount = ListView_GetItemCount(lvHandle))
       )
    {
        // Zero this out as we're going to rescan the components to install
        //
        GenSettings.dwWindowsComponents = 0;

        // Iterate through each of the items in the list
        //
        for (dwIndex=0;dwIndex < dwItemCount;dwIndex++)
        {
            ZeroMemory(&lvItem, sizeof(LVITEM));
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = dwIndex;
            lvItem.iSubItem = 0;
            ListView_GetItem(lvHandle, &lvItem);

            // Determine if this is a component group to install
            //
            if ( ListView_GetCheckState(lvHandle, dwIndex) )
            {
                // We would like to install this component group
                //
                GenSettings.dwWindowsComponents |= s_cgComponentNames[lvItem.lParam].dwComponents;
            }
        }
    }
}

static void OnListViewNotify(HWND hwnd, UINT uMsg, WPARAM wParam, NMLVDISPINFO * lpnmlvdi)
{
    HWND            lvHandle      = GetDlgItem(hwnd, IDC_OPTCOMP);
    POINT           ptScreen,
                    ptClient;
    LVHITTESTINFO   lvHitInfo;
    LVITEM          lvItem;

    // See what the notification message that was sent to the list view.
    //
    switch ( lpnmlvdi->hdr.code )
    {
        case NM_DBLCLK:

            // Get cursor position, translate to client coordinates and
            // do a listview hittest.
            //
            GetCursorPos(&ptScreen);
            ptClient.x = ptScreen.x;
            ptClient.y = ptScreen.y;
            MapWindowPoints(NULL, lvHandle, &ptClient, 1);
            lvHitInfo.pt.x = ptClient.x;
            lvHitInfo.pt.y = ptClient.y;
            ListView_HitTest(lvHandle, &lvHitInfo);

            // Test if item was clicked.
            //
            if ( lvHitInfo.flags & LVHT_ONITEM )
            {
                // Set the check button on/off depending on prior value
                //
                ListView_SetCheckState(lvHandle, lvHitInfo.iItem, !ListView_GetCheckState(lvHandle, lvHitInfo.iItem));
            }

            break;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\spfolder.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      spfolder.c
//
// Description:  
//      This file contains the dialog procedure for the page that asks if the
//      user wants a sysprep folder. (IDD_CREATESYSPREPFOLDER).
//      
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

INT_PTR CALLBACK DlgSysprepFolderPage( IN HWND     hwnd,    
                                   IN UINT     uMsg,        
                                   IN WPARAM   wParam,    
                                   IN LPARAM   lParam);

//----------------------------------------------------------------------------
//
// Function: OnSysprepFolderInitDialog
//
// Purpose:  
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID 
OnSysprepInitDialog( IN HWND hwnd ) {

    //
    //  Default to making the Sysprep folder
    //
    CheckRadioButton( hwnd,
                      IDC_YES_SYSPREP_FOLDER,
                      IDC_NO_SYSPREP_FOLDER,
                      IDC_YES_SYSPREP_FOLDER );

}

//----------------------------------------------------------------------------
//
// Function: OnWizNextSysprepFolder
//
// Purpose:  
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static BOOL 
OnWizNextSysprepFolder( IN HWND hwnd )
{

    BOOL bStayHere = FALSE;

    if( IsDlgButtonChecked( hwnd, IDC_YES_SYSPREP_FOLDER ) )
    {
        GenSettings.bCreateSysprepFolder = TRUE;
    }
    else
    {
        GenSettings.bCreateSysprepFolder = FALSE;
    }


    //
    //  Warn the user that if they have already picked files that need a
    //  sysprep folder but then here have chosen not to create a sysprep
    //  folder.
    //

    if( ! GenSettings.bCreateSysprepFolder )
    {

        if( GenSettings.iRegionalSettings == REGIONAL_SETTINGS_SKIP ||
            GenSettings.iRegionalSettings == REGIONAL_SETTINGS_NOT_SPECIFIED )
        {

            INT iRet;

            iRet = ReportErrorId( hwnd,
                                  MSGTYPE_YESNO,
                                  IDS_ERR_MIGHT_NEED_SYSPREP_FOLDER_FOR_FILES  );

            if( iRet == IDNO )
            {
                bStayHere = TRUE;
            }

        }
        else if( GenSettings.iRegionalSettings == REGIONAL_SETTINGS_SPECIFY )
        {

            INT iCount = GetNameListSize( &GenSettings.LanguageGroups );

            if( iCount != 0 )
            {

                INT iRet;

                iRet = ReportErrorId( hwnd,
                                      MSGTYPE_YESNO,
                                      IDS_ERR_NEED_SYSPREP_FOLDER_FOR_FILES  );

                if( iRet == IDNO )
                {
                    bStayHere = TRUE;
                }

            }

        }

    }

    return ( !bStayHere );
    

}

//----------------------------------------------------------------------------
//
// Function: DlgSysprepFolderPage
//
// Purpose:  
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK 
DlgSysprepFolderPage( IN HWND     hwnd,    
                      IN UINT     uMsg,        
                      IN WPARAM   wParam,    
                      IN LPARAM   lParam) {   

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {
           
            OnSysprepInitDialog( hwnd );

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    CancelTheWizard(hwnd); break;

                case PSN_SETACTIVE: {

                    PropSheet_SetWizButtons( GetParent(hwnd),
                                             PSWIZB_BACK | PSWIZB_NEXT );

                    break;

                }
                case PSN_WIZBACK:

                    break;

                case PSN_WIZNEXT:

                    if (!OnWizNextSysprepFolder( hwnd ))
                        WIZ_FAIL(hwnd);
                    
                    break;

                default:

                    break;
            }


            break;
        }
            
        default: 
            bStatus = FALSE;
            break;

    }

    return( bStatus );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oc\tapi.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      tapi.c
//
// Description:
//      This file contains the dialog procedure for the telephone settings
//      (IDD_TAPI).
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "resource.h"

#define LengthOf(x) ( sizeof(x) / sizeof(COUNTRYCODE_STRUCT) )

typedef struct _COUNTRYCODE_STRUCT {

    DWORD dwCountryCode;
    TCHAR *szCountryName;

} COUNTRYCODE_STRUCT;

COUNTRYCODE_STRUCT rgCountryCodeArray[243];
static TCHAR *StrDontSpecifySetting;

static VOID LoadCountryStrings( VOID );

//----------------------------------------------------------------------------
//
// Function: IsValidAreaCode
//
// Purpose:  Analyzes the area code the user entered to see if it is a valid
//           area code.
//
// Arguments:  VOID
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static BOOL
IsValidAreaCode( VOID )
{

    INT i;

    //
    //  Leaving it blank is valid
    //

    if( GenSettings.szAreaCode[0] == _T('\0') )
    {
        return( TRUE );
    }

    // ISSUE-2002/02/28-stelo- make sure these are the only valid chars on localized builds of NT as well

    //
    //  Only valid chars for area code are 0 through 9
    //

    for( i = 0; GenSettings.szAreaCode[i] != _T('\0'); i++ )
    {

        if( GenSettings.szAreaCode[i] < _T('0') ||
            GenSettings.szAreaCode[i] > _T('9') )
        {
            return( FALSE );
        }

    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: IsValidOutsideLine
//
// Purpose:  Analyzes the outside line the user entered to see if it is a valid
//           outside line.
//
// Arguments:  VOID
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
static BOOL
IsValidOutsideLine( VOID )
{

    INT i;

    //
    //  Leaving it blank is valid
    //

    if( GenSettings.szOutsideLine[0] == _T('\0') )
    {
        return( TRUE );
    }

    // ISSUE-2002/02/28-stelo- make sure these are the only valid chars on localized builds of NT as well

    //
    //  Only valid chars for outside line are 0 through 9 and * # ,
    //

    for( i = 0; GenSettings.szOutsideLine[i] != _T('\0'); i++ )
    {

        if( GenSettings.szOutsideLine[i] < _T('0')  ||
            GenSettings.szOutsideLine[i] > _T('9') )
        {

            //
            //  Only acceptable chars outside the 0-9 range are are * # ,
            //
            if( GenSettings.szOutsideLine[i] != _T('*') &&
                GenSettings.szOutsideLine[i] != _T('#') &&
                GenSettings.szOutsideLine[i] != _T(',') )
            {
                return( FALSE );
            }

        }

    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: OnTapiInitDialog
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnTapiInitDialog( IN HWND hwnd ) {

    INT i;
    INT_PTR iIndex = 0;

    //
    //  Load strings from resources
    //
    StrDontSpecifySetting = MyLoadString( IDS_DONTSPECIFYSETTING );

    LoadCountryStrings();

    // Disable IME so DBCS characters can not be entered in fields
    //
    ImmAssociateContext(GetDlgItem(hwnd, IDC_AREACODE), NULL);
    ImmAssociateContext(GetDlgItem(hwnd, IDC_OUTSIDELINE), NULL);

    //
    //  Set the text limit on the edit boxes to MAX_PHONE_LENGTH
    //
    SendDlgItemMessage( hwnd,
                        IDC_AREACODE,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PHONE_LENGTH,
                        (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_OUTSIDELINE,
                        EM_LIMITTEXT,
                        (WPARAM) MAX_PHONE_LENGTH,
                        (LPARAM) 0 );

    //
    //  Load the combo box with all the possible countries
    //    (it also loads the box with the "Don't specify setting")
    //

    for( i = 0; i < LengthOf(rgCountryCodeArray); i++ )
    {

        SendDlgItemMessage( hwnd,
                            IDC_COUNTRYCODE,
                            CB_ADDSTRING,
                            (WPARAM) 0,
                            (LPARAM) rgCountryCodeArray[i].szCountryName );

    }

    //
    //  Load the Tone/Pulse dialog with the strings Tone, Pulse and Don't specify
    //  and associate a unique number to them
    //

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_CB_TONEPULSE,
                                 CB_ADDSTRING,
                                 (WPARAM) 0,
                                 (LPARAM) MyLoadString( IDS_TONE ) );

    SendDlgItemMessage( hwnd,
                        IDC_CB_TONEPULSE,
                        CB_SETITEMDATA,
                        (WPARAM) iIndex,
                        (LPARAM) TONE );

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_CB_TONEPULSE,
                                 CB_ADDSTRING,
                                 (WPARAM) 0,
                                 (LPARAM) MyLoadString( IDS_PULSE ) );

    SendDlgItemMessage( hwnd,
                        IDC_CB_TONEPULSE,
                        CB_SETITEMDATA,
                        (WPARAM) iIndex,
                        (LPARAM) PULSE );

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_CB_TONEPULSE,
                                 CB_ADDSTRING,
                                 (WPARAM) 0,
                                 (LPARAM) StrDontSpecifySetting );

    SendDlgItemMessage( hwnd,
                        IDC_CB_TONEPULSE,
                        CB_SETITEMDATA,
                        (WPARAM) iIndex,
                        (LPARAM) DONTSPECIFYSETTING );


}

//----------------------------------------------------------------------------
//
// Function: OnTapiSetActive
//
// Purpose:
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnTapiSetActive( IN HWND hwnd ) {

    INT i;
    INT_PTR iReturnValue = 0;

    //
    //  Find the string corresponding to the country code
    //
    for( i = 0; i < LengthOf(rgCountryCodeArray); i++ )
    {

        if( rgCountryCodeArray[i].dwCountryCode ==
            GenSettings.dwCountryCode )
        {

            iReturnValue = SendDlgItemMessage( hwnd,
               IDC_COUNTRYCODE,
               CB_SELECTSTRING,
               (WPARAM) -1,
               (LPARAM) rgCountryCodeArray[i].szCountryName );

            break; // found the item so break out of the for loop

        }

    }

    //
    //  if the country code was not found just select the 1st item
    //
    if( i >= LengthOf(rgCountryCodeArray) || iReturnValue == CB_ERR )
    {

        SendDlgItemMessage( hwnd,
                            IDC_COUNTRYCODE,
                            CB_SETCURSEL,
                            (WPARAM) 0,
                            (LPARAM) 0 );

    }

    SetWindowText( GetDlgItem( hwnd, IDC_AREACODE ),
                   GenSettings.szAreaCode );

    SetWindowText( GetDlgItem( hwnd, IDC_OUTSIDELINE ),
                   GenSettings.szOutsideLine );

    //
    //  Set the dialing method to Tone, Pulse or Don't specify
    //
    if( GenSettings.iDialingMethod == TONE ) {

        SendDlgItemMessage( hwnd,
                            IDC_CB_TONEPULSE,
                            CB_SETCURSEL,
                            (WPARAM) 0,
                            (LPARAM) 0 );

    }
    else if( GenSettings.iDialingMethod == PULSE ) {

        SendDlgItemMessage( hwnd,
                            IDC_CB_TONEPULSE,
                            CB_SETCURSEL,
                            (WPARAM) 1,
                            (LPARAM) 0 );

    }
    else {

        SendDlgItemMessage( hwnd,
                            IDC_CB_TONEPULSE,
                            CB_SETCURSEL,
                            (WPARAM) 2,
                            (LPARAM) 0 );

    }

    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
}

//----------------------------------------------------------------------------
//
// Function: OnWizNextTapi
//
// Purpose:  Store the setting from the TAPI page into the appropriate
//           global variables
//
// Arguments:  IN HWND hwnd - handle to the dialog box
//
// Returns:  BOOL
//
//----------------------------------------------------------------------------
BOOL
OnWizNextTapi( IN HWND hwnd ) {

    INT i;
    INT_PTR iIndex;
    INT iData;
    TCHAR szBuffer[MAX_STRING_LEN];
    BOOL bStayOnThisPage = FALSE;
    BOOL bResult = TRUE;

    //
    //  Grab the country code
    //

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_COUNTRYCODE,
                                 CB_GETCURSEL,
                                 (WPARAM) 0,
                                 (LPARAM) 0 );

    SendDlgItemMessage( hwnd,
                        IDC_COUNTRYCODE,
                        CB_GETLBTEXT,
                        (WPARAM) iIndex,
                        (LPARAM) szBuffer );

    for(i = 0; i < LengthOf(rgCountryCodeArray); i++)
    {

        if( lstrcmp( szBuffer,
                    rgCountryCodeArray[i].szCountryName ) == 0 )
        {

            GenSettings.dwCountryCode = rgCountryCodeArray[i].dwCountryCode;

            break;  // found it, so break

        }

    }

    //
    // if, for some reason, the country doesn't match, just set it to US
    //
    if( i >= LengthOf(rgCountryCodeArray) )
    {
        //
        //  Somehow a country that was not known about was specified
        //
        AssertMsg(FALSE,
                  "Programming error: Unknown TAPI country code");

        GenSettings.dwCountryCode = 1;

    }

    //
    //  Grab the Area code
    //
    GetWindowText( GetDlgItem( hwnd, IDC_AREACODE ),
                   GenSettings.szAreaCode,
                   MAX_PHONE_LENGTH + 1 );

    //
    //  Grab the outside line number
    //
    GetWindowText( GetDlgItem( hwnd, IDC_OUTSIDELINE ),
                   GenSettings.szOutsideLine,
                   MAX_PHONE_LENGTH + 1 );

    //
    //  Grab if it is Tone or Pulse dialing (or Don't Specify)
    //

    iIndex = SendDlgItemMessage( hwnd,
                                 IDC_CB_TONEPULSE,
                                 CB_GETCURSEL,
                                 (WPARAM) 0,
                                 (LPARAM) 0 );

    GenSettings.iDialingMethod = (int)SendDlgItemMessage( hwnd,
                                                     IDC_CB_TONEPULSE,
                                                     CB_GETITEMDATA,
                                                     (WPARAM) iIndex,
                                                     (LPARAM) szBuffer );

    if( GenSettings.iDialingMethod == CB_ERR ) {

        AssertMsg( FALSE,
                   "Programming error: Bad item data for Tone/Pulse dialing" );

        GenSettings.iDialingMethod = TONE;

    }

    if( ! IsValidAreaCode() )
    {
        bResult = FALSE;

        ReportErrorId( hwnd,
                       MSGTYPE_ERR,
                       IDS_ERR_BAD_AREA_CODE );
    }

    if( ! IsValidOutsideLine() )
    {
        bResult = FALSE;

        ReportErrorId( hwnd,
                       MSGTYPE_ERR,
                       IDS_ERR_BAD_OUTSIDE_LINE );
    }

    return ( bResult );

}

//----------------------------------------------------------------------------
//
// Function: DlgTapiPage
//
// Purpose:
//
// Arguments:  standard Win32 dialog proc arguments
//
// Returns:  standard Win32 dialog proc return value -- whether the message
//           was handled or not
//
//----------------------------------------------------------------------------
INT_PTR CALLBACK
DlgTapiPage( IN HWND     hwnd,
             IN UINT     uMsg,
             IN WPARAM   wParam,
             IN LPARAM   lParam) {

    BOOL bStatus = TRUE;

    switch( uMsg ) {

        case WM_INITDIALOG: {

            OnTapiInitDialog( hwnd );

            break;

        }

        case WM_NOTIFY: {

            LPNMHDR pnmh = (LPNMHDR)lParam;

            switch( pnmh->code ) {

                case PSN_QUERYCANCEL:

                    WIZ_CANCEL(hwnd); 
                    break;

                case PSN_SETACTIVE: {

                    g_App.dwCurrentHelp = IDH_TELE_PHNY;

                    OnTapiSetActive( hwnd );
                    break;

                }
                case PSN_WIZBACK:

                    bStatus = FALSE; 
                    break;

                case PSN_WIZNEXT:

                    if ( !OnWizNextTapi( hwnd ) )
                        WIZ_FAIL(hwnd);
                    else
                        bStatus = FALSE;

                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:

                    break;
            }


            break;
        }

        default:
            bStatus = FALSE;
            break;

    }

    return bStatus;

}

static VOID
LoadCountryStrings( VOID ) {

    rgCountryCodeArray[0].dwCountryCode = 1;
    rgCountryCodeArray[0].szCountryName = MyLoadString( IDS_United_States_of_America );

    rgCountryCodeArray[1].dwCountryCode = 101;
    rgCountryCodeArray[1].szCountryName = MyLoadString( IDS_Anguilla );

    rgCountryCodeArray[2].dwCountryCode = 102;
    rgCountryCodeArray[2].szCountryName = MyLoadString( IDS_Antigua );

    rgCountryCodeArray[3].dwCountryCode = 103;
    rgCountryCodeArray[3].szCountryName = MyLoadString( IDS_Bahamas );

    rgCountryCodeArray[4].dwCountryCode = 104;
    rgCountryCodeArray[4].szCountryName = MyLoadString( IDS_Barbados );

    rgCountryCodeArray[5].dwCountryCode = 105;
    rgCountryCodeArray[5].szCountryName = MyLoadString( IDS_Bermuda );

    rgCountryCodeArray[6].dwCountryCode = 106;
    rgCountryCodeArray[6].szCountryName = MyLoadString( IDS_British_Virgin_Islands );

    rgCountryCodeArray[7].dwCountryCode = 107;
    rgCountryCodeArray[7].szCountryName = MyLoadString( IDS_Canada );

    rgCountryCodeArray[8].dwCountryCode = 108;
    rgCountryCodeArray[8].szCountryName = MyLoadString( IDS_Cayman_Islands );

    rgCountryCodeArray[9].dwCountryCode = 109;
    rgCountryCodeArray[9].szCountryName = MyLoadString( IDS_Dominica );

    rgCountryCodeArray[10].dwCountryCode = 110;
    rgCountryCodeArray[10].szCountryName = MyLoadString( IDS_Dominican_Republic );

    rgCountryCodeArray[11].dwCountryCode = 111;
    rgCountryCodeArray[11].szCountryName = MyLoadString( IDS_Grenada );

    rgCountryCodeArray[12].dwCountryCode = 112;
    rgCountryCodeArray[12].szCountryName = MyLoadString( IDS_Jamaica );

    rgCountryCodeArray[13].dwCountryCode = 113;
    rgCountryCodeArray[13].szCountryName = MyLoadString( IDS_Montserrat );

    rgCountryCodeArray[14].dwCountryCode = 114;
    rgCountryCodeArray[14].szCountryName = MyLoadString( IDS_Nevis );

    rgCountryCodeArray[15].dwCountryCode = 115;
    rgCountryCodeArray[15].szCountryName = MyLoadString( IDS_St__Kitts );

    rgCountryCodeArray[16].dwCountryCode = 116;
    rgCountryCodeArray[16].szCountryName = MyLoadString( IDS_St__Vincent_Grenadines );

    rgCountryCodeArray[17].dwCountryCode = 117;
    rgCountryCodeArray[17].szCountryName = MyLoadString( IDS_Trinidad_and_Tobago );

    rgCountryCodeArray[18].dwCountryCode = 118;
    rgCountryCodeArray[18].szCountryName = MyLoadString( IDS_Turks_and_Caicos_Islands );

    rgCountryCodeArray[19].dwCountryCode = 120;
    rgCountryCodeArray[19].szCountryName = MyLoadString( IDS_Barbuda );

    rgCountryCodeArray[20].dwCountryCode = 121;
    rgCountryCodeArray[20].szCountryName = MyLoadString( IDS_Puerto_Rico );

    rgCountryCodeArray[21].dwCountryCode = 122;
    rgCountryCodeArray[21].szCountryName = MyLoadString( IDS_Saint_Lucia );

    rgCountryCodeArray[22].dwCountryCode = 123;
    rgCountryCodeArray[22].szCountryName = MyLoadString( IDS_United_States_Virgin_Is );

    rgCountryCodeArray[23].dwCountryCode = 20;
    rgCountryCodeArray[23].szCountryName = MyLoadString( IDS_Egypt );

    rgCountryCodeArray[24].dwCountryCode = 212;
    rgCountryCodeArray[24].szCountryName = MyLoadString( IDS_Morocco );

    rgCountryCodeArray[25].dwCountryCode = 213;
    rgCountryCodeArray[25].szCountryName = MyLoadString( IDS_Algeria );

    rgCountryCodeArray[26].dwCountryCode = 216;
    rgCountryCodeArray[26].szCountryName = MyLoadString( IDS_Tunisia );

    rgCountryCodeArray[27].dwCountryCode = 218;
    rgCountryCodeArray[27].szCountryName = MyLoadString( IDS_Libya );

    rgCountryCodeArray[28].dwCountryCode = 220;
    rgCountryCodeArray[28].szCountryName = MyLoadString( IDS_Gambia );

    rgCountryCodeArray[29].dwCountryCode = 221;
    rgCountryCodeArray[29].szCountryName = MyLoadString( IDS_Senegal );

    rgCountryCodeArray[30].dwCountryCode = 222;
    rgCountryCodeArray[30].szCountryName = MyLoadString( IDS_Mauritania );

    rgCountryCodeArray[31].dwCountryCode = 223;
    rgCountryCodeArray[31].szCountryName = MyLoadString( IDS_Mali );

    rgCountryCodeArray[32].dwCountryCode = 224;
    rgCountryCodeArray[32].szCountryName = MyLoadString( IDS_Guinea );

    rgCountryCodeArray[33].dwCountryCode = 225;
    rgCountryCodeArray[33].szCountryName = MyLoadString( IDS_Cote_d_Ivoire );

    rgCountryCodeArray[34].dwCountryCode = 226;
    rgCountryCodeArray[34].szCountryName = MyLoadString( IDS_Burkina_Faso );

    rgCountryCodeArray[35].dwCountryCode = 227;
    rgCountryCodeArray[35].szCountryName = MyLoadString( IDS_Niger );

    rgCountryCodeArray[36].dwCountryCode = 228;
    rgCountryCodeArray[36].szCountryName = MyLoadString( IDS_Togo );

    rgCountryCodeArray[37].dwCountryCode = 229;
    rgCountryCodeArray[37].szCountryName = MyLoadString( IDS_Benin );

    rgCountryCodeArray[38].dwCountryCode = 230;
    rgCountryCodeArray[38].szCountryName = MyLoadString( IDS_Mauritius );

    rgCountryCodeArray[39].dwCountryCode = 231;
    rgCountryCodeArray[39].szCountryName = MyLoadString( IDS_Liberia );

    rgCountryCodeArray[40].dwCountryCode = 232;
    rgCountryCodeArray[40].szCountryName = MyLoadString( IDS_Sierra_Leone );

    rgCountryCodeArray[41].dwCountryCode = 233;
    rgCountryCodeArray[41].szCountryName = MyLoadString( IDS_Ghana );

    rgCountryCodeArray[42].dwCountryCode = 234;
    rgCountryCodeArray[42].szCountryName = MyLoadString( IDS_Nigeria );

    rgCountryCodeArray[43].dwCountryCode = 235;
    rgCountryCodeArray[43].szCountryName = MyLoadString( IDS_Chad );

    rgCountryCodeArray[44].dwCountryCode = 236;
    rgCountryCodeArray[44].szCountryName = MyLoadString( IDS_Central_African_Rep );

    rgCountryCodeArray[45].dwCountryCode = 237;
    rgCountryCodeArray[45].szCountryName = MyLoadString( IDS_Cameroon );

    rgCountryCodeArray[46].dwCountryCode = 238;
    rgCountryCodeArray[46].szCountryName = MyLoadString( IDS_Cape_Verde );

    rgCountryCodeArray[47].dwCountryCode = 239;
    rgCountryCodeArray[47].szCountryName = MyLoadString( IDS_Sao_Tome_and_Principe );

    rgCountryCodeArray[48].dwCountryCode = 240;
    rgCountryCodeArray[48].szCountryName = MyLoadString( IDS_Equatorial_Guinea );

    rgCountryCodeArray[49].dwCountryCode = 241;
    rgCountryCodeArray[49].szCountryName = MyLoadString( IDS_Gabon );

    rgCountryCodeArray[50].dwCountryCode = 242;
    rgCountryCodeArray[50].szCountryName = MyLoadString( IDS_Congo );

    rgCountryCodeArray[51].dwCountryCode = 243;
    rgCountryCodeArray[51].szCountryName = MyLoadString( IDS_Dem_Rep_of_the_Congo );

    rgCountryCodeArray[52].dwCountryCode = 244;
    rgCountryCodeArray[52].szCountryName = MyLoadString( IDS_Angola );

    rgCountryCodeArray[53].dwCountryCode = 245;
    rgCountryCodeArray[53].szCountryName = MyLoadString( IDS_Guinea_Bissau );

    rgCountryCodeArray[54].dwCountryCode = 246;
    rgCountryCodeArray[54].szCountryName = MyLoadString( IDS_Diego_Garcia );

    rgCountryCodeArray[55].dwCountryCode = 247;
    rgCountryCodeArray[55].szCountryName = MyLoadString( IDS_Ascension_Island );

    rgCountryCodeArray[56].dwCountryCode = 248;
    rgCountryCodeArray[56].szCountryName = MyLoadString( IDS_Seychelles );

    rgCountryCodeArray[57].dwCountryCode = 249;
    rgCountryCodeArray[57].szCountryName = MyLoadString( IDS_Sudan );

    rgCountryCodeArray[58].dwCountryCode = 250;
    rgCountryCodeArray[58].szCountryName = MyLoadString( IDS_Rwanda );

    rgCountryCodeArray[59].dwCountryCode = 251;
    rgCountryCodeArray[59].szCountryName = MyLoadString( IDS_Ethiopia );

    rgCountryCodeArray[60].dwCountryCode = 252;
    rgCountryCodeArray[60].szCountryName = MyLoadString( IDS_Somalia );

    rgCountryCodeArray[61].dwCountryCode = 253;
    rgCountryCodeArray[61].szCountryName = MyLoadString( IDS_Djibouti );

    rgCountryCodeArray[62].dwCountryCode = 254;
    rgCountryCodeArray[62].szCountryName = MyLoadString( IDS_Kenya );

    rgCountryCodeArray[63].dwCountryCode = 255;
    rgCountryCodeArray[63].szCountryName = MyLoadString( IDS_Tanzania );

    rgCountryCodeArray[64].dwCountryCode = 256;
    rgCountryCodeArray[64].szCountryName = MyLoadString( IDS_Uganda );

    rgCountryCodeArray[65].dwCountryCode = 257;
    rgCountryCodeArray[65].szCountryName = MyLoadString( IDS_Burundi );

    rgCountryCodeArray[66].dwCountryCode = 258;
    rgCountryCodeArray[66].szCountryName = MyLoadString( IDS_Mozambique );

    rgCountryCodeArray[67].dwCountryCode = 260;
    rgCountryCodeArray[67].szCountryName = MyLoadString( IDS_Zambia );

    rgCountryCodeArray[68].dwCountryCode = 261;
    rgCountryCodeArray[68].szCountryName = MyLoadString( IDS_Madagascar );

    rgCountryCodeArray[69].dwCountryCode = 262;
    rgCountryCodeArray[69].szCountryName = MyLoadString( IDS_Reunion_Island );

    rgCountryCodeArray[70].dwCountryCode = 263;
    rgCountryCodeArray[70].szCountryName = MyLoadString( IDS_Zimbabwe );

    rgCountryCodeArray[71].dwCountryCode = 264;
    rgCountryCodeArray[71].szCountryName = MyLoadString( IDS_Namibia );

    rgCountryCodeArray[72].dwCountryCode = 265;
    rgCountryCodeArray[72].szCountryName = MyLoadString( IDS_Malawi );

    rgCountryCodeArray[73].dwCountryCode = 266;
    rgCountryCodeArray[73].szCountryName = MyLoadString( IDS_Lesotho );

    rgCountryCodeArray[74].dwCountryCode = 267;
    rgCountryCodeArray[74].szCountryName = MyLoadString( IDS_Botswana );

    rgCountryCodeArray[75].dwCountryCode = 268;
    rgCountryCodeArray[75].szCountryName = MyLoadString( IDS_Swaziland );

    rgCountryCodeArray[76].dwCountryCode = 269;
    rgCountryCodeArray[76].szCountryName = MyLoadString( IDS_Mayotte_Island );

    rgCountryCodeArray[77].dwCountryCode = 2691;
    rgCountryCodeArray[77].szCountryName = MyLoadString( IDS_Comoros );

    rgCountryCodeArray[78].dwCountryCode = 27;
    rgCountryCodeArray[78].szCountryName = MyLoadString( IDS_South_Africa );

    rgCountryCodeArray[79].dwCountryCode = 290;
    rgCountryCodeArray[79].szCountryName = MyLoadString( IDS_St__Helena );

    rgCountryCodeArray[80].dwCountryCode = 291;
    rgCountryCodeArray[80].szCountryName = MyLoadString( IDS_Eritrea );

    rgCountryCodeArray[81].dwCountryCode = 297;
    rgCountryCodeArray[81].szCountryName = MyLoadString( IDS_Aruba );

    rgCountryCodeArray[82].dwCountryCode = 298;
    rgCountryCodeArray[82].szCountryName = MyLoadString( IDS_Faeroe_Islands );

    rgCountryCodeArray[83].dwCountryCode = 299;
    rgCountryCodeArray[83].szCountryName = MyLoadString( IDS_Greenland );

    rgCountryCodeArray[84].dwCountryCode = 30;
    rgCountryCodeArray[84].szCountryName = MyLoadString( IDS_Greece );

    rgCountryCodeArray[85].dwCountryCode = 31;
    rgCountryCodeArray[85].szCountryName = MyLoadString( IDS_Netherlands );

    rgCountryCodeArray[86].dwCountryCode = 32;
    rgCountryCodeArray[86].szCountryName = MyLoadString( IDS_Belgium );

    rgCountryCodeArray[87].dwCountryCode = 33;
    rgCountryCodeArray[87].szCountryName = MyLoadString( IDS_France );

    rgCountryCodeArray[88].dwCountryCode = 377;
    rgCountryCodeArray[88].szCountryName = MyLoadString( IDS_Monaco );

    rgCountryCodeArray[89].dwCountryCode = 34;
    rgCountryCodeArray[89].szCountryName = MyLoadString( IDS_Spain );

    rgCountryCodeArray[90].dwCountryCode = 350;
    rgCountryCodeArray[90].szCountryName = MyLoadString( IDS_Gibraltar );

    rgCountryCodeArray[91].dwCountryCode = 351;
    rgCountryCodeArray[91].szCountryName = MyLoadString( IDS_Portugal );

    rgCountryCodeArray[92].dwCountryCode = 352;
    rgCountryCodeArray[92].szCountryName = MyLoadString( IDS_Luxembourg );

    rgCountryCodeArray[93].dwCountryCode = 353;
    rgCountryCodeArray[93].szCountryName = MyLoadString( IDS_Ireland );

    rgCountryCodeArray[94].dwCountryCode = 354;
    rgCountryCodeArray[94].szCountryName = MyLoadString( IDS_Iceland );

    rgCountryCodeArray[95].dwCountryCode = 355;
    rgCountryCodeArray[95].szCountryName = MyLoadString( IDS_Albania );

    rgCountryCodeArray[96].dwCountryCode = 356;
    rgCountryCodeArray[96].szCountryName = MyLoadString( IDS_Malta );

    rgCountryCodeArray[97].dwCountryCode = 357;
    rgCountryCodeArray[97].szCountryName = MyLoadString( IDS_Cyprus );

    rgCountryCodeArray[98].dwCountryCode = 358;
    rgCountryCodeArray[98].szCountryName = MyLoadString( IDS_Finland );

    rgCountryCodeArray[99].dwCountryCode = 359;
    rgCountryCodeArray[99].szCountryName = MyLoadString( IDS_Bulgaria );

    rgCountryCodeArray[100].dwCountryCode = 36;
    rgCountryCodeArray[100].szCountryName = MyLoadString( IDS_Hungary );

    rgCountryCodeArray[101].dwCountryCode = 370;
    rgCountryCodeArray[101].szCountryName = MyLoadString( IDS_Lithuania );

    rgCountryCodeArray[102].dwCountryCode = 371;
    rgCountryCodeArray[102].szCountryName = MyLoadString( IDS_Latvia );

    rgCountryCodeArray[103].dwCountryCode = 372;
    rgCountryCodeArray[103].szCountryName = MyLoadString( IDS_Estonia );

    rgCountryCodeArray[104].dwCountryCode = 373;
    rgCountryCodeArray[104].szCountryName = MyLoadString( IDS_Moldova );

    rgCountryCodeArray[105].dwCountryCode = 374;
    rgCountryCodeArray[105].szCountryName = MyLoadString( IDS_Armenia );

    rgCountryCodeArray[106].dwCountryCode = 375;
    rgCountryCodeArray[106].szCountryName = MyLoadString( IDS_Belarus );

    rgCountryCodeArray[107].dwCountryCode = 376;
    rgCountryCodeArray[107].szCountryName = MyLoadString( IDS_Andorra );

    rgCountryCodeArray[108].dwCountryCode = 378;
    rgCountryCodeArray[108].szCountryName = MyLoadString( IDS_San_Marino );

    rgCountryCodeArray[109].dwCountryCode = 379;
    rgCountryCodeArray[109].szCountryName = MyLoadString( IDS_Vatican_City );

    rgCountryCodeArray[110].dwCountryCode = 380;
    rgCountryCodeArray[110].szCountryName = MyLoadString( IDS_Ukraine );

    rgCountryCodeArray[111].dwCountryCode = 381;
    rgCountryCodeArray[111].szCountryName = MyLoadString( IDS_Yugoslavia );

    rgCountryCodeArray[112].dwCountryCode = 385;
    rgCountryCodeArray[112].szCountryName = MyLoadString( IDS_Croatia );

    rgCountryCodeArray[113].dwCountryCode = 386;
    rgCountryCodeArray[113].szCountryName = MyLoadString( IDS_Slovenia );

    rgCountryCodeArray[114].dwCountryCode = 387;
    rgCountryCodeArray[114].szCountryName = MyLoadString( IDS_Bosnia_and_Herzegovina );

    rgCountryCodeArray[115].dwCountryCode = 389;
    rgCountryCodeArray[115].szCountryName = MyLoadString( IDS_Former_Yugo_Rep_of_Macedonia );

    rgCountryCodeArray[116].dwCountryCode = 39;
    rgCountryCodeArray[116].szCountryName = MyLoadString( IDS_Italy );

    rgCountryCodeArray[117].dwCountryCode = 40;
    rgCountryCodeArray[117].szCountryName = MyLoadString( IDS_Romania );

    rgCountryCodeArray[118].dwCountryCode = 41;
    rgCountryCodeArray[118].szCountryName = MyLoadString( IDS_Switzerland );

    rgCountryCodeArray[119].dwCountryCode = 4101;
    rgCountryCodeArray[119].szCountryName = MyLoadString( IDS_Liechtenstein );

    rgCountryCodeArray[120].dwCountryCode = 42;
    rgCountryCodeArray[120].szCountryName = MyLoadString( IDS_Czech_Republic );

    rgCountryCodeArray[121].dwCountryCode = 4201;
    rgCountryCodeArray[121].szCountryName = MyLoadString( IDS_Slovakia );

    rgCountryCodeArray[122].dwCountryCode = 43;
    rgCountryCodeArray[122].szCountryName = MyLoadString( IDS_Austria );

    rgCountryCodeArray[123].dwCountryCode = 44;
    rgCountryCodeArray[123].szCountryName = MyLoadString( IDS_United_Kingdom );

    rgCountryCodeArray[124].dwCountryCode = 45;
    rgCountryCodeArray[124].szCountryName = MyLoadString( IDS_Denmark );

    rgCountryCodeArray[125].dwCountryCode = 46;
    rgCountryCodeArray[125].szCountryName = MyLoadString( IDS_Sweden );

    rgCountryCodeArray[126].dwCountryCode = 47;
    rgCountryCodeArray[126].szCountryName = MyLoadString( IDS_Norway );

    rgCountryCodeArray[127].dwCountryCode = 48;
    rgCountryCodeArray[127].szCountryName = MyLoadString( IDS_Poland );

    rgCountryCodeArray[128].dwCountryCode = 49;
    rgCountryCodeArray[128].szCountryName = MyLoadString( IDS_Germany );

    rgCountryCodeArray[129].dwCountryCode = 500;
    rgCountryCodeArray[129].szCountryName = MyLoadString( IDS_Falkland_Islands );

    rgCountryCodeArray[130].dwCountryCode = 501;
    rgCountryCodeArray[130].szCountryName = MyLoadString( IDS_Belize );

    rgCountryCodeArray[131].dwCountryCode = 502;
    rgCountryCodeArray[131].szCountryName = MyLoadString( IDS_Guatemala );

    rgCountryCodeArray[132].dwCountryCode = 503;
    rgCountryCodeArray[132].szCountryName = MyLoadString( IDS_El_Salvador );

    rgCountryCodeArray[133].dwCountryCode = 504;
    rgCountryCodeArray[133].szCountryName = MyLoadString( IDS_Honduras );

    rgCountryCodeArray[134].dwCountryCode = 505;
    rgCountryCodeArray[134].szCountryName = MyLoadString( IDS_Nicaragua );

    rgCountryCodeArray[135].dwCountryCode = 506;
    rgCountryCodeArray[135].szCountryName = MyLoadString( IDS_Costa_Rica );

    rgCountryCodeArray[136].dwCountryCode = 507;
    rgCountryCodeArray[136].szCountryName = MyLoadString( IDS_Panama );

    rgCountryCodeArray[137].dwCountryCode = 508;
    rgCountryCodeArray[137].szCountryName = MyLoadString( IDS_St__Pierre_and_Miquelon );

    rgCountryCodeArray[138].dwCountryCode = 509;
    rgCountryCodeArray[138].szCountryName = MyLoadString( IDS_Haiti );

    rgCountryCodeArray[139].dwCountryCode = 51;
    rgCountryCodeArray[139].szCountryName = MyLoadString( IDS_Peru );

    rgCountryCodeArray[140].dwCountryCode = 52;
    rgCountryCodeArray[140].szCountryName = MyLoadString( IDS_Mexico );

    rgCountryCodeArray[141].dwCountryCode = 53;
    rgCountryCodeArray[141].szCountryName = MyLoadString( IDS_Cuba );

    rgCountryCodeArray[142].dwCountryCode = 5399;
    rgCountryCodeArray[142].szCountryName = MyLoadString( IDS_Guantanamo_Bay );

    rgCountryCodeArray[143].dwCountryCode = 54;
    rgCountryCodeArray[143].szCountryName = MyLoadString( IDS_Argentina );

    rgCountryCodeArray[144].dwCountryCode = 55;
    rgCountryCodeArray[144].szCountryName = MyLoadString( IDS_Brazil );

    rgCountryCodeArray[145].dwCountryCode = 56;
    rgCountryCodeArray[145].szCountryName = MyLoadString( IDS_Chile );

    rgCountryCodeArray[146].dwCountryCode = 57;
    rgCountryCodeArray[146].szCountryName = MyLoadString( IDS_Colombia );

    rgCountryCodeArray[147].dwCountryCode = 58;
    rgCountryCodeArray[147].szCountryName = MyLoadString( IDS_Venezuela );

    rgCountryCodeArray[148].dwCountryCode = 590;
    rgCountryCodeArray[148].szCountryName = MyLoadString( IDS_Guadeloupe );

    rgCountryCodeArray[149].dwCountryCode = 5901;
    rgCountryCodeArray[149].szCountryName = MyLoadString( IDS_French_Antilles );

    rgCountryCodeArray[150].dwCountryCode = 591;
    rgCountryCodeArray[150].szCountryName = MyLoadString( IDS_Bolivia );

    rgCountryCodeArray[151].dwCountryCode = 592;
    rgCountryCodeArray[151].szCountryName = MyLoadString( IDS_Guyana );

    rgCountryCodeArray[152].dwCountryCode = 593;
    rgCountryCodeArray[152].szCountryName = MyLoadString( IDS_Ecuador );

    rgCountryCodeArray[153].dwCountryCode = 594;
    rgCountryCodeArray[153].szCountryName = MyLoadString( IDS_French_Guiana );

    rgCountryCodeArray[154].dwCountryCode = 595;
    rgCountryCodeArray[154].szCountryName = MyLoadString( IDS_Paraguay );

    rgCountryCodeArray[155].dwCountryCode = 596;
    rgCountryCodeArray[155].szCountryName = MyLoadString( IDS_Martinique );

    rgCountryCodeArray[156].dwCountryCode = 597;
    rgCountryCodeArray[156].szCountryName = MyLoadString( IDS_Suriname );

    rgCountryCodeArray[157].dwCountryCode = 598;
    rgCountryCodeArray[157].szCountryName = MyLoadString( IDS_Uruguay );

    rgCountryCodeArray[158].dwCountryCode = 599;
    rgCountryCodeArray[158].szCountryName = MyLoadString( IDS_Netherlands_Antilles );

    rgCountryCodeArray[159].dwCountryCode = 60;
    rgCountryCodeArray[159].szCountryName = MyLoadString( IDS_Malaysia );

    rgCountryCodeArray[160].dwCountryCode = 61;
    rgCountryCodeArray[160].szCountryName = MyLoadString( IDS_Australia );

    rgCountryCodeArray[161].dwCountryCode = 6101;
    rgCountryCodeArray[161].szCountryName = MyLoadString( IDS_Cocos_Keeling_Islands );

    rgCountryCodeArray[162].dwCountryCode = 62;
    rgCountryCodeArray[162].szCountryName = MyLoadString( IDS_Indonesia );

    rgCountryCodeArray[163].dwCountryCode = 63;
    rgCountryCodeArray[163].szCountryName = MyLoadString( IDS_Philippines );

    rgCountryCodeArray[164].dwCountryCode = 64;
    rgCountryCodeArray[164].szCountryName = MyLoadString( IDS_New_Zealand );

    rgCountryCodeArray[165].dwCountryCode = 65;
    rgCountryCodeArray[165].szCountryName = MyLoadString( IDS_Singapore );

    rgCountryCodeArray[166].dwCountryCode = 66;
    rgCountryCodeArray[166].szCountryName = MyLoadString( IDS_Thailand );

    rgCountryCodeArray[167].dwCountryCode = 670;
    rgCountryCodeArray[167].szCountryName = MyLoadString( IDS_Saipan_Island );

    rgCountryCodeArray[168].dwCountryCode = 6701;
    rgCountryCodeArray[168].szCountryName = MyLoadString( IDS_Rota_Island );

    rgCountryCodeArray[169].dwCountryCode = 6702;
    rgCountryCodeArray[169].szCountryName = MyLoadString( IDS_Tinian_Island );

    rgCountryCodeArray[170].dwCountryCode = 671;
    rgCountryCodeArray[170].szCountryName = MyLoadString( IDS_Guam );

    rgCountryCodeArray[171].dwCountryCode = 672;
    rgCountryCodeArray[171].szCountryName = MyLoadString( IDS_Christmas_Island );

    rgCountryCodeArray[172].dwCountryCode = 6721;
    rgCountryCodeArray[172].szCountryName = MyLoadString( IDS_Australian_Antarctic_Territory );

    rgCountryCodeArray[173].dwCountryCode = 6722;
    rgCountryCodeArray[173].szCountryName = MyLoadString( IDS_Norfolk_Island );

    rgCountryCodeArray[174].dwCountryCode = 673;
    rgCountryCodeArray[174].szCountryName = MyLoadString( IDS_Brunei );

    rgCountryCodeArray[175].dwCountryCode = 674;
    rgCountryCodeArray[175].szCountryName = MyLoadString( IDS_Nauru );

    rgCountryCodeArray[176].dwCountryCode = 675;
    rgCountryCodeArray[176].szCountryName = MyLoadString( IDS_Papua_New_Guinea );

    rgCountryCodeArray[177].dwCountryCode = 676;
    rgCountryCodeArray[177].szCountryName = MyLoadString( IDS_Tonga );

    rgCountryCodeArray[178].dwCountryCode = 677;
    rgCountryCodeArray[178].szCountryName = MyLoadString( IDS_Solomon_Islands );

    rgCountryCodeArray[179].dwCountryCode = 678;
    rgCountryCodeArray[179].szCountryName = MyLoadString( IDS_Vanuatu );

    rgCountryCodeArray[180].dwCountryCode = 679;
    rgCountryCodeArray[180].szCountryName = MyLoadString( IDS_Fiji );

    rgCountryCodeArray[181].dwCountryCode = 680;
    rgCountryCodeArray[181].szCountryName = MyLoadString( IDS_Palau );

    rgCountryCodeArray[182].dwCountryCode = 681;
    rgCountryCodeArray[182].szCountryName = MyLoadString( IDS_Wallis_and_Futuna_Islands );

    rgCountryCodeArray[183].dwCountryCode = 682;
    rgCountryCodeArray[183].szCountryName = MyLoadString( IDS_Cook_Islands );

    rgCountryCodeArray[184].dwCountryCode = 683;
    rgCountryCodeArray[184].szCountryName = MyLoadString( IDS_Niue );

    rgCountryCodeArray[185].dwCountryCode = 684;
    rgCountryCodeArray[185].szCountryName = MyLoadString( IDS_American_Samoa );

    rgCountryCodeArray[186].dwCountryCode = 685;
    rgCountryCodeArray[186].szCountryName = MyLoadString( IDS_Samoa );

    rgCountryCodeArray[187].dwCountryCode = 686;
    rgCountryCodeArray[187].szCountryName = MyLoadString( IDS_Kiribati );

    rgCountryCodeArray[188].dwCountryCode = 687;
    rgCountryCodeArray[188].szCountryName = MyLoadString( IDS_New_Caledonia );

    rgCountryCodeArray[189].dwCountryCode = 688;
    rgCountryCodeArray[189].szCountryName = MyLoadString( IDS_Tuvalu );

    rgCountryCodeArray[190].dwCountryCode = 689;
    rgCountryCodeArray[190].szCountryName = MyLoadString( IDS_French_Polynesia );

    rgCountryCodeArray[191].dwCountryCode = 690;
    rgCountryCodeArray[191].szCountryName = MyLoadString( IDS_Tokelau );

    rgCountryCodeArray[192].dwCountryCode = 691;
    rgCountryCodeArray[192].szCountryName = MyLoadString( IDS_Micronesia__Fed_States_of );

    rgCountryCodeArray[193].dwCountryCode = 692;
    rgCountryCodeArray[193].szCountryName = MyLoadString( IDS_Marshall_Islands );

    rgCountryCodeArray[194].dwCountryCode = 7;
    rgCountryCodeArray[194].szCountryName = MyLoadString( IDS_Russia );

    rgCountryCodeArray[195].dwCountryCode = 705;
    rgCountryCodeArray[195].szCountryName = MyLoadString( IDS_Kazakhstan );

    rgCountryCodeArray[196].dwCountryCode = 706;
    rgCountryCodeArray[196].szCountryName = MyLoadString( IDS_Kyrgyzstan );

    rgCountryCodeArray[197].dwCountryCode = 708;
    rgCountryCodeArray[197].szCountryName = MyLoadString( IDS_Tajikistan );

    rgCountryCodeArray[198].dwCountryCode = 709;
    rgCountryCodeArray[198].szCountryName = MyLoadString( IDS_Turkmenistan );

    rgCountryCodeArray[199].dwCountryCode = 711;
    rgCountryCodeArray[199].szCountryName = MyLoadString( IDS_Uzbekistan );

    rgCountryCodeArray[200].dwCountryCode = 81;
    rgCountryCodeArray[200].szCountryName = MyLoadString( IDS_Japan );

    rgCountryCodeArray[201].dwCountryCode = 82;
    rgCountryCodeArray[201].szCountryName = MyLoadString( IDS_Korea__Republic_of );

    rgCountryCodeArray[202].dwCountryCode = 84;
    rgCountryCodeArray[202].szCountryName = MyLoadString( IDS_Vietnam );

    rgCountryCodeArray[203].dwCountryCode = 850;
    rgCountryCodeArray[203].szCountryName = MyLoadString( IDS_Korea__North_ );

    rgCountryCodeArray[204].dwCountryCode = 852;
    rgCountryCodeArray[204].szCountryName = MyLoadString( IDS_Hong_Kong );

    rgCountryCodeArray[205].dwCountryCode = 853;
    rgCountryCodeArray[205].szCountryName = MyLoadString( IDS_Macau );

    rgCountryCodeArray[206].dwCountryCode = 855;
    rgCountryCodeArray[206].szCountryName = MyLoadString( IDS_Cambodia );

    rgCountryCodeArray[207].dwCountryCode = 856;
    rgCountryCodeArray[207].szCountryName = MyLoadString( IDS_Laos );

    rgCountryCodeArray[208].dwCountryCode = 86;
    rgCountryCodeArray[208].szCountryName = MyLoadString( IDS_China );

    rgCountryCodeArray[209].dwCountryCode = 871;
    rgCountryCodeArray[209].szCountryName = MyLoadString( IDS_INMARSAT__Atlantic_East_ );

    rgCountryCodeArray[210].dwCountryCode = 872;
    rgCountryCodeArray[210].szCountryName = MyLoadString( IDS_INMARSAT__Pacific_ );

    rgCountryCodeArray[211].dwCountryCode = 873;
    rgCountryCodeArray[211].szCountryName = MyLoadString( IDS_INMARSAT__Indian_ );

    rgCountryCodeArray[212].dwCountryCode = 874;
    rgCountryCodeArray[212].szCountryName = MyLoadString( IDS_INMARSAT__Atlantic_West_ );

    rgCountryCodeArray[213].dwCountryCode = 880;
    rgCountryCodeArray[213].szCountryName = MyLoadString( IDS_Bangladesh );

    rgCountryCodeArray[214].dwCountryCode = 886;
    rgCountryCodeArray[214].szCountryName = MyLoadString( IDS_Taiwan );

    rgCountryCodeArray[215].dwCountryCode = 90;
    rgCountryCodeArray[215].szCountryName = MyLoadString( IDS_Turkey );

    rgCountryCodeArray[216].dwCountryCode = 91;
    rgCountryCodeArray[216].szCountryName = MyLoadString( IDS_India );

    rgCountryCodeArray[217].dwCountryCode = 92;
    rgCountryCodeArray[217].szCountryName = MyLoadString( IDS_Pakistan );

    rgCountryCodeArray[218].dwCountryCode = 93;
    rgCountryCodeArray[218].szCountryName = MyLoadString( IDS_Afghanistan );

    rgCountryCodeArray[219].dwCountryCode = 94;
    rgCountryCodeArray[219].szCountryName = MyLoadString( IDS_Sri_Lanka );

    rgCountryCodeArray[220].dwCountryCode = 95;
    rgCountryCodeArray[220].szCountryName = MyLoadString( IDS_Myanmar );

    rgCountryCodeArray[221].dwCountryCode = 960;
    rgCountryCodeArray[221].szCountryName = MyLoadString( IDS_Maldives );

    rgCountryCodeArray[222].dwCountryCode = 961;
    rgCountryCodeArray[222].szCountryName = MyLoadString( IDS_Lebanon );

    rgCountryCodeArray[223].dwCountryCode = 962;
    rgCountryCodeArray[223].szCountryName = MyLoadString( IDS_Jordan );

    rgCountryCodeArray[224].dwCountryCode = 963;
    rgCountryCodeArray[224].szCountryName = MyLoadString( IDS_Syria );

    rgCountryCodeArray[225].dwCountryCode = 964;
    rgCountryCodeArray[225].szCountryName = MyLoadString( IDS_Iraq );

    rgCountryCodeArray[226].dwCountryCode = 965;
    rgCountryCodeArray[226].szCountryName = MyLoadString( IDS_Kuwait );

    rgCountryCodeArray[227].dwCountryCode = 966;
    rgCountryCodeArray[227].szCountryName = MyLoadString( IDS_Saudi_Arabia );

    rgCountryCodeArray[228].dwCountryCode = 967;
    rgCountryCodeArray[228].szCountryName = MyLoadString( IDS_Yemen );

    rgCountryCodeArray[229].dwCountryCode = 968;
    rgCountryCodeArray[229].szCountryName = MyLoadString( IDS_Oman );

    rgCountryCodeArray[230].dwCountryCode = 971;
    rgCountryCodeArray[230].szCountryName = MyLoadString( IDS_United_Arab_Emirates );

    rgCountryCodeArray[231].dwCountryCode = 972;
    rgCountryCodeArray[231].szCountryName = MyLoadString( IDS_Israel );

    rgCountryCodeArray[232].dwCountryCode = 973;
    rgCountryCodeArray[232].szCountryName = MyLoadString( IDS_Bahrain );

    rgCountryCodeArray[233].dwCountryCode = 974;
    rgCountryCodeArray[233].szCountryName = MyLoadString( IDS_Qatar );

    rgCountryCodeArray[234].dwCountryCode = 975;
    rgCountryCodeArray[234].szCountryName = MyLoadString( IDS_Bhutan );

    rgCountryCodeArray[235].dwCountryCode = 976;
    rgCountryCodeArray[235].szCountryName = MyLoadString( IDS_Mongolia );

    rgCountryCodeArray[236].dwCountryCode = 977;
    rgCountryCodeArray[236].szCountryName = MyLoadString( IDS_Nepal );

    rgCountryCodeArray[237].dwCountryCode = 98;
    rgCountryCodeArray[237].szCountryName = MyLoadString( IDS_Iran );

    rgCountryCodeArray[238].dwCountryCode = 994;
    rgCountryCodeArray[238].szCountryName = MyLoadString( IDS_Azerbaijan );

    rgCountryCodeArray[239].dwCountryCode = 995;
    rgCountryCodeArray[239].szCountryName = MyLoadString( IDS_Georgia );

    rgCountryCodeArray[240].dwCountryCode = 800;
    rgCountryCodeArray[240].szCountryName = MyLoadString( IDS_Intl_Freephone_Service );

    rgCountryCodeArray[241].dwCountryCode = 870;
    rgCountryCodeArray[241].szCountryName = MyLoadString( IDS_INMARSAT );

    //
    //  Add the don't specify setting
    //
    rgCountryCodeArray[242].dwCountryCode = DONTSPECIFYSETTING;
    rgCountryCodeArray[242].szCountryName = StrDontSpecifySetting;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\appinst.c ===
/****************************************************************************\

    APPINST.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "application preinstallation" wizard page.

    06/99 - Jason Cohen (JCOHEN)
        Updated this source file for the OPK Wizard as part of the
        Millennium rewrite.

    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"
#include "appinst.h"
#include <setupapi.h>



//
// Internal Defined Value(s):
//

#define INI_SEC_RESERVEDNAMES           _T("AppNames")

#define INF_KEY_PREINSTALL              _T("\"%s\",\"\"\"%s\"\" %s\"")
#define INF_KEY_PREINSTALL_ADV          _T("\"%s\",%s,%s")

#define INI_KEY_SIG                     _T("Signature")
#define INI_VAL_SIG                     _T("$CHICAGO$")

#define STR_INI_SEC_ADVAPP              _T("AppPre%s%2.2d")
#define STR_INI_SEC_ADVAPP_STAGE        _T(".%s")

#define APP_ADD                         0
#define APP_DELETE                      1
#define APP_MOVE_DOWN                   2


//
// Internal Type Definition(s):
//

typedef struct _RADIOBUTTONS
{
    int         iButtonId;
    INSTALLTECH itSectionType;
}
RADIOBUTTONS, *PRADIOBUTTONS, *LPRADIOBUTTONS;


//
// Internal Constant Global(s):
//

// Resource ID for column header string.
//
const UINT g_cuHeader[] =
{
    IDS_PREINSTALL_NAME,
    IDS_PREINSTALL_COMMAND
};

// Column format flags.
//
const UINT g_cuFormat[] =
{
    LVCFMT_LEFT,
    LVCFMT_LEFT
};

// Column width in percent (the last one is
// zero so that it uses the rest of the space).
//
const UINT g_cuWidth[] =
{
    50,
    50
};

const INSTALLTECHS g_cSectionTypes[] =
{
    { installtechApp,   INI_VAL_WBOM_APP },
    { installtechMSI,   INI_VAL_WBOM_MSI },
    { installtechINF,   INI_VAL_WBOM_INF },
};

const INSTALLTYPES g_cInstallTypes[] =
{
    { installtypeStandard,  INI_VAL_WBOM_STANDARD },
    { installtypeStage,     INI_VAL_WBOM_STAGE },
    { installtypeAttach,    INI_VAL_WBOM_ATTACH },
    { installtypeDetach,    INI_VAL_WBOM_DETACH },
};

const RADIOBUTTONS g_crbChecked[] =
{
    { IDC_APP_TYPE_GEN, installtechApp },
    { IDC_APP_TYPE_MSI, installtechMSI },
    { IDC_APP_TYPE_INF, installtechINF },
};

//
// Internal Golbal Variable(s):
//

LPAPPENTRY  g_lpAppHead = NULL;
HMENU       g_hMenu;
HANDLE      g_hArrowUp  = NULL;
HANDLE      g_hArrowDn  = NULL;

//
// Other Internal Defined Value(s):
//

#define NUM_COLUMNS                     ARRAYSIZE(g_cuHeader)


//
// Internal Function Prototype(s):
//

BOOL CALLBACK OneAppDlgProc(HWND, UINT, WPARAM, LPARAM);
static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static LRESULT OnListViewNotify(HWND, UINT, WPARAM, NMLVDISPINFO*);
static BOOL SaveData(HWND);
static BOOL SaveOneApp(HWND, LPAPPENTRY);
static LPAPPENTRY ManageAppList(LPLPAPPENTRY, LPAPPENTRY, DWORD);
static void AddAppToListView(HWND, LPAPPENTRY);
static BOOL RefreshAppList(HWND, LPAPPENTRY);
static BOOL AdvancedView(HWND hwnd, BOOL bChange);
static void CleanupSections(LPTSTR lpSection, BOOL bStage);
static void StrCpyDbl(LPTSTR lpDst, LPTSTR lpSrc);
static BOOL FindUncPath(LPTSTR lpPath, DWORD cbPath);
static void EnableControls(HWND hwnd, UINT uId);
static BOOL AppInternal(LPTSTR lpszAppName);


//
// External Function(s):
//

LPAPPENTRY OpenAppList(LPTSTR lpIniFile)
{
    LPAPPENTRY  lpAppHead = NULL;
    HINF        hInf;
    DWORD       dwErr;
    HRESULT hrPrintf;

    // Open up the INF we need to look through to build our app list.
    //
    if ( (hInf = SetupOpenInfFile(lpIniFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, &dwErr)) != INVALID_HANDLE_VALUE )
    {
        INFCONTEXT  InfContext;
        BOOL        bRet,
                    bBadApp;
        APPENTRY    app;
        TCHAR       szIniVal[MAX_PATH];

        //
        // Now we look for and add our user added apps by searching thru
        // the INI_SEC_WBOM_PREINSTALL first.
        //
        // Lines in this section are of the form:
        // AppName=AppPath,n
        //
        // The fields start at index one, as index zero is for the key,
        // which we don't have.
        //

        // Loop thru each line in the INI_SEC_WBOM_PREINSTALL INF section.
        //
        for ( bRet = SetupFindFirstLine(hInf, INI_SEC_WBOM_PREINSTALL, NULL, &InfContext);
              bRet;
              bRet = SetupFindNextLine(&InfContext, &InfContext) )
        {
            // Clear the app structure.
            //
            ZeroMemory(&app, sizeof(APPENTRY));
            bBadApp = FALSE;

            // Get the AppName.
            //
            SetupGetStringField(&InfContext, 1, app.szDisplayName, AS(app.szDisplayName), NULL);

            // Get Command line path.
            //
            SetupGetStringField(&InfContext, 2, app.szSourcePath, AS(app.szSourcePath), NULL);

            // Check to see if this is an internal app.
            //
            if ( app.szDisplayName[0] &&
                 AppInternal(app.szDisplayName) )
            {
                SETBIT(app.dwFlags, APP_FLAG_INTERNAL, TRUE);
            }

            // By default this is not an advanced section type, so this is set to
            // undefined.
            //
            app.itSectionType = installtechUndefined;

            // Get advanced section type if there is one
            //
            szIniVal[0] = NULLCHR;
            SetupGetStringField(&InfContext, 3, szIniVal, AS(szIniVal), NULL);
            if ( szIniVal[0] )
            {
                DWORD dwIndex;

                // Lets make sure this has a valid section type.
                //                
                for ( dwIndex = 0; ( dwIndex < AS(g_cSectionTypes) ) && ( installtechUndefined == app.itSectionType ); dwIndex++ )
                {
                    if ( lstrcmpi(szIniVal, g_cSectionTypes[dwIndex].lpszDescription) == 0 )
                        app.itSectionType = g_cSectionTypes[dwIndex].InstallTech;
                }

                // Not a vallid app entry if it is still undefined at this point.
                //
                if ( installtechUndefined != app.itSectionType )
                {
                    INSTALLTYPE itInstallType = installtypeStandard;
                    LPTSTR      lpEnd;

                    // Since this is an advanced section type, the command line
                    // is actually the section name.
                    //
                    lstrcpyn(app.szSectionName, app.szSourcePath, AS(app.szSectionName));
                    app.szSourcePath[0] = NULLCHR;

                    // Now get the install type parameter.
                    //
                    szIniVal[0] = NULLCHR;
                    GetPrivateProfileString(app.szSectionName, INI_KEY_WBOM_INSTALLTYPE, NULLSTR, szIniVal, AS(szIniVal), lpIniFile);

                    // Test to see if we are staging this app.
                    //                
                    for ( dwIndex = 0; ( dwIndex < AS(g_cInstallTypes) ) && ( installtypeStandard == itInstallType ); dwIndex++ )
                    {
                        if ( lstrcmpi(szIniVal, g_cInstallTypes[dwIndex].lpszDescription) == 0 )
                            itInstallType = g_cInstallTypes[dwIndex].InstallType;
                    }

                    //
                    // Here we read in all the settings that are either in the staged
                    // or the standard section.
                    //

                    // Get the source path.
                    //
                    GetPrivateProfileString(app.szSectionName, INI_KEY_WBOM_SOURCEPATH, NULLSTR, app.szSourcePath, AS(app.szSourcePath), lpIniFile);

                    // Get the settings specific to the type of install.
                    //
                    switch ( itInstallType )
                    {
                        case installtypeStandard:
                            break;

                        case installtypeStage:

                            // Set this bit so we know it is a staged install.
                            //
                            SETBIT(app.dwFlags, APP_FLAG_STAGE, TRUE);

                            // Need check to see if we need to chop off the staging part of
                            // the section name.
                            //
                            lpEnd = (app.szSectionName + lstrlen(app.szSectionName)) - (lstrlen(szIniVal) + 1);
                            if ( ( lstrlen(app.szSectionName) > lstrlen(szIniVal) ) &&
                                 ( _T('.') == *lpEnd ) &&
                                 ( lstrcmpi(CharNext(lpEnd), szIniVal) == 0 ) )
                            {
                                *lpEnd = NULLCHR;
                            }
                            break;

                        case installtypeAttach:
                        case installtypeDetach:

                            // If it is attach or detach, then we didn't write the setting and
                            // the user must have manually edited the file.  Right now we can't
                            // handle this so it will just not show up in our list.
                            //
                            // TODO: We probably can be a little smarter about this.
                            //
                            bBadApp = TRUE;
                            break;
                    }

                    // Now get the rest of the settings if we are to continue.
                    //
                    if ( !bBadApp )
                    {
                        // If were are staging, look in the attach section for all
                        // of the following settings.
                        //
                        if ( GETBIT(app.dwFlags, APP_FLAG_STAGE) )
                        {
                            // Need the end of the section for staged installs.
                            //
                            lpEnd = app.szSectionName + lstrlen(app.szSectionName);

                            hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(app.szSectionName)), STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_ATTACH);
                        }
                        else
                            lpEnd = NULL;

                        // Get the setup file.
                        //
                        GetPrivateProfileString(app.szSectionName, INI_KEY_WBOM_SETUPFILE, NULLSTR, app.szSetupFile, AS(app.szSetupFile), lpIniFile);

                        // Get target path (only really used for staged installs).
                        //
                        GetPrivateProfileString(app.szSectionName, INI_KEY_WBOM_TARGETPATH, NULLSTR, app.szStagePath, AS(app.szStagePath), lpIniFile);

                        // Also get the command line arguments.
                        //
                        GetPrivateProfileString(app.szSectionName, INI_KEY_WBOM_CMDLINE, NULLSTR, app.szCommandLine, AS(app.szCommandLine), lpIniFile);

                        // Get the INF key if it is there.
                        //
                        GetPrivateProfileString(app.szSectionName, INI_KEY_WBOM_SECTIONNAME, NULLSTR, app.szInfSectionName, AS(app.szInfSectionName), lpIniFile);

                        // Get the reboot key.
                        //
                        szIniVal[0] = NULLCHR;
                        GetPrivateProfileString(app.szSectionName, INI_KEY_WBOM_REBOOT, NULLSTR, szIniVal, AS(szIniVal), lpIniFile);
                        if ( szIniVal[0] && ( LSTRCMPI( szIniVal, WBOM_YES) == 0 ) )
                            SETBIT(app.dwFlags, APP_FLAG_REBOOT, TRUE);

                        // Make sure the section name goes back to the proper format.
                        //
                        if ( lpEnd )
                            *lpEnd = NULLCHR;
                    }
                }
                else
                    bBadApp = TRUE;

            }
            else
            {
                DWORD   dwArgs;
                LPTSTR  *lpArg,
                        lpFilePart;
                // ISSUE-2002/02/27-stelo,swamip - Should initialize pointers before passing to GetLineArgs
                //
                
                // Need to split the command line into the setup file and command
                // arguments.  Call GetLineArgs() to convert the line buffer into
                // a list of arguments.
                //
                if ( (dwArgs = GetLineArgs(app.szSourcePath, &lpArg, &lpFilePart)) > 0 )
                {
                    // We need a pointer to a string with just the args.
                    //
                    if ( ( dwArgs > 1 ) && lpFilePart )
                        lstrcpyn(app.szCommandLine, lpFilePart, AS(app.szCommandLine));

                    // Use the first arg for our file name.
                    //
                    lstrcpyn(app.szSourcePath, lpArg[0], AS(app.szSourcePath));

                    // Now free the string and list of points returned.
                    //
                    FREE(*lpArg);
                    FREE(lpArg);
                }

                // Now need to split the file name from the source path.  If it fails,
                // oh well... no setup file.  That is bad but what can you do.
                //
                if ( GetFullPathName(app.szSourcePath, AS(app.szSetupFile), app.szSetupFile, &lpFilePart) &&
                     app.szSetupFile[0] &&
                     lpFilePart )
                {
                    DWORD dwPathLen = lstrlen(app.szSourcePath) - lstrlen(lpFilePart);

                    lstrcpyn(app.szSetupFile, app.szSourcePath + dwPathLen, AS(app.szSetupFile));
                    app.szSourcePath[dwPathLen] = NULLCHR;
                }
            }

            // Only add it to the list if it is a valid app entry.
            //
            if ( !bBadApp )
                ManageAppList(&lpAppHead, &app, APP_ADD);
        }

        // We are done, so close the INF file.
        //
        SetupCloseInfFile(hInf);
    }

    // Return the head pointer of the list we allocated with the apps
    // read in... or NULL if there were no apps.
    //
    return lpAppHead;
}

void CloseAppList(LPAPPENTRY lpAppHead)
{
    ManageAppList(&lpAppHead, NULL, 0);
}

BOOL SaveAppList(LPAPPENTRY lpAppHead, LPTSTR lpszIniFile, LPTSTR lpszAltIniFile)
{
    LPAPPENTRY  lpApp;
    LPTSTR      lpSection,
                lpIndex;
    TCHAR       szKey[MAX_STRING],
                szData[MAX_STRING];
    UINT        uIndex = 1;
    HRESULT hrPrintf;

    // Dynamically allocate our section buffer since it is quite large.
    //
    if ( (lpSection = MALLOC(MAX_SECTION * sizeof(TCHAR))) == NULL )
    {
        return FALSE;
    }
  
    // Delete the current INF_SEC_RUNONCE and INI_SEC_WBOM_PREINSTALL.
    // sections.  Passing NULL for the key name will do the trick.
    //
    WritePrivateProfileString(INI_SEC_WBOM_PREINSTALL, NULL, NULL, lpszIniFile);
    WritePrivateProfileString(INI_SEC_WBOM_PREINSTALL, NULL, NULL, lpszAltIniFile);

    // Loop through all the items so we can write them back out to the INF file.
    //
    lpIndex = lpSection;
    for ( lpApp = lpAppHead; lpApp; lpApp = lpApp->lpNext, uIndex++ )
    {
        TCHAR   szDisplayName[MAX_DISPLAYNAME * 2],
                szCommandLine[MAX_CMDLINE * 2],
                szSetupPathFile[MAX_PATH];
        LPTSTR  lpTest;

        // We have to double any quotes in the string so that
        // when we read them back they look the same way we
        // want them to.
        //
        StrCpyDbl(szDisplayName, lpApp->szDisplayName);
        StrCpyDbl(szCommandLine, lpApp->szCommandLine);

        // We also have to make sure the source path doesn't have a trailing backslash,
        // otherwise the stupid setupapi apis think that the next line is supposed to be
        // added onto the source path line.
        //
        if ( ( lpTest = CharPrev(lpApp->szSourcePath, lpApp->szSourcePath + lstrlen(lpApp->szSourcePath)) ) &&
             ( _T('\\') == *lpTest ) )
        {
            // Get rid of the trailing backslash.
            //
            *lpTest = NULLCHR;
        }

        switch ( lpApp->itSectionType )
        {
            case installtechUndefined:

                // Check if there is a section name.
                //
                if ( lpApp->szSectionName[0] )
                {
                    // There is, so this must have been an advanced
                    // type install and they changed it to a standard one.
                    // Need to remove an sections that might be around.
                    //
                    CleanupSections(lpApp->szSectionName, TRUE);
                    CleanupSections(lpApp->szSectionName, FALSE);
                    lpApp->szSectionName[0] = NULLCHR;
                }

                // Now write the one line entry to oem runonce.
                //
                lstrcpyn(szSetupPathFile, lpApp->szSourcePath, AS(szSetupPathFile));
                AddPathN(szSetupPathFile, lpApp->szSetupFile,AS(szSetupPathFile));

                hrPrintf=StringCchPrintf(lpIndex, (MAX_SECTION-(lpIndex-lpSection)),
                    INF_KEY_PREINSTALL, szDisplayName, szSetupPathFile, szCommandLine);
                lpIndex+= lstrlen(lpIndex)+1;
                break;

            case installtechApp:
            case installtechMSI:
            case installtechINF:
            {
                LPCTSTR lpSectionType;
                DWORD   dwIndex;

                // Lets find the string to use for this section type.
                //
                lpSectionType = NULL;
                for ( dwIndex = 0; ( dwIndex < AS(g_cSectionTypes) ) && ( NULL == lpSectionType ); dwIndex++ )
                {
                    if ( lpApp->itSectionType == g_cSectionTypes[dwIndex].InstallTech )
                        lpSectionType = g_cSectionTypes[dwIndex].lpszDescription;
                }

                // We can only save this app if we have a section type.
                //
                if ( lpSectionType )
                {
                    LPTSTR lpEnd = NULL;

                    // Make sure we have a section name to write to.
                    //
                    if ( NULLCHR == lpApp->szSectionName[0] )
                    {
                        BOOL    bFound  = FALSE;
                        DWORD   dwCount = 1;
                        TCHAR   szBuffer[256];

                        // Try to find a section name that isn't used.
                        //
                        do
                        {
                            // First check if the section exists.
                            //
                            hrPrintf=StringCchPrintf(lpApp->szSectionName, AS(lpApp->szSectionName), STR_INI_SEC_ADVAPP, lpSectionType, dwCount++);
                              if ( GetPrivateProfileSection(lpApp->szSectionName, szBuffer, AS(szBuffer), lpszIniFile) == 0 )
                            {
                                // Section doesn't exist, so make sure that the
                                // section + .stage also doesn't exist.
                                //
                                lpEnd = lpApp->szSectionName + lstrlen(lpApp->szSectionName);
                                hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(lpApp->szSectionName)), STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_STAGE);
                                bFound = ( GetPrivateProfileSection(lpApp->szSectionName, szBuffer, AS(szBuffer), lpszIniFile) == 0 );
                                *lpEnd = NULLCHR;
                                lpEnd = NULL;
                            }
                        }
                        while ( !bFound && ( dwCount < 100 ) );
                    }
                    else
                    {
                        // We do this because the user might have changed
                        // this app to a staged or not staged after it was
                        // already saved to the winbom.  This cleans up any
                        // sections we don't want laying around.
                        //
                        CleanupSections(lpApp->szSectionName, GETBIT(lpApp->dwFlags, APP_FLAG_STAGE));
                    }

                    // If we are staging, we have three sections to write out first.
                    //
                    if ( GETBIT(lpApp->dwFlags, APP_FLAG_STAGE) )
                    {
                        // First save off the end pointer.
                        //
                        lpEnd = lpApp->szSectionName + lstrlen(lpApp->szSectionName);

                        //
                        // Lets write out the attach section first.
                        //

                        // Create the attach section name first.
                        //
                        hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(lpApp->szSectionName)),  STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_ATTACH);

                        // First write out the type of install (attach in this case).
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, INI_VAL_WBOM_ATTACH, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, INI_VAL_WBOM_ATTACH, lpszAltIniFile);

                        // Always write out the target path to the attach section.
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_TARGETPATH, lpApp->szStagePath, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_TARGETPATH, lpApp->szStagePath, lpszAltIniFile);
                    }
                    else
                    {
                        // Must first write out the type of install (for standard we just remove the keys).
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, NULL, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, NULL, lpszAltIniFile);

                        // Always write out the source path for standard.
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SOURCEPATH, lpApp->szSourcePath, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SOURCEPATH, lpApp->szSourcePath, lpszAltIniFile);
                    }

                    //
                    // These are the settings writen the same for both attach and standard.
                    //

                    // Always write out the setup program.
                    //
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SETUPFILE, lpApp->szSetupFile, lpszIniFile);
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SETUPFILE, lpApp->szSetupFile, lpszAltIniFile);

                    // Always write out the command line arguments.
                    //
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_CMDLINE, lpApp->szCommandLine, lpszIniFile);
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_CMDLINE, lpApp->szCommandLine, lpszAltIniFile);

                    // Write out the reboot key if specified (remove if not).
                    // This is only done in attach, we don't give this option
                    // in the sections so don't touch it.
                    //
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_REBOOT, GETBIT(lpApp->dwFlags, APP_FLAG_REBOOT) ? WBOM_YES : NULL, lpszIniFile);
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_REBOOT, GETBIT(lpApp->dwFlags, APP_FLAG_REBOOT) ? WBOM_YES : NULL, lpszAltIniFile);

                    // Write out the inf section name key if specified this is
                    // an INF install (remove if not).
                    // This is only done in attach, we don't wrtie this option
                    // in the sections so don't touch it.
                    //
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SECTIONNAME, ( installtechINF == lpApp->itSectionType ) ? lpApp->szInfSectionName : NULL, lpszIniFile);
                    WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SECTIONNAME, ( installtechINF == lpApp->itSectionType ) ? lpApp->szInfSectionName : NULL, lpszAltIniFile);

                    // If we are staging, we still have two more sections to write out.
                    //
                    if ( GETBIT(lpApp->dwFlags, APP_FLAG_STAGE) )
                    {
                        //
                        // Here is where we write out the detach section.
                        //

                        // Create the detach section next.
                        //
                        hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(lpApp->szSectionName)), STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_DETACH);

                        // First write out the type of install (detach in this case).
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, INI_VAL_WBOM_DETACH, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, INI_VAL_WBOM_DETACH, lpszAltIniFile);

                        // Always write out the target path to the detach section.
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_TARGETPATH, lpApp->szStagePath, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_TARGETPATH, lpApp->szStagePath, lpszAltIniFile);

                        //
                        // Here is where we write out the stage section.
                        //

                        // Create the stage section next.
                        //
                        hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(lpApp->szSectionName)), STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_STAGE);

                        // First write out the type of install (stage in this case).
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, INI_VAL_WBOM_STAGE, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_INSTALLTYPE, INI_VAL_WBOM_STAGE, lpszAltIniFile);

                        // Always write out the target path to the stage section.
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_TARGETPATH, lpApp->szStagePath, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_TARGETPATH, lpApp->szStagePath, lpszAltIniFile);

                        // Always write out the source path to the stage section.
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SOURCEPATH, lpApp->szSourcePath, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SOURCEPATH, lpApp->szSourcePath, lpszAltIniFile);

                        // Only for MSI do we write out the setup file to the stage section.
                        //
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SETUPFILE, ( installtechMSI == lpApp->itSectionType ) ? lpApp->szSetupFile : NULL, lpszIniFile);
                        WritePrivateProfileString(lpApp->szSectionName, INI_KEY_WBOM_SETUPFILE, ( installtechMSI == lpApp->itSectionType ) ? lpApp->szSetupFile : NULL, lpszAltIniFile);
                    }

                    // Write out the line now that we know we have a section name
                    // we are going to use first.
                    //
                   hrPrintf=StringCchPrintf(lpIndex, (MAX_SECTION-(lpIndex-lpSection)),
                          INF_KEY_PREINSTALL_ADV, szDisplayName, lpApp->szSectionName, lpSectionType);
                   lpIndex+= lstrlen(lpIndex)+1;

                    // Make sure the section name goes back to the proper format.
                    //
                    if ( lpEnd )
                        *lpEnd = NULLCHR;

                }
                break;
            }
        }

        // Skip ahead so we don't overwrite the null terminator
        //
        
    }

    // Double null terminate the section end, write the section, and then free the buffer.
    //
    *lpIndex = NULLCHR;
    WritePrivateProfileSection(INI_SEC_WBOM_PREINSTALL, lpSection, lpszIniFile);
    WritePrivateProfileSection(INI_SEC_WBOM_PREINSTALL, lpSection, lpszAltIniFile);
    FREE(lpSection);

    return TRUE;
}

BOOL InsertApp(LPAPPENTRY * lplpAppHead, LPAPPENTRY lpApp)
{
    return ManageAppList(lplpAppHead, lpApp, APP_ADD) ? TRUE : FALSE;
}

BOOL RemoveApp(LPAPPENTRY * lplpAppHead, LPAPPENTRY lpApp)
{
    ManageAppList(lplpAppHead, lpApp, APP_DELETE);
    return TRUE;
}

LRESULT CALLBACK AppInstallDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( wParam )
            {
                case IDC_APPLIST:

                    // Notify message from the list view control.
                    //
                    OnListViewNotify(hwnd, uMsg, wParam, (NMLVDISPINFO*) lParam);
                    break;

                default:

                    switch ( ((NMHDR FAR *) lParam)->code )
                    {
                        case PSN_KILLACTIVE:
                        case PSN_RESET:
                        case PSN_WIZBACK:
                        case PSN_WIZFINISH:
                            break;

                        case PSN_WIZNEXT:
                            if ( !SaveData(hwnd) )
                                WIZ_FAIL(hwnd);
				break;

                        case PSN_QUERYCANCEL:
                            WIZ_CANCEL(hwnd);
                            break;

                        case PSN_HELP:
                            WIZ_HELP();
                            break;

                        case PSN_SETACTIVE:
                            g_App.dwCurrentHelp = IDH_APPINSTALL;

                            WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                            // Press next if the user is in auto mode
                            //
                            WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                            break;

                        default:
                            return FALSE;
                    }
            }
            break;

        case WM_DESTROY:

            // Free the memory for the app list.
            //
            CloseAppList(g_lpAppHead);
            g_lpAppHead = NULL;

            // Destroy the menu we loaded on INIT_DIALOG.
            //
            DestroyMenu(g_hMenu);

            if(g_hArrowUp)
                DestroyIcon(g_hArrowUp);

            if(g_hArrowDn)
                DestroyIcon(g_hArrowDn);

            return FALSE;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

BOOL CALLBACK OneAppDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch ( uMsg )
    {
        case WM_INITDIALOG:
        {
            LPAPPENTRY  lpApp = (LPAPPENTRY) lParam;
            DWORD       dwIndex;
            BOOL        bFound;
            TCHAR       szFullPath[MAX_PATH];

            // Save our APPENTRY pointer.
            //
            SetWindowLongPtr(hwnd, DWLP_USER, lParam);

            // We have to have an app struct.
            //
            if ( NULL == lpApp )
                return FALSE;

            // Limit the text which can be entered.
            //
            SendDlgItemMessage(hwnd, IDC_APP_NAME , EM_LIMITTEXT, AS(lpApp->szDisplayName) - 1, 0L);
            SendDlgItemMessage(hwnd, IDC_APP_PATH , EM_LIMITTEXT, AS(lpApp->szSetupFile) - 1, 0L);
            SendDlgItemMessage(hwnd, IDC_APP_ARGS , EM_LIMITTEXT, AS(lpApp->szCommandLine) - 1, 0L);
            SendDlgItemMessage(hwnd, IDC_APP_INF_SECTION , EM_LIMITTEXT, AS(lpApp->szInfSectionName) - 1, 0L);
            SendDlgItemMessage(hwnd, IDC_APP_STAGEPATH , EM_LIMITTEXT, AS(lpApp->szStagePath) - 1, 0L);

            // Make the full path with the setup file and source path.
            //
            lstrcpyn(szFullPath, lpApp->szSourcePath, AS(szFullPath));

            AddPathN(szFullPath, lpApp->szSetupFile,AS(szFullPath));

            // Set the edit and check box controls.
            //
            SetWindowText(GetDlgItem(hwnd, IDC_APP_NAME), lpApp->szDisplayName);
            SetWindowText(GetDlgItem(hwnd, IDC_APP_PATH), szFullPath);
            SetWindowText(GetDlgItem(hwnd, IDC_APP_ARGS), lpApp->szCommandLine);
            SetWindowText(GetDlgItem(hwnd, IDC_APP_INF_SECTION), lpApp->szInfSectionName);
            SetWindowText(GetDlgItem(hwnd, IDC_APP_STAGEPATH), lpApp->szStagePath);

            // Start with the standard view if this isn't an advanced install.
            //
            if ( installtechUndefined == lpApp->itSectionType )
                AdvancedView(hwnd, TRUE);

            // Select the correct radio button (select a default one first in case we
            // don't find the setting in the array, meaning it is installtechUndefined).
            //
            CheckRadioButton(hwnd, IDC_APP_TYPE_GEN, IDC_APP_TYPE_INF, IDC_APP_TYPE_GEN);
            bFound = FALSE;
            for ( dwIndex = 0; ( dwIndex < AS(g_crbChecked) ) && !bFound ; dwIndex++ )
            {
                if ( bFound = ( lpApp->itSectionType == g_crbChecked[dwIndex].itSectionType ) )
                    CheckRadioButton(hwnd, IDC_APP_TYPE_GEN, IDC_APP_TYPE_INF, g_crbChecked[dwIndex].iButtonId);
            }

            // Set the check boxes that are set in the app struct.
            //
            CheckDlgButton(hwnd, IDC_APP_REBOOT, GETBIT(lpApp->dwFlags, APP_FLAG_REBOOT) ? BST_CHECKED : BST_UNCHECKED);
            CheckDlgButton(hwnd, IDC_APP_STAGE, GETBIT(lpApp->dwFlags, APP_FLAG_STAGE) ? BST_CHECKED : BST_UNCHECKED);

            // Make sure the right controls are enable/disabled.
            //
            EnableControls(hwnd, IDC_APP_STAGE);
            EnableControls(hwnd, IDC_APP_TYPE_GEN);

            // Always return false to WM_INITDIALOG.
            //
            return FALSE;
        }
      
        case WM_COMMAND:

            switch ( LOWORD(wParam) )
            {
                case IDOK:

                    // Make sure we have valid info and then save to the app struct and fall
                    // through to end the dialog.
                    //
                    if ( !SaveOneApp(hwnd, (LPAPPENTRY) GetWindowLongPtr(hwnd, DWLP_USER)) )
                        break;

                case IDCANCEL:
                    EndDialog(hwnd, LOWORD(wParam));
                    break;

                case IDC_APP_ADVANCED:
                    AdvancedView(hwnd, TRUE);
                    break;

                case IDC_APP_STAGE:
                case IDC_APP_TYPE_GEN:
                case IDC_APP_TYPE_MSI:
                case IDC_APP_TYPE_INF:
                    EnableControls(hwnd, LOWORD(wParam));
                    break;

                case IDC_APP_BROWSE:
                {
                    TCHAR szFileName[MAX_PATH] = NULLSTR;
                    GetDlgItemText(hwnd, IDC_APP_PATH, szFileName, AS(szFileName));

                    if ( BrowseForFile(hwnd, IDS_BROWSE, IDS_INSTFILES, IDS_EXE, szFileName, AS(szFileName), g_App.szBrowseFolder, 0) ) 
                    {
                        LPTSTR lpFilePart = NULL;

                        // Save the last browse directory.
                        //
                        if ( GetFullPathName(szFileName, AS(g_App.szBrowseFolder), g_App.szBrowseFolder, &lpFilePart) && g_App.szBrowseFolder[0] && lpFilePart )
                            *lpFilePart = NULLCHR;

                        // Try to change the path from a local path
                        // to a network one.
                        //
                        FindUncPath(szFileName, AS(szFileName));

                        // Set the returned text into our edit box.
                        //
                        SetDlgItemText(hwnd, IDC_APP_PATH, szFileName);
                    }
                    break;
                }
            }
            return FALSE;

       default:
          return FALSE;
    }

    return TRUE ;
}

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND        hwndLV = GetDlgItem(hwnd, IDC_APPLIST);
    HIMAGELIST  hImages;
    TCHAR       szBuffer[256];
    LPTSTR      lpIniFile = GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szWinBomIniFile;
    LVCOLUMN    col;
    RECT        rc;
    UINT        uCount = 0,
                uIndex;


    //
    // First do some of the basic init stuff.
    //

    // Write out the version information for the OPKWIZ INI file so Windows thinks it is an INF
    //
    WritePrivateProfileString(INI_SEC_VERSION, INI_KEY_SIG, INI_VAL_SIG, g_App.szOpkWizIniFile);
    WritePrivateProfileString(INI_SEC_VERSION, INI_KEY_SIG, INI_VAL_SIG, g_App.szWinBomIniFile);

    // Load the right click menu.
    //
    g_hMenu = LoadMenu(g_App.hInstance, MAKEINTRESOURCE(IDR_LVRCLICK));


    //
    // Load the user credential stuff.
    //

    // Make sure the option is enabled.
    //
    if ( GetPrivateProfileInt(INI_SEC_GENERAL, INI_KEY_APPCREDENTIALS, 0, g_App.szOpkWizIniFile) )
    {
        // Check the button.
        //
        CheckDlgButton(hwnd, IDC_APP_CREDENTIALS, BST_CHECKED);

        // NTRAID#NTBUG9-531482-2002/02/27-stelo,swamip - Password stored in plain text
        //
        // Get the user name first.
        //
        szBuffer[0] = NULLCHR;
        GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_USERNAME, NULLSTR, szBuffer, AS(szBuffer), lpIniFile);
        SetDlgItemText(hwnd, IDC_APP_USERNAME, szBuffer);

        // Then the password and confirmation password.
        //
        szBuffer[0] = NULLCHR;
        GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_PASSWORD, NULLSTR, szBuffer, AS(szBuffer), lpIniFile);
        SetDlgItemText(hwnd, IDC_APP_PASSWORD, szBuffer);
        SetDlgItemText(hwnd, IDC_APP_CONFIRM, szBuffer);
    }


    //
    // Init the List view control (columns and titles).
    //

    // At this point, we have no apps installed so disable edit
    // and delete buttons. Add should always be available.
    //
    EnableWindow(GetDlgItem(hwnd, IDC_APPINST_EDIT),   FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_APPINST_DELETE), FALSE);

    // Enable/Disable the arrow buttons based on the position of the app in the list
    //
    EnableWindow(GetDlgItem(hwnd, IDC_APP_UP), FALSE);
    EnableWindow(GetDlgItem(hwnd, IDC_APP_DOWN), FALSE);

    // Get an image list for the list view control.  We will start with a default one.
    //
    if ( (hImages = ImageList_Create(16, 16, ILC_MASK, 2, 0)) )
    {
        ImageList_AddIcon(hImages, LoadImage(g_App.hInstance, MAKEINTRESOURCE(IDI_USERAPP), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR));
        ListView_SetImageList(hwndLV, hImages, LVSIL_SMALL);
    }

    // Set extended LV style for whole line selection.
    //
    SendMessage(hwndLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    // Setup the unchanging header values.
    //
    GetClientRect(hwndLV, &rc);
    ZeroMemory(&col, sizeof(LVCOLUMN));
    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.pszText = szBuffer;

    // Setup all the column headers.
    //
    for ( uIndex = 0; uIndex < NUM_COLUMNS; uIndex++ )
    {
        // Load the header string for this column.
        //
        LoadString(NULL, g_cuHeader[uIndex], szBuffer, STRSIZE(szBuffer));

        // Determine the width of the header.  The last width should be marked
        // with zero so we can use up the rest of the space.
        //
        if ( ( g_cuWidth[uIndex] == 0 ) &&
             ( (uIndex + 1) == NUM_COLUMNS) )
        {
            // This is the last item and it's width is zero, so we use up the
            // rest of the space in the list view control.
            //
            col.cx = (INT) (rc.right - uCount - GetSystemMetrics(SM_CYHSCROLL));
        }
        else
        {
            // The default is to make the column width what is in g_cuWidth[x].
            //
            col.cx = (INT) (rc.right * g_cuWidth[uIndex] * .01);
            uCount += col.cx;
        }

        // Set rest of the column settings.
        //
        col.fmt = g_cuFormat[uIndex];
        col.iSubItem = uIndex;

        // Insert the column.
        //
        ListView_InsertColumn(hwndLV, uIndex, &col);
    }


    //
    // Read app info from winbom.ini and fill the list view.
    //

    g_lpAppHead = OpenAppList(lpIniFile);


    //
    // Now finally fill the list view with all the apps it our global data structure.
    //

    // Loop through the app entries we have now.
    //
    RefreshAppList(hwndLV, g_lpAppHead);

    // Set the images on the buttons
    //
    if(g_hArrowUp = LoadImage(g_App.hInstance, MAKEINTRESOURCE(IDI_ARROWUP), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR))
        SendMessage(GetDlgItem(hwnd, IDC_APP_UP),BM_SETIMAGE, IMAGE_ICON, (LPARAM)g_hArrowUp);

    if(g_hArrowDn = LoadImage(g_App.hInstance, MAKEINTRESOURCE(IDI_ARROWDN), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR))
        SendMessage(GetDlgItem(hwnd, IDC_APP_DOWN),BM_SETIMAGE, IMAGE_ICON, (LPARAM)g_hArrowDn);

    // Make sure the controls are enabled/disable correctly.
    //
    EnableControls(hwnd, IDC_APP_CREDENTIALS);
    
    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    APPENTRY    app;
    HWND        hwndLV = GetDlgItem(hwnd, IDC_APPLIST);
    LVITEM      lvItem;

    switch ( id )
    {       
        case ID_ADD:
        case IDC_APPINST_ADD:
            //
            // Two ways to get here - add button, or right-click add.
            //
	
            // Zero out our app structure and set the default values.
            //
            ZeroMemory(&app, sizeof(APPENTRY));
            app.itSectionType = installtechUndefined;

            // Exec dialog to get info, pass it our app struct.  The dialog
            // will fill it in and make sure it is valid.
            //
            if ( DialogBoxParam(g_App.hInstance, MAKEINTRESOURCE(IDD_APP), hwnd, (DLGPROC) OneAppDlgProc, (LPARAM) &app) == IDOK )
            {
                LPAPPENTRY lpApp;
	
                // They clicked OK, so add a new entry to our link list (the
                // function allocs a new struct and copies from the one we
                // pass in so it is safe to blow it away).  Make sure it was
                // added and inserted into the list.  If the add fails, we
                // are out of memory.
                //
                if ( lpApp = ManageAppList(&g_lpAppHead, &app, APP_ADD) )
                    AddAppToListView(GetDlgItem(hwnd, IDC_APPLIST), lpApp);
                else
                {
                    MsgBox(GetParent(hwnd), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
                    WIZ_EXIT(hwnd);
                }

                RefreshAppList(hwndLV, g_lpAppHead);
            }
            break;
                
        case ID_EDIT:
        case IDC_APPINST_EDIT:

            //
            // Two ways to get here - edit button, or right-click edit.
            //

            // Get the selected item.
            //
            ZeroMemory(&lvItem, sizeof(LVITEM));
            if ( (lvItem.iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED)) >= 0 )
            {
                // Retrieve lParam for selected item which is the
                // corresponding APPENTRY item.
                //
                lvItem.mask = LVIF_PARAM;
                ListView_GetItem(hwndLV, &lvItem);

                // Pop up dialog inited with the app entry.
                //
                if ( lvItem.lParam && ( DialogBoxParam(g_App.hInstance, MAKEINTRESOURCE(IDD_APP), hwnd, (DLGPROC) OneAppDlgProc, lvItem.lParam) == IDOK ) )
                {
                    // This is to fix the problem where we would always put the item we
                    // just edited at the bottom of the list.  I'm going to leave all the
                    // old code in here, because it seems to me that we would have done
                    // all this crap for some reason.  But for now it seems to work fine
                    // this way.
                    //
                    RefreshAppList(hwndLV, g_lpAppHead);
                    ListView_SetItemState(hwndLV, lvItem.iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                    SetFocus(hwndLV);

                    /* Old code... just be careful if you want to try to use it again becase
                       we don't support the LPSTR_TEXTCALLBACK anymore.

                    // Hmm, the following wierdness is because the listview
                    // seems to remember the size of the first thing we put 
                    // in it and will truncate if we edit and make the thing
                    // larger.  Resetting the pszText field seems to have it
                    // recalc this buffer.
                    //
                    CopyMemory(&app, (LPAPPENTRY) lvItem.lParam, sizeof(APPENTRY));

                    ManageAppList(&g_lpAppHead, ((LPAPPENTRY) lvItem.lParam), APP_DELETE);
                    ManageAppList(&g_lpAppHead, &app, APP_ADD);

                    lvItem.mask = LVIF_TEXT;
                    lvItem.pszText = LPSTR_TEXTCALLBACK;
                    ListView_SetItem(hwndLV, &lvItem);

                    // The app entry is updated by the Dialog, so just tell 
                    // list view control to redraw.  The item gets deslected 
                    // at this point so I manually select it and give it focus
                    //
                    ListView_SetItemState(hwndLV, lvItem.iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                    ListView_RedrawItems(hwndLV, lvItem.iItem, lvItem.iItem);
                    SetFocus(hwndLV);

                    RefreshAppList(hwndLV, g_lpAppHead);

                    */
                }
            }

            break;
                
        case ID_DELETE:
        case IDC_APPINST_DELETE:

            //
            // Two ways to get here - delete button, or right-click delete.
            //

            // Get the selected item.
            //
            ZeroMemory(&lvItem, sizeof(LVITEM));
            if ( (lvItem.iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED)) >= 0 )
            {
                // Retrieve lParam for selected item which is the
                // corresponding APPENTRY item.
                //
                lvItem.mask = LVIF_PARAM;
                ListView_GetItem(hwndLV, &lvItem);

                // Make sure we clean out the sections that could be in the ini files
                // before we nuke the entry.
                //
                CleanupSections(((LPAPPENTRY) lvItem.lParam)->szSectionName, TRUE);
                CleanupSections(((LPAPPENTRY) lvItem.lParam)->szSectionName, FALSE);
                
                // Delete from link list and the list view.
                //
                ManageAppList(&g_lpAppHead, (LPAPPENTRY) lvItem.lParam, APP_DELETE);
                ListView_DeleteItem(hwndLV, lvItem.iItem);
            }

            break;
                
        case IDC_APP_UP:
        case IDC_APP_DOWN:
            {
                LPAPPENTRY lpApp;

                // Get the selected item.
                //
                ZeroMemory(&lvItem, sizeof(LVITEM));
                if ( (lvItem.iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED)) >= 0 )
                {
                    // Retrieve lParam for selected item which is the
                    // corresponding APPENTRY item.
                    //
                    lvItem.mask = LVIF_PARAM;
                    if (id==IDC_APP_UP)
                        lvItem.iItem--;
                    ListView_GetItem(hwndLV, &lvItem);
                }
            
                if(lpApp = (LPAPPENTRY) lvItem.lParam)
                {
                    ManageAppList(&g_lpAppHead, lpApp, APP_MOVE_DOWN);
                    RefreshAppList(hwndLV, g_lpAppHead);
                    ListView_SetItemState(hwndLV, lvItem.iItem + ((id==IDC_APP_UP) ? 0 : 1), LVIS_SELECTED | LVIS_FOCUSED, 
                        LVIS_SELECTED | LVIS_FOCUSED);

                    // Make sure the listview regains focus otherwise the alt+n won't
                    // work to navigate to next page
                    //
                    SetFocus(hwndLV);
                }
            }
            break;

        case IDC_APP_CREDENTIALS:
            EnableControls(hwnd, id);
            break;
    }
}

static LRESULT OnListViewNotify(HWND hwnd, UINT uMsg, WPARAM wParam, NMLVDISPINFO * lpnmlvdi)
{
    static TCHAR    szYes[32]   = NULLSTR,
                    szNo[32]    = NULLSTR;

    HWND            hwndLV      = GetDlgItem(hwnd, IDC_APPLIST);
    LPAPPENTRY      lpApp;
    POINT           ptScreen,
                    ptClient;
    HMENU           hPopupMenu;
    LVHITTESTINFO   lvHitInfo;
    LVITEM          lvItem;

    // Load the Yes/No strings into the statics.
    //
    LoadString(NULL, IDS_YES, szYes, STRSIZE(szYes));
    LoadString(NULL, IDS_NO, szNo, STRSIZE(szNo));

    // See what the notification message that was sent to the list view.
    //
    switch ( lpnmlvdi->hdr.code )
    {
        case NM_RCLICK:

            // Get cursor position, translate to client coordinates and
            // do a listview hit test.
            //
            GetCursorPos(&ptScreen);
            ptClient.x = ptScreen.x;
            ptClient.y = ptScreen.y;
            MapWindowPoints(NULL, hwndLV, &ptClient, 1);
            lvHitInfo.pt.x = ptClient.x;
            lvHitInfo.pt.y = ptClient.y;
            ListView_HitTest(hwndLV, &lvHitInfo);
            hPopupMenu = GetSubMenu(g_hMenu, 0);
            
            //
            // ISSUE-2002/02/27-stelo,swamip - Make sure the handle to the submenu is valid.
            //
            
            // Test if item was clicked.
            //
            lpApp = NULL;
            if ( lvHitInfo.flags & LVHT_ONITEM )
            {
                // Activate clicked item and bring up a popup menu.
                //
                ListView_SetItemState(hwndLV, lvHitInfo.iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);

                // Retrieve lParam for selected item which is the
                // corresponding APPENTRY item.
                //
                ZeroMemory(&lvItem, sizeof(lvItem));
                lvItem.iItem = lvHitInfo.iItem;
                lvItem.mask = LVIF_PARAM;
                ListView_GetItem(hwndLV, &lvItem);
                if ( lpApp = (LPAPPENTRY) lvItem.lParam )
                {            
                    // Enable/disable the edit menu item (always enabled).
                    //
                    EnableMenuItem(hPopupMenu, ID_EDIT, MF_BYCOMMAND | MF_ENABLED);

                    // Enable/disable the delete (disabled if not
                    // a user app).
                    //
                    EnableMenuItem(hPopupMenu, ID_DELETE, MF_BYCOMMAND | MF_ENABLED);
                }
            }

            if ( lpApp == NULL )
            {
                // User right clicked in control but not on an item, so we uncheck and gray everything except Add.
                //
                EnableMenuItem(hPopupMenu, ID_EDIT,    MF_BYCOMMAND | MF_GRAYED);
                EnableMenuItem(hPopupMenu, ID_DELETE,  MF_BYCOMMAND | MF_GRAYED);
            }

            // Show the right-click popup menu.
            //
            TrackPopupMenu(hPopupMenu, 0, ptScreen.x, ptScreen.y, 0, hwnd, NULL);

            break;

        case NM_DBLCLK:

            // Get cursor position, translate to client coordinates and
            // do a listview hittest.
            //
            GetCursorPos(&ptScreen);
            ptClient.x = ptScreen.x;
            ptClient.y = ptScreen.y;
            MapWindowPoints(NULL, hwndLV, &ptClient, 1);
            lvHitInfo.pt.x = ptClient.x;
            lvHitInfo.pt.y = ptClient.y;
            ListView_HitTest(hwndLV, &lvHitInfo);

            // Test if item was clicked.
            //
            if ( lvHitInfo.flags & LVHT_ONITEM )
            {
                // Select the item and send a message to the dialog the user wants
                // edit the selected item.
                //
                ListView_SetItemState(hwndLV, lvHitInfo.iItem, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
                SendMessage(hwnd, WM_COMMAND, ID_EDIT, 0);
            }

            break;

        /* Don't need to do this anymore because we don't need to use LPSTR_TEXTCALLBACK.

        case LVN_GETDISPINFO:

            // Display the appropriate item, getting the text from the
            // APPENTRY structure for this item.
            //
            lpApp = (LPAPPENTRY) lpnmlvdi->item.lParam;
            switch ( lpnmlvdi->item.iSubItem )
            {
                case 0: // Display Name:
                    lpnmlvdi->item.pszText = lpApp->szDisplayName;
                    break;

                case 1: // Command line:
                    lpnmlvdi->item.pszText = lpApp->szSourcePath;
                    break;
            }

            break;

        */

        case LVN_COLUMNCLICK:

            //
            // TODO:  Maybe it would be nice at this point to sort the
            //        list by the selected column
            //

            break;

        case LVN_ITEMCHANGED:

            // We capture all change messages here, although all we care
            // about is whether we are changing from an item selected to 
            // no item selected or vice-versa. However, I see no other
            // message that indicates this (like LB_SELCHANGE for Listbox).
            //
            ZeroMemory(&lvItem, sizeof(LVITEM));
            if ( (lvItem.iItem = ListView_GetNextItem(GetDlgItem(hwnd, IDC_APPLIST), -1, LVNI_SELECTED)) >= 0 )
            {
                LPAPPENTRY  lpAppPrev   = NULL,
                            lpAppSearch = NULL;

                // We need the flags for this item so we can find it in the list.
                // So retrieve lParam for selected item which is the corresponding
                // APPENTRY item.
                //
                lvItem.mask = LVIF_PARAM;
                ListView_GetItem(hwndLV, &lvItem);
                lpApp = (LPAPPENTRY) lvItem.lParam;

                // Search to see if there is a previous/next item so we can
                // enable/disable the up/down buttons.
                //
                for ( lpAppSearch = g_lpAppHead; lpAppSearch && (lpAppSearch !=lpApp); lpAppSearch = lpAppSearch->lpNext )
                {
                    lpAppPrev = lpAppSearch;
                }

                // Something is selected so enable the edit button and the delete
                // button.
                //
                EnableWindow(GetDlgItem(hwnd, IDC_APPINST_EDIT), TRUE);
                EnableWindow(GetDlgItem(hwnd, IDC_APPINST_DELETE), TRUE);

                // Enable/disable the up/down buttons.
                //
                EnableWindow(GetDlgItem(hwnd, IDC_APP_UP),(lpAppPrev ? TRUE : FALSE) );
                EnableWindow(GetDlgItem(hwnd, IDC_APP_DOWN),(lpApp->lpNext ? TRUE : FALSE) );
            }
            else
            {
                // Nothing is selected do disable these buttons.
                //
                EnableWindow(GetDlgItem(hwnd, IDC_APPINST_EDIT), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_APPINST_DELETE), FALSE);

                // Enable/Disable the arrow buttons based on the position of the app in the list
                //
                EnableWindow(GetDlgItem(hwnd, IDC_APP_UP),FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_APP_DOWN),FALSE);
            }

            break;

    }

    return 0L;
}

static BOOL SaveData(HWND hwnd)
{
    TCHAR       szUsername[256] = NULLSTR,
                szPassword[256] = _T("\"");
    BOOL        bUser = ( IsDlgButtonChecked(hwnd, IDC_APP_CREDENTIALS) == BST_CHECKED );
    HRESULT hrCat;

    // See if we need to write out credetials.  Start with the passwords
    // so we can make sure they are the same.
    //
    if ( bUser )
    {
        // First get the password and confirmation of the password and
        // make sure they match.
        //
        GetDlgItemText(hwnd, IDC_APP_PASSWORD, szPassword + 1, AS(szPassword) - 1);
        GetDlgItemText(hwnd, IDC_APP_CONFIRM, szUsername, AS(szUsername));
        if ( lstrcmp(szPassword + 1, szUsername) != 0 )
        {
            // Didn't match, so error out.
            //
            MsgBox(hwnd, IDS_ERR_CONFIRMPASSWORD, IDS_APPNAME, MB_ERRORBOX);
            SetDlgItemText(hwnd, IDC_APP_PASSWORD, NULLSTR);
            SetDlgItemText(hwnd, IDC_APP_CONFIRM, NULLSTR);
            SetFocus(GetDlgItem(hwnd, IDC_APP_PASSWORD));
            return FALSE;
        }

        // If there is a password, add the trailing quote.
        //
        if ( szPassword[1] )
            hrCat=StringCchCat(szPassword, AS(szPassword), _T("\""));
        else
            szPassword[0] = NULLCHR;

        // Now get the user name.
        //
        szUsername[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_APP_USERNAME, szUsername, AS(szUsername));
    }

    // Now write out the settings, or delete if the option is not set.
    //
    // NTRAID#NTBUG9-531482-2002/02/27-stelo,swamip - Password stored in plain text
    //
    WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_USERNAME, ( bUser ? szUsername : NULL ), g_App.szOpkWizIniFile);
    WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_USERNAME, ( bUser ? szUsername : NULL ), g_App.szWinBomIniFile);
    WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_PASSWORD, ( bUser ? szPassword : NULL ), g_App.szOpkWizIniFile);
    WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_PASSWORD, ( bUser ? szPassword : NULL ), g_App.szWinBomIniFile);
    WritePrivateProfileString(INI_SEC_GENERAL, INI_KEY_APPCREDENTIALS, ( bUser ? STR_ONE : NULL ), g_App.szOpkWizIniFile);

    if ( !SaveAppList(g_lpAppHead, g_App.szWinBomIniFile, g_App.szOpkWizIniFile) )
    {
        MsgBox(GetParent(hwnd), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
        WIZ_EXIT(hwnd);
        return FALSE;
    }

    return TRUE;
}

static BOOL SaveOneApp(HWND hwnd, LPAPPENTRY lpApp)
{
    APPENTRY    app;
    LPTSTR      lpFilePart;
    DWORD       dwIndex;
    BOOL        bFound;

    //
    // First do some checks to make sure all the data that
    // they entered is valid.  Once that is done, we can go
    // ahead and save the data.
    //

    // Make sure we have a pointer to a valid structure.
    //
    if ( lpApp == NULL )
        return FALSE;

    // Copy the current app structure into the temporary one.
    //
    CopyMemory(&app, lpApp, sizeof(APPENTRY));

    // Make sure they have a display name.
    //
    app.szDisplayName[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_APP_NAME, app.szDisplayName, AS(app.szDisplayName));
    if ( app.szDisplayName[0] == NULLCHR )
    {
        MsgBox(hwnd, IDS_BLANKNAME, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(GetDlgItem(hwnd, IDC_APP_NAME));
        return FALSE;
    }

#if 0
    //
    // We should have this safety check for resreved names, but I don't
    // want to mess around with adding error strings at this point.  We should
    // add this code in after we ship.
    //
    // IDS_RESERVEDNAME        "The name ""%s"" is a reserved name and cannot be used. Please choose another name for your application install."
    //

    // Make sure the display name isn't a reserved one.
    //
    if ( AppInternal(app.szDisplayName) )
    {
        MsgBox(hwnd, IDS_RESERVEDNAME, IDS_APPNAME, MB_OK | MB_ICONINFORMATION, app.szDisplayName);
        SetFocus(GetDlgItem(hwnd, IDC_APP_NAME));
        return FALSE;
    }
#endif

    // The app display name must be unique, so search through
    // our applist to see if this is a dup.
    //
    // Now that we use the WINBOM instead of the registry, this is no longer
    // true.  The display names do not need to be unique.
    /*
    LPAPPENTRY  lpAppSearch;
    for ( lpAppSearch = g_lpAppHead; lpAppSearch; lpAppSearch = lpAppSearch->lpNext )
    {
        if ( ( lpAppSearch != lpApp ) && 
             ( lstrcmpi(lpAppSearch->szDisplayName, app.szDisplayName) == 0 ) )
        {
            MsgBox(hwnd, IDS_DUPNAME, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_APP_NAME));
            return FALSE;
        }
    }
    */

    // Get the source path and setup file.
    //
    app.szSourcePath[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_APP_PATH, app.szSourcePath, AS(app.szSourcePath));

    // Now need to split the file name from the source path.
    //
    if ( app.szSourcePath[0] &&
         GetFullPathName(app.szSourcePath, AS(app.szSetupFile), app.szSetupFile, &lpFilePart) &&
         app.szSetupFile[0] &&
         lpFilePart )
    {
        DWORD dwPathLen = lstrlen(app.szSourcePath) - lstrlen(lpFilePart);

        lstrcpyn(app.szSetupFile, app.szSourcePath + dwPathLen, AS(app.szSetupFile));
        app.szSourcePath[dwPathLen] = NULLCHR;
    }

    // Make sure they have a setup file.
    //
    if ( app.szSetupFile[0] == NULLCHR )
    {
        MsgBox(hwnd, IDS_BLANKPATH, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(GetDlgItem(hwnd, IDC_APP_PATH));
        return FALSE;
    }

    // Get any command line arguments they have.
    //
    app.szCommandLine[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_APP_ARGS, app.szCommandLine, AS(app.szCommandLine));

    // Find out which radio button is checked.
    //
    bFound = FALSE;
    app.itSectionType = installtechUndefined;
    for ( dwIndex = 0; ( dwIndex < AS(g_crbChecked) ) && !bFound ; dwIndex++ )
    {
        if ( bFound = ( IsDlgButtonChecked(hwnd, g_crbChecked[dwIndex].iButtonId) == BST_CHECKED ) )
            app.itSectionType = g_crbChecked[dwIndex].itSectionType;
    }

    // Set the bits you can set in this dialog.
    //
    SETBIT(app.dwFlags, APP_FLAG_REBOOT, IsDlgButtonChecked(hwnd, IDC_APP_REBOOT));
    SETBIT(app.dwFlags, APP_FLAG_STAGE, IsDlgButtonChecked(hwnd, IDC_APP_STAGE));

    // If this is a generic app, and we are not rebooting or
    // staging, then no need to do an advanced section.
    //
    if ( ( installtechApp == app.itSectionType ) &&
         ( !GETBIT(app.dwFlags, APP_FLAG_REBOOT) ) &&
         ( !GETBIT(app.dwFlags, APP_FLAG_STAGE) ) )
    {
        // This means we are just going to do the one line thing,
        // no advanced parameters.
        //
        app.itSectionType = installtechUndefined;
    }

    // There is some special stuff to get if this is an INF install.
    //
    if ( installtechINF == app.itSectionType )
    {
        // Get the section name and make sure we have it.
        //
        app.szInfSectionName[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_APP_INF_SECTION, app.szInfSectionName, AS(app.szInfSectionName));
        if ( NULLCHR == app.szInfSectionName[0] )
        {
            MsgBox(hwnd, IDS_ERR_NOSECTION, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_APP_INF_SECTION));
            return FALSE;
        }
    }

    // There is also some special stuff to get if this is a staged install.
    //
    if ( GETBIT(app.dwFlags, APP_FLAG_STAGE) )
    {
        // Get the staged folder and make sure we have it.
        //
        app.szStagePath[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_APP_STAGEPATH, app.szStagePath, AS(app.szStagePath));
        if ( NULLCHR == app.szStagePath[0] )
        {
            MsgBox(hwnd, IDS_ERR_NOSTAGEPATH, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_APP_STAGEPATH));
            return FALSE;
        }
    }

    //
    // Now that we are sure that we have valid data, we can return the data
    // we collected into the supplied buffer.
    //

    // Start by moving over the data from our temporary buffer.
    //
    CopyMemory(lpApp, &app, sizeof(APPENTRY));

    // If we made it this far, we must return TRUE.
    //
    return TRUE;
}

static LPAPPENTRY ManageAppList(LPLPAPPENTRY lpAppHead, LPAPPENTRY lpAppAdd, DWORD dwFlag)
{
    LPAPPENTRY  lpAppNew        = NULL,
                *lpAppSearch;

    // Make sure the head pointer is valid.
    //
    if ( lpAppHead == NULL )
       return NULL;

    // See if we are freeing the list.
    //
    if ( lpAppAdd == NULL )
    {
        // Don't keep going when we hit the last NULL next pointer.
        //
        if ( *lpAppHead != NULL )
        {
            ManageAppList(&((*lpAppHead)->lpNext), NULL, 0);
            FREE(*lpAppHead);
        }
    }

    // OK, how about removing an item.
    //
    else if ( dwFlag == APP_DELETE )
    {
        // Search for the item we want to delete.
        //
        for ( lpAppSearch = lpAppHead; *lpAppSearch && ( *lpAppSearch != lpAppAdd ); lpAppSearch = &((*lpAppSearch)->lpNext) );

        // Make sure we found the item we were looking for.
        //
        if ( *lpAppSearch )
        {
            // Setup the list to skip over the item we are going to delete.
            //
            *lpAppSearch = (*lpAppSearch)->lpNext;

            // Then NULL the next pointer of the item we are removing.
            //
            lpAppAdd->lpNext = NULL;

            // Call this function again with the pointer to the item to delete
            // as the head parameter to free it up.
            //
            ManageAppList(&lpAppAdd, NULL, 0);
        }
    }

    // Must be adding a new one.  Allocate a new structure for the
    // item we are adding.
    //
    else if ( (dwFlag == APP_ADD) && (lpAppNew = (LPAPPENTRY) MALLOC(sizeof(APPENTRY))) )
    {
        // Copy contents of the passed in structure to the newly
        // allocated one.
        //
        CopyMemory(lpAppNew, lpAppAdd, sizeof(APPENTRY));

        // Reset the new next pointer to NULL.
        //
        lpAppNew->lpNext = NULL;

        lpAppSearch = lpAppHead;

        while (*lpAppSearch)
            lpAppSearch = &((*lpAppSearch)->lpNext);

        // Insert the new APPENTRY into the correct position
        //
        lpAppNew->lpNext = (*lpAppSearch);

        *lpAppSearch = lpAppNew;
        
    }
    else if ( dwFlag == APP_MOVE_DOWN )
    {
        LPAPPENTRY  lpAppPrev   = NULL;

        for ( lpAppNew = (*lpAppHead); lpAppNew && ((lpAppNew) != lpAppAdd); lpAppNew = lpAppNew->lpNext )
        {
            lpAppPrev = lpAppNew;    
        }
    
        if ( lpAppNew )
        {
            if ( lpAppPrev )
                lpAppPrev->lpNext = lpAppNew->lpNext;
            else 
                g_lpAppHead = lpAppNew->lpNext;

            lpAppNew->lpNext = lpAppNew->lpNext->lpNext;
        }

        if (lpAppPrev )
            lpAppPrev->lpNext->lpNext = lpAppNew;
        else
            g_lpAppHead->lpNext = lpAppNew;
    }

    return lpAppNew;
}

static void AddAppToListView(HWND hwndLV, LPAPPENTRY lpApp)
{
    LVITEM      lvItem;
    HIMAGELIST  hImages;
    TCHAR       szFullCmdLine[(MAX_PATH * 2) + MAX_CMDLINE + 1];
    HRESULT hrCat;

    // Don't show internal apps.
    //
    if ( GETBIT(lpApp->dwFlags, APP_FLAG_INTERNAL) )
    {
        return;
    }

    // Init the list view item structure with some of the things common
    // to all list view entries.
    //
    ZeroMemory(&lvItem, sizeof(LVITEM));
    lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvItem.state = 0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.iSubItem = 0;
    lvItem.lParam = (LPARAM) lpApp;

    // Get the index for this item (number currently in list since 
    // we are zero-based).
    //
    lvItem.iItem = ListView_GetItemCount(hwndLV);

    // I didn't see the need to do use the LPSTR_TEXTCALLBACK way of displaying
    // the text.  It seems to work fine this new way.  Although I left the old
    // code in here that handled the LVN_GETDISPINFO in case we need to go back
    // to this way.
    //    
    lvItem.pszText = lpApp->szDisplayName;

    // Create the full path part of the command line out of the data we have.
    //
    lstrcpyn(szFullCmdLine, lpApp->szSourcePath, AS(szFullCmdLine));
    if ( szFullCmdLine[0] )
        AddPathN(szFullCmdLine, lpApp->szSetupFile,AS(szFullCmdLine));
    else
        lstrcpyn(szFullCmdLine, lpApp->szSetupFile, AS(szFullCmdLine));

    // Add the icon for tha app the the list view's image list.
    //
    if ( ( *(lpApp->szSourcePath) ) &&
         ( *(lpApp->szSetupFile) ) &&
         ( hImages = ListView_GetImageList(hwndLV, LVSIL_SMALL) ) )
    {
        SHFILEINFO shfiIcon;

        // Now get the icon from the install file.
        //
        ZeroMemory(&shfiIcon, sizeof(SHFILEINFO));
        if ( SHGetFileInfo(szFullCmdLine, 0, &shfiIcon, sizeof(SHFILEINFO), SHGFI_ICON | SHGFI_SMALLICON) && shfiIcon.hIcon )
        {
            // Try to add the icon to our list... if it fails, use the default icon
            // for this item.
            //
            lvItem.iImage = ImageList_AddIcon(hImages, shfiIcon.hIcon);
            if ( lvItem.iImage < 0 )
                lvItem.iImage = 0;
        }
    }

    // Add on our command line for the display of the sub-item.
    hrCat=StringCchCat(szFullCmdLine, AS(szFullCmdLine), _T(" "));
    hrCat=StringCchCat(szFullCmdLine, AS(szFullCmdLine), lpApp->szCommandLine);

    // Insert the main guy.
    //
    ListView_InsertItem(hwndLV, &lvItem);

    // Insert each of the other columns.
    //
    // Only one other column for now, so just do it this way.
    //
    ListView_SetItemText(hwndLV, lvItem.iItem, 1, szFullCmdLine);
    
    /* This is the old code in case we want to do more than one later.

    for (lvItem.iSubItem = 1; lvItem.iSubItem < NUM_COLUMNS; lvItem.iSubItem++)
    {
        switch ( lvItem.iSubItem )
        {
            case 1:
                ListView_SetItemText(hwndLV, lvItem.iItem, lvItem.iSubItem, szFullCmdLine);
                break;
        }
    }

    */
}

static BOOL RefreshAppList(HWND hwnd, LPAPPENTRY lpAppHead)
{
    LPAPPENTRY lpApp;

    ListView_DeleteAllItems(hwnd);

    for ( lpApp = lpAppHead; lpApp; lpApp = lpApp->lpNext )
        AddAppToListView(hwnd, lpApp);

    return TRUE;
}

static BOOL AdvancedView(HWND hwnd, BOOL bChange)
{
    static int  iMaxHeight = 0;
    RECT        rc;
    LPTSTR      lpText;
    BOOL        bAdvanced;

    GetWindowRect(hwnd, &rc);

    // If this is the first time called, iMaxHeight will be
    // zero and we will be in advanced view.
    //
    if ( 0 == iMaxHeight )
    {
        bAdvanced = TRUE;
        iMaxHeight = rc.bottom - rc.top;
    }
    else
        bAdvanced = (rc.bottom - rc.top == iMaxHeight);

    // Only toggle if they want us to change the view.
    //
    if ( bChange )
    {
        if ( bAdvanced = !bAdvanced )
        {
            // Going into advanced view.
            //
            SetWindowPos(hwnd, NULL, 0, 0, rc.right - rc.left, iMaxHeight, SWP_NOMOVE | SWP_NOZORDER);
            if ( lpText = AllocateString(NULL, IDS_APP_STANDARD) )
            {
                SetWindowText(GetDlgItem(hwnd, IDC_APP_ADVANCED), lpText);
                FREE(lpText);
            }
        }
        else
        {
            int iWidth  = rc.right - rc.left,
                iHeight = rc.top;

            // Going into standard view.
            //
            GetWindowRect(GetDlgItem(hwnd, IDC_APP_DIVIDER), &rc);
            SetWindowPos(hwnd, NULL, 0, 0, iWidth, rc.bottom - iHeight, SWP_NOMOVE | SWP_NOZORDER);
            if ( lpText = AllocateString(NULL, IDS_APP_ADVANCED) )
            {
                SetWindowText(GetDlgItem(hwnd, IDC_APP_ADVANCED), lpText);
                FREE(lpText);
            }
        }
    }

    return bAdvanced;
}

static void CleanupSections(LPTSTR lpSection, BOOL bStage)
{
    TCHAR   szSection[MAX_SECTIONNAME];
    LPTSTR  lpEnd;
    HRESULT hrPrintf;

    // Make our own copy of the section name to play with.
    // Also need to get a pointer to the end of it.
    //
    lstrcpyn(szSection, lpSection, AS(szSection));
    lpEnd = szSection + lstrlen(szSection);

    // Now clean up the sections we don't want.
    //
    if ( bStage )
    {
        //
        // We do this because this might have been a
        // standard install before and we don't want to
        // leave the section laying around.
        //

        // Just nuke the section name from both files.
        //
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);
    }
    else
    {
        //
        // This could have been a staged install before, so
        // have to remove the three possible sections that
        // we could have created.
        //

        // Nuke the attach section from both files.
        //
        hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(szSection)), STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_ATTACH);
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);

        // Nuke the detach section from both files.
        //
        hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(szSection)), STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_DETACH);
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);

        // Nuke the stage section from both files.
        //
        hrPrintf=StringCchPrintf(lpEnd, (MAX_SECTIONNAME-lstrlen(szSection)), STR_INI_SEC_ADVAPP_STAGE, INI_VAL_WBOM_STAGE);
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);
        WritePrivateProfileString(szSection, NULL, NULL, g_App.szWinBomIniFile);
    }
}

static void StrCpyDbl(LPTSTR lpDst, LPTSTR lpSrc)
{
    while ( *lpDst++ = *lpSrc )
    {
        if ( CHR_QUOTE == *lpSrc )
            *lpDst++ = *lpSrc;
        lpSrc++;
    }
}

static BOOL FindUncPath(LPTSTR lpPath, DWORD cbPath)
{
    TCHAR   szUnc[MAX_PATH],
            szFullPath[MAX_PATH]    = NULLSTR,
            szSearch[MAX_PATH],
            szFullSearch[MAX_PATH],
            szDrive[]               = _T("_:");
    LPTSTR  lpFilePart;
    DWORD   cbUnc                   = AS(szUnc);
    BOOL    bRet                    = FALSE;
    HRESULT hrCat;

    // Make sure we have a full path.
    //
    if ( GetFullPathName(lpPath, AS(szFullPath), szFullPath, &lpFilePart) && szFullPath[0] && ISLET(szFullPath[0]) )
    {
        //
        // First see if the drive is actually a network drive.
        //

        // This will get the UNC if the drive passed in is a mapped
        // network drive.
        //
        szDrive[0] = szFullPath[0];
        if ( WNetGetConnection(szDrive, szUnc, &cbUnc) == NO_ERROR )
        {
            // Only add on the rest of the path if more than the root
            // directory was passed in.
            //
            if ( lstrlen(szFullPath) > 3 )
            {
                hrCat=StringCchCat(szUnc, AS(szUnc), szFullPath+2);
            }

            // Copy the path to return back and set the return value
            // to true.
            //
            lstrcpyn(lpPath, szUnc, cbPath);
            bRet = TRUE;
        }
        else
        {
            //
            // Must be local, so try to see if the path, or any parent
            // path is shared out.
            //

            // Start our search from the directory passed in and then
            // loop down the path until we find a shared folder, or the
            // root directory.
            //
            lstrcpyn(szFullSearch, szFullPath, AS(szFullSearch));
            if ( lpFilePart && !DirectoryExists(szFullSearch) )
            {
                // If we know that what they passed in isn't a directory (most
                // likely a file name then), then we can just chop off the file
                // part and start with the directory and not the file.
                //
                szFullSearch[lstrlen(szFullSearch) - lstrlen(lpFilePart)] = NULLCHR;
            }
            do
            {
                // If the folder is shared, use it.
                //
                if ( DirectoryExists(szFullSearch) &&
                     IsFolderShared(szFullSearch, szUnc, AS(szUnc)) )
                {
                    // Only add on the rest of the path if more than the root
                    // directory was passed in.
                    //
                    if ( lstrlen(szFullPath) > 3 )
                    {
                        AddPathN(szUnc, szFullPath + lstrlen(szFullSearch),AS(szUnc));
                    }

                    // Copy the path to return back and set the return value
                    // to true.
                    //
                    lstrcpyn(lpPath, szUnc, cbPath);
                    bRet = TRUE;
                }
                else
                {
                    // Not shared, so try the parent folder.  We will quit when
                    // we reach the root.
                    //
                    lstrcpyn(szSearch, szFullSearch, AS(szSearch));
                    AddPathN(szSearch, _T(".."),AS(szSearch));
                }
            }
            while ( ( !bRet ) &&
                    ( lstrlen(szFullSearch) > 3 ) &&
                    ( GetFullPathName(szSearch, AS(szFullSearch), szFullSearch, &lpFilePart) ) &&
                    ( szFullSearch[0] ) );
        }
    }

    return bRet;
}

static void EnableControls(HWND hwnd, UINT uId)
{
    BOOL fEnable = TRUE;

    switch ( uId )
    {
        case IDC_APP_STAGE:

            // Enable/disable all the stuff under the stage check box.
            //
            fEnable = ( IsDlgButtonChecked(hwnd, IDC_APP_STAGE) == BST_CHECKED );
            EnableWindow(GetDlgItem(hwnd, IDC_APP_STAGEPATH_TEXT), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_STAGEPATH), fEnable);
            break;

        case IDC_APP_TYPE_GEN:
        case IDC_APP_TYPE_MSI:
        case IDC_APP_TYPE_INF:

            // Enable/disable any stuff under the different radio buttons.
            //
            fEnable = ( IsDlgButtonChecked(hwnd, IDC_APP_TYPE_INF) == BST_CHECKED );
            EnableWindow(GetDlgItem(hwnd, IDC_APP_INF_SECTION_TEXT), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_INF_SECTION), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_ARGS_TEXT), !fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_ARGS), !fEnable);
            break;

        case IDC_APP_CREDENTIALS:

            // Enable/disable any stuff under the user credentials check box.
            //
            fEnable = ( IsDlgButtonChecked(hwnd, uId) == BST_CHECKED );
            EnableWindow(GetDlgItem(hwnd, IDC_APP_USERNAME_TEXT), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_USERNAME), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_PASSWORD_TEXT), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_PASSWORD), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_CONFIRM_TEXT), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_APP_CONFIRM), fEnable);
            break;
    }
}

static BOOL AppInternal(LPTSTR lpszAppName)
{
    BOOL        bRet = FALSE,
                bLoop;
    HINF        hInf;
    INFCONTEXT  InfContext;
    DWORD       dwErr,
                dwResId;
    LPTSTR      lpszResName;

    // Go through the reserved app names in the input inf file.
    //
    if ( (hInf = SetupOpenInfFile(g_App.szOpkInputInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, &dwErr)) != INVALID_HANDLE_VALUE )
    {
        // Loop thru each line in the reserved App Names section.
        //
        for ( bLoop = SetupFindFirstLine(hInf, INI_SEC_RESERVEDNAMES, NULL, &InfContext);
              bLoop && !bRet;
              bLoop = SetupFindNextLine(&InfContext, &InfContext) )
        {
            // Get the resreved name resource ID.
            //
            dwResId = 0;
            if ( ( SetupGetIntField(&InfContext, 1, &dwResId) && dwResId ) &&
                 ( lpszResName = AllocateString(NULL, dwResId) ) )
            {
                // If the match (case and all) then they can't use
                // this name because we use it for internal stuff.
                //
                if ( lstrcmp(lpszAppName, lpszResName) == 0 )
                {
                    bRet = TRUE;
                }
                FREE(lpszResName);
            }
        }

        // We are done, so close the INF file.
        //
        SetupCloseInfFile(hInf);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\btitle.c ===
/****************************************************************************\

    BTITLE.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "IE Customize" wizard page.

    4/99 - Brian Ku (BRIANK)
        Added this new source file for the IEAK integration as part of the
        Millennium rewrite.

    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"

#include "wizard.h"
#include "resource.h"

/* Example:

[Branding]
...
Window_Title_CN=Smoothie Joe
Window_Title=Microsoft Internet Explorer provided by Smoothie Joe
Toolbar Bitmap=C:\WINDOWS\Waves.bmp

[Internet_Mail]
Window_Title=Outlook Express provided by Smoothie Joe
*/


//
// Internal Defines
//

#define INI_KEY_WINDOW_TITLECN  _T("Window_Title_CN")
#define INI_KEY_WINDOW_TITLE    _T("Window_Title")
#define INI_KEY_TOOLBAR_BM      _T("Toolbar Bitmap")
#define INI_SEC_IEMAIL          _T("Internet_Mail")


// 
// Internal Globals
//

BOOL    g_fGrayTitle = TRUE, g_fGrayToolbarBm = TRUE;
TCHAR   g_szTitle[MAX_PATH] = NULLSTR, g_szToolbarBm[MAX_PATH] = NULLSTR;


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL FSaveData(HWND);
static void EnableControls(HWND, UINT, BOOL);

void SaveBTitle();


//
// External Function(s):
//

LRESULT CALLBACK BrandTitleDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if (!FSaveData(hwnd))
                        WIZ_FAIL(hwnd);
                    else
                        SaveBTitle();
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_BTITLE;

                    if (g_App.szManufacturer[0] && !g_szTitle[0])
                        lstrcpyn(g_szTitle, g_App.szManufacturer, AS(g_szTitle));

                    SetWindowText(GetDlgItem(hwnd, IDE_TITLE), g_szTitle);
                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
                    
                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szKey[MAX_PATH] = NULLSTR;
    TCHAR   szHoldDir[MAX_PATH];

    // Load the ins file sections to initialize items
    //
    ReadInstallInsKey(INI_SEC_BRANDING, INI_KEY_WINDOW_TITLECN, g_szTitle, STRSIZE(g_szTitle),
        GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile, &g_fGrayTitle);

    ReadInstallInsKey(INI_SEC_BRANDING, INI_KEY_TOOLBAR_BM, g_szToolbarBm, STRSIZE(g_szToolbarBm), 
        GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile, &g_fGrayToolbarBm);

    // Set the window text
    //
    SendDlgItemMessage(hwnd, IDE_TITLE , EM_LIMITTEXT, STRSIZE(g_szTitle) - 1, 0L);
    SetWindowText(GetDlgItem(hwnd, IDE_TITLE), g_szTitle);
    EnableControls(hwnd, IDC_TITLE, !g_fGrayTitle);

    SendDlgItemMessage(hwnd, IDE_TOOLBARBMP , EM_LIMITTEXT, STRSIZE(g_szToolbarBm) - 1, 0L);
    SetWindowText(GetDlgItem(hwnd, IDE_TOOLBARBMP), g_szToolbarBm);
    EnableControls(hwnd, IDC_TOOLBARBMP, !g_fGrayToolbarBm);

    // Create the IEAK holding place directories (these get deleted in save.c)
    //
    lstrcpyn(szHoldDir, g_App.szTempDir,AS(szHoldDir));
    AddPathN(szHoldDir, DIR_IESIGNUP,AS(szHoldDir));
    CreatePath(szHoldDir);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szFileName[MAX_PATH];

    switch ( id )
    {
    case IDC_TITLE:           
            EnableControls(hwnd, IDC_TITLE, g_fGrayTitle);
            g_fGrayTitle = !g_fGrayTitle ;
        break;

    case IDC_TOOLBARBMP:
            EnableControls(hwnd, IDC_TOOLBARBMP, g_fGrayToolbarBm);
            g_fGrayToolbarBm = !g_fGrayToolbarBm ;            
        break;

    case IDC_BROWSETBB:
        // Now get the filename
        //
        GetDlgItemText(hwnd, IDE_TOOLBARBMP, szFileName, STRSIZE(szFileName));

        if ( BrowseForFile(hwnd, IDS_BROWSE, IDS_BMPFILTER, IDS_BMP, szFileName, 
            STRSIZE(szFileName), g_App.szOpkDir, 0) ) 
            SetDlgItemText(hwnd, IDE_TOOLBARBMP, szFileName);     
        break;
    }
}

// The actual copying of the bitmap file happens in save.c.  Here we just save 
// to the install.ins
//
static BOOL FSaveData(HWND hwnd)
{
    TCHAR szBuffer[MAX_PATH], szTemp[MAX_PATH];
    HRESULT hrPrintf;

    // Get the new values
    //
    GetWindowText(GetDlgItem(hwnd, IDE_TITLE), g_szTitle, STRSIZE(g_szTitle));
    GetWindowText(GetDlgItem(hwnd, IDE_TOOLBARBMP), g_szToolbarBm, STRSIZE(g_szToolbarBm));
    

    // Save the window_title_cn
    //
    WriteInstallInsKey(INI_SEC_BRANDING, INI_KEY_WINDOW_TITLECN, g_szTitle, g_App.szInstallInsFile, g_fGrayTitle);

    // Save the toolbar bitmap
    //
    if (!g_fGrayToolbarBm && !FileExists(g_szToolbarBm)) {
        MsgBox(hwnd, lstrlen(g_szToolbarBm) ? IDS_NOFILE : IDS_BLANKFILE, IDS_APPNAME, MB_ERRORBOX, g_szToolbarBm);
        SetFocus(GetDlgItem(hwnd, IDE_TOOLBARBMP)); 
        return FALSE;
    }
    WriteInstallInsKey(INI_SEC_BRANDING, INI_KEY_TOOLBAR_BM, g_szToolbarBm, g_App.szInstallInsFile, g_fGrayToolbarBm);

    // Save the window_title
    //
    LoadString(g_App.hInstance, IDS_TITLE_PREFIX, szTemp, STRSIZE(szTemp));
    hrPrintf=StringCchPrintf(szBuffer, AS(szBuffer), szTemp, g_szTitle);
    WriteInstallInsKey(INI_SEC_BRANDING, INI_KEY_WINDOW_TITLE, szBuffer, g_App.szInstallInsFile, g_fGrayTitle);

    // Save the internet_mail
    //
    LoadString(g_App.hInstance, IDS_OETITLE_PREFIX, szTemp, STRSIZE(szTemp));
    hrPrintf=StringCchPrintf(szBuffer, AS(szBuffer), szTemp, g_szTitle);
    WriteInstallInsKey(INI_SEC_IEMAIL, INI_KEY_WINDOW_TITLE, szBuffer, g_App.szInstallInsFile, g_fGrayTitle);

    return TRUE;
}

static void EnableControls(HWND hwnd, UINT uId, BOOL fEnable)
{
    switch ( uId )
    {
        case IDC_TITLE:
            EnableWindow(GetDlgItem(hwnd, IDC_TITLE_TXT), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDE_TITLE), fEnable);
            CheckDlgButton(hwnd, IDC_TITLE, fEnable ? BST_CHECKED : BST_UNCHECKED);
            break;

        case IDC_TOOLBARBMP:
            EnableWindow(GetDlgItem(hwnd, IDC_TOOLBARBMP_TXT), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDE_TOOLBARBMP), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_BROWSETBB), fEnable);    
            CheckDlgButton(hwnd, IDC_TOOLBARBMP, fEnable ? BST_CHECKED : BST_UNCHECKED);
            break;
    }
}

void SaveBTitle()
{
    TCHAR szBmpFile[MAX_PATH] = NULLSTR;

    // Copy the Bitmap file if not grayed
    //
    if (!g_fGrayToolbarBm) {
        lstrcpyn(szBmpFile, g_App.szTempDir,AS(szBmpFile));
        AddPathN(szBmpFile, DIR_IESIGNUP,AS(szBmpFile));
        AddPathN(szBmpFile, PathFindFileName(g_szToolbarBm),AS(szBmpFile));
        CopyFile(g_szToolbarBm, szBmpFile, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\complete.c ===
/****************************************************************************\

    COMPLETE.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "completion" wizard page.

    3/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.

    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"
#include "setupmgr.h"

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);


//
// External Function(s):
//

INT_PTR CALLBACK CompleteDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        default:
            return FALSE;
    }

    return TRUE;
}

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    SetWindowFont(GetDlgItem(hwnd, IDC_BOLD), FixedGlobals.hBigBoldFont, TRUE);

    SetWindowText(GetDlgItem(hwnd, IDC_CONFIG_NAME), g_App.szConfigName);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\btoolbar.c ===
/****************************************************************************\

    BTOOLBAR.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "IE Customize" wizard page.

   10/99 - Brian Ku (BRIANK)
        Added this new source file for the IEAK integration as part of the
        Millennium rewrite.

   09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"

#include "wizard.h"
#include "resource.h"

/* Example:

[BrowserToolbars]
Caption0=Solitaire
Action0=c:\windows\sol.exe
Icon0=H:\iecust\icons\G.ico
HotIcon0=H:\iecust\icons\C.ico
Show0=1
Caption1=Calc
Action1=c:\windows\calc.exe
Icon1=\\Opksrv\tools\iecust\icons\G.ICO
HotIcon1=\\Opksrv\tools\iecust\icons\C.ICO
Show1=1
*/

//
// Internal Defined Value(s):
//

#define INI_KEY_CAPTION0         _T("Caption%d")
#define INI_KEY_ACTION0          _T("Action%d")
#define INI_KEY_ICON0            _T("Icon%d")
#define INI_KEY_HOTICON0         _T("HotIcon%d")
#define INI_KEY_SHOW0            _T("Show%d")
#define MAX_NAME                11

//
// Browser Toolbar Info
//
typedef struct _BTOOLBAR_BUTTON_INFO {
    TCHAR   szCaption[MAX_NAME];
    TCHAR   szAction[MAX_PATH];
    TCHAR   szIconColor[MAX_PATH];
    TCHAR   szIconGray[MAX_PATH];    
    BOOL    fShow;
}BTOOLBAR_BUTTON_INFO, *PBTOOLBAR_BUTTON_INFO;


//
// Internal Globals
//
PGENERIC_LIST           g_pgTbbiList;                   // Generic list of BTOOLBAR_INFO items
PGENERIC_LIST*          g_ppgTbbiNew = &g_pgTbbiList;   // Pointer to next unallocated item in list
PBTOOLBAR_BUTTON_INFO   g_pbtbbiNew;                    // Browser Toolbar Popup Info item


//
// Internal Function Prototype(s):
//

static BOOL OnInitTb(HWND, HWND, LPARAM);
static void OnCommandTb(HWND, INT, HWND, UINT);
static void InitToolbarButtonList(HWND);

static BOOL OnInitTbPopup(HWND, HWND, LPARAM);
static void OnCommandTbPopup(HWND, INT, HWND, UINT);

static void OnAddToolbar(HWND);
static void OnEditToolbar(HWND);
static void OnRemoveToolbar(HWND);
static void SaveData(PGENERIC_LIST);
static BOOL FSaveBToolbarButtonInfo(HWND hwnd, PBTOOLBAR_BUTTON_INFO pbtbbi);
static void DisableButtons(HWND hwnd);

void SaveBToolbar();
LRESULT CALLBACK ToolbarPopupDlgProc(HWND, UINT, WPARAM, LPARAM);

//
// External Function(s):
//

LRESULT CALLBACK BToolbarsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitTb);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommandTb);

        case WM_NOTIFY:
            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    SaveBToolbar();
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_BTOOLBAR;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_DESTROY:
            FreeList(g_pgTbbiList);
            g_ppgTbbiNew = &g_pgTbbiList;
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

//
// Internal Function(s):
//


static BOOL OnInitTb(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szHoldDir[MAX_PATH];

    // Load the list of toolbars from install.ins
    //
    InitToolbarButtonList(hwnd);    

    // Determine whether to show or hide edit/remove button at init
    //
    DisableButtons(hwnd);

#ifndef BRANDTITLE

    // Create the IEAK holding place directories (these get deleted in save.c)
    //
    lstrcpyn(szHoldDir, g_App.szTempDir,AS(szHoldDir));
    AddPathN(szHoldDir, DIR_IESIGNUP,AS(szHoldDir));
    CreatePath(szHoldDir);

#endif //BRANDTITLE

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommandTb(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    // Controls
    //
    switch ( id )
    {
    case IDC_ADDBTOOLBAR:
        OnAddToolbar(hwnd);
        break;

    case IDC_EDITBTOOLBAR:
        OnEditToolbar(hwnd);
        DisableButtons(hwnd);
        break;

    case IDC_REMOVEBTOOLBAR:
        OnRemoveToolbar(hwnd);
        DisableButtons(hwnd);
        break;
    }

    // Notifications
    //
    switch (codeNotify)
    {
    case LBN_DBLCLK:
        OnEditToolbar(hwnd);  
        break;

    case LBN_SELCHANGE:
    case LBN_SETFOCUS:
        DisableButtons(hwnd);
        break;
    }
}

void OnAddToolbar(HWND hwnd)
{
    PBTOOLBAR_BUTTON_INFO pbtbbiNew;
    HWND hwndList;

    if (NULL == (pbtbbiNew = (PBTOOLBAR_BUTTON_INFO)MALLOC(sizeof(BTOOLBAR_BUTTON_INFO)))) {
        MsgBox(GetParent(hwnd), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
        WIZ_EXIT(hwnd);
        return;
    }

    ZeroMemory(pbtbbiNew, sizeof(BTOOLBAR_BUTTON_INFO));

    hwndList         = GetDlgItem(hwnd, IDC_BTOOLBARLIST);

    if (IDOK == DialogBoxParam(g_App.hInstance,  
            MAKEINTRESOURCE(IDD_BRTOOLBAR),
            hwnd,     
            ToolbarPopupDlgProc,
            (LPARAM)pbtbbiNew)) {

        // Make sure we're not adding duplicates
        //
        if (LB_ERR == ListBox_FindString(hwndList, -1, pbtbbiNew->szCaption)) {    
            INT   iItem = -1;

            // Add the toolbar button info to the list
            //
            FAddListItem(&g_pgTbbiList, &g_ppgTbbiNew, pbtbbiNew);
            iItem = ListBox_AddString(hwndList, pbtbbiNew->szCaption);
            ListBox_SetItemData(hwndList, iItem, pbtbbiNew);                
        }
        else {
            FREE(pbtbbiNew);
            MsgBox(hwnd, IDS_ERR_DUP, IDS_APPNAME, MB_OK);
        }

    }
    else
        FREE(pbtbbiNew);
}

void OnEditToolbar(HWND hwnd)
{
    PBTOOLBAR_BUTTON_INFO pbtbbi;
    HWND    hwndList;
    INT     iItem;

    hwndList = GetDlgItem(hwnd, IDC_BTOOLBARLIST);
    iItem = ListBox_GetCurSel(hwndList);
    if (iItem != -1) {
        pbtbbi = (PBTOOLBAR_BUTTON_INFO) ListBox_GetItemData(hwndList, iItem);

        if (IDOK == DialogBoxParam(g_App.hInstance,  
                MAKEINTRESOURCE(IDD_BRTOOLBAR),
                hwnd,     
                ToolbarPopupDlgProc,
                (LPARAM)pbtbbi)) {

            // Remove old item and add modified item
            ListBox_DeleteString(hwndList, iItem);
            iItem = ListBox_AddString(hwndList, pbtbbi->szCaption);
            ListBox_SetItemData(hwndList, iItem, pbtbbi);                
        }
    }
}

void OnRemoveToolbar(HWND hwnd)
{
    BOOL fFound = FALSE;
    HWND hwndList = GetDlgItem(hwnd, IDC_BTOOLBARLIST);
    INT  iItem = ListBox_GetCurSel(hwndList);

    // Loop until we find what we want to delete 
    //
    PGENERIC_LIST pglItem = g_pgTbbiList;
    while ((iItem != -1) && !fFound && pglItem) {
        PBTOOLBAR_BUTTON_INFO pbDelete = (PBTOOLBAR_BUTTON_INFO)ListBox_GetItemData(hwndList, iItem);

        // Remove item from list
        //
        if (pglItem->pNext && pglItem->pNext->pvItem == pbDelete) {
            PGENERIC_LIST pTemp = pglItem->pNext;
            pglItem->pNext = pTemp->pNext;

            // Reset the g_ppglNew if last item
            //
            if (&pTemp->pNext == g_ppgTbbiNew)
                g_ppgTbbiNew = &pglItem->pNext;
            
            FREE(pTemp->pvItem);
            FREE(pTemp);
            fFound = TRUE;
        }
        else if (g_pgTbbiList && g_pgTbbiList->pvItem == pbDelete) {
            PGENERIC_LIST pTemp = g_pgTbbiList;
            g_pgTbbiList = g_pgTbbiList->pNext;

            // Reset the g_ppglNew if last item
            //
            if (&pTemp->pNext == g_ppgTbbiNew)
                g_ppgTbbiNew = NULL;

            FREE(pTemp->pvItem);
            FREE(pTemp);
            fFound = TRUE;
        }

        pglItem = pglItem ? pglItem->pNext : NULL;
    }
    ListBox_DeleteString(hwndList, iItem);
}

static void DisableButtons(HWND hwnd)
{
    HWND hwndList = GetDlgItem(hwnd, IDC_BTOOLBARLIST);
    INT  iSel     = ListBox_GetCurSel(hwndList);

    if ((iSel != -1) && ListBox_GetCount(hwndList)) {
        EnableWindow(GetDlgItem(hwnd, IDC_EDITBTOOLBAR), TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_REMOVEBTOOLBAR), TRUE);
    }
    else {
        EnableWindow(GetDlgItem(hwnd, IDC_EDITBTOOLBAR), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_REMOVEBTOOLBAR), FALSE);
    }
}

static void InitToolbarButtonList(HWND hwnd)
{
    LPTSTR  lpszTbSection = NULL;
    TCHAR*  pszItem = NULL;
    HWND    hwndList = GetDlgItem(hwnd, IDC_BTOOLBARLIST);
    INT     iItem = -1;

    // Allocate the section buffer...
    //
    lpszTbSection = MALLOC(MAX_SECTION * sizeof(TCHAR));
    
    if (lpszTbSection && OpkGetPrivateProfileSection(INI_SEC_TOOLBAR, lpszTbSection, MAX_SECTION, g_App.szInstallInsFile)) {
        PBTOOLBAR_BUTTON_INFO pbtbbiNew = NULL;
        pszItem = lpszTbSection;
        while (pszItem && *pszItem != NULLCHR) {
            TCHAR *pszTemp = NULL;

            // NOTE: This order is very important!
            //       The 'Caption' must be first and 'Show' must be last.
            //
            if (!_tcsncmp(pszItem, INI_KEY_CAPTION0, lstrlen(INI_KEY_CAPTION0)-2)) {
                pszTemp = StrStr(pszItem, STR_EQUAL);
                if (NULL == (pbtbbiNew = (PBTOOLBAR_BUTTON_INFO)MALLOC(sizeof(BTOOLBAR_BUTTON_INFO)))) {
                    MsgBox(GetParent(hwnd), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
                    WIZ_EXIT(hwnd);
                    return;
                }
                lstrcpyn(pbtbbiNew->szCaption, pszTemp+1, MAX_NAME);
            }
            else if (!_tcsncmp(pszItem, INI_KEY_ACTION0, lstrlen(INI_KEY_ACTION0)-2)) {
                pszTemp = StrStr(pszItem, STR_EQUAL);
                lstrcpyn(pbtbbiNew->szAction, pszTemp+1, AS(pbtbbiNew->szAction));                
            }
            else if (!_tcsncmp(pszItem, INI_KEY_ICON0, lstrlen(INI_KEY_ICON0)-2)) {                
                pszTemp = StrStr(pszItem, STR_EQUAL);
                lstrcpyn(pbtbbiNew->szIconGray, pszTemp+1, AS(pbtbbiNew->szIconGray));
            }
            else if (!_tcsncmp(pszItem, INI_KEY_HOTICON0, lstrlen(INI_KEY_HOTICON0)-2)) {
                pszTemp = StrStr(pszItem, STR_EQUAL);
                lstrcpyn(pbtbbiNew->szIconColor, pszTemp+1, AS(pbtbbiNew->szIconColor));                
            }
            else if (!_tcsncmp(pszItem, INI_KEY_SHOW0, lstrlen(INI_KEY_SHOW0)-2)) {                
                pszTemp = StrStr(pszItem, STR_EQUAL);                
                pbtbbiNew->fShow = (_tcsicmp((pszTemp+1),_T("1")) ? FALSE : TRUE);

                // Add the toolbar button info to the list
                //
                FAddListItem(&g_pgTbbiList, &g_ppgTbbiNew, pbtbbiNew);

                // Add to the listbox 
                //
                iItem = ListBox_AddString(hwndList, pbtbbiNew->szCaption);
                ListBox_SetItemData(hwndList, iItem, pbtbbiNew);
            }
            
            // Move to end
            //
            while (*pszItem != NULLCHR) 
                pszItem++;
            pszItem++;
        }
    }

    // Free the section buffer...
    //
    if ( lpszTbSection )
        FREE( lpszTbSection );

    // Make sure a selection is made
    //
    ListBox_SetSel(hwndList, TRUE, iItem);        
}

// ToolbarPopupDlgProc used for gathering the toolbar button information
//
LRESULT CALLBACK ToolbarPopupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitTbPopup);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommandTbPopup);
    }

    return FALSE;
}

static BOOL OnInitTbPopup(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    g_pbtbbiNew = (PBTOOLBAR_BUTTON_INFO)lParam;

    if (g_pbtbbiNew) {
        CheckDlgButton(hwnd, IDC_BUTTONSTATE, BST_CHECKED);
        SendDlgItemMessage(hwnd, IDC_NAME , EM_LIMITTEXT, STRSIZE(g_pbtbbiNew->szCaption) - 1, 0L);
        SetWindowText(GetDlgItem(hwnd, IDC_NAME), g_pbtbbiNew->szCaption);

        SendDlgItemMessage(hwnd, IDC_URL , EM_LIMITTEXT, STRSIZE(g_pbtbbiNew->szAction) - 1, 0L);
        SetWindowText(GetDlgItem(hwnd, IDC_URL), g_pbtbbiNew->szAction);

        SendDlgItemMessage(hwnd, IDC_DICON , EM_LIMITTEXT, STRSIZE(g_pbtbbiNew->szIconColor) - 1, 0L);
        SetWindowText(GetDlgItem(hwnd, IDC_DICON), g_pbtbbiNew->szIconColor);

        SendDlgItemMessage(hwnd, IDC_GRAYSCALE , IDC_GRAYSCALE, STRSIZE(g_pbtbbiNew->szIconGray) - 1, 0L);
        SetWindowText(GetDlgItem(hwnd, IDC_GRAYSCALE), g_pbtbbiNew->szIconGray);        
    }

    return TRUE;
}

static void OnCommandTbPopup(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szFileName[MAX_PATH] = NULLSTR;

    switch ( id )
    {
        case IDC_BROWSE1:
        case IDC_BROWSE2:
        case IDC_BROWSE3:
            if (id == IDC_BROWSE1)
                GetDlgItemText(hwnd, IDC_URL, szFileName, STRSIZE(szFileName));
            else if (id == IDC_BROWSE2)
                GetDlgItemText(hwnd, IDC_DICON, szFileName, STRSIZE(szFileName));
            else if (id == IDC_BROWSE3)
                GetDlgItemText(hwnd, IDC_GRAYSCALE, szFileName, STRSIZE(szFileName));
            
            if ( BrowseForFile(hwnd, IDS_BROWSE, id == IDC_BROWSE1 ? IDS_EXEFILES : IDS_ICONFILES, id == IDC_BROWSE1 ? IDS_EXE : IDS_ICO, szFileName, STRSIZE(szFileName),
                g_App.szOpkDir, 0) ) {
                if (id == IDC_BROWSE1)
                    SetDlgItemText(hwnd, IDC_URL, szFileName);
                else 
                    SetDlgItemText(hwnd, id == IDC_BROWSE2 ? IDC_DICON : IDC_GRAYSCALE, szFileName);
            }
            break;

        case IDOK:
            if (FSaveBToolbarButtonInfo(hwnd, g_pbtbbiNew))
                EndDialog(hwnd, 1);
            break;

        case IDCANCEL:
            EndDialog(hwnd, 0);
            break;
    }
}

static BOOL FSaveBToolbarButtonInfo(HWND hwnd, PBTOOLBAR_BUTTON_INFO pbtbbi)
{
    TCHAR   szTemp[MAX_URL] = NULLSTR;
    UINT    fButton = BST_CHECKED;

    if (!pbtbbi)
        return FALSE;

    // Save the caption to the INS file.
    //
    szTemp[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_NAME, szTemp, STRSIZE(szTemp)); 
    lstrcpyn(pbtbbi->szCaption, szTemp,AS(pbtbbi->szCaption));
    if (!lstrlen(szTemp)) {
        MsgBox(GetParent(hwnd), IDS_MUST, IDS_APPNAME, MB_ERRORBOX, pbtbbi->szIconGray);
        SetFocus(GetDlgItem(hwnd, IDC_NAME));
        return FALSE;
    }       

    // Save the action to the INS file.
    //
    szTemp[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_URL, szTemp, STRSIZE(szTemp));
    lstrcpyn(pbtbbi->szAction, szTemp, AS(pbtbbi->szAction));
    if (!lstrlen(szTemp)) {
        MsgBox(GetParent(hwnd), IDS_MUST, IDS_APPNAME, MB_ERRORBOX, pbtbbi->szIconGray);
        SetFocus(GetDlgItem(hwnd, IDC_URL));
        return FALSE;
    }       

    // Verify the source of the hot icon file.
    //
    szTemp[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_DICON, szTemp, STRSIZE(szTemp));
    lstrcpyn(pbtbbi->szIconColor, szTemp, AS(pbtbbi->szIconColor));
    if (!FileExists(pbtbbi->szIconColor)) {
        MsgBox(GetParent(hwnd), lstrlen(pbtbbi->szIconColor) ? IDS_NOFILE : IDS_BLANKFILE, 
            IDS_APPNAME, MB_ERRORBOX, pbtbbi->szIconColor);
        SetFocus(GetDlgItem(hwnd, IDC_DICON));
        return FALSE;
    }       

    // Verify the source of the icon file.
    //
    szTemp[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_GRAYSCALE, szTemp, STRSIZE(szTemp));
    lstrcpyn(pbtbbi->szIconGray, szTemp, AS(pbtbbi->szIconGray));
    if (!FileExists(pbtbbi->szIconGray)) {
        MsgBox(GetParent(hwnd), lstrlen(pbtbbi->szIconGray) ? IDS_NOFILE : IDS_BLANKFILE, 
            IDS_APPNAME, MB_ERRORBOX, pbtbbi->szIconGray);
        SetFocus(GetDlgItem(hwnd, IDC_GRAYSCALE));
        return FALSE;
    }       

    // Save the button state of the button.
    //
    szTemp[0] = NULLCHR;
    fButton = IsDlgButtonChecked(hwnd, IDC_BUTTONSTATE);
    if (fButton == BST_CHECKED) {
        pbtbbi->fShow = TRUE;
    }
    else {
        pbtbbi->fShow = FALSE;
    }

    return TRUE;
}

static void SaveData(PGENERIC_LIST pList)
{
    TCHAR   szTemp[MAX_URL],
            szFullPath[MAX_PATH],
            szCopyFile[MAX_PATH],
            szTempKey[MAX_PATH];
    LPTSTR  lpFilePart,
            lpIePath;
    UINT    fButton = BST_CHECKED;
    INT     iItem = 0;
    HRESULT hrPrintf;

    // Get the path to the IE directory.
    //
    lpIePath = AllocateString(NULL, IDS_IEDESTDIR);

    // Clear the section [BrowserToolbars]
    //
    OpkWritePrivateProfileSection(INI_SEC_TOOLBAR, NULL, g_App.szInstallInsFile);

    while (pList) {
        PBTOOLBAR_BUTTON_INFO pbtbbi = (PBTOOLBAR_BUTTON_INFO)pList->pvItem;
        if (pbtbbi) {
            // Save the caption to the INS file.
            //
            szTemp[0] = NULLCHR;
            lstrcpyn(szTemp, pbtbbi->szCaption,AS(szTemp));
            hrPrintf=StringCchPrintf(szTempKey, AS(szTempKey), INI_KEY_CAPTION0, iItem);
            OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, szTemp, g_App.szInstallInsFile);


            // Save the action to the INS file.
            //
            szTemp[0] = NULLCHR;
            lstrcpyn(szTemp, pbtbbi->szAction, AS(szTemp));
            hrPrintf=StringCchPrintf(szTempKey, AS(szTempKey), INI_KEY_ACTION0, iItem);
            OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, szTemp, g_App.szInstallInsFile);

            // Save the source of the icon to the wizard INF because it is
            // the only one that needs to know it.
            //
            szTemp[0] = NULLCHR;
            lstrcpyn(szTemp, pbtbbi->szIconGray,AS(szTemp));
            hrPrintf=StringCchPrintf(szTempKey, AS(szTempKey), INI_KEY_ICON0, iItem);
            OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, szTemp, g_App.szOpkWizIniFile);

            // Add the icon source file name onto the IE destination path to
            // write to the INS file.
            //
            if ( GetFullPathName(szTemp, STRSIZE(szFullPath), szFullPath, &lpFilePart) && lpFilePart )
            {
                /* NOTE: Why are we doing this?  This makes the file c:\windows\internet explorer\signup\*.ico
                         However talking to Pritvi they don't really care about the path, they always assume the
                         file will be in c:\windows\internet explorer\signup.

                lstrcpyn(szTemp, lpIePath,AS(szTemp));
                AddPathN(szTemp, lpFilePart,AS(szTemp));
                */
                hrPrintf=StringCchPrintf(szTempKey, AS(szTempKey), INI_KEY_ICON0, iItem);
                OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, szTemp, g_App.szInstallInsFile);
            }

            // Save the source of the hot icon to the wizard INF because it is
            // the only one that needs to know it.
            //
            szTemp[0] = NULLCHR;
            lstrcpyn(szTemp, pbtbbi->szIconColor,AS(szTemp));
            hrPrintf=StringCchPrintf(szTempKey, AS(szTempKey), INI_KEY_HOTICON0, iItem);
            OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, szTemp, g_App.szOpkWizIniFile);

            // Add the hot icon source file name onto the IE destination path to
            // write to the INS file.
            //
            if ( GetFullPathName(szTemp, STRSIZE(szFullPath), szFullPath, &lpFilePart) && lpFilePart )
            {
                /* NOTE: Why are we doing this?  This makes the file c:\windows\internet explorer\signup\*.ico
                         However talking to Pritvi they don't really care about the path, they always assume the
                         file will be in c:\windows\internet explorer\signup.

                lstrcpyn(szTemp, lpIePath,AS(szTemp));
                AddPathN(szTemp, lpFilePart,AS(szTemp));
                */
                hrPrintf=StringCchPrintf(szTempKey, AS(szTempKey), INI_KEY_HOTICON0, iItem);
                OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, szTemp, g_App.szInstallInsFile);
            }

            // Copy item files 
            //
            lstrcpyn(szCopyFile, g_App.szTempDir,AS(szCopyFile));
            AddPathN(szCopyFile, DIR_IESIGNUP,AS(szCopyFile));
            AddPathN(szCopyFile, PathFindFileName(pbtbbi->szIconColor),AS(szCopyFile));
            CopyFile(pbtbbi->szIconColor, szCopyFile, FALSE);
            
            lstrcpyn(szCopyFile, g_App.szTempDir,AS(szCopyFile));
            AddPathN(szCopyFile, DIR_IESIGNUP,AS(szCopyFile));
            AddPathN(szCopyFile, PathFindFileName(pbtbbi->szIconGray),AS(szCopyFile));
            CopyFile(pbtbbi->szIconGray, szCopyFile, FALSE);


            // Save the button state of the button to the INS. 
            //
            szTemp[0] = NULLCHR;
            fButton = pbtbbi->fShow;
            hrPrintf=StringCchPrintf(szTempKey, AS(szTempKey), INI_KEY_SHOW0, iItem);
            if (fButton == BST_CHECKED) {
                OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, _T("1"), g_App.szInstallInsFile);
                pbtbbi->fShow = TRUE;
            }
            else {
                OpkWritePrivateProfileString(INI_SEC_TOOLBAR, szTempKey, _T("0"), g_App.szInstallInsFile);
                pbtbbi->fShow = FALSE;
            }
        }

        // Next item
        //
        pList = pList ? pList->pNext : NULL;
        iItem++;
    }

    // Free the IE destination.
    //
    FREE(lpIePath);
}

void SaveBToolbar()
{
    SaveData(g_pgTbbiList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\appinst.h ===
/****************************************************************************\

    APPINST.H / Setup Manager (SETUPMGR.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001
    All rights reserved

    06/2001 - Jason Cohen (JCOHEN)
        Added this new header file for the new exported functions in the
        APPINST.C file.

\****************************************************************************/


#ifndef _APPINST_H_
#define _APPINST_H_


//
// External Defined Value(s):
//

#define MAX_DISPLAYNAME                 256

// ISSUE-2002/02/27-stelo,swamip - Multiple Definitions for MAX_CMDLINE 
#define MAX_CMDLINE                     256
#define MAX_SECTIONNAME                 32

#define APP_FLAG_REBOOT                 0x00000001
#define APP_FLAG_STAGE                  0x00000002
#define APP_FLAG_INTERNAL               0x00000004


//
// External Type Definition(s):
//

typedef struct _APPENTRY
{
    TCHAR               szDisplayName[MAX_DISPLAYNAME];
    TCHAR               szSourcePath[MAX_PATH];
    TCHAR               szSetupFile[MAX_PATH];
    TCHAR               szCommandLine[MAX_CMDLINE];
    DWORD               dwFlags;

    TCHAR               szSectionName[MAX_SECTIONNAME];
    INSTALLTECH         itSectionType;

    TCHAR               szInfSectionName[256];
    TCHAR               szStagePath[MAX_PATH];

    struct _APPENTRY *  lpNext;
}
APPENTRY, *PAPPENTRY, *LPAPPENTRY, **LPLPAPPENTRY;


//
// External Function Prototype(s):
//

LPAPPENTRY OpenAppList(LPTSTR lpIniFile);
void CloseAppList(LPAPPENTRY lpAppHead);
BOOL SaveAppList(LPAPPENTRY lpAppHead, LPTSTR lpszIniFile, LPTSTR lpszAltIniFile);
BOOL InsertApp(LPAPPENTRY * lplpAppHead, LPAPPENTRY lpApp);
BOOL RemoveApp(LPAPPENTRY * lplpAppHead, LPAPPENTRY lpApp);


#endif // _APPINST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\config.c ===
/****************************************************************************\

    CONFIG.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "existing configuration" wizard page.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.

    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static BOOL OnNext(HWND);
static void EnableControls(HWND, BOOL);


//
// External Function(s):
//

LRESULT CALLBACK ConfigDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        case WM_COMMAND:

            switch ( LOWORD(wParam) )
            {
                case IDC_NEW:
                case IDC_EXISTING:
                    EnableControls(hwnd, IsDlgButtonChecked(hwnd, IDC_EXISTING) == BST_CHECKED);
                    if ( ( LOWORD(wParam) != IDC_NEW ) &&
                         ( SendDlgItemMessage(hwnd, IDC_CONFIGS_LIST, LB_GETCURSEL, 0, 0L) < 0 ) )
                    {
                        WIZ_BUTTONS(hwnd, PSWIZB_BACK);
                    }
                    else
                        WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    break;

                case IDC_CONFIGS_LIST:

                    switch ( HIWORD(wParam) )
                    {
                        case LBN_SELCHANGE:
                            WIZ_BUTTONS(hwnd, ( SendDlgItemMessage(hwnd, IDC_CONFIGS_LIST, LB_GETCURSEL, 0, 0L) < 0 ) ? PSWIZB_BACK : (PSWIZB_BACK | PSWIZB_NEXT));
                            break;

                        case LBN_DBLCLK:
                            WIZ_PRESS(hwnd, PSBTN_NEXT);
                            break;
                    }
                    break;
            }
            return FALSE;

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:

                    // Make sure the user has an item selected if they choose
                    // an existing config set.
                    //
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_CONFIG;

                    // We want to skip this page if there are no config sets
                    // to choose from or we alread were passed one on the command
                    // line.
                    //
                    if ( ( SendDlgItemMessage(hwnd, IDC_CONFIGS_LIST, LB_GETCOUNT, 0, 0L) <= 0 ) ||
                         ( GET_FLAG(OPK_CMDMM) ||
                         ( GET_FLAG(OPK_BATCHMODE)) ) )
                    {
                        WIZ_SKIP(hwnd);
                    }
                    else
                    {
                        WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                        // Press next if the user is in auto mode
                        //
                        WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);
                    }

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;
    TCHAR           szFileName[MAX_PATH];
    LPTSTR          lpDir;
    int                 iDirLen;

    // Check the default radio button.
    //
    CheckRadioButton(hwnd, IDC_NEW, IDC_EXISTING, IDC_NEW);
    EnableControls(hwnd, FALSE);

    // Setup the list box with a list of availible config sets.
    //
    SetCurrentDirectory(g_App.szConfigSetsDir);
    lstrcpyn(szFileName, g_App.szConfigSetsDir,AS(szFileName));
    AddPathN(szFileName, NULLSTR,AS(szFileName));
    iDirLen= AS(szFileName)-lstrlen(szFileName);
    lpDir = szFileName + lstrlen(szFileName);
    if ( (hFile = FindFirstFile(_T("*"), &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // Look for all the directories that are not "." or "..".
            //
            if ( ( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                 ( lstrcmp(FileFound.cFileName, _T(".")) ) &&
                 ( lstrcmp(FileFound.cFileName, _T("..")) ) )
            {
                // Make sure the directory contains a valid config set and
                // add the directory name to the list box if it is.
                //
                lstrcpyn(lpDir, FileFound.cFileName,iDirLen);
                AddPathN(lpDir, FILE_OPKWIZ_INI,iDirLen);
                if ( GetPrivateProfileInt(INI_SEC_CONFIGSET, INI_KEY_FINISHED, 0, szFileName) == 1 )
                    SendDlgItemMessage(hwnd, IDC_CONFIGS_LIST, LB_ADDSTRING, 0, (LPARAM) FileFound.cFileName);
            }

        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }

    if ( GET_FLAG(OPK_OPENCONFIG) )
    {
        CheckRadioButton(hwnd, IDC_NEW, IDC_EXISTING, IDC_EXISTING);
        EnableControls(hwnd, IsDlgButtonChecked(hwnd, IDC_EXISTING) == BST_CHECKED);
        SET_FLAG(OPK_OPENCONFIG, FALSE);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static BOOL OnNext(HWND hwnd)
{
    BOOL    bOk     = TRUE,
            bReset  = FALSE;

    // Check to see if they want to use an existing config set.
    //
    if ( IsDlgButtonChecked(hwnd, IDC_EXISTING) == BST_CHECKED )
    {
        INT     nItem = (INT) SendDlgItemMessage(hwnd, IDC_CONFIGS_LIST, LB_GETCURSEL, 0, 0L);
        TCHAR   szConfigName[MAX_PATH],
                szConfigDir[MAX_PATH];

        // Make the path to where the config directory is.
        //
        lstrcpyn(szConfigDir, g_App.szConfigSetsDir,AS(szConfigDir));
        AddPathN(szConfigDir, NULLSTR,AS(szConfigDir));
        szConfigName[0] = NULLCHR;

        // Make sure there is one selected.
        //
        if ( ( nItem >= 0 ) &&
             ( SendDlgItemMessage(hwnd, IDC_CONFIGS_LIST, LB_GETTEXTLEN, nItem, 0L) < STRSIZE(szConfigName) ) &&
             ( SendDlgItemMessage(hwnd, IDC_CONFIGS_LIST, LB_GETTEXT, nItem, (LPARAM) szConfigName) > 0 ) &&
             ( szConfigName[0] ) &&
             ( (STRSIZE(szConfigDir) - lstrlen(szConfigDir)) > (UINT) lstrlen(szConfigName) ) )
        {
            if ( !( GET_FLAG(OPK_CREATED) && g_App.szTempDir[0] && ( !GET_FLAG(OPK_MAINTMODE) || lstrcmpi(g_App.szConfigName, szConfigName) ) ) ||
                 (bReset = ( MsgBox(GetParent(hwnd), ( GET_FLAG(OPK_MAINTMODE) && g_App.szConfigName[0] ) ? IDS_LOSEOLD : IDS_LOSENEW, IDS_APPNAME, MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION, szConfigName, g_App.szConfigName) == IDYES )) )
            {
                // We only want to do this stuff if there is already a config set and they choose to
                // reset it to another.
                //
                if ( bReset )
                {
                    if ( g_App.szTempDir[0] )
                        DeletePath(g_App.szTempDir);
                    SET_FLAG(OPK_CREATED, FALSE);
                }
                else
                {
                    lstrcpyn(g_App.szTempDir, szConfigDir,AS(g_App.szTempDir));
                    lstrcpyn(g_App.szConfigName, szConfigName,AS(g_App.szConfigName));
                    AddPathN(g_App.szTempDir, g_App.szConfigName,AS(g_App.szTempDir));
                    AddPathN(g_App.szTempDir, NULLSTR,AS(g_App.szTempDir));
                }

                // It doesn't hurt to always set the maint mode flag.
                //
                SET_FLAG(OPK_MAINTMODE, TRUE);
            }
            else
                bOk = FALSE;
        }
        else
            bOk = FALSE;
    }
    else
    {
        // See if we alread have a maint mode config set we are working on.
        //
        if ( !( GET_FLAG(OPK_CREATED) && GET_FLAG(OPK_MAINTMODE) && g_App.szTempDir[0] && g_App.szConfigName[0] ) ||
             (bReset = ( MsgBox(GetParent(hwnd), IDS_LOSECHANGES, IDS_APPNAME, MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION, g_App.szConfigName) == IDYES )) )
        {
            // We only want to do this stuff if there is already a config set and they choose to
            // reset it to another.
            //
            if ( bReset )
            {
                if ( g_App.szTempDir[0] )
                    DeletePath(g_App.szTempDir);
                SET_FLAG(OPK_CREATED, FALSE);
                g_App.szTempDir[0] = NULLCHR;
                g_App.szConfigName[0] = NULLCHR;
            }

            // It doesn't hurt to always reset the maint mode flag.
            //
            SET_FLAG(OPK_MAINTMODE, FALSE);                
        }
        else
            bOk = FALSE;
    }

    return bOk;
}

static void EnableControls(HWND hwnd, BOOL fEnable)
{
    EnableWindow(GetDlgItem(hwnd, IDC_CONFIGS_TEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_CONFIGS_LIST), fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\crc32.c ===
/****************************************************************************\

    CRC32.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    CRC API source file for CRC APIs used in the OPK Wizard.

    ??/?? - Mike Sliger (MSLIGER)
        Original Author.

    08/93 - BENS
        Initional version.

    04/96 - PRITOBLA
        Changed to a 32-bit program.

    05/99 - Jason Cohen (JCOHEN)
        Updated this old source file for the OPK Wizard as part of the
        Millennium rewrite.  Simply cleaned it up a little.

    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Internal Include File(s):
//

#include "pch.h"


//
// Internal Defined Value(s):
//

#define CRC32_INITIAL_VALUE 0L  // Must use this as initial value for CRC


//
// Internal Constant(s):
//

static long crc_32_tab[] =
{
    0x00000000L, 0x77073096L, 0xEE0E612CL, 0x990951BAL, 0x076DC419L, 0x706AF48FL, 0xE963A535L, 0x9E6495A3L,
    0x0EDB8832L, 0x79DCB8A4L, 0xE0D5E91EL, 0x97D2D988L, 0x09B64C2BL, 0x7EB17CBDL, 0xE7B82D07L, 0x90BF1D91L,
    0x1DB71064L, 0x6AB020F2L, 0xF3B97148L, 0x84BE41DEL, 0x1ADAD47DL, 0x6DDDE4EBL, 0xF4D4B551L, 0x83D385C7L,
    0x136C9856L, 0x646BA8C0L, 0xFD62F97AL, 0x8A65C9ECL, 0x14015C4FL, 0x63066CD9L, 0xFA0F3D63L, 0x8D080DF5L,
    0x3B6E20C8L, 0x4C69105EL, 0xD56041E4L, 0xA2677172L, 0x3C03E4D1L, 0x4B04D447L, 0xD20D85FDL, 0xA50AB56BL,
    0x35B5A8FAL, 0x42B2986CL, 0xDBBBC9D6L, 0xACBCF940L, 0x32D86CE3L, 0x45DF5C75L, 0xDCD60DCFL, 0xABD13D59L,
    0x26D930ACL, 0x51DE003AL, 0xC8D75180L, 0xBFD06116L, 0x21B4F4B5L, 0x56B3C423L, 0xCFBA9599L, 0xB8BDA50FL,
    0x2802B89EL, 0x5F058808L, 0xC60CD9B2L, 0xB10BE924L, 0x2F6F7C87L, 0x58684C11L, 0xC1611DABL, 0xB6662D3DL,

    0x76DC4190L, 0x01DB7106L, 0x98D220BCL, 0xEFD5102AL, 0x71B18589L, 0x06B6B51FL, 0x9FBFE4A5L, 0xE8B8D433L,
    0x7807C9A2L, 0x0F00F934L, 0x9609A88EL, 0xE10E9818L, 0x7F6A0DBBL, 0x086D3D2DL, 0x91646C97L, 0xE6635C01L,
    0x6B6B51F4L, 0x1C6C6162L, 0x856530D8L, 0xF262004EL, 0x6C0695EDL, 0x1B01A57BL, 0x8208F4C1L, 0xF50FC457L,
    0x65B0D9C6L, 0x12B7E950L, 0x8BBEB8EAL, 0xFCB9887CL, 0x62DD1DDFL, 0x15DA2D49L, 0x8CD37CF3L, 0xFBD44C65L,
    0x4DB26158L, 0x3AB551CEL, 0xA3BC0074L, 0xD4BB30E2L, 0x4ADFA541L, 0x3DD895D7L, 0xA4D1C46DL, 0xD3D6F4FBL,
    0x4369E96AL, 0x346ED9FCL, 0xAD678846L, 0xDA60B8D0L, 0x44042D73L, 0x33031DE5L, 0xAA0A4C5FL, 0xDD0D7CC9L,
    0x5005713CL, 0x270241AAL, 0xBE0B1010L, 0xC90C2086L, 0x5768B525L, 0x206F85B3L, 0xB966D409L, 0xCE61E49FL,
    0x5EDEF90EL, 0x29D9C998L, 0xB0D09822L, 0xC7D7A8B4L, 0x59B33D17L, 0x2EB40D81L, 0xB7BD5C3BL, 0xC0BA6CADL,

    0xEDB88320L, 0x9ABFB3B6L, 0x03B6E20CL, 0x74B1D29AL, 0xEAD54739L, 0x9DD277AFL, 0x04DB2615L, 0x73DC1683L,
    0xE3630B12L, 0x94643B84L, 0x0D6D6A3EL, 0x7A6A5AA8L, 0xE40ECF0BL, 0x9309FF9DL, 0x0A00AE27L, 0x7D079EB1L,
    0xF00F9344L, 0x8708A3D2L, 0x1E01F268L, 0x6906C2FEL, 0xF762575DL, 0x806567CBL, 0x196C3671L, 0x6E6B06E7L,
    0xFED41B76L, 0x89D32BE0L, 0x10DA7A5AL, 0x67DD4ACCL, 0xF9B9DF6FL, 0x8EBEEFF9L, 0x17B7BE43L, 0x60B08ED5L,
    0xD6D6A3E8L, 0xA1D1937EL, 0x38D8C2C4L, 0x4FDFF252L, 0xD1BB67F1L, 0xA6BC5767L, 0x3FB506DDL, 0x48B2364BL,
    0xD80D2BDAL, 0xAF0A1B4CL, 0x36034AF6L, 0x41047A60L, 0xDF60EFC3L, 0xA867DF55L, 0x316E8EEFL, 0x4669BE79L,
    0xCB61B38CL, 0xBC66831AL, 0x256FD2A0L, 0x5268E236L, 0xCC0C7795L, 0xBB0B4703L, 0x220216B9L, 0x5505262FL,
    0xC5BA3BBEL, 0xB2BD0B28L, 0x2BB45A92L, 0x5CB36A04L, 0xC2D7FFA7L, 0xB5D0CF31L, 0x2CD99E8BL, 0x5BDEAE1DL,

    0x9B64C2B0L, 0xEC63F226L, 0x756AA39CL, 0x026D930AL, 0x9C0906A9L, 0xEB0E363FL, 0x72076785L, 0x05005713L,
    0x95BF4A82L, 0xE2B87A14L, 0x7BB12BAEL, 0x0CB61B38L, 0x92D28E9BL, 0xE5D5BE0DL, 0x7CDCEFB7L, 0x0BDBDF21L,
    0x86D3D2D4L, 0xF1D4E242L, 0x68DDB3F8L, 0x1FDA836EL, 0x81BE16CDL, 0xF6B9265BL, 0x6FB077E1L, 0x18B74777L,
    0x88085AE6L, 0xFF0F6A70L, 0x66063BCAL, 0x11010B5CL, 0x8F659EFFL, 0xF862AE69L, 0x616BFFD3L, 0x166CCF45L,
    0xA00AE278L, 0xD70DD2EEL, 0x4E048354L, 0x3903B3C2L, 0xA7672661L, 0xD06016F7L, 0x4969474DL, 0x3E6E77DBL,
    0xAED16A4AL, 0xD9D65ADCL, 0x40DF0B66L, 0x37D83BF0L, 0xA9BCAE53L, 0xDEBB9EC5L, 0x47B2CF7FL, 0x30B5FFE9L,
    0xBDBDF21CL, 0xCABAC28AL, 0x53B39330L, 0x24B4A3A6L, 0xBAD03605L, 0xCDD70693L, 0x54DE5729L, 0x23D967BFL,
    0xB3667A2EL, 0xC4614AB8L, 0x5D681B02L, 0x2A6F2B94L, 0xB40BBE37L, 0xC30C8EA1L, 0x5A05DF1BL, 0x2D02EF8DL
};


//
// Internal Function Prototype(s):
//

static ULONG Crc32Compute(PBYTE, DWORD, ULONG);


//
// External Function(s):
//

/****************************************************************************\

    CrcFile() - Does a CRC on a filename

\****************************************************************************/

ULONG CrcFile(LPCTSTR lpszFQFile)
{
    HANDLE  hFile;
    LPTSTR  lpszBuf;
    DWORD   dwSize  = 0x8000,
            dwRead  = 0;
    ULONG   ulRes    = CRC32_INITIAL_VALUE;

    while ( ( dwSize > 32 )  && ( (lpszBuf = (LPTSTR) LocalAlloc(LPTR, dwSize)) == NULL ) )
        dwSize >>= 1;
        
    if ( lpszBuf == NULL )
        return 0;

    if ( (hFile = CreateFile(lpszFQFile, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE )
    {
        while ( ( ReadFile(hFile, (LPVOID) lpszBuf, dwSize, &dwRead, NULL) ) && ( dwRead > 0 ) )
            ulRes = Crc32Compute((PBYTE) lpszBuf, dwRead, ulRes);
        CloseHandle(hFile);
    }

    LocalFree(lpszBuf);

    return ulRes;
}


//
// Internal Functon(s):
//

/****************************************************************************\

    Crc32Compute() - Compute 32-bit

    Entry:
        pb    - Pointer to buffer to computer CRC on
        cb    - Count of bytes in buffer to CRC
        crc32 - Result from previous Crc32Compute call (on first call
                to Crc32Compute, must be CRC32_INITIAL_VALUE!!!!).

    Exit:
        Returns updated CRC value.

\****************************************************************************/

static ULONG Crc32Compute(PBYTE pb, DWORD cb, ULONG crc32)
{
    // Put CRC in form loop wants it.
    //
    crc32 = (-1L - crc32);

    while (cb--)
        crc32 = crc_32_tab[(BYTE) crc32 ^ *pb++] ^ ((crc32 >> 8) & 0x00FFFFFFL);

    // Put CRC in form client wants it.
    //
    return (-1L - crc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\favorite.c ===
/****************************************************************************\

    FAVORITE.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "IE Favorites" wizard page.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.

   10/99 - Brian Ku (BRIANK)
        Modified this file for the IEAK integration.

   09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"

/* Example:
 
[URL]
Quick_Link_1_Name=Customize Links.url
Quick_Link_1=http://www.microsoft.com/isapi/redir.dll?prd=ie&pver=5.0&ar=CLinks
Quick_Link_2_Name=Free Hotmail.url
Quick_Link_2=http://www.microsoft.com/isapi/redir.dll?prd=ie&ar=hotmail
Quick_Link_3_Name=Windows.url
Quick_Link_3=http://www.microsoft.com/isapi/redir.dll?prd=ie&ar=windows
...

[FavoritesEx]
Title1=News.url
URL1=http://www.cnn.com
IconFile1=c:\windows\temp\iedktemp\branding\favs\iefav.ico
Title2=MSN.url
URL2=http://www.microsoft.com/isapi/redir.dll?prd=ie&pver=5.0&ar=IStart
Title3=Radio Station Guide.url
URL3=http://www.microsoft.com/isapi/redir.dll?prd=windows&sbp=mediaplayer&plcid=&pver=6.1&os=&over=&olcid=&clcid=&ar=Media&sba=RadioBar&o1=&o2=&o3=
Title4=Web Events.url
URL4=http://www.microsoft.com/isapi/redir.dll?prd=windows&sbp=mediaplayer&plcid=&pver=5.2&os=&over=&olcid=&clcid=&ar=Media&sba=Showcase&o1=&o2=&o3=
Title5=celair.url
URL5=http://www.celair.com
IconFile5=c:\windows\temp\iedktemp\branding\favs\iefav.ico
Title6=My Favorites\celair.url
URL6=http://www.celair.com

[Favorites]
News.url=http://www.cnn.com
MSN.url=http://www.microsoft.com/isapi/redir.dll?prd=ie&pver=5.0&ar=IStart
Radio Station Guide.url=http://www.microsoft.com/isapi/redir.dll?prd=windows&sbp=mediaplayer&plcid=&pver=6.1&os=&over=&olcid=&clcid=&ar=Media&sba=RadioBar&o1=&o2=&o3=
Web Events.url=http://www.microsoft.com/isapi/redir.dll?prd=windows&sbp=mediaplayer&plcid=&pver=5.2&os=&over=&olcid=&clcid=&ar=Media&sba=Showcase&o1=&o2=&o3=
celair.url=http://www.celair.com
My Favorites\celair.url=http://www.celair.com
*/

//
// Innternal Defined Value(s):
//

#define INI_SEC_GENERAL     _T("General")
#define INI_KEY_MANUFACT    _T("Manufacturer")

#define INI_SEC_FAV         _T("Favorites")

#define INI_SEC_FAVEX       _T("FavoritesEx")
#define INI_KEY_TITLE       _T("Title%d")
#define INI_KEY_URL         _T("URL%d")
#define INI_KEY_ICON        _T("IconFile%d")

#define INI_KEY_QUICKLINK   _T("Quick_Link_%d%s")
#define NAME                _T("_Name")

#define MAX_TITLE           256 + MAX_URL
#define MAX_QUICKLINKS      10

#define STATIC_FAVS         2   // This is the number of static favorites in the install.ins, oems can't change the first N number of favs
#define STATIC_LINKS        4   // This is the number of static quick links in the install.ins
//
// Favorites structures for tree and details dialog
//

typedef struct _FAV_ITEM {
    HTREEITEM   hItem;
    HWND        hwndTV;
    BOOL        fLink;                          // This is a Quick Link
    BOOL        fFolder;                        // This is a Folder
    BOOL        fNew;
    TCHAR       szParents[MAX_PATH];
    TCHAR       szName[MAX_TITLE];
    TCHAR       szUrl[MAX_URL];
    TCHAR       szIcon[MAX_PATH];
}FAV_ITEM, *PFAV_ITEM;

//
// Internal Global variables
//

PGENERIC_LIST   g_prgFavList    = NULL;           // Generic list of PFAV_ITEM items
PGENERIC_LIST*  g_ppFavItemNew  = &g_prgFavList;  // Pointer to next unallocated item in list
PFAV_ITEM       g_pFavPopupInfo = NULL;           // New favorite info item


//
// Internal Function Prototype(s):
//

static BOOL OnInitFav(HWND, HWND, LPARAM);
static void OnCommandFav(HWND, INT, HWND, UINT);
static void OnAddUrl(HWND);
static void OnAddFolder(HWND);
static void OnEdit(HWND);
static void OnTestUrl(HWND);
static void OnRemoveUrl(HWND hDlg);
static HTREEITEM AddFav(HWND, HTREEITEM, LPTSTR, LPTSTR, LPTSTR, BOOL);
static void SetFavItem(PFAV_ITEM, LPTSTR, LPTSTR, LPTSTR);
static void DeleteFavItem(HTREEITEM);
static BOOL FSaveFavPopupInfo(HWND, PFAV_ITEM, BOOL);
static void GetSelectedFavFromTree(HWND, PFAV_ITEM*);
static PFAV_ITEM GetTreeItemHt(HWND hwndTV, HTREEITEM htFavItem);
static BOOL OnInitFavPopup(HWND, HWND, LPARAM);
static void OnCommandFavPopup(HWND, INT, HWND, UINT);
LRESULT CALLBACK FavoritesPopupDlgProc(HWND, UINT, WPARAM, LPARAM);
static void SaveData(PGENERIC_LIST);
static void DisableButtons(HWND);
static HTREEITEM FindTreeItem(HWND, HTREEITEM, LPTSTR);
static void DisableIconField(HWND hwnd); 

void SaveFavorites();

//
// External Function(s):
//

LRESULT CALLBACK FavoritesDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitFav);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommandFav);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    SaveFavorites();
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_FAVORITES;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                case TVN_SELCHANGED:
                    if (wParam == IDC_FAVS) 
                        DisableButtons(hwnd);
                    break;

                case NM_DBLCLK:
                    if (wParam == IDC_FAVS) 
                        OnEdit(hwnd);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_DESTROY:
            FreeList(g_prgFavList);
            g_ppFavItemNew  = &g_prgFavList;
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInitFav(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND            hwndTV              = GetDlgItem(hwnd, IDC_FAVS);
    HTREEITEM       hRoot               = NULL;
    int             nCount              = 1;
    TCHAR           szText[MAX_TITLE]   = NULLSTR,
                    szUrl[MAX_URL]      = NULLSTR,
                    szIcon[MAX_PATH]    = NULLSTR,
                    szKey[32];
    LPTSTR          lpFav;
    HRESULT hrPrintf;

    // Add the root tree view item.
    //
    if ( lpFav = AllocateString(NULL, IDS_FAVORITES) )
    {
        hRoot = AddFav(hwndTV, NULL, lpFav, NULL, NULL, FALSE);
        FREE(lpFav);
    }

    // Get all the FAVORITES from the install INS file.
    //
    do
    {
        szText[0] = NULLCHR;
        szUrl[0] = NULLCHR;
        szIcon[0] = NULLCHR;

        // First get the title.
        //
        hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_TITLE, nCount);
        GetPrivateProfileString(INI_SEC_FAVEX, szKey, NULLSTR, szText, STRSIZE(szText), ( GET_FLAG(OPK_BATCHMODE) && (nCount > STATIC_FAVS) ) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile);


        // Then get the URL.
        //
        hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_URL, nCount);
        GetPrivateProfileString(INI_SEC_FAVEX, szKey, NULLSTR, szUrl, STRSIZE(szUrl), ( GET_FLAG(OPK_BATCHMODE) && (nCount > STATIC_FAVS) ) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile);

        // Get the icon.
        //
        hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_ICON, nCount);
        GetPrivateProfileString(INI_SEC_FAVEX, szKey, NULLSTR, szIcon, STRSIZE(szIcon), ( GET_FLAG(OPK_BATCHMODE) && (nCount > STATIC_FAVS) ) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile);
        
        // Make sure we have the required items.
        //
        if ( szText[0] || szUrl[0] )
            AddFav(hwndTV, hRoot, szText, szUrl, szIcon, FALSE);
        else
            nCount = 0;
    }
    while (nCount++);

    // Always expand the root out.
    //
    if ( hRoot )
        TreeView_Expand(hwndTV, hRoot, TVE_EXPAND);

    // Add the root tree view item.
    //
    if ( lpFav = AllocateString(NULL, IDS_LINKS) )
    {
        hRoot = AddFav(hwndTV, NULL, lpFav, NULL, NULL, TRUE);
        FREE(lpFav);
    }

    // Get all the QUICK LINKS from the install INS file.
    //
    do
    {
        szText[0] = NULLCHR;
        szUrl[0] = NULLCHR;
        szIcon[0] = NULLCHR;

        // First get the quick link.
        //
        hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_QUICKLINK, nCount, NULLSTR);
        GetPrivateProfileString(INI_SEC_URL, szKey, NULLSTR, szUrl, STRSIZE(szUrl), ( GET_FLAG(OPK_BATCHMODE) && (nCount > STATIC_LINKS) ) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile);

        if (szUrl[0]) {
            hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_QUICKLINK, nCount, NAME);
            GetPrivateProfileString(INI_SEC_URL, szKey, NULLSTR, szText, STRSIZE(szText), ( GET_FLAG(OPK_BATCHMODE) && (nCount > STATIC_LINKS) ) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile);

        }

        // Make sure we have the required items.
        //
        if ( szText[0] || szUrl[0] )
            AddFav(hwndTV, hRoot, szText, szUrl, szIcon, TRUE);
        else
            nCount = 0;
    }
    while (nCount++);

    // Always expand the root out.
    //
    if ( hRoot )
        TreeView_Expand(hwndTV, hRoot, TVE_EXPAND);
    

    // Make sure the buttons are in their proper state
    //
    DisableButtons(hwnd);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommandFav(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    // Controls
    //
    switch ( id )
    {
        case IDC_ADDURL:
            OnAddUrl(hwnd);
            break;
        case IDC_ADDFOLDER:
            OnAddFolder(hwnd);
            break;
        case IDC_EDIT:
            OnEdit(hwnd);
            break;
        case IDC_TESTURL:
            OnTestUrl(hwnd);
            break;
        case IDC_REMOVE:
            OnRemoveUrl(hwnd);
            break;
    }
}

static void DisableButtons(HWND hwnd)
{
    PFAV_ITEM pFavItem = NULL;
    GetSelectedFavFromTree(GetDlgItem(hwnd, IDC_FAVS), &pFavItem);

    // If it's a folder disable the test url
    //
    if (pFavItem && pFavItem->fFolder) {
        EnableWindow(GetDlgItem(hwnd, IDC_TESTURL), FALSE);  

        // If Root disable edit
        //
        if (NULL == TreeView_GetParent(pFavItem->hwndTV, pFavItem->hItem))
            EnableWindow(GetDlgItem(hwnd, IDC_EDIT), FALSE);

        // If it's a quick link disable the add folders
        //
        if (!pFavItem->fLink)
            EnableWindow(GetDlgItem(hwnd, IDC_ADDFOLDER), TRUE); 
        else
            EnableWindow(GetDlgItem(hwnd, IDC_ADDFOLDER), FALSE); 

        EnableWindow(GetDlgItem(hwnd, IDC_ADDURL), TRUE);
    }
    else if (pFavItem && !pFavItem->fFolder) {
        // Urls disable add folder and add url
        //
        EnableWindow(GetDlgItem(hwnd, IDC_TESTURL), TRUE);  
        EnableWindow(GetDlgItem(hwnd, IDC_EDIT), TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_ADDFOLDER), FALSE); 
        EnableWindow(GetDlgItem(hwnd, IDC_ADDURL), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_REMOVE), TRUE);
    }
    else
    {
        // There is currently no selection, we need to disable all the buttons
        //
        EnableWindow(GetDlgItem(hwnd, IDC_TESTURL), FALSE);  
        EnableWindow(GetDlgItem(hwnd, IDC_EDIT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_ADDFOLDER), FALSE); 
        EnableWindow(GetDlgItem(hwnd, IDC_ADDURL), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_REMOVE), FALSE);
    }
}

// Rewrite of AddFav
// 1. If lpszText then folder
// 2. If lpszText and lpszUrl then URL
//
static HTREEITEM AddFav(HWND hwndTV, HTREEITEM htParent, LPTSTR lpszText, LPTSTR lpszUrl, 
                        LPTSTR lpszIcon, BOOL fLink)
{
    TVINSERTSTRUCT  tvisItem;
    HTREEITEM       hParent                 = NULL,
                    hRoot                   = TreeView_GetRoot(hwndTV);
    INT             i                       = 0,
                    j                       = 0;
    HRESULT hrCat;

    // Make sure there is a valid lpszText pointer...
    //
    if ( NULL == lpszText )
    {
        return NULL;
    }

    // We're adding with a Parent coming in
    //
    if (htParent)
        hRoot = htParent;
    else
        hRoot = NULL;

    // Check if we're adding a folder or url
    //
    if ( !lpszUrl ) 
    {
        // We're adding a root folder
        //
        PFAV_ITEM pFavNew = (PFAV_ITEM)MALLOC(sizeof(FAV_ITEM));
        if (NULL == pFavNew) {
            MsgBox(NULL, IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
            
            return NULL;
        }
        pFavNew->fFolder  = TRUE;
        pFavNew->fNew     = FALSE;
        pFavNew->fLink    = fLink;
        pFavNew->hwndTV   = hwndTV;
        SetFavItem(pFavNew, lpszText, NULL, NULL);

        FAddListItem(&g_prgFavList, &g_ppFavItemNew, pFavNew);

        // Add this folder and use it as the parent for the next item to add.
        //
        ZeroMemory(&tvisItem, sizeof(TVINSERTSTRUCT));
        tvisItem.hParent            = hParent ? hParent : hRoot;
        tvisItem.hInsertAfter       = TVI_SORT;
        tvisItem.item.pszText       = lpszText;
        tvisItem.item.cchTextMax    = lstrlen(lpszText);
        tvisItem.item.mask          = TVIF_TEXT|TVIF_PARAM|TVIF_STATE;
        tvisItem.item.stateMask     = TVIS_BOLD;
        tvisItem.item.state         = TVIS_BOLD;
        tvisItem.item.lParam        = (LPARAM)pFavNew;

        hParent = TreeView_InsertItem(hwndTV, &tvisItem);
        pFavNew->hItem = hParent;
    }
    else 
    {
        LPTSTR lpszTitle     = NULL;
        int iTitleLen;
        LPTSTR lpszFolder    = NULL;
        int iFolderLen;
        LPTSTR lpszSubFolder = NULL;

        // We're adding a Url with folder name in lpszText
        //
        LPTSTR pszFolder = StrRChr(lpszText, NULL, CHR_BACKSLASH);

        // Allocate the buffer for the title
        //
        iTitleLen=lstrlen(lpszText) + 1;
        lpszTitle = MALLOC( iTitleLen * sizeof(TCHAR) );
        if ( !lpszTitle )
        {
            return NULL;
        }

        // If we find a backslash, split up the strings.  pszFolder is really a bad
        // name because it actually points to the URL name, but is used to split the
        // folder path from the URL name.
        //
        if ( pszFolder )
        {
            LPTSTR lpSplit = pszFolder;
            pszFolder = CharNext(pszFolder);

            // Split the folder name from the title name
            //
            lstrcpyn(lpszTitle, pszFolder, iTitleLen);
            *lpSplit = NULLCHR;

            // Allocate the folder buffer...
            //
            iFolderLen= lstrlen(lpszText) + 1;
            lpszFolder = MALLOC( iFolderLen * sizeof(TCHAR) );
            if ( !lpszFolder )
            {
                FREE( lpszTitle );
                return NULL;
            }

            // lpszFolder now contains the folder path
            //
            lstrcpyn(lpszFolder, lpszText, iFolderLen);

            // Allocate a buffer for the subfolder
            //
            if ( (lpszSubFolder = MALLOC( (lstrlen(lpszFolder) + 1) * sizeof(TCHAR) )) )
            {
                // Get the first subfolder
                //
                while (lpszFolder[i] != CHR_BACKSLASH && lpszFolder[i] != NULLCHR)
                    lpszSubFolder[i] = lpszFolder[i++];
                lpszSubFolder[i] = NULLCHR;
    
                // If we have subfolders then continue to add them into the tree
                //
                while ( *lpszSubFolder ) 
                {
                    HTREEITEM hTemp = NULL;
                    TVITEM  tviItem;

                    // Check to see if the subfolder already exists in the tree 
                    //
                    ZeroMemory(&tviItem, sizeof(TVITEM));
                    tviItem.mask = TVIF_HANDLE | TVIF_TEXT;
                    tviItem.pszText = lpszSubFolder;
                    tviItem.cchTextMax = lstrlen(lpszSubFolder);
                    if (hTemp = FindTreeItem(hwndTV, hParent ? hParent : hRoot, lpszSubFolder))
                        hParent = hTemp;

                    // If the subfolder isn't in the tree, we must add it.
                    //
                    if (!hTemp)
                    {
                        PFAV_ITEM pFavNew = (PFAV_ITEM)MALLOC(sizeof(FAV_ITEM));
                        if (NULL == pFavNew) 
                        {
                            MsgBox(NULL, IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
                
                            // Free buffers and return
                            //
                            FREE( lpszTitle );
                            FREE( lpszFolder );
                            FREE( lpszSubFolder );

                            return NULL;
                        }
                        pFavNew->fFolder  = TRUE;
                        pFavNew->fNew     = FALSE;
                        pFavNew->fLink    = fLink;
                        pFavNew->hwndTV   = hwndTV;
                        SetFavItem(pFavNew, lpszSubFolder, NULL, NULL);

                        FAddListItem(&g_prgFavList, &g_ppFavItemNew, pFavNew);

                        // Add this folder and use it as the parent for the next item to add.
                        //
                        ZeroMemory(&tvisItem, sizeof(TVINSERTSTRUCT));
                        tvisItem.hParent            = hParent ? hParent : hRoot;
                        tvisItem.hInsertAfter       = TVI_SORT;
                        tvisItem.item.pszText       = lpszSubFolder;
                        tvisItem.item.cchTextMax    = lstrlen(lpszSubFolder);
                        tvisItem.item.mask          = TVIF_TEXT|TVIF_PARAM|TVIF_STATE;
                        tvisItem.item.stateMask     = TVIS_BOLD;
                        tvisItem.item.state         = TVIS_BOLD;
                        tvisItem.item.lParam        = (LPARAM)pFavNew;

                        hParent = TreeView_InsertItem(hwndTV, &tvisItem);
                        pFavNew->hItem = hParent;
                    }

                    // Check the next subfolder
                    //
                    j = 0;
                    while (lpszFolder[i] == CHR_BACKSLASH)
                        i++;
                    while (lpszFolder[i] != CHR_BACKSLASH && lpszFolder[i] != NULLCHR)
                        lpszSubFolder[j++] = lpszFolder[i++];
                    lpszSubFolder[j] = NULLCHR;
                }

                // Free the subfolder buffer...
                //
                FREE( lpszSubFolder );
            }
            else
            {
                // Unable to allocate subfolder buffer!
                // Free buffers and return
                //
                FREE( lpszTitle );
                FREE( lpszFolder );

                return NULL;
            }

            //
            // Free the folder buffer...
            //
            FREE( lpszFolder );
        }
        else
        {
            // Store the title name if this is just a URL
            //
            lstrcpyn(lpszTitle, lpszText, iTitleLen);
        }

        // Now add the url
        //
        if (lpszUrl)
        {
            LPTSTR lpszTitleTemp = NULL;
            int iTitleTempLen;
            
            PFAV_ITEM pFavParent = NULL;
            PFAV_ITEM pFavNew = (PFAV_ITEM)MALLOC(sizeof(FAV_ITEM));
            if (NULL == pFavNew) 
            {
                MsgBox(NULL, IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
                
                // Free buffer and return
                //
                FREE( lpszTitle );
                return NULL;
            }
            pFavNew->fFolder  = FALSE;
            pFavNew->fNew     = FALSE;
            pFavNew->fLink    = fLink;
            pFavNew->hwndTV   = hwndTV;

            pFavParent = GetTreeItemHt(hwndTV, hParent ? hParent : hRoot);

            // Build the tree path to of the folders for this url.
            //
            if (pFavParent) 
            {
                TCHAR szTemp1[MAX_TITLE] = NULLSTR, szTemp2[MAX_TITLE] = NULLSTR;            
                while (pFavParent && pFavParent->hItem != TreeView_GetRoot(hwndTV)) 
                {
                    lstrcpyn(szTemp1, pFavParent->szName,AS(szTemp1));                
                    _tcsrev(szTemp1);
                    AddPathN(szTemp2, szTemp1,AS(szTemp2));
                    pFavParent = GetTreeItemHt(hwndTV, TreeView_GetParent(hwndTV, pFavParent->hItem));                
                }
                _tcsrev(szTemp2);
                lstrcpyn(pFavNew->szParents, szTemp2,AS(pFavNew->szParents));
            }

            SetFavItem( pFavNew, lpszTitle, lpszUrl, lpszIcon);

            FAddListItem(&g_prgFavList, &g_ppFavItemNew, pFavNew);

            //
            // Allocate a buffer to hold the "title=url" string
            //
            iTitleTempLen= (lstrlen(lpszTitle) + lstrlen(lpszUrl) + 2);
            lpszTitleTemp = MALLOC( iTitleTempLen  * sizeof(TCHAR) );
            if ( lpszTitleTemp )
            {
                // Setup the title=url string, from title we stored above.
                //
                lstrcpyn(lpszTitleTemp, lpszTitle, iTitleTempLen);
                hrCat=StringCchCat(lpszTitleTemp, iTitleTempLen, STR_EQUAL);
                hrCat=StringCchCat(lpszTitleTemp, iTitleTempLen, lpszUrl);

                // Add this url and use it as the parent for the next item to add.
                //
                ZeroMemory(&tvisItem, sizeof(TVINSERTSTRUCT));
                tvisItem.hParent            = hParent ? hParent : hRoot;
                tvisItem.hInsertAfter       = TVI_SORT;
                tvisItem.item.pszText       = lpszTitleTemp;
                tvisItem.item.cchTextMax    = lstrlen(lpszTitleTemp);
                tvisItem.item.mask          = TVIF_TEXT|TVIF_PARAM|TVIF_STATE;
                tvisItem.item.lParam        = (LPARAM)pFavNew;

                hParent = TreeView_InsertItem(hwndTV, &tvisItem);
                pFavNew->hItem = hParent;

                // Free the temporary title buffer.
                //
                FREE( lpszTitleTemp );
            }
        }

        // Free the title buffer.
        //
        FREE( lpszTitle );
    }

    return hParent;
}

static void SaveData(PGENERIC_LIST pList)
{

    int iLinks = 1, iFavs = 1, iQuick = 0;
    HRESULT hrPrintf;
    if (!pList)
        return;

    // Clear the section 
    //
    OpkWritePrivateProfileSection(INI_SEC_FAVEX, NULL, g_App.szInstallInsFile);
    OpkWritePrivateProfileSection(INI_SEC_FAV, NULL, g_App.szInstallInsFile);
    /* NOTE: Can't bulk delete this section because it contains some start page info.
             So we're going to remove only what we know in the for loop below.

    WritePrivateProfileSection(INI_SEC_URL, NULL, g_App.szInstallInsFile);
    */    

    // Just to be sure lets remove some
    //
    for (iQuick = 1; iQuick < MAX_QUICKLINKS; iQuick++) {
        TCHAR szKey[MAX_PATH];

        hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_QUICKLINK, iQuick, NAME);
        
        OpkWritePrivateProfileString(INI_SEC_URL, szKey, NULL, g_App.szInstallInsFile);

        hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_QUICKLINK, iQuick, NULLSTR);

        OpkWritePrivateProfileString(INI_SEC_URL, szKey, NULL, g_App.szInstallInsFile);
    }

    // Write out favorites and links
    //
    while (pList) {
        TCHAR szKey[MAX_PATH];

        PFAV_ITEM pFav = (PFAV_ITEM)pList->pvItem;

        if (pFav && lstrlen(pFav->szUrl)) {

            // Write the [URL] section
            //
            if (pFav->fLink) {
                hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_QUICKLINK, iLinks, NAME);
                OpkWritePrivateProfileString(INI_SEC_URL, szKey, pFav->szName, g_App.szInstallInsFile);

                hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_QUICKLINK, iLinks, NULLSTR);
                OpkWritePrivateProfileString(INI_SEC_URL, szKey, pFav->szUrl, g_App.szInstallInsFile);

                iLinks++;
            }

            // Write the [FavoritesEx] and [Favorites] section
            //
            if (!pFav->fLink) {
                TCHAR szIconFile[MAX_PATH];

                if (pFav->szParents[0]) {
                    TCHAR szTitle[MAX_TITLE];
                    lstrcpyn(szTitle, pFav->szParents,AS(szTitle));
                    AddPathN(szTitle, pFav->szName,AS(szTitle));
                    hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_TITLE, iFavs);
                    OpkWritePrivateProfileString(INI_SEC_FAVEX, szKey, szTitle, g_App.szInstallInsFile);
                    lstrcpyn(szKey, szTitle, AS(szKey)); 
                    OpkWritePrivateProfileString(INI_SEC_FAV, szKey, pFav->szUrl, g_App.szInstallInsFile);
                }
                else {
                    hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_TITLE, iFavs);
                    OpkWritePrivateProfileString(INI_SEC_FAVEX, szKey, pFav->szName, g_App.szInstallInsFile);
                    lstrcpyn(szKey, pFav->szName, AS(szKey)); 
                    OpkWritePrivateProfileString(INI_SEC_FAV, szKey, pFav->szUrl, g_App.szInstallInsFile);
                }

                hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_URL, iFavs);
                OpkWritePrivateProfileString(INI_SEC_FAVEX, szKey, pFav->szUrl, g_App.szInstallInsFile);

                hrPrintf=StringCchPrintf(szKey, AS(szKey), INI_KEY_ICON, iFavs);
                if (lstrlen(pFav->szIcon)) {
                    OpkWritePrivateProfileString(INI_SEC_FAVEX, szKey, pFav->szIcon, g_App.szInstallInsFile);
                }

                // Copy the icon file
                //
                lstrcpyn(szIconFile, g_App.szTempDir,AS(szIconFile));
                AddPathN(szIconFile, DIR_IESIGNUP,AS(szIconFile));
                AddPathN(szIconFile, PathFindFileName(pFav->szIcon),AS(szIconFile));
                CopyFile(pFav->szIcon, szIconFile, FALSE);

                // Next Favorite item
                //
                iFavs++;
            }
        }
            
        pList = pList ? pList->pNext : NULL;
    }
}

void EditItem(HWND hDlg, HWND hwndTV, BOOL fFolder, BOOL fNew)
{
    PFAV_ITEM   pFavItem      = NULL;
    PFAV_ITEM   pFavParent    = NULL;
    HTREEITEM   hItem         = NULL;
    HRESULT hrCat;

    // If we're modifying an item get the current info
    //
    if (fNew) {       
        // This only allows folders to be added under folders
        //
        GetSelectedFavFromTree(hwndTV, &pFavParent);
        if (pFavParent && pFavParent->fFolder) {
            if (NULL == (pFavItem = (PFAV_ITEM)MALLOC(sizeof(FAV_ITEM)))) {
                MsgBox(GetParent(hDlg), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
                WIZ_EXIT(hDlg);
                return;
            }
            pFavItem->fFolder = fFolder;            
            pFavItem->fNew    = fNew;
            pFavItem->fLink   = pFavParent->fLink;
            pFavItem->hwndTV  = hwndTV;
        }
        else if (fFolder && NULL == TreeView_GetRoot(hwndTV)) {
            // Tree empty allow creation of a folder
            //
            if (NULL == (pFavItem = (PFAV_ITEM)MALLOC(sizeof(FAV_ITEM)))) {
                MsgBox(GetParent(hDlg), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
                WIZ_EXIT(hDlg);
                return;
            }
            pFavItem->fFolder = fFolder;
            pFavItem->fNew    = fNew;
            pFavItem->hwndTV  = hwndTV;
        }
        else
            return; // You should not add an Url under another Url!
    }
    else {
        GetSelectedFavFromTree(hwndTV, &pFavItem);
        if (!pFavItem) {
            MsgBox(hDlg, IDS_ERR_NOSEL, IDS_APPNAME, MB_ERRORBOX);
            return;
        }
    }

    if (IDOK == DialogBoxParam(g_App.hInstance, MAKEINTRESOURCE(IDD_FAVPOPUP), hDlg, 
                    FavoritesPopupDlgProc, (LPARAM)pFavItem)) {
        if (fNew) {      
            // The lstrlen is to check if we're adding a favorite or folder
            //
            HTREEITEM hParent = pFavParent ? pFavParent->hItem : NULL;
            hItem = AddFav(hwndTV, hParent, pFavItem->szName, lstrlen(pFavItem->szUrl) ? pFavItem->szUrl : NULL, 
                lstrlen(pFavItem->szIcon) ? pFavItem->szIcon : NULL, pFavParent ? pFavParent->fLink : fFolder);

            // Select the new item
            //
            TreeView_Expand(hwndTV, hParent, TVE_EXPAND);           
        }
        else {
            // Update the item in the treeview
            //
            TVITEM  tviTemp;
            TCHAR   szFolder[MAX_TITLE];
            lstrcpyn(szFolder, pFavItem->szName,AS(szFolder));
            if (!pFavItem->fFolder) {
                hrCat=StringCchCat(szFolder, AS(szFolder), STR_EQUAL);
                hrCat=StringCchCat(szFolder, AS(szFolder), pFavItem->szUrl);
            }

            tviTemp.hItem         = pFavItem->hItem;
            tviTemp.pszText       = szFolder;
            tviTemp.cchTextMax    = lstrlen(szFolder);
            tviTemp.mask          = TVIF_TEXT;            
            TreeView_SetItem(hwndTV, &tviTemp);
        }
    }

    // Select the new item
    //
    TreeView_Select(hwndTV, hItem, TVGN_CARET);           

    // Only if fNew AddFav will allocate and copy the information into the list
    // so we need to delete this here
    //
    if (fNew) 
        FREE(pFavItem);

}

static void OnAddUrl(HWND hDlg)
{
    HWND hwndTV = GetDlgItem(hDlg, IDC_FAVS);
    EditItem(hDlg, hwndTV, FALSE, TRUE);
}

static void OnAddFolder(HWND hDlg)
{
    HWND hwndTV = GetDlgItem(hDlg, IDC_FAVS);
    EditItem(hDlg, hwndTV, TRUE, TRUE);
}

static void OnEdit(HWND hDlg)
{
    HTREEITEM hItem = NULL;
    PFAV_ITEM pFavItem = NULL;

    HWND hwndTV = GetDlgItem(hDlg, IDC_FAVS);

    GetSelectedFavFromTree(hwndTV, &pFavItem);
    if (pFavItem && (NULL == TreeView_GetParent(hwndTV, pFavItem->hItem)))
        return;

    if ( hItem = TreeView_GetSelection(hwndTV) )        
        EditItem(hDlg, hwndTV, FALSE, FALSE);
    else
        EditItem(hDlg, hwndTV, FALSE, TRUE);
}

static void OnTestUrl(HWND hwnd)
{
    HWND        hwndTV         = GetDlgItem(hwnd, IDC_FAVS);
    PFAV_ITEM   pFavItem       = NULL;

    GetSelectedFavFromTree(hwndTV, &pFavItem);    
    if ( pFavItem && ValidURL(pFavItem->szUrl))
        ShellExecute(hwnd, STR_OPEN, pFavItem->szUrl, NULL, NULL, SW_SHOW);    
    else
        MsgBox(hwnd, IDS_ERR_FAVURL, IDS_APPNAME, MB_ERRORBOX); 
}

static void OnRemoveUrl(HWND hDlg)
{
    HTREEITEM   hItem = NULL;
    HWND hwndTV = GetDlgItem(hDlg, IDC_FAVS);

    // Remove it from the tree
    //
    if ( hItem = TreeView_GetSelection(hwndTV) ) {
        PFAV_ITEM pFav = NULL;
        TCHAR     szIconFile[MAX_PATH] = NULLSTR;

        // Check if any childrens
        //
        TVITEM tvi;
        tvi.mask = TVIF_HANDLE|TVIF_CHILDREN;
        tvi.hItem = hItem;
        TreeView_GetItem(hwndTV, &tvi);
        if (tvi.cChildren) {
            MsgBox(hDlg, IDS_ERR_CHILDEXISTS, IDS_APPNAME, MB_ERRORBOX);
            return;
        }

        // Don't allow removal of root Favorites or Links
        //
        if (NULL == TreeView_GetParent(hwndTV, hItem)) {
            MsgBox(hDlg, IDS_ERR_ROOT, IDS_APPNAME, MB_ERRORBOX);
            return;
        }

        // Remove it from the list and tree
        //
        DeleteFavItem(hItem);
        TreeView_DeleteItem(hwndTV, hItem);
    }
}

LRESULT CALLBACK FavoritesPopupDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInitFavPopup);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommandFavPopup);
    }

    return FALSE;
}

// Initialize the details dialog box with either new or to modify
// items
//
static BOOL OnInitFavPopup(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{

    LPTSTR lpString         = NULL,
           lpName           = NULL,
           lpDescription    = NULL;

    g_pFavPopupInfo = (PFAV_ITEM)lParam;

    // Make sure user can't add more than our size of strings!
    //
    if (g_pFavPopupInfo) {
        SendDlgItemMessage(hwnd, IDC_FAVNAME , EM_LIMITTEXT, STRSIZE(g_pFavPopupInfo->szName) - 1, 0L);
        SendDlgItemMessage(hwnd, IDC_FAVURL , EM_LIMITTEXT, STRSIZE(g_pFavPopupInfo->szUrl) - 1, 0L);
        SendDlgItemMessage(hwnd, IDC_FAVICON , EM_LIMITTEXT, STRSIZE(g_pFavPopupInfo->szIcon) - 1, 0L);
    }

    // Initialize the new items 
    //
    if (g_pFavPopupInfo && g_pFavPopupInfo->fNew) {
        if (g_pFavPopupInfo->fFolder) {

            if ( (lpString = AllocateString(NULL, IDS_FAVPOPUP_FOLDER)) &&
                 (lpName = AllocateString(NULL, IDS_FAVPOPUP_FOLDERNAME)) &&
                 (lpDescription = AllocateString(NULL, IDS_FAVPOPUP_FOLDERDESC))
               )
            {
                SetWindowText(GetDlgItem(hwnd, IDC_FAVNAME), lpName);
                SetWindowText(GetDlgItem(hwnd, IDC_FAVPOPUP_DESCRIPTION), lpDescription);
                SetWindowText(hwnd, lpString);
            }

            // Free the strings if allocated
            //
            FREE(lpName);
            FREE(lpString);
            FREE(lpDescription);

            EnableWindow(GetDlgItem(hwnd, IDC_FAVURL), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_FAVICON), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_FAVBROWSE), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_ICON), FALSE);
            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_URL), FALSE);
        }
        else {

            if ( (lpString = AllocateString(NULL, IDS_FAVPOPUP_URL)) &&
                 (lpDescription = AllocateString(NULL, IDS_FAVPOPUP_URLDESC))
               )
            {
                SetWindowText(GetDlgItem(hwnd, IDC_FAVNAME), lpString);
                SetWindowText(GetDlgItem(hwnd, IDC_FAVPOPUP_DESCRIPTION), lpDescription);
                SetWindowText(hwnd, lpString);
            }

            FREE(lpString);
            FREE(lpDescription);

            SetWindowText(GetDlgItem(hwnd, IDC_FAVURL), TEXT("http://www."));
            if (g_pFavPopupInfo->fLink) {
                // Hide the icon fields and resize dialog box.
                DisableIconField(hwnd);
            }
        }

    }
    else if (g_pFavPopupInfo) {
        // Initialize the folder item
        //
        if (g_pFavPopupInfo->fFolder) {
            if ( (lpString = AllocateString(NULL, IDS_FAVPOPUP_FOLDER)) &&
                 (lpDescription = AllocateString(NULL, IDS_FAVPOPUP_FOLDERDESC))
               )
            {
                SetWindowText(GetDlgItem(hwnd, IDC_FAVPOPUP_DESCRIPTION), lpDescription);
                SetWindowText(hwnd, lpString);
            }

            FREE(lpString);
            FREE(lpDescription);

            SetWindowText(GetDlgItem(hwnd, IDC_FAVNAME), g_pFavPopupInfo->szName);
            DisableIconField(hwnd);
        }
        else {
            // Initialize the url item
            //
            SetWindowText(GetDlgItem(hwnd, IDC_FAVNAME), g_pFavPopupInfo->szName);
            SetWindowText(GetDlgItem(hwnd, IDC_FAVURL), g_pFavPopupInfo->szUrl);

            if ( (lpString = AllocateString(NULL, IDS_FAVPOPUP_PROP)) &&
                 (lpDescription = AllocateString(NULL, IDS_FAVPOPUP_URLDESC))
               )
            {
                SetWindowText(GetDlgItem(hwnd, IDC_FAVPOPUP_DESCRIPTION), lpDescription);
                SetWindowText(hwnd, lpString);
            }

            FREE(lpDescription);
            FREE(lpString);

            if (g_pFavPopupInfo->fLink) {
                DisableIconField(hwnd);
            }
            else
                SetWindowText(GetDlgItem(hwnd, IDC_FAVICON), g_pFavPopupInfo->szIcon);
        }
    }

    CenterDialogEx(GetParent(hwnd), hwnd);
    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

// 
// Favorites Popup Dialog
//
static void OnCommandFavPopup(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szFileName[MAX_PATH];

    switch (id)
    {
    case IDOK:
        if (FSaveFavPopupInfo(hwnd, g_pFavPopupInfo, g_pFavPopupInfo->fFolder))          
            EndDialog(hwnd, id);
        break;

    case IDCANCEL:
        EndDialog(hwnd, id);
        break;

    case IDC_FAVBROWSE:
        {
            szFileName[0] = NULLCHR;
            GetDlgItemText(hwnd, IDC_FAVICON, szFileName, STRSIZE(szFileName));
            CheckValidBrowseFolder(szFileName);

            if ( BrowseForFile(hwnd, IDS_BROWSE, IDS_ICONFILES, IDS_ICO, szFileName, STRSIZE(szFileName), g_App.szOpkDir, 0) ) {
                SetDlgItemText(hwnd, IDC_FAVICON, szFileName);
                SetLastKnownBrowseFolder(szFileName);
            }
        }
        break;
    }
}

static BOOL FSaveFavPopupInfo(HWND hDlg, PFAV_ITEM lpFavItem, BOOL fFolder)
{
    if (lpFavItem) {
        HTREEITEM hParent = NULL;

        // Get the text for the new favorite
        //
        GetWindowText(GetDlgItem(hDlg, IDC_FAVNAME), lpFavItem->szName, MAX_TITLE);
        GetWindowText(GetDlgItem(hDlg, IDC_FAVURL), lpFavItem->szUrl, MAX_URL);
        GetWindowText(GetDlgItem(hDlg, IDC_FAVICON), lpFavItem->szIcon, MAX_PATH);

        // Make sure we don't save duplicate folders names under the same parent
        //
        hParent = TreeView_GetSelection(lpFavItem->hwndTV);       
        if (lpFavItem->fNew) 
            hParent = TreeView_GetChild(lpFavItem->hwndTV, hParent);

        if (hParent && FindTreeItem(lpFavItem->hwndTV, hParent, lpFavItem->szName)) {
            MsgBox(hDlg, IDS_ERR_DUP, IDS_APPNAME, MB_ERRORBOX);
            return FALSE;
        }

        // Verify if icon file is valid
        //
        if (lstrlen(lpFavItem->szIcon) && !FileExists(lpFavItem->szIcon)) {            
            MsgBox(GetParent(hDlg), lstrlen(lpFavItem->szIcon) ? IDS_NOFILE : IDS_BLANKFILE, IDS_APPNAME, 
                MB_ERRORBOX, lpFavItem->szIcon);
            SetFocus(GetDlgItem(hDlg, IDC_FAVICON));
            return FALSE;
        }

        // Verify the URL is valid (uses shlwapi.dll)
        //
        if (!fFolder && !ValidURL(lpFavItem->szUrl)) {
            MsgBox(hDlg, IDS_ERR_FAVURL, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hDlg, IDC_FAVURL));
            return FALSE;
        }
    }
    return TRUE;
}

// Function: DisableIconField(HWND hwnd)
// 
// Description:
//      Hides all the icon buttons, resizes the FAVPOPUP dialog box and moves the OK
//      and Cancel buttons to the correct locations.
//          

static void DisableIconField(HWND hwnd) 
{
    RECT rectDlg, 
         rectCtlUrl,
         rectCtlIcon,
         rectButton;

    POINT ptCtl;
     
    // Get the coordinates for the dialog box, two edit controls and the OK button.
    //
    if (GetWindowRect(hwnd, &rectDlg) && 
        GetWindowRect(GetDlgItem(hwnd, IDC_FAVURL), &rectCtlUrl) &&
        GetWindowRect(GetDlgItem(hwnd, IDC_FAVICON), &rectCtlIcon) &&
        GetWindowRect(GetDlgItem(hwnd, IDOK), &rectButton))
    {
        // Use the coords of the two edit controls to calculate the delta-Y to use
        // in reducing the size of the dialog box.
        //
        UINT uiDY = rectCtlIcon.top - rectCtlUrl.top;
        UINT uiDX = rectButton.right - rectButton.left;

        // Get the client coordinates of the OK button and shift it up by delta-Y
        //
        ptCtl.x = rectButton.left;
        ptCtl.y = rectButton.top;
        MapWindowPoints(NULL, hwnd, &ptCtl, 1);
        SetWindowPos(GetDlgItem(hwnd, IDOK), NULL, ptCtl.x - uiDX, ptCtl.y - uiDY, 0, 0, SWP_NOSIZE);

        // Get the coordinates of the Cancel button and shift it up by delta-Y
        //
        if (GetWindowRect(GetDlgItem(hwnd, IDCANCEL), &rectButton))
        {
            ptCtl.x = rectButton.left;
            ptCtl.y = rectButton.top;
            MapWindowPoints(NULL, hwnd, &ptCtl, 1);
            SetWindowPos(GetDlgItem(hwnd, IDCANCEL), NULL, ptCtl.x - uiDX, ptCtl.y - uiDY, 0, 0, SWP_NOSIZE);
            
            // Reduce the size of the dialog box by delta-Y
            //
            SetWindowPos(hwnd, NULL, 0, 0, rectDlg.right - rectDlg.left - uiDX, rectDlg.bottom - rectDlg.top - uiDY, SWP_NOMOVE);
        }
    }
    // Hide the 3 controls that are related to icons.
    //
    ShowWindow(GetDlgItem(hwnd, IDC_FAVICON), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDC_FAVBROWSE), SW_HIDE);
    ShowWindow(GetDlgItem(hwnd, IDC_STATIC_ICON), SW_HIDE);
    
}


static PFAV_ITEM GetTreeItemHt(HWND hwndTV, HTREEITEM htFavItem)
{
    TVITEM tvi;    
    tvi.mask    = TVIF_HANDLE|TVIF_PARAM;    
    tvi.hItem   = htFavItem;

    if (TreeView_GetItem(hwndTV, &tvi))
        return (PFAV_ITEM)tvi.lParam;

    return NULL;
}


//////////////////////////////////////////////////////////////////////////////
// Find pszItem in tree view starting from hItem 
//
HTREEITEM FindTreeItem(HWND hwndTV, HTREEITEM hItem, LPTSTR pszItem)
{
    // If hItem is NULL, start search from root item
    //
    if (hItem == NULL)
        hItem = (HTREEITEM)TreeView_GetRoot(hwndTV);

	// Loop thru all the child items
	//
    while (hItem != NULL)
    {
        TCHAR szBuffer[MAX_PATH];
        TVITEM item;

        item.hItem = hItem;
        item.mask = TVIF_TEXT | TVIF_CHILDREN;
        item.pszText = szBuffer;
        item.cchTextMax = MAX_PATH;
        TreeView_GetItem(hwndTV, &item);

        // Did we find it?
        //
        if (pszItem && CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, item.pszText, -1, pszItem, -1) == CSTR_EQUAL) 
            return hItem;

        // Check whether we have any child items
        //
        if (item.cChildren)
        {
            // Recursively traverse child items
            //
            HTREEITEM hItemFound = 0, hItemChild = 0;

            hItemChild = (HTREEITEM)TreeView_GetNextItem(hwndTV, hItem, TVGN_CHILD);
            if (hItemChild)
                hItemFound = FindTreeItem(hwndTV, hItemChild, pszItem);

            // Did we find it?
            //
            if (hItemFound != NULL) {
                return hItemFound;
            }
        }

        // Go to next sibling item
		//
        hItem = (HTREEITEM)TreeView_GetNextItem(hwndTV, hItem, TVGN_NEXT);
    }

    // Not found 
	//
    return NULL;
}

static void GetSelectedFavFromTree(HWND hwndTV, PFAV_ITEM* ppFavItem)
{
    HTREEITEM hItem = NULL;

    if ( hItem = TreeView_GetSelection(hwndTV) ) {
        TVITEM tvi;
        tvi.mask  = LVIF_PARAM;
        tvi.hItem = hItem;

        if (TreeView_GetItem(hwndTV, &tvi))
            *ppFavItem = (PFAV_ITEM)tvi.lParam;
    }   
}

static void SetFavItem(PFAV_ITEM lpFavItem, LPTSTR lpszFolder, LPTSTR lpszUrl, LPTSTR lpszIcon)
{
    if (lpFavItem) {
        if (lpszFolder)
            lstrcpyn(lpFavItem->szName, lpszFolder,AS(lpFavItem->szName));
        if (lpszUrl)
            lstrcpyn(lpFavItem->szUrl, lpszUrl,AS(lpFavItem->szUrl));
        if (lpszIcon)
            lstrcpyn(lpFavItem->szIcon, lpszIcon,AS(lpFavItem->szIcon));
    }
}

static void DeleteFavItem(HTREEITEM hItemDelete)
{
    BOOL          fFound   = FALSE;
    PGENERIC_LIST pFavItem = g_prgFavList;
    TCHAR         szIconFile[MAX_PATH] = NULLSTR;

    // Loop until we find what we want to delete
    //
    while (!fFound && pFavItem) 
    {
        if (pFavItem->pNext && ((PFAV_ITEM)((pFavItem->pNext)->pvItem))->hItem == hItemDelete) {
            PGENERIC_LIST pFavTemp = pFavItem->pNext;
            pFavItem->pNext = pFavTemp->pNext;

            FREE(pFavTemp->pvItem);
            FREE(pFavTemp);
            fFound = TRUE;
        }
        else if (((PFAV_ITEM)(g_prgFavList->pvItem))->hItem == hItemDelete) {
            PGENERIC_LIST pFavTemp = g_prgFavList;
            g_prgFavList = g_prgFavList->pNext;

            FREE(pFavTemp->pvItem);
            FREE(pFavTemp);
            fFound = TRUE;
        }        
        pFavItem = pFavItem ? pFavItem->pNext : NULL;
    }
}

void SaveFavorites()
{
    SaveData(g_prgFavList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\create.c ===
/****************************************************************************\

    CREATE.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "create directory" wizard page.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//


//
// Internal Global Variable(s):
//
HANDLE  g_hThread;
HANDLE  g_hEvent = NULL;

//
// Internal Function Prototype(s):
//

static DWORD CreateConfigDir(HWND);


//
// External Function(s):
//

BOOL CALLBACK CreateDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, IDC_PROGRESS, PBM_SETSTEP, 1, 0L);
            return FALSE;

        case WM_DESTROY:
            //
            // Close the cancellation event
            //
            if ( g_hEvent )
            {
                CloseHandle( g_hEvent );
                g_hEvent = NULL;
            }
            return 0;

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                case PSN_WIZNEXT:
                    break;

                case PSN_QUERYCANCEL:
                    
                    SuspendThread(g_hThread);
                    if ( !WIZ_CANCEL(hwnd) )
                        ResumeThread(g_hThread);
                    else 
                    {
                        // Signal the thread termination event if it exists...
                        //
                        if ( g_hEvent )
                            SetEvent( g_hEvent );
                    }
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_DEFAULT;


                    if ( GET_FLAG(OPK_CREATED) )
                        WIZ_SKIP(hwnd);
                    else
                    {
                        DWORD dwThreadId;
                        WIZ_BUTTONS(hwnd, 0);
                        
                        //
                        // Initialize the event we will use for cancellations
                        //
                        if ( NULL == g_hEvent )
                        {
                            g_hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
                        }
                        else
                        {
                            ResetEvent( g_hEvent );
                        }

                        //
                        // Now create the worker thread...
                        //
                        g_hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) CreateConfigDir, (LPVOID) hwnd, 0, &dwThreadId);
                    }
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static DWORD CreateConfigDir(HWND hwnd)
{
    TCHAR   szConfigDir[MAX_PATH];
    DWORD   dwNum;

    // If this is maintenance mode, we need to save the existing dir.
    //
    if ( GET_FLAG(OPK_MAINTMODE) )
        lstrcpyn(szConfigDir, g_App.szTempDir,AS(szConfigDir));
    else
        szConfigDir[0] = NULLCHR;

    // Make sure our configuration directory exists.
    //
    if ( !DirectoryExists(g_App.szConfigSetsDir) )
        CreatePath(g_App.szConfigSetsDir);

    // Create the temporary directory.
    //
    if ( GetTempFileName(g_App.szConfigSetsDir, _T("CFG"), 0, g_App.szTempDir) &&
         DeleteFile(g_App.szTempDir) &&
         CreatePath(g_App.szTempDir) )
    {
        // Make sure there is a trailing backslash.
        //
        AddPathN(g_App.szTempDir, NULLSTR,AS(g_App.szTempDir));

        // Now create the file set in the directory.  Either from an exising
        // config set, or from the files in the wizard directory.
        //
        if ( szConfigDir[0] )
        {
            //
            // Use the existing config set for all the default files.
            //

            // Get the count of the files for the progress bar.
            //
            dwNum = FileCount(szConfigDir);

            // Now setup the progress bar.
            //
            ShowWindow(GetDlgItem(hwnd, IDC_PROGRESS), dwNum ? SW_SHOW : SW_HIDE);
            SendDlgItemMessage(hwnd, IDC_PROGRESS, PBM_SETRANGE32, 0, (LPARAM) dwNum);

            // Copy all the files from the existing config directory into
            // the temp directory.
            //
            CopyDirectoryProgressCancel(GetDlgItem(hwnd, IDC_PROGRESS), g_hEvent, szConfigDir, g_App.szTempDir);
        }
        else
        {
            //
            // Use the wizard directory to get the default files.
            //

            HINF        hInf;
            INFCONTEXT  InfContext;
            BOOL        bLoop;
            DWORD       dwErr;

            if ( (hInf = SetupOpenInfFile(g_App.szOpkInputInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, &dwErr)) != INVALID_HANDLE_VALUE )
            {
                // Get the number of files so we can setup the progress bar.
                //
                dwNum = SetupGetLineCount(hInf, INF_SEC_COPYFILES);

                // Now setup the progress bar.
                //
                ShowWindow(GetDlgItem(hwnd, IDC_PROGRESS), dwNum ? SW_SHOW : SW_HIDE);
                SendDlgItemMessage(hwnd, IDC_PROGRESS, PBM_SETRANGE32, 0, (LPARAM) dwNum);

                for ( bLoop = SetupFindFirstLine(hInf, INF_SEC_COPYFILES, NULL, &InfContext);
                      bLoop;
                      bLoop = SetupFindNextLine(&InfContext, &InfContext) )
                {
                    DWORD   dwFlags             = 0;
                    TCHAR   szFile[MAX_PATH]    = NULLSTR,
                            szSubDir[MAX_PATH]  = NULLSTR,
                            szSrc[MAX_PATH],
                            szDst[MAX_PATH];
            

                    // Get the source filename.
                    //
                    if ( SetupGetStringField(&InfContext, 1, szFile, AS(szFile), NULL) && szFile[0] )
                    {
                        // Get any flags passed in.
                        //
                        if ( !SetupGetIntField(&InfContext, 2, &dwFlags) )
                            dwFlags = 0;

                        // Get the optional destination sub directory.
                        //
                        if ( !SetupGetStringField(&InfContext, 3, szSubDir, AS(szSubDir), NULL) )
                            szSubDir[0] = NULLCHR;

                        // If we're in batch mode, overwrite the necessary files
                        //
                        if ( ( GET_FLAG(OPK_BATCHMODE) ) &&
                             ( LSTRCMPI(szFile, FILE_OPKWIZ_INI) == 0 ) )
                        {
                            // Use this FILE_OPKWIZ_INI.
                            //
                            lstrcpyn(szSrc, g_App.szOpkWizIniFile, AS(szSrc));
                            dwFlags |= 0x1;
                        }
                        else if ( ( GET_FLAG(OPK_INSMODE) ) &&
                                  ( LSTRCMPI(szFile, FILE_INSTALL_INS) == 0 ) )
                        {
                            // Use this FILE_INSTALL_INS.
                            //
                            lstrcpyn(szSrc, g_App.szInstallInsFile,AS(szSrc));
                            dwFlags |= 0x1;
                        }
                        else
                        {
                            // Must not be in batch mode... so now create the full
                            // path to the source file as if it exists in the
                            // language specific directory.
                            //
                            lstrcpyn(szSrc, g_App.szLangDir,AS(szSrc));
                            AddPathN(szSrc, g_App.szLangName,AS(szSrc));
                            AddPathN(szSrc, DIR_WIZARDFILES,AS(szSrc));
                            AddPathN(szSrc, szFile,AS(szSrc));

                            // Check to see if the language specific version of this
                            // file is there.
                            //
                            if ( ( g_App.szLangName[0] == NULLCHR ) || !FileExists(szSrc) )
                            {
                                // Nope, so get the full path to the source file in
                                // the normal wizard directory.
                                //
                                lstrcpyn(szSrc, g_App.szWizardDir,AS(szSrc));
                                AddPathN(szSrc, szFile,AS(szSrc));
                            }
                        }

                        // Get the full path to the destination file.
                        //
                        lstrcpyn(szDst, g_App.szTempDir,AS(szDst));
                        if ( szSubDir[0] )
                        {
                            AddPathN(szDst, szSubDir,AS(szDst));
                            if ( !DirectoryExists(szDst) )
                                CreatePath(szDst);
                        }
                        AddPathN(szDst, szFile,AS(szDst));

                        // Copy the file.
                        //
                        if ( !CopyFile(szSrc, szDst, FALSE) )
                        {
                            // See if it is OK to fail the copy or not.
                            //
                            if ( dwFlags & 0x1 )
                            {
                                // Must now fail and error out because this file is required.
                                //
                                MsgBox(GetParent(hwnd), IDS_MISSINGFILE, IDS_APPNAME, MB_ERRORBOX, szFile);
                                WIZ_EXIT(hwnd);
                            }
                            else if ( dwFlags & 0x2 )
                            {

                                // We must try and create the (in Unicode) because it does not exist
                                //
                                CreateUnicodeFile(szDst);
                            }
                        }
                        else
                        {
                            // Reset the file attributes on the destination file.
                            //
                            SetFileAttributes(szDst, FILE_ATTRIBUTE_NORMAL);
                        }
                    }

                    // Increase the progress bar.
                    //
                    SendDlgItemMessage(hwnd, IDC_PROGRESS, PBM_STEPIT, 0, 0L);

                    // Check if the cancellation event has been signalled
                    //
                    if ( g_hEvent && ( WaitForSingleObject(g_hEvent, 0) != WAIT_TIMEOUT ) )
                    {
                        bLoop = FALSE;
                        WIZ_EXIT(hwnd);
                    }
                }
            }
            else
            {
                // If we can't open the INF file, then we must fail.
                //
                MsgBox(GetParent(hwnd), IDS_MISSINGFILE, IDS_APPNAME, MB_ERRORBOX, g_App.szOpkInputInfFile);
                WIZ_EXIT(hwnd);
            }
        }

        // Make sure the progress bar is at 100%.
        //
        SendDlgItemMessage(hwnd, IDC_PROGRESS, PBM_SETPOS, (WPARAM) dwNum, 0L);

        // Setup the full paths to all the config files.
        //
        SetConfigPath(g_App.szTempDir);

        // Delete the finished value from the ini file so that we know this is a
        // config set in progress.
        //
        WritePrivateProfileString(INI_SEC_CONFIGSET, INI_KEY_FINISHED, NULL, g_App.szOpkWizIniFile);

        // In maint mode we need to setup the path to the lang dir
        // and sku dir.
        //
        if ( szConfigDir[0] )
        {
            GetPrivateProfileString(INI_SEC_WINPE, INI_KEY_WINPE_LANG, NULLSTR, g_App.szLangName, STRSIZE(g_App.szLangName), GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szWinBomIniFile);
            GetPrivateProfileString(INI_SEC_WINPE, INI_KEY_WBOM_WINPE_SKU, NULLSTR, g_App.szSkuName, STRSIZE(g_App.szSkuName), GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szWinBomIniFile);
        }

        // Set the flag so we know we have created a directory.
        //
        SET_FLAG(OPK_CREATED, TRUE);
    }
    else
    {
        // We couldn't get a temp directory, zero out the string.
        //
        g_App.szTempDir[0] = NULLCHR;
        MsgBox(GetParent(hwnd), IDS_ERR_WIZBAD, IDS_APPNAME, MB_ERRORBOX);
        WIZ_EXIT(hwnd);
    }

    // Jump to next page.
    //
    WIZ_PRESS(hwnd, ( GET_FLAG(OPK_MAINTMODE) ? PSBTN_FINISH : PSBTN_NEXT ));
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\helpcent.c ===
/****************************************************************************\

    HELPCENT.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "helpcenter" wizard page.

    12/99 - Stephen Lodwick (STELO)
        Added this page

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//
#define REG_HCUPDATE_OEM            _T(";HKLM, \"Software\\Microsoft\\Windows\\CurrentVersion\\OEMRunOnce\", \"01_PC Health OEM Signature\",, \"START /M C:\\WINDOWS\\OPTIONS\\CABS\\HCU.VBS C:\\WINDOWS\\OPTIONS\\CABS\\PCH_OEM.CAB\"")
#define REG_HCUPDATE_HELP_CENTER    _T("HKLM, \"Software\\Microsoft\\Windows\\CurrentVersion\\OEMRunOnce\", \"02_PC Health Help Center\",, \"START /M C:\\WINDOWS\\OPTIONS\\CABS\\HCU.VBS C:\\WINDOWS\\OPTIONS\\CABS\\%s\"")
#define REG_HCUPDATE_SUPPORT        _T("HKLM, \"Software\\Microsoft\\Windows\\CurrentVersion\\OEMRunOnce\", \"03_PC Health Support\",, \"START /M C:\\WINDOWS\\OPTIONS\\CABS\\HCU.VBS C:\\WINDOWS\\OPTIONS\\CABS\\%s\"")
#define REG_HCUPDATE_BRANDING       _T("HKLM, \"Software\\Microsoft\\Windows\\CurrentVersion\\OEMRunOnce\", \"04_PC Health Branding\",, \"START /M C:\\WINDOWS\\OPTIONS\\CABS\\HCU.VBS C:\\WINDOWS\\OPTIONS\\CABS\\%s\"")
#define INF_SEC_HELPCENTER_ADDREG   _T("HelpCenter.AddReg")

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL ValidData(HWND);
static void SaveData(HWND);
static void EnableControls(HWND, UINT);


//
// External Function(s):
//

LRESULT CALLBACK HelpCenterDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if(ValidData(hwnd))
                        SaveData(hwnd);
                    else
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_HELPCENT;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szData[MAX_PATH]            = NULLSTR;
    
    // Get the string for Help Center customization
    //
    szData[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_HELP_CENTER, NULLSTR, szData, STRSIZE(szData), g_App.szOpkWizIniFile);

    // If the field exists, then check the hardware box and populate the directory
    //
    if (szData[0])
    {
        CheckDlgButton(hwnd, IDC_HELP_CHK, TRUE);
        SetDlgItemText(hwnd, IDC_HELP_DIR, szData);
        EnableControls(hwnd, IDC_HELP_CHK);
    }

    // Get the string for Support customization
    //
    szData[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_SUPPORT_CENTER, NULLSTR, szData, STRSIZE(szData), g_App.szOpkWizIniFile);

    // If the field exists, then check the hardware box and populate the directory
    //
    if (szData[0])
    {
        CheckDlgButton(hwnd, IDC_SUPPORT_CHK, TRUE);
        SetDlgItemText(hwnd, IDC_SUPPORT_DIR, szData);
        EnableControls(hwnd, IDC_SUPPORT_CHK);
    }

    // Get the string for Help Center co-branding
    //
    szData[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_HELP_BRANDING, NULLSTR, szData, STRSIZE(szData), g_App.szOpkWizIniFile);

    // If the field exists, then check the hardware box and populate the directory
    //
    if (szData[0])
    {
        CheckDlgButton(hwnd, IDC_BRANDING_CHK, TRUE);
        SetDlgItemText(hwnd, IDC_BRANDING_DIR, szData);
        EnableControls(hwnd, IDC_BRANDING_CHK);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}


static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szPath[MAX_PATH];

    switch ( id )
    {
        // Which browse button was pressed
        //
        case IDC_HELP_BROWSE:
        case IDC_SUPPORT_BROWSE:
            {
                szPath[0] = NULLCHR;

                GetDlgItemText(hwnd, ( id == IDC_HELP_BROWSE ) ? IDC_HELP_DIR : IDC_SUPPORT_DIR, szPath, STRSIZE(szPath));

                if ( BrowseForFile(hwnd, IDS_BROWSE, IDS_CABFILTER, IDS_CAB, szPath, STRSIZE(szPath), g_App.szOpkDir, 0) ) 
                    SetDlgItemText(hwnd, ( id == IDC_HELP_BROWSE ) ? IDC_HELP_DIR : IDC_SUPPORT_DIR, szPath);

            }
            break;

        case IDC_BRANDING_BROWSE:
            {
                szPath[0] = NULLCHR;

                // Get the current directory, if any, in the directory control
                //
                GetDlgItemText(hwnd, IDC_BRANDING_DIR, szPath, STRSIZE(szPath));

                // Browse for the folder
                //
                if ( BrowseForFile(hwnd, IDS_BROWSE, IDS_CABFILTER, IDS_CAB, szPath, STRSIZE(szPath), g_App.szOpkDir, 0) )
                    SetDlgItemText(hwnd, IDC_BRANDING_DIR, szPath);
            }

            break;

        case IDC_HELP_CHK:
        case IDC_SUPPORT_CHK:
        case IDC_BRANDING_CHK:
            // They checked one of the check boxes, enable/disable the appropriate controls
            //
            EnableControls(hwnd, id);
            break;     
    }
}

static BOOL ValidData(HWND hwnd)
{
    TCHAR   szPath[MAX_PATH];

    // Let's check and make sure that the Help Center file is there
    //
    if ( IsDlgButtonChecked(hwnd, IDC_HELP_CHK) == BST_CHECKED )
    {
        // Check for a valid Help Center file
        //
        szPath[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_HELP_DIR, szPath, STRSIZE(szPath));
        if ( !FileExists(szPath) )
        {
            MsgBox(GetParent(hwnd), IDS_HELP_ERROR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_HELP_DIR));
            return FALSE;
        }

    }

    // Let's check and make sure that the support file is there
    //
    if ( IsDlgButtonChecked(hwnd, IDC_SUPPORT_CHK) == BST_CHECKED )
    {
        // Check for a valid Support file
        //
        szPath[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_SUPPORT_DIR, szPath, STRSIZE(szPath));
        if ( !FileExists(szPath) )
        {
            MsgBox(GetParent(hwnd), IDS_SUPPORT_ERROR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_SUPPORT_DIR));
            return FALSE;
        }

    }

    // Let's check and make sure that the branding directory is valid
    //
    if ( IsDlgButtonChecked(hwnd, IDC_BRANDING_CHK) == BST_CHECKED )
    {        
        // Let's check to make sure the branding directory contains a specific .cab file 
        // that we're looking for
        //
        szPath[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_BRANDING_DIR, szPath, STRSIZE(szPath));
        if ( !FileExists(szPath) )
        {
            MsgBox(GetParent(hwnd), IDS_BRANDING_ERROR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_BRANDING_DIR));
            return FALSE;
        }
    }

    return TRUE;
}



static void SaveData(HWND hwnd)
{
    TCHAR   szPath[MAX_PATH]        = NULLSTR,
            szFullPath[MAX_PATH]    = NULLSTR,
            szRegEntry[MAX_PATH]    = NULLSTR;
    LPTSTR  lpIndex,
            lpSection,
            lpBuffer,
			lpRegEntry;
    DWORD   dwIndex     = 0,
            dwDir       = 0,
            dwCheck     = 0;
    BOOL    bComment    = TRUE;
    HRESULT hrPrintf;

    // Save the Help Center CAB file
    //
    szPath[0] = NULLCHR;    
    GetDlgItemText(hwnd, IDC_HELP_DIR, szPath, STRSIZE(szPath));    
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_HELP_CENTER, ( IsDlgButtonChecked(hwnd, IDC_HELP_CHK) == BST_CHECKED ) ? szPath : NULL, g_App.szOpkWizIniFile);
    
    // Save the Support CAB file
    //
    szPath[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_SUPPORT_DIR, szPath, STRSIZE(szPath));    
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_SUPPORT_CENTER, ( IsDlgButtonChecked(hwnd, IDC_SUPPORT_CHK) == BST_CHECKED ) ? szPath : NULL, g_App.szOpkWizIniFile);

    // Save the Branding directory
    szPath[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_BRANDING_DIR, szPath, STRSIZE(szPath));    
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_HELP_BRANDING, ( IsDlgButtonChecked(hwnd, IDC_BRANDING_CHK) == BST_CHECKED ) ? szPath : NULL, g_App.szOpkWizIniFile);

    // Allocate memory necessary to store the OemRunOnce section
    //
    if ( (lpSection = MALLOC(MAX_SECTION * sizeof(TCHAR))) == NULL )
    {
        MsgBox(GetParent(hwnd), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
        WIZ_EXIT(hwnd);
        return;
    }
    
    // Set the index of the section
    //
    lpIndex = lpSection;

    // We have three possible keys that we're going to write out - HELP CENTER, SUPPORT, and BRANDING
    //
    for (dwIndex = 0; dwIndex <= 2; dwIndex++)
    {
        switch ( dwIndex )
        {
            case 0:
                dwDir = IDC_HELP_DIR;
                dwCheck = IDC_HELP_CHK;
				lpRegEntry = REG_HCUPDATE_HELP_CENTER;
                break;
            case 1:
                dwDir = IDC_SUPPORT_DIR;
                dwCheck = IDC_SUPPORT_CHK;
				lpRegEntry = REG_HCUPDATE_SUPPORT;
                break;
            case 2:
                dwDir = IDC_BRANDING_DIR;
                dwCheck = IDC_BRANDING_CHK;
				lpRegEntry = REG_HCUPDATE_BRANDING;
                break;
        }

        szFullPath[0] = NULLCHR;

        // Get the text under the checkbox
        //
        GetDlgItemText(hwnd, dwDir, szFullPath, STRSIZE(szFullPath)); 

        // If the correct check box is checked and we can get the file name, then add a reg entry to the section
        //
        if  (   (IsDlgButtonChecked(hwnd, dwCheck) == BST_CHECKED) && 
                (GetFullPathName(szFullPath, STRSIZE(szFullPath), szPath, &lpBuffer)) && 
                (lpBuffer) )
        {
            // Write the comment if we haven't yet.
            //
            if ( bComment )
            {
                lstrcpyn(lpIndex, REG_HCUPDATE_OEM, MAX_SECTION);
                lpIndex += lstrlen(lpIndex) + 1;
                bComment = FALSE;
            }

            hrPrintf=StringCchPrintf(lpIndex, (MAX_SECTION-(lpIndex-lpSection)), lpRegEntry, lpBuffer);
            lpIndex+= lstrlen(lpIndex);
            
            // Move past the NULL pointer
            //
            lpIndex++;
        }
    }

    // Add a second NULL pointer to end the section
    //
    *lpIndex = NULLCHR;

    WritePrivateProfileSection(INF_SEC_HELPCENTER_ADDREG, lpSection, g_App.szWinBomIniFile);

    // Clean up the allocated memory
    //
    FREE(lpSection);
}

static void EnableControls(HWND hwnd, UINT uId)
{
    // Determine if the control is checked or not
    //
    BOOL fEnable = ( IsDlgButtonChecked(hwnd, uId) == BST_CHECKED );

    // Which control do we want to enable/disable
    //
    switch ( uId )
    {
        case IDC_HELP_CHK:
            EnableWindow(GetDlgItem(hwnd, IDC_HELP_CAPTION), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HELP_DIR), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HELP_BROWSE), fEnable);
            break;

        case IDC_SUPPORT_CHK:
            EnableWindow(GetDlgItem(hwnd, IDC_SUPPORT_CAPTION), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_SUPPORT_DIR), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_SUPPORT_BROWSE), fEnable);
            break;

        case IDC_BRANDING_CHK:
            EnableWindow(GetDlgItem(hwnd, IDC_BRANDING_CAPTION), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_BRANDING_DIR), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_BRANDING_BROWSE), fEnable);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\lang.c ===
/****************************************************************************\

    LANG.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Target Language" wizard page.

    10/00 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard.  It includes the new
        ability to deploy mulitple languages from one wizard.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Global(s):
//

static STRRES s_srLangDirs[] =
{
    { _T("ARA"),    IDS_ARA },
    { _T("CHH"),    IDS_CHH },
    { _T("CHT"),    IDS_CHT },
    { _T("CHS"),    IDS_CHS },
    { _T("ENG"),    IDS_USA },
    { _T("GER"),    IDS_GER },
    { _T("HEB"),    IDS_HEB },
    { _T("JPN"),    IDS_JPN },
    { _T("KOR"),    IDS_KOR },
    { _T("BRZ"),    IDS_BRZ },
    { _T("CAT"),    IDS_CAT },
    { _T("CZE"),    IDS_CZE },
    { _T("DAN"),    IDS_DAN },
    { _T("DUT"),    IDS_DUT },
    { _T("FIN"),    IDS_FIN },
    { _T("FRN"),    IDS_FRN },
    { _T("GRK"),    IDS_GRK },
    { _T("HUN"),    IDS_HUN },
    { _T("ITN"),    IDS_ITN },
    { _T("NOR"),    IDS_NOR },
    { _T("POL"),    IDS_POL },
    { _T("POR"),    IDS_POR },
    { _T("RUS"),    IDS_RUS },
    { _T("SPA"),    IDS_SPA },
    { _T("SWE"),    IDS_SWE },
    { _T("TRK"),    IDS_TRK },
    { NULL,         0 },
};


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static BOOL OnNext(HWND);


//
// External Function(s):
//

LRESULT CALLBACK LangDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:

                    g_App.dwCurrentHelp = IDH_TARGETLANG;

                    if ( GET_FLAG(OPK_MAINTMODE) )
                    {
                        // Can't change lang in maint mode.
                        //
                        WIZ_SKIP(hwnd);
                    }
                    else if ( SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETCOUNT, 0, 0L) <= 1 )
                    {
                        // Just keep going if only one lang to select.
                        //
                        WIZ_PRESS(hwnd, PSBTN_NEXT);
                    }
                    else
                    {
                        // Press next if the user is in auto mode
                        //
                        WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);
                    }

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void SetupLangListBox(HWND hwndLB)
{
    LPTSTR          lpLangName,
					lpLangDir,
                    lpDefault = AllocateString(NULL, IDS_DEF_LANG);
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;

    // Set the directory to the lang dir and look for lang folders.
    //
    if ( ( SetCurrentDirectory(g_App.szLangDir) ) &&
         ( (hFile = FindFirstFile(_T("*"), &FileFound)) != INVALID_HANDLE_VALUE ) )
    {
        do
        {
            // Look for all the directories that are not "." or "..".
            //
            if ( ( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                 ( lstrcmp(FileFound.cFileName, _T(".")) ) &&
                 ( lstrcmp(FileFound.cFileName, _T("..")) ) &&
				 ( lpLangName = AllocateLangStr(NULL, FileFound.cFileName, &lpLangDir) ) )
            {
                INT nItem;

				// Make sure we can add the string first.
				//
                if ( (nItem = (INT) SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM) lpLangName)) >= 0 )
                {
					// We have to have the item data be the lang dir.
					//
                    if ( SendMessage(hwndLB, LB_SETITEMDATA, nItem, (LPARAM) lpLangDir) >= 0 )
                    {
						// If we haven't already found the default check if this is it.
						//
                        if ( ( lpDefault ) &&
                             ( lstrcmpi(lpDefault, lpLangName) == 0 ) )
                        {
                            SendMessage(hwndLB, LB_SETCURSEL, nItem, 0L);
                            FREE(lpDefault);
                        }
                    }
                    else
                        SendMessage(hwndLB, LB_DELETESTRING, nItem, 0L);
                }

                FREE(lpLangName);
            }

        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }

    // Make sure this got free'd (macro checks for NULL).
    //
    FREE(lpDefault);

    // If there are items in the list, make sure there is one selected.
    //
    if ( ( SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) > 0 ) && 
         ( SendMessage(hwndLB, LB_GETCURSEL, 0, 0L) < 0 ) )
    {
        SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);
    }
}

LPTSTR AllocateLangStr(HINSTANCE hInst, LPTSTR lpLangDir, LPTSTR * lplpLangDir)
{
    return AllocateStrRes(NULL, s_srLangDirs, AS(s_srLangDirs), lpLangDir, lplpLangDir);
}


//
// Internal Function(s):
//


static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Setup the language list box.
    //
    SetupLangListBox(GetDlgItem(hwnd, IDC_LANG_LIST));

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static BOOL OnNext(HWND hwnd)
{
    BOOL bOk = FALSE;    

    if ( SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETCOUNT, 0, 0L) > 0 )
    {
        INT nItem = (INT) SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETCURSEL, 0, 0L);

        if ( nItem >= 0 )
        {
            LPTSTR lpLang = (LPTSTR) SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETITEMDATA, nItem, 0L);

            if ( lpLang != (LPTSTR) LB_ERR )
            {
                lstrcpyn(g_App.szLangName, lpLang,AS(g_App.szLangName));
                bOk = TRUE;
            }
            else
                MsgBox(GetParent(hwnd), IDS_ERR_LANGDIR, IDS_APPNAME, MB_ERRORBOX);
        }
        else
            MsgBox(GetParent(hwnd), IDS_ERR_NOLANGDIR, IDS_APPNAME, MB_ERRORBOX);
    }
    else
    {
		MsgBox(GetParent(hwnd), IDS_ERR_NOLANGS, IDS_APPNAME, MB_ERRORBOX);
        WIZ_EXIT(hwnd);
    }

    return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\debugapi.c ===
/*****************************************************************************\

    DEBUGAPI.C

    Confidential
    Copyright (c) Corporation 1998
    All rights reserved

    Debug API functions for the application to easily output information to
    the debugger.

    12/98 - Jason Cohen (JCOHEN)

  
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\*****************************************************************************/


//
// Include File(s):
//
#include "pch.h"

// We only want this code include if this is a debug version.
//
#ifdef DBG

#include <windows.h>
#include <tchar.h>
#include <stdio.h>
#include <stdarg.h>


//
// External Function(s):
//

INT DebugOutW(LPCWSTR lpFileName, LPCWSTR lpFormat, ...)
{
    INT     iChars = -1;
    va_list lpArgs;
    FILE *  hFile;
    LPWSTR  lpString;

    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, lpFormat);

    // Open the debug file for output if a file name was passed in.
    //
    if ( lpFileName && ( hFile = _wfopen(lpFileName, L"a") ) )
    {
        // Print the debug message to the file and close it.
        //
        iChars = vfwprintf(hFile, lpFormat, lpArgs);
        fclose(hFile);

        // Reinitialize the lpArgs parameter with va_start()
        // for the next call to a vptrintf function.
        //
        va_start(lpArgs, lpFormat);
    }

    // If something failed above, we won't know the size to use
    // for the string buffer, so just default to 2048 characters.
    //
    if ( iChars < 0 )
        iChars = 2047;

    // Allocate a buffer for the string.
    //
    if ( lpString = (LPWSTR) malloc((iChars + 1) * sizeof(WCHAR)) )
    {
        // Print out the string, send it to the debugger, and free it.
        //
        iChars = StringCchPrintf(lpString, iChars + 1, lpFormat, lpArgs);
        OutputDebugStringW(lpString);
        free(lpString);
    }
    else
        // Use -1 to return an error.
        //
        iChars = -1;

    // Return the number of characters printed.
    //
    return iChars;
}

INT DebugOutA(LPCSTR lpFileName, LPCSTR lpFormat, ...)
{
    INT     iChars = -1;
    va_list lpArgs;
    FILE *  hFile;
    LPSTR   lpString;

    // Initialize the lpArgs parameter with va_start().
    //
    va_start(lpArgs, lpFormat);

    // Open the debug file for output if a file name was passed in.
    //
    if ( lpFileName && ( hFile = fopen(lpFileName, "a") ) )
    {
        // Print the debug message to the file and close it.
        //
        iChars = vfprintf(hFile, lpFormat, lpArgs);
        fclose(hFile);

        // Reinitialize the lpArgs parameter with va_start()
        // for the next call to a vptrintf function.
        //
        va_start(lpArgs, lpFormat);
    }

    // If something failed above, we won't know the size to use
    // for the string buffer, so just default to 2048 characters.
    //
    if ( iChars < 0 )
        iChars = 2047;

    // Allocate a buffer for the string.
    //
    if ( lpString = (LPSTR) malloc((iChars + 1) * sizeof(CHAR)) )
    {
        // Print out the string, send it to the debugger, and free it.
        //
        iChars = StringCchPrintfA(lpString, iChars + 1, lpFormat, lpArgs);
        OutputDebugStringA(lpString);
        free(lpString);
    }
    else
        // Use -1 to return an error.
        //
        iChars = -1;

    // Return the number of characters printed.
    //
    return iChars;
}


#endif // DEBUG or _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\isp.c ===
/****************************************************************************\

    ISP.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "ISP" wizard page.

    03/99 - Added by PVSWAMI

    06/99 - Jason Cohen (JCOHEN)
        Updated this source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define FILE_ISP2SIGNUP         _T("ISP.HTM")

#define DIR_ISP                 DIR_OEM_OOBE _T("\\SETUP")

#define INI_VAL_NONE            _T("None")
#define INI_VAL_MSN             _T("MSN")

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND);
static void EnableControls(HWND);
static BOOL BrowseCopy(HWND hwnd, LPTSTR lpszPath, INT id, BOOL bBatch);


//
// External Function(s):
//

LRESULT CALLBACK IspDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_ISP;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR szPath[MAX_PATH];

    // Get the option for the OOBE ISP offer.
    //
    szPath[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, NULLSTR, szPath, STRSIZE(szPath), GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile);
    if ( LSTRCMPI(szPath, INI_VAL_OFFLINE) == 0 )
        CheckRadioButton(hwnd, IDC_MSNINTACCESS, IDC_PRECACHED, IDC_PRECACHED);
    else if ( LSTRCMPI(szPath, INI_VAL_NONE) == 0 )
        CheckRadioButton(hwnd, IDC_MSNINTACCESS, IDC_PRECACHED, IDC_OFFERNOISP);
    else if( LSTRCMPI(szPath, INI_VAL_PRECONFIG) == 0 )
        CheckRadioButton(hwnd, IDC_MSNINTACCESS, IDC_PRECACHED, IDC_PRECONFIGURE);
    else
        CheckRadioButton(hwnd, IDC_MSNINTACCESS, IDC_PRECACHED, IDC_MSNINTACCESS);
    
    // If it is a precached offer, see if the secondary offer should be checked.
    //
    if ( IsDlgButtonChecked(hwnd, IDC_PRECACHED) == BST_CHECKED )
    {
        szPath[0] = NULLCHR;
        GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_ISPRET, NULLSTR, szPath, STRSIZE(szPath), g_App.szOpkWizIniFile);
        if ( szPath[0] )
            CheckDlgButton(hwnd, IDC_ISP2_CHECK, BST_CHECKED);
    }

    // Populate the secondary ISP offer directory path from wizard INF file.
    //
    szPath[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_ISPRET, NULLSTR, szPath, STRSIZE(szPath), g_App.szOpkWizIniFile);
    SetDlgItemText(hwnd, IDC_ISP2_DIR, szPath);
    if ( ( szPath[0] ) &&
         ( GET_FLAG(OPK_BATCHMODE) ) &&
         ( IsDlgButtonChecked(hwnd, IDC_PRECACHED) == BST_CHECKED ) &&
         ( IsDlgButtonChecked(hwnd, IDC_ISP2_CHECK) == BST_CHECKED ) )
    {
        // Must simulate a copy if this is batch mode.
        //
        BrowseCopy(hwnd, szPath, IDC_ISP2_BROWSE, TRUE);
    }

    // Populate the pre-configured directory
    //
    szPath[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_PRECONFIG, NULLSTR, szPath, STRSIZE(szPath), g_App.szOpkWizIniFile);
    SetDlgItemText(hwnd, IDC_PRECONFIG_DIR, szPath);
    if ( ( szPath[0] ) &&
         ( GET_FLAG(OPK_BATCHMODE) ) &&
         ( IsDlgButtonChecked(hwnd, IDC_PRECONFIGURE) == BST_CHECKED ) )
    {
        // Must simulate a copy if this is batch mode.
        //
        BrowseCopy(hwnd, szPath, IDC_PRECONFIG_BROWSE, TRUE);
    }

    // Enable the correct controls based on the options selected.
    //
    EnableControls(hwnd);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szPath[MAX_PATH];

    switch ( id )
    {
        case IDC_MSNINTACCESS:
        case IDC_OFFERNOISP:
        case IDC_PRECONFIGURE:
        case IDC_PRECACHED:
        case IDC_ISP2_CHECK:
            EnableControls(hwnd);
            break;

        case IDC_PRECONFIG_BROWSE:
        case IDC_ISP2_BROWSE:
            
            // Try to use their current folder as the default.
            //
            szPath[0] = NULLCHR;
            GetDlgItemText(hwnd, (id == IDC_PRECONFIG_BROWSE) ? IDC_PRECONFIG_DIR : IDC_ISP2_DIR, szPath, AS(szPath));

            // If there is no current folder, just use the global browse default.
            //
            if ( szPath[0] == NULLCHR )
                lstrcpyn(szPath, g_App.szBrowseFolder,AS(szPath));

            // Now bring up the browse for folder dialog.
            //
            if ( BrowseForFolder(hwnd, IDS_BROWSEFOLDER, szPath, BIF_RETURNONLYFSDIRS | BIF_EDITBOX | BIF_VALIDATE) )
                BrowseCopy(hwnd, szPath, id, FALSE);
            break;
    }
}

static BOOL OnNext(HWND hwnd)
{
    TCHAR   szIspDir[MAX_PATH];
    BOOL    bIsp2 = FALSE;

    // Create the path to the directory that needs to be removed, or
    // must exist depending on the option selected.
    //
    lstrcpyn(szIspDir, g_App.szTempDir,AS(szIspDir));
    AddPathN(szIspDir, DIR_ISP,AS(szIspDir));

    // Validate the pre-configured check box or if we have custom OEM files.
    //
    if ( ( IsDlgButtonChecked(hwnd, IDC_PRECONFIGURE) == BST_CHECKED ) ||
         ( ( IsDlgButtonChecked(hwnd, IDC_PRECACHED) == BST_CHECKED ) &&
           ( bIsp2 = (IsDlgButtonChecked(hwnd, IDC_ISP2_CHECK) == BST_CHECKED) ) ) )
    {
        TCHAR szBuffer[MAX_PATH];

        // Make sure we have a valid target and source directory.
        //
        szBuffer[0] = NULLCHR;
        GetDlgItemText(hwnd, bIsp2 ? IDC_ISP2_DIR : IDC_PRECONFIG_DIR, szBuffer, STRSIZE(szBuffer));
        if ( !( szBuffer[0] && DirectoryExists(szBuffer) ) )
        {
            MsgBox(GetParent(hwnd), IDS_ERR_INVALIDDIR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, bIsp2 ? IDC_ISP2_BROWSE : IDC_PRECONFIG_BROWSE));
            return FALSE;
        }
    }
    else
    {
        // We used to remove existing files here, but this also removes OobeUSB files, so we no longer do this.

        // Clear out the display boxes so we know the files are
        // all gone now.
        //
        SetDlgItemText(hwnd, IDC_PRECONFIG_DIR, NULLSTR);
        SetDlgItemText(hwnd, IDC_ISP2_DIR, NULLSTR);
    }

    // Alwas remove these settings... we will rewrite them if needed.
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_PRECONFIG, NULL, g_App.szOpkWizIniFile);
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_ISPRET, NULL, g_App.szOpkWizIniFile);

    // Save the option for the OOBE ISP offer.
    //
    if ( IsDlgButtonChecked(hwnd, IDC_MSNINTACCESS) == BST_CHECKED )
    {
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_MSN, g_App.szOobeInfoIniFile);
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_MSN, g_App.szOpkWizIniFile);
    }
    else if ( IsDlgButtonChecked(hwnd, IDC_OFFERNOISP) == BST_CHECKED )
    {
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_NONE, g_App.szOobeInfoIniFile);
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_NONE, g_App.szOpkWizIniFile);
    }
    else if ( IsDlgButtonChecked(hwnd, IDC_PRECONFIGURE) == BST_CHECKED )
    {
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_PRECONFIG, g_App.szOobeInfoIniFile);
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_PRECONFIG, g_App.szOpkWizIniFile);

        // Save the source directory for the pre-configured files
        //
        szIspDir[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_PRECONFIG_DIR, szIspDir, STRSIZE(szIspDir));
        WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_PRECONFIG, szIspDir, g_App.szOpkWizIniFile);
    }
    else
    {
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_OFFLINE, g_App.szOobeInfoIniFile);
        WritePrivateProfileString(INI_SEC_SIGNUP, INI_KEY_ISPSIGNUP, INI_VAL_OFFLINE, g_App.szOpkWizIniFile);

        // Save the source directory to use for the secondary ISP files in wizard INI file.
        //
        szIspDir[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_ISP2_DIR, szIspDir, STRSIZE(szIspDir));
        WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_ISPRET, szIspDir, g_App.szOpkWizIniFile);
    }

    return TRUE;
}

static void EnableControls(HWND hwnd)
{
    BOOL fEnable = ( IsDlgButtonChecked(hwnd, IDC_PRECACHED) == BST_CHECKED );

    EnableWindow(GetDlgItem(hwnd,IDC_ISP2_TEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd,IDC_ISP2_CHECK), fEnable);
    if ( fEnable )
        fEnable = ( IsDlgButtonChecked(hwnd, IDC_ISP2_CHECK) == BST_CHECKED );
    EnableWindow(GetDlgItem(hwnd,IDC_ISP2_DIR), fEnable);
    EnableWindow(GetDlgItem(hwnd,IDC_ISP2_BROWSE), fEnable);

    // Enable/Disable the pre-configured controls
    //
    fEnable = ( IsDlgButtonChecked(hwnd, IDC_PRECONFIGURE) == BST_CHECKED );
    EnableWindow(GetDlgItem(hwnd, IDC_PRECONFIG_TEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_PRECONFIG_DIR), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_PRECONFIG_BROWSE), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_PRECONFIG_LABEL), fEnable);
}

static BOOL BrowseCopy(HWND hwnd, LPTSTR lpszPath, INT id, BOOL bBatch)
{
    BOOL    bRet = FALSE;
    TCHAR   szDst[MAX_PATH];
    LPTSTR  lpEnd;

    // If the pressed OK, save off the path in our last browse folder buffer.
    //
    if ( !bBatch )
        lstrcpyn(g_App.szBrowseFolder, lpszPath,AS(g_App.szBrowseFolder));

    // We need to create the path to the destination directory where
    // we are going to copy all the files.
    //
    lstrcpyn(szDst, g_App.szTempDir,AS(szDst));
    AddPathN(szDst, DIR_ISP,AS(szDst));

    // Check for required file.
    //
    lpEnd = lpszPath + lstrlen(lpszPath);
    AddPath(lpszPath, FILE_ISP2SIGNUP);
    if ( ( bBatch ) ||
         ( id == IDC_PRECONFIG_BROWSE ) ||
         ( FileExists(lpszPath) ) ||
         ( MsgBox(GetParent(hwnd), IDS_ERR_ISPFILES2, IDS_APPNAME, MB_ICONSTOP | MB_OKCANCEL | MB_APPLMODAL, FILE_ISP2SIGNUP) == IDOK ) )
    {
        // Chop that file name off so we just have the path again.
        //
        *lpEnd = NULLCHR;

        // We used to remove any exsisting ISP files here, but this also removes OobeUSB files so we no longer do this

        // Now try to copy all the new files over.
        //
        if ( !CopyDirectoryDialog(g_App.hInstance, hwnd, lpszPath, szDst) )
        {
            DeletePath(szDst);
            MsgBox(GetParent(hwnd), IDS_ERR_COPYINGFILES, IDS_APPNAME, MB_ERRORBOX, szDst[0], lpszPath);
            *lpszPath = NULLCHR;
        }
        else
            bRet = TRUE;

        // Reset the path display boxes.
        //
        SetDlgItemText(hwnd, (id == IDC_PRECONFIG_BROWSE) ? IDC_PRECONFIG_DIR : IDC_ISP2_DIR, lpszPath);
        SetDlgItemText(hwnd, (id == IDC_PRECONFIG_BROWSE) ? IDC_ISP2_DIR : IDC_PRECONFIG_DIR, NULLSTR);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\iecust.c ===
/****************************************************************************\

    IECUST.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "IE Customize" wizard page.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.

   10/99 - Brian Ku (BRIANK)
        Modified this file for the IEAK integration. Separated the toolbar 
        button features into btoolbar.c.

  
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"

/* Example:

[URL]
...
Home_Page=http://www.bbc.co.uk
Search_Page=http://www.yahoo.com
Help_Page=http://www.online.com
*/

//
// Internal Defined Value(s):
//

#define INI_KEY_HOMEPAGE        _T("Home_Page")
#define INI_KEY_HELPPAGE        _T("Help_Page")
#define INI_KEY_SEARCHPAGE      _T("Search_Page")

/* NOTE: Moved to btoolbar.c

#define INI_KEY_CAPTION         _T("Caption0")
#define INI_KEY_ACTION          _T("Action0")
#define INI_KEY_TOOLTIP         _T("ToolTipText0")
*/


//
// Internal Globals
//
BOOL g_fGrayHomePage = TRUE, g_fGrayHelpPage = TRUE, g_fGraySearchPage = TRUE;

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND);
static void EnableControls(HWND hwnd, UINT uId, BOOL fEnable);

/* NOTE: Moved to btoolbar.c

BOOL CALLBACK ToolBarDlgProc(HWND, UINT, WPARAM, LPARAM);
static BOOL ToolBarOnInit(HWND, HWND, LPARAM);
static void ToolBarOnCommand(HWND, INT, HWND, UINT);
static BOOL ValidData(HWND);
static void SaveData(HWND);
*/

//
// External Function(s):
//

LRESULT CALLBACK StartSearchDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if (!OnNext(hwnd))
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_IECUST;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR szUrl[MAX_URL];

    // Retrieve the IE home page URL.
    //
    szUrl[0] = NULLCHR;
    ReadInstallInsKey(INI_SEC_URL, INI_KEY_HOMEPAGE, szUrl, STRSIZE(szUrl),
        GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile, &g_fGrayHomePage);
    SendDlgItemMessage(hwnd, IDC_HOMEPAGE, EM_LIMITTEXT, STRSIZE(szUrl) - 1, 0L);
    SetDlgItemText(hwnd, IDC_HOMEPAGE, szUrl);
    EnableControls(hwnd, IDC_STARTPAGE, !g_fGrayHomePage);

    // Retrieve the IE search page URL.
    //
    szUrl[0] = NULLCHR;
    ReadInstallInsKey(INI_SEC_URL, INI_KEY_SEARCHPAGE, szUrl, STRSIZE(szUrl),
        GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile, &g_fGraySearchPage);
    SendDlgItemMessage(hwnd, IDC_SEARCHPAGE, EM_LIMITTEXT, STRSIZE(szUrl) - 1, 0L);
    SetDlgItemText(hwnd, IDC_SEARCHPAGE, szUrl);
    EnableControls(hwnd, IDC_SEARCHPAGE2, !g_fGraySearchPage);


    // Retrieve the IE help page URL.
    //
    szUrl[0] = NULLCHR;
    ReadInstallInsKey(INI_SEC_URL, INI_KEY_HELPPAGE, szUrl, STRSIZE(szUrl),
        GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szInstallInsFile, &g_fGrayHelpPage);
    SendDlgItemMessage(hwnd, IDC_HELPPAGE, EM_LIMITTEXT, STRSIZE(szUrl) - 1, 0L);
    SetDlgItemText(hwnd, IDC_HELPPAGE, szUrl);
    EnableControls(hwnd, IDC_CUSTOMSUPPORT, !g_fGrayHelpPage);


    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR   szUrl[MAX_URL];
    LPTSTR  lpUrlPart;
    BOOL    bEnable         = FALSE;
    HWND    hTestControl    = NULL;

    switch ( id )
    {
        case IDC_HPTEST:
        case IDC_SPTEST:
        case IDC_HLPTEST:
            lstrcpyn(szUrl, _T("http://"), AS(szUrl));
            lpUrlPart = szUrl + lstrlen(szUrl);
            GetDlgItemText(hwnd, id == IDC_HPTEST ? IDC_HOMEPAGE : id == IDC_SPTEST ? IDC_SEARCHPAGE : IDC_HELPPAGE, lpUrlPart, (int)(STRSIZE(szUrl) - (lpUrlPart - szUrl)));
            if ( *lpUrlPart )
                ShellExecute(hwnd, STR_OPEN, _tcsstr(lpUrlPart, _T("://")) ? lpUrlPart : szUrl, NULL, NULL, SW_SHOW);
            break;

        case IDC_STARTPAGE:
            g_fGrayHomePage = !g_fGrayHomePage;
            EnableControls(hwnd, IDC_STARTPAGE, !g_fGrayHomePage);
            break;

        case IDC_SEARCHPAGE2:   
            g_fGraySearchPage = !g_fGraySearchPage;
            EnableControls(hwnd, IDC_SEARCHPAGE2, !g_fGraySearchPage);
            break;

        case IDC_CUSTOMSUPPORT:
            g_fGrayHelpPage = !g_fGrayHelpPage;
            EnableControls(hwnd, IDC_CUSTOMSUPPORT, !g_fGrayHelpPage);
            break;

        case IDC_HOMEPAGE:
        case IDC_SEARCHPAGE:
        case IDC_HELPPAGE:

            // This is the notification for a text box that has just changed
            //
            if (codeNotify == EN_CHANGE)
            {
                szUrl[0] = NULLCHR;

                // Get the text (if any) in the text box
                //
                GetDlgItemText(hwnd, id, szUrl, STRSIZE(szUrl));

                // Is there text
                //
                if ( szUrl[0] )
                    bEnable = TRUE;

                // Get the sibling test button
                //
                switch ( id )
                {
                    case IDC_HOMEPAGE:
                        hTestControl = GetDlgItem(hwnd, IDC_HPTEST);
                        break;
                    case IDC_SEARCHPAGE:
                        hTestControl = GetDlgItem(hwnd, IDC_SPTEST);
                        break;
                    case IDC_HELPPAGE:
                        hTestControl = GetDlgItem(hwnd, IDC_HLPTEST);
                        break;
                }

                // Enable/Disable the control
                //
                if ( hTestControl )
                    EnableWindow(hTestControl, bEnable);
            }
            break;
            
        /* NOTE: Moved to btoolbar.c

        case IDC_REMOVE:
            WritePrivateProfileSection(INI_SEC_TOOLBAR, NULLSTR, g_App.szInstallInsFile);
            WritePrivateProfileSection(INI_SEC_TOOLBAR, NULL, g_App.szOpkWizIniFile);
            SetDlgItemText(hwnd, IDC_TOOLBAR, NULLSTR);
            EnableWindow(GetDlgItem(hwnd,IDC_EDIT),FALSE);
            EnableWindow(GetDlgItem(hwnd,IDC_REMOVE),FALSE);
            EnableWindow(GetDlgItem(hwnd,IDC_ADD),TRUE);
            break;
        */
    }
}

static BOOL OnNext(HWND hwnd)
{
    TCHAR szUrl[MAX_URL]; 

    // Save the IE home page URL.
    //
    szUrl[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_HOMEPAGE, szUrl, STRSIZE(szUrl));
    if (!g_fGrayHomePage && !ValidURL(szUrl)) {
        MsgBox(hwnd, IDS_ERR_FAVURL, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(GetDlgItem(hwnd, IDC_HOMEPAGE)); 
        return FALSE;
    }
    WriteInstallInsKey(INI_SEC_URL, INI_KEY_HOMEPAGE, szUrl, g_App.szInstallInsFile, g_fGrayHomePage);

    // Save the IE search page URL.
    //
    szUrl[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_SEARCHPAGE, szUrl, STRSIZE(szUrl));
    if (!g_fGraySearchPage && !ValidURL(szUrl)) {
        MsgBox(hwnd, IDS_ERR_FAVURL, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(GetDlgItem(hwnd, IDC_SEARCHPAGE)); 
        return FALSE;
    }
    WriteInstallInsKey(INI_SEC_URL, INI_KEY_SEARCHPAGE, szUrl, g_App.szInstallInsFile, g_fGraySearchPage);

    // Save the IE help page URL.
    //
    szUrl[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_HELPPAGE, szUrl, STRSIZE(szUrl));
    if (!g_fGrayHelpPage && !ValidURL(szUrl)) {
        MsgBox(hwnd, IDS_ERR_FAVURL, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(GetDlgItem(hwnd, IDC_HELPPAGE)); 
        return FALSE;
    }
    WriteInstallInsKey(INI_SEC_URL, INI_KEY_HELPPAGE, szUrl, g_App.szInstallInsFile, g_fGrayHelpPage);

    return TRUE;
}

static void EnableControls(HWND hwnd, UINT uId, BOOL fEnable)
{
    TCHAR szUrl[MAX_URL]; 

    switch ( uId )
    {
        case IDC_STARTPAGE:
            EnableWindow(GetDlgItem(hwnd, IDC_HPSTATIC), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HOMEPAGE), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HPTEST), fEnable && GetDlgItemText(hwnd, IDC_HOMEPAGE, szUrl, STRSIZE(szUrl)));
            CheckDlgButton(hwnd, IDC_STARTPAGE, fEnable ? BST_CHECKED : BST_UNCHECKED);
            break;

        case IDC_SEARCHPAGE2:
            EnableWindow(GetDlgItem(hwnd, IDC_SPSTATIC), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_SEARCHPAGE), fEnable);   
            EnableWindow(GetDlgItem(hwnd, IDC_SPTEST), fEnable && GetDlgItemText(hwnd, IDC_SEARCHPAGE, szUrl, STRSIZE(szUrl)));
            CheckDlgButton(hwnd, IDC_SEARCHPAGE2, fEnable ? BST_CHECKED : BST_UNCHECKED);            
            break;

        case IDC_CUSTOMSUPPORT:
            EnableWindow(GetDlgItem(hwnd, IDC_HLPSTATIC), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HELPPAGE), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HLPTEST), fEnable && GetDlgItemText(hwnd, IDC_HELPPAGE, szUrl, STRSIZE(szUrl)));
            CheckDlgButton(hwnd, IDC_CUSTOMSUPPORT, fEnable ? BST_CHECKED : BST_UNCHECKED);            
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\langsku.c ===
/****************************************************************************\

    LANGSKU.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Target Language" wizard page.

    10/00 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard.  It includes the new
        ability to deploy mulitple languages from one wizard.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"



//
// Internal Function Prototype(s):
//

LRESULT CALLBACK LangSkuDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam);
static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify);
static void ManageSkuList(HWND hwnd, BOOL bAdd);
static void UpdateSkuList(HWND hwnd);


//
// External Function(s):
//

void ManageLangSku(HWND hwndParent)
{
    DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_LANGSKU), hwndParent, LangSkuDlgProc);
}


//
// Internal Function(s):
//

LRESULT CALLBACK LangSkuDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_CLOSE:
            EndDialog(hwnd, 0);
            return FALSE;

        default:
            return FALSE;
    }

    return TRUE;
}

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Setup the language list box.
    //
    SetupLangListBox(GetDlgItem(hwnd, IDC_LANG_LIST));

    // Setup the sku list box.
    //
    UpdateSkuList(hwnd);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    NMHDR nmhMsg;

    switch ( id )
    {       
        case IDOK:
            SendMessage(hwnd, WM_CLOSE, 0, 0L);
            // Send a PSN_SETACTIVE message to make sure that the IDD_SKU wizard page
            // updates with the latest sku info if it is displayed currently.
            //
            ZeroMemory(&nmhMsg, sizeof(nmhMsg));
            nmhMsg.hwndFrom = hwnd;
            nmhMsg.code     = PSN_SETACTIVE;

            SendMessage(GetParent(hwnd), WM_NOTIFY, 0, (LPARAM) &nmhMsg);
            break;

        case IDC_ADDSKU:
            ManageSkuList(hwnd, TRUE);
            break;

        case IDC_DELSKU:
            ManageSkuList(hwnd, FALSE);
            break;

        case IDC_LANG_LIST:
            if ( codeNotify == LBN_SELCHANGE )
                UpdateSkuList(hwnd);
            break;
    }
}

static void ManageSkuList(HWND hwnd, BOOL bAdd)
{
    INT     nItem;
    LPTSTR  lpszLangName;

    // Make sure we know what lang is selected.
    //
    if ( ( (nItem = (INT) SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETCURSEL, 0, 0L)) != LB_ERR ) &&
         ( lpszLangName = (LPTSTR) SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETITEMDATA, nItem, 0L) ) )
    {
        if ( bAdd )
            AddSku(hwnd, GetDlgItem(hwnd, IDC_SKU_LIST), lpszLangName);
        else
            DelSku(hwnd, GetDlgItem(hwnd, IDC_SKU_LIST), lpszLangName);
    }
}

static void UpdateSkuList(HWND hwnd)
{
    LPTSTR  lpLangDir;
    INT     nItem = (INT) SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETCURSEL, 0, 0L);
    BOOL    bEnable = TRUE;

    // Remove everything from the sku list.
    //
    while ( (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCOUNT, 0, 0L) > 0 )
        SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_DELETESTRING, 0, 0L);

    // Make sure we know what lang is selected.
    //
    if ( ( nItem != LB_ERR ) &&
         ( lpLangDir = (LPTSTR) SendDlgItemMessage(hwnd, IDC_LANG_LIST, LB_GETITEMDATA, nItem, 0L) ) )
    {
        // Check the lang folder for SKUs and update the SKU list box.
        //
        SetupSkuListBox(GetDlgItem(hwnd, IDC_SKU_LIST), lpLangDir);
    }
    else
        bEnable = FALSE;

    // Now make sure the sku list is enabled if there
    // is a language selected.
    //
    EnableWindow(GetDlgItem(hwnd, IDC_SKU_LIST), bEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_SKUS), bEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\license.c ===
/****************************************************************************\

    LICENSE.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "system builder EULA" wizard page.

    5/99 - Jason Cohen (JCOHEN)
        Updated this old source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"

#ifndef NO_LICENSE

#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define INI_KEY_CRC         _T("wizlicns.txt")
#define INI_KEY_SKIPEULA    _T("skipeula")
#define FILE_EULA           INI_KEY_CRC
#define STR_ULONG           _T("%lu")


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
LONG CALLBACK EulaEditWndProc(HWND, UINT, WPARAM, LPARAM);


//
// External Function(s):
//

BOOL CALLBACK LicenseDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        case WM_COMMAND:

            switch ( LOWORD(wParam) )
            {
                case IDC_ACCEPT:
                case IDC_DONT:
                    WIZ_BUTTONS(hwnd, ( IsDlgButtonChecked(hwnd, IDC_ACCEPT) == BST_CHECKED ) ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_BACK);
                    break;

                case IDC_EULA_TEXT:
                    if ( HIWORD(wParam) == EN_SETFOCUS )
					    SendMessage((HWND) lParam, EM_SETSEL, (WPARAM) 0, 0L);
					break;
            }
            return FALSE;

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:

                    //
                    // ISSUE-2002/0s/28-stelo- Do we need to create an OPKWIZ.TAG file?  I don't know
                    //          what it is used for.  Also wouldn't it be nice if they
                    //          only got asked once for the EULA and then never again.
                    //

                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_LICENSE;

                    // Don't show the EULA for OEMs.
                    //
                    if ( GET_FLAG(OPK_OEM) )
                        WIZ_SKIP(hwnd);
                    else
                        ShowWindow(GetParent(hwnd), SW_SHOW);

                    // Setup the wizard buttons.
                    //
                    WIZ_BUTTONS(hwnd, ( IsDlgButtonChecked(hwnd, IDC_ACCEPT) == BST_CHECKED ) ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_BACK);

                    break;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR       szFullPath[MAX_PATH],
                szInfCRC[32],
                szCrc[32];
    LPTSTR      lpEulaText  = NULL;
    HANDLE      hfEula      = INVALID_HANDLE_VALUE;
    DWORD       dwSize      = 0xFFFFFFFF,
                dwBytes;
    HRESULT hrPrintf;

    // Now load the EULA if this isn't the OEM version.
    //
    if ( !GET_FLAG(OPK_OEM) )
    {
        // Get the CRC value from the inf file.
        //
        GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_CRC, NULLSTR, szInfCRC, sizeof(szInfCRC), g_App.szOpkInputInfFile);

        // Get the CRC value from the eula file.
        ///
        lstrcpyn(szFullPath, g_App.szWizardDir,AS(szFullPath));
        AddPathN(szFullPath, FILE_EULA,AS(szFullPath));
        hrPrintf=StringCchPrintf(szCrc, AS(szCrc), STR_ULONG, CrcFile(szFullPath));

        // Check the CRC and read in the file.
        //
        if ( ( lstrcmpi(szInfCRC, szCrc) == 0 ) &&
             ( (hfEula = CreateFile(szFullPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) != INVALID_HANDLE_VALUE ) &&
             ( (dwSize = GetFileSize(hfEula, NULL)) < 0xFFFF ) &&
             ( (lpEulaText = (LPTSTR) MALLOC(dwSize + 1)) != NULL ) &&
             ( ReadFile(hfEula, (LPVOID) lpEulaText, dwSize, &dwBytes, NULL) ) &&
             ( dwSize == dwBytes ) )
        {
            // Null terminate the string and put it in the edit box.
            //
            *(lpEulaText + dwSize) = NULLCHR;
            SetWindowText(GetDlgItem(hwnd, IDC_EULA_TEXT), lpEulaText);
            SendDlgItemMessage(hwnd, IDC_EULA_TEXT, EM_SETSEL, (WPARAM) 0, 0L);
        }
        else
        {
            // We need to error out, but first see if it was a memory error, or a problem with the EULA.
            //
            if ( ( dwSize < 0xFFFF ) && ( lpEulaText == NULL ) )
                MsgBox(GetParent(hwnd), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
            else
            {
                LPTSTR lpBuffer = AllocateString(NULL, IDS_NDA_CORRUPT2);
                MsgBox(GetParent(hwnd), IDS_NDA_CORRUPT1, IDS_APPNAME, MB_ERRORBOX, lpBuffer ? lpBuffer : NULLSTR);
                FREE(lpBuffer);
            }

            // Exit out of the wizard.
            //
            WIZ_EXIT(hwnd);
        }

        // Close the file handle if we opened it.
        //
        if ( hfEula != INVALID_HANDLE_VALUE )
            CloseHandle(hfEula);

        // Make sure that we free the eula text buffer.
        //
        FREE(lpEulaText);

        // Replace the wndproc for the edit box.
        //
        EulaEditWndProc(GetDlgItem(hwnd, IDC_EULA_TEXT), WM_SUBWNDPROC, 0, 0L);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

LONG CALLBACK EulaEditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static FARPROC lpfnOldProc = NULL;

    switch ( msg )
    {
        case EM_SETSEL:
            wParam = lParam = 0;
            PostMessage(hwnd, EM_SCROLLCARET, 0, 0L);
            break;

        case WM_CHAR:
            if ( wParam == KEY_ESC )
                WIZ_PRESS(GetParent(hwnd), PSBTN_CANCEL);
            break;

        case WM_SUBWNDPROC:
            lpfnOldProc = (FARPROC) GetWindowLong(hwnd, GWL_WNDPROC);
            SetWindowLongPtr(hwnd, GWPL_WNDPROC, (LONG) EulaEditWndProc);
            return 1;
    }

    if ( lpfnOldProc )
        return (LONG) CallWindowProc((WNDPROC) lpfnOldProc, hwnd, msg, wParam, lParam);
    else
        return 0;
}

#endif  // NO_LICENSE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\logo.c ===
/****************************************************************************\

    LOGO.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Logo" wizard page.

    5/99 - Jason Cohen (JCOHEN)
        Updated this old source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define FILE_CPLLOGO        _T("OEMLOGO.BMP")

#define INI_SEC_LOGOFILE    _T("LogoFiles")
#define INI_KEY_CPLBMP      _T("CplBmp")


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND hwnd);
static void EnableControls(HWND, UINT, BOOL);


//
// External Function(s):
//

LRESULT CALLBACK LogoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_LOGO;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szLocal[MAX_PATH],
            szSource[MAX_PATH];

    // Should always look for the source file name.
    //
    szSource[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_LOGOFILE, INI_KEY_CPLBMP, NULLSTR, szSource, AS(szSource), g_App.szOpkWizIniFile);

    // Now figure out the local file name.
    //
    lstrcpyn(szLocal, g_App.szTempDir,AS(szLocal));
    AddPathN(szLocal, DIR_OEM_SYSTEM32,AS(szLocal));
    if ( GET_FLAG(OPK_BATCHMODE) )
        CreatePath(szLocal);
    AddPathN(szLocal, FILE_CPLLOGO,AS(szLocal));

    // Limit the size of the edit box.
    //
    SendDlgItemMessage(hwnd, IDC_LOGO_CPLLOC, EM_LIMITTEXT, MAX_PATH - 1, 0);

    // Check for batch mode and copy the file if we need to.
    //
    if ( GET_FLAG(OPK_BATCHMODE) && szSource[0] && FileExists(szSource) )
        CopyResetFileErr(GetParent(hwnd), szSource, szLocal);

    // Check for the file to decide if we enable the
    // option or not.
    //
    if ( szSource[0] && FileExists(szLocal) )
    {
        CheckDlgButton(hwnd, IDC_LOGO_CPL, TRUE);
        EnableControls(hwnd, IDC_LOGO_CPL, TRUE);
        SetDlgItemText(hwnd, IDC_LOGO_CPLLOC, szSource);
    }
    else
        EnableControls(hwnd, IDC_LOGO_CPL, FALSE);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szFileName[MAX_PATH];

    switch ( id )
    {
        case IDC_LOGO_CPL:
            EnableControls(hwnd, id, IsDlgButtonChecked(hwnd, id) == BST_CHECKED);
            break;

        case IDC_LOGO_CPLBROWSE:

            szFileName[0] = NULLCHR;
            GetDlgItemText(hwnd, IDC_LOGO_CPLLOC, szFileName, STRSIZE(szFileName));

            if ( BrowseForFile(GetParent(hwnd), IDS_BROWSE, IDS_BMPFILTER, IDS_BMP, szFileName, STRSIZE(szFileName), g_App.szBrowseFolder, 0) ) 
            {
                LPTSTR  lpFilePart  = NULL;
                TCHAR   szTargetFile[MAX_PATH];

                // Save the last browse directory.
                //
                if ( GetFullPathName(szFileName, AS(g_App.szBrowseFolder), g_App.szBrowseFolder, &lpFilePart) && g_App.szBrowseFolder[0] && lpFilePart )
                    *lpFilePart = NULLCHR;

                lstrcpyn(szTargetFile, g_App.szTempDir,AS(szTargetFile));
                AddPathN(szTargetFile, DIR_OEM_SYSTEM32,AS(szTargetFile));
                CreatePath(szTargetFile);
                AddPathN(szTargetFile, FILE_CPLLOGO,AS(szTargetFile));
                if ( CopyResetFileErr(GetParent(hwnd), szFileName, szTargetFile) )
                    SetDlgItemText(hwnd, IDC_LOGO_CPLLOC, szFileName);
            }
            break;
    }
}

static BOOL OnNext(HWND hwnd)
{
    TCHAR   szTargetFile[MAX_PATH],
            szSourceFile[MAX_PATH];

    // Prepare oemlogo.bmp as target file.
    //
    lstrcpyn(szTargetFile, g_App.szTempDir,AS(szTargetFile));
    AddPathN(szTargetFile, DIR_OEM_SYSTEM32,AS(szTargetFile));
    AddPathN(szTargetFile, FILE_CPLLOGO,AS(szTargetFile));

    if ( IsDlgButtonChecked(hwnd, IDC_LOGO_CPL) == BST_CHECKED )
    {
        // Validation consists of verifying the files they have entered were actually copied.
        //
        szSourceFile[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_LOGO_CPLLOC, szSourceFile, STRSIZE(szSourceFile));
        if ( !szSourceFile[0] || !FileExists(szTargetFile) )
        {
            MsgBox(GetParent(hwnd), szSourceFile[0] ? IDS_NOFILE : IDS_BLANKFILE, IDS_APPNAME, MB_ERRORBOX, szSourceFile);
            SetFocus(GetDlgItem(hwnd, IDC_LOGO_CPLBROWSE));
            return FALSE;
        }

        // Save the source path in the batch file.
        //
        WritePrivateProfileString(INI_SEC_LOGOFILE, INI_KEY_CPLBMP, szSourceFile, g_App.szOpkWizIniFile);
    }
    else
    {
        // Remove the logo and source path.
        //
        DeleteFile(szTargetFile);
        WritePrivateProfileString(INI_SEC_LOGOFILE, INI_KEY_CPLBMP, NULL, g_App.szOpkWizIniFile);
        SetDlgItemText(hwnd, IDC_LOGO_CPLLOC, NULLSTR);
    }

    return TRUE;
}

static void EnableControls(HWND hwnd, UINT uId, BOOL fEnable)
{
    switch ( uId )
    {
        case IDC_LOGO_CPL:
            EnableWindow(GetDlgItem(hwnd, IDC_LOGO_CPLBROWSE), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_LOGO_CPLLOC), fEnable);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\miscapi.c ===
/****************************************************************************\

    MISCAPI.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Misc. API source file for generic APIs used in the OPK Wizard.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include file(s)
//
#include "pch.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define STR_URLDEF          _T("http://")
#define STR_EVENT_CANCEL    _T("SETUPMGR_EVENT_CANCEL")


//
// Internal Defined Macro(s):
//

#define MALLOC(cb)          HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb)
#define FREE(lp)            ( (lp != NULL) ? ( (HeapFree(GetProcessHeap(), HEAP_NO_SERIALIZE, (LPVOID) lp)) ? ((lp = NULL) == NULL) : (FALSE) ) : (FALSE) )


//
// Internal Type Definition(s):
//

typedef struct _COPYDIRDATA
{
    HWND    hwndParent;
    LPTSTR  lpSrc;
    LPTSTR  lpDst;
    HANDLE  hEvent;
} COPYDIRDATA, *PCOPYDIRDATA, *LPCOPYDIRDATA;


//
// Internal Function Prototype(s):
//

LRESULT CALLBACK CopyDirDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD WINAPI CopyDirThread(LPVOID lpVoid);


//
// External Function(s):
//

// If we find a key name with _Gray then *pfGray == TRUE
//
void ReadInstallInsKey(TCHAR szSection[], TCHAR szKey[], TCHAR szValue[], INT cchValue, TCHAR szIniFile[], BOOL* pfGray)
{
    TCHAR szTempKey[MAX_PATH];
    HRESULT hrCat;

    if (!pfGray)
        return;

    lstrcpyn(szTempKey, szKey, AS(szTempKey));
    if (!OpkGetPrivateProfileString(szSection, szTempKey, szValue, szValue, cchValue, szIniFile)) {
        hrCat=StringCchCat(szTempKey, AS(szTempKey), GRAY);
        if (OpkGetPrivateProfileString(szSection, szTempKey, szValue, szValue, cchValue, szIniFile))
                *pfGray = TRUE;
        else
            *pfGray = TRUE; // default to unchecked if not found!
    }
    else
        *pfGray = FALSE;
}

// If pfGrayed == TRUE then concatenate _Gray to the key name
//
void WriteInstallInsKey(TCHAR szSection[], TCHAR szKey[], TCHAR szValue[], TCHAR szIniFile[], BOOL fGrayed)
{
    TCHAR szKeyTemp[MAX_PATH];
    HRESULT hrCat;

    // Clear the old value
    //
    lstrcpyn(szKeyTemp, szKey, AS(szKeyTemp));
    OpkWritePrivateProfileString(szSection, szKeyTemp, NULL, szIniFile);
    hrCat=StringCchCat(szKeyTemp, AS(szKeyTemp), GRAY);
    OpkWritePrivateProfileString(szSection, szKeyTemp, NULL, szIniFile);

    // Write the new value
    lstrcpyn(szKeyTemp, szKey, AS(szKeyTemp));
    if (fGrayed) 
        hrCat=StringCchCat(szKeyTemp, AS(szKeyTemp), GRAY);
    OpkWritePrivateProfileString(szSection, szKeyTemp, szValue, szIniFile);
}

//  NOTE: pszFileName must point to buffer at least length MAX_PATH
void CheckValidBrowseFolder(TCHAR* pszFileName)
{
    if (NULL == pszFileName)
        return;

    // Last known good browse start folder
    //
    PathRemoveFileSpec(pszFileName);
    if (!lstrlen(pszFileName))
        lstrcpyn(pszFileName, g_App.szLastKnownBrowseFolder, MAX_PATH);
}

void SetLastKnownBrowseFolder(TCHAR* pszFileName)
{
    if (NULL == pszFileName)
        return;

    // Save Last known good browse start folder
    //
    PathCombine(g_App.szLastKnownBrowseFolder, pszFileName, NULL);
    PathRemoveFileSpec(g_App.szLastKnownBrowseFolder);
}

// NOTE: lpszURL is assumed to point to a buffer at least MAX_URL in length
BOOL ValidURL(LPTSTR lpszURL)
{
    BOOL    bResult             = TRUE;
    TCHAR   szBuffer[MAX_PATH]  = NULLSTR;
    HRESULT hrCat;

    // Check if valid URL
    //
    if ( !PathIsURL(lpszURL) )
    {
        // Check if empty string first
        //
        if (0 == lstrlen(lpszURL))
            bResult = FALSE;
        else {
            // Currently not a valid URL, we are now going to prepend the
            // URL with http:// and then test the validity again
            //
            lstrcpyn(szBuffer, STR_URLDEF, AS(szBuffer));
            hrCat=StringCchCat(szBuffer, AS(szBuffer), lpszURL);
        
            // Still not a valid URL or we were unable to copy the string
            //
            if ( !PathIsURL(szBuffer) ||
                 !lstrcpyn(lpszURL, szBuffer, MAX_URL) )
                bResult = FALSE;
        }
    }

    return bResult;

}

BOOL IsFolderShared(LPWSTR lpFolder, LPWSTR lpShare, DWORD cbShare)
{
    LPSHARE_INFO_502        lpsi502 = NULL;
    DWORD                   dwRead  = 0,
                            dwTotal = 0;
    NET_API_STATUS          nas;
    BOOL                    bRet    = FALSE,
                            bBest   = FALSE,
                            bBuffer = ( lpShare && cbShare );
    PACL                    paclOld = NULL;
    TCHAR                   szUnc[MAX_COMPUTERNAME_LENGTH + 4] = NULLSTR;

    // Success or failure, we will always atleast pass back the computer
    // name if they passed in a buffer.  So here is where we create the
    // computer name part of the path.
    //
    if ( bBuffer )
    {
        DWORD cbUnc = AS(szUnc) - 2;
        HRESULT hrCat;

        // We want to return the UNC path, so first need the \\ plus the
        // computer name.
        //
        // NOTE:  We hard coded the length of the "\\" string below as 2
        //        in two different places.  Once just above, and once below
        //        in the GetComputerName() call.  We also hard code the "\"
        //        string below as 1 when adding to the lenght of the string
        //        after adding the computer name.  So don't forget these things
        //        if you make some changes here.
        //
        lstrcpyn(szUnc, _T("\\\\"), cbUnc);
        if ( ( GetComputerName(szUnc + 2, &cbUnc) ) &&
             ( AS(szUnc) > ((DWORD) lstrlen(szUnc) + 1) ) )
        {
            // Added on a backslash so we can add the share name.
            //
            hrCat=StringCchCat(szUnc,AS(szUnc), _T("\\"));
        }
        else
        {
            // If GetComputerName() fails, that is bad.  But we will just
            // return the share name.  That is about all we can do.
            //
            szUnc[0] = NULLCHR;
        }

    }
 
    // Now share time, first retrieve all the shares on this machine.
    //
    nas = NetShareEnum(NULL, 502, (unsigned char **) &lpsi502, MAX_PREFERRED_LENGTH, &dwRead, &dwTotal, NULL);

    // Make sure we got a list of shares, otherwise there is nothing.
    // we can do.  Because we specify MAX_PREFERRED_LENGTH, we should
    // never get ERROR_MORE_DATA, but if for some reason we do there is
    // no reason not to loop through the ones we did get.
    //
    if ( ( lpsi502 ) &&
         ( ( nas == NERR_Success ) || ( nas == ERROR_MORE_DATA ) ) )
    {
        int     iLength     = lstrlen(lpFolder);
        LPTSTR  lpSearch    = lpFolder + iLength;
        HRESULT hrCat;

        // Trailing backslash is only bad if not the root folder.
        //
        if ( iLength > 3 )
        {
            // See if the folder has a trailing backslash.
            //
            lpSearch = CharPrev(lpFolder, lpSearch);
            if ( *lpSearch == _T('\\') )
            {
                iLength--;
            }
        }

        // Go through all the shares until we fine the best
        // one for this directory.
        //
        while ( dwRead-- && !bBest )
        {
            // See if this share is a disk share and is the
            // same path passed in.
            //
            if ( ( lpsi502[dwRead].shi502_type == STYPE_DISKTREE ) &&
                 ( StrCmpNI(lpsi502[dwRead].shi502_path, lpFolder, iLength) == 0 ) &&
                 ( lstrlen(lpsi502[dwRead].shi502_path) == iLength ) )
            {
                // If this directory is shared more than once, we want to use
                // the first one we fine with no security descriptor, because 
                // then it is most likely shared out to everyone.
                //
                if ( lpsi502[dwRead].shi502_security_descriptor == NULL )
                {
                    // If there is no security descriptor, then everyone should have
                    // access and this is a good share.
                    //
                    bBest = TRUE;
                }

                // If we have no ACL, or we reset it because the new one is better,
                // then we want to copy off the share name into our return buffer.
                //
                if ( !bRet || bBest )
                {
                    // Return the share name for this directory in the supplied buffer
                    // (if the buffer is NULL or zero size, we just return TRUE so they
                    // know that the folder is shared even if they don't care what the
                    // name of the share is).
                    //
                    if ( bBuffer )
                    {
                        // Find out what we have room for in the return buffer.
                        //
                        if ( cbShare > (DWORD) (lstrlen(lpsi502[dwRead].shi502_netname) + lstrlen(szUnc)) )
                        {
                            // Copy the computer name and share into return buffer.
                            //
                            lstrcpyn(lpShare, szUnc, cbShare);
                            hrCat=StringCchCat(lpShare, cbShare, lpsi502[dwRead].shi502_netname);
                        }
                        else if ( cbShare > (DWORD) lstrlen(lpsi502[dwRead].shi502_netname) )
                        {
                            // Return buffer not big enough for both computer name and
                            // share name, so just return the share name.
                            //
                            lstrcpyn(lpShare, lpsi502[dwRead].shi502_netname,cbShare);
                        }
                        else
                        {
                            // Not big enough for both, so return TRUE because we found a
                            // share, but don't return anything in the buffer.
                            //
                            *lpShare = NULLCHR;
                        }
                    }
                }

                // We found one, so always set this to TRUE.
                //
                bRet = TRUE;
            }
        }
    }

    // Make sure and free the buffer returned by NetShareEnum().
    //
    if ( lpsi502 )
        NetApiBufferFree(lpsi502);

    // Now check to see if we didn't find the share, because we can
    // still just return the computer name.
    //
    if ( ( !bRet && bBuffer ) &&
         ( cbShare > (DWORD) lstrlen(szUnc) ) )
    {
        lstrcpyn(lpShare, szUnc, cbShare);
    }

    return bRet;
}

BOOL CopyDirectoryDialog(HINSTANCE hInstance, HWND hwnd, LPTSTR lpSrc, LPTSTR lpDst)
{
    COPYDIRDATA cdd;

    // Pass in via the structure the source and destination the dialog needs
    // to know about.
    //
    cdd.lpSrc = lpSrc;
    cdd.lpDst = lpDst;

    // Create the progress dialog.
    //
    return ( DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PROGRESS), hwnd, CopyDirDlgProc, (LPARAM) &cdd) != 0 );
}

BOOL CopyResetFileErr(HWND hwnd, LPCTSTR lpSource, LPCTSTR lpTarget)
{
    BOOL bReturn;

    if ( !(bReturn = CopyResetFile(lpSource, lpTarget)) && hwnd )
        MsgBox(hwnd, IDS_MISSINGFILE, IDS_APPNAME, MB_ERRORBOX, lpSource);
    return bReturn;
}


//
// Internal Function(s):
//

LRESULT CALLBACK CopyDirDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPCOPYDIRDATA lpcdd = NULL;

    switch (uMsg)
    {
        case WM_INITDIALOG:

            // Make sure we have out copy directory data structure.
            //
            if ( lParam )
            {
                HANDLE  hThread;
                DWORD   dwThreadId;

                // Save off our lParam.
                //
                lpcdd = (LPCOPYDIRDATA) lParam;

                // Replace the old parent with the new progress dialog parent.
                //
                lpcdd->hwndParent = hwnd;

                // Need to pass in the cancel event as well.
                //
                lpcdd->hEvent = CreateEvent(NULL, TRUE, FALSE, STR_EVENT_CANCEL);

                // Now create the thread that will copy the actual files.
                //
                if ( hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) CopyDirThread, (LPVOID) lpcdd, 0, &dwThreadId) )
                    CloseHandle(hThread);
                else
                    EndDialog(hwnd, 0);
            }
            else
                EndDialog(hwnd, 0);

            return FALSE;

        case WM_COMMAND:
        case WM_CLOSE:

            // If we have an event, signal it, or just end the dialog.
            //
            if ( lpcdd && lpcdd->hEvent )
                SetEvent(lpcdd->hEvent);
            else
                EndDialog(hwnd, 0);
            return FALSE;

        case WM_DESTROY:

            // If there is an event, get rid of it.
            //
            if ( lpcdd && lpcdd->hEvent )
            {
                CloseHandle(lpcdd->hEvent);
                lpcdd->hEvent = NULL;
            }
            return FALSE;

        default:
            return FALSE;
    }

    return TRUE;
}

DWORD WINAPI CopyDirThread(LPVOID lpVoid)
{
    LPCOPYDIRDATA   lpcdd           = (LPCOPYDIRDATA) lpVoid;
    HWND            hwnd            = lpcdd->hwndParent,
                    hwndProgress    = GetDlgItem(hwnd, IDC_PROGRESS);
    HANDLE          hEvent          = lpcdd->hEvent;
    DWORD           dwRet           = 0;
    LPTSTR          lpSrc           = lpcdd->lpSrc,
                    lpDst           = lpcdd->lpDst;

    // First we need to create the path.
    //
    if ( CreatePath(lpDst) )
    {
        // Setup the progress bar.
        //
        SendMessage(hwndProgress, PBM_SETSTEP, 1, 0L);
        SendMessage(hwndProgress, PBM_SETRANGE32, 0, (LPARAM) FileCount(lpSrc));

        // Now copy the directory.
        //
        if ( CopyDirectoryProgressCancel(hwndProgress, hEvent, lpSrc, lpDst) )
            dwRet = 1;
    }

    // Now end the dialog with our error code and return.
    //
    EndDialog(hwnd, dwRet);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\newfiles.h ===
/****************************************************************************\

    NEWFILES.H / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    3/99 - Jason Cohen (JCOHEN)
        Added this new header file for the OPK Wizard as part of the OOBE
        update.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


#ifndef _NEWFILES_H_
#define _NEWFILES_H_


//
// External Function Prototype(s):
//

void AddFiles(HWND, LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPTSTR);


#endif // _NEWFILES_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\mode.c ===
/****************************************************************************\

    MODE.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "mode select" wizard page.

    4/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define INI_KEY_MODE                _T("Mode")
#define INI_KEY_RESEAL              _T("Reseal")
#define INI_VAL_ADVANCED            1
#define INI_VAL_ENHANCED            2

#define INI_VAL_SADVANCED           STR_ONE
#define INI_VAL_SSTANDARD           STR_ZERO
#define INI_VAL_SENHANCED           _T("2")


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify);
static void OnNext(HWND);
static void EnableControls(HWND hwnd);


//
// External Function(s):
//

LRESULT CALLBACK ModeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    OnNext(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_MODESEL;

                    WIZ_BUTTONS(hwnd, PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//


static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    INT     iStrings[] = 
    {
        IDS_RESEAL_FACTORY,
        IDS_RESEAL_OOBE,
    };

    TCHAR   szScratch[256];
    DWORD   dwIndex;
    LPTSTR  lpString;

    // Set the flag because we want to warn before exiting
    //
    SET_FLAG(OPK_EXIT, FALSE);

    // Setup the combo box.
    //
    for ( dwIndex = 0; dwIndex < AS(iStrings); dwIndex++ )
    {
        if ( lpString = AllocateString(NULL, iStrings[dwIndex]) )
        {
            SendDlgItemMessage(hwnd, IDC_RESEAL_COMBO, CB_ADDSTRING, 0, (LPARAM) lpString);
            FREE(lpString);
        }
    }
    SendDlgItemMessage(hwnd, IDC_RESEAL_COMBO, CB_SETCURSEL, 0, 0L);

    // Determine the mode that we are going to use (different
    // for batch mode).
    //
    if ( GET_FLAG(OPK_BATCHMODE) )
    {
        // In Batch we use the opkwiz inf file.
        //
        switch ( GetPrivateProfileInt(INI_SEC_GENERAL, INI_KEY_MODE, 0, g_App.szOpkWizIniFile) )
        {
            // Check the necessary radio button
            //
            case INI_VAL_ADVANCED:
                CheckRadioButton(hwnd, IDC_STANDARD, IDC_ADVANCED, IDC_ADVANCED);
                break;
            case INI_VAL_ENHANCED:
                CheckRadioButton(hwnd, IDC_STANDARD, IDC_ADVANCED, IDC_EXPRESS);
                if ( GetPrivateProfileInt(INI_SEC_GENERAL, INI_KEY_RESEAL, 0, g_App.szOpkWizIniFile) == 1 )
                    SendDlgItemMessage(hwnd, IDC_RESEAL_COMBO, CB_SETCURSEL, 1, 0L);
                break;
            default:
                CheckRadioButton(hwnd, IDC_STANDARD, IDC_ADVANCED, IDC_STANDARD);
        }
    }
    else
    {
        // Normally we just look in the winbom.
        //
        szScratch[0] = NULLCHR;
        GetPrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_RESTART, NULLSTR, szScratch, AS(szScratch), g_App.szWinBomIniFile);
        if ( LSTRCMPI(szScratch, INI_VAL_WBOM_WINPE_IMAGE) == 0 )
        {
            // If the image key is in the winbom, must be an advanced install.
            //
            CheckRadioButton(hwnd, IDC_STANDARD, IDC_ADVANCED, IDC_ADVANCED);
        }
        else
        {
            // Need to check another key to see if it is express or standard.
            //
            szScratch[0] = NULLCHR;
            GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_FACTORY_RESEAL, NULLSTR, szScratch, AS(szScratch), g_App.szWinBomIniFile);
            if ( szScratch[0] && ( LSTRCMPI(szScratch, _T("No")) != 0 ) )
            {
                // They have reseal equal something other than NO, so they must
                // be doing and express install.
                //
                CheckRadioButton(hwnd, IDC_STANDARD, IDC_ADVANCED, IDC_EXPRESS);

                // Need to figure out the reseal mode option.
                //
                szScratch[0] = NULLCHR;
                GetPrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_FACTORY_RESEALMODE, NULLSTR, szScratch, AS(szScratch), g_App.szWinBomIniFile);
                if ( ( szScratch[0] == NULLCHR ) ||
                     ( LSTRCMPI(szScratch, INI_VAL_WBOM_FACTORY) != 0 ) )
                {
                    // They don't have the mode set to factory, so it must be end user
                    // boot (it was already set to factory by default so nothing to do
                    // if that is what the reseal mode key says).
                    //
                    SendDlgItemMessage(hwnd, IDC_RESEAL_COMBO, CB_SETCURSEL, 1, 0L);
                }
            }
            else
            {
                // No reseal, so this is just a standard install.
                //
                CheckRadioButton(hwnd, IDC_STANDARD, IDC_ADVANCED, IDC_STANDARD);
            }
        }
    }

    // Make sure the proper controls are enabled/disabled.
    //
    EnableControls(hwnd);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    switch ( id )
    {
        case IDC_STANDARD:
        case IDC_EXPRESS:
        case IDC_ADVANCED:
            EnableControls(hwnd);
            break;
    }
}

static void OnNext(HWND hwnd)
{
    BOOL    bAdvanced       = ( IsDlgButtonChecked(hwnd, IDC_ADVANCED) == BST_CHECKED ),
            bExpress        = ( !bAdvanced && ( IsDlgButtonChecked(hwnd, IDC_EXPRESS) == BST_CHECKED ) ),
            bEndUser        = ( bExpress && ( SendDlgItemMessage(hwnd, IDC_RESEAL_COMBO, CB_GETCURSEL, 0, 0L) == 1 ) );

    // Write out the mode to the opkwiz inf and winbom files.
    //
    WritePrivateProfileString(WBOM_WINPE_SECTION, INI_KEY_WBOM_WINPE_RESTART, ( bAdvanced ? INI_VAL_WBOM_WINPE_IMAGE : INI_VAL_WBOM_WINPE_REBOOT ), g_App.szWinBomIniFile);
    WritePrivateProfileString(INI_SEC_GENERAL, INI_KEY_MODE, ( bAdvanced ? INI_VAL_SADVANCED : ( bExpress ? INI_VAL_SENHANCED : INI_VAL_SSTANDARD ) ), g_App.szOpkWizIniFile);

    // Now if this is express write out what is in the combo box
    // to the opkwiz inf and winbom files.
    //
    WritePrivateProfileString(INI_SEC_GENERAL, INI_KEY_RESEAL, ( bEndUser ? STR_ONE : NULL ), g_App.szOpkWizIniFile);
    WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_FACTORY_RESEAL, ( bExpress ? _T("Yes") : NULL ), g_App.szWinBomIniFile);
    WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_FACTORY_RESEALMODE, ( ( bExpress && !bEndUser ) ? INI_VAL_WBOM_FACTORY : NULL ), g_App.szWinBomIniFile);
}

static void EnableControls(HWND hwnd)
{
    BOOL fEnable = ( IsDlgButtonChecked(hwnd, IDC_EXPRESS) == BST_CHECKED );

    EnableWindow(GetDlgItem(hwnd, IDC_RESEAL_TEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_RESEAL_COMBO), fEnable);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\newfiles.c ===
/****************************************************************************\

    NEWFILES.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    3/99 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard as part of the OOBE
        update.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include file(s):
//

#include "pch.h"
#include "newfiles.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define DIR_CONFIG_OOBE         _T("$OEM$")

#define INF_SECT_SOURCEDISK     _T("SourcedisksFiles")
#define INF_SECT_DESTDIRS       _T("DestinationDirs")
#define INF_SECT_OOBE           _T("RegisterOOBE")

#define INF_LINE_COPYFILES      _T("CopyFiles")

#define INF_PREFIX              _T("X")
#define SOURCENUM_OPTIONS_CAB   _T("782")
#define DESTLDID_OOBE           _T("11")
#define STR_SEARCH              _T("*")
#define STR_PADDING             _T("\r\n\r\n")

#define MAX_BUFFER              16384 // 32768

#ifndef CSTR_EQUAL
#define CSTR_EQUAL              2
#endif // CSTR_EQUAL


//
// Internal Structure(s):
//

typedef struct _FILELIST
{
    LPTSTR              lpFileName;
    LPTSTR              lpDirectory;
    struct _FILELIST *  lpNext;
} FILELIST, *PFILELIST, *LPFILELIST;


//
// Internal Function Prototype(s):
//

static void DelFiles(LPTSTR, LPTSTR, DWORD, LPTSTR, LPTSTR);
static LPFILELIST AllocFileList(HWND, LPTSTR, LPTSTR);
static BOOL CompareFiles(LPTSTR, LPTSTR);


//
// External Function(s):
//

//////////////////////////////////////////////////////////////////////////////
// AddFiles - lpSourceDir = location of files to copy to OOBE directory.
//            Destination = location of the system directory where installed to
//                          LDID.
//            lpConfigDir = location of oemaudit.inf, and config files.
//            lpSourceDir -> OOBE -> lpDestDir
//
void AddFiles(HWND hwndParent, LPTSTR lpSourceDir, LPTSTR lpDestLdid, 
              LPTSTR lpDestDir, LPTSTR lpDestName, LPTSTR lpConfigDir)
{
    LPTSTR      lpFilePart,
                lpFile,
                lpFileName,
                lpSectEnd,
                lpSearch,
                lpTarget,
                lpNext;
    TCHAR       szBuffer[MAX_PATH + 32] = NULLSTR,
                szCurDir[MAX_PATH]      = NULLSTR,
                szSourceDir[MAX_PATH]   = NULLSTR,
                szCopyDir[MAX_PATH],                
                szWinbom[MAX_PATH],
                szCopyFiles[MAX_PATH + 32];
    LPFILELIST  lpflHead                = NULL,
                lpflCur,
                lpflBuf;
    BOOL        bFound;
    DWORD       dwNum;
    int        iFilePartLen;
    HRESULT hrCat;
    HRESULT hrPrintf;


    //
    // First thing we do is setup the directories and strings
    // that we need to do all the work.
    //

    // We need the path to the config directory.  Copydir is where
    // the files are going to be copied to from the SourceDir 
    // so it needs to be cleaned out before we do the CopyFile.
    // CopyDir will be created if not exists.
    //
    lstrcpyn(szCopyDir, lpConfigDir, AS(szCopyDir));
    AddPathN(szCopyDir, DIR_CONFIG_OOBE,AS(szCopyDir));
    AddPathN(szCopyDir, _T("\\"),AS(szCopyDir));
    lpFilePart = szCopyDir + lstrlen(szCopyDir);
    iFilePartLen= AS(szCopyDir)-lstrlen(szCopyDir);

    // Need a full path to the oemaudit inf.
    //
    lstrcpyn(szWinbom, lpConfigDir,AS(szWinbom));
    AddPathN(szWinbom, FILE_WINBOM_INI,AS(szWinbom));

    // We need to construct the prefix to the copy
    // files section name.
    //
    lstrcpyn(szCopyFiles, INF_PREFIX,AS(szCopyFiles));
    hrCat=StringCchCat(szCopyFiles, AS(szCopyFiles), lpDestLdid ? lpDestLdid : DESTLDID_OOBE);
    if ( lpDestDir && *lpDestDir )
        hrCat=StringCchCat(szCopyFiles, AS(szCopyFiles), lpDestDir);
    StrRem(szCopyFiles, CHR_BACKSLASH);
    lpSectEnd = szCopyFiles + lstrlen(szCopyFiles);


    //
    // Now that we have that info, we need to get rid of any files that
    // may have already been put in the inf and the destination directory.
    //

    // Cleaned out of the inf and destination directory only if we are
    // passed in NULL for the source.
    //
    if ( !(lpSourceDir && *lpSourceDir) )
        DelFiles(szCopyDir, lpFilePart, iFilePartLen, szWinbom, szCopyFiles);


    //
    // Now we make a list of all the files we are going to add to the
    // inf and destination directory.
    //

    // If the source isn't a valid dir, we must have just wanted to clean up.
    //
    if ( ( lpSourceDir && *lpSourceDir ) &&
         ( GetFullPathName(lpSourceDir, sizeof(szSourceDir) / sizeof(TCHAR), szSourceDir, &lpFile) && szSourceDir[0] ) &&
         ( (dwNum = GetFileAttributes(szSourceDir)) != 0xFFFFFFFF ) )
    {
        // Check to see if we were passed a file or a directory.
        //
        if ( ( dwNum & FILE_ATTRIBUTE_DIRECTORY ) ||
             ( lpFile <= szSourceDir ) )
        {
            // We are search for all the files in the diretory.
            //
            lpFile = STR_SEARCH;
        }
        else
        {
            // We are only doing one file.  We need to separate
            // the file from the directory.
            //
            *(lpFile - 1) = NULLCHR;
        }

        // Set the staring point for our file search.
        //
        GetCurrentDirectory(sizeof(szCurDir) / sizeof(TCHAR), szCurDir);
        SetCurrentDirectory(szSourceDir);

        // Get the file list.
        //
        lpflHead = AllocFileList(hwndParent, szBuffer, lpFile);

        // Make sure the destination dir exits.
        //
        *lpFilePart = NULLCHR;
        CreatePath(szCopyDir);


        //
        // Now that we have the file list, go through each one processing
        // it separately and then free the memory allocated for it.
        //

        // Loop through all the files in our linked list.
        //
        for ( lpflCur = lpflHead; lpflCur; lpflCur = lpflBuf )
        {
            //
            // First copy the file into the flat directory.
            //

            // Setup the relative path from the currect directory
            // to the file we want to copy.
            //        
            if ( lpflCur->lpDirectory && *lpflCur->lpDirectory )
                lstrcpyn(szBuffer, lpflCur->lpDirectory,AS(szBuffer));
            else
                szBuffer[0] = NULLCHR;
            AddPathN(szBuffer, lpflCur->lpFileName,AS(szBuffer));

            // Support for a different file name for the destination.
            //
            lpFileName = lpDestName ? lpDestName : lpflCur->lpFileName;

            // Setup the destination file name.
            //
            lstrcpyn(lpFilePart, lpFileName, iFilePartLen);

            // Copy the file to the Options\Cabs directory and display
            // an error if the copy failed.  Probably means that this
            // is a duplicate file.
            //
            if ( !CopyFile(szBuffer, szCopyDir, TRUE) )
            {
                // Save the CopyFile error and then check to see if the file
                // is actaully different then the one tried to copy over.
                //
                dwNum = GetLastError();
                if ( ( !CompareFiles(szBuffer, szCopyDir) ) &&
                     ( lpTarget = (LPTSTR) MALLOC(256 * sizeof(TCHAR)) ) )
                {
                    //
                    // I hate doing UI in backend type code.  Because of time I don't have
                    // much choice, but in the future, this UI code should be replaced
                    // with a call back mechanism so the caller can do the UI.
                    //
                    // This is the first of only two places where UI is used in here.
                    //

                    // Allocate another buffer to hold the message with the file name.
                    //
                    if ( ( LoadString(NULL, dwNum == ERROR_FILE_EXISTS ? IDS_ERR_DUPFILE : IDS_ERR_COPY, lpTarget, 256 * sizeof(TCHAR)) ) &&
                         ( lpNext = (LPTSTR) MALLOC((lstrlen(lpFileName) + lstrlen(lpTarget) + 1) * sizeof(TCHAR)) ) )
                    {
                        // Add the file name to the message, get the title for the message
                        // box and display the error.
                        //
                        hrPrintf=StringCchPrintf(lpNext, (lstrlen(lpFileName) + lstrlen(lpTarget) + 1), lpTarget, lpFileName);
                        *lpTarget = NULLCHR;
                        LoadString(NULL, IDS_APPNAME, lpTarget, 256 * sizeof(TCHAR));
                        MessageBox(hwndParent, lpNext, lpTarget, MB_OK | MB_ICONWARNING | MB_APPLMODAL);
                        FREE(lpNext);
                    }
                    FREE(lpTarget);
                }
            }


            //
            // Now add the file to the [SourceDiskFiles] section.
            //

            // We just use WritePrivateProfileString() to write
            // FILENAME=781 to the [SourceDiskFiles] section.
            //
            WritePrivateProfileString(INF_SECT_SOURCEDISK, lpFileName, SOURCENUM_OPTIONS_CAB, szWinbom);


            //
            // This code figures out what the copy files section will be
            // called.  This is based on the path where the files will
            // be copied.
            //

            // Create the name of the copy files section the file will be in.
            //
            *lpSectEnd = NULLCHR;
            if ( lpflCur->lpDirectory && *lpflCur->lpDirectory )
                lstrcpyn(lpSectEnd, lpflCur->lpDirectory, AS(szCopyFiles)-(int)(lpSectEnd - szCopyFiles) );
            StrRem(lpSectEnd, CHR_BACKSLASH);


            //
            // Now add the file path to the [DestinationDirs] section.
            //

            // Create the LDID and dir combo to write to the dest dir section.
            //
            lstrcpyn(szBuffer, lpDestLdid ? lpDestLdid : DESTLDID_OOBE,AS(szBuffer));
            if ( ( lpDestDir && *lpDestDir ) ||
                 ( lpflCur->lpDirectory && *lpflCur->lpDirectory ) )
            {
                hrCat=StringCchCat(szBuffer,AS(szBuffer), _T(",\""));
                if ( lpDestDir && *lpDestDir )
                {
                    hrCat=StringCchCat(szBuffer, AS(szBuffer),lpDestDir);
                    if ( lpflCur->lpDirectory && *lpflCur->lpDirectory )
                        AddPathN(szBuffer, lpflCur->lpDirectory,AS(szBuffer));
                }
                else
                    hrCat=StringCchCat(szBuffer, AS(szBuffer), lpflCur->lpDirectory);
                hrCat=StringCchCat(szBuffer, AS(szBuffer), _T("\""));
            }

            // We just use WritePrivateProfileString() to write
            // COPYFILES=11,"OOBE\\DIR" to the [DestinationDirs] section.
            //
            WritePrivateProfileString(INF_SECT_DESTDIRS, szCopyFiles, szBuffer, szWinbom);


            //
            // Now add the copy files section to the CopyFiles line.
            //

            // First get current CopyFiles line.
            //
            szBuffer[0] = NULLCHR;
            GetPrivateProfileString(INF_SECT_OOBE, INF_LINE_COPYFILES, NULLSTR, szBuffer, sizeof(szBuffer) / sizeof(TCHAR), szWinbom);

            // Search each section listed in the CopyFiles line to see
            // if we need to add this one.  The sections are divided by
            // commas.
            //
            // ISSUE-2002/02/28-stelo- May want to take qutoes into account, but I don't think so.
            //
            bFound = FALSE;
            for ( lpTarget = szBuffer; !bFound && lpTarget && *lpTarget; lpTarget = lpNext )
            {
                // Get rid of proceeding spaces.
                //
                while ( *lpTarget == CHR_SPACE )
                    lpTarget = CharNext(lpTarget);

                // NULL terminate at the ',' and setup
                // the lpNext pointer.
                //
                if ( lpNext = StrChr(lpTarget, _T(',')) )
                    *lpNext = NULLCHR;
            
                // Make sure there are no trailing spaces.
                //
                if ( lpSearch = StrChr(lpTarget, CHR_SPACE) )
                    *lpSearch = NULLCHR;

                // Check if this section is the same as the one
                // we are going to add.
                //
                if ( CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpTarget, -1, szCopyFiles, -1) == CSTR_EQUAL )
                    bFound = TRUE;

                // Need to restore the characters we may have stomped on.
                //
                if ( lpNext )
                    *lpNext++ = _T(',');
                if ( lpSearch )
                    *lpSearch = CHR_SPACE;
            }

            // Now see if we need to add the line.
            //
            if ( !bFound )
            {
                // Append our copy files section.
                //
                if ( szBuffer[0] )
                    hrCat=StringCchCat(szBuffer,AS(szBuffer), _T(", "));
                hrCat=StringCchCat(szBuffer, AS(szBuffer), szCopyFiles);

                // We just use WritePrivateProfileString() to write
                // the CopyFiles line back to the [RegisterOOBE] section
                // with our added copy files section on it.
                //
                WritePrivateProfileString(INF_SECT_OOBE, INF_LINE_COPYFILES, szBuffer, szWinbom);
            }


            //
            // Now write the file name to it's copy files section.
            //

            // First get the entire copy files section.
            //
            GetPrivateProfileSection(szCopyFiles, szBuffer, sizeof(szBuffer) / sizeof(TCHAR), szWinbom);

            // Loop throught the strings to see if the file is already there.
            //
            bFound = FALSE;
            for ( lpTarget = szBuffer; !bFound && *lpTarget; lpTarget += (lstrlen(lpTarget) + 1) )
            {
                // Get rid of proceeding spaces.
                //
                while ( *lpTarget == CHR_SPACE )
                    lpTarget = CharNext(lpTarget);

                // Make sure there are no trailing spaces.
                //
                if ( lpSearch = StrChr(lpTarget, CHR_SPACE) )
                    *lpSearch = NULLCHR;

                // Check if this section is the same as the one
                // we are going to add.
                //
                if ( CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpTarget, -1, lpFileName, -1) == CSTR_EQUAL )
                    bFound = TRUE;

                // Need to restore the character we may have stomped on.
                //
                if ( lpSearch )
                    *lpSearch = CHR_SPACE;
            }

            // Now write back the section if we need to.
            //
            if ( !bFound )
            {
                // Need to a pointer to the end of the sub strings.
                //
                for ( lpSearch = szBuffer; *lpSearch; lpSearch += (lstrlen(lpSearch) + 1) );

                // Copy the string to the end and add an extra NULL.
                //
                lstrcpyn(lpSearch, lpFileName, ((MAX_PATH+32)-(int)(lpSearch-szBuffer)) );
                lpSearch += (lstrlen(lpSearch) + 1);
                *lpSearch = NULLCHR;

                // We need to call WritePrivateProfileSection() with NULL
                // to remove the section.  We shouldn't have to do this,
                // but the Win32 docs are not correct.
                //
                WritePrivateProfileSection(szCopyFiles, NULL, szWinbom);

                // We just use WritePrivateProfileSection() to write the
                // copy files section back with our added file in it.
                //
                WritePrivateProfileSection(szCopyFiles, szBuffer, szWinbom);
            }


            //
            // Now free the structure and the data within it.
            //

            // Save the next pointer before we free the structure.
            //
            lpflBuf = lpflCur->lpNext;

            // Free the file buffers and the structure.
            //
            FREE(lpflCur->lpFileName);
            FREE(lpflCur->lpDirectory);
            FREE(lpflCur);
        }


        //
        // All done, now just clean up.
        //

        // Put the current directory back to where it should be.
        //
        if ( szCurDir[0] )
            SetCurrentDirectory(szCurDir);
    }

    // Make sure the changes to the inf are flushed to disk
    //
    WritePrivateProfileString(NULL, NULL, NULL, szWinbom);
}


//
// Internal Function(s):
//

static void DelFiles(LPTSTR lpszCopyDir, LPTSTR lpszFilePart, DWORD cbFilePart, LPTSTR lpszWinbom, LPTSTR lpszCopyFiles)
{
    LPTSTR      lpSearch,
                lpSection,
                lpFileName,
                lpTarget,
                lpNext;
    LPTSTR      lpszSections  = NULL,
                lpszFileNames = NULL,
                lpszBuffer    = NULL;
    BOOL        bFound;

    //
    // Allocate buffers...
    //
    lpszSections  = MALLOC(MAX_BUFFER * sizeof(TCHAR));
    lpszFileNames = MALLOC(MAX_BUFFER * sizeof(TCHAR));
    lpszBuffer    = MALLOC(MAX_BUFFER * sizeof(TCHAR));

    if ( !lpszSections || !lpszFileNames || !lpszBuffer )
    {
        // Free the buffers... Note: FREE macro checks for NULL
        //
        FREE( lpszSections );
        FREE( lpszFileNames );
        FREE( lpszBuffer );

        return;
    }

    // We need all the section names.
    //
    GetPrivateProfileSectionNames(lpszSections, MAX_BUFFER, lpszWinbom);

    // Loop throught the section to see if there is any that match our search criteria.
    //
    for ( lpSection = lpszSections; lpSection && *lpSection; lpSection += (lstrlen(lpSection) + 1) )
    {
        // Get rid of proceeding spaces.
        //
        while ( *lpSection == CHR_SPACE )
            lpSection = CharNext(lpSection);

        // Make sure there are no trailing spaces.
        //
        if ( lpSearch = StrChr(lpSection, CHR_SPACE) )
            *lpSearch = NULLCHR;

        // Check if this section is the same as the one
        // we are going to add.
        //
        if ( CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpSection, lstrlen(lpszCopyFiles), lpszCopyFiles, lstrlen(lpszCopyFiles)) == CSTR_EQUAL )
        {
            // We need all the files in the section.
            //
            GetPrivateProfileSection(lpSection, lpszFileNames, MAX_BUFFER, lpszWinbom);

            // Loop throught the section to see if there is any that match our search criteria.
            //
            for ( lpFileName = lpszFileNames; *lpFileName; lpFileName += (lstrlen(lpFileName) + 1) )
            {
                // Get rid of proceeding spaces.
                //
                while ( *lpFileName == CHR_SPACE )
                    lpFileName = CharNext(lpFileName);

                // Make sure there are no trailing spaces.
                //
                if ( lpSearch = StrChr(lpFileName, CHR_SPACE) )
                    *lpSearch = NULLCHR;

                // Delete the file from the destination directory.
                //
                lstrcpyn(lpszFilePart, lpFileName, cbFilePart);
                DeleteFile(lpszCopyDir);

                // Remove the line from the source disk section.
                //
                WritePrivateProfileString(INF_SECT_SOURCEDISK, lpFileName, NULL, lpszWinbom);
            }

            // Search each section listed in the CopyFiles and remove
            // this one.  The sections are divided by commas.
            //
            bFound = FALSE;
            GetPrivateProfileString(INF_SECT_OOBE, INF_LINE_COPYFILES, NULLSTR, lpszBuffer, MAX_BUFFER, lpszWinbom);
            for ( lpTarget = lpszBuffer; !bFound && lpTarget && *lpTarget; lpTarget = lpNext )
            {
                // Get rid of proceeding spaces.
                //
                while ( *lpTarget == CHR_SPACE )
                    lpTarget = CharNext(lpTarget);

                // NULL terminate at the ',' and setup
                // the lpNext pointer.
                //
                if ( lpNext = StrChr(lpTarget, _T(',')) )
                    *lpNext = NULLCHR;
            
                // Make sure there are no trailing spaces.
                //
                if ( lpSearch = StrChr(lpTarget, CHR_SPACE) )
                    *lpSearch = NULLCHR;

                // Check if this section is the same as the one
                // we are going to remove.
                //
                if ( CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, lpTarget, -1, lpSection, -1) == CSTR_EQUAL )
                    bFound = TRUE;

                // Need to restore the characters we may have stomped on.
                //
                if ( lpNext )
                    *lpNext++ = _T(',');
                if ( lpSearch )
                    *lpSearch = CHR_SPACE;

                if ( bFound )
                {
                    // Go back to the ',' or the beginning of the buffer.
                    //
                    while ( ( lpTarget > lpszBuffer) && ( *lpTarget != _T(',') ) )
                        lpTarget = CharPrev(lpszBuffer, lpTarget);

                    // Now overwrite the string we took out.
                    //
                    if ( lpNext )
                        lstrcpyn(lpTarget, lpNext - 1, (MAX_BUFFER-(int)(lpTarget-lpszBuffer)));
                    else
                        *lpTarget = NULLCHR;
                }
            }
            if ( bFound )
            {
                // We should eat any preceeding spaces and/or commas just
                // for good measure.
                //
                for ( lpTarget = lpszBuffer; ( *lpTarget == CHR_SPACE ) || ( *lpTarget == _T(',') ); lpTarget = CharNext(lpTarget) );

                // Now write the buffer back to the inf file.
                //
                WritePrivateProfileString(INF_SECT_OOBE, INF_LINE_COPYFILES, *lpTarget ? lpTarget : NULL, lpszWinbom);
            }

            // Remove the line from the destination dirs section.
            //
            WritePrivateProfileString(INF_SECT_DESTDIRS, lpSection, NULL, lpszWinbom);

            // Remove this section entirely.
            //
            WritePrivateProfileSection(lpSection, NULL, lpszWinbom);
        }
    }

    // Free the buffers... Note: FREE macro checks for NULL
    //
    FREE( lpszSections );
    FREE( lpszFileNames );
    FREE( lpszBuffer );
}

static LPFILELIST AllocFileList(HWND hwndParent, LPTSTR lpDirectory, LPTSTR lpSearch)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;
    LPTSTR          lpEnd,
                    lpFileName;
    LPFILELIST      lpflHead   = NULL;
    LPFILELIST*     lplpflNext = &lpflHead;
    HRESULT hrPrintf;

    // Process all the files and directories.
    //
    if ( (hFile = FindFirstFile(lpSearch, &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // Display an error if the short and long file names don't match.
            // Means that it is a LFN, which INFs don't like.
            //
            if ( ( FileFound.cAlternateFileName[0] ) &&
                 ( CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, FileFound.cAlternateFileName, -1, FileFound.cFileName, -1) != CSTR_EQUAL ) &&
                 ( lpEnd = (LPTSTR) MALLOC(256 * sizeof(TCHAR)) ) )
            {
                //
                // I hate doing UI in backend type code.  Because of time I don't have
                // much choice, but in the future, this UI code should be replaced
                // with a call back mechanism so the caller can do the UI.
                //
                // This is the second of only two places where UI is used in here.
                //

                // Allocate another buffer to hold the message with the file name.
                //
                if ( ( LoadString(NULL, IDS_ERR_LFN, lpEnd, 256) ) &&
                     ( lpFileName = (LPTSTR) MALLOC((lstrlen(FileFound.cFileName) + lstrlen(lpEnd) + 1) * sizeof(TCHAR)) ) )
                {
                    // Add the file name to the message, get the title for the message
                    // box and display the error.
                    //
                    hrPrintf=StringCchPrintf(lpFileName, (lstrlen(FileFound.cFileName) + lstrlen(lpEnd) + 1), lpEnd, FileFound.cFileName);
                    *lpEnd = NULLCHR;
                    LoadString(NULL, IDS_APPNAME, lpEnd, 256 * sizeof(TCHAR));
                    MessageBox(hwndParent, lpFileName, lpEnd, MB_OK | MB_ICONWARNING | MB_APPLMODAL);
                    FREE(lpFileName);
                }
                FREE(lpEnd);
            }

            // Get a pointer to the file name, the short one if possible.
            //
            if ( FileFound.cAlternateFileName[0] )
                lpFileName = FileFound.cAlternateFileName;
            else
                lpFileName = FileFound.cFileName;

            // First check to see if this is a files (not a directory).
            //
            if ( !( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) )
            {
                // Allocate the next item in the structure.
                //
                if ( *lplpflNext = (LPFILELIST) MALLOC(sizeof(FILELIST)) )
                {
                    // Allocate the buffer for the file name and path and
                    // make sure that none of the allocations fail.
                    //
                    if ( ( (*lplpflNext)->lpFileName = (LPTSTR) MALLOC((lstrlen(lpFileName) + 1) * sizeof(TCHAR)) ) &&
                         ( (*lplpflNext)->lpDirectory = (LPTSTR) MALLOC((lstrlen(lpDirectory) + 1) * sizeof(TCHAR)) ) )
                    {
                        // Copy the file name and path into the buffers.
                        //
                        lstrcpyn((*lplpflNext)->lpFileName, lpFileName, (lstrlen(lpFileName) + 1));
                        lstrcpyn((*lplpflNext)->lpDirectory, lpDirectory, (lstrlen(lpDirectory) + 1));

                        // Null the next pointer so we know this is the last item.
                        //
                        (*lplpflNext)->lpNext = NULL;

                        // Set the next pointer to point to the address of
                        // the next member of this new structure.
                        //
                        lplpflNext = &((*lplpflNext)->lpNext);
                    }
                    else
                    {
                        // Don't worry, the FREE() macro checks for NULL
                        // before it frees the memory.
                        //
                        FREE((*lplpflNext)->lpFileName);
                        FREE(*lplpflNext);
                    }
                }
            }
            // Otherwise, make sure the directory is not "." or "..".
            //
            else if ( ( lstrcmp(lpFileName, _T(".")) ) &&
                      ( lstrcmp(lpFileName, _T("..")) ) )
            {
                // Tack on this directory name to the current path saving
                // the end pointer so that it is easy to get rid of this
                // directory name when we return back.
                //
                lpEnd = lpDirectory + lstrlen(lpDirectory);
                AddPath(lpDirectory, lpFileName);

                // Go into the next directory, get all the files, and
                // the set the current directory back to the original
                // directory.
                //
                SetCurrentDirectory(lpFileName);
                *lplpflNext = AllocFileList(hwndParent, lpDirectory, lpSearch);
                SetCurrentDirectory(_T(".."));

                // Get rid of the directory name off our path buffer.
                //
                *lpEnd = NULLCHR;

                // Need to setup our next pointer to the end of the list
                // returned to us.
                //
                while ( *lplpflNext )
                    lplpflNext = &((*lplpflNext)->lpNext);
            }

        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }

    return lpflHead;
}

static BOOL CompareFiles(LPTSTR lpFile1, LPTSTR lpFile2)
{
    BOOL    bCompare,
            bRead1,
            bRead2;
    HANDLE  hFile1,
            hFile2;
    BYTE    baBuffer1[4096],
            baBuffer2[4096];
    DWORD   dwBytes1,
            dwBytes2,
            dwCount;

    // Open the files.
    //
    hFile1 = CreateFile(lpFile1, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    hFile2 = CreateFile(lpFile2, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    // Make sure the files were opened.
    //
    if ( ( hFile1 != INVALID_HANDLE_VALUE ) &&
         ( hFile2 != INVALID_HANDLE_VALUE ) )
    {
        // Read all the data from the files.
        //
        do
        {
            // Read in the max buffer from each file.
            //
            bRead1 = ReadFile(hFile1, baBuffer1, sizeof(baBuffer1), &dwBytes1, NULL);
            bRead2 = ReadFile(hFile2, baBuffer2, sizeof(baBuffer2), &dwBytes2, NULL);

            // Make sure the reads didn't fail.
            //
            if ( bRead1 && bRead2 )
            {
                // Check to make sure the sizes are the same.
                //
                if ( bCompare = ( dwBytes1 == dwBytes2 ) )
                {
                    // Make sure the buffers are identical.
                    //
                    for ( dwCount = 0; bCompare && ( dwCount < dwBytes1 ); dwCount++ )
                        bCompare = ( baBuffer1[dwCount] == baBuffer2[dwCount] );
                }
            }
            else
                // If both the reads failed, we will return true.
                //
                bCompare = ( !bRead1 && !bRead2 );
        }
        while ( bCompare && bRead1 && bRead2 && dwBytes1 && dwBytes2 );
    }
    else
        // If both the files does not exist, then we will
        // return false.
        //
        bCompare = ( ( hFile1 != INVALID_HANDLE_VALUE ) && ( hFile2 != INVALID_HANDLE_VALUE ) );

    // Close the files.
    //
    if ( hFile1 == INVALID_HANDLE_VALUE )
        CloseHandle(hFile1);
    if ( hFile2 == INVALID_HANDLE_VALUE )
        CloseHandle(hFile2);

    return bCompare;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\oemcust.c ===
/****************************************************************************\

    OEMCUST.C

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Dialog proc and other stuff for the OEM custom file screen.

    3/99 - Added by JCOHEN
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#ifdef OEMCUST

#include "newfiles.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define OEMCUST_FILE        _T("OEMCUST.HTM")


//
// Internal Global Variable(s):
//

TCHAR g_szOemCustomDir[MAX_PATH];


//
// Internal Function Prototype(s):
//

static BOOL OnSetActive(HWND);
static BOOL OnInit(HWND, HWND, LPARAM);
static VOID OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND);


//
// External Function(s):
//

BOOL CALLBACK OemCustDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:

                    if ( !OnNext(hwnd) )
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_SANDBOX;

					if ( OnSetActive(hwnd) )
                        PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);
                    else
                        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, -1);
    				break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnSetActive(HWND hwnd)
{
    // If this page is OK to show, just return TRUE.
    //
    if ( GET_FLAG(OPK_OEM) )
        return TRUE;

    // This page and setting is not allowed in non OEM.
    //
    if ( IsDlgButtonChecked(hwnd, IDC_OEMCUST_ON) == BST_CHECKED )
    {
        // We have to make sure the check box is uncheck.  They may
        // have already been to this page when multi-lingual wasn't set.
        //
        CheckDlgButton(hwnd, IDC_OEMCUST_ON, BST_UNCHECKED);
        EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_TEXT), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_DIR), FALSE);
        EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_BROWSE), FALSE);

        // Now save the unchecked state to the file.
        //
        OnNext(hwnd);
    }

    // We don't want to display this page.
    //
    return FALSE;
}

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Get the file path to use for the OEM custom files from
    // opkwiz inf.
    //
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_OEMCUST, NULLSTR, g_szOemCustomDir, sizeof(g_szOemCustomDir) / sizeof (TCHAR), g_App.szOpkWizIniFile);
    SetDlgItemText(hwnd, IDC_OEMCUST_DIR, g_szOemCustomDir);

    // Check the dialog box if it was set in the oobeinfo ini.
    //
    if ( GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_OEMCUST, 0, g_App.szOobeInfoIniFile) )
    {
        CheckDlgButton(hwnd, IDC_OEMCUST_ON, BST_CHECKED);
        EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_TEXT), TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_DIR), TRUE);
        EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_BROWSE), TRUE);
    }

    return FALSE;
}

static VOID OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    BOOL bCheck;

    switch ( id )
    {
        case IDC_OEMCUST_ON:

            // Enable/Disable the extra stuff if the option is checked or not.
            //
            bCheck = ( IsDlgButtonChecked(hwnd, IDC_OEMCUST_ON) == BST_CHECKED );
            EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_TEXT), bCheck);
            EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_DIR), bCheck);
            EnableWindow(GetDlgItem(hwnd, IDC_OEMCUST_BROWSE), bCheck);
			break;

        case IDC_OEMCUST_BROWSE:

            // Browse for the folder the OEM wants to use as their source.
            //
            if ( BrowseForFolder(hwnd, IDS_BROWSEFOLDER, g_szOemCustomDir) )
                SetDlgItemText(hwnd, IDC_OEMCUST_DIR, g_szOemCustomDir);
            break;
    }
}

static BOOL OnNext(HWND hwnd)
{
    TCHAR   szFullPath[MAX_PATH];
    BOOL    bCheck;
    DWORD   dwAttr;


    //
    // First do some checks to make sure we can continue.
    //

    // If we have custom OEM files, there are some checks to make.
    //
    GetDlgItemText(hwnd, IDC_OEMCUST_DIR, g_szOemCustomDir, sizeof(g_szOemCustomDir));
    if ( bCheck = ( IsDlgButtonChecked(hwnd, IDC_OEMCUST_ON) == BST_CHECKED ) )
    {
        // Make sure we have a valid directory.
        //
        if ( g_szOemCustomDir[0] )
            dwAttr = GetFileAttributes(g_szOemCustomDir);
        if ( ( !g_szOemCustomDir[0] ) ||
             ( dwAttr == 0xFFFFFFFF ) ||
             ( !( dwAttr & FILE_ATTRIBUTE_DIRECTORY ) ) )
        {
            MsgBox(GetParent(hwnd), IDS_ERR_OEMCUSTDIR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_OEMCUST_DIR));
            return FALSE;
        }

        // Check for hardware tutorial required file.
        //
        lstrcpyn(szFullPath, g_szOemCustomDir,AS(szFullPath));
        AddPathN(szFullPath, OEMCUST_FILE,AS(szFullPath));
        if ( ( !EXIST(szFullPath) ) && ( MsgBox(GetParent(hwnd), IDS_ERR_OEMCUSTFILE, IDS_APPNAME, MB_ICONSTOP | MB_OKCANCEL | MB_APPLMODAL) == IDCANCEL ) )
            return FALSE;
    }


    //
    // Checks are done, save the data now.
    //

    // Save the file path to use for the OEM custom files
    // in opkwiz inf.
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_OEMCUST, g_szOemCustomDir, g_App.szOpkWizIniFile);

    // Save the on/off setting for the OEM custom files
    // in oobeinfo ini.
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_OEMCUST, bCheck ? _T("1") : NULL, g_App.szOobeInfoIniFile);

    return TRUE;
}


#endif // OEMCUST
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\oemfldr.c ===
/****************************************************************************\

    OEMFLDR.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2000
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Start Menu OEM branding" wizard page.

    11/2000 - Sankar Ramasubramanian (SANKAR)
    3/2000  - Sankar Ramasubramanian (SANKAR):
              Changed the code to get graphic images and a link.

\****************************************************************************/


//
// Include File(s):
//
#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND hwnd);
static void EnableControls(HWND, UINT, BOOL);
static int  GetIndexOfPushButton(int id);

#define LOC_FILENAME_OEMLINK_ICON       _T("OemLinkIcon")
#define LOC_FILENAME_OEMLINK_PATH       _T("OemLink")
#define LOC_FILENAME_OEMLINK_ICON_EXT   _T(".ico")
#define LOC_FILENAME_OEMLINK_HTML_EXT   _T(".htm")


#define ENV_WINDIR_SYS32      _T("%WINDIR%\\System32")

typedef struct  {
    LPTSTR pszIniKeyNameOriginal;
    LPTSTR pszIniKeyNameLocal;
    int   idDlgItemStatic;
    int   idDlgItemEdit;
    int   idDlgItemButton;
    LPTSTR pszLocalFileName;
    LPTSTR pszExtension;
} OEMDETAILS;

static OEMDETAILS OemInfo[] = {
    {
        INI_KEY_OEMLINK_ICON_ORIGINAL,  
        INI_KEY_OEMLINK_ICON_LOCAL,  
        IDC_OEMLINK_STATIC_ICON, 
        IDC_OEM_LINK_ICON,
        IDC_OEMLINK_ICON_BUTTON,
        LOC_FILENAME_OEMLINK_ICON,
        LOC_FILENAME_OEMLINK_ICON_EXT
    },
    {
        INI_KEY_OEMLINK_PATH_ORIGINAL,      
        INI_KEY_OEMLINK_PATH_LOCAL,      
        IDC_OEMLINK_LINK_STATIC,     
        IDC_OEM_LINK_PATH,            
        IDC_OEMLINK_LINK_BUTTON,
        LOC_FILENAME_OEMLINK_PATH,
        NULLSTR                     //We need to use the extension given by the user.
                                    //because it could be .exe or .htm
    }
};


//
// External Function(s):
//

LRESULT CALLBACK OemLinkDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:
            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZFINISH:
                case PSN_WIZBACK:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_OEMFOLDER;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_FINISH);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

// NOTE: pszLocal is assumed to be at least MAX_PATH length
void AppendCorrectExtension(int iIndex, LPTSTR pszLocal, LPTSTR pszSource)
{
    LPTSTR pszExt = NULL;
    HRESULT hrCat;
   
    // Find the appropriate extension.
    if(OemInfo[iIndex].pszExtension[0])     //If we know what extension we look for....
        pszExt = OemInfo[iIndex].pszExtension; //use it.
    else
    {
        // It could be HTM or EXE. So, use the one in the source.
        pszExt = PathFindExtension(pszSource);
        // If source doesn't have an extension, use the default HTM
        if( pszExt && (*pszExt == _T('\0')) )
            pszExt = LOC_FILENAME_OEMLINK_HTML_EXT;
    }
    //Append the extension to the local filename.
    hrCat=StringCchCat(pszLocal, MAX_PATH, pszExt);
}
        
//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    int iIndex;
    BOOL fValidData = TRUE; //Assume that the data is valid.
    TCHAR   szLocal[MAX_PATH],
            szSource[MAX_PATH];

    szSource[0] = NULLCHR;
    //Read the Oem Link Static Text.
    GetPrivateProfileString(INI_SEC_OEMLINK, INI_KEY_OEMLINK_LINKTEXT, NULLSTR, szSource, AS(szSource), g_App.szOpkWizIniFile);
    // Limit the size of the edit box.
    //
    SendDlgItemMessage(hwnd, IDC_OEM_LINK_TEXT, EM_LIMITTEXT, STRSIZE(szSource) - 1, 0);
    SetDlgItemText(hwnd, IDC_OEM_LINK_TEXT, szSource);

    //Read the Oem Link's infotip text.
    GetPrivateProfileString(INI_SEC_OEMLINK, INI_KEY_OEMLINK_INFOTIP, NULLSTR, szSource, AS(szSource), g_App.szOpkWizIniFile);
    // Limit the size of infotip editbox to 128 characters.
    //
    SendDlgItemMessage(hwnd, IDC_OEM_LINK_INFOTIP, EM_LIMITTEXT, 128, 0);
    SetDlgItemText(hwnd, IDC_OEM_LINK_INFOTIP, szSource);
        
    for(iIndex = 0; iIndex < ARRAYSIZE(OemInfo); iIndex++)
    {
        // Should always look for the source file name.
        //
        szSource[0] = NULLCHR;
        GetPrivateProfileString(INI_SEC_OEMLINK, OemInfo[iIndex].pszIniKeyNameOriginal, NULLSTR, szSource, AS(szSource), g_App.szOpkWizIniFile);
        
        // Now figure out the local file name.
        //
        lstrcpyn(szLocal, g_App.szTempDir,AS(szLocal));
        AddPathN(szLocal, DIR_OEM_SYSTEM32,AS(szLocal));
        if ( GET_FLAG(OPK_BATCHMODE) )
            CreatePath(szLocal);
        AddPathN(szLocal, OemInfo[iIndex].pszLocalFileName,AS(szLocal));

        // Append the appropriate extension.
        AppendCorrectExtension(iIndex, szLocal, szSource);        

        // Limit the size of the edit box.
        //
        SendDlgItemMessage(hwnd, OemInfo[iIndex].idDlgItemEdit, EM_LIMITTEXT, STRSIZE(szSource) - 1, 0);
        
        // Check for batch mode and copy the file if we need to.
        //
        if ( GET_FLAG(OPK_BATCHMODE) && szSource[0] && FileExists(szSource) )
            CopyResetFileErr(GetParent(hwnd), szSource, szLocal);

        // Check for the file to decide if we enable the
        // option or not.
        //
        if ( szSource[0] && FileExists(szLocal) )
        {
            SetDlgItemText(hwnd, OemInfo[iIndex].idDlgItemEdit, szSource);
        }
        else
        {
            fValidData = FALSE;
        }
    }

    //
    // If all the data is valid, we enable the controls.
    if(fValidData)
    {
        CheckDlgButton(hwnd, IDC_OEMLINK_CHECK, TRUE);
        EnableControls(hwnd, IDC_OEMLINK_CHECK, TRUE);
    }
    else
    {
        CheckDlgButton(hwnd, IDC_OEMLINK_CHECK, FALSE);
        EnableControls(hwnd, IDC_OEMLINK_CHECK, FALSE);
    }
        
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szFileName[MAX_PATH];
    int iIndex;
    int iFilter, iDefExtension;

    switch ( id )
    {
        case IDC_OEMLINK_CHECK:
            EnableControls(hwnd, id, IsDlgButtonChecked(hwnd, id) == BST_CHECKED);
            break;

        case IDC_OEMLINK_ICON_BUTTON:
        case IDC_OEMLINK_LINK_BUTTON:

            //Get the correct filter and Default extension
            if(id == IDC_OEMLINK_LINK_BUTTON)
            {
                //We accept only .HTM and .HTML files here.
                iFilter = IDS_HTMLFILTER;
                iDefExtension = 0;
            }
            else
            {
                //We accept only .ICO files here.
                iFilter = IDS_ICO_FILTER;
                iDefExtension = IDS_ICO;
            }
            
            szFileName[0] = NULLCHR;
            iIndex = GetIndexOfPushButton(id);
            if(iIndex >= 0)
            {
                GetDlgItemText(hwnd, OemInfo[iIndex].idDlgItemEdit, szFileName, STRSIZE(szFileName));

                if ( BrowseForFile(GetParent(hwnd), IDS_BROWSE, iFilter, iDefExtension, szFileName, STRSIZE(szFileName), g_App.szBrowseFolder, 0) ) 
                {
                    LPTSTR  lpFilePart  = NULL;
                    TCHAR   szTargetFile[MAX_PATH];

                    // Save the last browse directory.
                    //
                    if ( GetFullPathName(szFileName, AS(g_App.szBrowseFolder), g_App.szBrowseFolder, &lpFilePart) && g_App.szBrowseFolder[0] && lpFilePart )
                        *lpFilePart = NULLCHR;

                    lstrcpyn(szTargetFile, g_App.szTempDir,AS(szTargetFile));
                    AddPathN(szTargetFile, DIR_OEM_SYSTEM32,AS(szTargetFile));
                    CreatePath(szTargetFile);
                    AddPathN(szTargetFile, OemInfo[iIndex].pszLocalFileName,AS(szTargetFile));
                    AppendCorrectExtension(iIndex, szTargetFile, szFileName);
                    if ( CopyResetFileErr(GetParent(hwnd), szFileName, szTargetFile) )
                        SetDlgItemText(hwnd, OemInfo[iIndex].idDlgItemEdit, szFileName);
                }
            }
            break;
    }
}

static BOOL OnNext(HWND hwnd)
{
    int iIndex;
    TCHAR   szTargetFile[MAX_PATH],
            szSourceFile[MAX_PATH];
    LPTSTR  psz;
    BOOL    fOemLinkEnabled = FALSE;

    fOemLinkEnabled = (IsDlgButtonChecked(hwnd, IDC_OEMLINK_CHECK) == BST_CHECKED);
    
    //Save the OEM text for the link!
    szSourceFile[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_OEM_LINK_TEXT, szSourceFile, STRSIZE(szSourceFile));
    // Save the text in the batch file.
    WritePrivateProfileString(INI_SEC_OEMLINK, INI_KEY_OEMLINK_LINKTEXT, szSourceFile, g_App.szOpkWizIniFile);
    
    // Save the text in WinBom.Ini also. This is used by factory.exe
    if (!fOemLinkEnabled)
        psz = NULL;
    else
        psz = szSourceFile;
    WritePrivateProfileString(INI_SEC_OEMLINK, INI_KEY_OEMLINK_LINKTEXT, psz, g_App.szWinBomIniFile);
    
    //Save the OEM Infotip text for the link!
    szSourceFile[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_OEM_LINK_INFOTIP, szSourceFile, STRSIZE(szSourceFile));
    // Save the text in the batch file.
    WritePrivateProfileString(INI_SEC_OEMLINK, INI_KEY_OEMLINK_INFOTIP, szSourceFile, g_App.szOpkWizIniFile);
 
    // Save the text in WinBom.Ini also. This is used by factory.exe
    if (!fOemLinkEnabled)
        psz = NULL;
    else
        psz = szSourceFile;
    WritePrivateProfileString(INI_SEC_OEMLINK, INI_KEY_OEMLINK_INFOTIP, psz, g_App.szWinBomIniFile);

    for(iIndex = 0; iIndex < ARRAYSIZE(OemInfo); iIndex++)
    {
        // Prepare OEM link bitmap as target file.
        //
        lstrcpyn(szTargetFile, g_App.szTempDir,AS(szTargetFile));
        AddPathN(szTargetFile, DIR_OEM_SYSTEM32,AS(szTargetFile));
        AddPathN(szTargetFile, OemInfo[iIndex].pszLocalFileName,AS(szTargetFile));

        if (fOemLinkEnabled)
        {
            // Validation consists of verifying the files they have entered were actually copied.
            //
            szSourceFile[0] = NULLCHR;
            GetDlgItemText(hwnd, OemInfo[iIndex].idDlgItemEdit, szSourceFile, STRSIZE(szSourceFile));
            AppendCorrectExtension(iIndex, szTargetFile, szSourceFile);
            if ( !szSourceFile[0] || !FileExists(szTargetFile) )
            {
                MsgBox(GetParent(hwnd), szSourceFile[0] ? IDS_NOFILE : IDS_BLANKFILE, IDS_APPNAME, MB_ERRORBOX, szSourceFile);
                SetFocus(GetDlgItem(hwnd, OemInfo[iIndex].idDlgItemButton));
                return FALSE;
            }

            // Save the Original name in the batch file.
            //
            WritePrivateProfileString(INI_SEC_OEMLINK, OemInfo[iIndex].pszIniKeyNameOriginal, szSourceFile, g_App.szOpkWizIniFile);

            // Create the target filename in a generic way.
            // For example, "%WINDIR%\System32\<LocalFileName>"
            lstrcpyn(szTargetFile, ENV_WINDIR_SYS32,AS(szTargetFile)); // %WINDIR%\System32
            AddPathN(szTargetFile, OemInfo[iIndex].pszLocalFileName,AS(szTargetFile));
            AppendCorrectExtension(iIndex, szTargetFile, szSourceFile);
            
            // Save the local filename in WinBom.Ini. This is used by factory.exe
            WritePrivateProfileString(INI_SEC_OEMLINK, OemInfo[iIndex].pszIniKeyNameLocal, szTargetFile, g_App.szWinBomIniFile);
        }
        else
        {
            szSourceFile[0] = NULLCHR;
            GetDlgItemText(hwnd, OemInfo[iIndex].idDlgItemEdit, szSourceFile, STRSIZE(szSourceFile));
            AppendCorrectExtension(iIndex, szTargetFile, szSourceFile);
            
            //Delete the local files.
            DeleteFile(szTargetFile);
            
            // Remove the Source path!
            //
            WritePrivateProfileString(INI_SEC_OEMLINK, OemInfo[iIndex].pszIniKeyNameOriginal, NULL, g_App.szOpkWizIniFile);
            //
            // Make the edit controls blank!
            //
            SetDlgItemText(hwnd, OemInfo[iIndex].idDlgItemEdit, NULLSTR);
            //
            // Remove the local filenames from Ini files.
            WritePrivateProfileString(INI_SEC_OEMLINK, OemInfo[iIndex].pszIniKeyNameLocal, NULL, g_App.szWinBomIniFile);
        }
    }
    return TRUE;
}

static void EnableControls(HWND hwnd, UINT uId, BOOL fEnable)
{
    switch ( uId )
    {
        case IDC_OEMLINK_CHECK:
            {
                int iIndex;
                for(iIndex = 0; iIndex < ARRAYSIZE(OemInfo); iIndex++)
                {
                    //Enable/Disable the Static control.
                    EnableWindow(GetDlgItem(hwnd, OemInfo[iIndex].idDlgItemStatic), fEnable);
                    //Enable/Disable the Edit control.
                    EnableWindow(GetDlgItem(hwnd, OemInfo[iIndex].idDlgItemEdit), fEnable);
                    //Enable/Disable the Push Button control.
                    EnableWindow(GetDlgItem(hwnd, OemInfo[iIndex].idDlgItemButton), fEnable);
                }
                //Enable disable the Oem Link Text static control
                EnableWindow(GetDlgItem(hwnd, IDC_OEMLINK_STATIC_TEXT), fEnable);
                //Enable/Disable the Edit control.
                EnableWindow(GetDlgItem(hwnd, IDC_OEM_LINK_TEXT), fEnable);
                //Enable disable the Oem Link Infotip Text static control
                EnableWindow(GetDlgItem(hwnd, IDC_OEMLINK_STATIC_INFOTIP), fEnable);
                //Enable/Disable the oem link Infotip Edit control.
                EnableWindow(GetDlgItem(hwnd, IDC_OEM_LINK_INFOTIP), fEnable);
            }
            break;
    }
}

//Given the id of a Pushbutton in our dlg, get the index of the item in our OemInfo struct
static int GetIndexOfPushButton(int id)
{
    int iIndex;

    for(iIndex = 0; iIndex < ARRAYSIZE(OemInfo); iIndex++)
    {
        if(id == OemInfo[iIndex].idDlgItemButton)
            return iIndex;
    }

    return -1; //Error!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\oobecust.c ===
/****************************************************************************\

    OOBECUST.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "OOBE customization" wizard page.

    03/99 - Added by PVSWAMI

    06/99 - Jason Cohen (JCOHEN)
        Updated this source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define INI_SEC_BRANDING        _T("Branding")
#define INI_KEY_OEMNAME         _T("OEMName")
#define INI_KEY_OEMLOGO         _T("OEMLogo")

#define DIR_IMAGES              DIR_OEM_OOBE _T("\\IMAGES")
#define FILE_WATERMARK          _T("watermrk.gif")
#define FILE_LOGO               _T("oemlogo.gif")


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND hwnd);
static void EnableControls(HWND hwnd, UINT uId, BOOL fEnable);


//
// External Function(s):
//

LRESULT CALLBACK OobeCustDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_OEMCUST;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
                    
                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);


                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szLocal[MAX_PATH]       = NULLSTR,
            szSource[MAX_PATH]      = NULLSTR,
            szPathBuffer[MAX_PATH]  = NULLSTR;
    LPTSTR  lpFilePart              = NULL;

    // Populate the OEM name.
    //
    szSource[0] = NULLCHR;
    if ( !GET_FLAG(OPK_MAINTMODE) )
        GetPrivateProfileString(INI_SEC_GENERAL, INI_KEY_MANUFACT, NULLSTR, szSource, AS(szSource), g_App.szOemInfoIniFile);
    GetPrivateProfileString(INI_SEC_BRANDING, INI_KEY_OEMNAME, szSource, szSource, AS(szSource), GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile);
    SendDlgItemMessage(hwnd, IDC_MANF_NAME, EM_LIMITTEXT, AS(szSource) - 1, 0);
    SetDlgItemText(hwnd, IDC_MANF_NAME, szSource);


    //
    // Take care of the OOBE watermark file.
    //

    // Should always look for the source file name.
    //
    szSource[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_OEMCUST, INI_KEY_LOGO1, NULLSTR, szSource, AS(szSource), g_App.szOpkWizIniFile);

    // Now figure out the local file name.
    //
    lstrcpyn(szLocal, g_App.szTempDir,AS(szLocal));
    AddPathN(szLocal, DIR_IMAGES,AS(szLocal));
    if ( GET_FLAG(OPK_BATCHMODE) )
        CreatePath(szLocal);
    AddPathN(szLocal, FILE_WATERMARK,AS(szLocal));

    // Limit the size of the edit box.
    //
    SendDlgItemMessage(hwnd, IDC_BACKLOGO, EM_LIMITTEXT, MAX_PATH - 1, 0);

    // Check for batch mode and copy the file if we need to.
    //
    if ( GET_FLAG(OPK_BATCHMODE) && szSource[0] && FileExists(szSource) )
        CopyResetFileErr(GetParent(hwnd), szSource, szLocal);

    // Check for the file to decide if we enable the
    // option or not.
    //
    if ( szSource[0] && FileExists(szLocal) )
    {
        CheckDlgButton(hwnd, IDC_CHECK_WATERMARK, TRUE);
        EnableControls(hwnd, IDC_CHECK_WATERMARK, TRUE);
        SetDlgItemText(hwnd, IDC_BACKLOGO, szSource);
    }
    else
        EnableControls(hwnd, IDC_CHECK_WATERMARK, FALSE);


    //
    // Take are of the OOBE logo file.
    //

    // Should always look for the source file name.
    //
    szSource[0] = NULLCHR;
    szLocal[0] = NULLCHR;
    if ( ( GetPrivateProfileString(INI_SEC_OEMCUST, INI_KEY_LOGO2, NULLSTR, szSource, AS(szSource), g_App.szOpkWizIniFile) ) && 
         ( szSource[0] ) && 
         ( GetFullPathName(szSource, AS(szPathBuffer), szPathBuffer, &lpFilePart) ) && 
         ( lpFilePart ) 
       )
    {
        lstrcpyn(szLocal, g_App.szTempDir,AS(szLocal));
        AddPathN(szLocal, DIR_IMAGES,AS(szLocal));
        AddPathN(szLocal, lpFilePart,AS(szLocal));
    }

    // Now figure out the local file name.
    //


    // Limit the size of the edit box.
    //
    SendDlgItemMessage(hwnd, IDC_TOPLOGO, EM_LIMITTEXT, MAX_PATH - 1, 0);

    // Check for batch mode and copy the file if we need to.
    //
    if ( GET_FLAG(OPK_BATCHMODE) && szLocal[0] && FileExists(szSource) )
        CopyResetFileErr(GetParent(hwnd), szSource, szLocal);

    // Check for the file to decide if we enable the
    // option or not.
    //
    if ( szSource[0] && FileExists(szLocal) )
    {
        CheckDlgButton(hwnd, IDC_CHECK_LOGO, TRUE);
        EnableControls(hwnd, IDC_CHECK_LOGO, TRUE);
        SetDlgItemText(hwnd, IDC_TOPLOGO, szSource);
    }
    else
        EnableControls(hwnd, IDC_CHECK_LOGO, FALSE);


    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szFileName[MAX_PATH],
          szOldFile[MAX_PATH];

    switch ( id )
    {
        case IDC_CHECK_WATERMARK:
        case IDC_CHECK_LOGO:
            EnableControls(hwnd, id, IsDlgButtonChecked(hwnd, id) == BST_CHECKED);
            break;

        case IDC_BROWSE1:
        case IDC_BROWSE2:

            szFileName[0] = NULLCHR;
            GetDlgItemText(hwnd, (id == IDC_BROWSE1) ? IDC_BACKLOGO : IDC_TOPLOGO, szFileName, STRSIZE(szFileName));
            lstrcpyn(szOldFile, szFileName, AS(szOldFile));

            if ( BrowseForFile(GetParent(hwnd), IDS_BROWSE, IDS_GIFFILES, IDS_GIF, szFileName, STRSIZE(szFileName), g_App.szBrowseFolder, 0) ) 
            {
                LPTSTR  lpFilePart  = NULL;
                TCHAR   szTargetFile[MAX_PATH],
                        szFilePartBuffer[MAX_PATH]  = NULLSTR;

                // Save the last browse directory.
                //
                if ( GetFullPathName(szFileName, AS(g_App.szBrowseFolder), g_App.szBrowseFolder, &lpFilePart) && g_App.szBrowseFolder[0] && lpFilePart )
                {
                    lstrcpyn(szFilePartBuffer, lpFilePart, AS(szFilePartBuffer));
                    *lpFilePart = NULLCHR;
                }

                // Copy file.
                //
                lstrcpyn(szTargetFile, g_App.szTempDir,AS(szTargetFile));
                AddPathN(szTargetFile, DIR_IMAGES,AS(szTargetFile));
                CreatePath(szTargetFile);
                AddPathN(szTargetFile, (id == IDC_BROWSE1) ? FILE_WATERMARK : szFilePartBuffer, AS(szTargetFile));
                if ( CopyResetFileErr(GetParent(hwnd), szFileName, szTargetFile) )
                {
                    TCHAR szPathBuffer[MAX_PATH] = NULLSTR;

                    SetDlgItemText(hwnd, (id == IDC_BROWSE1) ? IDC_BACKLOGO : IDC_TOPLOGO, szFileName);

                    // Copy was successful, we should remove the old file
                    //
                    if ( ( szOldFile[0] ) &&
                         ( GetFullPathName(szOldFile, AS(szPathBuffer), szPathBuffer, &lpFilePart) ) && 
                         ( lpFilePart ) &&
                         ( lstrcmpi(szFilePartBuffer, lpFilePart) != 0)
                       )
                    {
                        // Get the local path to the old file
                        //
                        lstrcpyn(szOldFile, g_App.szTempDir, AS(szOldFile));
                        AddPathN(szOldFile, DIR_IMAGES, AS(szOldFile));
                        AddPathN(szOldFile, lpFilePart, AS(szOldFile));

                        DeleteFile(szOldFile);
                    }
                }
            }
            break;
    }
}

static BOOL OnNext(HWND hwnd)
{
    TCHAR   szWatermark[MAX_PATH],
            szLogo[MAX_PATH]     = NULLSTR,
            szSourceFile[MAX_PATH]  = NULLSTR,
            szPathBuffer[MAX_PATH]  = NULLSTR;
    BOOL    bSaveWatermark;
    LPTSTR  lpFilePart              = NULL;

    // Prepare the watermark target file name.
    //
    lstrcpyn(szWatermark, g_App.szTempDir,AS(szWatermark));
    AddPathN(szWatermark, DIR_IMAGES,AS(szWatermark));
    AddPathN(szWatermark, FILE_WATERMARK,AS(szWatermark));

    if ( bSaveWatermark = (IsDlgButtonChecked(hwnd, IDC_CHECK_WATERMARK) == BST_CHECKED) )
    {
        // Validation consists of verifying the files they have entered were actually copied.
        //
        szSourceFile[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_BACKLOGO, szSourceFile, AS(szSourceFile));
        if ( !szSourceFile[0] || !FileExists(szWatermark) )
        {
            MsgBox(GetParent(hwnd), szSourceFile[0] ? IDS_NOFILE : IDS_BLANKFILE, IDS_APPNAME, MB_ERRORBOX, szSourceFile);
            SetFocus(GetDlgItem(hwnd, IDC_BROWSE1));
            return FALSE;
        }

        // Save the source path in the batch file.
        //
        WritePrivateProfileString(INI_SEC_OEMCUST, INI_KEY_LOGO1, szSourceFile, g_App.szOpkWizIniFile);
    }

    szSourceFile[0] = NULLCHR;
    szPathBuffer[0] = NULLCHR;

    // Determine what the new filename is
    //
    if ( ( GetDlgItemText(hwnd, IDC_TOPLOGO, szSourceFile, AS(szSourceFile)) ) && 
         ( szSourceFile[0] ) && 
         ( GetFullPathName(szSourceFile, AS(szPathBuffer), szPathBuffer, &lpFilePart) ) && 
         ( lpFilePart ) 
       )
    {
        lstrcpyn(szLogo, g_App.szTempDir, AS(szLogo));
        AddPathN(szLogo, DIR_IMAGES, AS(szLogo));
        AddPathN(szLogo, lpFilePart, AS(szLogo));
    }

    if ( IsDlgButtonChecked(hwnd, IDC_CHECK_LOGO) == BST_CHECKED )
    {
        // Validation consists of verifying the files they have entered were actually copied.
        //
        if ( !szLogo[0] || !FileExists(szLogo) )
        {
            MsgBox(GetParent(hwnd), szSourceFile[0] ? IDS_NOFILE : IDS_BLANKFILE, IDS_APPNAME, MB_ERRORBOX, szSourceFile);
            SetFocus(GetDlgItem(hwnd, IDC_BROWSE2));
            return FALSE;
        }

        // Save the source path in the batch file.
        //
        WritePrivateProfileString(INI_SEC_OEMCUST, INI_KEY_LOGO2, szSourceFile, g_App.szOpkWizIniFile);
        WritePrivateProfileString(INI_SEC_BRANDING, INI_KEY_OEMLOGO, lpFilePart, g_App.szOobeInfoIniFile);
    }
    else
    {
        // Remove the logo and source path.
        //
        if ( szLogo[0] )
        {
            DeleteFile(szLogo);
        }

        WritePrivateProfileString(INI_SEC_OEMCUST, INI_KEY_LOGO2, NULL, g_App.szOpkWizIniFile);
        WritePrivateProfileString(INI_SEC_BRANDING, INI_KEY_OEMLOGO, NULL, g_App.szOobeInfoIniFile);
        SetDlgItemText(hwnd, IDC_TOPLOGO, NULLSTR);
    }

    // Now we want to remove the watermark file if need be (we don't do
    // this above because only want to remove files after we have
    // made it passed all the cases where we can return.
    //
    if ( !bSaveWatermark )
    {
        // Remove the logo and source path.
        //
        DeleteFile(szWatermark);
        WritePrivateProfileString(INI_SEC_OEMCUST, INI_KEY_LOGO1, NULL, g_App.szOpkWizIniFile);
        SetDlgItemText(hwnd, IDC_BACKLOGO, NULLSTR);
    }

    // Save the branding name.
    //
    szSourceFile[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_MANF_NAME, szSourceFile, AS(szSourceFile));
    WritePrivateProfileString(INI_SEC_BRANDING, INI_KEY_OEMNAME, szSourceFile, g_App.szOobeInfoIniFile);
    WritePrivateProfileString(INI_SEC_BRANDING, INI_KEY_OEMNAME, szSourceFile, g_App.szOpkWizIniFile);

    return TRUE;
}

static void EnableControls(HWND hwnd, UINT uId, BOOL fEnable)
{
    switch ( uId )
    {
        case IDC_CHECK_WATERMARK:
            EnableWindow(GetDlgItem(hwnd, IDC_CAPTION_WATERMARK), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_BACKLOGO), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_BROWSE1), fEnable);
            break;

        case IDC_CHECK_LOGO:
            EnableWindow(GetDlgItem(hwnd, IDC_LOGO_CAPTION), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_TOPLOGO), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_BROWSE2), fEnable);
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\pch.c ===
/****************************************************************************\

	PCH.C / OPK Wizard (OPKWIZ.EXE)

	Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

	Source file that includes just the standard includes.

	4/99 - Jason Cohen (JCOHEN)
        Updated this old source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


#include "pch.h"
#include "main.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\oobeusb.c ===
/****************************************************************************\

    OOBEUSB.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "OOBE USB Hardware Detection" wizard page.

    09/99 - Added by A-STELO
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define INI_KEY_USBMOUSE        _T("USBMouse")
#define INI_KEY_USBKEYBOARD     _T("USBKeyboard")
#define FILE_USBMOUSE_HTM       _T("nousbms.htm")   // No USB mouse detected, director
#define FILE_USBKEYBOARD_HTM    _T("nousbkbd.htm")  // No USB keyboard detected, director
#define FILE_USBMSEKEY_HTM      _T("nousbkm.htm")   // No USB mouse/keyboard detected, director
#define FILE_HARDWARE_HTM       _T("oemhw.htm")     // Hardware tutorial
#define INI_SEC_OEMHW           _T("OEMHardwareTutorial")

#define DIR_USB                 DIR_OEM_OOBE _T("\\SETUP")
#define DIR_HARDWARE            DIR_OEM_OOBE _T("\\HTML\\OEMHW")


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND);
static void EnableControls(HWND, UINT);
static BOOL BrowseCopy(HWND hwnd, LPTSTR lpszPath, INT id, BOOL bBatch);


//
// External Function(s):
//

LRESULT CALLBACK OobeUSBDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_OOBEUSB;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szData[MAX_URL]             =NULLSTR,
            szHardwarePath[MAX_PATH]    =NULLSTR;

    // Get information about local usb error files
    //
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_USBERRORFILES, NULLSTR, szData, STRSIZE(szData), g_App.szOpkWizIniFile);

    // If the directory exists, then check the hardware box and populate the directory
    //
    if ( szData[0] )
    {
        CheckDlgButton(hwnd, IDC_USB_HARDWARE, TRUE);
        SetDlgItemText(hwnd, IDC_USB_DIR, szData);

        // Must simulate a copy if this is batch mode.
        //
        if ( GET_FLAG(OPK_BATCHMODE) )
            BrowseCopy(hwnd, szData, IDC_USB_BROWSE, TRUE);
    }

    // Check the USB Mouse detection if specified in oemaudit or opkwiz.inf (batchmode)
    //
    CheckDlgButton(hwnd, IDC_USB_MOUSE, GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_USBMOUSE, 0, GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile) == 1);

    // Check the USB Keyboard detection if specified in oemaudit or opkwiz.inf (batchmode)
    //
    CheckDlgButton(hwnd, IDC_USB_KEYBOARD, GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_USBKEYBOARD, 0, GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile) == 1);

    // If we've checked the hardware detection box, we must enable the proper controls
    //
    EnableControls(hwnd, IDC_USB_HARDWARE);

    // Get the file path to use for the hardware tutorials.
    //
    GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_HARDWARE, NULLSTR, szHardwarePath, STRSIZE(szHardwarePath), g_App.szOpkWizIniFile);

    // Now init the hardware tutorial fields.
    //    
    if ( szHardwarePath[0] )
    {
        CheckDlgButton(hwnd, IDC_HARDWARE_ON, TRUE);
        EnableControls(hwnd, IDC_HARDWARE_ON);
        SetDlgItemText(hwnd, IDC_HARDWARE_DIR, szHardwarePath);

        // Must simulate a copy if this is batch mode.
        //
        if ( GET_FLAG(OPK_BATCHMODE) )
            BrowseCopy(hwnd, szHardwarePath, IDC_HARDWARE_BROWSE, TRUE);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szPath[MAX_PATH];

    switch ( id )
    {
        case IDC_USB_BROWSE:
        case IDC_HARDWARE_BROWSE:

            // Try to use their current folder as the default.
            //
            szPath[0] = NULLCHR;
            GetDlgItemText(hwnd, (id == IDC_USB_BROWSE) ? IDC_USB_DIR : IDC_HARDWARE_DIR, szPath, AS(szPath));

            // If there is no current folder, just use the global browse default.
            //
            if ( szPath[0] == NULLCHR )
                lstrcpyn(szPath, g_App.szBrowseFolder,AS(szPath));

            // Now bring up the browse for folder dialog.
            //
            if ( BrowseForFolder(hwnd, IDS_BROWSEFOLDER, szPath, BIF_RETURNONLYFSDIRS | BIF_EDITBOX | BIF_VALIDATE) )
                BrowseCopy(hwnd, szPath, id, FALSE);
            break;

        case IDC_USB_KEYBOARD:
        case IDC_USB_MOUSE:

            // Check for required directory.
            //
            szPath[0] = NULLCHR;
            GetDlgItemText(hwnd, IDC_USB_DIR, szPath, AS(szPath));
            if ( szPath[0] )
            {
                // Check for required file(s).
                //
                lstrcpyn(szPath, g_App.szTempDir,AS(szPath));
                AddPathN(szPath, DIR_USB,AS(szPath));
                if ( DirectoryExists(szPath) )
                {
                    LPTSTR  lpEnd       = szPath + lstrlen(szPath),
                            lpFileName  = (id == IDC_USB_KEYBOARD) ? FILE_USBKEYBOARD_HTM : FILE_USBMOUSE_HTM;

                    // Check for keyboard or mouse file depending on what was checked.
                    //
                    if ( IsDlgButtonChecked(hwnd, id) == BST_CHECKED )
                    {
                        AddPathN(szPath, lpFileName,AS(szPath));
                        if ( !FileExists(szPath) )
                            MsgBox(GetParent(hwnd), IDS_ERR_USBFILE, IDS_APPNAME, MB_ICONWARNING | MB_OK | MB_APPLMODAL, lpFileName);
                        *lpEnd = NULLCHR;
                    }

                    // Check for mouse/keyboard file.
                    //
                    if ( ( IsDlgButtonChecked(hwnd, IDC_USB_MOUSE) == BST_CHECKED ) &&
                         ( IsDlgButtonChecked(hwnd, IDC_USB_KEYBOARD) == BST_CHECKED ) )
                    {
                        AddPathN(szPath, FILE_USBMSEKEY_HTM,AS(szPath));
                        if ( !FileExists(szPath) )
                            MsgBox(GetParent(hwnd), IDS_ERR_USBFILE, IDS_APPNAME, MB_ICONWARNING | MB_OK | MB_APPLMODAL, FILE_USBMSEKEY_HTM);
                        *lpEnd = NULLCHR;
                    }
                }
            }
            break;

        case IDC_USB_HARDWARE:
        case IDC_HARDWARE_ON:
            EnableControls(hwnd, id);
            break;
    }
}

static BOOL OnNext(HWND hwnd)
{
    TCHAR   szUsbPath[MAX_PATH],
            szHardwarePath[MAX_PATH];
    BOOL    bSaveUsb;

    // Create the path to the directory that needs to be removed, or
    // must exist depending on the option selected.
    //
    lstrcpyn(szUsbPath, g_App.szTempDir,AS(szUsbPath));
    AddPathN(szUsbPath, DIR_USB,AS(szUsbPath));

    // If we are doing a custom USB hardware detection, check for a valid directory.
    //
    if ( bSaveUsb = (IsDlgButtonChecked(hwnd, IDC_USB_HARDWARE) == BST_CHECKED) )
    {
        TCHAR szBuffer[MAX_PATH];

        // One of the two boxes must be checked.
        //
        if ( ( IsDlgButtonChecked(hwnd, IDC_USB_MOUSE) != BST_CHECKED ) &&
             ( IsDlgButtonChecked(hwnd, IDC_USB_KEYBOARD) != BST_CHECKED ) )
        {
            MsgBox(GetParent(hwnd), IDS_ERR_USBHARDWARE, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_USB_HARDWARE));
            return FALSE;
        }

        // Make sure we have a valid target and source directory.
        //
        szBuffer[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_USB_DIR, szBuffer, AS(szBuffer));
        if ( !( szBuffer[0] && DirectoryExists(szUsbPath) ) )
        {
            MsgBox(GetParent(hwnd), IDS_ERR_USBDIR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_USB_BROWSE));
            return FALSE;
        }
    }

    // Create the path to the directory that needs to be removed, or
    // must exist depending on the option selected.
    //
    lstrcpyn(szHardwarePath, g_App.szTempDir,AS(szHardwarePath));
    AddPathN(szHardwarePath, DIR_HARDWARE,AS(szHardwarePath));
    
    // If we are doing a custom hardware tutorial, check for a valid directory.
    //
    if ( IsDlgButtonChecked(hwnd, IDC_HARDWARE_ON) == BST_CHECKED )
    {
        TCHAR szBuffer[MAX_PATH];

        // Make sure we have a valid directory.
        //
        szBuffer[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_HARDWARE_DIR, szBuffer, AS(szBuffer));
        if ( !( szBuffer[0] && DirectoryExists(szHardwarePath) ) )
        {
            MsgBox(GetParent(hwnd), IDS_ERR_HARDWAREDIR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_HARDWARE_BROWSE));
            return FALSE;
        }
    }
    else
    {
        // Remove the files that might be there.
        //
        if ( DirectoryExists(szHardwarePath) )
            DeletePath(szHardwarePath);

        // Clear out the display box so we know the files are
        // all gone now.
        //
        SetDlgItemText(hwnd, IDC_HARDWARE_DIR, NULLSTR);
    }

    // Now we want to remove the USB files if need be (we don't do
    // this above because only want to remove files after we have
    // made it passed all the cases where we can return.
    //
    if ( !bSaveUsb )
    {
        // We used to remove existing files here, but this also removes ISP files so we no longer do this.

        // Clear out the display box so we know the files are
        // all gone now.
        //
        SetDlgItemText(hwnd, IDC_USB_DIR, NULLSTR);
    }

    //
    // USB Section: Write out the path for hardware error files
    //
    szUsbPath[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_USB_DIR, szUsbPath, STRSIZE(szUsbPath));
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_USBERRORFILES, ( IsDlgButtonChecked(hwnd, IDC_USB_HARDWARE) == BST_CHECKED ) ? szUsbPath : NULL, g_App.szOpkWizIniFile);

    // Write out the mouse detection settings
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_USBMOUSE, (((IsDlgButtonChecked(hwnd, IDC_USB_MOUSE) == BST_CHECKED) && ( IsDlgButtonChecked(hwnd, IDC_USB_HARDWARE) == BST_CHECKED )) ? STR_ONE : NULL), g_App.szOobeInfoIniFile);
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_USBMOUSE, (((IsDlgButtonChecked(hwnd, IDC_USB_MOUSE) == BST_CHECKED) && ( IsDlgButtonChecked(hwnd, IDC_USB_HARDWARE) == BST_CHECKED )) ? STR_ONE : NULL), g_App.szOpkWizIniFile);

    // Write out the keyboard detection settings
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_USBKEYBOARD, (((IsDlgButtonChecked(hwnd, IDC_USB_KEYBOARD) == BST_CHECKED) && ( IsDlgButtonChecked(hwnd, IDC_USB_HARDWARE) == BST_CHECKED )) ? STR_ONE : NULL), g_App.szOobeInfoIniFile);  
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_USBKEYBOARD, (((IsDlgButtonChecked(hwnd, IDC_USB_KEYBOARD) == BST_CHECKED) && ( IsDlgButtonChecked(hwnd, IDC_USB_HARDWARE) == BST_CHECKED )) ? STR_ONE : NULL), g_App.szOpkWizIniFile);

    //
    // Hardware Detection: Write the custom hardware string.
    //
    szHardwarePath[0] = NULLCHR;
    GetDlgItemText(hwnd, IDC_HARDWARE_DIR, szHardwarePath, STRSIZE(szHardwarePath));
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_HARDWARE, ( IsDlgButtonChecked(hwnd, IDC_HARDWARE_ON) == BST_CHECKED ) ? szHardwarePath : NULL, g_App.szOpkWizIniFile);

    // Write the hardware bit to the oobe ini file.
    //
    WritePrivateProfileString(INI_SEC_OEMHW, INI_KEY_HARDWARE, ( IsDlgButtonChecked(hwnd, IDC_HARDWARE_ON) == BST_CHECKED ) ? STR_ONE : STR_ZERO, g_App.szOobeInfoIniFile);

    return TRUE;
}

static void EnableControls(HWND hwnd, UINT uId)
{
    BOOL fEnable = ( IsDlgButtonChecked(hwnd, uId) == BST_CHECKED );

    switch ( uId )
    {
        case IDC_USB_HARDWARE:
            EnableWindow(GetDlgItem(hwnd, IDC_USB_CAPTION), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_USB_DIR), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_USB_BROWSE), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_USB_MOUSE), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_USB_KEYBOARD), fEnable);
            break;

        case IDC_HARDWARE_ON:
            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_HARDWARE), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HARDWARE_DIR), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_HARDWARE_BROWSE), fEnable);
            break;
    }
}

static BOOL BrowseCopy(HWND hwnd, LPTSTR lpszPath, INT id, BOOL bBatch)
{
    BOOL    bRet = FALSE;
    TCHAR   szDst[MAX_PATH];
    BOOL    bOk = TRUE;

    // We need to create the path to the destination directory where
    // we are going to copy all the files.
    //
    lstrcpyn(szDst, g_App.szTempDir,AS(szDst));
    AddPathN(szDst, (id == IDC_USB_BROWSE) ? DIR_USB : DIR_HARDWARE,AS(szDst));

    // All these checks only need to happen if we are not copying in batch mode.
    //
    if ( !bBatch )
    {
        LPTSTR  lpEnd;

        // If the pressed OK, save off the path in our last browse folder buffer.
        //
        lstrcpyn(g_App.szBrowseFolder, lpszPath,AS(g_App.szBrowseFolder));

        // Check for required file(s).
        //
        lpEnd = lpszPath + lstrlen(lpszPath);
        if ( id == IDC_HARDWARE_BROWSE )
        {
            AddPath(lpszPath, FILE_HARDWARE_HTM);
            bOk = ( FileExists(lpszPath) || ( MsgBox(GetParent(hwnd), IDS_ERR_HARDWAREFILES, IDS_APPNAME, MB_ICONSTOP | MB_OKCANCEL | MB_APPLMODAL) == IDOK ) );
            *lpEnd = NULLCHR;
        }
        else
        {
            // Check for keyboard file.
            //
            if ( bOk && ( IsDlgButtonChecked(hwnd, IDC_USB_KEYBOARD) == BST_CHECKED ) )
            {
                AddPath(lpszPath, FILE_USBKEYBOARD_HTM);
                bOk = ( FileExists(lpszPath) || ( MsgBox(GetParent(hwnd), IDS_ERR_USBFILE, IDS_APPNAME, MB_ICONSTOP | MB_OKCANCEL | MB_APPLMODAL, FILE_USBKEYBOARD_HTM) == IDOK ) );
                *lpEnd = NULLCHR;
            }

            // If we are doing a usb hardware detection, check for the required file, check for mouse error file.
            //
            if ( bOk && ( IsDlgButtonChecked(hwnd, IDC_USB_MOUSE) == BST_CHECKED ) )
            {
                AddPath(lpszPath, FILE_USBMOUSE_HTM);
                bOk = ( FileExists(lpszPath) || ( MsgBox(GetParent(hwnd), IDS_ERR_USBFILE, IDS_APPNAME, MB_ICONSTOP | MB_OKCANCEL | MB_APPLMODAL, FILE_USBMOUSE_HTM) == IDOK ) );
                *lpEnd = NULLCHR;
            }

            // Check for mouse/keyboard file.
            //
            if ( ( bOk ) &&
                 ( IsDlgButtonChecked(hwnd, IDC_USB_MOUSE) == BST_CHECKED ) &&
                 ( IsDlgButtonChecked(hwnd, IDC_USB_KEYBOARD) == BST_CHECKED ) )
            {
                AddPath(lpszPath, FILE_USBMSEKEY_HTM);
                bOk = ( FileExists(lpszPath) || ( MsgBox(GetParent(hwnd), IDS_ERR_USBFILE, IDS_APPNAME, MB_ICONSTOP | MB_OKCANCEL | MB_APPLMODAL, FILE_USBMSEKEY_HTM) == IDOK ) );
                *lpEnd = NULLCHR;
            }
        }
    }

    if ( bOk )
    {
        // We used to remove existing OobeUSB files here, but this also removes ISP files so we no longer do this.
        // Hardware is in unique directory, so it is OK to delete existing files for it
        if (id != IDC_USB_BROWSE) {
            if ( DirectoryExists(szDst) )
                DeletePath(szDst);
        }

        // Now try to copy all the new files over.
        //
        if ( !CopyDirectoryDialog(g_App.hInstance, hwnd, lpszPath, szDst) )
        {
            DeletePath(szDst);
            MsgBox(GetParent(hwnd), IDS_ERR_COPYINGFILES, IDS_APPNAME, MB_ERRORBOX, szDst[0], lpszPath);
            *lpszPath = NULLCHR;
        }
        else
            bRet = TRUE;

        // Reset the path display box.
        //
        SetDlgItemText(hwnd, (id == IDC_USB_BROWSE) ? IDC_USB_DIR : IDC_HARDWARE_DIR, lpszPath);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\pch.h ===
/****************************************************************************\

	PCH.H / OPK Wizard (OPKWIZ.EXE)

	Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

	Pre-compiled header file for the OPK Wizard.  Include file for standard
    system include files, or project specific include files that are used
    frequently, but are changed infrequently

	4/99 - Jason Cohen (JCOHEN)
        Updated this new header file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


#ifndef _PCH_H_
#define _PCH_H_


//
// Pre-include Defined Value(s):
//

// Needed to run on OSR2.
//
//#define _WIN32_IE 0x0400

// Better type checking for windows
//
#define STRICT

//
// Include File(s):
//

// Standard include files (that are commonly used)
//
#include <opklib.h>

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <shlobj.h>
#include <lm.h>

// Project include files (that don't change often)
//
#include "allres.h"
#include "jcohen.h"
#include "main.h"


#endif // _PCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\oeminfo.c ===
/****************************************************************************\

    OEMINFO.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "OEM info" wizard page.

    5/99 - Jason Cohen (JCOHEN)
        Updated this old source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define INI_SEC_SUPPORT         _T("Support Information")
#define INI_SEC_NAUGHTY         _T("IllegalWords")
#define INI_SEC_USERDATA        _T("UserData")
#define INI_KEY_MODELNAME       _T("Model")
#define INI_KEY_SUPLINE         INI_KEY_FILELINE

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static BOOL ValidData(HWND);
static void SaveData(HWND);
LONG CALLBACK SupportEditWndProc(HWND, UINT, WPARAM, LPARAM);

//
// External Function(s):
//

LRESULT CALLBACK OemInfoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
            
        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( ValidData(hwnd) )
                    {
                        SaveData(hwnd);

                        // If we are currently in the wizard, press the finish button
                        //
                        if ( GET_FLAG(OPK_ACTIVEWIZ) )
                            WIZ_PRESS(hwnd, PSBTN_FINISH);
                    }
                    else
                        WIZ_FAIL(hwnd);
                    break;
                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_OEMINFO;

                    WIZ_BUTTONS(hwnd, GET_FLAG(OPK_OEM) ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    // We should continue on to maint. wizard if in maintenance mode
                    //
                    //if ( GET_FLAG(OPK_MAINTMODE) )
                    //    WIZ_PRESS(hwnd, PSBTN_NEXT);

                    break;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    HWND    hwndEdit = GetDlgItem(hwnd, IDC_INFO_SUPPORT);
    TCHAR   szBuf[MAX_URL],
            szKeyBuf[32];
    INT     uIndex = 1;
    BOOL    bNotDone;
    HRESULT hrPrintf;

    //
    // Get stuff from the oeminfo.ini/opkwiz.inf file.
    //

    // OEM name.
    //
    szBuf[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_GENERAL, INI_KEY_MANUFACT, NULLSTR, szBuf, MAX_INFOLEN, GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOemInfoIniFile);
    SetWindowText(GetDlgItem(hwnd, IDC_INFO_OEM), szBuf);
    SendDlgItemMessage(hwnd, IDC_INFO_OEM, EM_LIMITTEXT, MAX_INFOLEN - 1, 0L);

    // Model name.
    //
    szBuf[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_GENERAL, INI_KEY_MODELNAME, NULLSTR, szBuf, MAX_INFOLEN, GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOemInfoIniFile);
    SetWindowText(GetDlgItem(hwnd, IDC_INFO_MODEL), szBuf);
    SendDlgItemMessage(hwnd, IDC_INFO_MODEL, EM_LIMITTEXT, MAX_INFOLEN - 1, 0L);

    // Support info.
    //
    // This exists in the section as:
    //
    // Line1="df"
    // Line2="dfvkl"
    //
    // Note we read lines in order (Line1, Line2...) and stop as soon
    // as we see a gap. This means we ingnore the rest of the info if they
    // have skipped a line (blanks are ok, i mean a line not existing).
    //
    do
    {
        // Get the line from the ini file.
        //
        hrPrintf=StringCchPrintf(szKeyBuf, AS(szKeyBuf), INI_KEY_SUPLINE, uIndex++);
        szBuf[0] = NULLCHR;
        GetPrivateProfileString(INI_SEC_SUPPORT, szKeyBuf, INI_VAL_DUMMY, szBuf, STRSIZE(szBuf), GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOemInfoIniFile);

        // Make sure the line existed in the ini file.
        //
        if ( bNotDone = (lstrcmp(szBuf, INI_VAL_DUMMY) != 0) )
        {
            // This is to fix a bug.  We used to add a blank line everytime to
            // the support text when we ran in mantenance mode.
            //
            // If this isn't he first line we have added, add a CRLF first.
            //
            if ( uIndex > 2 )
            {
                SendMessage(hwndEdit, EM_SETSEL, (WPARAM) -1, 0L);
                SendMessage(hwndEdit, EM_REPLACESEL, FALSE, (LPARAM) STR_CRLF);
            }
                // Now tack this line we read in to the end of the edit control.
            //
            SendMessage(hwndEdit, EM_SETSEL, (WPARAM) -1, 0L);
            SendMessage(hwndEdit, EM_REPLACESEL, FALSE, (LPARAM) szBuf);
        }
    }
    while ( bNotDone );

    // Replace the wndproc for the edit box.
    //
    SupportEditWndProc(GetDlgItem(hwnd, IDC_INFO_SUPPORT), WM_SUBWNDPROC, 0, 0L);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static BOOL ValidData(HWND hwnd)
{
    TCHAR       szString[512]   = NULLSTR;
    HINF        hInf            = NULL;
    INFCONTEXT  InfContext;
    BOOL        bOk             = TRUE,
                bRet;
    HWND        hwndOem         = GetDlgItem(hwnd, IDC_INFO_OEM),
                hwndEdit        = GetDlgItem(hwnd, IDC_INFO_SUPPORT);
    LPTSTR      lpszText,
                lpBad;
    DWORD       dwBuffer;

    // Check to make sure the OEM name is filled in.
    //
    if ( GetWindowTextLength(hwndOem) == 0 )
    {
        MsgBox(GetParent(hwnd), IDS_ERROEMNAME, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(hwndOem);
        return FALSE;
    }

    // Check to make sure there is support information.
    //
    if ( GetWindowTextLength(hwndEdit) == 0 )
    {
        MsgBox(GetParent(hwnd), IDS_ERROEMSUPPORT, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(hwndEdit);
        return FALSE;
    }
    
    //
    // Now make sure they don't use any naughty words.
    //

    // Get the text from the edit control.
    //
    
    dwBuffer = ((GetWindowTextLength(hwndEdit) + 1) * sizeof(TCHAR));
    if ( (lpszText = MALLOC(dwBuffer)) == NULL )
        return bOk;
    GetWindowText(hwndEdit, lpszText, dwBuffer);

    // Open the opkinput file
    //
    if ((hInf = SetupOpenInfFile(g_App.szOpkInputInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL)))
    {
        // Loop through all the naughty words and check for each.
        //
        for ( bRet = SetupFindFirstLine(hInf, INI_SEC_NAUGHTY, NULL, &InfContext);
              bRet && bOk;
              bRet = SetupFindNextLine(&InfContext, &InfContext) )
        {
            // Make sure we set the line back to nothing
            //
            szString[0] = NULLCHR;

            // Get the naughty word and compare to window text
            //
            if ( ( SetupGetStringField(&InfContext, 1, szString, AS(szString), NULL) ) &&
                 ( lpBad = StrStrI(lpszText, szString) ) )
            {
                // We found a bad string.
                //
                MsgBox(GetParent(hwnd), IDS_ERR_NAUGHTY, IDS_ERR_NAUGHTY_TITLE, MB_ERRORBOX, szString);

                // Select the bad text in the edit control.
                //
                dwBuffer = (DWORD) (lpBad - lpszText);
                SetFocus(hwndEdit);
                PostMessage(hwndEdit, WM_SETSEL, (WPARAM) dwBuffer, (LPARAM) dwBuffer + lstrlen(szString));
                PostMessage(hwndEdit, EM_SCROLLCARET, 0, 0L);

                // Return false.
                //
                bOk = FALSE;
            }
                  
        }

        SetupCloseInfFile(hInf);
    }
    
    // Free our edit text buffer.
    //
    FREE(lpszText);

    // Return our search result.
    //
    return bOk;
}

static void SaveData(HWND hwnd)
{
    TCHAR   szBuf[MAX_URL],
            szKeyBuf[32];
    UINT    uCount,
            uIndex,
            uNumBytes;
    HRESULT hrPrintf;

    //
    // Save the stuff to the oeminfo.ini/opkwiz.ini file.
    //

    // OEM name.
    //
    GetDlgItemText(hwnd, IDC_INFO_OEM, szBuf, MAX_INFOLEN);
    WritePrivateProfileString(INI_SEC_GENERAL, INI_KEY_MANUFACT, szBuf,g_App.szOemInfoIniFile);
    WritePrivateProfileString(INI_SEC_GENERAL, INI_KEY_MANUFACT, szBuf,g_App.szOpkWizIniFile);

    // Store away the Manufacturer name for IE Branding page
    //
    lstrcpyn(g_App.szManufacturer, szBuf[0] ? szBuf : NULLSTR, AS(g_App.szManufacturer));

    // Model name.
    //
    GetDlgItemText(hwnd, IDC_INFO_MODEL, szBuf, MAX_INFOLEN);
    WritePrivateProfileString(INI_SEC_GENERAL, INI_KEY_MODELNAME, szBuf, g_App.szOemInfoIniFile);
    WritePrivateProfileString(INI_SEC_GENERAL, INI_KEY_MODELNAME, szBuf, g_App.szOpkWizIniFile);


    // If there isn't already a config name, use the model name as the default.
    //
    if ( g_App.szConfigName[0] == NULLCHR )
        lstrcpyn(g_App.szConfigName, szBuf, AS(g_App.szConfigName));
    
    // Support info.
    //
    // All this nonsense below does:
    //
    // 1. Reads a line from the edit.
    // 2. Prepends LineX=" to it (note the quote).
    // 3. Adds a " and null terminator onto the end (the API
    //    used here does NOT null terminate the string).
    // 4. Writes the line to the approp. section.
    //
    // First remove the section, setup the buffer, and find out
    // many lines we are going to have to read in.
    //
    WritePrivateProfileString(INI_SEC_SUPPORT, NULL, NULL, g_App.szOemInfoIniFile);
    WritePrivateProfileString(INI_SEC_SUPPORT, NULL, NULL, g_App.szOpkWizIniFile);
    szBuf[0] = CHR_QUOTE;
    uCount = (UINT) SendDlgItemMessage(hwnd, IDC_INFO_SUPPORT, EM_GETLINECOUNT, 0, 0);
    for ( uIndex = 0; uIndex < uCount; uIndex++ )
    {
        // Setup how big the buffer is.
        //
        *((WORD *) (szBuf + 1)) = STRSIZE(szBuf);

        // Read a line in from the edit box.
        //
        uNumBytes = (UINT) SendDlgItemMessage(hwnd, IDC_INFO_SUPPORT, EM_GETLINE, (WPARAM) uIndex, (LPARAM) (szBuf + 1));

        // Add the trailing quote and the null terminator.
        //
        *(szBuf + uNumBytes + 1) = CHR_QUOTE;
        *(szBuf + uNumBytes + 2) = NULLCHR;

        // Now write it to the ini file.
        //
        hrPrintf=StringCchPrintf(szKeyBuf, AS(szKeyBuf), INI_KEY_SUPLINE, uIndex + 1);
        WritePrivateProfileString(INI_SEC_SUPPORT, szKeyBuf, szBuf, g_App.szOemInfoIniFile);
        WritePrivateProfileString(INI_SEC_SUPPORT, szKeyBuf, szBuf, g_App.szOpkWizIniFile);
    }
}

LONG CALLBACK SupportEditWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static FARPROC lpfnOldProc = NULL;

    switch ( msg )
    {
        case EM_SETSEL:
            wParam = lParam = 0;
            PostMessage(hwnd, EM_SCROLLCARET, 0, 0L);
            break;

        case WM_CHAR:
            if ( wParam == KEY_ESC )
                WIZ_PRESS(GetParent(hwnd), PSBTN_CANCEL);
            break;

        case WM_SUBWNDPROC:
            lpfnOldProc = (FARPROC) GetWindowLongPtr(hwnd, GWLP_WNDPROC);
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)SupportEditWndProc);
            return 1;

        case WM_SETSEL:
            msg = EM_SETSEL;
            break;
    }

    if ( lpfnOldProc )
        return (LONG) CallWindowProc((WNDPROC) lpfnOldProc, hwnd, msg, wParam, lParam);
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by oem.rc
//
#define IDI_SHARE                       18001
#define IDD_DETMODULE                   18001
#define IDD_APPINSTALL                  18002
#define IDD_APP                         18003
#define IDR_LVRCLICK                    18004
#define IDD_OEMINFO                     18005
#define IDD_LOGO                        18006
#define IDD_SCREENS                     18007
#define IDD_MEDIA                       18009
#define IDD_PAGEEDIT                    18011
#define IDD_LICENSE                     18012
#define IDD_MODE                        18013
#define IDD_OOBECUST                    18014
#define IDD_BRTOOLBAR                   18016
#define IDD_CUSTICON                    18017
#define IDD_DETAILS                     18018
#define IDI_OPKSETUP                    18020
#define IDI_USERAPP                     18021
#define IDD_HELP                        18023
#define IDD_OOBEUSB                     18024
#define IDD_SCREENSTWO                  18025
#define IDI_ARROWUP                     18026
#define IDI_ARROWDN                     18027
#define IDD_HELPCENT                    18028
#define IDD_MAINT                       18029
#define IDR_MAIN_OEM                    18031
#define IDD_SAVEAS                      18032
#define IDD_ISP                         18034
#define IDD_OEMCUST                     18035
#define IDD_CONFIG                      18036
#define IDD_CREATE                      18037
#define IDD_COMPLETE                    18038
#define IDB_CHECKS                      18041
#define IDC_LIST_MODULE                 18042
#define IDD_BTITLE                      18044
#define IDD_STARTSEARCH                 18045
#define IDD_FAVORITES                   18046
#define IDC_FAC_SELALL                  18048
#define IDC_FAC_SELNONE                 18049
#define IDD_CATEGORYPOPUP               18050
#define IDC_USR_SELALL                  18051
#define IDC_USR_SELNONE                 18052
#define IDC_BOLD                        18053
#define IDD_BTOOLBARS                   18054
#define IDC_APPLIST                     18055
#define IDC_APPINST_ADD                 18056
#define IDC_APPINST_EDIT                18057
#define IDC_APPINST_DELETE              18058
#define IDC_APP_NAME                    18059
#define IDC_APP_PATH                    18060
#define IDC_FAVBROWSE                   18061
#define IDC_INFO_OEM                    18062
#define IDC_INFO_MODEL                  18063
#define IDC_LOGO_CPL                    18064
#define IDC_LOGO_CPLLOC                 18065
#define IDC_LOGO_CPLBROWSE              18066
#define IDC_SCREEN_REGIONAL             18067
#define IDC_SCREEN_TIMEZONE             18068
#define IDC_LOGO_SCPL                   18069
#define IDC_NAME_EDIT                   18070
#define IDC_BAK_COMPANION               18071
#define IDC_BAK_FLOPPY                  18072
#define IDC_BAK_CD                      18073
#define IDC_BAK_CABS                    18074
#define IDC_BAK_FULL                    18075
#define IDC_BAK_BOOT                    18076
#define IDC_BAK_USER                    18077
#define IDC_BAK_CREATE                  18078
#define IDC_BAK_KIND                    18079
#define IDC_BAK_FULL2                   18080
#define IDC_BAK_OTHER                   18081
#define IDC_BAK_GB1                     18082
#define IDC_BAK_MSCSD_TEXT              18083
#define IDC_DETMOD_COL1                 18084
#define IDC_DETMOD_COL2                 18085
#define IDC_GB_USR                      18086
#define IDC_EDIT1                       18087
#define IDC_BACKLOGO                    18088
#define IDC_TOPLOGO                     18090
#define IDC_TEXT_OEM                    18091
#define IDC_TEXT_MODEL                  18092
#define IDC_TEXT_SUPPORT                18093
#define IDC_PID                         18094
#define IDC_OEMINFO_DESC                18094
#define IDC_INFO_SUPPORT                18095
#define IDC_PRODUCTKEY_DESC             18095
#define IDC_STANDARD                    18096
#define IDC_EXPRESS                     18097
#define IDC_ADVANCED                    18098
#define IDC_HARDWARE_ON                 18105
#define IDC_IME_NO                      18106
#define IDC_IME_CUSTOM                  18107
#define IDC_BRANDING_CHK                18109
#define IDC_HARDWARE_BROWSE             18110
#define IDC_STATIC_IME                  18111
#define IDC_STATIC_HARDWARE             18112
#define IDC_IME_DIR                     18113
#define IDC_HARDWARE_DIR                18114
#define IDC_IME_BROWSE                  18115
#define IDC_BRANDING_DIR                18116
#define IDC_BRANDING_BROWSE             18117
#define IDC_BRANDING_CAPTION            18118
#define IDC_MSNINTACCESS                18119
#define IDC_OFFERNOISP                  18120
#define IDC_PRECONFIGURE                18121
#define IDC_PRECACHED                   18122
#define IDC_BROWSE1                     18124
#define IDC_ISP2_DIR                    18125
#define IDC_ISP2_BROWSE                 18126
#define IDC_OEMCUST_ON                  18127
#define IDC_PRECONFIG_BROWSE            18128
#define IDC_ISP2_TEXT                   18129
#define IDC_OEMCUST_TEXT                18130
#define IDC_OEMCUST_DIR                 18131
#define IDC_OEMCUST_BROWSE              18132
#define IDC_BROWSE2                     18133
#define IDC_MANF_NAME                   18134
#define IDC_ISP2_CHECK                  18135
#define IDC_TITLE                       18140
#define IDC_BITMAP                      18141
#define IDC_BROWSEFAV                   18142
#define IDC_BITMAP2                     18143
#define IDC_ADDFOLDER                   18144
#define IDC_REMOVE                      18145
#define IDC_ADDURL                      18146
#define IDC_TESTURL                     18147
#define IDC_FAVS                        18148
#define IDC_EDIT                        18149
#define IDC_SMALLBMBUTTON               18151
#define IDC_HOMEPAGE                    18158
#define IDC_SEARCHPAGE                  18159
#define IDC_HELPPAGE                    18160
#define IDC_HPTEST                      18161
#define IDC_SPTEST                      18162
#define IDC_HLPTEST                     18163
#define IDC_HPSTATIC                    18164
#define IDC_SPSTATIC                    18165
#define IDC_HLPSTATIC                   18166
#define IDC_LARGEBMBUTTON               18167
#define IDC_BROWSE3                     18168
#define IDC_NAME                        18171
#define IDC_URL                         18172
#define IDC_DICON                       18173
#define IDC_GRAYSCALE                   18174
#define IDC_CONFIGS_LIST                18175
#define IDC_NEW                         18176
#define IDC_EXISTING                    18177
#define IDC_CONFIGS_TEXT                18178
#define IDC_PROGRESS                    18179
#define IDC_NAME_TEXT                   18180
#define IDC_ADVANCED_TEXT               18181
#define IDC_ACCEPT                      18183
#define IDC_DONT                        18184
#define IDC_EULA_TEXT                   18185
#define IDC_HELPCMD                     18186
#define IDC_HELPPARAM1                  18187
#define IDC_HELPPARAM2                  18188
#define IDC_HELPPARAM3                  18189
#define IDC_HELPPARAM4                  18190
#define IDC_LOGO_CAPTION                18191
#define IDC_HELPPARAM7                  18192
#define IDC_USB_HARDWARE                18193
#define IDC_HELPPARAM8                  18194
#define IDC_USB_MOUSE                   18195
#define IDC_USB_KEYBOARD                18196
#define IDC_USB_CAPTION                 18197
#define IDC_USB_DIR                     18198
#define IDC_CAPTION_WATERMARK           18199
#define IDC_USB_BROWSE                  18200
#define IDC_EXPRESS_TEXT                18201
#define IDC_APP_UP                      18202
#define IDC_APP_DOWN                    18203
#define IDC_STATIC_URL                  18204
#define IDC_STATIC_ICON                 18205
#define IDC_PRECONFIG_TEXT              18206
#define IDC_PRECONFIG_DIR               18207
#define IDC_HELP_CHK                    18208
#define IDC_PRECONFIG_LABEL             18208
#define IDC_SUPPORT_CHK                 18209
#define IDC_HELP_CAPTION                18210
#define IDC_SUPPORT_CAPTION             18211
#define IDC_HELP_DIR                    18212
#define IDC_SUPPORT_DIR                 18213
#define IDC_HELP_BROWSE                 18214
#define IDC_SUPPORT_BROWSE              18215
#define IDC_PRODUCT_KEY1                18216
#define IDC_PRODUCT_KEY2                18217
#define IDC_PRODUCT_KEY3                18218
#define IDC_PRODUCT_KEY4                18219
#define IDC_PRODUCT_KEY5                18220
#define IDC_DASH1                       18221
#define IDC_DASH2                       18222
#define IDC_DASH3                       18223
#define IDC_DASH4                       18224
#define IDC_PAGES                       18225
#define ID_MAINT_NEXT                   18226
#define ID_MAINT_BACK                   18227
#define IDC_LANG_LIST                   18228
#define IDS_ERR_WIZBAD                  18230
#define IDS_APPNAME                     18231
#define IDS_OUTOFMEM                    18232
#define IDS_MISSINGFILE                 18233
#define IDS_MISSSECT                    18234
#define IDS_ERR_OPENFILE                18235
#define IDS_ERR_READFILE                18236
#define IDS_PREINSTALL_NAME             18237
#define IDS_PREINSTALL_COMMAND          18238
#define IDS_PREINSTALL_FACTORY          18239
#define IDS_PREINSTALL_USER             18240
#define IDS_YES                         18241
#define IDS_NO                          18242
#define IDS_PREINSTALL_AUDIT            18243
#define IDS_BLANKNAME                   18244
#define IDS_BLANKPATH                   18245
#define IDS_ERR_NOSECTION               18246
#define IDS_BROWSE                      18247
#define IDS_BMPFILTER                   18248
#define IDS_NOFILE                      18249
#define IDS_ERROEMNAME                  18250
#define IDS_ERROEMSUPPORT               18251
#define IDS_ERR_BADCMDLINE              18252
#define IDS_HTMLFILTER                  18253
#define IDS_FORCEDET                    18254
#define IDS_ERR_BADCONFIG               18255
#define IDS_DIREXISTS                   18256
#define IDS_NOCONFIG                    18257
#define IDS_QUERYCANCEL                 18258
#define IDS_ERR_BADBATCH                18259
#define IDS_ERR_BADINS                  18260
#define IDS_DUPNAME                     18261
#define IDS_ERR_STAMPFAIL               18262
#define IDS_ERR_STAMPEXIT               18263
#define IDS_ERR_STAMPCREATE             18264
#define IDS_ICO_FILTER                  18265
#define IDS_ERR_NAUGHTY                 18266
#define IDS_ERR_NAUGHTY_TITLE           18267
#define IDS_NDA_CORRUPT1                18268
#define IDS_NDA_CORRUPT2                18269
#define IDS_PREINSTALL_DDE              18270
#define IDS_NOMOUSEPATH                 18271
#define IDS_CANNOTSAVE                  18272
#define IDD_FAVPOPUP                    18273
#define IDD_LANG                        18274
#define IDS_BROWSEFOLDER                18275
#define IDS_ERR_HARDWAREDIR             18276
#define IDS_ERR_MOUSEDIR                18277
#define IDS_ERR_HARDWAREFILES           18278
#define IDS_ERR_MOUSEFILES              18279
#define IDS_ERR_LFN                     18280
#define IDS_ERR_DUPFILE                 18281
#define IDS_ERR_COPY                    18282
#define IDS_OPKWIZ                      18283
#define IDS_ERR_OEMCUSTFILE             18284
#define IDS_ERR_OEMCUSTDIR              18285
#define IDS_ICONFILES                   18286
#define IDS_GIFFILES                    18287
#define IDS_ERR_ISPDIR                  18288
#define IDS_ERR_ISPFILES2               18289
#define IDS_ERR_REGDATA                 18290
#define IDS_ERR_INVALIDDIR              18293
#define IDS_CABFILTER                   18295
#define IDS_COMPONENTFILTER             18296
#define IDS_RECOMMEND                   18297
#define IDS_CHANNELMASK                 18298
#define IDS_EXEFILES                    18299
#define IDS_MUST                        18300
#define IDS_IEDESTDIR                   18301
#define IDS_BIG_FONT                    18302
#define IDS_BIG_SIZE                    18303
#define IDS_BMP                         18304
#define IDS_CAB                         18305
#define IDS_FAVORITES                   18306
#define IDS_BLANKFILE                   18307
#define IDS_EXE                         18308
#define IDS_ICO                         18309
#define IDS_GIF                         18310
#define IDS_LOSECHANGES                 18311
#define IDS_LOSENEW                     18312
#define IDS_LOSEOLD                     18313
#define IDS_ERR_INVCMD                  18314
#define IDS_ERR_IE5                     18315
#define IDS_ERR_IEAKWIZ                 18316
#define IDS_ERR_KEYCODE                 18317
#define IDS_ERR_USBDIR                  18318
#define IDS_ERR_USBFILE                 18319
#define IDS_ERR_USBHARDWARE             18320
#define IDS_ERR_FAVURL                  18321
#define IDS_ERR_DUP                     18322
#define IDS_LINKS                       18323
#define IDS_ERR_CHILDEXISTS             18324
#define IDS_ERR_NOSEL                   18325
#define IDS_ERR_ROOT                    18326
#define IDS_INSTFILES                   18327
#define IDS_HTM                         18328
#define IDE_TITLE                       18330
#define IDE_TOOLBARBMP                  18331
#define IDC_BROWSETBB                   18332
#define IDC_TOOLBARBMP                  18333
#define IDC_STARTPAGE                   18334
#define IDC_SEARCHPAGE2                 18335
#define IDC_CUSTOMSUPPORT               18336
#define IDC_CHANNELBITMAP2              18346
#define IDC_BROWSECHBMP2                18347
#define IDC_CHANNELICON2                18348
#define IDC_BROWSECHICO2                18349
#define IDE_CATEGORYTITLE               18351
#define IDC_CATEGORYHTML                18352
#define IDC_BROWSECATHTML               18353
#define IDC_TITLE_TXT                   18354
#define IDC_TOOLBARBMP_TXT              18355
#define IDC_BTOOLBARLIST                18356
#define IDC_ADDBTOOLBAR                 18357
#define IDC_REMOVEBTOOLBAR              18358
#define IDC_EDITBTOOLBAR                18359
#define IDC_BUTTONSTATE                 18360
#define IDC_FAVNAME                     18361
#define IDC_FAVURL                      18362
#define IDC_FAVICON                     18363
#define IDS_TITLE_PREFIX                18364
#define IDS_OETITLE_PREFIX              18365
#define IDS_ERR_IMEDIR                  18366
#define IDS_ERR_IMEFILES                18367
#define IDS_HELP_ERROR                  18368
#define IDS_SUPPORT_ERROR               18369
#define IDS_BRANDING_ERROR              18370
#define IDS_ERROR_PRODKEY_LEN           18371
#define IDS_ERROR_PRODKEY_INV           18372
#define IDS_USA                         18373
#define IDS_GER                         18374
#define IDS_DEF_LANG                    18375
#define IDS_ERR_LANGDIR                 18376
#define IDS_ERR_NOLANGDIR               18377
#define IDS_USERCLOSE                   18378
#define IDS_DLG_GENERAL                 18385
#define IDS_DLG_OOBE                    18386
#define IDS_DLG_IEAK                    18394
#define IDS_NEXT                        18403
#define IDS_FINISH                      18404
#define ID_ADD                          18405
#define ID_DELETE                       18406
#define ID_EDIT                         18407
#define ID_FILE_OPEN                    18409
#define ID_FILE_CLOSE                   18410
#define ID_HELP_CONTENTS                18411
#define ID_HELP_ABOUT                   18412
#define ID_FILE_NEW                     18413
#define ID_FILE_SAVE                    18414
#define ID_FILE_SAVEAS                  18415
#define ID_FILE_EXIT                    18416
#define IDS_DLG_NETWORK                 18417
#define IDS_DLG_ADVANCED                18418
#define IDC_MAINT_TITLE                 18419
#define IDC_MAINT_SUBTITLE              18420
#define ID_TOOLS_SKUS                   18421
#define IDC_SKU_LIST                    18422
#define IDC_ADD                         18423
#define IDC_DELETE                      18424
#define IDC_ADDSKU                      18425
#define IDC_DELSKU                      18426
#define IDC_ADDLANG                     18427
#define IDC_DELLANG                     18428
#define IDC_SKUS                        18429
#define IDC_SKU_NAME                    18430
#define IDD_SKU                         18431
#define IDD_PROGRESS                    18432
#define IDD_LANGSKU                     18433
#define IDD_SKUNAME                     18434
#define IDS_SKU_PRO                     18435
#define IDS_SKU_PER                     18436
#define IDS_SKU_SRV                     18437
#define IDS_SKU_ADV                     18438
#define IDS_SKU_DTC                     18439
#define IDS_ARCH_X86                    18440
#define IDS_ARCH_IA64                   18441
#define IDS_ERR_SKUDIR                  18442
#define IDS_ERR_NOSKU                   18443
#define IDS_DELETESKU                   18444
#define IDS_SKUHEADER                   18445
#define IDS_ERR_INVALIDCONFIG           18446
#define IDS_ERR_BADSOURCE               18447
#define IDS_ERR_BADARCH                 18448
#define IDS_ERR_COPYFAIL                18449
#define IDS_ERR_NOLANGS                 18450
#define IDS_DLG_SKU                     18451
#define IDD_OEMFOLDER                   18452
#define IDD_OEMLINK                     18452
#define IDD_STARTMENU                   18453
#define IDC_PROGRAM_1                   18454
#define IDC_PROGRAM_2                   18455
#define IDC_PROGRAM_3                   18456
#define IDC_OEM_LINK_PATH               18458
#define IDC_OEM_LINK_TEXT               18460
#define IDS_DLG_SHELLSETTINGS           18461
#define IDS_OVERWRITESKU                18462
#define IDC_MAINT_HELP                  18463
#define IDS_ERR_COPYINGFILES            18464
#define IDC_CHECK_LOGO                  18465
#define IDS_RESEAL_FACTORY              18465
#define IDC_CHECK_WATERMARK             18466
#define IDS_RESEAL_OOBE                 18466
#define IDC_RESEAL_COMBO                18467
#define IDS_ERR_NODISTSHARE             18467
#define IDC_RESEAL_TEXT                 18468
#define IDS_ERR_CONFIRMPASSWORD         18468
#define IDC_SHARE_ICON                  18469
#define IDS_ERR_NETSHAREACCESS          18469
#define IDD_SHARE                       18470
#define IDS_ERR_INVALIDSHARE            18470
#define IDC_SHARE_USERNAME              18471
#define IDS_ASK_SHAREFOLDER             18471
#define IDD_ABOUT                       18471
#define IDC_SHARE_PASSWORD              18472
#define IDS_ERR_CANTSHARE               18472
#define IDC_SHARE_USERNAME_TEXT         18473
#define IDS_ERR_NOSHAREINFO             18473
#define IDC_SHARE_PASSWORD_TEXT         18474
#define IDS_ASK_SHARENOW                18474
#define IDC_SHARE_CONFIRM_TEXT          18475
#define IDS_APP_STANDARD                18475
#define IDC_SHARE_CONFIRM               18476
#define IDS_APP_ADVANCED                18476
#define IDC_SHARE_PATH                  18477
#define IDS_ERR_NOSTAGEPATH             18477
#define IDC_SHARE_ACCOUNT_GUEST         18478
#define IDS_WINPEFLOPPY                 18478
#define IDC_SHARE_ACCOUNT_SPECIFY       18479
#define IDS_ERR_WINPEFLOPPY             18479
#define IDC_APP_REBOOT                  18480
#define IDS_WINPEOVERWRITE              18480
#define IDC_APP_TYPE_GEN                18481
#define IDC_APP_TYPE_MSI                18482
#define IDC_APP_TYPE_INF                18483
#define IDC_APP_STAGE                   18484
#define IDC_APP_ADVANCED                18485
#define IDC_APP_ARGS                    18486
#define IDC_APP_STAGEPATH               18489
#define IDC_APP_DIVIDER                 18490
#define IDC_APP_BROWSE                  18491
#define IDC_APP_STAGEPATH_TEXT          18492
#define IDC_APP_INF_SECTION             18496
#define IDC_APP_INF_SECTION_TEXT        18497
#define IDC_APP_ARGS_TEXT               18498
#define IDC_SAVEAS_WINPEFLOPPY          18499
#define IDC_MAINT_BAR                   18500
#define IDC_MOUSE_NO                    18501
#define IDC_MOUSE_CUSTOM                18502
#define IDC_MOUSE_BROWSE                18504
#define IDC_MOUSE_DIR                   18505
#define IDC_STATIC_MOUSE                18506
#define IDC_MOUSE_NO2                   18507
#define IDR_MAIN_CORP                   18508
#define IDC_APP_CREDENTIALS             18509
#define IDC_APP_USERNAME                18510
#define IDC_APP_PASSWORD                18511
#define IDC_APP_USERNAME_TEXT           18512
#define IDC_APP_PASSWORD_TEXT           18513
#define IDC_APP_CONFIRM_TEXT            18514
#define IDC_APP_CONFIRM                 18515
#define IDC_ABOUT_COMPANY               18516
#define IDC_ABOUT_VERSION               18517
#define IDC_ABOUT_COPYRIGHT             18518
#define IDC_ABOUT_DESCRIPTION           18519
#define IDC_OEM_LINK_ICON               18530
#define IDC_OEMLINK_CHECK               18532
#define IDC_OEMLINK_ICON_BUTTON         18534
#define IDC_OEMLINK_LINK_BUTTON         18535
#define IDC_OEMLINK_STATIC_TEXT         18536
#define IDC_OEMLINK_STATIC_ICON         18537
#define IDC_OEMLINK_LINK_STATIC         18538
#define IDC_OEMLINK_STATIC_INFOTIP      18543
#define IDC_OEM_LINK_INFOTIP            18544
#define IDC_TIMEZONE                    18545
#define IDS_TMZ_000                     18546
#define IDC_LOCALE                      18546
#define IDS_TMZ_001                     18547
#define IDC_KEYBOARD                    18547
#define IDS_TMZ_002                     18548
#define IDC_REGION                      18548
#define IDS_TMZ_003                     18549
#define IDS_TMZ_004                     18550
#define IDS_TMZ_010                     18551
#define IDS_TMZ_015                     18552
#define IDS_TMZ_020                     18553
#define IDS_TMZ_025                     18554
#define IDS_TMZ_030                     18555
#define IDS_TMZ_033                     18556
#define IDS_TMZ_035                     18557
#define IDS_TMZ_040                     18558
#define IDS_TMZ_045                     18559
#define IDS_TMZ_050                     18560
#define IDS_TMZ_055                     18561
#define IDS_TMZ_056                     18562
#define IDS_TMZ_060                     18563
#define IDS_TMZ_065                     18564
#define IDS_TMZ_070                     18565
#define IDS_TMZ_073                     18566
#define IDS_TMZ_075                     18567
#define IDS_TMZ_080                     18568
#define IDS_TMZ_083                     18569
#define IDS_TMZ_085                     18570
#define IDS_TMZ_090                     18571
#define IDS_TMZ_095                     18572
#define IDS_TMZ_100                     18573
#define IDS_TMZ_105                     18574
#define IDS_TMZ_110                     18575
#define IDS_TMZ_113                     18576
#define IDS_TMZ_115                     18577
#define IDS_TMZ_120                     18578
#define IDS_TMZ_125                     18579
#define IDS_TMZ_130                     18580
#define IDS_TMZ_135                     18581
#define IDS_TMZ_140                     18582
#define IDS_TMZ_145                     18583
#define IDS_TMZ_150                     18584
#define IDS_TMZ_155                     18585
#define IDS_TMZ_160                     18586
#define IDS_TMZ_165                     18587
#define IDS_TMZ_170                     18588
#define IDS_TMZ_175                     18589
#define IDS_TMZ_180                     18590
#define IDS_TMZ_185                     18591
#define IDS_TMZ_190                     18592
#define IDS_TMZ_193                     18593
#define IDS_TMZ_195                     18594
#define IDS_TMZ_200                     18595
#define IDS_TMZ_201                     18596
#define IDS_TMZ_203                     18597
#define IDS_TMZ_205                     18598
#define IDS_TMZ_207                     18599
#define IDS_TMZ_210                     18600
#define IDS_TMZ_215                     18601
#define IDS_TMZ_220                     18602
#define IDS_TMZ_225                     18603
#define IDS_TMZ_227                     18604
#define IDS_TMZ_230                     18605
#define IDS_TMZ_235                     18606
#define IDS_TMZ_240                     18607
#define IDS_TMZ_245                     18608
#define IDS_TMZ_250                     18609
#define IDS_TMZ_255                     18610
#define IDS_TMZ_260                     18611
#define IDS_TMZ_265                     18612
#define IDS_TMZ_270                     18613
#define IDS_TMZ_275                     18614
#define IDS_TMZ_280                     18615
#define IDS_TMZ_285                     18616
#define IDS_TMZ_290                     18617
#define IDS_TMZ_300                     18618
#define IDS_TMZ_158                     18619
#define IDS_ITL_USR                     18630
#define IDS_LOC_001                     18641
#define IDS_LOC_002                     18642
#define IDS_LOC_003                     18643
#define IDS_LOC_004                     18644
#define IDS_LOC_005                     18645
#define IDS_LOC_006                     18646
#define IDS_LOC_007                     18647
#define IDS_LOC_008                     18648
#define IDS_LOC_009                     18649
#define IDS_LOC_010                     18650
#define IDS_LOC_011                     18651
#define IDS_LOC_012                     18652
#define IDS_LOC_013                     18653
#define IDS_LOC_014                     18654
#define IDS_LOC_015                     18655
#define IDS_LOC_016                     18656
#define IDS_LOC_017                     18657
#define IDS_LOC_018                     18658
#define IDS_LOC_019                     18659
#define IDS_LOC_020                     18660
#define IDS_LOC_021                     18661
#define IDS_LOC_022                     18662
#define IDS_LOC_023                     18663
#define IDS_LOC_024                     18664
#define IDS_LOC_025                     18665
#define IDS_LOC_026                     18666
#define IDS_LOC_027                     18667
#define IDS_LOC_028                     18668
#define IDS_LOC_029                     18669
#define IDS_LOC_030                     18670
#define IDS_LOC_031                     18671
#define IDS_LOC_032                     18672
#define IDS_LOC_033                     18673
#define IDS_LOC_034                     18674
#define IDS_LOC_035                     18675
#define IDS_LOC_036                     18676
#define IDS_LOC_037                     18677
#define IDS_LOC_038                     18678
#define IDS_LOC_039                     18679
#define IDS_LOC_040                     18680
#define IDS_LOC_041                     18681
#define IDS_LOC_042                     18682
#define IDS_LOC_043                     18683
#define IDS_LOC_044                     18684
#define IDS_LOC_045                     18685
#define IDS_LOC_046                     18686
#define IDS_LOC_047                     18687
#define IDS_LOC_048                     18688
#define IDS_LOC_049                     18689
#define IDS_LOC_050                     18690
#define IDS_LOC_051                     18691
#define IDS_LOC_052                     18692
#define IDS_LOC_053                     18693
#define IDS_LOC_054                     18694
#define IDS_LOC_055                     18695
#define IDS_LOC_056                     18696
#define IDS_LOC_057                     18697
#define IDS_LOC_058                     18698
#define IDS_LOC_059                     18699
#define IDS_LOC_060                     18700
#define IDS_LOC_061                     18701
#define IDS_LOC_062                     18702
#define IDS_LOC_063                     18703
#define IDS_LOC_064                     18704
#define IDS_LOC_065                     18705
#define IDS_LOC_066                     18706
#define IDS_LOC_067                     18707
#define IDS_LOC_068                     18708
#define IDS_LOC_069                     18709
#define IDS_LOC_070                     18710
#define IDS_LOC_071                     18711
#define IDS_LOC_072                     18712
#define IDS_LOC_073                     18713
#define IDS_LOC_074                     18714
#define IDS_LOC_075                     18715
#define IDS_LOC_076                     18716
#define IDS_LOC_077                     18717
#define IDS_LOC_078                     18718
#define IDS_LOC_079                     18719
#define IDS_LOC_080                     18720
#define IDS_LOC_081                     18721
#define IDS_LOC_082                     18722
#define IDS_LOC_083                     18723
#define IDS_LOC_084                     18724
#define IDS_LOC_085                     18725
#define IDS_LOC_086                     18726
#define IDS_LOC_087                     18727
#define IDS_LOC_088                     18728
#define IDS_LOC_089                     18729
#define IDS_LOC_090                     18730
#define IDS_LOC_091                     18731
#define IDS_LOC_092                     18732
#define IDS_LOC_093                     18733
#define IDS_LOC_094                     18734
#define IDS_LOC_095                     18735
#define IDS_LOC_096                     18736
#define IDS_LOC_097                     18737
#define IDS_LOC_098                     18738
#define IDS_LOC_099                     18739
#define IDS_LOC_100                     18740
#define IDS_LOC_101                     18741
#define IDS_LOC_102                     18742
#define IDS_LOC_103                     18743
#define IDS_LOC_104                     18744
#define IDS_LOC_105                     18745
#define IDS_LOC_106                     18746
#define IDS_LOC_107                     18747
#define IDS_LOC_108                     18748
#define IDS_LOC_109                     18749
#define IDS_LOC_110                     18750
#define IDS_LOC_111                     18751
#define IDS_LOC_112                     18752
#define IDS_LOC_113                     18753
#define IDS_LOC_114                     18754
#define IDS_LOC_115                     18755
#define IDS_LOC_116                     18756
#define IDS_LOC_117                     18757
#define IDS_LOC_118                     18758
#define IDS_LOC_119                     18759
#define IDS_LOC_120                     18760
#define IDS_LOC_121                     18761
#define IDS_LOC_122                     18762
#define IDS_LOC_123                     18763
#define IDS_LOC_124                     18764
#define IDS_LOC_125                     18765
#define IDS_LOC_126                     18766
#define IDS_LOC_127                     18767
#define IDS_LOC_128                     18768
#define IDS_LOC_129                     18769
#define IDS_LOC_130                     18770
#define IDS_LOC_131                     18771
#define IDS_LOC_132                     18772
#define IDS_LOC_133                     18773
#define IDS_LOC_134                     18774
#define IDS_LOC_135                     18775
#define IDS_GEO_001                     18801
#define IDS_GEO_002                     18802
#define IDS_GEO_003                     18803
#define IDS_GEO_004                     18804
#define IDS_GEO_005                     18805
#define IDS_GEO_006                     18806
#define IDS_GEO_007                     18807
#define IDS_GEO_008                     18808
#define IDS_GEO_009                     18809
#define IDS_GEO_010                     18810
#define IDS_GEO_011                     18811
#define IDS_GEO_012                     18812
#define IDS_GEO_013                     18813
#define IDS_GEO_014                     18814
#define IDS_GEO_015                     18815
#define IDS_GEO_016                     18816
#define IDS_GEO_017                     18817
#define IDS_GEO_018                     18818
#define IDS_GEO_019                     18819
#define IDS_GEO_020                     18820
#define IDS_GEO_021                     18821
#define IDS_GEO_022                     18822
#define IDS_GEO_023                     18823
#define IDS_GEO_024                     18824
#define IDS_GEO_025                     18825
#define IDS_GEO_026                     18826
#define IDS_GEO_027                     18827
#define IDS_GEO_028                     18828
#define IDS_GEO_029                     18829
#define IDS_GEO_030                     18830
#define IDS_GEO_031                     18831
#define IDS_GEO_032                     18832
#define IDS_GEO_033                     18833
#define IDS_GEO_034                     18834
#define IDS_GEO_035                     18835
#define IDS_GEO_036                     18836
#define IDS_GEO_037                     18837
#define IDS_GEO_038                     18838
#define IDS_GEO_039                     18839
#define IDS_GEO_040                     18840
#define IDS_GEO_041                     18841
#define IDS_GEO_042                     18842
#define IDS_GEO_043                     18843
#define IDS_GEO_044                     18844
#define IDS_GEO_045                     18845
#define IDS_GEO_046                     18846
#define IDS_GEO_047                     18847
#define IDS_GEO_048                     18848
#define IDS_GEO_049                     18849
#define IDS_GEO_050                     18850
#define IDS_GEO_051                     18851
#define IDS_GEO_052                     18852
#define IDS_GEO_053                     18853
#define IDS_GEO_054                     18854
#define IDS_GEO_055                     18855
#define IDS_GEO_056                     18856
#define IDS_GEO_057                     18857
#define IDS_GEO_058                     18858
#define IDS_GEO_059                     18859
#define IDS_GEO_060                     18860
#define IDS_GEO_061                     18861
#define IDS_GEO_062                     18862
#define IDS_GEO_063                     18863
#define IDS_GEO_064                     18864
#define IDS_GEO_065                     18865
#define IDS_GEO_066                     18866
#define IDS_GEO_067                     18867
#define IDS_GEO_068                     18868
#define IDS_GEO_069                     18869
#define IDS_GEO_070                     18870
#define IDS_GEO_071                     18871
#define IDS_GEO_072                     18872
#define IDS_GEO_073                     18873
#define IDS_GEO_074                     18874
#define IDS_GEO_075                     18875
#define IDS_GEO_076                     18876
#define IDS_GEO_077                     18877
#define IDS_GEO_078                     18878
#define IDS_GEO_079                     18879
#define IDS_GEO_080                     18880
#define IDS_GEO_081                     18881
#define IDS_GEO_082                     18882
#define IDS_GEO_083                     18883
#define IDS_GEO_084                     18884
#define IDS_GEO_085                     18885
#define IDS_GEO_086                     18886
#define IDS_GEO_087                     18887
#define IDS_GEO_088                     18888
#define IDS_GEO_089                     18889
#define IDS_GEO_090                     18890
#define IDS_GEO_091                     18891
#define IDS_GEO_092                     18892
#define IDS_GEO_093                     18893
#define IDS_GEO_094                     18894
#define IDS_GEO_095                     18895
#define IDS_GEO_096                     18896
#define IDS_GEO_097                     18897
#define IDS_GEO_098                     18898
#define IDS_GEO_099                     18899
#define IDS_GEO_100                     18900
#define IDS_GEO_101                     18901
#define IDS_GEO_102                     18902
#define IDS_GEO_103                     18903
#define IDS_GEO_104                     18904
#define IDS_GEO_105                     18905
#define IDS_GEO_106                     18906
#define IDS_GEO_107                     18907
#define IDS_GEO_108                     18908
#define IDS_GEO_109                     18909
#define IDS_GEO_110                     18910
#define IDS_GEO_111                     18911
#define IDS_GEO_112                     18912
#define IDS_GEO_113                     18913
#define IDS_GEO_114                     18914
#define IDS_GEO_115                     18915
#define IDS_GEO_116                     18916
#define IDS_GEO_117                     18917
#define IDS_GEO_118                     18918
#define IDS_GEO_119                     18919
#define IDS_GEO_120                     18920
#define IDS_GEO_121                     18921
#define IDS_GEO_122                     18922
#define IDS_GEO_123                     18923
#define IDS_GEO_124                     18924
#define IDS_GEO_125                     18925
#define IDS_GEO_126                     18926
#define IDS_GEO_127                     18927
#define IDS_GEO_128                     18928
#define IDS_GEO_129                     18929
#define IDS_GEO_130                     18930
#define IDS_GEO_131                     18931
#define IDS_GEO_132                     18932
#define IDS_GEO_133                     18933
#define IDS_GEO_134                     18934
#define IDS_GEO_135                     18935
#define IDS_GEO_136                     18936
#define IDS_GEO_137                     18937
#define IDS_GEO_138                     18938
#define IDS_GEO_139                     18939
#define IDS_GEO_140                     18940
#define IDS_GEO_141                     18941
#define IDS_GEO_142                     18942
#define IDS_GEO_143                     18943
#define IDS_GEO_144                     18944
#define IDS_GEO_145                     18945
#define IDS_GEO_146                     18946
#define IDS_GEO_147                     18947
#define IDS_GEO_148                     18948
#define IDS_GEO_149                     18949
#define IDS_GEO_150                     18950
#define IDS_GEO_151                     18951
#define IDS_GEO_152                     18952
#define IDS_GEO_153                     18953
#define IDS_GEO_154                     18954
#define IDS_GEO_155                     18955
#define IDS_GEO_156                     18956
#define IDS_GEO_157                     18957
#define IDS_GEO_158                     18958
#define IDS_GEO_159                     18959
#define IDS_GEO_160                     18960
#define IDS_GEO_161                     18961
#define IDS_GEO_162                     18962
#define IDS_GEO_163                     18963
#define IDS_GEO_164                     18964
#define IDS_GEO_165                     18965
#define IDS_GEO_166                     18966
#define IDS_GEO_167                     18967
#define IDS_GEO_168                     18968
#define IDS_GEO_169                     18969
#define IDS_GEO_170                     18970
#define IDS_GEO_171                     18971
#define IDS_GEO_172                     18972
#define IDS_GEO_173                     18973
#define IDS_GEO_174                     18974
#define IDS_GEO_175                     18975
#define IDS_GEO_176                     18976
#define IDS_GEO_177                     18977
#define IDS_GEO_178                     18978
#define IDS_GEO_179                     18979
#define IDS_GEO_180                     18980
#define IDS_GEO_181                     18981
#define IDS_GEO_182                     18982
#define IDS_GEO_183                     18983
#define IDS_GEO_184                     18984
#define IDS_GEO_185                     18985
#define IDS_GEO_186                     18986
#define IDS_GEO_187                     18987
#define IDS_GEO_188                     18988
#define IDS_GEO_189                     18989
#define IDS_GEO_190                     18990
#define IDS_GEO_191                     18991
#define IDS_GEO_192                     18992
#define IDS_GEO_193                     18993
#define IDS_GEO_194                     18994
#define IDS_GEO_195                     18995
#define IDS_GEO_196                     18996
#define IDS_GEO_197                     18997
#define IDS_GEO_198                     18998
#define IDS_GEO_199                     18999
#define IDS_GEO_200                     19000
#define IDS_GEO_201                     19001
#define IDS_GEO_202                     19002
#define IDS_GEO_203                     19003
#define IDS_GEO_204                     19004
#define IDS_GEO_205                     19005
#define IDS_GEO_206                     19006
#define IDS_GEO_207                     19007
#define IDS_GEO_208                     19008
#define IDS_GEO_209                     19009
#define IDS_GEO_210                     19010
#define IDS_GEO_211                     19011
#define IDS_GEO_212                     19012
#define IDS_GEO_213                     19013
#define IDS_GEO_214                     19014
#define IDS_GEO_215                     19015
#define IDS_GEO_216                     19016
#define IDS_GEO_217                     19017
#define IDS_GEO_218                     19018
#define IDS_GEO_219                     19019
#define IDS_GEO_220                     19020
#define IDS_GEO_221                     19021
#define IDS_GEO_222                     19022
#define IDS_GEO_223                     19023
#define IDS_GEO_224                     19024
#define IDS_GEO_225                     19025
#define IDS_GEO_226                     19026
#define IDS_GEO_227                     19027
#define IDS_GEO_228                     19028
#define IDS_GEO_229                     19029
#define IDS_GEO_230                     19030
#define IDS_GEO_231                     19031
#define IDS_GEO_232                     19032
#define IDS_GEO_233                     19033
#define IDS_GEO_234                     19034
#define IDS_GEO_235                     19035
#define IDS_GEO_236                     19036
#define IDS_GEO_237                     19037
#define IDS_GEO_238                     19038
#define IDS_GEO_239                     19039
#define IDS_GEO_240                     19040
#define IDS_GEO_241                     19041
#define IDS_GEO_242                     19042
#define IDS_GEO_243                     19043
#define IDS_GEO_244                     19044
#define IDS_GEO_245                     19045
#define IDS_GEO_246                     19046
#define IDS_GEO_247                     19047
#define IDS_GEO_248                     19048
#define IDS_GEO_249                     19049
#define IDS_GEO_250                     19050
#define IDS_GEO_251                     19051
#define IDS_GEO_252                     19052
#define IDS_GEO_253                     19053
#define IDS_GEO_254                     19054
#define IDS_GEO_255                     19055
#define IDS_GEO_256                     19056
#define IDS_GEO_257                     19057
#define IDS_GEO_258                     19058
#define IDS_GEO_259                     19059
#define IDS_GEO_260                     19060
#define IDS_GEO_261                     19061
#define IDS_KEY_000                     19100
#define IDS_KEY_001                     19101
#define IDS_KEY_002                     19102
#define IDS_KEY_003                     19103
#define IDS_KEY_004                     19104
#define IDS_KEY_005                     19105
#define IDS_KEY_006                     19106
#define IDS_KEY_007                     19107
#define IDS_KEY_008                     19108
#define IDS_KEY_009                     19109
#define IDS_KEY_010                     19110
#define IDS_KEY_011                     19111
#define IDS_KEY_012                     19112
#define IDS_KEY_013                     19113
#define IDS_KEY_014                     19114
#define IDS_KEY_015                     19115
#define IDS_KEY_016                     19116
#define IDS_KEY_017                     19117
#define IDS_KEY_018                     19118
#define IDS_KEY_019                     19119
#define IDS_KEY_020                     19120
#define IDS_KEY_021                     19121
#define IDS_KEY_022                     19122
#define IDS_KEY_023                     19123
#define IDS_KEY_024                     19124
#define IDS_KEY_025                     19125
#define IDS_KEY_026                     19126
#define IDS_KEY_027                     19127
#define IDS_KEY_028                     19128
#define IDS_KEY_029                     19129
#define IDS_KEY_030                     19130
#define IDS_KEY_031                     19131
#define IDS_KEY_032                     19132
#define IDS_KEY_033                     19133
#define IDS_KEY_034                     19134
#define IDS_KEY_035                     19135
#define IDS_KEY_036                     19136
#define IDS_KEY_037                     19137
#define IDS_KEY_038                     19138
#define IDS_KEY_039                     19139
#define IDS_KEY_040                     19140
#define IDS_KEY_041                     19141
#define IDS_KEY_042                     19142
#define IDS_KEY_043                     19143
#define IDS_KEY_044                     19144
#define IDS_KEY_045                     19145
#define IDS_KEY_046                     19146
#define IDS_KEY_047                     19147
#define IDS_KEY_048                     19148
#define IDS_KEY_049                     19149
#define IDS_KEY_050                     19150
#define IDS_KEY_051                     19151
#define IDS_KEY_052                     19152
#define IDS_KEY_053                     19153
#define IDS_KEY_054                     19154
#define IDS_KEY_055                     19155
#define IDS_KEY_056                     19156
#define IDS_KEY_057                     19157
#define IDS_KEY_058                     19158
#define IDS_KEY_059                     19159
#define IDS_KEY_060                     19160
#define IDS_KEY_061                     19161
#define IDS_KEY_062                     19162
#define IDS_KEY_063                     19163
#define IDS_KEY_064                     19164
#define IDS_KEY_065                     19165
#define IDS_KEY_066                     19166
#define IDS_KEY_067                     19167
#define IDS_KEY_068                     19168
#define IDS_KEY_069                     19169
#define IDS_KEY_070                     19170
#define IDS_KEY_071                     19171
#define IDS_KEY_072                     19172
#define IDS_KEY_073                     19173
#define IDS_KEY_074                     19174
#define IDS_KEY_075                     19175
#define IDS_KEY_076                     19176
#define IDS_KEY_077                     19177
#define IDS_KEY_078                     19178
#define IDS_KEY_079                     19179
#define IDS_KEY_080                     19180
#define IDS_KEY_081                     19181
#define IDS_KEY_082                     19182
#define IDS_KEY_083                     19183
#define IDS_KEY_084                     19184
#define IDS_KEY_085                     19185
#define IDS_KEY_086                     19186
#define IDS_KEY_087                     19187
#define IDS_KEY_088                     19188
#define IDS_KEY_089                     19189
#define IDS_KEY_090                     19190
#define IDS_KEY_091                     19191
#define IDS_KEY_092                     19192
#define IDS_KEY_093                     19193
#define IDS_KEY_094                     19194
#define IDS_KEY_095                     19195
#define IDS_KEY_096                     19196
#define IDS_KEY_097                     19197
#define IDS_ARA                         19200
#define IDS_CHH                         19201
#define IDS_CHT                         19202
#define IDS_CHS                         19203
#define IDS_HEB                         19204
#define IDS_JPN                         19205
#define IDS_KOR                         19206
#define IDS_ERR_BADSOURCELANG           19207
#define IDS_BRZ                         19208
#define IDS_CAT                         19209
#define IDS_CZE                         19210
#define IDS_DAN                         19211
#define IDS_DUT                         19212
#define IDS_FIN                         19213
#define IDS_FRN                         19214
#define IDS_GRK                         19215
#define IDS_HUN                         19216
#define IDS_ITN                         19217
#define IDS_NOR                         19218
#define IDS_POL                         19219
#define IDS_POR                         19220
#define IDS_RUS                         19221
#define IDS_SPA                         19222
#define IDS_SWE                         19223
#define IDS_TRK                         19224
#define IDS_ASK_ENABLEGUEST             19225
#define IDC_WIZARDFRAME                 19225
#define IDS_INSTALLSBSI                 19226
#define IDC_SPLASHFRAME                 19227
#define IDS_SKU_BLA                     19228
#define IDS_SKU_SBS                     19229
#define IDC_FAVPOPINTRO                 19230
#define IDS_FAVPOPUP_FOLDER             19230
#define IDC_FAVPOP_DESCRIPTION          19230
#define IDD_PRODUCTKEY                  19231
#define IDS_FAVPOPUP_URL                19231
#define IDC_NAME_TEXT2                  19232
#define IDS_FAVPOPUP_PROPERTIES         19232
#define IDC_FAVPOPUP_NAME               19233
#define IDS_FAVPOPUP_FOLDERNAME         19233
#define IDC_CONFIG_NAME                 19234
#define IDS_FAVPOPUP_PROP               19234
#define IDS_FAVPOPUP_URLDESC            19235
#define IDS_FAVPOPUP_FOLDERDESC         19236
#define IDC_FAVPOPUP_DESCRIPTION        19237
#define IDS_ASK_USEGUEST		19238
#define IDS_CANNOTFIND                  19239
#define IDS_SKU_SP                      19240
#define ID_TOOLS_SHARE                  48001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        18002
#define _APS_NEXT_COMMAND_VALUE         48002
#define _APS_NEXT_CONTROL_VALUE         19235
#define _APS_NEXT_SYMED_VALUE           18001
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\prodkey.c ===
/****************************************************************************\

    PRODKEY.C / OPK Wizard (SETUPMGR.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2001-2002
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Product Key" wizard page.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define INI_SEC_USERDATA        _T("UserData")
#define INI_KEY_PRODUCTKEY      _T("ProductKey")
#define INI_KEY_PRODUCTKEY_OLD  _T("ProductID")
#define MAX_PID_FIELD           5
#define STR_DASH                _T("-")
#define STR_VALID_KEYCHARS      _T("23456789BCDFGHJKMPQRTVWXY")

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL ValidData(HWND);
static void SaveData(HWND);
LONG CALLBACK PidEditSubWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
static void PidChar(HWND hwnd, INT id, HWND hwndCtl, WPARAM wParam, LPARAM lParam);
static int PidPrev(int id);
static int PidNext(int id);
static BOOL PidPaste(HWND hwnd, INT id, HWND hwndCtl);


//
// External Function(s):
//

LRESULT CALLBACK ProductKeyDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
            
        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( ValidData(hwnd) )
                    {
                        SaveData(hwnd);

                        // If we are currently in the wizard, press the finish button
                        //
                        if ( GET_FLAG(OPK_ACTIVEWIZ) )
                            WIZ_PRESS(hwnd, PSBTN_FINISH);
                    }
                    else
                        WIZ_FAIL(hwnd);
                    break;
                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_OEMINFO;

                    WIZ_BUTTONS(hwnd, GET_FLAG(OPK_OEM) ? (PSWIZB_BACK | PSWIZB_NEXT) : PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    // We should continue on to maint. wizard if in maintenance mode
                    //
                    //if ( GET_FLAG(OPK_MAINTMODE) )
                    //    WIZ_PRESS(hwnd, PSBTN_NEXT);

                    break;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szBuf[MAX_URL];
    LPTSTR  lpCurrent,
            lpIndex;
    DWORD   dwIndex = IDC_PRODUCT_KEY1;

    // Set the text limits, disable IME, and replace window proc for each edit box.
    //
    for ( dwIndex = IDC_PRODUCT_KEY1; dwIndex <= IDC_PRODUCT_KEY5; dwIndex++)
    {
        // Limit the edit box text
        //
        SendDlgItemMessage(hwnd, dwIndex, EM_LIMITTEXT, MAX_PID_FIELD, 0);

        // Turn off the IME
        //
        ImmAssociateContext(GetDlgItem(hwnd, dwIndex), NULL);

        // Replace the wndproc for the pid edit boxes.
        //
        PidEditSubWndProc(GetDlgItem(hwnd, dwIndex), WM_SUBWNDPROC, 0, 0L);
    }

    // Populate the Product Key fields
    //
    szBuf[0] = NULLCHR;
    GetPrivateProfileString(INI_SEC_USERDATA, INI_KEY_PRODUCTKEY, NULLSTR, szBuf, MAX_INFOLEN, GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szUnattendTxtFile);

    // Check for the old ProductID as well
    //
    if ( szBuf[0] == NULLCHR )
    {
        GetPrivateProfileString(INI_SEC_USERDATA, INI_KEY_PRODUCTKEY_OLD, NULLSTR, szBuf, MAX_INFOLEN, GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szUnattendTxtFile);
    }

    lpCurrent = szBuf;
    lpIndex = lpCurrent;


    // Reset the index for the next loop
    //
    dwIndex = IDC_PRODUCT_KEY1;


    // If we have not reached the end of the string and we haven't exceded the number of fields, then continue
    //
    while ( *lpCurrent && dwIndex < (IDC_PRODUCT_KEY1 + 5) )
    {
        // If we've reached a dash, then we have the next field in the product key
        //
        if ( *lpCurrent == _T('-') )
        {
            // Set the current char to null so lpIndex is a string
            //
            *lpCurrent = NULLCHR;

            // Set the proper Product Key field
            //
            SetWindowText(GetDlgItem(hwnd, dwIndex++), lpIndex);

            // Move lpIndex past the NULLCHR
            //
            lpIndex = lpCurrent + 1;
        }

        // Move to the next character
        //
        lpCurrent++;

        // We have to special case the last field because lpCurrent==NULLCHR and we would fall
        // through without populating the last field
        //
        if ( (*lpCurrent == NULLCHR) && *lpIndex)
            SetWindowText(GetDlgItem(hwnd, dwIndex++), lpIndex);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    if ( ( codeNotify == EN_CHANGE ) &&
         ( MAX_PID_FIELD == GetWindowTextLength(hwndCtl) ) )
    {
        if ( IDC_PRODUCT_KEY5 == id )
        {
            id = ID_MAINT_NEXT;
            hwnd = GetParent(hwnd);
        }
        else
            id = PidNext(id);

        if ( id )
        {
            hwndCtl = GetDlgItem(hwnd, id);
            SetFocus(hwndCtl);
            SendMessage(hwndCtl, EM_SETSEL, 0, (LPARAM) MAX_PID_FIELD);
        }
    }
}

static BOOL ValidData(HWND hwnd)
{
    TCHAR   szBuffer[MAX_PATH];
    BOOL    bProductKey         = FALSE;
    LPTSTR  lpCurrent;
    DWORD   dwIndex             = IDC_PRODUCT_KEY1;
    UINT    cb;

    //
    // Validate the product key
    //

    // Check to see if there was a key entered
    //
    while ( dwIndex < (IDC_PRODUCT_KEY1 + 5) && !bProductKey)
    {
        if ( (cb = GetDlgItemText(hwnd, dwIndex, szBuffer, STRSIZE(szBuffer)) != 0) )
            bProductKey = TRUE;

        dwIndex++;
    }

    // Make sure that each field has the proper number of characters
    //
    while ( dwIndex < (IDC_PRODUCT_KEY1 + 5) && bProductKey)
    {
        // Check to make sure that each field is five characters in length
        //
        if ( (cb = GetDlgItemText(hwnd, dwIndex, szBuffer, STRSIZE(szBuffer)) != 5) )
        {
            MsgBox(GetParent(hwnd), IDS_ERROR_PRODKEY_LEN, IDS_APPNAME, MB_ERRORBOX);
            SetFocus( GetDlgItem(hwnd, dwIndex) );
            return FALSE;
        }

        // Go to the next field
        //
        dwIndex++;
    }

    // Check to make sure that there are no invalid characters
    //
    dwIndex = IDC_PRODUCT_KEY1;
    
    while ( dwIndex < (IDC_PRODUCT_KEY1 + 5) && bProductKey)
    {
        // Check for invalid characters in the strings
        //
        GetDlgItemText(hwnd, dwIndex, szBuffer, STRSIZE(szBuffer));

        for ( lpCurrent = szBuffer; *lpCurrent; lpCurrent++)
        {
            if ( !(_tcschr(STR_VALID_KEYCHARS, *lpCurrent)) )
            {
                MsgBox(GetParent(hwnd), IDS_ERROR_PRODKEY_INV, IDS_APPNAME, MB_ERRORBOX);
                SetFocus( GetDlgItem(hwnd, dwIndex) );
                return FALSE;
            }

        }
        
        // Go to the next field
        //
        dwIndex++;
    }
    
    //
    // Return our search result.
    //
    return TRUE;
}

static void SaveData(HWND hwnd)
{
    TCHAR   szKeyBuf[32],
            szProductKey[MAX_PATH];
    HRESULT hrCat;

    // Save the product ID information
    //
    GetDlgItemText(hwnd, IDC_PRODUCT_KEY1, szKeyBuf, STRSIZE(szKeyBuf));
    lstrcpyn(szProductKey, szKeyBuf,AS(szProductKey));
    hrCat=StringCchCat(szProductKey, AS(szProductKey), STR_DASH);
    
    GetDlgItemText(hwnd, IDC_PRODUCT_KEY2, szKeyBuf, STRSIZE(szKeyBuf));
    hrCat=StringCchCat(szProductKey, AS(szProductKey), szKeyBuf);
    hrCat=StringCchCat(szProductKey, AS(szProductKey), STR_DASH);
    
    GetDlgItemText(hwnd, IDC_PRODUCT_KEY3, szKeyBuf, STRSIZE(szKeyBuf));
    hrCat=StringCchCat(szProductKey, AS(szProductKey), szKeyBuf);
    hrCat=StringCchCat(szProductKey, AS(szProductKey), STR_DASH);

    GetDlgItemText(hwnd, IDC_PRODUCT_KEY4, szKeyBuf, STRSIZE(szKeyBuf));
    hrCat=StringCchCat(szProductKey, AS(szProductKey), szKeyBuf);
    hrCat=StringCchCat(szProductKey, AS(szProductKey), STR_DASH);

    GetDlgItemText(hwnd, IDC_PRODUCT_KEY5, szKeyBuf, STRSIZE(szKeyBuf));
    hrCat=StringCchCat(szProductKey, AS(szProductKey), szKeyBuf);

    if ( lstrlen(szProductKey) <= 4  )
        szProductKey[0] = NULLCHR;

    // Write out the product key, if the user is not an OEM write NULL to the section just in case they populated the field in the inf
    //
    WritePrivateProfileString(INI_SEC_USERDATA, INI_KEY_PRODUCTKEY, ( szProductKey[0] ? szProductKey : NULL ), g_App.szUnattendTxtFile);
    WritePrivateProfileString(INI_SEC_USERDATA, INI_KEY_PRODUCTKEY, ( szProductKey[0] ? szProductKey : NULL ), g_App.szOpkWizIniFile);

    // if Product key specified, delete old ProductId
    if (szProductKey[0]) {
        WritePrivateProfileString(INI_SEC_USERDATA, INI_KEY_PRODUCTKEY_OLD, NULL, g_App.szUnattendTxtFile);
        WritePrivateProfileString(INI_SEC_USERDATA, INI_KEY_PRODUCTKEY_OLD, NULL, g_App.szOpkWizIniFile);
    }
}

LONG CALLBACK PidEditSubWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static FARPROC lpfnOldProc = NULL;

    switch ( msg )
    {
        case WM_SUBWNDPROC:
            lpfnOldProc = (FARPROC) GetWindowLongPtr(hwnd, GWLP_WNDPROC);
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) PidEditSubWndProc);
            return 1;

        case WM_KEYDOWN:

            // We want to let the VK_LEFT and VK_RIGHT WM_KEYDOWN messages to call the pid char
            // function because they don't generate a WM_CHAR message.
            //
            switch ( (TCHAR) wParam )
            {
                case VK_LEFT:
                case VK_RIGHT:
                    PidChar(GetParent(hwnd), GetDlgCtrlID(hwnd), hwnd, (TCHAR) wParam, (DWORD) lParam);
                    break;
            }
            break;

        case WM_CHAR:

            // Only need to do this for VK_BACK right now.
            //
            switch ( (TCHAR) wParam )
            {
                case VK_BACK:
                    PidChar(GetParent(hwnd), GetDlgCtrlID(hwnd), hwnd, (TCHAR) wParam, (DWORD) lParam);
                    break;
            }
            break;

        case WM_PASTE:
            if ( PidPaste(GetParent(hwnd), GetDlgCtrlID(hwnd), hwnd) )
                return 0;
            break;
    }

    if ( lpfnOldProc )
        return (LONG) CallWindowProc((WNDPROC) lpfnOldProc, hwnd, msg, wParam, lParam);
    else
        return 0;
}

static void PidChar(HWND hwnd, INT id, HWND hwndCtl, WPARAM wParam, LPARAM lParam)
{
    DWORD   dwPos = 0,
            dwLast;

    switch ( (TCHAR) wParam )
    {
        case VK_BACK:

            // Only if we are at the beginning of the box do
            // we want to switch to the previous one and delete
            // a character from the end of that one.
            //
            SendMessage(hwndCtl, EM_GETSEL, (WPARAM) &dwPos, 0L);
            if ( ( 0 == dwPos ) &&
                 ( id = PidPrev(id) ) )
            {
                // First set the focus to the previous pid edit control.
                //
                hwndCtl = GetDlgItem(hwnd, id);
                SetFocus(hwndCtl);

                // Need to reset the caret to the end of the text box, or we will
                // do weird things.
                //
                SendMessage(hwndCtl, EM_SETSEL, MAX_PID_FIELD, (LPARAM) MAX_PID_FIELD);

                // Now pass the backspace key to the previous edit box.
                //
                PostMessage(hwndCtl, WM_CHAR, wParam, lParam);
            }
            break;

        case VK_LEFT:

            // Only if we are at the beginning of the box do
            // we want to switch to the previous one.
            //
            SendMessage(hwndCtl, EM_GETSEL, (WPARAM) &dwPos, 0L);
            if ( ( 0 == dwPos ) &&
                 ( id = PidPrev(id) ) )
            {
                // First set the focus to the previous pid edit control.
                //
                hwndCtl = GetDlgItem(hwnd, id);
                SetFocus(hwndCtl);

                // Now make sure the caret is at the end of this edit box
                // if at MAX_PID_FIELD, or 2nd to last if it isn't and the
                // shift key isn't down.
                //
                if ( ( MAX_PID_FIELD <= (dwLast = (DWORD) GetWindowTextLength(hwndCtl)) ) &&
                     ( 0 == (0XFF00 & GetKeyState(VK_SHIFT)) ) )
                {
                    dwLast--;
                }
                SendMessage(hwndCtl, EM_SETSEL, dwLast, (LPARAM) dwLast);
            }
            break;

        case VK_RIGHT:

            // Need to first know where the caret is in the edit box.
            //
            SendMessage(hwndCtl, EM_GETSEL, 0, (LPARAM) &dwPos);

            // Now we need to know how much text is in the buffer now.  If the numer
            // of characters is already at the max, we subtract one so that you can
            // we arror to the next box instead of the end of the string.  Unless the
            // shift key is down, then we want them to be able to select the whole string.
            //
            dwLast = (DWORD) GetWindowTextLength(hwndCtl);
            if ( ( MAX_PID_FIELD == GetWindowTextLength(hwndCtl) ) &&
                 ( 0 == (0XFF00 & GetKeyState(VK_SHIFT)) ) )
            {
                dwLast--;
            }

            // Now only if this is the last character do we switch to the next pid
            // edit box.
            //
            if ( ( dwLast <= dwPos ) &&
                 ( id = PidNext(id) ) )
            {
                // First set the focus to the next pid edit control.
                //
                hwndCtl = GetDlgItem(hwnd, id);
                SetFocus(hwndCtl);

                // Now make sure the caret is at the beginning of this
                // edit box.
                //
                SendMessage(hwndCtl, EM_SETSEL, 0, 0L);
            }
            break;
    }
}

static int PidPrev(int id)
{
    switch ( id )
    {
        case IDC_PRODUCT_KEY2:
            id = IDC_PRODUCT_KEY1;
            break;

        case IDC_PRODUCT_KEY3:
            id = IDC_PRODUCT_KEY2;
            break;

        case IDC_PRODUCT_KEY4:
            id = IDC_PRODUCT_KEY3;
            break;

        case IDC_PRODUCT_KEY5:
            id = IDC_PRODUCT_KEY4;
            break;

        default:
            id = 0;
    }

    return id;
}

static int PidNext(int id)
{
    switch ( id )
    {
        case IDC_PRODUCT_KEY1:
            id = IDC_PRODUCT_KEY2;
            break;

        case IDC_PRODUCT_KEY2:
            id = IDC_PRODUCT_KEY3;
            break;

        case IDC_PRODUCT_KEY3:
            id = IDC_PRODUCT_KEY4;
            break;

        case IDC_PRODUCT_KEY4:
            id = IDC_PRODUCT_KEY5;
            break;

        default:
            id = 0;
    }

    return id;
}

static BOOL PidPaste(HWND hwnd, INT id, HWND hwndCtl)
{
    BOOL bRet       = FALSE;
#ifdef  _UNICODE
    UINT uFormat    = CF_UNICODETEXT;
#else   // _UNICODE
    UINT uFormat    = CF_TEXT;
#endif  // _UNICODE

    if ( IsClipboardFormatAvailable(uFormat) &&
         OpenClipboard(NULL) )
    {
        HGLOBAL hClip;
        LPTSTR  lpText;
        DWORD   dwFirst,
                dwLast,
                dwLength;

        SendMessage(hwndCtl, EM_GETSEL, (WPARAM) &dwFirst, (LPARAM) &dwLast);
        dwLength = (DWORD) GetWindowTextLength(hwndCtl);

        if ( ( dwLength <= (dwLast - dwFirst) ) &&
             ( hClip = GetClipboardData(uFormat) ) &&
             ( lpText = (LPTSTR) GlobalLock(hClip) ) )
        {
            LPTSTR  lpSearch = lpText;
            TCHAR   szPaste[MAX_PID_FIELD + 1];

            bRet = TRUE;

            do
            {
                hwndCtl = GetDlgItem(hwnd, id);
                SetFocus(hwndCtl);
                lstrcpyn(szPaste, lpSearch, AS(szPaste));
                SetWindowText(hwndCtl, szPaste);
                lpSearch = lpSearch + lstrlen(szPaste);
                if ( ( _T('-') == *lpSearch ) ||
                     ( _T(' ') == *lpSearch ) )
                {
                    lpSearch++;
                }
            }
            while ( *lpSearch && ( id = PidNext(id) ) );

            GlobalUnlock(hClip);
        }
        CloseClipboard();
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\screens2.h ===
#ifndef _SCREENS2_H_
#define _SCREENS2_H_

typedef struct _LONGRES
{
    LONG    Index;
    UINT    uId;
} LONGRES, *LPLONGRES;

static LONGRES lr_keyboard_default [] =
{
    { -1,            IDS_ITL_USR },     
    { 0x00000402,    IDS_KEY_000 },     
    { 0x00000405,    IDS_KEY_001 },     
    { 0x00000406,    IDS_KEY_002 },     
    { 0x00000407,    IDS_KEY_003 },     
    { 0x00000408,    IDS_KEY_004 },     
    { 0x00000409,    IDS_KEY_005 },     
    { 0x0000040a,    IDS_KEY_006 },     
    { 0x0000040b,    IDS_KEY_007 },     
    { 0x0000040c,    IDS_KEY_008 },     
    { 0x0000040e,    IDS_KEY_009 },     
    { 0x0000040f,    IDS_KEY_010 },     
    { 0x00000410,    IDS_KEY_011 },     
    { 0x00000413,    IDS_KEY_012 },     
    { 0x00000414,    IDS_KEY_013 },     
    { 0x00000415,    IDS_KEY_014 },     
    { 0x00000416,    IDS_KEY_015 },     
    { 0x00000418,    IDS_KEY_016 },     
    { 0x00000419,    IDS_KEY_017 },     
    { 0x0000041A,    IDS_KEY_018 },     
    { 0x0000041b,    IDS_KEY_019 },     
    { 0x0000041c,    IDS_KEY_020 },     
    { 0x0000041d,    IDS_KEY_021 },     
    { 0x0000041f,    IDS_KEY_022 },     
    { 0x00000422,    IDS_KEY_023 },     
    { 0x00000423,    IDS_KEY_024 },     
    { 0x00000424,    IDS_KEY_025 },     
    { 0x00000425,    IDS_KEY_026 },     
    { 0x00000426,    IDS_KEY_027 },     
    { 0x00000427,    IDS_KEY_028 },     
    { 0x0000042c,    IDS_KEY_029 },     
    { 0x0000042f,    IDS_KEY_030 },     
    { 0x00000438,    IDS_KEY_031 },     
    { 0x0000043f,    IDS_KEY_032 },     
    { 0x00000440,    IDS_KEY_033 },     
    { 0x00000444,    IDS_KEY_034 },     
    { 0x00000450,    IDS_KEY_035 },     
    { 0x00000807,    IDS_KEY_036 },     
    { 0x00000809,    IDS_KEY_037 },     
    { 0x0000080a,    IDS_KEY_038 },     
    { 0x0000080c,    IDS_KEY_039 },     
    { 0x00000813,    IDS_KEY_040 },     
    { 0x00000816,    IDS_KEY_041 },     
    { 0x0000081a,    IDS_KEY_042 },     
    { 0x0000082c,    IDS_KEY_043 },     
    { 0x00000843,    IDS_KEY_044 },     
    { 0x00000c0c,    IDS_KEY_045 },     
    { 0x00000c1a,    IDS_KEY_046 },     
    { 0x00001009,    IDS_KEY_047 },     
    { 0x0000100c,    IDS_KEY_048 },     
    { 0x00001809,    IDS_KEY_049 },     
    { 0x00010402,    IDS_KEY_050 },     
    { 0x00010405,    IDS_KEY_051 },     
    { 0x00010407,    IDS_KEY_052 },     
    { 0x00010408,    IDS_KEY_053 },     
    { 0x00010409,    IDS_KEY_054 },     
    { 0x0001040a,    IDS_KEY_055 },     
    { 0x0001040e,    IDS_KEY_056 },     
    { 0x00010410,    IDS_KEY_057 },     
    { 0x00010415,    IDS_KEY_058 },     
    { 0x00010416,    IDS_KEY_059 },     
    { 0x00010419,    IDS_KEY_060 },     
    { 0x0001041b,    IDS_KEY_061 },     
    { 0x0001041f,    IDS_KEY_062 },     
    { 0x00010426,    IDS_KEY_063 },     
    { 0x00010427,    IDS_KEY_064 },     
    { 0x0001080c,    IDS_KEY_065 },     
    { 0x00011009,    IDS_KEY_066 },     
    { 0x00011809,    IDS_KEY_067 },     
    { 0x00020405,    IDS_KEY_068 },     
    { 0x00020408,    IDS_KEY_069 },     
    { 0x00020409,    IDS_KEY_070 },     
    { 0x00030408,    IDS_KEY_071 },     
    { 0x00030409,    IDS_KEY_072 },     
    { 0x00040408,    IDS_KEY_073 },     
    { 0x00040409,    IDS_KEY_074 },     
    { 0x00050408,    IDS_KEY_075 },     
    { 0x00060408,    IDS_KEY_076 },     
    { 0x00000411,    IDS_KEY_077 },     
    { 0x00000412,    IDS_KEY_078 },     
    { 0x00000404,    IDS_KEY_079 },     
    { 0x00000804,    IDS_KEY_080 },     
    { 0xE0010404,    IDS_KEY_081 },     
    { 0xE0010411,    IDS_KEY_082 },     
    { 0xE0010412,    IDS_KEY_083 },     
    { 0xE0010804,    IDS_KEY_084 },     
    { 0xE0020404,    IDS_KEY_085 },     
    { 0xE0020804,    IDS_KEY_086 },     
    { 0xE0030404,    IDS_KEY_087 },     
    { 0xE0030804,    IDS_KEY_088 },     
    { 0xE0040404,    IDS_KEY_089 },     
    { 0xE0050404,    IDS_KEY_090 },     
    { 0xE0050804,    IDS_KEY_091 },     
    { 0xE0060404,    IDS_KEY_092 },     
    { 0xE0070404,    IDS_KEY_093 },     
    { 0xE0080404,    IDS_KEY_094 },     
    { 0xE0090404,    IDS_KEY_095 },     
    { 0xE00E0804,    IDS_KEY_096 },
    { 0xE01F0404,    IDS_KEY_097 },     
};
static LONGRES lr_region_default [] =
{
    { -1,           IDS_ITL_USR },
    { 2,            IDS_GEO_001 },
    { 3,            IDS_GEO_002 },
    { 4,            IDS_GEO_003 },
    { 5,            IDS_GEO_004 },
    { 6,            IDS_GEO_005 },
    { 7,            IDS_GEO_006 },
    { 8,            IDS_GEO_007 },
    { 9,            IDS_GEO_008 },
    { 10,           IDS_GEO_009 },
    { 11,           IDS_GEO_010 },
    { 12,           IDS_GEO_011 },
    { 14,           IDS_GEO_012 },
    { 17,           IDS_GEO_013 },
    { 18,           IDS_GEO_014 },
    { 19,           IDS_GEO_015 },
    { 20,           IDS_GEO_016 },
    { 21,           IDS_GEO_017 },
    { 22,           IDS_GEO_018 },
    { 23,           IDS_GEO_019 },
    { 24,           IDS_GEO_020 },
    { 25,           IDS_GEO_021 },
    { 26,           IDS_GEO_022 },
    { 27,           IDS_GEO_023 },
    { 28,           IDS_GEO_024 },
    { 29,           IDS_GEO_025 },
    { 30,           IDS_GEO_026 },
    { 32,           IDS_GEO_027 },
    { 34,           IDS_GEO_028 },
    { 35,           IDS_GEO_029 },
    { 37,           IDS_GEO_030 },
    { 38,           IDS_GEO_031 },
    { 39,           IDS_GEO_032 },
    { 40,           IDS_GEO_033 },
    { 41,           IDS_GEO_034 },
    { 42,           IDS_GEO_035 },
    { 43,           IDS_GEO_036 },
    { 44,           IDS_GEO_037 },
    { 45,           IDS_GEO_038 },
    { 46,           IDS_GEO_039 },
    { 49,           IDS_GEO_040 },
    { 50,           IDS_GEO_041 },
    { 51,           IDS_GEO_042 },
    { 54,           IDS_GEO_043 },
    { 55,           IDS_GEO_044 },
    { 56,           IDS_GEO_045 },
    { 57,           IDS_GEO_046 },
    { 59,           IDS_GEO_047 },
    { 61,           IDS_GEO_048 },
    { 62,           IDS_GEO_049 },
    { 63,           IDS_GEO_050 },
    { 65,           IDS_GEO_051 },
    { 66,           IDS_GEO_052 },
    { 67,           IDS_GEO_053 },
    { 68,           IDS_GEO_054 },
    { 69,           IDS_GEO_055 },
    { 70,           IDS_GEO_056 },
    { 71,           IDS_GEO_057 },
    { 72,           IDS_GEO_058 },
    { 73,           IDS_GEO_059 },
    { 75,           IDS_GEO_060 },
    { 77,           IDS_GEO_061 },
    { 78,           IDS_GEO_062 },
    { 80,           IDS_GEO_063 },
    { 81,           IDS_GEO_064 },
    { 84,           IDS_GEO_065 },
    { 86,           IDS_GEO_066 },
    { 87,           IDS_GEO_067 },
    { 88,           IDS_GEO_068 },
    { 89,           IDS_GEO_069 },
    { 90,           IDS_GEO_070 },
    { 91,           IDS_GEO_071 },
    { 93,           IDS_GEO_072 },
    { 94,           IDS_GEO_073 },
    { 98,           IDS_GEO_074 },
    { 99,           IDS_GEO_075 },
    { 100,          IDS_GEO_076 },
    { 101,          IDS_GEO_077 },
    { 103,          IDS_GEO_078 },
    { 104,          IDS_GEO_079 },
    { 106,          IDS_GEO_080 },
    { 108,          IDS_GEO_081 },
    { 109,          IDS_GEO_082 },
    { 110,          IDS_GEO_083 },
    { 111,          IDS_GEO_084 },
    { 113,          IDS_GEO_085 },
    { 114,          IDS_GEO_086 },
    { 116,          IDS_GEO_087 },
    { 117,          IDS_GEO_088 },
    { 118,          IDS_GEO_089 },
    { 119,          IDS_GEO_090 },
    { 121,          IDS_GEO_091 },
    { 122,          IDS_GEO_092 },
    { 124,          IDS_GEO_093 },
    { 125,          IDS_GEO_094 },
    { 126,          IDS_GEO_095 },
    { 127,          IDS_GEO_096 },
    { 129,          IDS_GEO_097 },
    { 130,          IDS_GEO_098 },
    { 131,          IDS_GEO_099 },
    { 133,          IDS_GEO_100 },
    { 134,          IDS_GEO_101 },
    { 136,          IDS_GEO_102 },
    { 137,          IDS_GEO_103 },
    { 138,          IDS_GEO_104 },
    { 139,          IDS_GEO_105 },
    { 140,          IDS_GEO_106 },
    { 141,          IDS_GEO_107 },
    { 142,          IDS_GEO_108 },
    { 143,          IDS_GEO_109 },
    { 145,          IDS_GEO_110 },
    { 146,          IDS_GEO_111 },
    { 147,          IDS_GEO_112 },
    { 148,          IDS_GEO_113 },
    { 149,          IDS_GEO_114 },
    { 151,          IDS_GEO_115 },
    { 152,          IDS_GEO_116 },
    { 154,          IDS_GEO_117 },
    { 156,          IDS_GEO_118 },
    { 157,          IDS_GEO_119 },
    { 158,          IDS_GEO_120 },
    { 159,          IDS_GEO_121 },
    { 160,          IDS_GEO_122 },
    { 162,          IDS_GEO_123 },
    { 163,          IDS_GEO_124 },
    { 164,          IDS_GEO_125 },
    { 165,          IDS_GEO_126 },
    { 166,          IDS_GEO_127 },
    { 167,          IDS_GEO_128 },
    { 168,          IDS_GEO_129 },
    { 173,          IDS_GEO_130 },
    { 174,          IDS_GEO_131 },
    { 175,          IDS_GEO_132 },
    { 176,          IDS_GEO_133 },
    { 177,          IDS_GEO_134 },
    { 178,          IDS_GEO_135 },
    { 180,          IDS_GEO_136 },
    { 181,          IDS_GEO_137 },
    { 182,          IDS_GEO_138 },
    { 183,          IDS_GEO_139 },
    { 184,          IDS_GEO_228 },
    { 185,          IDS_GEO_141 },
    { 187,          IDS_GEO_142 },
    { 190,          IDS_GEO_143 },
    { 191,          IDS_GEO_144 },
    { 192,          IDS_GEO_145 },
    { 193,          IDS_GEO_146 },
    { 194,          IDS_GEO_147 },
    { 195,          IDS_GEO_148 },
    { 196,          IDS_GEO_149 },
    { 197,          IDS_GEO_150 },
    { 198,          IDS_GEO_151 },
    { 199,          IDS_GEO_152 },
    { 200,          IDS_GEO_153 },
    { 201,          IDS_GEO_154 },
    { 202,          IDS_GEO_155 },
    { 203,          IDS_GEO_156 },
    { 204,          IDS_GEO_157 },
    { 205,          IDS_GEO_158 },
    { 206,          IDS_GEO_159 },
    { 207,          IDS_GEO_160 },
    { 208,          IDS_GEO_161 },
    { 209,          IDS_GEO_162 },
    { 210,          IDS_GEO_163 },
    { 212,          IDS_GEO_164 },
    { 213,          IDS_GEO_165 },
    { 214,          IDS_GEO_166 },
    { 215,          IDS_GEO_167 },
    { 216,          IDS_GEO_168 },
    { 217,          IDS_GEO_169 },
    { 218,          IDS_GEO_170 },
    { 219,          IDS_GEO_171 },
    { 220,          IDS_GEO_172 },
    { 221,          IDS_GEO_173 },
    { 222,          IDS_GEO_174 },
    { 223,          IDS_GEO_175 },
    { 224,          IDS_GEO_176 },
    { 225,          IDS_GEO_177 },
    { 227,          IDS_GEO_178 },
    { 228,          IDS_GEO_179 },
    { 231,          IDS_GEO_180 },
    { 232,          IDS_GEO_181 },
    { 233,          IDS_GEO_182 },
    { 234,          IDS_GEO_183 },
    { 235,          IDS_GEO_184 },
    { 236,          IDS_GEO_185 },
    { 237,          IDS_GEO_186 },
    { 238,          IDS_GEO_187 },
    { 239,          IDS_GEO_188 },
    { 240,          IDS_GEO_189 },
    { 241,          IDS_GEO_190 },
    { 242,          IDS_GEO_191 },
    { 244,          IDS_GEO_192 },
    { 245,          IDS_GEO_193 },
    { 246,          IDS_GEO_194 },
    { 247,          IDS_GEO_195 },
    { 248,          IDS_GEO_196 },
    { 249,          IDS_GEO_197 },
    { 251,          IDS_GEO_198 },
    { 252,          IDS_GEO_199 },
    { 253,          IDS_GEO_200 },
    { 254,          IDS_GEO_201 },
    { 258,          IDS_GEO_202 },
    { 259,          IDS_GEO_203 },
    { 260,          IDS_GEO_204 },
    { 261,          IDS_GEO_205 },
    { 263,          IDS_GEO_206 },
    { 264,          IDS_GEO_207 },
    { 269,          IDS_GEO_208 },
    { 300,          IDS_GEO_209 },
    { 301,          IDS_GEO_210 },
    { 302,          IDS_GEO_211 },
    { 303,          IDS_GEO_212 },
    { 304,          IDS_GEO_213 },
    { 305,          IDS_GEO_214 },
    { 306,          IDS_GEO_215 },
    { 307,          IDS_GEO_216 },
    { 308,          IDS_GEO_217 },
    { 309,          IDS_GEO_218 },
    { 310,          IDS_GEO_219 },
    { 311,          IDS_GEO_220 },
    { 312,          IDS_GEO_221 },
    { 313,          IDS_GEO_222 },
    { 314,          IDS_GEO_223 },
    { 315,          IDS_GEO_224 },
    { 317,          IDS_GEO_225 },
    { 318,          IDS_GEO_226 },
    { 319,          IDS_GEO_227 },
    { 321,          IDS_GEO_229 },
    { 322,          IDS_GEO_230 },
    { 323,          IDS_GEO_231 },
    { 324,          IDS_GEO_232 },
    { 325,          IDS_GEO_233 },
    { 326,          IDS_GEO_234 },
    { 327,          IDS_GEO_235 },
    { 328,          IDS_GEO_236 },
    { 329,          IDS_GEO_237 },
    { 330,          IDS_GEO_238 },
    { 331,          IDS_GEO_239 },
    { 332,          IDS_GEO_240 },
    { 333,          IDS_GEO_241 },
    { 334,          IDS_GEO_242 },
    { 335,          IDS_GEO_243 },
    { 336,          IDS_GEO_244 },
    { 337,          IDS_GEO_245 },
    { 338,          IDS_GEO_246 },
    { 339,          IDS_GEO_247 },
    { 340,          IDS_GEO_248 },
    { 341,          IDS_GEO_249 },
    { 342,          IDS_GEO_250 },
    { 343,          IDS_GEO_251 },
    { 346,          IDS_GEO_252 },
    { 347,          IDS_GEO_253 },
    { 348,          IDS_GEO_254 },
    { 349,          IDS_GEO_255 },
    { 351,          IDS_GEO_256 },
    { 352,          IDS_GEO_257 },
    { 15126,        IDS_GEO_258 },
    { 19618,        IDS_GEO_259 },
    { 21242,        IDS_GEO_260 },
    { 7299303,      IDS_GEO_261 },
};

static LONGRES lr_location_default [] =
{
    { -1,            IDS_ITL_USR },
    { 0x00000401,    IDS_LOC_001 },
    { 0x00000402,    IDS_LOC_002 },
    { 0x00000403,    IDS_LOC_003 },
    { 0x00000404,    IDS_LOC_004 },
    { 0x00000405,    IDS_LOC_005 },
    { 0x00000406,    IDS_LOC_006 },
    { 0x00000407,    IDS_LOC_007 },
    { 0x00000408,    IDS_LOC_008 },
    { 0x00000409,    IDS_LOC_009 },
    { 0x0000040a,    IDS_LOC_010 },
    { 0x0000040b,    IDS_LOC_011 },
    { 0x0000040c,    IDS_LOC_012 },
    { 0x0000040d,    IDS_LOC_013 },
    { 0x0000040e,    IDS_LOC_014 },
    { 0x0000040f,    IDS_LOC_015 },
    { 0x00000410,    IDS_LOC_016 },
    { 0x00000411,    IDS_LOC_017 },
    { 0x00000412,    IDS_LOC_018 },
    { 0x00000413,    IDS_LOC_019 },
    { 0x00000414,    IDS_LOC_020 },
    { 0x00000415,    IDS_LOC_021 },
    { 0x00000416,    IDS_LOC_022 },
    { 0x00000418,    IDS_LOC_023 },
    { 0x00000419,    IDS_LOC_024 },
    { 0x0000041a,    IDS_LOC_025 },
    { 0x0000041b,    IDS_LOC_026 },
    { 0x0000041c,    IDS_LOC_027 },
    { 0x0000041d,    IDS_LOC_028 },
    { 0x0000041e,    IDS_LOC_029 },
    { 0x0000041f,    IDS_LOC_030 },
    { 0x00000420,    IDS_LOC_031 },
    { 0x00000421,    IDS_LOC_032 },
    { 0x00000422,    IDS_LOC_033 },
    { 0x00000423,    IDS_LOC_034 },
    { 0x00000424,    IDS_LOC_035 },
    { 0x00000425,    IDS_LOC_036 },
    { 0x00000426,    IDS_LOC_037 },
    { 0x00000427,    IDS_LOC_038 },
    { 0x00000429,    IDS_LOC_039 },
    { 0x0000042a,    IDS_LOC_040 },
    { 0x0000042b,    IDS_LOC_041 },
    { 0x0000042c,    IDS_LOC_042 },
    { 0x0000042d,    IDS_LOC_043 },
    { 0x0000042f,    IDS_LOC_044 },
    { 0x00000436,    IDS_LOC_045 },
    { 0x00000437,    IDS_LOC_046 },
    { 0x00000438,    IDS_LOC_047 },
    { 0x00000439,    IDS_LOC_048 },
    { 0x0000043e,    IDS_LOC_049 },
    { 0x0000043f,    IDS_LOC_050 },
    { 0x00000440,    IDS_LOC_051 },
    { 0x00000441,    IDS_LOC_052 },
    { 0x00000443,    IDS_LOC_053 },
    { 0x00000444,    IDS_LOC_054 },
    { 0x00000446,    IDS_LOC_055 },
    { 0x00000447,    IDS_LOC_056 },
    { 0x00000449,    IDS_LOC_057 },
    { 0x0000044a,    IDS_LOC_058 },
    { 0x0000044b,    IDS_LOC_059 },
    { 0x0000044e,    IDS_LOC_060 },
    { 0x0000044f,    IDS_LOC_061 },
    { 0x00000450,    IDS_LOC_062 },
    { 0x00000456,    IDS_LOC_063 },
    { 0x00000457,    IDS_LOC_064 },
    { 0x0000045a,    IDS_LOC_065 },
    { 0x00000465,    IDS_LOC_066 },
    { 0x00000801,    IDS_LOC_067 },
    { 0x00000804,    IDS_LOC_068 },
    { 0x00000807,    IDS_LOC_069 },
    { 0x00000809,    IDS_LOC_070 },
    { 0x0000080a,    IDS_LOC_071 },
    { 0x0000080c,    IDS_LOC_072 },
    { 0x00000810,    IDS_LOC_073 },
    { 0x00000813,    IDS_LOC_074 },
    { 0x00000814,    IDS_LOC_075 },
    { 0x00000816,    IDS_LOC_076 },
    { 0x0000081a,    IDS_LOC_077 },
    { 0x0000081d,    IDS_LOC_078 },
    { 0x0000082c,    IDS_LOC_079 },
    { 0x0000083e,    IDS_LOC_080 },
    { 0x00000843,    IDS_LOC_081 },
    { 0x00000c01,    IDS_LOC_082 },
    { 0x00000c04,    IDS_LOC_083 },
    { 0x00000c07,    IDS_LOC_084 },
    { 0x00000c09,    IDS_LOC_085 },
    { 0x00000c0a,    IDS_LOC_086 },
    { 0x00000c0c,    IDS_LOC_087 },
    { 0x00000c1a,    IDS_LOC_088 },
    { 0x00001001,    IDS_LOC_089 },
    { 0x00001004,    IDS_LOC_090 },
    { 0x00001007,    IDS_LOC_091 },
    { 0x00001009,    IDS_LOC_092 },
    { 0x0000100a,    IDS_LOC_093 },
    { 0x0000100c,    IDS_LOC_094 },
    { 0x00001401,    IDS_LOC_095 },
    { 0x00001404,    IDS_LOC_096 },
    { 0x00001407,    IDS_LOC_097 },
    { 0x00001409,    IDS_LOC_098 },
    { 0x0000140a,    IDS_LOC_099 },
    { 0x0000140c,    IDS_LOC_100 },
    { 0x00001801,    IDS_LOC_101 },
    { 0x00001809,    IDS_LOC_102 },
    { 0x0000180a,    IDS_LOC_103 },
    { 0x0000180c,    IDS_LOC_104 },
    { 0x00001c01,    IDS_LOC_105 },
    { 0x00001c09,    IDS_LOC_106 },
    { 0x00001c0a,    IDS_LOC_107 },
    { 0x00002001,    IDS_LOC_108 },
    { 0x00002009,    IDS_LOC_109 },
    { 0x0000200a,    IDS_LOC_110 },
    { 0x00002401,    IDS_LOC_111 },
    { 0x00002409,    IDS_LOC_112 },
    { 0x0000240a,    IDS_LOC_113 },
    { 0x00002801,    IDS_LOC_114 },
    { 0x00002809,    IDS_LOC_115 },
    { 0x0000280a,    IDS_LOC_116 },
    { 0x00002c01,    IDS_LOC_117 },
    { 0x00002c09,    IDS_LOC_118 },
    { 0x00002c0a,    IDS_LOC_119 },
    { 0x00003001,    IDS_LOC_120 },
    { 0x00003009,    IDS_LOC_121 },
    { 0x0000300a,    IDS_LOC_122 },
    { 0x00003401,    IDS_LOC_123 },
    { 0x00003409,    IDS_LOC_124 },
    { 0x0000340a,    IDS_LOC_125 },
    { 0x00003801,    IDS_LOC_126 },
    { 0x0000380a,    IDS_LOC_127 },
    { 0x00003c01,    IDS_LOC_128 },
    { 0x00003c0a,    IDS_LOC_129 },
    { 0x00004001,    IDS_LOC_130 },
    { 0x0000400a,    IDS_LOC_131 },
    { 0x0000440a,    IDS_LOC_132 },
    { 0x0000480a,    IDS_LOC_133 },
    { 0x00004c0a,    IDS_LOC_134 },
    { 0x0000500a,    IDS_LOC_135 },
};


static LONGRES lr_timezone_default [] =
{
    { -1,           IDS_ITL_USR },
    { 0,            IDS_TMZ_000 },
    { 1,            IDS_TMZ_001 },
    { 2,            IDS_TMZ_002 },
    { 3,            IDS_TMZ_003 },
    { 4,            IDS_TMZ_004 },
    { 10,           IDS_TMZ_010 },
    { 15,           IDS_TMZ_015 },
    { 20,           IDS_TMZ_020 },
    { 25,           IDS_TMZ_025 },
    { 30,           IDS_TMZ_030 },
    { 33,           IDS_TMZ_033 },
    { 35,           IDS_TMZ_035 },
    { 40,           IDS_TMZ_040 },
    { 45,           IDS_TMZ_045 },
    { 50,           IDS_TMZ_050 },
    { 55,           IDS_TMZ_055 },
    { 56,           IDS_TMZ_056 },
    { 60,           IDS_TMZ_060 },
    { 65,           IDS_TMZ_065 },
    { 70,           IDS_TMZ_070 },
    { 73,           IDS_TMZ_073 },
    { 75,           IDS_TMZ_075 },
    { 80,           IDS_TMZ_080 },
    { 83,           IDS_TMZ_083 },
    { 85,           IDS_TMZ_085 },
    { 90,           IDS_TMZ_090 },
    { 95,           IDS_TMZ_095 },    
    { 100,          IDS_TMZ_100 },
    { 105,          IDS_TMZ_105 },
    { 110,          IDS_TMZ_110 },
    { 113,          IDS_TMZ_113 },
    { 115,          IDS_TMZ_115 },
    { 120,          IDS_TMZ_120 },
    { 125,          IDS_TMZ_125 },
    { 130,          IDS_TMZ_130 },
    { 135,          IDS_TMZ_135 },
    { 140,          IDS_TMZ_140 },
    { 145,          IDS_TMZ_145 },
    { 150,          IDS_TMZ_150 },
    { 155,          IDS_TMZ_155 },
    { 158,          IDS_TMZ_158 },
    { 160,          IDS_TMZ_160 },
    { 165,          IDS_TMZ_165 },
    { 170,          IDS_TMZ_170 },
    { 175,          IDS_TMZ_175 },
    { 180,          IDS_TMZ_180 },
    { 185,          IDS_TMZ_185 },
    { 190,          IDS_TMZ_190 },
    { 193,          IDS_TMZ_193 },
    { 195,          IDS_TMZ_195 },
    { 200,          IDS_TMZ_200 },
    { 201,          IDS_TMZ_201 },
    { 203,          IDS_TMZ_203 },
    { 205,          IDS_TMZ_205 },
    { 207,          IDS_TMZ_207 },
    { 210,          IDS_TMZ_210 },
    { 215,          IDS_TMZ_215 },
    { 220,          IDS_TMZ_220 },
    { 225,          IDS_TMZ_225 },
    { 227,          IDS_TMZ_227 },
    { 230,          IDS_TMZ_230 },
    { 235,          IDS_TMZ_235 },
    { 240,          IDS_TMZ_240 },
    { 250,          IDS_TMZ_250 },
    { 255,          IDS_TMZ_255 },
    { 260,          IDS_TMZ_260 },
    { 265,          IDS_TMZ_265 },
    { 270,          IDS_TMZ_270 },
    { 275,          IDS_TMZ_275 },
    { 280,          IDS_TMZ_280 },
    { 285,          IDS_TMZ_285 },
    { 290,          IDS_TMZ_290 },
    { 300,          IDS_TMZ_300 },
};

#endif // _SCREENS2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\saveas.c ===
/****************************************************************************\

    SAVEAS.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "saveas / save" wizard page.

    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"
#include "appinst.h"


//
// Internal Define(s):
//

#define MAX_CONFIG_NAME 32

#define DIR_SBSI        _T("sbsi")
#define DIR_SBSI_SETUP  _T("setup")
#define FILE_SBSI_SETUP _T("setup.exe")
#define CMD_SBSI_SETUP  _T("-SMS -S -f1\"%s\\silent.iss\"")


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static BOOL OnSave(HWND);

static BOOL AddSbsiInstall(LPTSTR lpszShare);


//
// External Function(s):
//

LRESULT CALLBACK SaveAsDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        case WM_COMMAND:

            switch ( LOWORD(wParam) )
            {
                case IDOK:
                    if ( OnSave(hwnd))
                        EndDialog(hwnd, TRUE);
                    
                    break;

                case IDCANCEL:
                    EndDialog(hwnd, FALSE);
                    break;
            }
            return FALSE;
        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Set the limit
    //
    SendDlgItemMessage(hwnd, IDC_NAME_EDIT, EM_LIMITTEXT, MAX_CONFIG_NAME, 0);

    // Set the default config name.
    //
    SetWindowText(GetDlgItem(hwnd, IDC_NAME_EDIT), g_App.szConfigName);

    // Set the focus to the edit dialog
    //
    SetFocus(GetDlgItem(hwnd, IDC_NAME_EDIT));

    // Auto save if the auto run flag is set.
    //
    if ( GET_FLAG(OPK_AUTORUN) )
        PostMessage(GetDlgItem(hwnd, IDOK), BM_CLICK, 0, 0L);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static BOOL OnSave(HWND hwnd)
{
    INT     nStrLen;
    TCHAR   szConfigDir[MAX_PATH],
            szLocalTempDir[MAX_PATH],
            szSharePath[MAX_PATH],
            szUsername[256],
            szPassword[256],
            szFullConfigName[MAX_PATH];
    LPTSTR  lpFullConfigName;
    LPTSTR  lpConfigName;
    BOOL    bSameConfig  = FALSE;
    DWORD   dwSize;
    HRESULT hrCat;

    // Check to see if they want to use an existing config set.
    //

    // Copy the configuration set directory name into the config directory buffer,
    // makeing sure there is a trailing backslash and that we have a pointer
    // to the end of the path.
    //
    lstrcpyn(szConfigDir, g_App.szConfigSetsDir,AS(szConfigDir));
    AddPathN(szConfigDir, NULLSTR,AS(szConfigDir));
    lpConfigName = szConfigDir + (nStrLen = lstrlen(szConfigDir));

    // Now grab the text from the control.
    //
    GetWindowText(GetDlgItem(hwnd, IDC_NAME_EDIT), lpConfigName, STRSIZE(szConfigDir) - nStrLen );

    // Validate the config name.
    //
    if ( *lpConfigName == NULLCHR )
    {
        MsgBox(hwnd, IDS_NOCONFIG, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(GetDlgItem(hwnd, IDC_NAME_EDIT));
        return FALSE;
    }

    // get the full pathname, this will expand . or ..
    // if the entered name doesn't match the full name, we will consider this invalid and make user
    // either enter a valid filename or cancel
    dwSize=GetFullPathName(lpConfigName,AS(szFullConfigName),szFullConfigName,&lpFullConfigName);
    if (!dwSize || 
    	  (dwSize > AS(szFullConfigName)+1) ||
    	  lstrcmpi(lpFullConfigName, lpConfigName))
   {
        MsgBox(hwnd, IDS_CANNOTSAVE, IDS_APPNAME, MB_OK | MB_ICONERROR, lpConfigName);
        SetFocus(GetDlgItem(hwnd, IDC_NAME_EDIT));
        return FALSE;
    }

    // We need to make sure no ini files are cached and everything
    // is flushed to disk before we move the directory.
    //
    WritePrivateProfileString(NULL, NULL, NULL, g_App.szOpkWizIniFile);


    if (!lstrcmpi(g_App.szConfigName,lpConfigName))
        bSameConfig = TRUE;
   
    // Check to see if the directory exists.
    //
    if ( DirectoryExists(szConfigDir) )
    {
        // Check to see if we are updating an existing config or or ask the user
        // if they don't mind blowing away the existing directory.
        //
        if ( bSameConfig || MsgBox(hwnd, IDS_DIREXISTS, IDS_APPNAME, MB_YESNO | MB_ICONQUESTION, lpConfigName) == IDYES )
        {
            // Alright, remove the existing directory.
            //
            DeletePath(szConfigDir);
        }
        else
        {
            SetFocus(GetDlgItem(hwnd, IDC_NAME_EDIT));
            return FALSE;
        }
    }

    // Write out the config set name to the ini file
    //
    WritePrivateProfileString(INI_SEC_CONFIGSET, INI_SEC_CONFIG, lpConfigName, g_App.szOpkWizIniFile);

    // Need to also write the config set name to the winbom for WinPE.
    //
    WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WINPE_CFGSET, lpConfigName, g_App.szWinBomIniFile);

    // The password needs to have quotes around it.
    //
    lstrcpyn(szPassword, _T("\""),AS(szPassword));

    // Need to figure out what the share info is for the OPK stuff so we can write it out to
    // the winbom for WinPE.
    //
    if ( !GetShareSettings(szSharePath, AS(szSharePath), szUsername, AS(szUsername), szPassword + 1, AS(szPassword) - 1) )
    {
        if ( ( MsgBox(hwnd, IDS_ASK_SHARENOW, IDS_APPNAME, MB_OKCANCEL | MB_ICONWARNING | MB_APPLMODAL) == IDOK ) &&
             ( DistributionShareDialog(hwnd) ) )
        {
            GetShareSettings(szSharePath, AS(szSharePath), szUsername, AS(szUsername), szPassword + 1, AS(szPassword) - 1);
        }
        else
            MsgBox(hwnd, IDS_ERR_NOSHAREINFO, IDS_APPNAME, MB_ICONERROR);
    }

    // If there is a password, add the trailing quote.
    //
    if ( szPassword[1] )
        hrCat=StringCchCat(szPassword, AS(szPassword), _T("\""));
    else
        szPassword[0] = NULLCHR;

    // Now write out the settings.
    //
    // NTRAID#NTBUG9-531482-2002/02/27-stelo,swamip - Password stored in plain text
    WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WINPE_SRCROOT, szSharePath, g_App.szWinBomIniFile);
    WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WINPE_USERNAME, szUsername, g_App.szWinBomIniFile);
    WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WINPE_PASSWORD, szPassword, g_App.szWinBomIniFile);

    // If the user didn't specify custom credentials for the app preinstall stuff,
    // also write this stuff out to the factory section.
    //
    if ( GetPrivateProfileInt(INI_SEC_GENERAL, INI_KEY_APPCREDENTIALS, 0, g_App.szOpkWizIniFile) == 0 )
    {
        WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_USERNAME, szUsername, g_App.szWinBomIniFile);
        WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_VAL_WBOM_PASSWORD, szPassword, g_App.szWinBomIniFile);
    }

    // Once we have the distribution share settings finished, we need
    // to make sure they have a runonce entry to install the SBSI stuff.
    //
    AddSbsiInstall(szSharePath);

    // Trim any backslashes off the directory names so we don't fail the MoveFile
    //
    lstrcpyn(szLocalTempDir, g_App.szTempDir,AS(szLocalTempDir));
    StrRTrm(szConfigDir, CHR_BACKSLASH);
    StrRTrm(szLocalTempDir, CHR_BACKSLASH);

    // Make sure the current directory is somewhere that won't cause us problems.
    // This is to fix WinXP bug 324896.
    //
    SetCurrentDirectory(g_App.szOpkDir);

    // Now try to move the temp directory to the new config directory.
    //
    if ( !MoveFile(szLocalTempDir, szConfigDir) )
    {
        // We already tried to remove the existing directory, so we must
        // be failing for some other reason.
        //
        #ifndef DBG
        MsgBox(hwnd, IDS_CANNOTSAVE, IDS_APPNAME, MB_OK | MB_ICONERROR, szConfigDir);
        #else // DBG
        DBGOUT(NULL, _T("OPKWIZ:  MoveFile('%s', '%s') failed.  GLE=%d\n"), szLocalTempDir, szConfigDir, GetLastError());
        DBGMSGBOX(hwnd, _T("Cannot save the config set.\n\nMoveFile('%s', '%s') failed.  GLE=%d"), _T("OPKWIZ Debug Message"), MB_ERRORBOX, szLocalTempDir, szConfigDir, GetLastError());
        #endif // DBG
        return FALSE;
    }

    // Now that we have saved the config set, update the global data with the right paths.
    //
    lstrcpyn(g_App.szTempDir, szConfigDir,AS(g_App.szTempDir));
    SetConfigPath(g_App.szTempDir);
    lstrcpyn(g_App.szConfigName, lpConfigName,AS(g_App.szConfigName));

    // The last thing to do before we return is to write the ini setting to say this config set is finished.
    //
    WritePrivateProfileString(INI_SEC_CONFIGSET, INI_KEY_FINISHED, STR_ONE, g_App.szOpkWizIniFile);

    // Now that it is saved, check if they want to make a winpe floppy.
    //
    if ( IsDlgButtonChecked(hwnd, IDC_SAVEAS_WINPEFLOPPY) == BST_CHECKED )
        MakeWinpeFloppy(hwnd, g_App.szConfigName, g_App.szWinBomIniFile);

    return TRUE;
}

static BOOL AddSbsiInstall(LPTSTR lpszShare)
{
    BOOL        bRet            = FALSE,
                bChanged        = FALSE;
    LPAPPENTRY  lpAppList,
                lpAppSearch;
    APPENTRY    appSbsi;
    LPTSTR      lpszSbsiName    = AllocateString(NULL, IDS_INSTALLSBSI),
                lpszSbsiPath;
    TCHAR       szLocalSbsiPath[MAX_PATH];
    HRESULT hrPrintf;

    // We have to have a friendly name to make this work.
    //
    if ( NULL == lpszSbsiName )
    {
        return FALSE;
    }

    // Start by clearing out the SBSI app structure.
    //
    ZeroMemory(&appSbsi, sizeof(APPENTRY));

    // Set the friendly name.
    //
    lstrcpyn(appSbsi.szDisplayName, lpszSbsiName, AS(appSbsi.szDisplayName));
    FREE(lpszSbsiName);

    // The source path starts with the distribution share.
    //
    lstrcpyn(appSbsi.szSourcePath, lpszShare, AS(appSbsi.szSourcePath));

    // Need to save this pointer, we will use this path to make sure the
    // SBSI content is there.
    //
    lpszSbsiPath = appSbsi.szSourcePath + lstrlen(appSbsi.szSourcePath);

    // Now create the rest of the path to where the content should be.
    //
    AddPathN(appSbsi.szSourcePath, g_App.szLangDir + lstrlen(g_App.szOpkDir), AS(appSbsi.szSourcePath));
    AddPathN(appSbsi.szSourcePath, g_App.szLangName, AS(appSbsi.szSourcePath));
    AddPathN(appSbsi.szSourcePath, DIR_SBSI, AS(appSbsi.szSourcePath));
    AddPathN(appSbsi.szSourcePath, g_App.szSkuName, AS(appSbsi.szSourcePath));
    AddPathN(appSbsi.szSourcePath, DIR_SBSI_SETUP, AS(appSbsi.szSourcePath));

    // This is the name of the setup program.
    //
    lstrcpyn(appSbsi.szSetupFile, FILE_SBSI_SETUP, AS(appSbsi.szSetupFile));

    // This will create the command line for the file.
    //
    hrPrintf=StringCchPrintf(appSbsi.szCommandLine, AS(appSbsi.szCommandLine), CMD_SBSI_SETUP, appSbsi.szSourcePath);

    // This is the base install tech type.
    //
	appSbsi.itSectionType = installtechUndefined;

    // If there is a list, make sure our entry isn't already
    // there.
    //
    lpAppSearch = lpAppList = OpenAppList(g_App.szWinBomIniFile);
    while ( lpAppSearch && !bChanged)
    {
        if ( lstrcmp(lpAppSearch->szDisplayName, appSbsi.szDisplayName) == 0 )
        {
            if ( RemoveApp(&lpAppList, lpAppSearch) )
            {
                bChanged = TRUE;
            }
        }
        else
        {
            lpAppSearch = lpAppSearch->lpNext;
        }
    }

    // Create the local path to the setup file where the SBSI content should
    // be.  Only if that exists to we add the app.
    //
    lstrcpyn(szLocalSbsiPath, g_App.szOpkDir, AS(szLocalSbsiPath));
    AddPathN(szLocalSbsiPath, lpszSbsiPath, AS(szLocalSbsiPath));
    AddPathN(szLocalSbsiPath, appSbsi.szSetupFile, AS(szLocalSbsiPath));

    // Now try to insert our SBSI stuff to the end of the list.
    //
    if ( FileExists(szLocalSbsiPath) &&
         InsertApp(&lpAppList, &appSbsi) )
    {
        bChanged = TRUE;
        bRet = TRUE;
    }

    // Save and close our list.
    //
    if ( lpAppList )
    {
        // Only need to save if we changed something.
        //
        if ( bChanged )
        {
            if ( !SaveAppList(lpAppList, g_App.szWinBomIniFile, g_App.szOpkWizIniFile) )
            {
                bRet = FALSE;
            }
        }

        // This will free up the memory for the list.
        //
        CloseAppList(lpAppList);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\screens2.c ===
/****************************************************************************\

    SCREENS2.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "screenstwo" wizard page.

    10/99 - Stephen Lodwick (A-STELO)
        Added this page
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"
#include "screens2.h"


//
// Internal Defined Value(s):
//

#define INI_KEY_REGIONAL        _T("INTL_Settings")
#define INI_KEY_TIMEZONE        _T("TimeZone")
#define INI_KEY_TIMEZONEVALUE   _T("TimeZoneValue")
#define INI_SEC_TIMEZONES       _T("TimeZones")
#define INI_KEY_DEFAULTLOCALE   _T("DefaultLanguage")
#define INI_SEC_LOCALE          _T("Languages")
#define INI_KEY_DEFAULTREGION   _T("DefaultRegion")
#define INI_SEC_REGION          _T("Regions")
#define INI_KEY_DEFAULTKEYBD    _T("DefaultKeyboard")
#define INI_SEC_KEYBD           _T("Keyboards")


//
// Internal Structure(s):
//

typedef struct _OOBEOPTIONS
{
    INT         ListBox;
    LPTSTR      lpDefaultKey;
    LPTSTR      lpAlternateSection;
    LPTSTR      lpOutputFormat;
    LPLONGRES   lplrListItems;
    INT         dwListSize;
} OOBEOPTIONS, *LPOOBEOPTIONS;


//
// Global Define(s):
//

static OOBEOPTIONS g_OobeOptions [] =
{
    { IDC_TIMEZONE, INI_KEY_TIMEZONEVALUE, INI_SEC_TIMEZONES, _T("%03lu"), lr_timezone_default, AS(lr_timezone_default) }, 
    { IDC_LOCALE,   INI_KEY_DEFAULTLOCALE, INI_SEC_LOCALE,    _T("%x"),    lr_location_default, AS(lr_location_default) }, 
    { IDC_REGION,   INI_KEY_DEFAULTREGION, INI_SEC_REGION,    _T("%d"),    lr_region_default,   AS(lr_region_default)   }, 
    { IDC_KEYBOARD, INI_KEY_DEFAULTKEYBD,  INI_SEC_KEYBD,     _T("%x"),    lr_keyboard_default, AS(lr_keyboard_default) }, 
};


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnNext(HWND);
static void LoadListBox(HWND, OOBEOPTIONS);

//
// External Function(s):
//

LRESULT CALLBACK ScreensTwoDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    OnNext(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_SCREENSTWO;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    INT i;

    // Decide if we check Regional Settings checkbox
    //
    if (( GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_REGIONAL, 0, GET_FLAG(OPK_BATCHMODE) ?  g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile) == 1 ) )
        CheckDlgButton(hwnd, IDC_SCREEN_REGIONAL, TRUE);

    // Decide if we check Time Zone Settings checkbox
    //
    if (( GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_TIMEZONE, 1, GET_FLAG(OPK_BATCHMODE) ?  g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile) == 1 ) )
        CheckDlgButton(hwnd, IDC_SCREEN_TIMEZONE, TRUE);


    // Loop through each of the list boxes and load them
    //
    for( i = 0; i < AS(g_OobeOptions); i++)
    {
        // Load the list box using the items in the global oobe structure
        //
        LoadListBox(hwnd, g_OobeOptions[i]);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnNext(HWND hwnd)
{
    INT iReturn,
        i;
    LONG lItemData = -1;
    TCHAR szItemData[MAX_PATH] = NULLSTR;
    HRESULT hrPrintf;


    // Loop through each of the OOBE options and save them off
    //
    for( i = 0; i < AS(g_OobeOptions); i++)
    {
        // Set the default values
        //
        lItemData = -1;
        szItemData[0] = NULLCHR;

        // Check to see what the current item selection is
        //
        if ( (iReturn = (INT) SendDlgItemMessage(hwnd, g_OobeOptions[i].ListBox, CB_GETCURSEL, (WPARAM) 0, (LPARAM) 0)) != CB_ERR )
        {
            // Get the DefaultLocale
            //
            lItemData = (INT) SendDlgItemMessage(hwnd, g_OobeOptions[i].ListBox, CB_GETITEMDATA, (WPARAM) iReturn, (LPARAM) 0);
        
            // Convert the item data from a long to a string
            //
            if ( lItemData != CB_ERR )
                hrPrintf=StringCchPrintf(szItemData, AS(szItemData), g_OobeOptions[i].lpOutputFormat, lItemData);
        }
        
        // Write out the settings to the INF files
        //
        WritePrivateProfileString(INI_SEC_OPTIONS, g_OobeOptions[i].lpDefaultKey, szItemData, g_App.szOobeInfoIniFile);
        WritePrivateProfileString(INI_SEC_OPTIONS, g_OobeOptions[i].lpDefaultKey, szItemData, g_App.szOpkWizIniFile);
    }

    // Write regional settings to the INF files
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_REGIONAL, ( IsDlgButtonChecked(hwnd, IDC_SCREEN_REGIONAL) == BST_CHECKED ) ? STR_ONE : STR_ZERO, g_App.szOobeInfoIniFile);
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_REGIONAL, ( IsDlgButtonChecked(hwnd, IDC_SCREEN_REGIONAL) == BST_CHECKED ) ? STR_ONE : STR_ZERO, g_App.szOpkWizIniFile);

    // Write time zone settings to the INF files
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_TIMEZONE, ( IsDlgButtonChecked(hwnd, IDC_SCREEN_TIMEZONE) == BST_CHECKED ) ? STR_ONE : STR_ZERO, g_App.szOobeInfoIniFile);
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_TIMEZONE, ( IsDlgButtonChecked(hwnd, IDC_SCREEN_TIMEZONE) == BST_CHECKED ) ? STR_ONE : STR_ZERO, g_App.szOpkWizIniFile);

}

static void LoadListBox(HWND hwnd, OOBEOPTIONS OobeOptions)
{
    INT         index               = -1,
                iReturn;
    LPTSTR      lpBuffer            = NULL;
    HINF        hInf                = NULL;
    LONG        lReturn             = 0;
    DWORD       dwErr               = 0,
                dwItemsAdded        = 0;
    BOOL        bLoop               = 0;
    INFCONTEXT  InfContext;
    TCHAR       szBuffer[MAX_PATH]      = NULLSTR,
                szDefaultIndex[MAX_PATH]= NULLSTR,
                szTemp[MAX_PATH]        = NULLSTR;
    HRESULT hrPrintf;

    // If we don't have any of the following values, we must return
    //
    if ( !hwnd || !OobeOptions.ListBox || !OobeOptions.lplrListItems || !OobeOptions.dwListSize || !OobeOptions.lpDefaultKey )
        return;

    // Get the default value for this field from the INF file
    //
    GetPrivateProfileString(INI_SEC_OPTIONS, OobeOptions.lpDefaultKey, NULLSTR, szDefaultIndex, AS(szDefaultIndex), GET_FLAG(OPK_BATCHMODE) ?  g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile);

    // We need to always add the default key, "User Default"
    //
    if ( lpBuffer = AllocateString(NULL, OobeOptions.lplrListItems[0].uId) )
    {
        // If we allocated the string add the item to the list
        //
        if ( (iReturn = (INT) SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_ADDSTRING, (WPARAM) 0, (LPARAM) lpBuffer)) >= 0 )
        {
            SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_SETCURSEL, (WPARAM) iReturn, (LPARAM) 0);

            // Add associated data along with the string to the combo box
            //
            SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_SETITEMDATA, (WPARAM) iReturn, (LPARAM) OobeOptions.lplrListItems[0].Index);
        }
        FREE(lpBuffer);
    }

    // Open the inf file and determine if the section that we're looking for is there.
    //
    if ( OobeOptions.lpAlternateSection && *(OobeOptions.lpAlternateSection) && (hInf = SetupOpenInfFile(g_App.szOpkInputInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, &dwErr)) != INVALID_HANDLE_VALUE )
    {
        // Loop through each item in the list
        //
        for ( bLoop = SetupFindFirstLine(hInf, OobeOptions.lpAlternateSection, NULL, &InfContext);
              bLoop;
              bLoop = SetupFindNextLine(&InfContext, &InfContext) )
        {
            // Get the string field and the number representing it and add it to the list
            //
            if ( (SetupGetStringField(&InfContext, 1, szBuffer, AS(szBuffer), NULL)) && (szBuffer[0]) && 
                 (SetupGetIntField(&InfContext, 2, &index)) && ( index >= 0 ) &&
                 ((iReturn = (INT) SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_ADDSTRING, (WPARAM) 0, (LPARAM) szBuffer)) >= 0)
               )
            {                
                // Add associated data along with the string to the combo box
                //
                SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_SETITEMDATA, (WPARAM) iReturn, (LPARAM) index);

                // Format the current value so that we can compare it to the default value
                //
                hrPrintf=StringCchPrintf(szTemp, AS(szTemp), OobeOptions.lpOutputFormat, index);

                // Compare the default value to the current value just added to the list box
                //
                if ( lstrcmpi(szTemp, szDefaultIndex) == 0 )
                {
                    // Set this as the default value
                    //
                    SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_SETCURSEL, (WPARAM) iReturn, (LPARAM) 0);    
                }

                dwItemsAdded++;
            }
        }
     
        SetupCloseInfFile(hInf);
    }
    
    // If we didn't add items through the inf, use the defaults in the resource
    //
    if ( !dwItemsAdded )
    {
        // Loop through each of the items in the list
        //
        for ( index=1; index < (OobeOptions.dwListSize); index++ )
        {
            // Allocate a string for the resource identifier and add it to the list
            //
            if ( (lpBuffer = AllocateString(NULL, OobeOptions.lplrListItems[index].uId)) &&
                 ((iReturn = (INT) SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_ADDSTRING, (WPARAM) 0, (LPARAM) lpBuffer)) >= 0))
            {                
                // Add associated data along with the string to the combo box
                //
                SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_SETITEMDATA, (WPARAM) iReturn, (LPARAM) OobeOptions.lplrListItems[index].Index);

                // Format the current value so that we can compare it to the default value
                //
                hrPrintf=StringCchPrintf(szTemp, AS(szTemp), OobeOptions.lpOutputFormat, OobeOptions.lplrListItems[index].Index);

                // Compare the default value to the current value just added to the list box
                //
                if ( lstrcmpi(szTemp, szDefaultIndex) == 0 )
                {
                    // Set this as the default value
                    //
                    SendDlgItemMessage(hwnd, OobeOptions.ListBox, CB_SETCURSEL, (WPARAM) iReturn, (LPARAM) 0);    
                }
            }

            // Clean up the allocated string
            //
            FREE(lpBuffer);

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\screens.c ===
/****************************************************************************\

    SCREENS.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "screens" wizard page.

    3/99 - Jason Cohen (JCOHEN)
        Updated this old source file for the OPK Wizard as part of the OOBE
        update.  This file was totally re-written.

    5/99 - Jason Cohen (JCOHEN)
        Got rid of the global variables and cleaned up the code some more.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

    02/2000 - Jason Cohen (JCOHEN)
        Added back in the mouse stuff since the OOBE guys now decided that
        the still need it.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define FILE_MOUSE_HTM          _T("MOUSE.HTM")
#define FILE_IME_HTM            _T("IMETUT1.HTM")

#define DIR_MOUSE               DIR_OEM_OOBE _T("\\HTML\\Mouse")
#define DIR_IME                 DIR_OEM_OOBE _T("\\HTML\\IME")


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void OnCommand(HWND, INT, HWND, UINT);
static BOOL OnNext(HWND hwnd);
static void EnableControls(HWND, UINT);
static BOOL BrowseCopy(HWND hwnd, LPTSTR lpszPath, INT id, BOOL bBatch);


//
// External Function(s):
//

LRESULT CALLBACK ScreensDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_SCREENS;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szCustDir[MAX_PATH]         = NULLSTR,
            szCustomIMEDir[MAX_PATH]    = NULLSTR;
    DWORD   dwUseIMETutorial;


    //
    // Mouse tutorial:
    //

    // Check if mouse tutor is in use!
    //
    if ( GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_MOUSE, 0, GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szOobeInfoIniFile) == 2 )
    {
        // 2 is a custom mouse tutorial, need to get the custom
        // dir.
        //
        CheckRadioButton(hwnd, IDC_MOUSE_NO, IDC_MOUSE_CUSTOM, IDC_MOUSE_CUSTOM);
        GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_CUSTMOUSE, NULLSTR, szCustDir, AS(szCustDir), g_App.szOpkWizIniFile);

        // Must simulate a copy if this is batch mode.
        //
        if ( GET_FLAG(OPK_BATCHMODE) )
            BrowseCopy(hwnd, szCustDir, IDC_MOUSE_BROWSE, TRUE);
    }
    else
    {
        // 0, or default is no mouse tutorial.
        //
        CheckRadioButton(hwnd, IDC_MOUSE_NO, IDC_MOUSE_CUSTOM, IDC_MOUSE_NO);
    }        

    // Now init the mouse tutorial fields.
    //
    SetDlgItemText(hwnd, IDC_MOUSE_DIR, szCustDir);
    EnableControls(hwnd, IDC_MOUSE_CUSTOM);


    //
    // IME TUTORIAL
    //

    // Do we display the tutorial
    //
    if ( !GET_FLAG(OPK_DBCS) )
    {
        // Check the default radio button for Non-DBCS builds
        //
        CheckRadioButton(hwnd, IDC_IME_NO, IDC_IME_CUSTOM, IDC_IME_NO);

        // Hide the options is not DBCS
        //
        ShowEnableWindow(GetDlgItem(hwnd, IDC_IME_NO), FALSE);
        ShowEnableWindow(GetDlgItem(hwnd, IDC_IME_CUSTOM), FALSE);
        ShowEnableWindow(GetDlgItem(hwnd, IDC_STATIC_IME), FALSE);
        ShowEnableWindow(GetDlgItem(hwnd, IDC_IME_DIR), FALSE);
        ShowEnableWindow(GetDlgItem(hwnd, IDC_IME_BROWSE), FALSE);
    }
    else
    {
        // Get the custom directory from the opkwiz.inf
        //
        GetPrivateProfileString(INI_SEC_OPTIONS, INI_KEY_IMECUSTDIR, NULLSTR, szCustomIMEDir, AS(szCustomIMEDir), g_App.szOpkWizIniFile);

        // See if we are going to use the tutorial
        //
        dwUseIMETutorial = GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_IMETUT, 0, GET_FLAG(OPK_BATCHMODE) ? g_App. szOpkWizIniFile : g_App.szOobeInfoIniFile);

        // Select the proper IME Tutorial
        //
        if ( szCustomIMEDir[0] && dwUseIMETutorial )
        {
            CheckRadioButton(hwnd, IDC_IME_NO, IDC_IME_CUSTOM, IDC_IME_CUSTOM);

            // Must simulate a copy if this is batch mode.
            //
            if ( GET_FLAG(OPK_BATCHMODE) )
                BrowseCopy(hwnd, szCustDir, IDC_IME_BROWSE, TRUE);
        }
        else
            CheckRadioButton(hwnd, IDC_IME_NO, IDC_IME_CUSTOM, IDC_IME_NO);

        SetDlgItemText(hwnd, IDC_IME_DIR, szCustomIMEDir);
        EnableControls(hwnd, IDC_IME_CUSTOM);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    TCHAR szPath[MAX_PATH];

    switch ( id )
    {
        case IDC_MOUSE_NO:
        case IDC_MOUSE_CUSTOM:
        case IDC_IME_NO:
        case IDC_IME_CUSTOM:
            EnableControls(hwnd, id);
            break;

        case IDC_MOUSE_BROWSE:
        case IDC_IME_BROWSE:

            // Try to use their current folder as the default.
            //
            szPath[0] = NULLCHR;
            GetDlgItemText(hwnd, ( id == IDC_MOUSE_BROWSE ) ? IDC_MOUSE_DIR : IDC_IME_DIR, szPath, AS(szPath));

            // If there is no current folder, just use the global browse default.
            //
            if ( szPath[0] == NULLCHR )
                lstrcpyn(szPath, g_App.szBrowseFolder,AS(szPath));

            // Now bring up the browse for folder dialog.
            //
            if ( BrowseForFolder(hwnd, IDS_BROWSEFOLDER, szPath, BIF_RETURNONLYFSDIRS | BIF_EDITBOX | BIF_VALIDATE) )
                BrowseCopy(hwnd, szPath, id, FALSE);
            break;
    }
}

static BOOL OnNext(HWND hwnd)
{
    TCHAR   szFullPath[MAX_PATH],
            szImeDir[MAX_PATH]      = NULLSTR,
            szMouseDir[MAX_PATH]    = NULLSTR;
    LPTSTR  lpMouseOption;


    //
    // Verify the mouse tutorial settings.
    //

    // Create the path to the directory that needs to be removed, or
    // must exist depending on the option selected.
    //
    lstrcpyn(szFullPath, g_App.szTempDir,AS(szFullPath));
    AddPathN(szFullPath, DIR_MOUSE,AS(szFullPath));

    // If we are doing a custom mouse tutorial, check for a valid directory.
    // Otherwise, setup the correct values to write to the config files.
    //
    if ( IsDlgButtonChecked(hwnd, IDC_MOUSE_CUSTOM) == BST_CHECKED )
    {
        // Make sure we have a valid directory.
        //
        GetDlgItemText(hwnd, IDC_MOUSE_DIR, szMouseDir, AS(szMouseDir));
        if ( !( szMouseDir[0] && DirectoryExists(szFullPath) ) )
        {
            MsgBox(GetParent(hwnd), IDS_ERR_MOUSEDIR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_MOUSE_BROWSE));
            return FALSE;
        }

        // This is what we write out to the oobeinfo and batch file.
        //
        lpMouseOption = STR_2;
    }
    else
    {
        // This is what we write out to the oobeinfo and batch file.
        //
        lpMouseOption = STR_0;

        // Remove the custom files that might already be there.
        //
        if ( DirectoryExists(szFullPath) )
            DeletePath(szFullPath);

        // Clear out the display box(es) so we know the files are
        // all gone now.
        //
        SetDlgItemText(hwnd, IDC_MOUSE_DIR, NULLSTR);
    }


    //
    // Verify the IME tutorial settings.
    //

    // Create the path to the directory that needs to be removed, or
    // must exist depending on the option selected.
    //
    lstrcpyn(szFullPath, g_App.szTempDir,AS(szFullPath));
    AddPathN(szFullPath, DIR_IME,AS(szFullPath));

    // If we are doing a custom IME tutorial, check for a valid directory.
    //
    if ( ( GET_FLAG(OPK_DBCS) ) &&
         ( IsDlgButtonChecked(hwnd, IDC_IME_CUSTOM) == BST_CHECKED ) )
    {
        // Make sure we have a valid directory.
        //
        GetDlgItemText(hwnd, IDC_IME_DIR, szImeDir, AS(szImeDir));
        if ( !( szImeDir[0] && DirectoryExists(szFullPath) ) )
        {
            MsgBox(GetParent(hwnd), IDS_ERR_IMEDIR, IDS_APPNAME, MB_ERRORBOX);
            SetFocus(GetDlgItem(hwnd, IDC_IME_BROWSE));
            return FALSE;
        }
    }
    else
    {
        // Remove the files that might be there.
        //
        if ( DirectoryExists(szFullPath) )
            DeletePath(szFullPath);

        // Clear out the display box(es) so we know the files are
        // all gone now.
        //
        SetDlgItemText(hwnd, IDC_IME_DIR, NULLSTR);
    }


    //
    // Save the mouse tutorial settings:
    //

    // Write the custom mouse path.
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_CUSTMOUSE, szMouseDir[0] ? szMouseDir : NULL, g_App.szOpkWizIniFile);

    // Write the data back to the config files.
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_MOUSE, lpMouseOption, g_App.szOobeInfoIniFile);
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_MOUSE, lpMouseOption, g_App.szOpkWizIniFile);


    //
    // Save the IME tutorial settings:
    //

    // If the IME tutorial should not be used, then write out STR_ZERO
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_IMETUT, szImeDir[0] ? STR_1 : STR_0, g_App.szOobeInfoIniFile);
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_IMETUT, szImeDir[0] ? STR_1 : STR_0, g_App.szOpkWizIniFile);

    // Write out the IME tutorial custom directory if it's being used
    //
    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_IMECUSTDIR, szImeDir[0] ? szImeDir : NULL, g_App.szOpkWizIniFile);


    // Always return TRUE if we got this far.
    //
    return TRUE;
}

static void EnableControls(HWND hwnd, UINT uId)
{
    BOOL fEnable;

    switch ( uId )
    {
        case IDC_MOUSE_NO:
        case IDC_MOUSE_CUSTOM:

            fEnable = ( IsDlgButtonChecked(hwnd, IDC_MOUSE_CUSTOM) == BST_CHECKED );
            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_MOUSE), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_MOUSE_DIR), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_MOUSE_BROWSE), fEnable);
            break;

        case IDC_IME_NO:
        case IDC_IME_CUSTOM:

            fEnable = ( IsDlgButtonChecked(hwnd, IDC_IME_CUSTOM) == BST_CHECKED );
            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_IME), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_IME_DIR), fEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_IME_BROWSE), fEnable);
            break;
    }
}

static BOOL BrowseCopy(HWND hwnd, LPTSTR lpszPath, INT id, BOOL bBatch)
{
    BOOL    bRet = FALSE;
    TCHAR   szDst[MAX_PATH];
    LPTSTR  lpEnd,
            lpFilename;

    // If the pressed OK, save off the path in our last browse folder buffer.
    //
    if ( !bBatch )
        lstrcpyn(g_App.szBrowseFolder, lpszPath, AS(g_App.szBrowseFolder));

    // We need to create the path to the destination directory where
    // we are going to copy all the files.
    //
    lstrcpyn(szDst, g_App.szTempDir,AS(szDst));
    AddPathN(szDst, ( id == IDC_MOUSE_BROWSE ) ? DIR_MOUSE : DIR_IME,AS(szDst));

    // Check for required file.
    //
    lpEnd = lpszPath + lstrlen(lpszPath);
    lpFilename = ( id == IDC_MOUSE_BROWSE ) ? FILE_MOUSE_HTM : FILE_IME_HTM;
    AddPath(lpszPath, lpFilename);
    if ( ( bBatch ) ||
         ( FileExists(lpszPath) ) ||
         ( MsgBox(GetParent(hwnd), ( id == IDC_MOUSE_BROWSE ) ? IDS_ERR_MOUSEFILES : IDS_ERR_IMEFILES, IDS_APPNAME, MB_ICONSTOP | MB_OKCANCEL | MB_APPLMODAL, lpFilename) == IDOK ) )
    {
        // Chop that file name off so we just have the path again.
        //
        *lpEnd = NULLCHR;

        // Make sure that any exsisting files are removed.
        //
        if ( DirectoryExists(szDst) )
            DeletePath(szDst);

        // Now try to copy all the new files over.
        //
        if ( !CopyDirectoryDialog(g_App.hInstance, hwnd, lpszPath, szDst) )
        {
            DeletePath(szDst);
            MsgBox(GetParent(hwnd), IDS_ERR_COPYINGFILES, IDS_APPNAME, MB_ERRORBOX, szDst[0], lpszPath);
            *lpszPath = NULLCHR;
        }
        else
            bRet = TRUE;

        // Reset the path display boxes.
        //
        SetDlgItemText(hwnd, ( id == IDC_MOUSE_BROWSE ) ? IDC_MOUSE_DIR : IDC_IME_DIR, lpszPath);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\share.c ===
/****************************************************************************\

    SHARE.C / OPK Wizard (SETUPMGR.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Distribution Share" dialog page.

    01/01 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard.  It includes the new
        ability to set the account and share information in the WinPE section
        of the WINBOM file.  Will also automatically share out the local
        folder.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include <shgina.h>   // ILocalMachine
#include <aclapi.h>
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//

#define INI_SEC_SHARE           _T("DistShare")
#define INI_KEY_SHARE_PATH      _T("Folder")
#define INI_KEY_SHARE_USERNAME  _T("Username")
#define INI_KEY_SHARE_PASSOWRD  _T("Password")


//
// Internal Function Prototype(s):
//

LRESULT CALLBACK ShareDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam);
static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify);
static BOOL OnOk(HWND hwnd);
static void EnableControls(HWND hwnd);
static PSECURITY_DESCRIPTOR CreateShareAccess(LPTSTR lpUsername, LPTSTR lpDomain, PSID * lppsid, PACL * lppacl);
static BOOL IsLocalShare(LPTSTR lpszUnc);
static BOOL GuestAccount(BOOL bSet);
static PSID GetAccountSid(LPCTSTR lpszUserName);
static PSID GetWorldSid(VOID);
static BOOL AddDirAce(PACL pacl, ACCESS_MASK Mask, PSID psid);
static BOOL SetDirectoryPermissions(LPTSTR lpDirectory, PSID psid, ACCESS_MASK dwMask);


//
// External Function(s):
//

BOOL DistributionShareDialog(HWND hwndParent)
{
    // ISSUE-2002/02/27-stelo,swamip - We need to check for -1 Error condition also.
    return ( DialogBox(g_App.hInstance, MAKEINTRESOURCE(IDD_SHARE), hwndParent, ShareDlgProc) != 0 );
}

// NOTE: it is assumes lpszPath points to a buffer at least MAX_PATH in length
BOOL GetShareSettings(LPTSTR lpszPath, DWORD cbszPath, LPTSTR lpszUsername, DWORD cbszUserName, LPTSTR lpszPassword, DWORD cbszPassword)
{
    BOOL bRet = TRUE;

    // First try to get the path from the ini file.
    //
    *lpszPath = NULLCHR;
    GetPrivateProfileString(INI_SEC_SHARE, INI_KEY_SHARE_PATH, NULLSTR, lpszPath, cbszPath, g_App.szSetupMgrIniFile);
    if ( *lpszPath == NULLCHR )
    {
        //
        // Just create the default network path to use with this computer
        // name and either the share name of the installed directory or
        // just the directory name if it isn't shared.
        //

        // Check if the install directory is shared and create the share name
        // path if it is.
        //
        if ( !IsFolderShared(g_App.szOpkDir, lpszPath, cbszPath) )
        {
            TCHAR   szOpkDir[MAX_PATH],
                    szFullPath[MAX_PATH]    = NULLSTR;
            LPTSTR  lpFilePart              = NULL;
            HRESULT hrCat;

            // Need the path to the OPK dir w/o a trailing backslash (very important,
            // or we don't get the file part pointer back from GetFullPathName().
            //
            lstrcpyn(szOpkDir, g_App.szOpkDir,AS(szOpkDir));
            StrRTrm(szOpkDir, CHR_BACKSLASH);

            // It isn't shared, so just use the actual name of the install directory.
            //
            // Note: szFullPath is MAX_PATH, so this should not overflow
            if ( GetFullPathName(szOpkDir, AS(szFullPath), szFullPath, &lpFilePart) && szFullPath[0] && lpFilePart )
                hrCat=StringCchCat(lpszPath, MAX_PATH, lpFilePart);
            else
                hrCat=StringCchCat(lpszPath, MAX_PATH, INI_VAL_WINPE_SHARENAME);

            // We have to return false because the folder isn't shared.
            //
            bRet = FALSE;
        }
    }

    // Get the user name and password from the registry.
    //
    *lpszUsername = NULLCHR;
    *lpszPassword = NULLCHR;
    GetPrivateProfileString(INI_SEC_SHARE, INI_KEY_SHARE_USERNAME, NULLSTR, lpszUsername, cbszUserName, g_App.szSetupMgrIniFile);
    GetPrivateProfileString(INI_SEC_SHARE, INI_KEY_SHARE_PASSOWRD, NULLSTR, lpszPassword, cbszPassword, g_App.szSetupMgrIniFile);

    // If we have an empty string, use guest
    //
    if ( *lpszUsername == NULLCHR )
        lstrcpyn(lpszUsername, _T("guest"), cbszUserName);

    // We only return TRUE if we actually got a path from the registry
    // or verified that the folder we installed to is shared.
    //
    return bRet;
}


//
// Internal Function(s):
//

LRESULT CALLBACK ShareDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_CLOSE:
            EndDialog(hwnd, 0);
            return FALSE;

        default:
            return FALSE;
    }

    return TRUE;
}

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    TCHAR   szPath[MAX_PATH],
            szUsername[256],
            szPassword[256];

    // Get the share settings and populate the edit boxes.
    //
    GetShareSettings(szPath, AS(szPath), szUsername, AS(szUsername), szPassword, AS(szPassword));

    // If we are going to use guest, we do not want to display in the username control
    //
    if (!LSTRCMPI(szUsername, _T("guest"))) {
        szUsername[0] = NULLCHR;
        CheckRadioButton(hwnd, IDC_SHARE_ACCOUNT_GUEST, IDC_SHARE_ACCOUNT_SPECIFY, IDC_SHARE_ACCOUNT_GUEST);
    } else {
        // otherwise, default to account specify
        CheckRadioButton(hwnd, IDC_SHARE_ACCOUNT_GUEST, IDC_SHARE_ACCOUNT_SPECIFY, IDC_SHARE_ACCOUNT_SPECIFY);
    }

    SetDlgItemText(hwnd, IDC_SHARE_PATH, szPath);
    SetDlgItemText(hwnd, IDC_SHARE_USERNAME, szUsername);
    SetDlgItemText(hwnd, IDC_SHARE_PASSWORD, szPassword);
    SetDlgItemText(hwnd, IDC_SHARE_CONFIRM, szPassword);

    EnableControls(hwnd);

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    switch ( id )
    {       
        case IDOK:
            if ( OnOk(hwnd) )
                EndDialog(hwnd, 1);
            break;
        
        case IDCANCEL:
            SendMessage(hwnd, WM_CLOSE, 0, 0L);
            break;

        case IDC_SHARE_ACCOUNT_GUEST:
        case IDC_SHARE_ACCOUNT_SPECIFY:
            EnableControls(hwnd);
            break;
    }
}

static BOOL OnOk(HWND hwnd)
{
    TCHAR           szPath[MAX_PATH]        = NULLSTR,
                    szNetUse[MAX_PATH],
                    szUsername[256]         = NULLSTR,
                    szPassword[256]         = _T("\""),
                    szDomain[256];
    LPTSTR          lpSearch,
                    lpUser;
    BOOL            bAccount            = ( IsDlgButtonChecked(hwnd, IDC_SHARE_ACCOUNT_SPECIFY) == BST_CHECKED ),
                    bGuest,
                    bLocal,
                    bNoWarn             = FALSE;
    USE_INFO_2      ui2;
    NET_API_STATUS  nerr_NetUse;
    HRESULT hrCat;

    // If they checked the account radio button, get that info.
    //
    if ( bAccount )
    {
        // First get the password and confirmation of the password and
        // make sure they match.
        //
        GetDlgItemText(hwnd, IDC_SHARE_PASSWORD, szPassword + 1, AS(szPassword) - 1);
        GetDlgItemText(hwnd, IDC_SHARE_CONFIRM, szUsername, AS(szUsername));
        if ( lstrcmp(szPassword + 1, szUsername) != 0 )
        {
            // Didn't match, so error out.
            //
            MsgBox(hwnd, IDS_ERR_CONFIRMPASSWORD, IDS_APPNAME, MB_ERRORBOX);
            SetDlgItemText(hwnd, IDC_SHARE_PASSWORD, NULLSTR);
            SetDlgItemText(hwnd, IDC_SHARE_CONFIRM, NULLSTR);
            SetFocus(GetDlgItem(hwnd, IDC_SHARE_PASSWORD));
            return FALSE;
        }

        // Now get the user name.
        //
        szUsername[0] = NULLCHR;
        GetDlgItemText(hwnd, IDC_SHARE_USERNAME, szUsername, AS(szUsername));
    }

    // Get the share name.
    //
    GetDlgItemText(hwnd, IDC_SHARE_PATH, szPath, AS(szPath));

    // Make sure they have entered a valid UNC path.
    //
    // Here are all the checks we do:
    //   1.  Must have a backslash as the 1st and 2nd characters.
    //   2.  Must have a non backslash as the 3rd character.
    //   3.  Must have at least one more backslash in the path.
    //   4.  Must be at least one non backslash character after
    //       that one more backslash.
    //   5.  Must not contain any invalid characters.
    //
    // Note:  We use the lpSearch below assuming it is at the first
    //        character of the share name, so don't change the if
    //        with out thinking about that first.
    //
    if ( ( szPath[0] != CHR_BACKSLASH ) ||
         ( szPath[1] != CHR_BACKSLASH ) ||
         ( szPath[2] == NULLCHR ) ||
         ( szPath[2] == CHR_BACKSLASH ) ||
         ( (lpSearch = StrChr(szPath + 3, CHR_BACKSLASH)) == NULL ) ||
         ( *(++lpSearch) == NULLCHR ) ||
         ( *lpSearch == CHR_BACKSLASH ) || 
         ( StrChr(szPath, _T('/')) != NULL ) ||
         ( StrChr(szPath, _T(':')) != NULL ) ||
         ( StrChr(szPath, _T('?')) != NULL ) ||
         ( StrChr(szPath, _T('"')) != NULL ) ||
         ( StrChr(szPath, _T('<')) != NULL ) ||
         ( StrChr(szPath, _T('>')) != NULL ) ||
         ( StrChr(szPath, _T('|')) != NULL ) )
    {
        MsgBox(hwnd, IDS_ERR_NODISTSHARE, IDS_APPNAME, MB_ERRORBOX);
        SetFocus(GetDlgItem(hwnd, IDC_SHARE_PATH));
        return FALSE;
    }

    // Need just the "\\computer\share" part of the path.  Just use
    // lpSearch as the staring point because it should point to the
    // first character of the share name.  So just find the next
    // backslash and copy everything before it.
    //
    if ( lpSearch = StrChr(lpSearch, CHR_BACKSLASH) )
        lstrcpyn(szNetUse, szPath, (int)((lpSearch - szPath) + 1));
    else
        lstrcpyn(szNetUse, szPath,AS(szNetUse));

    // Init the user info struct for NetUserAdd().
    //
    ZeroMemory(&ui2, sizeof(ui2));
    ui2.ui2_remote      = szNetUse;
    ui2.ui2_asg_type    = USE_DISKDEV;
    ui2.ui2_password    = szPassword + 1;

    // See if the UNC share they specified is local.
    //
    bLocal = IsLocalShare(szPath);

    // Check to see if we are using the guest account (basically
    // an empty username).
    //
    bGuest = ( szUsername[0] == NULLCHR || !LSTRCMPI(szUsername, _T("guest")));
    
    if (bGuest) 
    {
            // Ask then if they want to share out this local folder.
            //
            switch ( MsgBox(hwnd, IDS_ASK_USEGUEST, IDS_APPNAME, MB_YESNOCANCEL | MB_APPLMODAL | MB_DEFBUTTON3) )
            {
                case IDYES:
                    break;

                case IDNO:
                case IDCANCEL:

                    // If they pressed cancel, return so they can enter
                    // different credintials.
                    //
                    SetFocus(GetDlgItem(hwnd, IDC_SHARE_ACCOUNT_GUEST));
                    return FALSE;
            }
    }
    // If the user specified a username of the form "domain\username"
    // use the domain specified here.
    //
    lstrcpyn(szDomain, szUsername,AS(szDomain));
    if ( ( !bGuest ) &&
         ( lpUser = StrChr(szDomain, CHR_BACKSLASH) ) )
    {
        // Put a NULL character after the domain part of the user name
        // and advance the pointer to point to the actual user name.
        //
        *(lpUser++) = NULLCHR;
    }
    else 
    {
        // Use the computer name in the path as the domain name.
        //
        if ( lpSearch = StrChr(szPath + 2, CHR_BACKSLASH) )
            lstrcpyn(szDomain, szPath + 2, (int)((lpSearch - (szPath + 2)) + 1));
        else
            lstrcpyn(szDomain, szPath + 2, AS(szDomain));

        // Set the lpUser to point to the user name.  If no user
        // name, use the guest account.
        //
        if ( bGuest )
            lstrcpyn(szUsername, _T("guest"),AS(szUsername));
        lpUser = szUsername;
    }

    // Set the domain and user name pointers into our struct.
    //
    ui2.ui2_domainname  = szDomain;
    ui2.ui2_username    = lpUser;

    // Last try to disconnect any possible connection we might already
    // have to the share.
    //
    NetUseDel(NULL, szNetUse, USE_NOFORCE);

    // See if we need to enable the guest account (only works
    // on XP, not Win2K).
    //
    if ( ( g_App.dwOsVer >= OS_XP ) &&
         ( bLocal && bGuest ) )
    {
        CoInitialize(NULL);
        if ( !GuestAccount(FALSE) )
        {
            // Ask then if they want to share out this local folder.
            //
            switch ( MsgBox(hwnd, IDS_ASK_ENABLEGUEST, IDS_APPNAME, MB_YESNOCANCEL | MB_APPLMODAL) )
            {
                case IDYES:

                    // If they pressed yes, try to enable the guess account.
                    //
                    GuestAccount(TRUE);
                    break;

                case IDCANCEL:

                    // If they pressed cancel, return so they can enter
                    // different credintials.
                    //
                    SetFocus(GetDlgItem(hwnd, IDC_SHARE_ACCOUNT_GUEST));
                    CoUninitialize();
                    return FALSE;
            }
        }
        CoUninitialize();
    }

    // Try to connect to the share.
    //
    if ( (nerr_NetUse = NetUseAdd(NULL, 2, (LPBYTE) &ui2, NULL)) != NERR_Success ) 
    {
        // If the share doesn't exist, we might be able to create it.
        //
        if ( ERROR_BAD_NET_NAME == nerr_NetUse )
        {
            LPTSTR  lpShareName;
            TCHAR   szShare[MAX_PATH],
                    szRootDir[] = _T("_:\\");

            // Get the root dir to the drive we are considering creating a share on.
            //
            szRootDir[0] = g_App.szOpkDir[0];

            // Get just the share from the UNC path they specified.
            //
            lstrcpyn(szShare, szNetUse,AS(szShare));
            if ( lpShareName = StrChr(szShare + 2, CHR_BACKSLASH) )
                lpShareName++;

            // Now check to make sure the UNC path points to this computer,
            // that we can make a share on the drive we are installed to
            // (meaning it isn't a mapped network drive), that the folder
            // isn't already shared, and that we have a share name.
            //
            if ( ( lpShareName && *lpShareName ) &&
                 ( bLocal ) &&
                 ( ISLET(szRootDir[0]) ) &&
                 ( GetDriveType(szRootDir) != DRIVE_REMOTE ) &&
                 ( !IsFolderShared(g_App.szOpkDir, NULL, 0) ) )
            {
                SHARE_INFO_502  si502;
                NET_API_STATUS  nerr_ShareAdd;
                PSID            psid;
                PACL            pacl;

                // Ask then if they want to share out this local folder.
                //
                switch ( MsgBox(hwnd, IDS_ASK_SHAREFOLDER, IDS_APPNAME, MB_YESNOCANCEL | MB_ICONQUESTION | MB_APPLMODAL, lpShareName, g_App.szOpkDir) )
                {
                    case IDYES:

                        //
                        // If they pressed yes, try to the share out the folder.
                        //

                        // Setup the share info struct.
                        //
                        ZeroMemory(&si502, sizeof(SHARE_INFO_502));
                        si502.shi502_netname                = lpShareName;
                        si502.shi502_type                   = STYPE_DISKTREE;
                        si502.shi502_remark                 = NULLSTR;
                        si502.shi502_permissions            = ACCESS_READ;
                        si502.shi502_passwd                 = szPassword + 1;
                        si502.shi502_max_uses               = -1;
                        si502.shi502_path                   = g_App.szOpkDir;
                        si502.shi502_security_descriptor    = CreateShareAccess(bGuest ? NULL : lpUser, szDomain, &psid, &pacl);

                        // Now try to create the share.
                        //
                        if ( NERR_Success != (nerr_ShareAdd = NetShareAdd(NULL, 502, (LPBYTE) &si502, NULL)) )
                        {
                            LPTSTR lpError;

                            // Try to get the description of the error.
                            //
                            if ( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, nerr_ShareAdd, 0, (LPTSTR) &lpError, 0, NULL) == 0 )
                                lpError = NULL;
                            else
                                StrRTrm(lpError, _T('\n'));

                            // Can't authenticate to the server, warn the user.
                            //
                            MsgBox(hwnd, IDS_ERR_CANTSHARE, IDS_APPNAME, MB_ERRORBOX, lpError ? lpError : NULLSTR);

                            // Free the text from FormatMessage().
                            //
                            if ( lpError )
                                LocalFree((HLOCAL) lpError);
                        }
                        else
                        {
                            ACCESS_MASK dwPermissions;

                            // Access permissions to the shared directory
                            //
                            dwPermissions = FILE_READ_ATTRIBUTES | FILE_READ_DATA | FILE_READ_EA | FILE_LIST_DIRECTORY | SYNCHRONIZE | READ_CONTROL;

                            // Set the security permissions
                            //
                            SetDirectoryPermissions( g_App.szOpkDir, psid, dwPermissions );
                        }



                        // Make sure we free the security descriptor.
                        //
                        if ( si502.shi502_security_descriptor )
                        {
                            FREE(si502.shi502_security_descriptor);
                            FREE(psid);
                            FREE(pacl);
                        }

                        // We hit an error so we must return to the dialog.
                        //
                        if ( nerr_ShareAdd != NERR_Success )
                            return FALSE;

                        // Now we only use the computer and share name part of the UNC path.
                        //
                        lstrcpyn(szPath, szShare,AS(szPath));

                        break;

                    case IDCANCEL:

                        // If they pressed cancel, then return so they can enter
                        // another path.
                        //
                        SetFocus(GetDlgItem(hwnd, IDC_SHARE_PATH));
                        return FALSE;
                }

                // Set this so we don't error out again or do
                // any more checks.
                //
                bNoWarn = TRUE;
            }
        }

        // Only warn if we didn't offer to share the folder already.
        //
        if ( !bNoWarn )
        {
            LPTSTR lpError;

            // Try to get the description of the error.
            //
            if ( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, nerr_NetUse, 0, (LPTSTR) &lpError, 0, NULL) == 0 )
                lpError = NULL;

            // Can't authenticate to the server, warn the user.
            //
            if ( MsgBox(hwnd, IDS_ERR_NETSHAREACCESS, IDS_APPNAME, MB_YESNO | MB_ICONWARNING | MB_APPLMODAL | MB_DEFBUTTON2, szPath, lpError ? lpError : NULLSTR) == IDYES )
                bNoWarn = TRUE;

            // Free the text from FormatMessage().
            //
            if ( lpError )
                LocalFree((HLOCAL) lpError);

            // Get out now if we the pressed cancel (bNoWarn gets set
            // to TRUE if they don't care about the error).
            //
            if ( !bNoWarn )
            {
                SetFocus(GetDlgItem(hwnd, IDC_SHARE_PATH));
                return FALSE;
            }
        }
    }

    // Don't want them to get two error messages if they already said OK.
    //
    if ( !bNoWarn )
    {
        TCHAR szCheckPath[MAX_PATH];

        // Create the path to where the OEM.TAG file should be.
        //
        lstrcpyn(szCheckPath, szPath,AS(szCheckPath));
        AddPathN(szCheckPath, DIR_WIZARDFILES,AS(szCheckPath));
        AddPathN(szCheckPath, FILE_OEM_TAG,AS(szCheckPath));

        // Now make sure the tag file is there or that they are
        // okay to continue with out it.
        //
        if ( ( !FileExists(szCheckPath) ) &&
             ( MsgBox(hwnd, IDS_ERR_INVALIDSHARE, IDS_APPNAME, MB_YESNO | MB_ICONWARNING | MB_APPLMODAL | MB_DEFBUTTON2, szPath) == IDNO ) )
        {
            SetFocus(GetDlgItem(hwnd, IDC_SHARE_PATH));
            return FALSE;
        }
    }

    // If we net used to a share, lets disconnect it.
    //
    if ( NERR_Success == nerr_NetUse )
        NetUseDel(NULL, szNetUse, USE_NOFORCE);

    // Reset the user name if we used the default guest account.
    //
    if ( bGuest )
        lstrcpyn(szUsername, _T("guest"),AS(szUsername));

    // If there is a password, add the trailing quote.
    //
    if ( szPassword[1] )
        hrCat=StringCchCat(szPassword, AS(szPassword), _T("\""));
    else
        szPassword[0] = NULLCHR;

    // Now commit all the settings to the ini file.
    //
    WritePrivateProfileString(INI_SEC_SHARE, INI_KEY_SHARE_PATH, szPath, g_App.szSetupMgrIniFile);
    WritePrivateProfileString(INI_SEC_SHARE, INI_KEY_SHARE_USERNAME, ( bAccount ? szUsername : NULL ), g_App.szSetupMgrIniFile);
    WritePrivateProfileString(INI_SEC_SHARE, INI_KEY_SHARE_PASSOWRD, ( bAccount ? szPassword : NULL ), g_App.szSetupMgrIniFile);

    return TRUE;
}

static void EnableControls(HWND hwnd)
{
    BOOL fEnable = ( IsDlgButtonChecked(hwnd, IDC_SHARE_ACCOUNT_SPECIFY) == BST_CHECKED );

    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_USERNAME_TEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_USERNAME), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_PASSWORD_TEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_PASSWORD), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_CONFIRM_TEXT), fEnable);
    EnableWindow(GetDlgItem(hwnd, IDC_SHARE_CONFIRM), fEnable);
}

static PSECURITY_DESCRIPTOR CreateShareAccess(LPTSTR lpUsername, LPTSTR lpDomain, PSID * lppsid, PACL * lppacl)
{
    TCHAR                   szAccount[256];
    PSECURITY_DESCRIPTOR    lpsd;
    PSID                    psid;
    PACL                    pacl;
    DWORD                   cbacl;
    BOOL                    bRet = FALSE;
    HRESULT hrPrintf;

    // Need the user name and domain in one string.
    //
    if ( lpUsername && lpDomain )
        hrPrintf=StringCchPrintf(szAccount, AS(szAccount), _T("%s\\%s"), lpDomain, lpUsername);
    else
        szAccount[0] = NULLCHR;

    // Need to allocate the security descriptor and sid for the account.
    //
    if ( ( lpsd = MALLOC(sizeof(SECURITY_DESCRIPTOR)) ) &&
         ( psid = ( szAccount[0] ? GetAccountSid(szAccount) : GetWorldSid() ) ) )
    {

        // Allocate space for and initialize the ACL.
        //
        cbacl = GetLengthSid(psid) + sizeof(ACL) + (1 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));
        if ( pacl = (PACL) MALLOC(cbacl) )
        {
            // Initialize the ACL.
            //
            if ( InitializeAcl(pacl, cbacl, ACL_REVISION) )
            {
                // Add Aces for the User.
                //
                AddDirAce(pacl, GENERIC_READ | GENERIC_EXECUTE, psid);

                // Put together the security descriptor.
                //
                if ( InitializeSecurityDescriptor(lpsd, SECURITY_DESCRIPTOR_REVISION) &&
                     SetSecurityDescriptorDacl(lpsd, TRUE, pacl, FALSE) )
                {
                    bRet = TRUE;
                }
            }

            // Clean up the ACL allocated.
            //
            if ( !bRet )
                FREE(pacl);
        }

        // Clean up the SID allocated.
        //
        if ( !bRet )
            FREE(psid);
    }

    // If we failed anywhere, just free the security descriptor.
    //
    if ( bRet )
    {
        // Return the allocated security descriptor if successful.
        //
        *lppsid = psid;
        *lppacl = pacl;
        return lpsd;
    }

    // Didn't work, free and return.
    //
    FREE(lpsd);
    return NULL;
}

static BOOL IsLocalShare(LPTSTR lpszUnc)
{
    LPTSTR  lpBackslash;
    TCHAR   szThisComputer[MAX_COMPUTERNAME_LENGTH + 1],
            szRemoteComputer[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD   dwSize = AS(szThisComputer);

    // Get just the computer from the UNC path they specified.
    //
    lstrcpyn(szRemoteComputer, lpszUnc + 2, AS(szRemoteComputer));
    if ( lpBackslash = StrChr(szRemoteComputer, CHR_BACKSLASH) )
        *lpBackslash = NULLCHR;

    // Now check to make sure the UNC path points to this computer.
    //
    return ( ( GetComputerName(szThisComputer, &dwSize) ) &&
             ( lstrcmpi(szThisComputer, szRemoteComputer) == 0 ) );
}

static BOOL GuestAccount(BOOL bSet)
{
    HRESULT         hr;
    ILocalMachine   *pLM;
    BOOL            bRet = TRUE;
    VARIANT_BOOL    vbEnabled;

    hr = CoCreateInstance(&CLSID_ShellLocalMachine, NULL, CLSCTX_INPROC_SERVER, &IID_ILocalMachine, (LPVOID *) &pLM);
    if ( SUCCEEDED(hr) )
    {
        hr = pLM->lpVtbl->get_isGuestEnabled(pLM, ILM_GUEST_NETWORK_LOGON, &vbEnabled);
        if ( SUCCEEDED(hr) )
        {
            bRet = vbEnabled;
            if ( !bRet && bSet )
            {
                hr = pLM->lpVtbl->EnableGuest(pLM, ILM_GUEST_NETWORK_LOGON);
                if ( SUCCEEDED(hr) )
                {
                    bRet = TRUE;
                }
            }
        }
        pLM->lpVtbl->Release(pLM);
    }

    return bRet;
}

static PSID GetAccountSid(LPCTSTR lpszUserName)
{
    TCHAR           szDomain[64];
    DWORD           cbSid       = 0,
                    cbDomain    = AS(szDomain);
    PSID            pSid        = NULL;
    SID_NAME_USE    peUse;

    if ( (!LookupAccountName(NULL, lpszUserName, pSid, &cbSid, szDomain, &cbDomain, &peUse) ) &&
         ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) &&
         ( pSid = (PSID) MALLOC(cbSid) ) )
    {
        cbDomain = AS(szDomain);
        if ( !LookupAccountName(NULL, lpszUserName, pSid, &cbSid, szDomain, &cbDomain, &peUse) )
            FREE(pSid);
    }
    return pSid;
}

static PSID GetWorldSid()
{
    SID_IDENTIFIER_AUTHORITY    authWorld   = SECURITY_WORLD_SID_AUTHORITY;
    PSID                        pSid        = NULL,
                                psidWorld;
    DWORD                       cbSid;

    if ( AllocateAndInitializeSid(&authWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &psidWorld) )
    {
        cbSid = GetLengthSid(psidWorld);
        if ( ( pSid = (PSID) MALLOC(cbSid) ) &&
             ( !CopySid(cbSid, pSid, psidWorld) ) )
        {
            FREE(pSid);
        }
        FreeSid(psidWorld);
    }
    return pSid;
}

static BOOL AddDirAce(PACL pacl, ACCESS_MASK Mask, PSID psid)
{
    WORD                AceSize;
    ACCESS_ALLOWED_ACE  *pAce;
    BOOL                bResult;

    AceSize = (USHORT) (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(psid));
    pAce = (ACCESS_ALLOWED_ACE *) MALLOC(AceSize);

    // Fill in the ACE.
    //
    memcpy(&pAce->SidStart, psid, GetLengthSid(psid));
    pAce->Mask              = Mask;
    pAce->Header.AceType    = ACCESS_ALLOWED_ACE_TYPE;
    pAce->Header.AceFlags   = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
    pAce->Header.AceSize    = AceSize;

    // Put the ACE into the ACL.
    //
    bResult = AddAce(pacl,
                     pacl->AclRevision,
                     0xFFFFFFFF,
                     pAce,
                     pAce->Header.AceSize);

    FREE(pAce);
    return bResult;
}

static BOOL SetDirectoryPermissions(LPTSTR lpDirectory, PSID psid, ACCESS_MASK dwMask)
{
    EXPLICIT_ACCESS         AccessEntry;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor = NULL;
    PACL                    pOldAccessList      = NULL;
    PACL                    pNewAccessList      = NULL;
    DWORD                   dwRes;
    BOOL                    bReturn             = FALSE;

    // Zero out the memory
    //
    ZeroMemory(&AccessEntry, sizeof(EXPLICIT_ACCESS));

    // Check to make sure we have the necessary parameters
    //
    if ( !(lpDirectory && *lpDirectory && psid) )
    {
        return FALSE;
    }

    // Make sure we are able to get the security information on the directory
    //
    if ( GetNamedSecurityInfo(lpDirectory,SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, &pOldAccessList, NULL, &pSecurityDescriptor) == ERROR_SUCCESS )
    {
        // Build Trustee list
        //
        BuildTrusteeWithSid(&(AccessEntry.Trustee), psid);

        //
        AccessEntry.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        AccessEntry.grfAccessMode = GRANT_ACCESS;

        // Set permissions in structure
        //
        AccessEntry.grfAccessPermissions =  dwMask;

        if ( (SetEntriesInAcl(1, &AccessEntry, pOldAccessList, &pNewAccessList) == ERROR_SUCCESS) &&
             (SetNamedSecurityInfo(lpDirectory, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, pNewAccessList, NULL) == ERROR_SUCCESS) )
        {
            bReturn = TRUE; 
        }

        // Clean up some of the memory
        //
        FREE(pNewAccessList);
        FREE(pSecurityDescriptor);

        
    }
    

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\welcome.c ===
/****************************************************************************\

    WELCOME.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "welcome" wizard page.

    3/99 - Jason Cohen (JCOHEN)
        Updated this old source file for the OPK Wizard as part of the
        Millennium rewrite.
        
    09/2000 - Stephen Lodwick (STELO)
        Ported OPK Wizard to Whistler

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"
#include "setupmgr.h"


//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);


//
// External Function(s):
//

INT_PTR CALLBACK WelcomeDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        case WM_NOTIFY:
            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZFINISH:
                case PSN_WIZBACK:
                    break;

                case PSN_WIZNEXT:

                    /*
                    if(GET_FLAG(OPK_AUTORUN))
                    {   
                        RECT rc;

                        // Hide the window
                        //
                        ShowWindow(GetParent(hwnd), SW_HIDE);

                        // This needs to get reset so that we warn an cancel from
                        // this point on.
                        //
                        if ( GetWindowRect(GetParent(hwnd), &rc) )
                            SetWindowPos(GetParent(hwnd), NULL, ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2), ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2), 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);  
                    }
                    */

                    WritePrivateProfileString(INI_SEC_OPTIONS, INI_KEY_WELCOME, ( IsDlgButtonChecked(hwnd, IDC_HIDE) == BST_CHECKED ) ? STR_ZERO : NULL , g_App.szSetupMgrIniFile);
                    break;

                case PSN_SETACTIVE:

                    g_App.dwCurrentHelp = IDH_WELCOME;

                    WIZ_BUTTONS(hwnd, PSWIZB_NEXT);

                    if ( GetPrivateProfileInt(INI_SEC_OPTIONS, INI_KEY_WELCOME, 1, g_App.szSetupMgrIniFile) == 0 )
                        CheckDlgButton(hwnd, IDC_HIDE, BST_CHECKED);

                    if ( ( IsDlgButtonChecked(hwnd, IDC_HIDE) == BST_CHECKED ) ||
                         ( GET_FLAG(OPK_WELCOME) ) ||
                         ( GET_FLAG(OPK_CMDMM) ) )
                    {
                        WIZ_SKIP(hwnd);
                    }
                    else
                    {
                        SET_FLAG(OPK_WELCOME, TRUE);

                        // Press next if the user is in auto mode
                        //
                        WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);
                    }

                    break;

                case PSN_QUERYCANCEL:
                    // If we are in maintenence mode then we don't want to delete the temp dir
                    //
                    g_App.szTempDir[0] = NULLCHR;

                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    RECT    rc;
    TCHAR   szAppName[MAX_PATH] = NULLSTR;
    LPTSTR  lpWelcomeText       = NULL;

    LoadString(NULL, IDS_APPNAME, szAppName, STRSIZE(szAppName));
    SetWindowText(GetParent(hwnd), szAppName);

    // Set the welcome text
    //
    if (lpWelcomeText = AllocateString(NULL, IDS_WELCOME_TEXT_OEM))
    {
        SetDlgItemText(hwnd, IDC_WELCOME_TEXT, lpWelcomeText);
        FREE(lpWelcomeText);
    }
    

    // Set the big bold font.
    //
    SetWindowFont(GetDlgItem(hwnd, IDC_BIGBOLDTITLE), FixedGlobals.hBigBoldFont, TRUE);

    // Center the wizard.
    //
    if ( GetWindowRect(GetParent(hwnd), &rc) )
    {
        SetWindowPos(GetParent(hwnd), NULL, ((GetSystemMetrics(SM_CXSCREEN) - (rc.right - rc.left)) / 2), ((GetSystemMetrics(SM_CYSCREEN) - (rc.bottom - rc.top)) / 2), 0, 0, SWP_NOSIZE | SWP_NOACTIVATE);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\sku.c ===
/****************************************************************************\

    SKU.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Target SKU" wizard page.

    10/00 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard.  It includes the new
        ability to deploy mulitple product skus (per, pro, srv, ...) from one
        wizard.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "sku.h"
#include "wizard.h"
#include "resource.h"

//
// Internal Global(s):
//

static STRRES s_srSkuDirs[] =
{
    { DIR_SKU_PRO,      IDS_SKU_PRO },
    { DIR_SKU_SRV,      IDS_SKU_SRV },
    { DIR_SKU_ADV,      IDS_SKU_ADV },
    { DIR_SKU_DTC,      IDS_SKU_DTC },
    { DIR_SKU_PER,      IDS_SKU_PER },
    { DIR_SKU_BLA,      IDS_SKU_BLA },
    { DIR_SKU_SBS,      IDS_SKU_SBS },
};

static STRRES s_srArchDirs[] =
{
    { DIR_ARCH_X86,     IDS_ARCH_X86 },
    { DIR_ARCH_IA64,    IDS_ARCH_IA64 },

};

// This is used to map the product type in the inf to
// the directory name we use.  These MUST be in the
// correct order.
//
static LPTSTR s_lpProductType[] =
{
    DIR_SKU_PRO,    // ProductType = 0
    DIR_SKU_SRV,    // ProductType = 1
    DIR_SKU_ADV,    // ProductType = 2
    DIR_SKU_DTC,    // ProductType = 3
    DIR_SKU_PER,    // ProductType = 4
    DIR_SKU_BLA,    // ProductType = 5
    DIR_SKU_SBS,    // ProductType = 6
};

static LPTSTR s_lpSourceDirs[] =
{
    DIR_CD_IA64,    // Must be before x86 because ia64 has both dirs.
    DIR_CD_X86,     // Should always be last in the list.
};

static LPTSTR s_lpPlatformArchDir[] =
{
    STR_PLATFORM_X86,   DIR_ARCH_X86,
    STR_PLATFORM_IA64,  DIR_ARCH_IA64,
};

static LPTSTR s_lpLocalIDs[] =
{
    _T("00000401"), _T("ARA"),
    _T("00000404"), _T("CHT"),
    _T("00000804"), _T("CHS"),
    _T("00000409"), _T("ENG"),
    _T("00000407"), _T("GER"),
    _T("0000040D"), _T("HEB"),
    _T("00000411"), _T("JPN"),
    _T("00000412"), _T("KOR"),
    _T("00000416"), _T("BRZ"),
    _T("00000403"), _T("CAT"),
    _T("00000405"), _T("CZE"),
    _T("00000406"), _T("DAN"),
    _T("00000413"), _T("DUT"),
    _T("0000040B"), _T("FIN"),
    _T("0000040C"), _T("FRN"),
    _T("00000408"), _T("GRK"),
    _T("0000040E"), _T("HUN"),
    _T("00000410"), _T("ITN"),
    _T("00000414"), _T("NOR"),
    _T("00000415"), _T("POL"),
    _T("00000816"), _T("POR"),
    _T("00000419"), _T("RUS"),
    _T("00000C0A"), _T("SPA"),
    _T("0000041D"), _T("SWE"),
    _T("0000041F"), _T("TRK"),
};

//
// Local Define(s):
//
#define FILE_INTL_INF       _T("INTL.INF")
#define INF_SEC_DEFAULT     _T("DefaultValues")
#define INF_VAL_LOCALE      _T("Locale")

//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam);
static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify);
static BOOL OnNext(HWND hwnd);
static void OnDestroy(HWND hwnd);
static BOOL OnSetActive(HWND hwnd); 
static void EnumDirs(HWND hwndLB, LPTSTR lpSkuDir);
static LPTSTR AllocateSPStrRes(HINSTANCE hInstance, LPSTRRES lpsrTable, DWORD cbTable, LPTSTR lpString, LPTSTR * lplpReturn, DWORD *lpdwSP);
static INT AddSkuToList(HWND hwndLB, LPTSTR lpSkuDir, LPTSTR lpArchDir, LPTSTR lpReturn, DWORD cbReturn, DWORD dwSP);
static BOOL StartCopy(HWND hwnd, HANDLE hEvent, LPCOPYDIRDATA lpcdd);
DWORD WINAPI CopyDirectoryThread(LPVOID lpVoid);
LRESULT CALLBACK SkuNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);



//
// External Function(s):
//

LRESULT CALLBACK SkuDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);

        case WM_NOTIFY:

            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    break;

                case PSN_WIZNEXT:
                    if ( !OnNext(hwnd) )
                        WIZ_FAIL(hwnd);
                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                case PSN_SETACTIVE:
                    OnSetActive(hwnd);
                    break;

                default:
                    return FALSE;
            }
            break;

        case WM_DESTROY:
            OnDestroy(hwnd);
            return 0;

        default:
            return FALSE;
    }

    return TRUE;
}

void SetupSkuListBox(HWND hwndLB, LPTSTR lpLangDir)
{
    TCHAR szPath[MAX_PATH];


    // Setup the path buffer to the config dir for the
    // tag files we might need to look for.
    //
    lstrcpyn(szPath, g_App.szLangDir,AS(szPath));
    AddPathN(szPath, lpLangDir,AS(szPath));
    AddPathN(szPath, DIR_SKU,AS(szPath));
    if ( SetCurrentDirectory(szPath) )
        EnumDirs(hwndLB, NULL);

    // If there are items in the list, make sure there is one selected.
    //
    if ( ( (INT) SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) > 0 ) && 
         ( SendMessage(hwndLB, LB_GETCURSEL, 0, 0L) == LB_ERR ) )
    {
        SendMessage(hwndLB, LB_SETCURSEL, 0, 0L);
    }
}

void AddSku(HWND hwnd, HWND hwndLB, LPTSTR lpLangName)
{
    BOOL    bGoodSource = FALSE,
            bErrorDisplayed = FALSE;
    DWORD   dwSearch;
    DWORD   dwSP=0;

    // First find out where the sku is that they want to add.
    //
    while ( !bGoodSource && BrowseForFolder(hwnd, IDS_BROWSEFOLDER, g_App.szBrowseFolder, BIF_RETURNONLYFSDIRS | BIF_EDITBOX | BIF_VALIDATE) )
    {
        TCHAR   szPath[MAX_PATH] = NULLSTR;
        LPTSTR  lpEnd,
                lpEnd2;

        // Set to default value
        //
        bErrorDisplayed = FALSE;

        // Make our own copy of the path we got back.
        //
        lstrcpyn(szPath, g_App.szBrowseFolder, AS(szPath));

        // First check and see if we have the inf we need right here.
        //
        lpEnd = szPath + lstrlen(szPath);
        AddPathN(szPath, FILE_DOSNET_INF,AS(szPath));
        if ( !(bGoodSource = FileExists(szPath)) )
        {
            // Search for all the possible source directories that could be on the CD.
            //
            for ( dwSearch = 0; !bGoodSource && ( dwSearch < AS(s_lpSourceDirs) ); dwSearch++ )
            {
                // First test for the directory.
                //
                *lpEnd = NULLCHR;
                AddPathN(szPath, s_lpSourceDirs[dwSearch],AS(szPath));
                if ( DirectoryExists(szPath) )
                {
                    // Also make sure that the inf file we need is there.
                    //
                    lpEnd2 = szPath + lstrlen(szPath);
                    AddPathN(szPath, FILE_DOSNET_INF,AS(szPath));
                    if ( bGoodSource = FileExists(szPath) )
                        lpEnd = lpEnd2;
                }
            }
        }

        // Check to see if we have a matching language
        //
        if ( bGoodSource )
        {

            TCHAR   szLangFile[MAX_PATH]= NULLSTR,
                    szLang[MAX_PATH]    = NULLSTR;

            // Check for the lang dir
            //
            lstrcpyn(szLangFile, szPath, (lstrlen(szPath) - lstrlen(lpEnd) + 1));
            AddPathN(szLangFile, FILE_INTL_INF,AS(szLangFile));

            // Check to see that the lang file contains a valid locale and that we recognize the locale
            //
            if ( GetPrivateProfileString(INF_SEC_DEFAULT, INF_VAL_LOCALE, NULLSTR, szLang, STRSIZE(szLang), szLangFile) && szLang[0] )
            {
                // Find the locale in our list
                //
                for ( dwSearch = 1; ( dwSearch < AS(s_lpLocalIDs) ) && ( lstrcmpi(s_lpLocalIDs[dwSearch - 1], szLang) != 0 ); dwSearch += 2 );

                // See if we found the item in our list and they match
                //
                if ( !(dwSearch < AS(s_lpLocalIDs)) || 
                     (lstrcmpi(s_lpLocalIDs[dwSearch], lpLangName) != 0) )
                {
                    // We are not in the list, let the user know that we can't add the language
                    //
                    MsgBox(GetParent(hwnd), IDS_ERR_BADSOURCELANG, IDS_APPNAME, MB_ERRORBOX);
                    bGoodSource = FALSE;
                    bErrorDisplayed = TRUE;
                }
            }
            else
            {
                // We were not able to get the locale string from the source files, this is not a valid source
                //
                bGoodSource = FALSE;
            }
        }
        // Only if we found the inf is this going to be a vaild location.
        //
        if ( bGoodSource )
        {
            TCHAR   szInfFile[MAX_PATH],
                    szSrcPath[MAX_PATH] = NULLSTR,
                    szPlatform[256]     = NULLSTR;
            DWORD   dwProdType;
            TCHAR   szSP[MAX_INFOLEN];

            // Reset this to false... we will set it to true if most everything works as planned.
            //
            bGoodSource = FALSE;

            // Copy our inf file into its own buffer.
            //
            lstrcpyn(szInfFile, szPath, AS(szInfFile));

            // Now we need to get the path to the root of our source (up one
            // from where we are now).
            //
            *lpEnd = NULLCHR;
            AddPathN(szPath, _T(".."),AS(szPath));

            // Make sure we have the full path and all the data out of the inf
            // we need.
            //
            if ( ( GetFullPathName(szPath, AS(szSrcPath), szSrcPath, &lpEnd) && szSrcPath[0] ) &&
                 ( (dwProdType = GetPrivateProfileInt(INI_SEC_MISC, INI_KEY_PRODTYPE, 0xFFFFFFFF, szInfFile)) != 0xFFFFFFFF ) &&
                 ( GetPrivateProfileString(INI_SEC_MISC, INI_KEY_PLATFORM, NULLSTR, szPlatform, STRSIZE(szPlatform), szInfFile) && szPlatform[0] ) )
            {
                // At this point we have done most of the checks to know for sure that
                // this is a good source location for a sku.  By setting this we won't error
                // out on our exit.
                //
                bGoodSource = TRUE;

                // Convert the platform name we found in the inf to the arch name we use for
                // the directory.
                //
                for ( dwSearch = 1; ( dwSearch < AS(s_lpPlatformArchDir) ) && ( lstrcmpi(s_lpPlatformArchDir[dwSearch - 1], szPlatform) != 0 ); dwSearch += 2 );

                // Make sure we found it in our list.  We must recognize the platform in order
                // to preinstall it.
                //
                if ( dwSearch < AS(s_lpPlatformArchDir) )
                {
                    TCHAR   szSkuName[64];
                    LPTSTR  lpSkuDir;

                    // Make sure this is a known product type.
                    //
                    if ( dwProdType < AS(s_lpProductType) ) {
                        // get the ServicePack number
                        szSP[0]= NULLCHR;
                        if ( GetPrivateProfileString(INI_SEC_MISC, INI_KEY_SERVICEPACK, NULLSTR, szSP, STRSIZE(szSP), szInfFile) && szSP[0] )
                            dwSP= _wtol(szSP);
                        lpSkuDir = s_lpProductType[dwProdType];
                    }
                    else
                    {
                        // Don't know the product type, we should ask them what to use
                        // for the directory name.
                        //
                        *((LPDWORD) szSkuName) = AS(szSkuName);
                        if ( DialogBoxParam(g_App.hInstance, MAKEINTRESOURCE(IDD_SKUNAME), hwnd, SkuNameDlgProc, (LPARAM) szSkuName) && szSkuName[0] )
                            lpSkuDir = szSkuName;
                        else
                            lpSkuDir = NULL;
                    }

                    // Make sure we have the sku dir.
                    //
                    if ( lpSkuDir )
                    {
                        DWORD   dwEndSkuLen,
                                dwFileCount;
                        TCHAR   szDstPath[MAX_PATH],
                                szDirKey[32];
                        LPTSTR  lpArchDir;
                        HRESULT hrPrintf;
                        TCHAR   szSkuDir[32];

                        // Create the path of the root destination directory we need.
                        //
                        lstrcpyn(szDstPath, g_App.szLangDir,AS(szDstPath));
                        AddPathN(szDstPath, lpLangName,AS(szDstPath));
                        AddPathN(szDstPath, DIR_SKU,AS(szDstPath));
                        AddPathN(szDstPath, lpSkuDir,AS(szDstPath));
                        dwEndSkuLen = (DWORD) lstrlen(szDstPath);

                        // if this is a service pack, cat .spx to product name where x is the SP number
                        // and make szSkuDir be the sku.xpx name
                        lstrcpyn(szSkuDir, lpSkuDir,AS(szSkuDir));
                        if (dwSP) {
                            hrPrintf=StringCchPrintf(szDstPath+(DWORD)lstrlen(szDstPath), AS(szDstPath)-(DWORD)lstrlen(szDstPath), _T(".sp%d"), dwSP);
                            hrPrintf=StringCchPrintf(szSkuDir+(DWORD)lstrlen(szSkuDir), AS(szSkuDir)-(DWORD)lstrlen(szSkuDir), _T(".sp%d"), dwSP);
                        }

                        // Finally add our arch name to the end.
                        //
                        lpArchDir = s_lpPlatformArchDir[dwSearch];
                        AddPathN(szDstPath, lpArchDir,AS(szDstPath));

                        // Make sure there is at least one source directory and file.
                        //
                        hrPrintf=StringCchPrintf(szDirKey, AS(szDirKey), INI_KEY_DIR, NUM_FIRST_SOURCE_DX);
                        szPath[0] = NULLCHR;
                        if ( ( GetPrivateProfileString(INI_SEC_DIRS, szDirKey, NULLSTR, szPath, STRSIZE(szPath), szInfFile) && szPath[0] ) &&
                             ( dwFileCount = CopySkuFiles(NULL, NULL, szSrcPath, szDstPath, szInfFile) ) )
                        {
                            BOOL bExists;
                            TCHAR szDisplayName[256];

                            // Make sure we don't already have this SKU here.
                            //
                            if ( bExists = DirectoryExists(szDstPath) )
                                AddSkuToList(NULL, szSkuDir, lpArchDir, szDisplayName, AS(szDisplayName), dwSP);
                            if ( ( !bExists ) ||
                                 ( MsgBox(GetParent(hwnd), IDS_OVERWRITESKU, IDS_APPNAME, MB_YESNO | MB_DEFBUTTON2 | MB_ICONQUESTION, szDisplayName) == IDYES ) )
                            {
                                // Now we are ready to actually create our root destination directory.
                                //
                                COPYDIRDATA cdd;
                                INT         nItem;

                                // May need to remove the sku files first if we are overwriting a SKU.
                                //
                                if ( bExists )
                                    DeletePath(szDstPath);

                                // Put all our data in the structure so we can pass it on to the progress dialog.
                                //
                                lstrcpyn(cdd.szSrc, szSrcPath,AS(cdd.szSrc));
                                lstrcpyn(cdd.szDst, szDstPath,AS(cdd.szDst));
                                lstrcpyn(cdd.szInfFile, szInfFile,AS(cdd.szInfFile));
                                cdd.lpszEndSku = cdd.szDst + dwEndSkuLen;
                                cdd.dwFileCount = dwFileCount;

                                // Create the progress dialog.
                                //
                                switch ( DialogBoxParam(g_App.hInstance, MAKEINTRESOURCE(IDD_PROGRESS), hwnd, ProgressDlgProc, (LPARAM) &cdd) )
                                {
                                    case PROGRESS_ERR_SUCCESS:
                                        if ( ( !bExists ) &&
                                             ( (nItem = AddSkuToList(hwndLB, szSkuDir, lpArchDir, NULL, 0, dwSP)) >= 0 ) &&
                                             ( (INT) SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) > 0 ) &&
                                             ( (INT) SendMessage(hwndLB, LB_GETCURSEL, 0, 0L) == LB_ERR ) )
                                        {
                                            SendMessage(hwndLB, LB_SETCURSEL, nItem, 0L);
                                        }
                                        break;

                                    case PROGRESS_ERR_CANCEL:
                                        break;
                            
                                    case PROGRESS_ERR_COPYERR:
                                        MsgBox(GetParent(hwnd), IDS_ERR_COPYFAIL, IDS_APPNAME, MB_ERRORBOX, UPPER(cdd.szDst[0]));
                                        break;

                                    case PROGRESS_ERR_THREAD:
                                        MsgBox(GetParent(hwnd), IDS_OUTOFMEM, IDS_APPNAME, MB_ERRORBOX);
                                        break;
                                }
                            }
                        }
                        else
                        {
                            // Actually turns out the source is not vallid.  Reset this to false
                            // so we show the bad source error.
                            //
                            bGoodSource = FALSE;
                        }
                    }
                }
                else
                {
                    // Display an error saying we don't recognize the arch.
                    //
                    MsgBox(GetParent(hwnd), IDS_ERR_BADARCH, IDS_APPNAME, MB_ERRORBOX);
                    bGoodSource = FALSE;
                    bErrorDisplayed = TRUE;
                }
            }
        }

        // This is only not true if the source the user selected is not valid and we need to tell them.
        // Any other failure and this will still be true and the user will have already been informed.
        //
        if ( !bGoodSource && !bErrorDisplayed)
            MsgBox(GetParent(hwnd), IDS_ERR_BADSOURCE, IDS_APPNAME, MB_ERRORBOX);
    }
}

void DelSku(HWND hwnd, HWND hwndLB, LPTSTR lpLangName)
{
    INT     nItem;

    // Get the selected item.
    //
    if ( (nItem = (INT) SendMessage(hwndLB, LB_GETCURSEL, 0, 0L)) >= 0 )
    {
        TCHAR   szSkuPath[MAX_PATH],
                szSkuName[256]  = NULLSTR;
        LPTSTR  lpEnd,
                lpDirs          = (LPTSTR) SendMessage(hwndLB, LB_GETITEMDATA, nItem, 0L);
                
        SendMessage(hwndLB, LB_GETTEXT, nItem, (LPARAM) szSkuName);
        if ( ( lpDirs != (LPTSTR) LB_ERR ) &&
             ( szSkuName[0] ) &&
             ( MsgBox(hwnd, IDS_DELETESKU, IDS_APPNAME, MB_ICONQUESTION | MB_YESNO | MB_DEFBUTTON2, szSkuName) == IDYES ) &&
             ( SendMessage(hwndLB, LB_DELETESTRING, nItem, 0L) != LB_ERR ) )
        {
            LPTSTR lpDirsDup = lpDirs;
            // Create a path to the folder for this SKU\Arch.
            //
            lstrcpyn(szSkuPath, g_App.szLangDir,AS(szSkuPath));
            AddPathN(szSkuPath, lpLangName,AS(szSkuPath));
            AddPathN(szSkuPath, DIR_SKU,AS(szSkuPath));
            AddPathN(szSkuPath, lpDirs,AS(szSkuPath));
            lpEnd = szSkuPath + lstrlen(szSkuPath);
            lpDirs += lstrlen(lpDirs) + 1;
            AddPathN(szSkuPath, lpDirs,AS(szSkuPath));

            // This removes just the Arch folder... the folder for this sku might have some others
            // in it.
            //
            DeletePath(szSkuPath);
            
            // You have to reset the current directory before we try removing the folder for
            // this SKU because DeletePath leaves its current dir as the parent of the one
            // it removed.
            //
            SetCurrentDirectory(g_App.szOpkDir);

            // Now try to remve the folder for this SKU if it is empty (otherwise the RemoveDir
            // call just fails and we don't care.
            //
            *lpEnd = NULLCHR;
            RemoveDirectory(szSkuPath);

            // Now reselect another item in the list.
            //
            if ( (INT) SendMessage(hwndLB, LB_GETCOUNT, 0, 0L) <= nItem )
                nItem--;
            if ( nItem >= 0 )
                SendMessage(hwndLB, LB_SETCURSEL, nItem, 0L);
        
            FREE(lpDirsDup);
        }
    }
}


//
// Internal Function(s):
//


static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void OnCommand(HWND hwnd, INT id, HWND hwndCtl, UINT codeNotify)
{
    BOOL bReset = FALSE;

    switch ( id )
    {
        case IDC_ADD:

            // User clicked Add.
            //
            AddSku(GetParent(hwnd), GetDlgItem(hwnd, IDC_SKU_LIST), g_App.szLangName);
            bReset = TRUE;

            break;
                
        case IDC_DELETE:

            // User clicked Delete (not implimented on the page yet).
            //
            DelSku(GetParent(hwnd), GetDlgItem(hwnd, IDC_SKU_LIST), g_App.szLangName);
            bReset = TRUE;

            break;

        case IDC_SKU_LIST:
            if ( codeNotify == LBN_SELCHANGE )
                bReset = TRUE;
            break;
    }

    if ( bReset )
    {
        if ( (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCURSEL, 0, 0L) >= 0 )
            WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
        else
            WIZ_BUTTONS(hwnd, PSWIZB_BACK);
    }
}

static BOOL OnNext(HWND hwnd)
{
    BOOL bOk = FALSE;    

    if ( (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCOUNT, 0, 0L) > 0 )
    {
        INT nItem = (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCURSEL, 0, 0L);

        if ( nItem >= 0 )
        {
            LPTSTR lpDirs = (LPTSTR) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETITEMDATA, nItem, 0L);

            if ( lpDirs != (LPTSTR) LB_ERR )
            {
                lstrcpyn(g_App.szSkuName, lpDirs, AS(g_App.szSkuName));
                WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WINPE_LANG, g_App.szLangName, g_App.szWinBomIniFile);
                WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WINPE_LANG, g_App.szLangName, g_App.szOpkWizIniFile);
                WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WBOM_WINPE_SKU, g_App.szSkuName, g_App.szWinBomIniFile);
                WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_WBOM_WINPE_SKU, g_App.szSkuName, g_App.szOpkWizIniFile);
                WritePrivateProfileString(INI_SEC_WINPE, INI_KEY_ARCH, lpDirs + lstrlen(lpDirs) + 1, g_App.szOpkWizIniFile);
                bOk = TRUE;
            }
            else
                MsgBox(GetParent(hwnd), IDS_ERR_SKUDIR, IDS_APPNAME, MB_ERRORBOX);
        }
        else
            MsgBox(GetParent(hwnd), IDS_ERR_NOSKU, IDS_APPNAME, MB_ERRORBOX);
    }
    else
        MsgBox(GetParent(hwnd), IDS_ERR_NOSKU, IDS_APPNAME, MB_ERRORBOX);

    return bOk;
}


//
// This function gets called when the dialog is destroyed as well as when 
// a PSN_SETACTIVE message is sent to the IDD_SKU dialog.
//
static void OnDestroy(HWND hwnd)
{
    LPTSTR  lpString;
    INT     nItem = (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCOUNT, 0, 0L);

    // Free the string I allocated for each list item's data.
    //
    while ( --nItem >= 0 )
    {
        if ( (lpString = (LPTSTR) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETITEMDATA, nItem, 0L)) != (LPTSTR) LB_ERR )
        {
            FREE(lpString);
            SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_SETITEMDATA, nItem, 0L);
        }
    }
    SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_RESETCONTENT, 0, 0L);
}

static void EnumDirs(HWND hwndLB, LPTSTR lpSkuDir)
{
    WIN32_FIND_DATA FileFound;
    HANDLE          hFile;

    if ( (hFile = FindFirstFile(_T("*"), &FileFound)) != INVALID_HANDLE_VALUE )
    {
        do
        {
            // Look for all the directories that are not "." or "..".
            //
            if ( ( FileFound.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) &&
                 ( lstrcmp(FileFound.cFileName, _T(".")) ) &&
                 ( lstrcmp(FileFound.cFileName, _T("..")) ) )
            {
                // If we have a sku name already, then we just got the arch and we can
                // add the string to the list box now.  Otherwise we just got the sku
                // name and we have to call this function to get the arch.
                //
                if ( lpSkuDir ) 
                {
                    AddSkuToList(hwndLB, lpSkuDir, FileFound.cFileName, NULL, 0, 0);
                }
                else if ( SetCurrentDirectory(FileFound.cFileName) )
                {
                    EnumDirs(hwndLB, FileFound.cFileName);
                    SetCurrentDirectory(_T(".."));
                }
            }

        }
        while ( FindNextFile(hFile, &FileFound) );
        FindClose(hFile);
    }
}

// AllocateSPStrRes - allocate string resource for product name checking for .spx extension where x is SP number
//
// OUT:		lpdwSP - Service pack number
//
// RETURNS:	NULL if string not found, else pointer to product string
static LPTSTR AllocateSPStrRes(HINSTANCE hInstance, LPSTRRES lpsrTable, DWORD cbTable, LPTSTR lpString, LPTSTR * lplpReturn, DWORD *lpdwSP)
{
    LPSTRRES    lpsrSearch  = lpsrTable;
    LPTSTR      lpReturn    = NULL;
    BOOL        bFound;

    // Init this return value.
    //
    if ( lplpReturn )
        *lplpReturn = NULL;

    // Try to find the friendly name for this string in our table.
    //
    while ( ( bFound = ((DWORD) (lpsrSearch - lpsrTable) < cbTable) ) &&
            ( CompareString( MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE, lpString, 3, lpsrSearch->lpStr, 3 ) != CSTR_EQUAL )  )

    {
        lpsrSearch++;
    }

    // If it was found, allocate the friendly name from the resource.
    //
    if ( bFound )
    {
        // if this is a service pack, the last character of the dir name will be a digit
        // _wtol returns 0 if there is not a digit at the end which is what we want
        *lpdwSP= _wtol(lpString+lstrlen(lpString)-1);

        lpReturn = AllocateString(hInstance, lpsrSearch->uId);
        if ( lplpReturn )
            *lplpReturn = lpsrSearch->lpStr;
    }

    return lpReturn;
}

static INT AddSkuToList(HWND hwndLB, LPTSTR lpSkuDir, LPTSTR lpArchDir, LPTSTR lpReturn, DWORD cbReturn, DWORD dwSP)
{
    LPTSTR  lpSkuName = AllocateStrRes(NULL, s_srSkuDirs, AS(s_srSkuDirs), lpSkuDir, NULL),
            lpArchName  = AllocateStrRes(NULL, s_srArchDirs, AS(s_srArchDirs), lpArchDir, NULL),
            lpString,
            lpszItemData,
            lpszSkuSP;
    INT     nItem = LB_ERR;
    BOOL    bAllocatedName = TRUE;
    int	iStringLen;
    HRESULT hrPrintf;

    // We have an un-recognized product that we should add to the list
    //
    if ( lpSkuDir && !lpSkuName )
    {
        // check to see if this is a service pack
        if (!(lpSkuName   = AllocateSPStrRes(NULL, s_srSkuDirs, AS(s_srSkuDirs), lpSkuDir, NULL, &dwSP))) {
        
            // We don't want to try and free this at the end of the function
            //
            bAllocatedName = FALSE;
        
            // The friendly name is the sku dir that was entered
            //
            lpSkuName = lpSkuDir; 
        }
    }
    
    lpszSkuSP = AllocateString(NULL, IDS_SKU_SP);
    if ( ( lpSkuName && lpArchName ) && 
         ( lpString = MALLOC((lstrlen(lpSkuName) + lstrlen(lpArchName) + AS(STR_SKUARCH) + lstrlen(lpszSkuSP) + 1) * sizeof(TCHAR)) ) )
    {
        // Create the display name for the list box.
        //
        iStringLen=(lstrlen(lpSkuName) + lstrlen(lpArchName) + AS(STR_SKUARCH) + lstrlen(lpszSkuSP) + 1);
        hrPrintf=StringCchPrintf(lpString, iStringLen, STR_SKUARCH, lpSkuName ? lpSkuName : lpSkuDir, lpArchName ? lpArchName : lpArchDir);
        if (dwSP)
            hrPrintf=StringCchPrintf(lpString+lstrlen(lpString), iStringLen-lstrlen(lpString), lpszSkuSP, dwSP);

        // Check to see if we want to return the display string.
        //
        if ( lpReturn && cbReturn )
            lstrcpyn(lpReturn, lpString, cbReturn);

        // Add the string to the list box if we were passed in a list box handle.
        //
        if ( ( hwndLB ) &&
             ( (nItem = (INT) SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM) lpString)) >= 0 ) )
        {
            // Make sure we are able to save the sku and arch dir names as the item data, otherwise it is no good
            // and we have to delete the string from the list.
            //
            if ( ( (lpszItemData = MALLOC((lstrlen(lpSkuDir) + lstrlen(lpArchDir) + 2) * sizeof(TCHAR))) == NULL ) ||
                 ( SendMessage(hwndLB, LB_SETITEMDATA, nItem, (LPARAM) lpszItemData) == LB_ERR ) )

            {
                // Do'h... we have to remove it.
                //
                SendMessage(hwndLB, LB_DELETESTRING, nItem, 0L);
                nItem = LB_ERR;
                FREE(lpszItemData); // Macro checks for NULL.
            }
            else
            {
                // Store the two directory names in the same string, separated by a null character.
                //
                iStringLen=(lstrlen(lpSkuDir) + lstrlen(lpArchDir) + 2);
                lstrcpyn(lpszItemData, lpSkuDir,iStringLen);
                lstrcpyn(lpszItemData + lstrlen(lpszItemData) + 1, lpArchDir,(iStringLen -lstrlen(lpszItemData)-1));
            }
        }

        FREE(lpString);
    }

    // Only free lpSkuName if we allocated in the function
    //
    if ( bAllocatedName )
    {
        FREE(lpSkuName); // Macro checks for NULL.
    }

    FREE(lpArchName); // Macro checks for NULL.
    FREE(lpszSkuSP); // Macro checks for NULL.

    return nItem;
}

//  Note: lpszSrc and lpszDst must be at least size MAX_PATH
DWORD CopySkuFiles(HWND hwndProgress, HANDLE hEvent, LPTSTR lpszSrc, LPTSTR lpszDst, LPTSTR lpszInfFile)
{
    LPTSTR  lpszEndSrc  = lpszSrc + lstrlen(lpszSrc),
            lpszEndDst  = lpszDst + lstrlen(lpszDst);
    DWORD   dwRet       = 1,
            dwCount     = 0,
            dwLoop      = NUM_FIRST_SOURCE_DX;
    BOOL    bFound,
            bCopyOK;
    TCHAR   szDirKey[32],
            szDir[MAX_PATH];
    HRESULT hrPrintf;
    do
    {
        // Create the key we want to look for in the inf file.
        //
        hrPrintf=StringCchPrintf(szDirKey, AS(szDirKey), INI_KEY_DIR, dwLoop++);

        // Now see if that key exists.
        //
        szDir[0] = NULLCHR;
        if ( bFound = ( GetPrivateProfileString(INI_SEC_DIRS, szDirKey, NULLSTR, szDir, STRSIZE(szDir), lpszInfFile) && szDir[0] ) )
        {
            // Now setup the destination and source paths.
            //
            AddPathN(lpszSrc, szDir, MAX_PATH);
            AddPathN(lpszDst, szDir, MAX_PATH);

            // Copy the directory, if it fails we should error and bail.
            // Note that if the progress is NULL, then we are just doing
            // a count and we don't need to actually copy.
            //
            if ( hwndProgress == NULL )
                dwCount = dwCount + FileCount(lpszSrc);
            else
            {
                CopyDirectoryProgressCancel(hwndProgress, hEvent, lpszSrc, lpszDst);
            }

            // If we keep going we need to reset our root destination and source paths.
            //
            *lpszEndSrc = NULLCHR;
            *lpszEndDst = NULLCHR;
        }

        // on professional 32-bit skus, only copy the first Directory
        if (wcsstr(lpszDst,DIR_SKU_PRO) && wcsstr(lpszDst,DIR_ARCH_X86))
            break;
    }
    while ( dwRet && bFound );
    
    // Now return, either 0 for an error, or 1 for a successful copy,
    // or the count of files if hwndProgress is NULL.
    //
    return hwndProgress ? dwRet : dwCount;
}

static BOOL StartCopy(HWND hwnd, HANDLE hEvent, LPCOPYDIRDATA lpcdd)
{
    BOOL    bRet = TRUE;
    HANDLE  hThread;
    DWORD   dwThreadId;

    // Replace the old parent with the new progress dialog parent.
    //
    lpcdd->hwndParent = hwnd;

    // Need to pass in the cancel event as well.
    //
    lpcdd->hEvent = hEvent;

    // Now create the thread that will copy the actual files.
    //
    if ( hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) CopyDirectoryThread, (LPVOID) lpcdd, 0, &dwThreadId) )
        CloseHandle(hThread);
    else
        bRet = FALSE;

    return bRet;
}

DWORD WINAPI CopyDirectoryThread(LPVOID lpVoid)
{
    LPCOPYDIRDATA   lpcdd           = (LPCOPYDIRDATA) lpVoid;
    BOOL            bRet            = FALSE;
    INT_PTR         iRet            = PROGRESS_ERR_SUCCESS;
    HWND            hwnd            = lpcdd->hwndParent,
                    hwndProgress    = GetDlgItem(hwnd, IDC_PROGRESS);

    // First we need to create the path.
    //
    if ( CreatePath(lpcdd->szDst) )
    {
        // Setup the progress bar.
        //
        SendMessage(hwndProgress, PBM_SETSTEP, 1, 0L);
        SendMessage(hwndProgress, PBM_SETRANGE32, 0, (LPARAM) lpcdd->dwFileCount);

        // Now try and copy the files.
        //
        if ( !CopySkuFiles(hwndProgress, lpcdd->hEvent, lpcdd->szSrc, lpcdd->szDst, lpcdd->szInfFile) )
        {
            // Delete our destination directory if there is an error.  This removes just the Arch
            // folder... the folder for this sku might have some others in it.
            //
            DeletePath(lpcdd->szDst);

            // You have to reset the current directory before we try removing the folder for
            // this SKU because DeletePath leaves its current dir as the parent of the one
            // it removed.
            //
            SetCurrentDirectory(g_App.szOpkDir);

            // Now try to remove the folder for this SKU if it is empty (otherwise the RemoveDir
            // call just fails and we don't care).
            //
            *lpcdd->lpszEndSku = NULLCHR;
            RemoveDirectory(lpcdd->szDst);
        }
        else
            bRet = TRUE;
    }

    // Figure out our error code.
    //
    if ( !bRet )
    {
        if ( ( lpcdd->hEvent ) &&
             ( WaitForSingleObject(lpcdd->hEvent, 0) != WAIT_TIMEOUT ) )
        {
            iRet = PROGRESS_ERR_CANCEL;
        }
        else
            iRet = PROGRESS_ERR_COPYERR;
    }        

    // Now end the dialog with our error code.
    //
    EndDialog(hwnd, iRet);

    return bRet;
}

LRESULT CALLBACK ProgressDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static HANDLE hEvent;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            hEvent = CreateEvent(NULL, TRUE, FALSE, STR_EVENT_CANCEL);
            PostMessage(hwnd, WM_APP_STARTCOPY, 0, lParam);
            return FALSE;

        case WM_COMMAND:
        case WM_CLOSE:
            if ( hEvent )
                SetEvent(hEvent);
            else
                EndDialog(hwnd, PROGRESS_ERR_CANCEL);
            return FALSE;

        case WM_APP_STARTCOPY:
            if ( !StartCopy(hwnd, hEvent, (LPCOPYDIRDATA) lParam) )
                EndDialog(hwnd, PROGRESS_ERR_THREAD);
            break;

        case WM_DESTROY:
            if ( hEvent )
            {
                CloseHandle(hEvent);
                hEvent = NULL;
            }
            return FALSE;

        default:
            return FALSE;
    }

    return TRUE;
}

LRESULT CALLBACK SkuNameDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static LPTSTR   lpszRet = NULL;
    static DWORD    dwSize  = 0;

    switch (uMsg)
    {
        case WM_INITDIALOG:

            if ( lParam )
            {
                // We need to save the pointer to our return string buffer.
                //
                lpszRet = (LPTSTR) lParam;

                // The size of our string buffer is stored in the first 4 bytes of the string.
                //
                dwSize = *((LPDWORD) lParam);

                // Init our string buffer to a empty string.
                //
                *lpszRet = NULLCHR;

                // Limit the size of the string that can be entered.
                //
                SendDlgItemMessage(hwnd, IDC_SKU_NAME, EM_LIMITTEXT, dwSize ? dwSize - 1 : 0, 0L);
            }
            return FALSE;

        case WM_COMMAND:

            switch ( LOWORD(wParam) )
            {
                case IDOK:
                    if ( lpszRet && dwSize )
                        GetDlgItemText(hwnd, IDC_SKU_NAME, lpszRet, dwSize);
                    EndDialog(hwnd, 1);
                    break;

                case IDCANCEL:
                    EndDialog(hwnd, 0);
                    break;
            }
            return FALSE;

        default:
            return FALSE;
    }

    return TRUE;
}


BOOL OnSetActive(HWND hwnd) 
{
    TCHAR   szSku[256]  = NULLSTR,
            szArch[256] = NULLSTR;
    INT     nItem;
    LPTSTR  lpDirs;

    g_App.dwCurrentHelp = IDH_TARGET;

    if ( (nItem = (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCURSEL, 0, 0L)) ==  LB_ERR )
    {
        // Retrieve the settings from the winbom.
        //
        GetPrivateProfileString(INI_SEC_WINPE, INI_KEY_WBOM_WINPE_SKU, NULLSTR, szSku, STRSIZE(szSku), GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szWinBomIniFile);
        GetPrivateProfileString(INI_SEC_WINPE, INI_KEY_ARCH, NULLSTR, szArch, STRSIZE(szArch), g_App.szOpkWizIniFile);
    }
    else 
    {
        // Remember the selection from the item if an item was selected
        lpDirs = (LPTSTR) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETITEMDATA, nItem, 0L);
        lstrcpyn(szSku, lpDirs,AS(szSku));
        lstrcpyn(szArch, lpDirs + lstrlen(lpDirs) + 1,AS(szArch));
    }
 
    // We must have a lang at this point.
    //
    if ( g_App.szLangName[0] == NULLCHR )
    {
        MsgBox(GetParent(hwnd), IDS_ERR_INVALIDCONFIG, IDS_APPNAME, MB_ERRORBOX);
        WIZ_EXIT(hwnd);
    }

    
    // Remove all items from the list
    //
    OnDestroy(hwnd);
    
    // Setup the path buffer to the config dir for the
    // tag files we might need to look for.
    //
    SetupSkuListBox(GetDlgItem(hwnd, IDC_SKU_LIST), g_App.szLangName);

    // Look through the items in the list and select the one
    // that was in the winbom, if we find one.
    //
    nItem = (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCOUNT, 0, 0L);

    while ( --nItem >= 0)
    {
        lpDirs = (LPTSTR) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETITEMDATA, nItem, 0L);
        if ( lpDirs != (LPTSTR) LB_ERR )
        {
            if ( ( lstrcmpi(szSku, lpDirs) == 0 ) &&
                 ( lstrcmpi(szArch, lpDirs + lstrlen(lpDirs) + 1) == 0 ) )
            {
                SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_SETCURSEL, nItem, 0L);
            }
        }
    }
    
    if ( (INT) SendDlgItemMessage(hwnd, IDC_SKU_LIST, LB_GETCURSEL, 0, 0L) >= 0 )
    {
        WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);
        if ( GET_FLAG(OPK_BATCHMODE) &&
            OnNext(hwnd) )
        {
            WIZ_SKIP(hwnd);
        }
    }
    else
        WIZ_BUTTONS(hwnd, PSWIZB_BACK);
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\winpe.c ===
/****************************************************************************\

    WINPE.C / OPK Wizard (SETUPMGR.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1998
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the Win PE tools available in setupmgr.

    01/01 - Jason Cohen (JCOHEN)
        Added this new source file for the OPK Wizard.  It includes the new
        function to create the winpe floppy used by winpe to download this
        config set.

\****************************************************************************/


//
// Include File(s):
//

#include "pch.h"
#include "wizard.h"
#include "resource.h"


//
// Internal Defined Value(s):
//



//
// Internal Function Prototype(s):
//


//
// External Function(s):
//

BOOL MakeWinpeFloppy(HWND hwndParent, LPTSTR lpConfigName, LPTSTR lpWinBom)
{
    BOOL    bRet                    = FALSE,
            bDone;
    TCHAR   szFloppyFile[MAX_PATH]  = _T("a:\\");
    HCURSOR hcursorOld              = NULL,
            hcursorWait             = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));

    // First make the path to the winbom on the floppy drive.
    //
    AddPathN(szFloppyFile, FILE_WINBOM_INI,AS(szFloppyFile));

    do
    {
        // Ask them to insert the floppy disk.
        //
        if ( !(bDone = ( MsgBox(hwndParent, IDS_WINPEFLOPPY, IDS_APPNAME, MB_OKCANCEL | MB_APPLMODAL, lpConfigName) != IDOK )) )
        {
            // Make sure they want to overwrite any files that might
            // already be on there.
            //
            if ( ( !FileExists(szFloppyFile) ) ||
                 ( MsgBox(hwndParent, IDS_WINPEOVERWRITE, IDS_APPNAME, MB_YESNO | MB_ICONQUESTION, lpConfigName) == IDYES ) )
            {
                // Change to the wait cursor.
                //
                if ( hcursorWait )
                    hcursorOld = SetCursor(hcursorWait);

                if ( CopyFile(lpWinBom, szFloppyFile, FALSE) )
                {
                    // It worked, so woo hoo.
                    //
                    bRet = bDone = TRUE;

                    // Take out some stuff in the winbom that we don't want in there.
                    //
                    WritePrivateProfileSection(INI_SEC_WBOM_PREINSTALL, NULL, szFloppyFile);
                    WritePrivateProfileSection(INI_SEC_MFULIST, NULL, szFloppyFile);

                    // Write out stuff we only want in the WinPE WinBOM.
                    //
                    WritePrivateProfileString(WBOM_FACTORY_SECTION, INI_KEY_WBOM_FACTORY_TYPE, INI_VAL_WBOM_TYPE_WINPE, szFloppyFile);

                    // Reset the cursor.
                    //
                    SetCursor(hcursorOld);
                }
                else
                {
                    LPTSTR lpError = NULL;

                    // Get the error message string.
                    //
                    if ( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(), 0, (LPTSTR) &lpError, 0, NULL) == 0 )
                        lpError = NULL;

                    // Reset the cursor.
                    //
                    SetCursor(hcursorOld);

                    // See if they want to try again.
                    //
                    bDone = ( MsgBox(hwndParent, IDS_ERR_WINPEFLOPPY, IDS_APPNAME, MB_OKCANCEL | MB_ICONSTOP | MB_APPLMODAL, lpError ? lpError : NULLSTR) != IDOK );

                    // Free the error message string.
                    //
                    if ( lpError )
                        LocalFree((HLOCAL) lpError);
                }
            }
        }
    }
    while ( !bDone );

    // Only return TRUE if we created the floppy w/o error.
    //
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\chknames.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      chknames.c
//
// Description:
//  Code to check whether the given filename/netname/sharname etc...
//  contain illegal chars or not.
//
//  These are used to validate such things as the TargetPath setting,
//  net printers and computername.
//
//  Exports:
//  --------
//      IsValidComputerName
//      IsValidNetShareName
//      IsValidFileName8_3
//      IsValidPathNameNoRoot8_3ot.
//
//----------------------------------------------------------------------------

#include "pch.h"

//
// The below list of illegal netnames characters was stolen from setup
// source code during NT5 Beta3 timeframe (end of 1998).
//

LPTSTR IllegalNetNameChars = _T("\"/\\[]:|<>+=;,?*.");

//
// The below list of illegal filename characters were stolen from fileio
// test sources at NT5 Beta3 timeframe.
//
//      #define ILLEGAL_FAT_CHARS      "\"*+,/:;<=>?[]|\\"
//      #define ILLEGAL_FATLONG_CHARS  "\"*/:<>?|\\"
//      #define ILLEGAL_NETWARE_CHARS  "\"*+,/:;<=>?[]|\\ "
//      #define ILLEGAL_HPFS_CHARS     "\"*/:<>?|\\"
//      #define ILLEGAL_NTFS_CHARS     "\"*/<>?|\\"
//
// In addition to the above list, strict 8.3 also includes:
//   1. no spaces
//   2. only 1 dot
//

LPTSTR IllegalFatChars = _T("\"*+,/:;<=>?[]|\\ ");

//
// Enum constants, one of these must be passed to IsNameValid
//

enum {
    NAME_NETNAME = 1,
    NAME_FILESYS_8DOT3
};

//---------------------------------------------------------------------------
//
//  Function: IsNameValid
//
//  Purpose: Internal support routine that checks whether the given name
//           contains invalid chars or not.  The list of printable invalid
//           chars is given as an arg.  Control characters are always
//           invalid.
//
//---------------------------------------------------------------------------

static
BOOL
IsNameValid(
    LPTSTR NameToCheck,
    LPTSTR IllegalChars,
    int    iNameType
)
{
    UINT Length;
    UINT u;
    UINT nDots = 0;

    Length = lstrlen(NameToCheck);

    //
    // Want at least one character.
    //

    if(!Length) {
        return(FALSE);
    }

    //
    // No Leading/trailing spaces if this is a network name
    //

    if ( iNameType == NAME_NETNAME ) {
        if((NameToCheck[0] == _T(' ')) || (NameToCheck[Length-1] == _T(' '))) {
            return(FALSE);
        }
    }

    //
    // Control chars are invalid, as are characters in the illegal chars list.
    //
    for(u=0; u<Length; u++) {

        if( NameToCheck[u] <= _T(' ') )
        {
            return( FALSE );
        }
            
        if( wcschr( IllegalFatChars,NameToCheck[u] ) )
        {
            return( FALSE );
        }

        if( NameToCheck[u] == _T('.') )
        {
            nDots++;
        }

    }

    //
    // For 8.3 names be sure there is only max of 1 dot in the name, and
    // check that each part has <=8 and <=3 chars respectively.  Als, don't
    // allow a name like this: .foo.
    //

    if ( iNameType == NAME_FILESYS_8DOT3 ) {

        TCHAR *p;

        if ( nDots > 1 )
            return FALSE;

        if ( p = wcschr( NameToCheck, _T('.') ) ) {

            if ( p - NameToCheck > 8 || p - NameToCheck == 0 )
                return FALSE;

            if ( Length - (p - NameToCheck) - 1 > 3 )
                return FALSE;

        } else {

            if ( Length > 8 )
                return FALSE;
        }
    }

    //
    // We got here, name is ok.
    //

    return(TRUE);
}

//---------------------------------------------------------------------------
//
//  Function: IsNetNameValid
//
//  Purpose: Internal support routine to check for invalid chars in a
//           single piece of a network name.  See IsValidComputerName and
//           IsValidNetShareName.
//
//---------------------------------------------------------------------------
BOOL
IsNetNameValid(
    LPTSTR NameToCheck
)
{
    return IsNameValid(NameToCheck, IllegalNetNameChars, NAME_NETNAME);
}

//---------------------------------------------------------------------------
//
//  Function: IsValidComputerName
//
//  Purpose: Checks whether the given computer name contains invalid chars.
//
//---------------------------------------------------------------------------

BOOL
IsValidComputerName(
    LPTSTR ComputerName
)
{
    return IsNetNameValid(ComputerName);
}

//---------------------------------------------------------------------------
//
//  Function: IsValidNetShareName
//
//  Purpose: Checks whether the given netshare name contains invalid
//           chars, and whether it is of valid format.  Only \\srv\share
//           form is permitted.
//
//---------------------------------------------------------------------------

BOOL
IsValidNetShareName(
    LPTSTR NetShareName
)
{
    TCHAR *pEnd;

    //
    // Has to have \\ at the beginning
    //

    if ( NetShareName[0] != _T('\\') ||
         NetShareName[1] != _T('\\') )
        return FALSE;

    //
    // Isolate the 'srv' in \\srv\share and validate it for bogus chars
    //

    NetShareName += 2;

    if ( (pEnd = wcschr(NetShareName, _T('\\'))) == NULL )
        return FALSE;

    *pEnd = _T('\0');

    if ( ! IsNetNameValid(NetShareName) ) {
        *pEnd = _T('\\');
        return FALSE;
    }

    *pEnd = _T('\\');

    //
    // Validate the 'share' in \\srv\share
    //

    pEnd++;

    if ( ! IsNetNameValid(pEnd) )
        return FALSE;

    return( TRUE );
}

//---------------------------------------------------------------------------
//
//  Function: IsValidFileName8_3
//
//  Purpose: Checks whether the given filename, or single piece of a pathname
//           contains invalid chars or not, and whether it follows 8.3 naming
//           rules.
//
//---------------------------------------------------------------------------

BOOL
IsValidFileName8_3(
    LPTSTR FileName
)
{
    TCHAR *p;
    int nDots;

    //
    // Check for illegal chars, lead/trail whitespace is illegal for 8.3
    //

    if ( ! IsNameValid(FileName, IllegalFatChars, NAME_FILESYS_8DOT3) )
        return FALSE;

    //
    // Be sure there is zero or one dot
    //

    for ( p=FileName, nDots=0; *p; p++ ) {
        if ( *p == _T('.') )
            nDots++;
    }

    if ( nDots > 1 )
        return FALSE;

    return TRUE;
}

//---------------------------------------------------------------------------
//
//  Function: IsValidPathNameNoRoot8_3
//
//  Purpose: Checks whether the given pathname contains invalid chars or not.
//           A drive_letter: or \\unc\name are not permitted.  The pathname
//           must also follow strict 8.3 rules.  This is useful for
//           TargetPath setting (for e.g.)
//
//---------------------------------------------------------------------------

BOOL
IsValidPathNameNoRoot8_3(
    LPTSTR PathName
)
{
    TCHAR *p = PathName, *pEnd, Remember;

    //
    // No UNC names
    //

    if ( PathName[0] == _T('\\') && PathName[1] == _T('\\') )
        return FALSE;

    //
    // No drive letter allowed
    //

    if ( towupper(PathName[0]) >= _T('A') &&
         towupper(PathName[0]) <= _T('Z') &&
         PathName[1] == _T(':')         ) {

        return FALSE;
    }

    //  
    // Loop until the end of this string breaking out each piece of
    // the pathname and checking for bad chars.
    //
    // e.g. foo1\foo2\foo3, call IsValidFileName8_3() 3 times with the
    // little piece.
    //

    do {

        while ( *p && *p == _T('\\') )
            p++;

        for ( pEnd = p; *pEnd && *pEnd != _T('\\'); pEnd++ )
            ;
            
        Remember = *pEnd;
        *pEnd = _T('\0');

        if ( ! IsValidFileName8_3(p) ) {
            *pEnd = Remember;
            return FALSE;
        }

        *pEnd = Remember;
        p = pEnd;

    } while ( *p );

    //
    // Made it here, we're ok
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\oem\startmnu.c ===
/****************************************************************************\

    STARTMNU.C / OPK Wizard (OPKWIZ.EXE)

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 2000
    All rights reserved

    Source file for the OPK Wizard that contains the external and internal
    functions used by the "Start Menu MFU List" wizard page.

    11/2000 - Sankar Ramasubramanian (SANKAR)

\****************************************************************************/


//
// Include File(s):
//
#include "pch.h"
#include "wizard.h"
#include "resource.h"

// We allow a maximum of 4 links to be added.
#define MAX_LINKS   3
//
// Internal Function Prototype(s):
//

static BOOL OnInit(HWND, HWND, LPARAM);
static void SaveData(HWND hwnd);


//
// External Function(s):
//

LRESULT CALLBACK StartMenuDlgProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_INITDIALOG, OnInit);

        case WM_NOTIFY:
            switch ( ((NMHDR FAR *) lParam)->code )
            {
                case PSN_KILLACTIVE:
                case PSN_RESET:
                case PSN_WIZFINISH:
                case PSN_WIZBACK:
                    break;

                case PSN_WIZNEXT:
                    // We can not validate the data here because these links entered by them do not
                    // exist now. They get validated during the factory.exe run time. So, we simply
                    // save the data here.
                    SaveData(hwnd);
                    break;

                case PSN_SETACTIVE:
                    g_App.dwCurrentHelp = IDH_STARTMENU_MFU;

                    WIZ_BUTTONS(hwnd, PSWIZB_BACK | PSWIZB_NEXT);

                    // Press next if the user is in auto mode
                    //
                    WIZ_NEXTONAUTO(hwnd, PSBTN_NEXT);

                    break;

                case PSN_QUERYCANCEL:
                    WIZ_CANCEL(hwnd);
                    break;

                case PSN_HELP:
                    WIZ_HELP();
                    break;

                default:
                    return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Internal Function(s):
//

static BOOL OnInit(HWND hwnd, HWND hwndFocus, LPARAM lParam)
{
    int iIndex;
    TCHAR szPath[MAX_PATH];
    TCHAR szKeyName[20];
    HRESULT hrPrintf;

    //
    // Populate the Links 1 to 4.
    //
    for(iIndex = 0; iIndex < MAX_LINKS; iIndex++)
    {
        szPath[0] = NULLCHR;
        hrPrintf=StringCchPrintf(szKeyName, AS(szKeyName), INI_KEY_MFULINK, iIndex);
        GetPrivateProfileString(INI_SEC_MFULIST, szKeyName, szPath, szPath, STRSIZE(szPath), GET_FLAG(OPK_BATCHMODE) ? g_App.szOpkWizIniFile : g_App.szWinBomIniFile);
        SendDlgItemMessage(hwnd, (IDC_PROGRAM_1+iIndex), EM_LIMITTEXT, STRSIZE(szPath) - 1, 0);
        SetDlgItemText(hwnd, IDC_PROGRAM_1+iIndex, szPath);
    }

    // Always return false to WM_INITDIALOG.
    //
    return FALSE;
}

static void SaveData(HWND hwnd)
{
    int iIndex;
    TCHAR szPath[MAX_PATH];
    TCHAR szKeyName[20];
    HRESULT hrPrintf;

    //
    // Save the Links 1 to 4.
    //
    for(iIndex = 0; iIndex < MAX_LINKS; iIndex++)
    {
        szPath[0] = NULLCHR;
        if( hwnd ) 
        {
            TCHAR szExpanded[MAX_PATH];
            GetDlgItemText(hwnd, IDC_PROGRAM_1+iIndex, szExpanded, STRSIZE(szExpanded));
            if (!PathUnExpandEnvStrings(szExpanded, szPath, STRSIZE(szPath)))
            {
                lstrcpyn(szPath, szExpanded, STRSIZE(szPath));
            }
        }
        hrPrintf=StringCchPrintf(szKeyName, AS(szKeyName), INI_KEY_MFULINK, iIndex);
        WritePrivateProfileString(INI_SEC_MFULIST, szKeyName, szPath, g_App.szWinBomIniFile);
        WritePrivateProfileString(INI_SEC_MFULIST, szKeyName, szPath, g_App.szOpkWizIniFile);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\pch.h ===
#include "setupmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\listbox.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      listbox.c
//
// Description:
//      This file contains supplemental functions for list boxes throughout
//      the wizard.
//
//----------------------------------------------------------------------------

#include "pch.h"

//----------------------------------------------------------------------------
//
// Function: OnUpButtonPressed
//
// Purpose:  Generic procedure called whenever a user clicks the Up arrow
//           button on any of the property pages
//
//           this function shifts the currently selected item up one entry in
//           the list box
//
// Arguments:  IN HWND hwnd - handle to the dialog with the list box
//             IN WORD ListBoxControlID - control ID of the list box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnUpButtonPressed( IN HWND hwnd, IN WORD ListBoxControlID )
{

    INT_PTR   iIndex;
    TCHAR szBuffer[MAX_INILINE_LEN];
    HWND  hListBox = GetDlgItem( hwnd, ListBoxControlID );

    iIndex = SendMessage( hListBox, LB_GETCURSEL, 0, 0 );

    //
    //  If there is no currently selected item, do nothing
    //

    if( iIndex == LB_ERR )
    {
        return;
    }

    SendMessage( hListBox, LB_GETTEXT, iIndex, (LPARAM) szBuffer );

    SendMessage( hListBox, LB_DELETESTRING, iIndex, 0 );

    //
    // -1 so it inserts it before the current item
    //

    SendMessage( hListBox, LB_INSERTSTRING, iIndex - 1, (LPARAM) szBuffer );

    SendMessage( hListBox, LB_SETCURSEL, iIndex - 1, 0 );

}

//----------------------------------------------------------------------------
//
// Function: OnDownButtonPressed
//
// Purpose:  Generic procedure called whenever a user clicks the Down arrow
//           button on any of the property pages
//
//             this function shifts the currently selected item down one entry
//           in the list box
//
// Arguments:  IN HWND hwnd - handle to the dialog with the list box
//             IN WORD ListBoxControlID - control ID of the list box
//
// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
OnDownButtonPressed( IN HWND hwnd, IN WORD ListBoxControlID )
{

    INT_PTR  iIndex;
    TCHAR szBuffer[MAX_INILINE_LEN];
    HWND hListBox = GetDlgItem( hwnd, ListBoxControlID );

    iIndex = SendMessage( hListBox, LB_GETCURSEL, 0, 0 );

    //
    //  If there is no currently selected item, do nothing
    //

    if( iIndex == LB_ERR )
    {
        return;
    }

    SendMessage( hListBox, LB_GETTEXT, iIndex, (LPARAM) szBuffer );

    SendMessage( hListBox, LB_DELETESTRING, iIndex, 0 );

    //
    // +1 so it inserts it after the current item
    //
    SendMessage( hListBox, LB_INSERTSTRING, iIndex + 1, (LPARAM) szBuffer );

    SendMessage( hListBox, LB_SETCURSEL, iIndex + 1, 0 );

}

//----------------------------------------------------------------------------
//
// Function: SetArrows
//
// Purpose:  this function examines the entries in the list box and enables
//           and disables the up and down arrows appropriately
//
// Arguments:
//      IN HWND hwnd - handle to the dialog
//      IN WORD ListBoxControlID - the list box to set the arrows for
//      IN WORD UpButtonControlID   - the up button associated with the
//                                    list box
//      IN WORD DownButtonControlID - the down button associated with the
//                                    list box


// Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
SetArrows( IN HWND hwnd,
           IN WORD ListBoxControlID,
           IN WORD UpButtonControlID,
           IN WORD DownButtonControlID )
{

    INT_PTR iIndex;
    INT_PTR iCount;

    HWND hListBox    = GetDlgItem( hwnd, ListBoxControlID    );
    HWND hUpButton   = GetDlgItem( hwnd, UpButtonControlID   );
    HWND hDownButton = GetDlgItem( hwnd, DownButtonControlID );

    iCount = SendMessage( hListBox, LB_GETCOUNT, 0, 0 );

    if( iCount < 2 )
    {

        EnableWindow( hUpButton, FALSE );

        EnableWindow( hDownButton, FALSE );

    }
    else
    {

        iIndex = SendMessage( hListBox, LB_GETCURSEL, 0, 0 );

        // case when the first item is selected
        if( iIndex == 0 )
        {

            EnableWindow( hUpButton, FALSE );

            EnableWindow( hDownButton, TRUE );

        }
        // case when the last item is selected, -1 because iIndex is zero-based
        else if( iIndex == (iCount - 1) )
        {

            EnableWindow( hUpButton, TRUE );

            EnableWindow( hDownButton, FALSE );

        }
        // case when an item in the middle is selected
        else
        {

            EnableWindow( hUpButton, TRUE );

            EnableWindow( hDownButton, TRUE );

        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\fileio.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      fileio.c
//
// Description:
//    Isolate CRT fileio stuff so any necessary character translation can
//    be done easily.  Some of these are implemented as macros in supplib.h
//
//----------------------------------------------------------------------------

#include "pch.h"

FILE*
My_fopen(
    LPWSTR FileName,
    LPWSTR Mode
)
{
    return _wfopen(FileName, Mode);
}

int
My_fputs(
    LPWSTR Buffer,
    FILE*  fp
)
{
    return fputws(Buffer, fp);
}

LPWSTR
My_fgets(
    LPWSTR Buffer,
    int    MaxChars,
    FILE*  fp
)
{
    return fgetws(Buffer, MaxChars, fp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\msg.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      msg.c
//
// Description:
//      This file contains the low-level error reporting routines.
//
//----------------------------------------------------------------------------

#include "pch.h"

#define MAX_ERROR_MSG_LEN     1024
#define MAX_ERROR_CAPTION_LEN 64
#define MAJORTYPE_MASK        0xff

static TCHAR *StrError = NULL;

int
ReportErrorLow(
    HWND    hwnd,
    DWORD   dwMsgType,
    LPTSTR  lpMessageStr,
    va_list arglist);

int
__cdecl
ReportErrorId(
    HWND   hwnd,            // calling window
    DWORD  dwMsgType,       // combo of MSGTYPE_*
    UINT   StringId,
    ...)
{
    int iRet;
    va_list arglist;
    TCHAR *Str;

    Str = MyLoadString(StringId);

    if ( Str == NULL ) {
        AssertMsg(FALSE, "Invalid StringId");
        return IDCANCEL;
    }

    va_start(arglist, StringId);

    iRet = ReportErrorLow(hwnd,
                          dwMsgType,
                          Str,
                          arglist);
    va_end(arglist);
    free(Str);
    return iRet;
}

//---------------------------------------------------------------------------
//
// Function: ReportErrorLow
//
// Purpose: This is the routine to report errors to the user for the
//          Setup Manager wizard.
//
// Arguments:
//      HWND   hwnd         - calling window
//      DWORD  dwMsgType    - combo of MSGTYPE_* (see supplib.h)
//      LPTSTR lpMessageStr - message string
//      va_list arglist     - args to expand
//
// Returns:
//      Whatever MessageBox returns.
//
//---------------------------------------------------------------------------

int
ReportErrorLow(
    HWND    hwnd,            // calling window
    DWORD   dwMsgType,       // combo of MSGTYPE_*
    LPTSTR  lpMessageStr,    // passed to sprintf
    va_list arglist)
{
    DWORD dwLastError;
    DWORD dwMajorType;
    TCHAR MessageBuffer[MAX_ERROR_MSG_LEN]     = _T("");
    TCHAR CaptionBuffer[MAX_ERROR_CAPTION_LEN] = _T("");
    DWORD dwMessageBoxFlags;
    HRESULT hrPrintf;

    //
    // Hurry and get the last error before it changes.
    //

    if ( dwMsgType & MSGTYPE_WIN32 )
        dwLastError = GetLastError();

    if( StrError == NULL )
    {
        StrError = MyLoadString( IDS_ERROR );
    }

    //
    // Caller must specify _err or _warn or _yesno or _retrycancel, and
    // Caller must specify only one of them
    //
    // Note, we reserved 8 bits for the "MajorType".
    //

    dwMajorType = dwMsgType & MAJORTYPE_MASK;

    if ( dwMajorType != MSGTYPE_ERR &&
         dwMajorType != MSGTYPE_WARN &&
         dwMajorType != MSGTYPE_YESNO &&
         dwMajorType != MSGTYPE_RETRYCANCEL ) {

        AssertMsg(FALSE, "Invalid MSGTYPE");
    }

    //
    // Expand the string and varargs the caller might have passed in.
    //

    if ( lpMessageStr )
        hrPrintf=StringCchVPrintf(MessageBuffer, AS(MessageBuffer), lpMessageStr, arglist);

    //
    // Retrieve the error message for the Win32 error code and suffix
    // it onto the callers expanded string.
    //

    if ( dwMsgType & MSGTYPE_WIN32 ) {

        TCHAR *pEndOfBuff = MessageBuffer + lstrlen(MessageBuffer);

        hrPrintf=StringCchPrintf(pEndOfBuff, (AS(MessageBuffer)-lstrlen(MessageBuffer)), _T("\r\n\r%s #%d: "), StrError, dwLastError);
        pEndOfBuff += lstrlen(pEndOfBuff);

        FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                      0,
                      dwLastError,
                      0,
                      pEndOfBuff,
                      (DWORD)(MAX_ERROR_MSG_LEN - (pEndOfBuff-MessageBuffer)),
                      NULL);
    }

    if( g_StrWizardTitle == NULL )
    {
        g_StrWizardTitle = MyLoadString( IDS_WIZARD_TITLE );
    }

    //
    // Set the caption and compute the flags to pass to MessageBox()
    //
    lstrcpyn( CaptionBuffer, g_StrWizardTitle, AS(CaptionBuffer) );

    dwMessageBoxFlags = MB_OK | MB_ICONERROR;

    if ( dwMajorType == MSGTYPE_YESNO )
        dwMessageBoxFlags = MB_YESNO | MB_ICONQUESTION;

    else if ( dwMajorType == MSGTYPE_WARN )
        dwMessageBoxFlags = MB_OK | MB_ICONWARNING;

    else if ( dwMajorType == MSGTYPE_RETRYCANCEL )
        dwMessageBoxFlags = MB_RETRYCANCEL | MB_ICONERROR;

    //
    // Display the error message
    //

    return MessageBox(hwnd,
                      MessageBuffer,
                      CaptionBuffer,
                      dwMessageBoxFlags);
}

//---------------------------------------------------------------------------
//
//  Function: SetupMgrAssert
//
//  Purpose: Reports DBG assertion failures.
//
//  Note: Only pass ANSI strings.
//        Use the macros in supplib.h.
//
//---------------------------------------------------------------------------

#if DBG
VOID __cdecl SetupMgrAssert(char *pszFile, int iLine, char *pszFormat, ...)
{
    char Buffer[MAX_ERROR_MSG_LEN], *pEnd;
    va_list arglist;
    HRESULT hrPrintf;

    if ( pszFormat ) {
        va_start(arglist, pszFormat);
        hrPrintf=StringCchVPrintfA(Buffer, AS(Buffer), pszFormat, arglist);
        va_end(arglist);
    }

    hrPrintf=StringCchPrintfA(Buffer+strlen(Buffer), MAX_ERROR_MSG_LEN-strlen(Buffer), "\r\nFile: %s\r\nLine: %d", pszFile, iLine);

    MessageBoxA(NULL,
                Buffer,
                "Assertion Failure",
                MB_OK);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\hstemp.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      hsload.c
//
// Description:
//
//      The functions in this file are a workaround.  Ideally they should be
//      merged in with non-Hal/SCSI equivalents of these functions.  The
//      decision was made to fix a HAL/SCSI bug and we are close to RTM so
//      these extra functions were created to not jeopardize the standard
//      answerfile write out.  Sometime post-RTM these functions should be
//      merged back into the core write out and queueing routines.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "settypes.h"

LINKED_LIST *SelectSettingQueue(QUEUENUM dwWhichQueue);

BOOL DoesSectionHaveKeys( SECTION_NODE *pSection );

BOOL SettingQueueHalScsi_Flush(LPTSTR   lpFileName,
                               QUEUENUM dwWhichQueue);

BOOL SettingQueueHalScsi_AddSetting(LPTSTR   lpSection,
                                    LPTSTR   lpKey,
                                    LPTSTR   lpValue,
                                    QUEUENUM dwWhichQueue);

SECTION_NODE * SettingQueue_AddSection(LPTSTR lpSection, QUEUENUM dwWhichQueue);

KEY_NODE* FindKey(LINKED_LIST *ListHead,
                  LPTSTR       lpKeyName);

VOID InsertNode(LINKED_LIST *pList, PVOID pNode);


//----------------------------------------------------------------------------
//
//  Function: IsBlankLine
//
//  Purpose: 
//
//----------------------------------------------------------------------------
BOOL
IsBlankLine( TCHAR * pszBuffer )
{

    TCHAR * p = pszBuffer;

    while( *p != _T('\0') )
    {
        if( ! _istspace( *p ) )
        {
            return( FALSE );
        }

        p++;

    }

    return( TRUE );

}

//----------------------------------------------------------------------------
//
//  Function: LoadOriginalSettingsLowHalScsi
//
//  Purpose: 
//
//----------------------------------------------------------------------------

VOID
LoadOriginalSettingsLowHalScsi(HWND     hwnd,
                               LPTSTR   lpFileName,
                               QUEUENUM dwWhichQueue)
{
    TCHAR Buffer[MAX_INILINE_LEN];
    FILE  *fp;

    TCHAR SectionName[MAX_ININAME_LEN + 1] = _T("");
    TCHAR KeyName[MAX_ININAME_LEN + 1]     = _T("");
    TCHAR *pValue;

    //
    // Open the answer file for reading
    //

    if ( (fp = My_fopen( lpFileName, _T("r") )) == NULL )
        return;

    //
    // Read each line
    //

    while ( My_fgets(Buffer, MAX_INILINE_LEN - 1, fp) != NULL ) {

        BOOL bSectionLine         = FALSE;
        BOOL bCreatedPriorSection = FALSE;

        TCHAR *p;
        TCHAR *pEqual;

        //
        //  A semicolon(;) denotes that the rest of the line is a comment.
        //  Thus, if a semicolon(;) exists in the Buffer, place a null char
        //  there and send the Buffer on for further processing.
        //

        //
        // Look for [SectionName]
        //

        if ( Buffer[0] == _T('[') ) {

            for ( p=Buffer+1; *p && *p != _T(']'); p++ )
                ;

            if ( p ) {
                *p = _T('\0');
                bSectionLine = TRUE;
            }
        }

        //
        // If this line has [SectionName], be sure we made a section node
        // on the setting queue before overwriting SectionName buffer.  This
        // is the only way to get the SettingQueueFlush routine to write
        // out an empty section.  The user had an empty section originally,
        // so we'll preserve it.
        //

        if( bSectionLine )
        {
            lstrcpyn(SectionName, Buffer+1, AS(SectionName));
        }
        else {

            //
            // if its not a Section line or a blank line then just add the full line to the
            // queue under its appropriate section
            //

            if( ! IsBlankLine( Buffer ) )
            {

                //
                //  Don't add the key unless it has a section to go under.  This has the side
                //  effect of striping comments from the top of txtsetup.oem.
                //

                if( SectionName[0] != _T('\0') )
                {

                    SettingQueueHalScsi_AddSetting(SectionName,
                                                   L"",
                                                   Buffer,
                                                   dwWhichQueue);

                    bCreatedPriorSection = TRUE;

                }

            }

        }

    }

    My_fclose(fp);
    return;
}


//----------------------------------------------------------------------------
//
// Function: SettingQueueHalScsi_Flush
//
// Purpose: This function is called (by the wizard) once all the settings
//          have been queued for Hal and SCSI.
//
// Arguments:
//      LPTSTR lpFileName   - name of file to create/edit
//      DWORD  dwWhichQueue - which queue, answers file, .udf, ...
//
// Returns:
//      BOOL - success
//
//----------------------------------------------------------------------------

BOOL
SettingQueueHalScsi_Flush(LPTSTR   lpFileName,
                          QUEUENUM dwWhichQueue)
{
    LINKED_LIST *pList;
    SECTION_NODE *pSection;
    KEY_NODE *pKey;
    TCHAR Buffer[MAX_INILINE_LEN];
    FILE *fp;
    INT BufferSize = sizeof(Buffer) / sizeof(TCHAR);
    HRESULT hrPrintf;

    //
    // Point to the proper queue to flush
    //

    pList = SelectSettingQueue(dwWhichQueue);
    if (pList == NULL)
        return FALSE;
    pSection = (SECTION_NODE *) pList->Head;

    //
    // Start writing the file
    //

    if( ( fp = My_fopen( lpFileName, _T("w") ) ) == NULL ) {

        return( FALSE );

    }

    if( My_fputs( _T(";SetupMgrTag\n"), fp ) == _TEOF ) {

        My_fclose( fp );

        return( FALSE );
    }

    //
    // For each section ...
    //

    for ( pSection = (SECTION_NODE *) pList->Head;
          pSection;
          pSection = (SECTION_NODE *) pSection->Header.next ) {

        Buffer[0] = _T('\0');

        //
        // We don't write out sections that are still marked volatile.
        //

        if ( pSection->bVolatile )
            continue;

        //
        // Write the section name only if we will write keys below it
        //
        // ISSUE-2002/02/28-stelo- this causes problems because we want to write out
        // some sections without keys, like:
        //
        //[NetServices]
        //    MS_SERVER=params.MS_SERVER
        //
        //[params.MS_SERVER]
        //
        //  How can we get around this?
        //
        if( DoesSectionHaveKeys( pSection ) ) {

            hrPrintf=StringCchPrintf(Buffer, 
                       AS(Buffer),
                       _T("[%s]\n"),
                       pSection->lpSection);

        }
        else {

            continue;

        }

        if( My_fputs( Buffer, fp ) == _TEOF ) {

            My_fclose( fp );

            return( FALSE );

        }

        //
        // Write out the value
        //

        for ( pKey = (KEY_NODE *) pSection->key_list.Head;
              pKey;
              pKey = (KEY_NODE *) pKey->Header.next ) {

            TCHAR *p;

            Buffer[0] = _T('\0');

            //
            // An empty value means to not write it
            //

            if ( pKey->lpValue[0] == _T('\0') )
                continue;


            //
            // Put the key we want into Buffer
            //

            lstrcatn( Buffer, pKey->lpValue, BufferSize );

            if( My_fputs( Buffer, fp ) == _TEOF ) {

                My_fclose( fp );

                return( FALSE );

            }

        }

        //
        // Write a blank line at the end of the section
        //

        hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("\n"));

        if( My_fputs( Buffer, fp ) == _TEOF ) {

            My_fclose( fp );

            return( FALSE );

        }

    }

    My_fclose( fp );

    return( TRUE );
}

//----------------------------------------------------------------------------
//
// Function: FindValue
//
// Purpose: Searches the given list of keynodes and finds one with the
//          given name.
//
// Arguments:
//      LPTSTR lpSection - name of section in .ini
//
// Returns:
//      SECTION_NODE * or NULL if it does not exist
//
// Notes:
//  - Searches are case insensitive
//
//----------------------------------------------------------------------------

KEY_NODE* FindValue(LINKED_LIST *ListHead,
                    LPTSTR       lpValue)
{
    KEY_NODE *p = (KEY_NODE *) ListHead->Head;

    if ( p == NULL )
        return NULL;

    do {
        if ( _tcsicmp(p->lpValue, lpValue) == 0 )
            break;
        p = (KEY_NODE *) p->Header.next;
    } while ( p );

    return p;
}

//----------------------------------------------------------------------------
//
// Function: SettingQueueHalScsi_AddSetting
//
// Purpose:  Same as SettingQueue_AddSetting except with HAL and SCSI all of 
//  the enties under a section are values, there are no keys.  So don't add a
//  setting if the value is already there.
//
// Arguments:

//
// Returns:

//
//----------------------------------------------------------------------------
BOOL SettingQueueHalScsi_AddSetting(LPTSTR   lpSection,
                                    LPTSTR   lpKey,
                                    LPTSTR   lpValue,
                                    QUEUENUM dwWhichQueue)
{
    SECTION_NODE *pSectionNode;
    KEY_NODE     *pKeyNode;

    //
    // You have to pass a section key and value.  Section name cannot
    // be empty.
    //

    Assert(lpSection != NULL);
    Assert(lpKey != NULL);
    Assert(lpValue != NULL);
    Assert(lpSection[0]);

    //
    // See if a node for this section already exists.  If not, create one.
    //

    pSectionNode = SettingQueue_AddSection(lpSection, dwWhichQueue);
    if ( pSectionNode == NULL )
        return FALSE;

    //
    // See if this key has already been set.  If not, alloc a node and
    // set all of its fields except for the lpValue.
    //
    // If the node already exist, free the lpValue to make room for
    // the new value.
    //

    pKeyNode = FindValue( &pSectionNode->key_list, lpValue );

    if( pKeyNode == NULL ) {

        if ( (pKeyNode=malloc(sizeof(KEY_NODE))) == NULL )
            return FALSE;

        if ( (pKeyNode->lpKey = lstrdup(lpKey)) == NULL )
        {
            free(pKeyNode);
            return FALSE;
        }
        InsertNode(&pSectionNode->key_list, pKeyNode);

    } else {

#if DBG
        //
        // If the wizard has already set this key once, assert.
        //

        if ( pKeyNode->bSetOnce ) {
            AssertMsg2(FALSE,
                       "Section \"%S\" Key \"%S\" has already been set",
                       lpSection, lpKey);
        }
#endif

        free(pKeyNode->lpValue);
    }

#if DBG
    //
    // If this is going to an output queue, mark this setting as
    // having already been set by the wizard.
    //
    // Note that when the input queue is copied to the output queue,
    // the copy function preserves this setting.
    //

    pKeyNode->bSetOnce = ( (dwWhichQueue == SETTING_QUEUE_ANSWERS) |
                           (dwWhichQueue == SETTING_QUEUE_UDF) );
#endif

    //
    // Put the (possibly new) value in
    //

    if ( (pKeyNode->lpValue = lstrdup(lpValue)) == NULL )
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sprestrt\fileren.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    fileren.c

Abstract:

    This program is used to help make GUI Setup restartable,
    if setup was started in restartable mode.


Author:

    Souren Aghajanyan (sourenag) July 2001

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "msg.h"

#include "psp.h"

#define MAX_DOS_PATH_IN_NT_PATH 260
#define TXT_FILE_UNICODE_SIGN   0xfeff
#define SIZE_ULONG64(x, y)  (((ULONGLONG)x)-((ULONGLONG)y))

const PCWSTR UndoFilePath = L"\\SystemRoot\\System32\\UNDO_GUIMODE.TXT";

typedef struct _SP_FILE_OPERATION {
    LIST_ENTRY Entry;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
} SP_FILE_OPERATION, *PSP_FILE_OPERATION;

BOOLEAN
SpRemoveFileObject_U(
    IN PUNICODE_STRING FileObjectPath
    );

NTSTATUS
SpSaveFileOperation(
    IN OUT PLIST_ENTRY ListHead,
    IN PCWSTR Name,
    IN PCWSTR Value OPTIONAL
    )
{
    PSP_FILE_OPERATION p = NULL;
    UNICODE_STRING UnicodeName;
    UNICODE_STRING UnicodeValue;

    RtlInitUnicodeString( &UnicodeName, Name );
    RtlInitUnicodeString( &UnicodeValue, Value );

    p = (PSP_FILE_OPERATION)MALLOC(sizeof(*p) + UnicodeName.MaximumLength);
    if(!p){
        return STATUS_NO_MEMORY;
    }

    InitializeListHead(&p->Entry);
    p->Name.Buffer = (PWSTR)(p+1);
    p->Name.Length = UnicodeName.Length;
    p->Name.MaximumLength = UnicodeName.MaximumLength;
    RtlMoveMemory(p->Name.Buffer,
                  UnicodeName.Buffer,
                  UnicodeName.MaximumLength);
    p->Value.Buffer = NULL;
    InsertHeadList( ListHead, &p->Entry );

    if (p->Value.Buffer != NULL) {
        FREE(p->Value.Buffer);
        }

    if(ARGUMENT_PRESENT(Value)){
        p->Value.Buffer = (PWSTR)MALLOC(UnicodeValue.MaximumLength);
        if(!p->Value.Buffer){
            RemoveEntryList(&p->Entry);
            FREE(p);
            return STATUS_NO_MEMORY;
        }

        p->Value.Length = UnicodeValue.Length;
        p->Value.MaximumLength = UnicodeValue.MaximumLength;
        RtlMoveMemory(p->Value.Buffer,
                      UnicodeValue.Buffer,
                      UnicodeValue.MaximumLength);
    }
    else {
        RtlInitUnicodeString(&p->Value, NULL);
    }

    return STATUS_SUCCESS;
}

VOID
SpProcessFileRenames(
    IN PLIST_ENTRY pFileRenameList
    )
{
    NTSTATUS Status;
    NTSTATUS OpenStatus;
    PLIST_ENTRY Next;
    PLIST_ENTRY thisEntry;
    PSP_FILE_OPERATION p;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE OldFileHandle,SetAttributesHandle;
    PFILE_RENAME_INFORMATION RenameInformation;
    FILE_INFORMATION_CLASS SetInfoClass;
    FILE_BASIC_INFORMATION BasicInfo;
    ULONG SetInfoLength;
    PVOID SetInfoBuffer;
    PWSTR s;
    BOOLEAN WasEnabled;
    UNICODE_STRING NewName;
    int pass;


    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &WasEnabled);
    if(!NT_SUCCESS(Status)){
        WasEnabled = TRUE;
    }

    //
    // Process the list of file rename operations.
    //

    for (pass = 0 ; pass < 2 ; pass++) {

        thisEntry = pFileRenameList->Flink;

        while (thisEntry != pFileRenameList) {

            p = CONTAINING_RECORD(thisEntry, SP_FILE_OPERATION, Entry);
            thisEntry = thisEntry->Flink;

            DbgPrint("SPRESTRT: FileRename( [%wZ] => [%wZ] )\n", &p->Name, &p->Value);

            //
            // We left all syntax and fuctionality SMSS FileRename supports.
            //

            Status = 0;

            if(p->Value.Length){
                if (pass == 0) {
                    //
                    // We have target path and it means rename operation
                    //
                    if(p->Name.Buffer[0] == '@'){
                        p->Name.Buffer += 1;
                        p->Name.Length -= sizeof(WCHAR);
                    }

                    InitializeObjectAttributes(&ObjectAttributes,
                                               &p->Name,
                                               OBJ_CASE_INSENSITIVE,
                                               NULL,
                                               NULL);

                    Status = NtOpenFile(&OldFileHandle,
                                        (ACCESS_MASK)DELETE | SYNCHRONIZE,
                                        &ObjectAttributes,
                                        &IoStatusBlock,
                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                        FILE_SYNCHRONOUS_IO_NONALERT);

                    if(NT_SUCCESS(Status)){
                        SetInfoClass = FileRenameInformation;
                        SetInfoLength = p->Value.Length + sizeof(*RenameInformation);
                        s = p->Value.Buffer;
                        if (*s == L'!' || *s == L'@') {
                            s++;
                            SetInfoLength -= sizeof( UNICODE_NULL );
                        }

                        SetInfoBuffer = MALLOC(SetInfoLength);

                        if (SetInfoBuffer) {
                            RenameInformation = (FILE_RENAME_INFORMATION *)SetInfoBuffer;
                            RenameInformation->ReplaceIfExists = (BOOLEAN)(s != p->Value.Buffer);
                            RenameInformation->RootDirectory = NULL;
                            RenameInformation->FileNameLength = SetInfoLength - sizeof( *RenameInformation );
                            RtlMoveMemory(RenameInformation->FileName,
                                          s,
                                          RenameInformation->FileNameLength);
                            }
                        else {
                            Status = STATUS_NO_MEMORY;
                        }

                        if(NT_SUCCESS(Status)){
                            Status = NtSetInformationFile(OldFileHandle,
                                                          &IoStatusBlock,
                                                          SetInfoBuffer,
                                                          SetInfoLength,
                                                          SetInfoClass);
                            if(!NT_SUCCESS( Status ) &&
                               Status == STATUS_OBJECT_NAME_COLLISION &&
                               RenameInformation->ReplaceIfExists){
                                KdPrintEx((DPFLTR_SETUP_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "\nSPRESTRT: %wZ => %wZ failed - Status == %x, Possible readonly target\n",
                                           &p->Name,
                                           &p->Value,
                                           Status));

                                //
                                // A rename was attempted, but the source existing file is readonly.
                                // this is a problem because folks that use movefileex to do delayed
                                // renames expect this to work and can leave a machine unbootable if
                                // the rename fails
                                //

                                //
                                // Open the file for Write Attributes access
                                //

                                NewName.Length = p->Value.Length - sizeof(L'!');
                                NewName.MaximumLength = p->Value.MaximumLength - sizeof(L'!');
                                NewName.Buffer = s;

                                InitializeObjectAttributes(&ObjectAttributes,
                                                           &NewName,
                                                           OBJ_CASE_INSENSITIVE,
                                                           NULL,
                                                           NULL);

                                OpenStatus = NtOpenFile(&SetAttributesHandle,
                                                        (ACCESS_MASK)FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                                                        &ObjectAttributes,
                                                        &IoStatusBlock,
                                                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                                                        FILE_SYNCHRONOUS_IO_NONALERT);

                                if(NT_SUCCESS(OpenStatus)){
                                    KdPrintEx((DPFLTR_SETUP_ID,
                                               DPFLTR_INFO_LEVEL,
                                               "     SPRESTRT: Open Existing Success\n"));

                                    RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
                                    BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

                                    OpenStatus = NtSetInformationFile(SetAttributesHandle,
                                                                      &IoStatusBlock,
                                                                      &BasicInfo,
                                                                      sizeof(BasicInfo),
                                                                      FileBasicInformation);
                                    NtClose(SetAttributesHandle);
                                    if(NT_SUCCESS(OpenStatus)){
                                        KdPrintEx((DPFLTR_SETUP_ID,
                                                   DPFLTR_INFO_LEVEL,
                                                   "     SPRESTRT: Set To NORMAL OK\n"));

                                        Status = NtSetInformationFile(OldFileHandle,
                                                                      &IoStatusBlock,
                                                                      SetInfoBuffer,
                                                                      SetInfoLength,
                                                                      SetInfoClass);

                                        if(NT_SUCCESS(Status)){
                                            KdPrintEx((DPFLTR_SETUP_ID,
                                                       DPFLTR_INFO_LEVEL,
                                                       "     SPRESTRT: Re-Rename Worked OK\n"));
                                        }
                                        else {
                                            KdPrintEx((DPFLTR_SETUP_ID,
                                                       DPFLTR_WARNING_LEVEL,
                                                       "     SPRESTRT: Re-Rename Failed - Status == %x\n",
                                                       Status));
                                        }
                                    }
                                    else {
                                        KdPrintEx((DPFLTR_SETUP_ID,
                                                   DPFLTR_WARNING_LEVEL,
                                                   "     SPRESTRT: Set To NORMAL Failed - Status == %x\n",
                                                   OpenStatus));
                                    }
                                }
                                else {
                                    KdPrintEx((DPFLTR_SETUP_ID,
                                               DPFLTR_WARNING_LEVEL,
                                               "     SPRESTRT: Open Existing file Failed - Status == %x\n",
                                               OpenStatus));
                                }
                            }
                        }

                        NtClose(OldFileHandle);
                    }
                }
            }
            else if (pass == 1) {
                //
                // p->Value.Length == NULL means delete operation.
                //
                Status = SpRemoveFileObject_U(&p->Name)? STATUS_SUCCESS: STATUS_ACCESS_DENIED;
            }

            if (!NT_SUCCESS( Status )) {
                KdPrintEx((DPFLTR_SETUP_ID,
                           DPFLTR_WARNING_LEVEL,
                           "SPRESTRT: %wZ => %wZ failed - Status == %x\n",
                           &p->Name,
                           &p->Value,
                           Status));

            } else if (pass == 1 && p->Value.Length == 0) {

                KdPrintEx((DPFLTR_SETUP_ID,
                           DPFLTR_INFO_LEVEL,
                           "SPRESTRT: %wZ (deleted)\n",
                           &p->Name));

            } else if (pass == 0) {

                KdPrintEx((DPFLTR_SETUP_ID,
                           DPFLTR_INFO_LEVEL,
                           "SPRESTRT: %wZ (renamed to) %wZ\n",
                           &p->Name,
                           &p->Value));
            }

            if (pass == 1) {
                FREE(p);
            }
        }
    }

    if (!WasEnabled) {
        Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE,
                                    FALSE,
                                    FALSE,
                                    &WasEnabled);
    }

    return;
}

BOOLEAN
SpRemoveFile(
    PCWSTR pFilePath
    )
{
    NTSTATUS Status;
    HANDLE FileHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_DISPOSITION_INFORMATION Disposition;
    FILE_BASIC_INFORMATION BasicInfo;
    BOOLEAN bResult = FALSE;

    INIT_OBJA(&ObjectAttributes, &UnicodeString, pFilePath);

    Status = NtOpenFile(&FileHandle,
                        FILE_WRITE_ATTRIBUTES | DELETE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_VALID_FLAGS,
                        FILE_OPEN_FOR_BACKUP_INTENT);

    if(NT_SUCCESS(Status)) {
        //
        // Change attribute to FILE_ATTRIBUTE_NORMAL.
        //
        RtlZeroMemory(&BasicInfo,sizeof(BasicInfo));
        BasicInfo.FileAttributes = FILE_ATTRIBUTE_NORMAL;

        NtSetInformationFile(FileHandle,
                             &IoStatusBlock,
                             &BasicInfo,
                             sizeof(BasicInfo),
                             FileBasicInformation);

        //
        // Perform delete operation.
        //
        Disposition.DeleteFile = TRUE;
        Status = NtSetInformationFile(FileHandle,
                                      &IoStatusBlock,
                                      &Disposition,
                                      sizeof(Disposition),
                                      FileDispositionInformation);

        if(!NT_SUCCESS(Status)) {
            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "RestartSetup: Unable to delete %ws (%lx)\n",
                       pFilePath, Status));
        }
        else {
            bResult = TRUE;
        }

        NtClose(FileHandle);
    }

    return bResult;
}

BOOLEAN
SpRemoveDir(
    PWSTR pFilePath
    )
{
    NTSTATUS Status;
    HANDLE DirectoryHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LONGLONG Buffer[2048/8];
    BOOLEAN FirstQuery;
    PFILE_DIRECTORY_INFORMATION FileInfo;
    ULONG LengthChars;
    BOOLEAN AnyErrors;
    ULONG indexEndOfRootPath;

    if(!pFilePath){
        ASSERT(FALSE);
        return FALSE;
    }

    indexEndOfRootPath = wcslen(pFilePath);
    ASSERT(indexEndOfRootPath);

    INIT_OBJA(&ObjectAttributes, &UnicodeString, pFilePath);

    Status = NtOpenFile(&DirectoryHandle,
                        FILE_LIST_DIRECTORY | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_DIRECTORY_FILE |
                            FILE_SYNCHRONOUS_IO_NONALERT |
                            FILE_OPEN_FOR_BACKUP_INTENT
                        );

    if(!NT_SUCCESS(Status)){
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: unable to open system32\\config for list access (%lx)\n",
                   Status));

        return(FALSE);
    }

    FirstQuery = TRUE;
    FileInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;
    AnyErrors = FALSE;

    do {

        Status = NtQueryDirectoryFile(DirectoryHandle,
                                      NULL,                           // no event to signal
                                      NULL,                           // no apc routine
                                      NULL,                           // no apc context
                                      &IoStatusBlock,
                                      Buffer,
                                      sizeof(Buffer)-sizeof(WCHAR),   // leave room for terminating nul
                                      FileDirectoryInformation,
                                      TRUE,                           // want single entry
                                      NULL,                           // get 'em all
                                      FirstQuery);

        if(NT_SUCCESS(Status)){
            LengthChars = FileInfo->FileNameLength / sizeof(WCHAR);
            FileInfo->FileName[LengthChars] = 0;

            if(wcscmp(FileInfo->FileName, L".") &&
               wcscmp(FileInfo->FileName, L"..")){
                wcscat(pFilePath, L"\\");
                wcscat(pFilePath, FileInfo->FileName);

                if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    SpRemoveDir(pFilePath);
                } else {
                    SpRemoveFile(pFilePath);
                }

                pFilePath[indexEndOfRootPath] = '\0';
            }
            FirstQuery = FALSE;
        }
    } while(NT_SUCCESS(Status));

    //
    // Check for normal loop termination.
    //
    if(Status == STATUS_NO_MORE_FILES) {
        Status = STATUS_SUCCESS;
    }

    //
    // Even if we got errors, try to keep going.
    //
    if(!NT_SUCCESS(Status)) {
        AnyErrors = TRUE;
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: Status %lx enumerating files\n",
                   Status));
    }

    NtClose(DirectoryHandle);

    SpRemoveFile(pFilePath);

    return ((BOOLEAN)!AnyErrors);
}

BOOLEAN
SpRemoveFileObject(
    IN PCWSTR pFileObjectPath
    )
{
    NTSTATUS Status;
    HANDLE FileHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    FILE_BASIC_INFORMATION BasicInfo;
    ULONG logestNtPath;
    PWSTR pFilePathToDelete;
    BOOLEAN bResult = FALSE;

    INIT_OBJA(&ObjectAttributes, &UnicodeString, pFileObjectPath);

    Status = NtOpenFile(&FileHandle,
                        SYNCHRONIZE | GENERIC_READ,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ,
                        0);

    if(NT_SUCCESS(Status)){
        RtlZeroMemory(&BasicInfo, sizeof(BasicInfo));

        Status = NtQueryInformationFile(FileHandle,
                                        &IoStatusBlock,
                                        &BasicInfo,
                                        sizeof(BasicInfo),
                                        FileBasicInformation);

        NtClose(FileHandle);

        if(!NT_SUCCESS(Status)){
            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "RestartSetup: Unable to delete %ws (%lx)\n",
                       pFileObjectPath, Status));
            return FALSE;
        }

        if(BasicInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY){
            logestNtPath = RtlGetLongestNtPathLength();
            if(!logestNtPath){
                logestNtPath = MAX_DOS_PATH_IN_NT_PATH;
            }
            pFilePathToDelete = (PWSTR)MALLOC(logestNtPath * sizeof(WCHAR));
            if(pFilePathToDelete){
                wcscpy(pFilePathToDelete, pFileObjectPath);

                bResult = SpRemoveDir(pFilePathToDelete);

                FREE(pFilePathToDelete);
            }
        }
        else {
            bResult = SpRemoveFile(pFileObjectPath);
        }
    }

    return bResult;
}

BOOLEAN
SpRemoveFileObject_U(
    IN PUNICODE_STRING FileObjectPath
    )
{
    return SpRemoveFileObject(FileObjectPath->Buffer);
}

BOOLEAN
SpReadFileRenameOperations(
    IN PLIST_ENTRY pFileRenameList
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    UNICODE_STRING      UnicodeString;
    NTSTATUS    Status;
    HANDLE      hUndoFile;
    WCHAR       wUnicodeSign;
    WCHAR       RenameOperationBuffer[2 * (MAX_DOS_PATH_IN_NT_PATH + 2/*"\n\r"*/)];
    ULONG       readBytes;
    ULONG       readActualBytes;
    PCWSTR      pDestinationFilePath;
    FILE_POSITION_INFORMATION currentPosition;
    PWSTR       pEnd;

    INIT_OBJA(&ObjectAttributes, &UnicodeString, UndoFilePath);

    Status = NtOpenFile(&hUndoFile,
                        FILE_READ_DATA | SYNCHRONIZE,
                        &ObjectAttributes,
                        &IoStatusBlock,
                        FILE_SHARE_READ,
                        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);

    if(!NT_SUCCESS(Status)) {
        //
        // We do not have any operation to perform
        //
        return FALSE;
    }

    Status = NtReadFile(hUndoFile,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        &wUnicodeSign,
                        sizeof(wUnicodeSign),
                        NULL,
                        NULL);
    if(NT_SUCCESS(Status) && TXT_FILE_UNICODE_SIGN == wUnicodeSign){
        currentPosition.CurrentByteOffset.QuadPart = sizeof(wUnicodeSign);
        do{
            readBytes = sizeof(RenameOperationBuffer) - 1;

            Status = NtReadFile(hUndoFile,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                RenameOperationBuffer,
                                readBytes,
                                NULL,
                                NULL);

            if(!NT_SUCCESS(Status)){
                ASSERT(STATUS_END_OF_FILE == Status);
                break;
            }

            readActualBytes = (ULONG)IoStatusBlock.Information;
            RenameOperationBuffer[readActualBytes / sizeof(WCHAR)] = '\0';

            pEnd = wcsstr(RenameOperationBuffer, L"\r\n");
            if(!pEnd){
                break;
            }
            *pEnd = '\0';

            pDestinationFilePath = pEnd + 2;//wcslen(L"\r\n");
            pEnd = wcsstr(pDestinationFilePath, L"\r\n");
            if(!pEnd){
                if(readActualBytes < readBytes){
                    pEnd = &RenameOperationBuffer[readActualBytes / 2];
                }
                else {
                    //
                    // Ether we have path which len exceed MAX_PATH,
                    // or probably some crap.
                    //
                    ASSERT(FALSE);
                    break;
                }
            }
            *pEnd = '\0';

            pEnd += 2;//wcslen(L"\r\n");

            SpSaveFileOperation(pFileRenameList,
                                RenameOperationBuffer,
                                *pDestinationFilePath? pDestinationFilePath: NULL);

            currentPosition.CurrentByteOffset.QuadPart += (LONGLONG)SIZE_ULONG64(pEnd, RenameOperationBuffer);
            Status = NtSetInformationFile(hUndoFile,
                                          &IoStatusBlock,
                                          &currentPosition,
                                          sizeof(currentPosition),
                                          FilePositionInformation);
        }while(NT_SUCCESS(Status));
    }

    NtClose(hUndoFile);

    //
    // Add this file to file operations list to be deleted.
    //

    SpSaveFileOperation(pFileRenameList, UndoFilePath, NULL);

    return TRUE;
}

BOOLEAN
SetupDelayedFileRename(
    VOID
    )
/*++

Routine Description:


Arguments:

    None.

Return Value:

    Boolean value indicating whether we were successful.

--*/
{
    LIST_ENTRY listFileRename;

    KdPrint(("SetupDelayedFileRename: Start"));

    InitializeListHead(&listFileRename);

    //
    // Fill list of file operations
    //
    if(!SpReadFileRenameOperations(&listFileRename)){
        return FALSE;
    }

    //
    // Perform file operations
    //
    SpProcessFileRenames(&listFileRename);

    KdPrint(("SetupDelayedFileRename: End"));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\namelist.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      namelist.c
//
// Description:
//
//      This file contains the implementation for a NAMELIST.  It is
//      useful for keeping a copy of what the user puts into a list-box.
//      Storage is obtained from the heap and there is not a fixed limit
//      on the size of the table.
//
//      IMPORTANT: When a NAMELIST is declared, init it to 0. e.g.
//                 NAMELIST Names = {0}.  Use ResetNameList() to reset
//                 it because we use the heap to store this list.
//
//----------------------------------------------------------------------------


#include "pch.h"


//
// The NAMELIST type is used on dialogs such as ComputerName and Printers
// where the user can ADD or REMOVE a list of entries which are displayed
// in a list box.  Callers should declare a NAMELIST and use these routines
// to get/set values.  These routines take care of the reallocation
// needed to support an arbitrary length list.
//
// Entries in the namelist can be added to the end or any specific index.
// Entries can be removed by name or by index.  This allows the programmer to
// not worry about maintaining the order in this list and keeping it
// synchronized with however the listbox displays (e.g. the listbox might
// display in alphabetical order).
//
// Obviously, a search for the entry must be done at removal time, and this
// is an insignificant (and unnoticeable) time hit in this context.
//


#define SIZE_TO_GROW 16

//----------------------------------------------------------------------------
//
// Function: ResetNameList
//
// Purpose: Empties the names in the namelist.  A namelist looks like:
//              int AllocedSize
//              int NumEntries
//              char **Vector
//          We free each of the names in the vector and set NumEntries
//          to 0.  The NAMELIST block is not freed or shrunk.
//
// Arguments: NAMELIST * - pointer to namelist to reset
//
// Returns: void
//
//----------------------------------------------------------------------------

VOID ResetNameList(NAMELIST *pNameList)
{
    UINT i;

    for ( i=0; i<pNameList->nEntries; i++ )
        free(pNameList->Names[i]);

    pNameList->nEntries = 0;
}

//----------------------------------------------------------------------------
//
// Function: GetNameListSize
//
// Purpose: retrieves number entries in namelist
//
// Arguments: NAMELIST * - pointer to namelist
//
// Returns: UINT - number of entries
//
//----------------------------------------------------------------------------

UINT GetNameListSize(NAMELIST *pNameList)
{
    return pNameList->nEntries;
}

//----------------------------------------------------------------------------
//
// Function: GetNameListName
//
// Purpose: Gets a name out of the namelist by index.
//
// Arguments:
//      NAMELIST* - pointer to namelist
//      UINT idx  - index of name to retrieve
//
//----------------------------------------------------------------------------

TCHAR *GetNameListName(NAMELIST *pNameList,
                       UINT      idx)
{
    if( idx >= pNameList->nEntries )
        return( _T("") );

    return pNameList->Names[idx];
}

//----------------------------------------------------------------------------
//
// Function: RemoveNameFromNameListIdx
//
// Purpose: Removes a name at a specific position in the namelist.
//
// Arguments:
//      NAMELIST* - namelist to remove from
//      UINT      - 0-based index on where to do the deletion
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
RemoveNameFromNameListIdx(
    IN  NAMELIST *pNameList,
    IN  UINT      idx)
{
    UINT i;

    Assert(idx < pNameList->nEntries);

    free(pNameList->Names[idx]);

    for ( i=idx+1; i<pNameList->nEntries; i++ )
        pNameList->Names[i-1] = pNameList->Names[i];

    pNameList->nEntries--;
}

//----------------------------------------------------------------------------
//
// Function: RemoveNameFromNameList
//
// Purpose: Removes a name from the name list (by name).
//
// Arguments:
//      NAMELIST* - pointer to namelist
//      TCHAR*    - name to remove
//
// Returns: TRUE if found and removed, FALSE if not found
//
//----------------------------------------------------------------------------

BOOL RemoveNameFromNameList(NAMELIST *pNameList,
                            TCHAR    *NameToRemove)
{
    UINT idx;

    if ( (idx=FindNameInNameList(pNameList, NameToRemove)) == -1 )
        return FALSE;

    Assert(idx < pNameList->nEntries);

    RemoveNameFromNameListIdx(pNameList, idx);

    return TRUE;
}

//----------------------------------------------------------------------------
//
// Function: AddNameToNameListIdx
//
// Purpose: Inserts a name at a specific position in the namelist.  Handles
//          the details of allocating more room if the table gets full.
//
// Arguments:
//      NAMELIST* - namelist to add to
//      TCHAR*    - string to add (input)
//      UINT      - 0-based index on where to do the insertion
//
// Returns: FALSE if out of memory.
//
//----------------------------------------------------------------------------

BOOL AddNameToNameListIdx(NAMELIST *pNameList,
                          TCHAR    *String,
                          UINT      idx) {

    UINT i;
    TCHAR *pStr; // temp var

    //
    // If we're out of room, realloc the namelist.  It is a vector
    // of TCHAR*
    //

    if ( pNameList->nEntries >= pNameList->AllocedSize ) {
        LPTSTR *lpTmpNames;

        pNameList->AllocedSize += SIZE_TO_GROW;

        // Use a temporary buffer in case the realloc fails
        //
        lpTmpNames = realloc(pNameList->Names,
                             pNameList->AllocedSize * sizeof(TCHAR*));

        // Make sure the realloc succeeded before stomping the original pointer
        //
        if ( lpTmpNames == NULL ) {
            free(pNameList->Names);
            pNameList->Names = NULL;
            pNameList->AllocedSize = 0;
            pNameList->nEntries    = 0;
            return FALSE;
        }
        else {
            pNameList->Names = lpTmpNames;
        }
    }

    if ( (pStr = lstrdup(String)) == NULL )
        return FALSE;

    //
    //  If they specifed an index beyond the end of the list,
    //  just add it to the end of the list
    //
    if ( idx > pNameList->nEntries ) {

        idx = pNameList->nEntries;

    }

    //
    //  Shift the array to make room at the insertion point
    //
    for( i = pNameList->nEntries; i > idx ; i-- ) {

        pNameList->Names[i] = pNameList->Names[i-1];

    }

    pNameList->Names[i] = pStr;

    pNameList->nEntries++;

    return TRUE;

}

//----------------------------------------------------------------------------
//
// Function: AddNameToNameList
//
// Purpose: Adds a name to the end of the namelist.  Handles the details
//          of allocating more room if the table gets full.
//
// Arguments:
//      NAMELIST* - namelist to add to
//      TCHAR*    - string to add (input)
//
// Returns: FALSE if out of memory.
//
//----------------------------------------------------------------------------

BOOL AddNameToNameList(NAMELIST *pNameList,
                       TCHAR    *String)
{

    return( AddNameToNameListIdx( pNameList, String, pNameList->nEntries ) );

}

//----------------------------------------------------------------------------
//
// Function: AddNameToNameListNoDuplicates
//
// Purpose: Adds a name to the end of the namelist only if the string is not
//          already in the list.  Handles the details of allocating more room
//          if the table gets full.
//
// Arguments:
//      NAMELIST* - namelist to add to
//      TCHAR*    - string to add (input)
//
// Returns: FALSE if out of memory.
//
//----------------------------------------------------------------------------

BOOL AddNameToNameListNoDuplicates( NAMELIST *pNameList,
                                    TCHAR    *String )
{

    if( FindNameInNameList( pNameList, String ) == -1 ) {

        return( AddNameToNameListIdx( pNameList, String, pNameList->nEntries ) );

    }

    //
    //  the string is already in the list so just return
    //
    return( TRUE );

}

//----------------------------------------------------------------------------
//
// Function: FindNameInNameList
//
// Purpose: Checks to see if a name already exists in the table.
//
// Arguments:
//      NAMELIST* - namelist to add to
//      TCHAR*    - string to search for
//
// Returns: INT idx of entry, -1 if not found
//
//----------------------------------------------------------------------------

INT FindNameInNameList(NAMELIST *pNameList,
                       TCHAR    *String)
{
    UINT i;

    for ( i=0; i<pNameList->nEntries; i++ )
        if ( (pNameList->Names) && (lstrcmpi(pNameList->Names[i], String) == 0) )
            return i;

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\string.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      string.c
//
// Description:
//
//----------------------------------------------------------------------------

#include "pch.h"

#define _SMGR_MAX_STRING_LEN_  1024

//----------------------------------------------------------------------------
//
//  Function: MyLoadString
//
//  Purpose: Loads a string resource given it's IDS_* and returns 
//           a malloc'ed buffer with its contents.
//
//           The malloc()'ed buffer can be freed with free()
//
//  Arguments:
//      UINT StringId
//
//  Returns:
//      Pointer to buffer.  An empty string is returned if the StringId
//      does not exist.  Null is returned if out of memory.
//
//----------------------------------------------------------------------------

LPTSTR 
MyLoadString(IN UINT StringId)
{
    TCHAR   Buffer[_SMGR_MAX_STRING_LEN_];
    TCHAR   *lpszRetVal;
    UINT    Length;

    Length = LoadString(FixedGlobals.hInstance,
                        StringId,
                        Buffer,
                        sizeof(Buffer)/sizeof(TCHAR));

    if( ! Length ) {
        Buffer[0] = _T('\0');
    }

    lpszRetVal = lstrdup(Buffer);
    if (lpszRetVal == NULL)
        TerminateTheWizard(IDS_ERROR_OUTOFMEMORY);
    
    return lpszRetVal;
}

//----------------------------------------------------------------------------
//
//  Function: CleanSpaceAndQuotes
//
//  Purpose: Cleans white-space and double quotes from the string and
//           returns a pointer to the start of the non-white-space data.
//
//  Arguments:
//      LPTSTR - input string
//
//  Returns:
//      LPTSTR
//
//  Notes:
//      Uses crt iswspace and iswcntrl.  Unicode only.
//
//----------------------------------------------------------------------------

LPTSTR 
CleanSpaceAndQuotes(LPTSTR Buffer)
{

    TCHAR *p;
    TCHAR *pEnd;

    p = CleanLeadSpace( Buffer );

    CleanTrailingSpace( p );

    pEnd = p + lstrlen( p ) - 1;

    //
    //  Only remove quotes if there is a matching quote at the beginning and
    //  end of the string
    //
    if( *p == _T('"') && *pEnd == _T('"'))
    {

        *pEnd = _T('\0');
        pEnd--;

        p++;

    }

    p = CleanLeadSpace( p );

    CleanTrailingSpace( p );

    return( p );

}

//----------------------------------------------------------------------------
//
//  Function: CleanLeadSpace
//
//  Purpose: Cleans leading white-space.  Returns a pointer to the start
//           of the non-white-space data.
//
//  Arguments:
//      LPTSTR - input string
//
//  Returns:
//      LPTSTR
//
//----------------------------------------------------------------------------

LPTSTR 
CleanLeadSpace(LPTSTR Buffer)
{
    TCHAR *p = Buffer;

    while ( *p && ( _istspace(*p) || _istcntrl(*p) ) )
        p++;

    return p;
}

//----------------------------------------------------------------------------
//
//  Function: CleanTrailingSpace
//
//  Purpose: Cleans any trailing spaces on a string.
//
//  Arguments:
//      TCHAR *pszBuffer - the string to remove the trailing spaces from
//
//  Returns:
//      VOID
//
//----------------------------------------------------------------------------
VOID 
CleanTrailingSpace(TCHAR *pszBuffer)
{
    
    TCHAR *p = pszBuffer;

    p = p + lstrlen( pszBuffer );

    while ( p >= pszBuffer && ( _istspace(*p) || _istcntrl(*p) ) )
    {
        *p = _T('\0');
        p--;
    }

}

//----------------------------------------------------------------------------
//
//  Function: ConvertQuestionsToNull
//
//  Purpose:  Scan a string and replace all ? with the null char (\0).
//
//  Arguments:  IN OUT TCHAR *pszString - 
//
//  Returns:  VOID
//
//----------------------------------------------------------------------------
VOID
ConvertQuestionsToNull( IN OUT TCHAR *pszString )
{

    while( *pszString != _T('\0') )
    {

        if( *pszString == _T('?') )
        {
            *pszString = _T('\0');
        }

        pszString++;

    }

}

//----------------------------------------------------------------------------
//
//  Function: lstrcatn
//
//  Purpose:  The standard libraries do not include this function so here it
//     is.  It does exactly what you would expect it to.  It concatenates
//     one string on to another with a char max limit.  No matter the value of
//     iMaxLength, the first string will never be truncated.  The terminating
//     null(\0) is always appended.
//
//  Arguments:
//     IN       TCHAR *pszString1   - pointer to target buffer
//     IN const TCHAR *pszString2   - pointer to source string
//     IN INT     iMaxLength  - max number of characters to appear in the
//                  returned string (the combination of the two strings)
//
//  Returns:
//      LPTSTR
//
//----------------------------------------------------------------------------
TCHAR*
lstrcatn( IN TCHAR *pszString1, IN const TCHAR *pszString2, IN INT iMaxLength )
{ 

    INT i;
    INT iCharCount = 0;

    if( lstrlen( pszString1 ) >= iMaxLength ) {

        return( pszString1 );

    }

    //
    //  Advance to the end of the first string
    //
    while( *pszString1 != _T('\0') && iCharCount < iMaxLength )
    {
        pszString1++;
        iCharCount++;
    }

    //
    //  Append on to the string character by character
    //
    for( ; iCharCount < (iMaxLength - 1) && *pszString2 != _T('\0'); iCharCount++ ) 
    {

        *pszString1 = *pszString2;

        pszString1++;
        pszString2++;

    }

    *pszString1 = _T('\0');

    return( pszString1 );

}


//----------------------------------------------------------------------------
//
//  Function: DoubleNullStringToNameList
//
//  Purpose:  Takes a pointer to a list of strings (each terminated by a null)
//     with a double null terminating the last string and adds each one to the
//     given namelist.  If there are any double quotes(") in the string, they
//     are removed.
//
//  Arguments:
//     TCHAR *szDoubleNullString - string with embedded strings
//     NAMELIST *pNameList - namelist to add the strings to
//
//  Returns:  VOID
//
//  Example:
//     If the function is called with the string:
//           one\0two\0\three\0\0
//     then the following strings are added to the namelist:
//           one
//           two
//           three
//
//----------------------------------------------------------------------------
VOID
DoubleNullStringToNameList( IN     TCHAR *szDoubleNullString, 
                            IN OUT NAMELIST *pNameList )
{

    TCHAR  szTempString[MAX_INILINE_LEN];
    TCHAR *pStr;
    TCHAR *pShiftStr;

    do
    {
        lstrcpyn( szTempString, szDoubleNullString, AS(szTempString) );

        pStr = szTempString;

        //
        //  Remove quotes(") from the string
        //
        while( *pStr != _T('\0') )
        {

            if( *pStr == _T('"') )
            {
                // 
                //  Found a quote so slide the string down one to overwrite the "
                //
                pShiftStr = pStr;

                while( *pShiftStr != _T('\0') )
                {

                    *pShiftStr = *(pShiftStr+1);

                    pShiftStr++;

                }

            }

            pStr++;

        }

        AddNameToNameList( pNameList, szTempString );

        //
        //  Advance to 1 character passed the \0
        //
        szDoubleNullString = szDoubleNullString + lstrlen( szDoubleNullString ) + 1;

    } while( *szDoubleNullString != _T('\0') );

}

//----------------------------------------------------------------------------
//
// Function: GetCommaDelimitedEntry
//
// Purpose: Used to extract comma separated items out of a buffer
//
//          pBuffer is passed by reference so it always points to the next
//          char that has not been extracted yet
//
// Arguments: TCHAR szIPString[] - used to put the new IP into
//            TCHAR **Buffer     - pointer to the IP addresses
//
// Returns: BOOL    TRUE  if an IP was placed in szIPString
//                  FALSE if an IP was NOT placed in szIPString
//
//----------------------------------------------------------------------------
BOOL 
GetCommaDelimitedEntry( OUT TCHAR szIPString[], IN OUT TCHAR **pBuffer )
{

    INT i;

    if( **pBuffer == _T('\0') )
    {

        return( FALSE );

    }
    else
    {
        if( **pBuffer == _T(',') )
        {

            (*pBuffer)++;

        }

        //
        //  Copy an IP string into szIPString char by char
        //

        for(i = 0;
            **pBuffer != _T(',') && **pBuffer != _T('\0');
            (*pBuffer)++, i++)
        {
            szIPString[i] = **pBuffer;
        }

        szIPString[i] = _T('\0');  // append the null character

        return( TRUE );

    }

}

//----------------------------------------------------------------------------
//
//  Function: StripQuotes
//
//  Purpose:  If a string is quoted(") it removes the quotes and returns the
//            string without quotes.
//
//            This function has no effect on strings that are not quoted.  It
//            will only removed quotes at the beginning at end of the string,
//            regardless if they are paired or not
//
//  Arguments:
//     TCHAR *String - the string to have its quotes removed.
//
//  Returns:  via the output parameter String, the string with no quotes
//
//  Example:  Some example calls and their return values
//
//     Called With:         Returns:
//     -----------          -------
//
//      "Quoted"            Quoted
//      Not Quoted          Not Quoted
//      "Single Quote       Single Quote
//      Another Quote"      Another Quote
//
//----------------------------------------------------------------------------
VOID
StripQuotes( IN OUT TCHAR *String )
{

    TCHAR *pLastChar = String + lstrlen(String) - 1;

    //
    //  If the last char is quoted, replace it with \0
    //
    if( *pLastChar == _T('"') )
    {
        *pLastChar = _T('\0');
    }

    if( String[0] == _T('"') )
    {

        TCHAR *pString = String;

        //
        //  Slide the entire string back one
        //
        while( *pString != _T('\0') )
        {
            *pString = *(pString+1);
            pString++;
        }

    }

}

//----------------------------------------------------------------------------
//
//  Function: DoesContainWhiteSpace
//
//  Purpose:  Determines if a given string contains white space chars.
//
//  Arguments:
//     LPCTSTR p - the strig to scan for white space
//
//  Returns:  BOOL - TRUE if the string contains white space, FALSE if not
//
//----------------------------------------------------------------------------
BOOL
DoesContainWhiteSpace( LPCTSTR p )
{

    for( ; *p; p++ )
    {
        if( iswspace( *p ) )
        {
            return( TRUE );
        }
    }

    return( FALSE );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\settypes.h ===
//
// Linked list header.  All nodes must start with this.
//

typedef struct node_header_tag {

    struct node_header_tag *next;

} NODE_HEADER;

//
// A list header with a head and a tail
//

typedef struct queue_tag {

    NODE_HEADER *Head;
    NODE_HEADER *Tail;

} LINKED_LIST;

//
// A type to hold the key=value.
//
// If lpValue is a null-string, SettingQueue_Flush will not write it to
// the answer file.
//
// The bSetOnce forces the wizard to only set a particular setting one
// time.  This is just to keep common\savefile.c sane.  It is ok to
// over-write an original setting (on an edit), but only one time.
//

typedef struct key_node {

    NODE_HEADER Header;     // linked list stuff

    TCHAR *lpKey;           // The 'key' part of key=value
    TCHAR *lpValue;         // The 'value' part of key=value

#if DBG
    BOOL  bSetOnce;         // Only let the wizard make a setting once
#endif

} KEY_NODE;

//
// A type to hold the [Section_Name] and related info
//
// It contains the Section_Name and a linked list of key=value pairs.
//
// The Volatile flag can be changed using SettingQueue_MakeVolatile()
//

typedef struct section_node {

    NODE_HEADER Header;         // linked list stuff

    TCHAR *lpSection;           // The [name] of this section

    LINKED_LIST key_list;       // List of key=value (KEY_NODE)

    BOOL bVolatile;             // Don't write this section

} SECTION_NODE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\pathsup.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      pathsup.c
//
// Description:
//      Some path support routines.
//
//----------------------------------------------------------------------------

#include "pch.h"

static TCHAR g_szSetupMgrFileExtensions[MAX_PATH + 1] = _T("");


//---------------------------------------------------------------------------
//
//  Function: CleanTrailingSlashes
//
//  Purpose: Cleans up trailing slashes off pathnames.  This is a support
//           routine for ConcatenatePaths().
//
//  Arguments:
//      LPTSTR lpBuffer - MAX_PATH buffer
//
//  Returns: VOID
//
//---------------------------------------------------------------------------

static VOID CleanTrailingSlashes(LPTSTR lpBuffer)
{
    TCHAR *p = lpBuffer + lstrlen(lpBuffer) - 1;

    while ( p >= lpBuffer && *p == _T('\\') )
        *p-- = _T('\0');
}


//---------------------------------------------------------------------------
//
//  Function: CleanLeadingSlashes
//
//  Purpose: Removes leading slashes from the given string.
//
//  Arguments:
//      LPTSTR lpStr - str to clean
//
//  Returns:
//      A pointer to the character after the run of back-slashes.
//
//---------------------------------------------------------------------------

static LPTSTR CleanLeadingSlashes(LPTSTR lpStr)
{
    TCHAR *p=lpStr;

    while ( *p && *p == TEXT('\\') )
        p++;

    return p;
}


//---------------------------------------------------------------------------
//
//  Function: ConcatenatePaths
//
//  Purpose: This function cats path components together.  It makes sure
//           that there are not multiple slashes separating each item, and
//           that there isn't a trailing back-slash.
//
//           The last string passed must be NULL.
//
//  Arguments:
//      LPTSTR lpBuffer - MAX_PATH buffer
//      ...
//
//  Returns:
//      TRUE if all is ok
//      FALSE if resultant string is >= MAX_PATH chars
//
//---------------------------------------------------------------------------

BOOL __cdecl ConcatenatePaths(LPTSTR lpBuffer, ...)
{
    LPTSTR  lpString;
    va_list arglist;
    HRESULT hrCat;

    va_start(arglist, lpBuffer);
    lpString = va_arg(arglist, LPTSTR);

    while ( lpString != NULL ) {

        if ( lstrlen(lpBuffer) + lstrlen(lpString) >= MAX_PATH )
            return FALSE;

        lpString = CleanLeadingSlashes(lpString);
        CleanTrailingSlashes(lpString);
        CleanTrailingSlashes(lpBuffer);

        if ( lpBuffer[0] ) {
            hrCat=StringCchCat(lpBuffer, MAX_PATH, _T("\\"));
            hrCat=StringCchCat(lpBuffer, MAX_PATH, lpString);
        } else {
            lstrcpyn(lpBuffer, lpString, MAX_PATH);
        }

        lpString = va_arg(arglist, LPTSTR);
    }

    va_end(arglist);

    return TRUE;
}


//---------------------------------------------------------------------------
//
//  Function: ParseDriveLetterOrUnc
//
//  Purpose: Will parse past the \\srv\share\ or D:\ and return a pointer
//           to the character after that mess.
//
//  Returns: Pointer to the pathname 1 char past the volume descriptor,
//           NULL if errors.  GetLastError() will be valid when NULL
//           is returned.
//
//  Notes:
//      - Only pass in fully qualified pathnames.  Use MyGetFullPath().
//
//---------------------------------------------------------------------------

LPTSTR ParseDriveLetterOrUnc(LPTSTR lpFileName)
{
    TCHAR *p=NULL;

    //
    // If path is of form \\srv\share\, get a pointer past the whole mess.
    //
    // Note we start at lpFileName+3 because "srv" (in this example) must
    // be at least 1 character.
    //

    if ( lpFileName[0] == _T('\\') && lpFileName[1] == _T('\\') ) {

        //
        //  Move past the computer name
        //

        p = lpFileName + 2;

        while( *p != _T('\\') )
        {
            if( *p == _T('\0') )
            {
                SetLastError( ERROR_BAD_PATHNAME );
                return( NULL );
            }

            p++;

        }

        p++;

        //
        //  Scan past the share name
        //

        while( *p != _T('\\') )
        {
            if( *p == _T('\0') )
            {
                SetLastError( ERROR_BAD_PATHNAME );
                return( NULL );
            }

            p++;

        }

        p++;

    }

    //
    // Get past the D:\ if path is of that form
    //

    if ( towupper(lpFileName[0]) >= _T('A') &&
         towupper(lpFileName[0]) <= _T('Z') &&
         lpFileName[1] == _T(':')           &&
         lpFileName[2] == _T('\\') ) {

        p = lpFileName + 3;
    }

    //
    // If we never set *p, then the path is not in a valid form.
    //

    if ( p == NULL ) {
        SetLastError(ERROR_BAD_PATHNAME);
        return NULL;
    }

    return p;
}

//---------------------------------------------------------------------------
//
//  Function: GetComputerNameFromUnc
//
//  Purpose:  To strip out the computer name from a full UNC path.
//
//  Example:  \\computername\sharename\dir1\dir2 would return
//            \\computername
//
//  Arguments:
//
//     szComputerName is assumed to be MAX_PATH length
//
//  Returns:  VOID
//
//  Notes:
//      - Only pass in fully qualified pathnames.  Use MyGetFullPath().
//
//---------------------------------------------------------------------------
VOID
GetComputerNameFromUnc( IN  TCHAR   *szFullUncPath,
                        OUT TCHAR   *szComputerName,
                        IN  DWORD   cbSize) {

    TCHAR *pString;

    AssertMsg( szFullUncPath[0] == _T('\\') && szFullUncPath[1] == _T('\\'),
               "szFullUncPath is not a well formed net path" );

    lstrcpyn( szComputerName, szFullUncPath, cbSize );

    pString = &(szComputerName[2]);

    //
    //  Scan past the computer name
    //

    while( *pString != _T('\\') )
    {
        if( *pString == _T('\0') )
        {
            AssertMsg( FALSE,
                       "Bad UNC path");
            return;
        }

        pString++;

    }

    *pString = _T('\0');

}


//---------------------------------------------------------------------------
//
//  Function: GetComputerAndShareNameFromUnc
//
//  Purpose:  To strip out the computer and share name from a full UNC path.
//
//  Example:  \\computername\sharename\dir1\dir2 would return
//            \\computername\sharename
//
//  Arguments:
//
//     szComputerAndShareName is assumed to be MAX_PATH length
//
//  Returns:  VOID
//
//  Notes:
//      - Only pass in fully qualified pathnames.  Use MyGetFullPath().
//
//---------------------------------------------------------------------------
VOID
GetComputerAndShareNameFromUnc( IN  TCHAR *szFullUncPath,
                                OUT TCHAR *szComputerAndShareName,
                                IN  DWORD cbSize) {

    TCHAR *pString;

    AssertMsg( szFullUncPath[0] == _T('\\') && szFullUncPath[1] == _T('\\'),
               "szFullUncPath is not a well formed net path");

    lstrcpyn( szComputerAndShareName, szFullUncPath, cbSize );

    pString = &(szComputerAndShareName[2]);

    //
    //  Scan past the computer name
    //

    while( *pString != _T('\\') )
    {
        if( *pString == _T('\0') )
        {
            AssertMsg( FALSE,
                       "Bad UNC path");
            return;
        }

        pString++;

    }

    pString++;

    //
    //  Scan past the share name
    //

    while( *pString != _T('\\') )
    {
        if( *pString == _T('\0') )
        {
            //
            //  already just the computer and share name so just return
            //
            return;
        }

        pString++;

    }

    *pString = _T('\0');

}


//---------------------------------------------------------------------------
//
//  Function: MyGetFullPath
//
//  Purpose: Small wrapper on GetFullPathName().  It assumes the buffer
//           is MAX_PATH.
//
//  Returns:
//      Pointer to filename part in the buffer, NULL if errors.  The
//      Win32 error code will be valid if fails.
//
//  Notes:
//      - This function should be called whenever obtaining a pathname
//        from the user.  Some of the other routines in this file
//        require a fully qualified and cleaned up pathname (i.e. no
//        trailing space and such).
//
//---------------------------------------------------------------------------

LPTSTR MyGetFullPath(LPTSTR lpFileName)
{
    TCHAR Buffer[MAX_PATH], *lpFilePart;

    lstrcpyn(Buffer, lpFileName, AS(Buffer));

    if ( ! GetFullPathName(Buffer,
                           MAX_PATH,
                           lpFileName,
                           &lpFilePart) ) {
        lpFilePart = NULL;
        return NULL;
    }

    return lpFilePart;
}

//---------------------------------------------------------------------------
//
//  Function: GetPathFromPathAndFilename
//
//  Purpose:  To obtain the just the path from a string that contains a path
//     and a filename.
//
//  Arguments:  LPTSTR lpPathAndFileName - the full path and filename
//              TCHAR *szPath - buffer the path is to be returned in, it is
//                              assumed to be of MAX_PATH length
//
//  Returns:
//      Inside szBuffer is just the path from the input of the path and file
//      name
//      BOOL - TRUE on success, FALSE on failure
//
//
//  Examples:
//      lpPathAndFileName           szBuffer
//
//      c:\foo\bar.exe     returns  c:\foo
//      c:\bar.exe                  c:\
//
//---------------------------------------------------------------------------
BOOL
GetPathFromPathAndFilename( IN LPTSTR lpPathAndFileName, OUT TCHAR *szPath, IN DWORD cbSize )
{

    INT iFileNameLength;
    INT iPathLength;
    INT iPathAndFileNameLength;
    TCHAR  Buffer[MAX_PATH];
    TCHAR *lpFilePart;

    lstrcpyn(Buffer, lpPathAndFileName, AS(Buffer));

    if ( ! GetFullPathName(Buffer,
                           MAX_PATH,
                           lpPathAndFileName,
                           &lpFilePart) ) {
        return( FALSE );
    }

    iFileNameLength = lstrlen( lpFilePart );

    iPathAndFileNameLength = lstrlen( lpPathAndFileName );

    lstrcpyn( szPath, lpPathAndFileName, cbSize );

    szPath[iPathAndFileNameLength - iFileNameLength] = _T('\0');

    //
    //  At this point szPath looks like either c:\foo\ or c:\
    //  So trim the last back slash unless at the root
    //

    iPathLength = lstrlen( szPath );

    if( iPathLength > 3 )
    {
        szPath[iPathLength-1] = _T('\0');
    }

    return( TRUE );

}


//---------------------------------------------------------------------------
//
//  Function: MyGetDiskFreeSpace
//
//  Purpose: Gets the free space in bytes on the given drive and returns
//           a LONGLONG (int64).
//
//           The Win32 apis won't return an int64.  Also, the Win32 apis
//           require d:\.  But this function will accept any fully
//           qualified path.
//
//  Arguments:
//      LPTSTR - any fully qualified path
//
//  Returns:
//      LONGLONG - free space
//
//---------------------------------------------------------------------------

LONGLONG
MyGetDiskFreeSpace(LPTSTR Drive)
{
    BOOL  bRet;
    DWORD nSectorsPerCluster,
          nBytesPerSector,
          nFreeClusters,
          nTotalClusters;
    TCHAR DriveBuffer[MAX_PATH];

    LONGLONG FreeBytes;
    HRESULT hrCat;

    if( _istalpha( Drive[0] ) )
    {
        lstrcpyn(DriveBuffer, Drive, 4);
        DriveBuffer[3] = _T('\0');
    }
    else if( Drive[0] == _T('\\') )
    {
        GetComputerNameFromUnc( Drive, DriveBuffer, AS(DriveBuffer) );

        hrCat=StringCchCat( DriveBuffer, AS(DriveBuffer),  _T("\\") );

        hrCat=StringCchCat( DriveBuffer, AS(DriveBuffer), WizGlobals.DistShareName );

        hrCat=StringCchCat( DriveBuffer, AS(DriveBuffer), _T("\\") );
    }
    else
    {
        AssertMsg(FALSE,
                  "MyGetDiskFreeSpace failed, programming error, bad Drive parameter");
    }

    bRet = GetDiskFreeSpace( DriveBuffer,
                             &nSectorsPerCluster,
                             &nBytesPerSector,
                             &nFreeClusters,
                             &nTotalClusters );

    if( bRet == FALSE )
    {
        ReportErrorId( NULL,
                       MSGTYPE_ERR | MSGTYPE_WIN32,
                       IDS_ERR_UNABLE_TO_DETERMINE_FREE_SPACE,
                       DriveBuffer );

        return( 0 );
    }

    FreeBytes  = (LONGLONG) nFreeClusters *
                 (LONGLONG) nBytesPerSector *
                 (LONGLONG) nSectorsPerCluster;

    return( FreeBytes );
}


//---------------------------------------------------------------------------
//
//  Function: MySetupQuerySpaceRequiredOnDrive
//
//  Purpose: Uses setupapi disk-space-list and returns the LONGLONG
//           of how many bytes are needed.
//
//  Arguments:
//      LPTSTR - any fully qualified path
//
//  Returns:
//      LONGLONG - free space
//
//---------------------------------------------------------------------------

LONGLONG
MySetupQuerySpaceRequiredOnDrive(HDSKSPC hDiskSpace, LPTSTR Drive)
{
    BOOL     bRet;
    LONGLONG llRequiredSpace;
    TCHAR    DriveBuffer[MAX_PATH];

    if( _istalpha( Drive[0] ) )
    {
        lstrcpyn(DriveBuffer, Drive, 3);
        DriveBuffer[2] = _T('\0');
    }
    else if( Drive[0] == _T('\\') )
    {

        GetComputerAndShareNameFromUnc( Drive, DriveBuffer, AS(DriveBuffer) );

    }
    else
    {
        AssertMsg(FALSE,
                  "SetupQuerySpaceRequiredOnDrive failed, programming error, bad Drive parameter");
    }

    bRet = SetupQuerySpaceRequiredOnDrive(
                            hDiskSpace,
                            DriveBuffer,
                            &llRequiredSpace,
                            NULL, 0);

    AssertMsg(bRet,
              "SetupQuerySpaceRequiredOnDrive failed, programming error");

    return llRequiredSpace;
}


//---------------------------------------------------------------------------
//
//  Function: IsPathOnLocalDiskDrive
//
//  Purpose: Determines if the path is on a local disk drive or not.
//
//  Arguments:
//      LPTSTR lpPath - fully qualified path
//
//  Returns: BOOL
//
//---------------------------------------------------------------------------

BOOL
IsPathOnLocalDiskDrive(LPCTSTR lpPath)
{
    UINT nDriveType;
    TCHAR szDrivePath[MAX_PATH + 1];

    //
    //  Use GetDriveType to determine if the path is a local or a network path
    //

    lstrcpyn( szDrivePath, lpPath, AS(szDrivePath) );

    if( szDrivePath[0] != _T('\\') )
    {

        //
        //  Truncate the path to the root dir
        //
        szDrivePath[3] = _T('\0');

    }

    nDriveType = GetDriveType( szDrivePath );

    if( nDriveType == DRIVE_REMOTE )
    {
        return( FALSE );
    }
    else
    {
        return( TRUE );
    }

}


//---------------------------------------------------------------------------
//
//  Function: EnsureDirExists
//
//  Purpose: Function that will iteratively create the given directory
//           by creating each piece of the pathname if necessary.
//
//  Arguments:
//      LPTSTR lpDirName - dir name
//
//  Returns: BOOL
//
//  Notes:
//      - This function requires a fully qualified pathname.  Translate
//        pathnames using MyGetFullPath() first.
//
//      - The Win32 error code will be valid upon failure.
//
//---------------------------------------------------------------------------

BOOL EnsureDirExists(LPTSTR lpDirName)
{
    BOOL  bRestoreSlash;
    DWORD dwAttribs;
    TCHAR *p;

    //
    // Parse off the D:\ or \\srv\shr\.  The lasterror will already
    // be set by ParseDriveLetterOrUnc() if any errors occured.
    //

    if ( (p = ParseDriveLetterOrUnc(lpDirName)) == NULL )
        return FALSE;

    //
    // Now parse off each piece of the pathname and make sure dir exists
    //

    while ( *p ) {

        // find next \ or end // of pathname

        while ( *p && *p != _T('\\') )
            p++;

        bRestoreSlash = FALSE;

        if ( *p == _T('\\') ) {
            *p = _T('\0');
            bRestoreSlash = TRUE;
        }

        // see if a file with that name already exists

        dwAttribs = GetFileAttributes(lpDirName);
        if ( dwAttribs != (DWORD) -1 &&
             !(dwAttribs & FILE_ATTRIBUTE_DIRECTORY) ) {

            if ( bRestoreSlash )
                *p = _T('\\');

            SetLastError(ERROR_ALREADY_EXISTS);
            return FALSE;
        }

        // create the dir and allow a failure if the dir already exists

        if ( !CreateDirectory(lpDirName, NULL) &&
              GetLastError() != ERROR_ALREADY_EXISTS ) {

            if ( bRestoreSlash )
                *p = _T('\\');

            return FALSE;
        }

        if ( bRestoreSlash )
            *p = _T('\\');

        // advance to next piece of the pathname

        p++;
    }

    return TRUE;
}


//---------------------------------------------------------------------------
//
//  Function: DoesFolderExist
//
//  Purpose: Checks if the given folder exists or not.
//
//  Arguments:
//      LPTSTR lpDirName - dir name
//
//  Returns: BOOL
//
//---------------------------------------------------------------------------

BOOL DoesFolderExist(LPTSTR lpDirName)
{
    DWORD dwAttribs = GetFileAttributes(lpDirName);

    if ( dwAttribs == (DWORD) -1 )
        return FALSE;

    if ( !(dwAttribs & FILE_ATTRIBUTE_DIRECTORY) )
        return FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------
//
//  Function: DoesFileExist
//
//  Purpose: Checks if the given file exists or not.
//
//  Arguments:
//      LPTSTR lpFileName - file name
//
//  Returns: BOOL
//
//---------------------------------------------------------------------------

BOOL DoesFileExist(LPTSTR lpFileName)
{
    DWORD dwAttribs = GetFileAttributes(lpFileName);

    if ( dwAttribs == (DWORD) -1 )
        return FALSE;

    if ( dwAttribs & FILE_ATTRIBUTE_DIRECTORY )
        return FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------
//
//  Function: DoesPathExist
//
//  Purpose: Checks if the given path exists or not.  It does not pay
//           attention to whether it is a file or directory.
//
//  Arguments:
//      LPTSTR lpPathName - path name
//
//  Returns: BOOL
//
//---------------------------------------------------------------------------

BOOL DoesPathExist(LPTSTR lpPathName)
{
    DWORD dwAttribs = GetFileAttributes(lpPathName);

    if ( dwAttribs == (DWORD) -1 )
        return FALSE;

    return TRUE;
}


//---------------------------------------------------------------------------
//
//  Function: ILFreePriv
//
//  Purpose: Frees an ID list that some shell apis allocate with it's own
//           special allocator.
//
//  Arguments:
//      LPITEMIDLIST pidl - pointer to shell specially alloced mem
//
//  Returns: VOID
//
//---------------------------------------------------------------------------

VOID ILFreePriv(LPITEMIDLIST pidl)
{
    LPMALLOC pMalloc;

    if (pidl) 
    {
        if ( NOERROR == SHGetMalloc(&pMalloc) )
        {
            pMalloc->lpVtbl->Free(pMalloc, pidl);
            pMalloc->lpVtbl->Release(pMalloc);
        }
    }
}


//
// Constants used for GetOpenFileName() and GetSaveFileName() calls that
// allow user to browse for an answer file.
//

//#define TEXT_FILE_FILTER _T("Text Files (*.txt)\0*.txt\0Remote Boot Files (*.sif)\0*.sif\0Sysprep Inf Files (*.inf)\0*.inf\0All Files (*.*)\0*.*\0")
#define TEXT_EXTENSION _T("txt")

//----------------------------------------------------------------------------
//
// Function: GetAnswerFileName
//
// Purpose: Function for the 'Browse' button on the SaveScript page and
//          the NewOrEdit page.
//
// Arguments:
//      HWND   hwnd   - calling window
//      LPTSTR buffer - output, pass in a MAX_PATH buffer
//
// Returns:
//      BOOL - success
//
//----------------------------------------------------------------------------

BOOL GetAnswerFileName(HWND   hwnd,
                       LPTSTR lpFileName,
                       BOOL   bSavingFile)
{
    OPENFILENAME ofn;
    DWORD  dwFlags;
    TCHAR  PathBuffer[MAX_PATH];
    INT    iRet;
    HRESULT hrPrintf;


    //
    //  If we haven't already loaded the resource strings, then load them now.
    //

    if( g_szSetupMgrFileExtensions[0] == _T('\0') )
    {

        TCHAR *StrTextFiles;
        TCHAR *StrRemoteBootFiles;
        TCHAR *StrSysprepFiles;
        TCHAR *StrAllFiles;

        //
        //  Load the resource strings
        //

        StrTextFiles       = AllocateString(NULL, IDS_TEXT_FILES);
        StrRemoteBootFiles = AllocateString(NULL, IDS_REMOTE_BOOT_FILES);
        StrSysprepFiles    = AllocateString(NULL, IDS_SYSPREP_FILES);
        StrAllFiles        = AllocateString(NULL, IDS_ALL_FILES);

        //
        //  Build the text file filter string
        //

        //
        //  The question marks (?) are just placehoders for where the NULL char
        //  will be inserted.
        //

        hrPrintf=StringCchPrintf( g_szSetupMgrFileExtensions,AS(g_szSetupMgrFileExtensions),
                   _T("%s (*.txt)?*.txt?%s (*.sif)?*.sif?%s (*.inf)?*.inf?%s (*.*)?*.*?"),
                   StrTextFiles,
                   StrRemoteBootFiles,
                   StrSysprepFiles,
                   StrAllFiles );

        FREE(StrTextFiles);
        FREE(StrRemoteBootFiles);
        FREE(StrSysprepFiles);
        FREE(StrAllFiles);

        ConvertQuestionsToNull( g_szSetupMgrFileExtensions );

    }

    if ( bSavingFile )
        dwFlags = OFN_HIDEREADONLY  |
                  OFN_PATHMUSTEXIST;
    else
        dwFlags = OFN_HIDEREADONLY  |
                  OFN_FILEMUSTEXIST;

    GetCurrentDirectory(MAX_PATH, PathBuffer);

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = g_szSetupMgrFileExtensions;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0L;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = lpFileName;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = PathBuffer;
    ofn.lpstrTitle        = NULL;
    ofn.Flags             = dwFlags;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = TEXT_EXTENSION;

    if ( bSavingFile )
        iRet = GetSaveFileName(&ofn);
    else
        iRet = GetOpenFileName(&ofn);

    if ( ! iRet )
        return FALSE;

    MyGetFullPath(lpFileName);

    return TRUE;
}

//----------------------------------------------------------------------------
//
// Function: ShowBrowseFolder
//
// Purpose:  Displays a browse folder for the user to select a file from.
//    Takes the headache out of making an OPENFILENAME struct and filling
//    it up.
//
// Arguments:
//     HWND   hwnd - handle to the dialog box
//     TCHAR *szFileFilter - string to display descriptions and extensions
//                           on the files
//     TCHAR *szFileExtension - string that is the default extension for the file
//     DWORD  dwFlags - bit flags used to initialize the browse dialog
//     TCHAR *szStartingPath - path the browse should start at
//     TCHAR *szFileNameAndPath - path and filename the user selected
//
// Returns:  Non-Zero - if user specified a file
//           Zero     - if user did not specify a file
//
//----------------------------------------------------------------------------
INT
ShowBrowseFolder( IN     HWND   hwnd,
                  IN     TCHAR *szFileFilter,
                  IN     TCHAR *szFileExtension,
                  IN     DWORD  dwFlags,
                  IN     TCHAR *szStartingPath,
                  IN OUT TCHAR *szFileNameAndPath ) {

    OPENFILENAME ofn;

    ofn.lStructSize       = sizeof(OPENFILENAME);
    ofn.hwndOwner         = hwnd;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFileFilter;
    ofn.lpstrCustomFilter = NULL;
    ofn.nMaxCustFilter    = 0L;
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = szFileNameAndPath;
    ofn.nMaxFile          = MAX_PATH;
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = szStartingPath;
    ofn.lpstrTitle        = NULL;
    ofn.Flags             = dwFlags;
    ofn.nFileOffset       = 0;
    ofn.nFileExtension    = 0;
    ofn.lpstrDefExt       = szFileExtension;

    return( GetOpenFileName( &ofn ) );

}

//----------------------------------------------------------------------------
//
// Function: GetPlatform
//
// Purpose:
//
// Arguments: OUT TCHAR *pBuffer - buffer to copy the platform string to,
//              assumed to be able to hold MAX_PATH chars
//
// Returns: VOID
//
//----------------------------------------------------------------------------
VOID
GetPlatform( OUT TCHAR *pBuffer )
{

    SYSTEM_INFO SystemInfo;

    GetSystemInfo( &SystemInfo );

    switch( SystemInfo.wProcessorArchitecture )
    {
        case PROCESSOR_ARCHITECTURE_INTEL:

            lstrcpyn( pBuffer, _T("i386"), MAX_PATH );

            break;

        case PROCESSOR_ARCHITECTURE_AMD64:

            lstrcpyn( pBuffer, _T("amd64"), MAX_PATH );

            break;

        default:

            lstrcpyn( pBuffer, _T("i386"), MAX_PATH );

            AssertMsg( FALSE,
                       "Unknown Processor.  Can't set sysprep language files path." );

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sprestrt\makefile.inc ===
$(O)\res.res: res.rc msg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\setupmgr\supplib\settngs.c ===
//----------------------------------------------------------------------------
//
// Copyright (c) 1997-1999  Microsoft Corporation
// All rights reserved.
//
// File Name:
//      settngs.c
//
// Description:
//
//      This file contains the support routines to deal with settings
//      in answer files.
//
//      This wizard does not do in-place editting of answer files.
//      These apis must be used to write to the answer file.
//
//      For most settings, the job is easy.  Call SettingQueue_AddSetting,
//      and specify the [SectionName] KeyName=Value and which queue (the
//      answer file or the .udf for the case of multiple computer names).
//      Check common\savefile.c for tons of examples.
//
//      Be aware that on an edit, these queues are initialized with the
//      settings loaded from the original file.
//
//      When the user edits a script and pushes NEXT on the NewOrEdit
//      page, the settings in the existing answer file and .udf are loaded
//      onto the OrignalAnswerFileQueue and the OriginalUdfQueue.
//
//      When the user pushes NEXT on the SaveScript page, the following
//      ocurrs.  (the below code is in common\save.c)
//
//          Empty(AnswerFileQueue)
//          Empty(UdfQueue)
//
//          Copy original answer file settings to the AnswerFileQueue
//          Copy original .udf settings to the UdfQueue
//
//          Call common\savefile.c to enqueue all new settings
//
//          Flush(AnswerFileQueue)
//          Flush(UdfQueue)
//
//      To support "Do not specify this setting", you must call
//      SettingQueue_AddSetting with an lpValue of "".  SettingQueue_Flush
//      writes nothing if lpValue == "".  Failure to do this results in
//      the original setting being preserved in the outputed answer file.
//
//      You must also ensure that mutually excluded settings are cleared
//      by setting the lpValue to "".  For example, if JoinWorkGroup=workgroup,
//      then, make sure to set JoinDomain="", CreateComputerAccount="" etc.
//
//      A section can be marked as volatile.  This is needed for the network
//      pages because many sections should be removed if (for example) the
//      user changes from CustomNet to TypicalNet.  When the queue is flushed,
//      any sections still marked as volatile will not be written to the file.
//      Use SettingQueue_MarkVolatile to mark a section as such.  Check
//      common\loadfile.c for examples.
//
//      In contrast to in-place editing, being able to mark a section
//      as volatile at load time means that the answer file does not have
//      to be re-read to determine what should be removed at save time.
//
//----------------------------------------------------------------------------

#include "pch.h"
#include "settypes.h"

//
// Declare the queues
//
// AnswerFileQueue holds the settings to write
// UdfQueue holds the settings in case of mulitple computers
//
// OrigAnswerFileQueue holds the settings loaded on an edit
// OrigUdfFileQueue holds the settings loaded on an edit in the .udf
//
// The first 2 are "output queues"
// The next 2 are "input queues"
// The last is a queue for the HAL and SCSI OEM settings.
//
// First, we read the answer file and .udf at the NewOrEdit page and
// place each setting on the Orig*Queue's.
//
// When user is way at the end of the wizard (SaveScript page), we
// empty the AnswerFileQueue and UdfQueue and initialize it with a
// copy of the original settings.  This is all necessary because we
// don't want to merge with garbage we previously put on the queue
// if the user went back and forth in the wizard alot.
//

static LINKED_LIST AnswerFileQueue = { 0 };
static LINKED_LIST UdfQueue        = { 0 };

static LINKED_LIST OrigAnswerFileQueue = { 0 };
static LINKED_LIST OrigUdfQueue        = { 0 };

static LINKED_LIST TxtSetupOemQueue = { 0 };

//
// Local prototypes
//

SECTION_NODE *
SettingQueue_AddSection(LPTSTR lpSection, QUEUENUM dwWhichQueue);

static SECTION_NODE *FindQueuedSection(LPTSTR   lpSection,
                                       QUEUENUM dwWhichQueue);

VOID InsertNode(LINKED_LIST *pList, PVOID pNode);

KEY_NODE* FindKey(LINKED_LIST *ListHead,
                  LPTSTR       lpKeyName);

LINKED_LIST *SelectSettingQueue(QUEUENUM dwWhichQueue);

static BOOL IsNecessaryToQuoteString(LPTSTR p);

BOOL DoesSectionHaveKeys( SECTION_NODE *pSection );


//----------------------------------------------------------------------------
//
//  This section has the entry points for the wizard
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Function: SettingQueue_AddSetting
//
// Purpose: Queues [section] key=value in internal structs.
//
// Arguments:
//      LPTSTR   lpSection    - name of section in .ini
//      LPTSTR   lpKey        - name of key in section
//      LPTSTR   lpValue      - value of setting
//      QUEUENUM dwWhichQueue - which settings queue
//
// Returns:
//      BOOL - fails only because of no memory
//
// Notes:
//
//  - A lpValue = "" is interpreted to mean 'Do not write this setting'.
//
//  - A lpKey = "" creates a [SectionName] header with no settings.
//
//  - If the setting existed in the original answer file, it's value
//    is updated.  An assert fires if the wizard tries to set the same
//    key twice.
//
//----------------------------------------------------------------------------

BOOL SettingQueue_AddSetting(LPTSTR   lpSection,
                             LPTSTR   lpKey,
                             LPTSTR   lpValue,
                             QUEUENUM dwWhichQueue)
{
    SECTION_NODE *pSectionNode;
    KEY_NODE     *pKeyNode;

    //
    // You have to pass a section key and value.  Section name cannot
    // be empty.
    //

    Assert(lpSection != NULL);
    Assert(lpKey != NULL);
    Assert(lpValue != NULL);
    Assert(lpSection[0]);

    //
    // See if a node for this section already exists.  If not, create one.
    //

    pSectionNode = SettingQueue_AddSection(lpSection, dwWhichQueue);
    if ( pSectionNode == NULL )
        return FALSE;

    //
    // See if this key has already been set.  If not, alloc a node and
    // set all of its fields except for the lpValue.
    //
    // If the node already exist, free the lpValue to make room for
    // the new value.
    //

    if ( lpKey[0] == _T('\0') || 
         (pKeyNode = FindKey( &pSectionNode->key_list, lpKey) ) == NULL ) {

        if ( (pKeyNode=malloc(sizeof(KEY_NODE))) == NULL )
            return FALSE;

        if ( (pKeyNode->lpKey = lstrdup(lpKey)) == NULL )
        {
            free(pKeyNode);
            return FALSE;
        }
        InsertNode(&pSectionNode->key_list, pKeyNode);

    } else {

#if DBG
        //
        // If the wizard has already set this key once, assert.
        //

        if ( pKeyNode->bSetOnce ) {
            AssertMsg2(FALSE,
                       "Section \"%S\" Key \"%S\" has already been set",
                       lpSection, lpKey);
        }
#endif

        free(pKeyNode->lpValue);
    }

#if DBG
    //
    // If this is going to an output queue, mark this setting as
    // having already been set by the wizard.
    //
    // Note that when the input queue is copied to the output queue,
    // the copy function preserves this setting.
    //

    pKeyNode->bSetOnce = ( (dwWhichQueue == SETTING_QUEUE_ANSWERS) |
                           (dwWhichQueue == SETTING_QUEUE_UDF) );
#endif

    //
    // Put the (possibly new) value in
    //

    if ( (pKeyNode->lpValue = lstrdup(lpValue)) == NULL )
        return FALSE;

    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function: SettingQueue_AddSection
//
//  Purpose: Adds a section (by name) to either the answer file setting
//           queue, or the .udf queue.
//
//  Returns: FALSE if out of memory
//
//  Notes:
//
//    - If the section is already on the given list, a pointer to it
//      is returned.  Else a new one is created and put at the end of
//      the list.
//
//----------------------------------------------------------------------------

SECTION_NODE *
SettingQueue_AddSection(LPTSTR lpSection, QUEUENUM dwWhichQueue)
{
    SECTION_NODE *pSectionNode;
    LINKED_LIST  *pList;

    //
    // If it already exists, return a pointer to it.
    //
    // If we're modifying a section (or any of it's settings) on one
    // of the output queues, we must make sure that this section is not
    // marked volatile anymore.
    //

    pSectionNode = FindQueuedSection(lpSection, dwWhichQueue);

    if ( pSectionNode != NULL ) {

        if ( dwWhichQueue == SETTING_QUEUE_ANSWERS ||
             dwWhichQueue == SETTING_QUEUE_UDF ) {

            pSectionNode->bVolatile = FALSE;
        }

        return pSectionNode;
    }

    //
    // Create the new section node.  They always begin not volatile.
    // Callers use MarkVolatile to mark a volatile section on in input
    // queue at answer file load time.
    //

    if ( (pSectionNode=malloc(sizeof(SECTION_NODE))) == NULL )
        return FALSE;

    if ( (pSectionNode->lpSection = lstrdup(lpSection)) == NULL )
    {
        free(pSectionNode);
        return FALSE;
    }
    pSectionNode->bVolatile = FALSE;

    memset(&pSectionNode->key_list, 0, sizeof(pSectionNode->key_list));

    //
    // Put this node at the tail of the correct list.
    //
    pList = SelectSettingQueue(dwWhichQueue);

    if ( pList != NULL )
        InsertNode(pList, pSectionNode);

    return pSectionNode;
}


//----------------------------------------------------------------------------
//
//  Function: SettingQueue_RemoveSection
//
//  Purpose: 
//
//  Returns: 
//
//  Notes:
//
//----------------------------------------------------------------------------
VOID
SettingQueue_RemoveSection( LPTSTR lpSection, QUEUENUM dwWhichQueue )
{
    
    LINKED_LIST  *pList;
    KEY_NODE     *pKeyNode;
    SECTION_NODE *pSectionNode;
    SECTION_NODE *pPreviousSectionNode = NULL;

    pList = SelectSettingQueue( dwWhichQueue );
    if (pList == NULL)
        return;
    pSectionNode = (SECTION_NODE *) pList->Head;

    //
    //  Iterate through all the sections.
    //
    while( pSectionNode ) {

        KEY_NODE *pTempKeyNode;

        //
        //  If this section matches the one we are looking for, delete it.
        //  Else advance to the next section.
        //
        if( lstrcmpi( pSectionNode->lpSection, lpSection ) == 0 ) {

            for( pKeyNode = (KEY_NODE *) pSectionNode->key_list.Head; pKeyNode; ) {

                free( pKeyNode->lpKey );

                free( pKeyNode->lpValue );

                pTempKeyNode = (KEY_NODE *) pKeyNode->Header.next;

                free( pKeyNode );

                pKeyNode = pTempKeyNode;

            }

            //
            //  Special case if we are at the head of the list
            //
            if( pPreviousSectionNode == NULL ) {
                pList->Head = pSectionNode->Header.next;

                free( pSectionNode->lpSection );

                pSectionNode = (SECTION_NODE *) pList->Head;
            }
            else {
                pPreviousSectionNode->Header.next = pSectionNode->Header.next;

                free( pSectionNode->lpSection );

                pSectionNode = (SECTION_NODE *) pPreviousSectionNode->Header.next;
            }

        }
        else {

            pPreviousSectionNode = pSectionNode;

            pSectionNode = (SECTION_NODE *) pSectionNode->Header.next;

        }

    }

}

//----------------------------------------------------------------------------
//
//  Function: SettingQueue_MarkVolatile
//
//  Purpose: Marks or clears the Volatile flag for a section.  Typically
//           one marks volatile sections at load time on the "Orig" queues.
//
//           Later, at save time, the volatile flag gets cleared if you
//           ever call *_AddSetting() *_AddSection().
//
//----------------------------------------------------------------------------

VOID
SettingQueue_MarkVolatile(LPTSTR   lpSection,
                          QUEUENUM dwWhichQueue)
{
    SECTION_NODE *p = FindQueuedSection(lpSection, dwWhichQueue);

    if ( p == NULL )
        return;

    p->bVolatile = TRUE;
}

//----------------------------------------------------------------------------
//
// Function: SettingQueue_Empty
//
// Purpose: This function emptys the queue of settings.  Since the user
//          can go BACK and re-save a file, it must be emptied before
//          trying to save it again.
//
// Arguments: VOID
//
// Returns: VOID
//
//----------------------------------------------------------------------------

VOID SettingQueue_Empty(QUEUENUM dwWhichQueue)
{
    LINKED_LIST *pList;
    SECTION_NODE *p, *pn;
    KEY_NODE *q, *qn;

    //
    // Point to the proper queue to empty and start at the head of it
    //

    pList = SelectSettingQueue(dwWhichQueue);
    if (pList == NULL)
        return;
        
    p = (SECTION_NODE *) pList->Head;

    //
    // For each SECTION_NODE, walk down each KEY_NODE.  Unlink and free all.
    //

    while ( p ) {
        for ( q = (KEY_NODE *) p->key_list.Head; q; ) {
            free(q->lpKey);
            free(q->lpValue);
            qn=(KEY_NODE *) q->Header.next;
            free(q);
            q=qn;
        }
        free(p->lpSection);
        pn=(SECTION_NODE *) p->Header.next;
        free(p);
        p=pn;
    }

    //
    // Zero out the head & tail pointers
    //

    pList->Head = NULL;
    pList->Tail = NULL;
}

//----------------------------------------------------------------------------
//
// Function: SettingQueue_Flush
//
// Purpose: This function is called (by the wizard) once all the settings
//          have been queued.
//
// Arguments:
//      LPTSTR lpFileName   - name of file to create/edit
//      DWORD  dwWhichQueue - which queue, answers file, .udf, ...
//
// Returns:
//      BOOL - success
//
//----------------------------------------------------------------------------

BOOL
SettingQueue_Flush(LPTSTR   lpFileName,
                   QUEUENUM dwWhichQueue)
{
    LINKED_LIST *pList;
    SECTION_NODE *pSection;
    KEY_NODE *pKey;
    TCHAR Buffer[MAX_INILINE_LEN];
    FILE *fp;
    INT BufferSize = sizeof(Buffer) / sizeof(TCHAR);
    HRESULT hrPrintf;

    //
    // Point to the proper queue to flush
    //

    pList = SelectSettingQueue(dwWhichQueue);
    if (pList == NULL)
        return FALSE;
        
    pSection = (SECTION_NODE *) pList->Head;

    //
    // Start writing the file
    //

    if( ( fp = My_fopen( lpFileName, _T("w") ) ) == NULL ) {

        return( FALSE );

    }

    if( My_fputs( _T(";SetupMgrTag\n"), fp ) == _TEOF ) {

        My_fclose( fp );

        return( FALSE );
    }

    //
    // For each section ...
    //

    for ( pSection = (SECTION_NODE *) pList->Head;
          pSection;
          pSection = (SECTION_NODE *) pSection->Header.next ) {

        //
        // We don't write out sections that are still marked volatile.
        //

        if ( pSection->bVolatile )
            continue;

        //
        // Write the section name only if we will write keys below it
        //
        // ISSUE-2002/02/28-stelo- this causes problems because we want to write out
        // some sections without keys, like:
        //
        //[NetServices]
        //    MS_SERVER=params.MS_SERVER
        //
        //[params.MS_SERVER]
        //
        //  How can we get around this?
        //
        if( DoesSectionHaveKeys( pSection ) ) {

            hrPrintf=StringCchPrintf(Buffer,
                       AS(Buffer),
                       _T("[%s]\n"),
                       pSection->lpSection);

        }
        else {

            continue;

        }

        if( My_fputs( Buffer, fp ) == _TEOF ) {

            My_fclose( fp );

            return( FALSE );

        }

        //
        // Write out each key=value
        //

        for ( pKey = (KEY_NODE *) pSection->key_list.Head;
              pKey;
              pKey = (KEY_NODE *) pKey->Header.next ) {

            BOOL bQuoteKey   = FALSE;
            BOOL bQuoteValue = FALSE;
            TCHAR *p;

            //
            // An empty value means to not write it
            //

            if ( pKey->lpValue[0] == _T('\0') )
                continue;

            //
            //  Double-quote the value if it has white-space and is not
            //  already quoted
            //

            bQuoteKey = IsNecessaryToQuoteString( pKey->lpKey );

            bQuoteValue = IsNecessaryToQuoteString( pKey->lpValue );

            //
            // Put the key we want into Buffer

            // ISSUE-2002/02/28-stelo- text might get truncated here, should we show a warning?

            Buffer[0] = _T('\0');

            if( pKey->lpKey[0] != _T('\0') ) {
                if ( bQuoteKey ) {

                    hrPrintf=StringCchPrintf(Buffer,
                               AS(Buffer),
                               _T("    \"%s\"="),
                               pKey->lpKey);

                }
                else {

                    hrPrintf=StringCchPrintf(Buffer,
                               AS(Buffer),
                               _T("    %s="),
                               pKey->lpKey);

                }
            }

            //
            // Put the value we want into Buffer paying attention to
            // whether we want quotes around the it or not.
            //

            if ( bQuoteValue ) {

                lstrcatn( Buffer, _T("\""), BufferSize );
                lstrcatn( Buffer, pKey->lpValue, BufferSize );
                lstrcatn( Buffer, _T("\""), BufferSize );
                lstrcatn( Buffer, _T("\n"), BufferSize );

            }
            else {

                lstrcatn( Buffer, pKey->lpValue, BufferSize );
                lstrcatn( Buffer, _T("\n"), BufferSize );

            }

            if( My_fputs( Buffer, fp ) == _TEOF ) {

                My_fclose( fp );

                return( FALSE );

            }

        }

        //
        // Write a blank line at the end of the section
        //

        hrPrintf=StringCchPrintf(Buffer, AS(Buffer), _T("\n"));

        if( My_fputs( Buffer, fp ) == _TEOF ) {

            My_fclose( fp );

            return( FALSE );

        }

    }

    My_fclose( fp );

    return( TRUE );
}

//----------------------------------------------------------------------------
//
//  Function: SettingQueue_Copy
//
//  Purpose: Copies one settings queue to another.  Used to copy the
//           input queues to the output queues.
//
//           Look at common\save.c
//
//----------------------------------------------------------------------------

VOID
SettingQueue_Copy(QUEUENUM dwFrom, QUEUENUM dwTo)
{
    LINKED_LIST *pListFrom = SelectSettingQueue(dwFrom);

    SECTION_NODE *p, *pSectionNode;
    KEY_NODE *q;

#if DBG
    KEY_NODE *pKeyNode;
#endif

    if (pListFrom == NULL)
        return;
        
    for ( p = (SECTION_NODE *) pListFrom->Head;
          p;
          p = (SECTION_NODE *) p->Header.next ) {

        //
        // Add the section to the output queue
        //

        SettingQueue_AddSetting(p->lpSection,
                                _T(""),
                                _T(""),
                                dwTo);

        pSectionNode = FindQueuedSection(p->lpSection, dwTo);

        for ( q = (KEY_NODE *) p->key_list.Head;
              q;
              q = (KEY_NODE *) q->Header.next ) {

            //
            // Add the key=value
            //

            SettingQueue_AddSetting(p->lpSection,
                                    q->lpKey,
                                    q->lpValue,
                                    dwTo);
#if DBG
            //
            // Retain the bSetOnce flag
            //

            pKeyNode = FindKey(&pSectionNode->key_list, q->lpKey);

            if ( pKeyNode != NULL ) {
                pKeyNode->bSetOnce = q->bSetOnce;
            }
#endif
        }

        //
        // Retain the bVolatile flag on the section node.
        //

        if ( pSectionNode != NULL ) {
            pSectionNode->bVolatile = p->bVolatile;
        }

    }
}


//----------------------------------------------------------------------------
//
//  Internal support routines
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
// Function: DoesSectionHaveKeys
//
// Purpose: Determines if a section has keys to be written out or not
//
// Arguments:
//      SECTION_NODE *pSection - the section to determine if it has keys or not
//
// Returns:
//      TRUE -  if this section contains keys
//      FALSE - if this section does not contain keys
//
//----------------------------------------------------------------------------
BOOL
DoesSectionHaveKeys( SECTION_NODE *pSection ) {

    KEY_NODE *pKey;

    for ( pKey = (KEY_NODE *) pSection->key_list.Head;
          pKey;
          pKey = (KEY_NODE *) pKey->Header.next ) {

        if ( pKey->lpValue[0] != _T('\0') ) {
        
            return( TRUE );

        }

    }

    return( FALSE );

}

//----------------------------------------------------------------------------
//
// Function: IsNecessaryToQuoteString
//
// Purpose: Determines if a string is already quoted and if it is not quoted,
//          if a string has white space or not
//
// Arguments:
//      LPTSTR p - the string to be scanned
//
// Returns:
//      TRUE -  if the string needs to be quoted
//      FALSE - if the string does not need to be quoted
//
//----------------------------------------------------------------------------
static BOOL
IsNecessaryToQuoteString( LPTSTR p )
{

    LPTSTR pCommaSearch;

    //
    //  See if it is already quoted
    //  We only check if the first char is a quote because the last char may
    //  not be a quote.  Example:  ComputerType = "HAL Friendly Name", OEM
    //
    if( *p == _T('"') )
    {
        return( FALSE );
    }

    //
    //  If it contains a comma, then don't quote it except for the printer
    //  command that contains rundll32.  This is kind of a hack.
    //  This prevents keys like:
    //
    //  ComputerType = "HAL Friendly Name", OEM
    //
    //  from being quoted.
    //

    if( ! _tcsstr( p, _T("rundll32") ) )
    {

        for( pCommaSearch = p; *pCommaSearch; pCommaSearch++ )
        {

            if( *pCommaSearch == _T(',') )
            {

                return( FALSE );
           
            }

        }

    }

    //
    //  Look for white space
    //
    for ( ; *p; p++ )
    {

        if( iswspace(*p) )
        {

            return( TRUE );
           
        }

    }

    return( FALSE );

}

//----------------------------------------------------------------------------
//
// Function: FindQueuedSection (static)
//
// Purpose: Finds the SECTION_NODE on the global settings queue with
//          the given name.
//
// Arguments:
//      LPTSTR lpSection - name of section in .ini
//
// Returns:
//      SECTION_NODE * or NULL if it does not exist
//
// Notes:
//  - Searches are case insensitive
//
//----------------------------------------------------------------------------

static SECTION_NODE *FindQueuedSection(LPTSTR   lpSection,
                                       QUEUENUM dwWhichQueue)
{
    SECTION_NODE *p;
    LINKED_LIST  *pList;
    
    pList = SelectSettingQueue(dwWhichQueue);
    if (pList == NULL)
        return NULL;
        
    p = (SECTION_NODE *) pList->Head;
    if ( p == NULL )
        return NULL;

    do {
        if ( _tcsicmp(p->lpSection, lpSection) == 0 )
            break;
        p = (SECTION_NODE *) p->Header.next;
    } while ( p );

    return p;
}

//----------------------------------------------------------------------------
//
//  Function: InsertNode
//
//  Purpose: Puts the given node at the tail of the given list.  All nodes
//           must begin with a NODE_HEADER.
//
//  Returns: VOID
//
//  Notes:
//      - Allocates no memory, only links the node in.
//
//----------------------------------------------------------------------------

VOID InsertNode(LINKED_LIST *pList, PVOID pNode)
{
    NODE_HEADER *pNode2 = (NODE_HEADER *) pNode;

    //
    // Put it at the tail
    //

    pNode2->next = NULL;
    if ( pList->Tail )
        pList->Tail->next = pNode2;
    pList->Tail = pNode2;

    //
    // In case its the first one onto the list, fixup the head
    //

    if ( ! pList->Head )
        pList->Head = pNode2;
}

//----------------------------------------------------------------------------
//
// Function: FindKey
//
// Purpose: Searches the given list of keynodes and finds one with the
//          given name.
//
// Arguments:
//      LPTSTR lpSection - name of section in .ini
//
// Returns:
//      SECTION_NODE * or NULL if it does not exist
//
// Notes:
//  - Searches are case insensitive
//
//----------------------------------------------------------------------------

KEY_NODE* FindKey(LINKED_LIST *ListHead,
                         LPTSTR       lpKeyName)
{
    KEY_NODE *p = (KEY_NODE *) ListHead->Head;

    if ( p == NULL )
        return NULL;

    do {
        if ( _tcsicmp(p->lpKey, lpKeyName) == 0 )
            break;
        p = (KEY_NODE *) p->Header.next;
    } while ( p );

    return p;
}

//----------------------------------------------------------------------------
//
//  Function: SelectSettingQueue
//
//  Purpose: Translates dwWhichQueue into a LINKED_LIST pointer.
//
//  Returns: A pointer to one of the 5 settings queues we have.
//
//----------------------------------------------------------------------------

LINKED_LIST *SelectSettingQueue(QUEUENUM dwWhichQueue)
{
    switch ( dwWhichQueue ) {

        case SETTING_QUEUE_ANSWERS:
            return &AnswerFileQueue;

        case SETTING_QUEUE_UDF:
            return &UdfQueue;

        case SETTING_QUEUE_ORIG_ANSWERS:
            return &OrigAnswerFileQueue;

        case SETTING_QUEUE_ORIG_UDF:
            return &OrigUdfQueue;

        case SETTING_QUEUE_TXTSETUP_OEM:
            return &TxtSetupOemQueue;

        default:
            AssertMsg(FALSE, "Invalid dwWhichQueue");
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sprestrt\psp.h ===
#pragma once

//
// Define result codes.
//
#define SUCCESS 0
#define FAILURE 1

//
// Define helper macro to deal with subtleties of NT-level programming.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )

BOOLEAN 
SetupDelayedFileRename(
    VOID
    );

//
// Memory routines
//
#define MALLOC(size)    RtlAllocateHeap(RtlProcessHeap(),0,(size))
#define FREE(block)     RtlFreeHeap(RtlProcessHeap(),0,(block))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\syslib\pch.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Pre-compiled header for syslib.lib.  

Author:

    Brian Ku (briank) 06/20/2000

Revision History:

--*/
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpoapi.h>
#include <windows.h>
#include <shlwapi.h>
#include <regstr.h>
#include <tchar.h>

#include <spsyslib.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sys\disk.h ===
//
// DISK.H - Classes for partition table manipulation
//
// Revision History:
//

#ifndef _SRT__DISK_H_
#define _SRT__DISK_H_

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <diskguid.h>
}
#include <windows.h>
#include <sys.h>


class CDrive;

#define PARTITION_NAME_LENGTH   36

typedef struct Geometry {
    LONGLONG    cylinders;
    MEDIA_TYPE  mediaType;
    ULONG       tracksPerCylinder;  // heads
    ULONG       sectorsPerTrack;
    ULONG       bytesPerSector;     // sectorSize
    ULONGLONG   totalSectorCount;   // cylinders*tracksPerCylinder*sectorsPerTrack
    ULONG       bytesPerCylinder;   // tracksPerCylinder*sectorsPerTack*bytesPerSector
    ULONG       bytesPerTrack;      // sectorsPerTack*bytesPerSector
} GEOMETRY, *PGEOMETRY;


class CDrive
{
public:
    
    ULONG               m_diskNumber;
    
    ULONG               m_numPartitions;
    LONGLONG            m_length;
    GEOMETRY            m_geometry;
    LONGLONG            m_trueLength;
    BOOLEAN             m_isNEC98;
    PARTITION_STYLE     m_style;        // The partitioning style of the disk (MBR, GPT, unknown)
    union {                             // Information specific to the partitioning style
        struct {                        // The discriminator of the union is the field "style"
            ULONG       m_signature;
        } m_mbr;
        struct {
            GUID        m_diskId;
            LONGLONG    m_startingUsableOffset;
            LONGLONG    m_usableLength;
            ULONG       m_maxPartitionCount;
        } m_gpt;
    } m_info;
    
    
public:
    
    HRESULT 
    Initialize(
        LPCTSTR lpszLogicalDrive
        );

    ~CDrive(
        );
    
public:

    HRESULT
    ReadBootRecord(
        LPCTSTR lpszLogicalDrive,
        UINT   nSectors,
        PBYTE  *buffer
        );

    HRESULT 
    WriteBootRecord(
        LPCTSTR lpszLogicalDrive,
        UINT   nSectors,
        PBYTE  *buffer
        );
    
    HRESULT 
    WriteBootRecordXP(
        LPCTSTR lpszLogicalDrive,
        UINT   nSectors,
        PBYTE  *buffer
        );

};

/*
 *  Low level functions for manipulating disks, partitions, 
 *  volumes, filesystems
 */

HANDLE 
LowOpenDisk(
    ULONG diskNumber
    );

HANDLE
LowOpenPartition(
    ULONG   diskNumber,
    ULONG   partitionNumber
    );

HANDLE
LowOpenPartition(
    LPCTSTR lpszLogicalDrive
    );

HRESULT 
LowGetGeometry(
    HANDLE          handle,
    PDISK_GEOMETRY  geometry
    );

HRESULT 
LowGetLength(
    HANDLE      handle, 
    PLONGLONG   length
    );



HRESULT 
LowReadSectors(
    HANDLE  handle, 
    ULONG   sectorSize,
    ULONG   startingSector, 
    ULONG   numberOfSectors,
    PVOID   buffer
    );

HRESULT
LowWriteSectors(
    HANDLE  handle,
    ULONG   sectorSize,
    ULONG   startingSector,
    ULONG   numberOfSectors,
    PVOID   buffer
    ); 

HRESULT
LowFsLock(
    HANDLE handle
    );

HRESULT
LowFsUnlock(
    HANDLE handle
    );

HRESULT
LowFsDismount(
    HANDLE handle
    );

/*
 *  Arithmetics
 */

LONGLONG
RoundUp(
    LONGLONG    value, 
    LONGLONG    factor
    );

LONGLONG
RoundDown(
    LONGLONG    value, 
    LONGLONG    factor
    );

#endif // _SRT__DISK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sys\sys.h ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    sys.h

Abstract:

    Contains macros, type and function declarations
    used by sys.cpp
    
Author:

    Ryan Burkhardt (ryanburk)

Revision History:

    10 May 2001 :
    First crack at it...
    
--*/


#ifndef _HEADER_SYS_H_
#define _HEADER_SYS_H_

#pragma once

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <ntddstor.h>
}
#include <windows.h>

#include <stdio.h>
#include <iostream>
#include <vector>
#include <tchar.h>
#include <string>
#include <stdlib.h>
#include "disk.h"

//
// Macros
//
#define ELEMENT_COUNT(x) (sizeof(x)/sizeof((x)[0]))

//
// forward declarations
//
class File;

//
// Types
//


//
// Helper dump operators
//
inline
std::ostream& operator<<(std::ostream &os, const std::wstring &str) {
    FILE    *OutStream = (&os == &std::cerr) ? stderr : stdout;

    fputws(str.c_str(), OutStream);
    return os;
}

inline
std::ostream& operator<<(std::ostream &os, PCTSTR str) {
    return os << std::wstring(str);
}

//
// Exceptions
//
struct ProgramException : public std::exception {
    virtual void Dump(std::ostream &os) = 0;
};

//
// Abstracts a Win32 error
//
struct W32Error : public ProgramException {
    DWORD   ErrorCode;
    
    W32Error(DWORD ErrCode = GetLastError()) : ErrorCode(ErrCode){}
    
    void Dump(std::ostream &os) {
        WCHAR   MsgBuffer[4096];

        MsgBuffer[0] = UNICODE_NULL;

        DWORD CharCount = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                ErrorCode,
                                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                MsgBuffer,
                                sizeof(MsgBuffer)/sizeof(WCHAR),
                                NULL);

        if (CharCount) {
            std::wstring Msg(MsgBuffer);

            os << Msg;
        } else {
            os << std::hex << ErrorCode;
        }
    }
};

#define SECTOR_SIZE  512

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\syslib\sysprep.c ===
/*++

File Description:

    This file contains all the functions required to add a registry entry
    to force execution of the system clone worker upon reboot.

--*/

#include <pch.h>
#include <sysprep_.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\syslib\devids.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    devids.c

Abstract:

    Builds a list of device ID and INF name pairs, based on a device class, and or
    INI file list. 
    The list will be built as follows:
    If the list exists in the specified INI file, then the INI file will be used.
    If the specified INI file section exists, but is empty, then the local INF files
    will be used
    If the specified INI section does not exists, then no list will be built


Author:

    Donald McNamara (donaldm) 02/08/2000

Revision History:

--*/
#include "pch.h"
#include <spsyslib.h>

/*++
===============================================================================
Routine Description:

    BOOL  bIniSectionExists

    This routine will determine if the specified INI sections exists in the 
    specificed INI file

Arguments:

    lpszSectionName - The section name to look for
    lpszIniFile     - The INI file to search

Return Value:

    TRUE if the section name exists
    FALSE if the section name does not exist
    FALSE and LastError != 0 if there was a critical failure.

===============================================================================
--*/

#ifndef LOG
#define LogFactoryInstallError
#endif

// ISSUE-2002/03/27-acosma,robertko - Check for NULL input parameters.
//
BOOL bINISectionExists
(
    LPTSTR  lpszSectionName,
    LPTSTR  lpszIniFile
)
{
    BOOL        bRet = FALSE;       // Assume it does not exists
    LPTSTR      lpBuffer;
    LPTSTR      lpNew;
    LPTSTR      lpSections;
    DWORD       dwSectionLen;
    DWORD       dwBufferSize;
    DWORD       dwResult;

    SetLastError(0);                // Assume no errors so far
        
    // Allocate a buffer to hold the section names
    if(lpBuffer = (LPTSTR)LocalAlloc(LPTR, (INIBUF_SIZE*sizeof(TCHAR)))) 
    {
        dwBufferSize = INIBUF_SIZE;
    } 
    else 
    {
        LogFactoryInstallError(TEXT("FACTORY:: Failed to allocate a buffer for reading the WINBOM file"));
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto Clean0;
    }

    while((dwResult = GetPrivateProfileSectionNames(lpBuffer,
                                                    dwBufferSize,
                                                    lpszIniFile)) == (dwBufferSize-2)) 
    {
        if(lpNew = LocalReAlloc(lpBuffer,
                                ((dwBufferSize+INIBUF_GROW)*sizeof(TCHAR)), 
                                LMEM_MOVEABLE))
        {
            lpBuffer = lpNew;
            dwBufferSize += INIBUF_GROW;
        } 
        else 
        {
            LogFactoryInstallError(TEXT("FACTORY:: Failed to Re-allocate a buffer for reading the WINBOM file"));
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Clean0;
        }
    }
    
    // Enumerate all sections
    for(lpSections = lpBuffer; *lpSections; lpSections+=dwSectionLen) 
    {
        dwSectionLen = lstrlen(lpSections)+1;
        if (lstrcmpi(lpSections, lpszSectionName) == 0)
        {
            bRet = TRUE;
            break;
        }            
    }
    
Clean0:
    if (lpBuffer)
    {
        LocalFree(lpBuffer);
    }   
    
    return bRet; 
}

/*++
===============================================================================
Routine Description:

    BOOL  BuildDeviceIDList

    This routine will build the list of device IDs

Arguments:

    lpszSectionName      - The section name that might contain a list of device IDs and INFs
    lpszIniFile          - The INI file to search
    lpDeviceClassGUID    - The device class to use to generate a list of all possible IDs
    lpDeviceIDList       - A pointer to be allocated and filled in with the list of IDs
    lpdwNumDeviceIDs     - A pointer to a DWORD that will recieve the number of IDs found
    bForceIDScan         - If TRUE a scan of IDs will be forced, even if the Section name is
                           not empty.
    bForceAlwaysSecExist - Do a Scan for all IDs even if the section name does not exist.

Return Value:

    TRUE if the list is build with no problem, or the list is empty because there
         was no INI file section. lpdwNumDeviceIDs is valid in this case
    FALSE if the list cannot be built.

===============================================================================
--*/

// ISSUE-2002/03/27-acosma,robertko - Check for NULL input parameters.
//
BOOL BuildDeviceIDList
(
    LPTSTR      lpszSectionName,
    LPTSTR      lpszIniFileName,
    LPGUID      lpDeviceClassGUID,
    LPDEVIDLIST *lplpDeviceIDList,
    LPDWORD     lpdwNumDeviceIDs,
    BOOL        bForceIDScan,
    BOOL        bForceAlwaysSecExist
)
{
    BOOL                    bRet = TRUE;
    LPTSTR                  lpNew;
    LPTSTR                  lpBuffer;
    LPTSTR                  lpKeys;
    DWORD                   dwBufferSize;
    DWORD                   dwKeyLen;
    DWORD                   dwResult;
    HDEVINFO                DeviceInfoSet;
    SP_DRVINFO_DATA         DrvInfoData;
    SP_DEVINSTALL_PARAMS    DeviceInstallParams;
    PSP_DRVINFO_DETAIL_DATA lpDrvInfoDetailData;
    DWORD                   cbBytesNeeded = 0;
    int                     i;
    LPTSTR                  lpszHwIDs;
    LPDEVIDLIST             lpDevIDList;
    DWORD                   dwSizeDevIDList;
    WCHAR                   szINFFileName[MAX_PATH];
    

    // Allocate a buffer to hold the section names
    if(lpBuffer = (LPTSTR)LocalAlloc(LPTR, (INIBUF_SIZE*sizeof(TCHAR)))) 
    {
        dwBufferSize = INIBUF_SIZE;
    } 
    else 
    {
        LogFactoryInstallError(TEXT("FACTORY:: Failed to allocate a buffer for reading the WINBOM file"));
        bRet = FALSE;
        goto Clean1;
    }

    // Iniitalize the number of device ID's found    
    *lpdwNumDeviceIDs = 0;
    
    // See if the INI section exists. We don't do anything if it does not
    if (bForceAlwaysSecExist || bINISectionExists(lpszSectionName, lpszIniFileName))
    {
        // Allocate the Initial ID array
        *lplpDeviceIDList = LocalAlloc(LPTR, DEVID_ARRAY_SIZE * sizeof(DEVIDLIST));        
        lpDevIDList = *lplpDeviceIDList;
        dwSizeDevIDList = DEVID_ARRAY_SIZE;
        
        // Make sure there was not an error
        if (!lpDevIDList)
        {
            LogFactoryInstallError(TEXT("FACTORY:: Failed to allocate a buffer for reading the WINBOM file"));
            bRet = FALSE;
            goto Clean1;
        }
        
        dwResult = GetPrivateProfileString(lpszSectionName,
                                           NULL,             // Get all keys
                                           TEXT(""),
                                           lpBuffer,
                                           dwBufferSize,
                                           lpszIniFileName);
        if (bForceIDScan || dwResult == 0)
        {
            // Allocate a DeviceInfo Set, for the specific device class GUID    
            DeviceInfoSet = SetupDiCreateDeviceInfoList(lpDeviceClassGUID, NULL);
            if(DeviceInfoSet == INVALID_HANDLE_VALUE) 
            {
                bRet = FALSE;
                goto Clean1;
            }

            // OR in the DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE flag to ensure we populate
            // the list with all of the device id's
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                              NULL,
                                              &DeviceInstallParams))
              {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE;
                SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                              NULL,
                                              &DeviceInstallParams);
              }

            if (!SetupDiBuildDriverInfoList(DeviceInfoSet, NULL, SPDIT_CLASSDRIVER))
            {
                bRet = FALSE;
                goto Clean1;
            }
    
            i = 0;
            DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
            while (SetupDiEnumDriverInfo(DeviceInfoSet, 
                                         NULL,
                                         SPDIT_CLASSDRIVER,
                                         i, 
                                         &DrvInfoData))
            {
                if (!SetupDiGetDriverInfoDetail(DeviceInfoSet, 
                                                NULL,
                                                &DrvInfoData,
                                                NULL,
                                                0,
                                                &cbBytesNeeded))
                {
                    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    {
                        continue;
                    }                        
                }                                   
         
                lpDrvInfoDetailData = LocalAlloc(LPTR, cbBytesNeeded);
                lpDrvInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                lpDrvInfoDetailData->HardwareID[0] = (TCHAR)NULL;
                lpDrvInfoDetailData->CompatIDsLength = 0;

                if (!SetupDiGetDriverInfoDetail(DeviceInfoSet, 
                                                NULL,
                                                &DrvInfoData,
                                                lpDrvInfoDetailData,
                                                cbBytesNeeded,
                                                NULL))
                {
                    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
                    {
                        LocalFree(lpDrvInfoDetailData);
                        continue;
                    }
                }       

                // 
                // Init
                //
                lpDevIDList[*lpdwNumDeviceIDs].szHardwareID[0] = _T('\0');
                lpDevIDList[*lpdwNumDeviceIDs].szCompatibleID[0] = _T('\0');

                //
                // Process only devices with valid HardWareID
                //
                if (lpDrvInfoDetailData->HardwareID[0] || lpDrvInfoDetailData->CompatIDsLength) 
                {
                    // Copy the HW ID
                    if (lpDrvInfoDetailData->HardwareID[0])
                        lstrcpy(lpDevIDList[*lpdwNumDeviceIDs].szHardwareID, lpDrvInfoDetailData->HardwareID);
                
                    // Copy the Compat ID
                    if (lpDrvInfoDetailData->CompatIDsLength) 
                    {
                        lstrcpyn(lpDevIDList[*lpdwNumDeviceIDs].szCompatibleID, 
                            (LPCTSTR)lpDrvInfoDetailData->HardwareID + lpDrvInfoDetailData->CompatIDsOffset,
                            lpDrvInfoDetailData->CompatIDsLength);
                    }

                    // Copy the INF file name
                    lstrcpy(lpDevIDList[*lpdwNumDeviceIDs].szINFFileName, lpDrvInfoDetailData->InfFileName);                                        

                    // 
                    // Increment PnP devices count
                    //
                    ++(*lpdwNumDeviceIDs);
            
                    // See if the device ID buffer needs to be reallocated
                    if (*lpdwNumDeviceIDs == dwSizeDevIDList)
                    {
                        if(lpNew = LocalReAlloc(*lplpDeviceIDList,
                                                ((dwSizeDevIDList + DEVID_ARRAY_GROW)*sizeof(DEVIDLIST)), 
                                                LMEM_MOVEABLE))
                        {
                            *lplpDeviceIDList = (LPDEVIDLIST)lpNew;
                            lpDevIDList = *lplpDeviceIDList;
                            dwSizeDevIDList += DEVID_ARRAY_GROW;
                        } 
                        else 
                        {
                            LogFactoryInstallError(TEXT("FACTORY:: Failed to Re-allocate a buffer for reading the WINBOM file"));
                            bRet = FALSE;
                            goto Clean1;
                        }
                    }
                }
                
                LocalFree(lpDrvInfoDetailData);        
                ++i;            
            }
        }
        else
        {
            // See if we got the whole section, and while we don't keep
            // making lpbuffer biffer
            while (dwResult == (dwBufferSize-2))
            {
                if(lpNew = LocalReAlloc(lpBuffer,
                                        ((dwBufferSize+INIBUF_GROW)*sizeof(TCHAR)), 
                                        LMEM_MOVEABLE))
                {
                    lpBuffer = lpNew;
                    dwBufferSize += INIBUF_GROW;
                } 
                else 
                {
                    LogFactoryInstallError(TEXT("FACTORY:: Failed to Re-allocate a buffer for reading the WINBOM file"));
                    bRet = FALSE;
                    goto Clean1;
                }
                
                dwResult = GetPrivateProfileString(lpszSectionName,
                                                   NULL,             // Get all keys
                                                   TEXT(""),
                                                   lpBuffer,
                                                   dwBufferSize,
                                                   lpszIniFileName);
            }

            // Walk the list, building the DeviceIDList
            for(lpKeys = lpBuffer; *lpKeys; lpKeys+=dwKeyLen) 
            {
                dwKeyLen = lstrlen(lpKeys)+1;
            
                // Copy the HW ID
                
                // NTRAID#NTBUG9-551266-2002/02/26-acosma - Buffer overrun possibility.
                //
                lstrcpy(lpDevIDList[*lpdwNumDeviceIDs].szHardwareID, lpKeys);
                // Get the INF name    
                GetPrivateProfileString(lpszSectionName,
                                        lpKeys,
                                        TEXT(""),
                                        szINFFileName,
                                        MAX_PATH,
                                        lpszIniFileName);

                ExpandEnvironmentStrings(szINFFileName, lpDevIDList[*lpdwNumDeviceIDs].szINFFileName, MAX_PATH);
                
                ++(*lpdwNumDeviceIDs);
                
                // See if the device ID buffer needs to be reallocated
                if (*lpdwNumDeviceIDs == dwSizeDevIDList)
                {
                    if(lpNew = LocalReAlloc(*lplpDeviceIDList,
                                            ((dwSizeDevIDList + DEVID_ARRAY_GROW)*sizeof(DEVIDLIST)), 
                                            LMEM_MOVEABLE))
                    {
                        *lplpDeviceIDList = (LPDEVIDLIST)lpNew;
                        lpDevIDList = *lplpDeviceIDList;
                        dwSizeDevIDList += DEVID_ARRAY_GROW;
                    } 
                    else 
                    {
                        LogFactoryInstallError(TEXT("FACTORY:: Failed to Re-allocate a buffer for reading the WINBOM file"));
                        bRet = FALSE;
                        goto Clean1;
                    }
                }
            }                        
        }
    }
    else
    {
        // See if there was an error, or the section just does not exist
        if (GetLastError() != 0)
        {
            bRet = FALSE;
        }
    }
    
Clean1:
    
    if (lpBuffer)
    {
        LocalFree(lpBuffer);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sys\disk.cpp ===
//
// DISK.CPP - Classes for partition table manipulation
//
// Revision History:
//

#include "disk.h"
#include <stdio.h>
#include <rpc.h>
#include <rpcdce.h>
#include <bootmbr.h>


HRESULT
CDrive::Initialize(
    LPCTSTR lpszLogicalDrive
    )
{
    HANDLE          handle;
    HRESULT         hr;
    DISK_GEOMETRY   geom;
    ULONG           bps;
    PVOID           unalignedBuffer;
    PVOID           buffer;
    
    /*
     *  Open the disk device
     */
    handle = LowOpenPartition(lpszLogicalDrive);
    if (handle == INVALID_HANDLE_VALUE) {
        return E_INVALIDARG;
    }
  
    /*
     *  Get the geometry
     */
    
    hr = LowGetGeometry(handle, &geom);
    if (FAILED(hr)) {
        CloseHandle(handle);
        return hr;
    }

    m_geometry.cylinders = geom.Cylinders.QuadPart;
    m_geometry.mediaType = geom.MediaType;
    m_geometry.tracksPerCylinder = geom.TracksPerCylinder;
    m_geometry.sectorsPerTrack = geom.SectorsPerTrack;
    m_geometry.bytesPerSector = geom.BytesPerSector;
    m_geometry.bytesPerTrack = m_geometry.sectorsPerTrack * 
                               m_geometry.bytesPerSector;
    m_geometry.bytesPerCylinder = m_geometry.tracksPerCylinder * 
                                  m_geometry.bytesPerTrack;
    m_geometry.totalSectorCount = (ULONGLONG)(m_geometry.cylinders * 
                                              m_geometry.bytesPerCylinder);
    m_length = m_geometry.cylinders * m_geometry.bytesPerCylinder;
    if (m_length == 0) {
        // Probably no media is present in the drive
        return E_INVALIDARG;
    }

    /*
     *  Get the true length of the drive
     */

    hr = LowGetLength(handle, &m_trueLength);
    if (FAILED(hr)) {
        CloseHandle(handle);
        return hr;
    }

    /*
     *  Check whether this is a NEC98 disk
     */

    m_isNEC98 = FALSE;

    bps = m_geometry.bytesPerSector;
    unalignedBuffer = (PVOID) new char[2 * bps];
    if (!unalignedBuffer) {
        CloseHandle(handle);
        return E_OUTOFMEMORY;
    }

    buffer = (PVOID) (((ULONG_PTR)unalignedBuffer + bps) & ~((ULONG_PTR)(bps - 1)));

    hr = LowReadSectors(handle, bps, 0, 1, buffer);
    if (FAILED(hr)) {
        delete [] (char*) unalignedBuffer;
        CloseHandle(handle);
        return hr;
    }

    if (IsNEC_98) {
        if (((unsigned char *)buffer)[0x1fe] == 0x55 && ((unsigned char *)buffer)[0x1ff] == 0xaa) {
            if (((unsigned char *)buffer)[4] == 'I' && ((unsigned char *)buffer)[5] == 'P' &&
                ((unsigned char *)buffer)[6] == 'L' && ((unsigned char *)buffer)[7] == '1') {
                m_isNEC98 = TRUE;
            }
        } else {
            m_isNEC98 = TRUE;
        }
    }
    
    delete [] (char*) unalignedBuffer;

    /*
     *  We have all the information we need. Return.
     */
    
    CloseHandle(handle);
    return S_OK;
}



CDrive::~CDrive(
    )
{
      
}

HRESULT 
CDrive::ReadBootRecord(
    LPCTSTR lpszLogicalDrive,
    UINT    nSectors,
    PBYTE   *buffer
    )
{
    HANDLE  hPartition;
    HRESULT hr;
    
    *buffer = new BYTE[m_geometry.bytesPerSector * nSectors];
    
    // Do disk ops, read bootcode
    //
    hPartition = LowOpenPartition(lpszLogicalDrive);
    
    if ( hPartition == INVALID_HANDLE_VALUE ) 
    {
        delete[] *buffer;
        *buffer = NULL;
        throw new W32Error();
    }
   
    hr = LowReadSectors(hPartition, m_geometry.bytesPerSector, 0, nSectors, *buffer);
    
    if ( S_OK != hr )
    {
        delete[] *buffer;
        *buffer = NULL;
        CloseHandle( hPartition );
        throw new W32Error();
    }

    CloseHandle( hPartition );
    
    // The calling function is responsible for cleaning up the buffer.
    //
    return hr;
}


HRESULT 
CDrive::WriteBootRecord(
    LPCTSTR lpszLogicalDrive,
    UINT    nSectors,
    PBYTE   *buffer
    )
{
    HANDLE  hPartition;
    HRESULT hr;
    UINT    *uiBackupSector = NULL;
    
    // Do disk ops, write bootcode
    //
    hPartition = LowOpenPartition(lpszLogicalDrive);
    
    if ( INVALID_HANDLE_VALUE == hPartition ) 
    {
        throw new W32Error();
    }
    
    // Figure out where the backup boot sector is.  It is at offset 0x32 in the boot record.
    //
    uiBackupSector = (UINT *) &((*buffer)[0x32]);

    hr = LowWriteSectors(hPartition, m_geometry.bytesPerSector, 0, nSectors, *buffer);
    
    if ( S_OK != hr )
    {
        CloseHandle(hPartition);
        throw new W32Error();
    }

    if ( uiBackupSector )
    {
        hr = LowWriteSectors(hPartition, m_geometry.bytesPerSector, *uiBackupSector, nSectors, *buffer);
    }

    if ( S_OK != hr )
    {
        CloseHandle(hPartition);
        throw new W32Error();
    }
     
    CloseHandle(hPartition);
 
    return hr;
}

HRESULT 
CDrive::WriteBootRecordXP(
    LPCTSTR lpszLogicalDrive,
    UINT    nSectors,
    PBYTE   *buffer
    )
{
    HANDLE  hPartition;
    HRESULT hr;
    UINT    *uiBackupSector = NULL;
    
    // Do disk ops, write bootcode
    //
    hPartition = LowOpenPartition(lpszLogicalDrive);
    
    if ( INVALID_HANDLE_VALUE == hPartition ) 
    {
        throw new W32Error();
    }
    
    // Figure out where the backup boot sector is.  It is at offset 0x32 in the boot record.
    //
    uiBackupSector = (UINT *) &((*buffer)[0x32]);
    
    // Write out the first 2 sectors to sectors 0 and 1 on the disk.  We will write the 
    // third sector to sector 12.
    //
    hr = LowWriteSectors(hPartition, m_geometry.bytesPerSector, 0, nSectors - 1, *buffer);
    
    if ( S_OK != hr )
    {
        CloseHandle(hPartition);
        throw new W32Error();
    }
    
    // For NT we need to write out the third sector of the bootcode to sector 12.
    //
    hr = LowWriteSectors(hPartition, m_geometry.bytesPerSector, 12, 1, *buffer + (2 * m_geometry.bytesPerSector));
    
    if ( S_OK != hr )
    {
        CloseHandle(hPartition);
        throw new W32Error();
    }
    
    if ( uiBackupSector )
    {
        hr = LowWriteSectors(hPartition, m_geometry.bytesPerSector, *uiBackupSector, nSectors, *buffer);
    }

    if ( S_OK != hr )
    {
        CloseHandle(hPartition);
        throw new W32Error();
    }
     
    CloseHandle(hPartition);
 
    return hr;
}


HANDLE
LowOpenDisk(
    ULONG   diskNumber 
    )
{
    HANDLE handle = NULL;
    int    err    = 0;
    int    i      = 0;
    WCHAR  buffer[64];

    swprintf(buffer, L"\\\\.\\PHYSICALDRIVE%lu", diskNumber);

    for ( i = 0; i < 5; i++ )
    {
        handle = CreateFile(
            buffer,
            GENERIC_READ |
            GENERIC_WRITE,
            FILE_SHARE_DELETE |
            FILE_SHARE_READ |
            FILE_SHARE_WRITE,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
        if (handle == INVALID_HANDLE_VALUE)
        {
            err = GetLastError();
            if (err == ERROR_SHARING_VIOLATION) Sleep(2000);
            else break;
        }
        else break;
    }
    return handle;
}

HANDLE
LowOpenPartition(
    ULONG   diskNumber,
    ULONG   partitionNumber
    )
{
    WCHAR buffer[64];

    swprintf(buffer, L"\\\\?\\GLOBALROOT\\Device\\Harddisk%lu\\Partition%lu",
             diskNumber, partitionNumber);

    return CreateFile(
        buffer,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
}

HANDLE
LowOpenPartition(
    LPCTSTR lpszLogicalDrive
    )
{
    return CreateFile(
        lpszLogicalDrive,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_DELETE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
}


HRESULT
LowGetGeometry(
    HANDLE          handle,
    PDISK_GEOMETRY  geometry
    )
{
    ULONG size;

    if (!DeviceIoControl(
        handle,
        IOCTL_DISK_GET_DRIVE_GEOMETRY,
        NULL,
        0,
        geometry,
        sizeof(DISK_GEOMETRY),
        &size,
        NULL)) {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
LowGetLength(
    HANDLE      handle,
    PLONGLONG   length
    )
{
    PARTITION_INFORMATION_EX    partInfoEx;
    PARTITION_INFORMATION       partInfo;
    ULONG                       size;

    /*
     *  Try first the new ioctl
     */

    if (DeviceIoControl(
        handle,
        IOCTL_DISK_GET_PARTITION_INFO_EX,
        NULL,
        0,
        &partInfoEx,
        sizeof(PARTITION_INFORMATION_EX),
        &size,
        NULL)) {

        *length = partInfoEx.PartitionLength.QuadPart;
        return S_OK;
    }

    /*
     *  For Win2K systems we should use the old ioctl
     */

    if (DeviceIoControl(
        handle,
        IOCTL_DISK_GET_PARTITION_INFO,
        NULL,
        0,
        &partInfo,
        sizeof(PARTITION_INFORMATION),
        &size,
        NULL)) {

        *length = partInfo.PartitionLength.QuadPart;
        return S_OK;
    }

    return E_FAIL;
}


HRESULT
LowReadSectors(
    HANDLE  handle,
    ULONG   sectorSize,
    ULONG   startingSector,
    ULONG   numberOfSectors,
    PVOID   buffer
    )
{
    IO_STATUS_BLOCK statusBlock;
    LARGE_INTEGER   byteOffset;

    byteOffset.QuadPart = UInt32x32To64(startingSector, sectorSize);

    statusBlock.Status = 0;
    statusBlock.Information = 0;

    if (!NT_SUCCESS(NtReadFile(
                        handle,
                        0,
                        NULL,
                        NULL,
                        &statusBlock,
                        buffer,
                        numberOfSectors * sectorSize,
                        &byteOffset,
                        NULL))) {
        return E_FAIL;
    }
    return S_OK;
}

HRESULT
LowWriteSectors(
    HANDLE  handle,
    ULONG   sectorSize,
    ULONG   startingSector,
    ULONG   numberOfSectors,
    PVOID   buffer
    )
{
    IO_STATUS_BLOCK statusBlock;
    LARGE_INTEGER   byteOffset;
 
    byteOffset.QuadPart = UInt32x32To64(startingSector, sectorSize);

    statusBlock.Status = 0;
    statusBlock.Information = 0;
    
    if (!NT_SUCCESS(NtWriteFile(
                        handle,
                        0,
                        NULL,
                        NULL,
                        &statusBlock,
                        buffer,
                        numberOfSectors * sectorSize,
                        &byteOffset,
                        NULL))) {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
LowFsLock(
    HANDLE handle
    )
{
    ULONG size;

    if (!DeviceIoControl(
        handle,
        FSCTL_LOCK_VOLUME,
        NULL,
        0,
        NULL,
        0,
        &size,
        NULL)) {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
LowFsUnlock(
    HANDLE handle
    )
{
    ULONG size;

    if (!DeviceIoControl(
        handle,
        FSCTL_UNLOCK_VOLUME,
        NULL,
        0,
        NULL,
        0,
        &size,
        NULL)) {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
LowFsDismount(
    HANDLE handle
    )
{
    ULONG size;

    if (!DeviceIoControl(
        handle,
        FSCTL_DISMOUNT_VOLUME,
        NULL,
        0,
        NULL,
        0,
        &size,
        NULL)) {
        return E_FAIL;
    }

    return S_OK;
}
 
LONGLONG
RoundUp(
    LONGLONG    value, 
    LONGLONG    factor
    )
/*
 *  Rounds a value up to a multiple of a given number
 */
{
    // This is the most common case so treat it separately
    if (value % factor == 0) {
        return value;
    }

    // And this is the generic formula
    return ((LONGLONG)((value + factor - 1) / factor)) * factor;
}


LONGLONG
RoundDown(
    LONGLONG    value, 
    LONGLONG    factor
    )
/*
 *  Rounds a value down to a multiple of a given number
 */
{
    // This is the most common case so treat it separately
    if (value % factor == 0) {
        return value;
    }
    
    //And this the generic formula
    return ((LONGLONG)(value / factor)) * factor;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sys\sys.cpp ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    sys.cpp

Abstract:

    Writes WinME boot sector to local hard disk.
    
Author:

    Adrian Cosma (acosma)

Revision History:

    July 11, 2001 - Created
    
--*/


#include <new.h>			// for MyNewHandler
#include <iostream>
#include <string>
#include <vector>
#include <9xboot32.h>
#include <bootf32.h>
#include "sys.h"


//
// Define a function to be called if new fails to allocate memory.
//
int __cdecl MyNewHandler( size_t size )
{
    wprintf(L"Memory allocation failed. Exiting program.\n");

    // Exit program
    //
    throw new W32Error();
}

//
// usage
//
std::wstring Usage = TEXT("sys.exe [/?] [/xp] drive-letter:\nExample: sys.exe c:");


//
// Invalid arguments
//
struct ProgramUsage : public ProgramException {
    std::wstring PrgUsage;

    ProgramUsage(const std::wstring &Usg) : PrgUsage(Usg) {}
    
    const char *what() const throw() {
        return "Program Usage exception";
    }

    void Dump(std::ostream &os) {
        os << Usage << std::endl;
    }
};

//
// Missing files
//
struct FileMissing : public ProgramException {
    std::wstring Message;

    FileMissing(std::wstring Msg) : Message(Msg) {}
    
    const char *what() const throw() {
        return "File missing exception";
    }

    void Dump(std::ostream &os) {
        os << TEXT("Error: ") << Message << std::endl;
    }
};


//
// Wrong filesystem.
//
struct FileSystem : public ProgramException {
    std::wstring Message;

    FileSystem(std::wstring Msg) : Message(Msg) {}
    
    const char *what() const throw() {
        return "Unsupported filesystem exception";
    }

    void Dump(std::ostream &os) {
        os << Message << std::endl;
    }
};

//
// Argument cracker
//
struct ProgramArguments 
{
    std::wstring    DriveLetter;
    bool            bXPBootSector;  // TRUE for XP boot sector, FALSE for 9x boot sector.
        
    ProgramArguments(int Argc, wchar_t *Argv[]) 
    {
        bool ValidArgs = true;
        
        bXPBootSector  = false;

        for (ULONG Index = 1; ValidArgs && (Index < Argc); Index++) 
        {
            ValidArgs = false;
                      
            // Find all the arguments that start with "/"
            //
            if ( TEXT('/') == Argv[Index][0] )
            {
                if ( !bXPBootSector && !_wcsicmp(Argv[Index], TEXT("/xp")) )
                {
                    bXPBootSector = true;
                    ValidArgs     = true;
                }
            }
            else  // Process arguments without the "/".  Must be the drive letter.
            {
                DriveLetter = Argv[Index];
                ValidArgs   = ((DriveLetter.length() == 2) &&
                               (DriveLetter[1] == TEXT(':')));
            }
        }

        if (!ValidArgs)
        {
            throw new ProgramUsage(Usage);
        }

        DriveLetter = TEXT("\\\\.\\") + DriveLetter;
    }

    friend std::ostream& operator<<(std::ostream &os, const ProgramArguments &Args) 
    {
        os << TEXT("DriveLetter : ") << Args.DriveLetter << std::endl;
        return os;
    }
};

// Verify that this partition is ready to be sys-ed.
//
VOID VerifyPartition(CDrive &Disk, ProgramArguments Args)
{
    TCHAR szFileSystemNameBuffer[20] = TEXT("");
    std::vector<LPTSTR> FileNames;
    std::vector<LPTSTR>::iterator i;

    
    if ( Args.bXPBootSector )
    {
        FileNames.push_back(TEXT("ntdetect.com"));
        FileNames.push_back(TEXT("ntldr"));
    }
    else
    {
        FileNames.push_back(TEXT("io.sys"));
        FileNames.push_back(TEXT("msdos.sys"));
        FileNames.push_back(TEXT("command.com"));
    }

    // Make sure that io.sys and msdos.sys and command.com are there on the root.
    //
    std::wstring Temp;

    for (i = FileNames.begin(); i < FileNames.end(); i++)
    {
        Temp = Args.DriveLetter + TEXT("\\");
        Temp += *i;
             
        if ( 0xFFFFFFFF == GetFileAttributes(Temp.c_str()) )
        {
            // Re-use the Temp string to put the error message in.
            //
            Temp = *i;
            Temp += TEXT(" is not present on the root of the drive specified.");
            throw new FileMissing(Temp);
        }
    }
    
    // Verify that this partition is FAT32.  Only handling FAT32 partitions at this point.
    //
    Temp = Args.DriveLetter + TEXT("\\");
    
    // If the filesystem is not FAT32 then trow an exception.
    //
    if ( !(GetVolumeInformation(Temp.c_str(), NULL, 0, NULL, NULL, NULL, szFileSystemNameBuffer, sizeof (szFileSystemNameBuffer)/sizeof (szFileSystemNameBuffer[0])) &&
          (CSTR_EQUAL == CompareString( LOCALE_INVARIANT, 
                                        NORM_IGNORECASE, 
                                        szFileSystemNameBuffer, 
                                        -1, 
                                        TEXT("FAT32"), 
                                        -1 ))) )
    {
        throw new FileSystem(TEXT("The target filesystem is not formatted FAT32."));
    }
}

VOID Sys(CDrive &Disk, ProgramArguments &Args)
{
    PBYTE pBuffer = NULL;
    PBYTE pBootRecord = NULL;   // Need a pointer to the boot record.

    if ( Args.bXPBootSector )
    {
        pBootRecord = Fat32BootCode;
    }
    else
    {
        pBootRecord = Fat32BootCode9x;
    }

    // Read the 1st sector of the disk in order to get the BPB
    //
    Disk.ReadBootRecord(Args.DriveLetter.c_str(), 1, &pBuffer);
    
    // Copy the old BPB to our boot record.
    //
    memcpy(&pBootRecord[11], &pBuffer[11], 79);

    // Delete the buffer allocated by ReadBootRecord.
    //
    delete [] pBuffer;
   
    // Write out the boot record.
    //
    if ( Args.bXPBootSector )
    {
         Disk.WriteBootRecordXP(Args.DriveLetter.c_str(), sizeof(Fat32BootCode9x) / SECTOR_SIZE, &pBootRecord);
    }
    else
    {
         Disk.WriteBootRecord(Args.DriveLetter.c_str(), sizeof(Fat32BootCode9x) / SECTOR_SIZE, &pBootRecord);
    }
   
    std::cout << TEXT("Done.") << std::endl;
}

//
// wmain() entry point
//
int 
_cdecl 
wmain(
    int Argc,
    wchar_t *Argv[]
    ) 
{
	INT Result = 0;
   		
    _set_new_handler( MyNewHandler );   // handles PREFIX issues

    try 
    {
        CDrive              Disk;
        ProgramArguments    Args(Argc, Argv);
        
        if ( S_OK != Disk.Initialize(Args.DriveLetter.c_str()))
        {
            throw new W32Error();
        }

        VerifyPartition(Disk, Args);
        Sys(Disk, Args);
    }
    catch(W32Error *Error)
    {
        if (Error)
        {
            Result = (INT)(Error->ErrorCode);
            Error->Dump(std::cout);
            delete Error;
        }
    }
    catch(ProgramException *Exp)
    {
        if (Exp)
        {
            Exp->Dump(std::cout);
            delete Exp;
        }
    }
    catch(...)
    {
        Result = 1;
        return Result;
    } 
    
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sprestrt\sprestrt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    sprestrt.c

Abstract:

    This program is used to help make GUI Setup restartable,
    if setup was started in restartable mode.

    Text mode setup will create a system hive containing the value

        HKLM\System\Setup:RestartSetup = REG_DWORD FALSE

    and a system.sav with RestartSetup set to TRUE. In both hives
    the session manager key will be written such that this program
    runs at autochk time.

    When this program starts, it checks the RestartSetup flag.
    If FALSE, then this is the first boot into GUI Setup, and we change it
    to TRUE and we're done here. If TRUE, then GUI setup needs to be
    restarted, and we clean out the config directory, copying *.sav to *.
    and erase everything else in there. System.sav has RestartSetup = TRUE,
    so GUI setup will be restarted over and over again until it succeeds.

    At the end of GUI Setup, sprestrt.exe is removed from the list of
    autochk programs and RestartSetup is set to FALSE.

    The boot loader looks at RestartSetup to see whether it needs to unload
    system and load system.sav instead. On the first boot into gui setup,
    we don't want to do this but on subsequent boots we do. The logic above
    makes this work correctly.

Author:

    Ted Miller (tedm) Feb 1996

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "msg.h"
#include "psp.h"

//
// Define result codes.
//
#define SUCCESS 0
#define FAILURE 1

//
// Define helper macro to deal with subtleties of NT-level programming.
//
#define INIT_OBJA(Obja,UnicodeString,UnicodeText)           \
                                                            \
    RtlInitUnicodeString((UnicodeString),(UnicodeText));    \
                                                            \
    InitializeObjectAttributes(                             \
        (Obja),                                             \
        (UnicodeString),                                    \
        OBJ_CASE_INSENSITIVE,                               \
        NULL,                                               \
        NULL                                                \
        )
//
// Relevent registry key and values.
//
const PCWSTR SetupRegistryKeyName = L"\\Registry\\Machine\\SYSTEM\\Setup";
const PCWSTR RestartSetupValueName = L"RestartSetup";
const PCWSTR ConfigDirectory =L"\\SystemRoot\\System32\\Config";
const PCWSTR ProgressIndicator = L".";

//
// Copy buffer. What the heck, it doesn't take up any space in the image.
//
#define COPYBUF_SIZE 65536
UCHAR CopyBuffer[COPYBUF_SIZE];

//
// Tristate value, where a boolean just won't do.
//
typedef enum {
    xFALSE,
    xTRUE,
    xUNKNOWN
} TriState;


//
// Define structure for keeping a linked list of unicode strings.
//
typedef struct _COPY_LIST_NODE {
    LONGLONG FileSize;
    UNICODE_STRING UnicodeString;
    struct _COPY_LIST_NODE *Next;
} COPY_LIST_NODE, *PCOPY_LIST_NODE;

//
// Memory routines
//
#define MALLOC(size)    RtlAllocateHeap(RtlProcessHeap(),0,(size))
#define FREE(block)     RtlFreeHeap(RtlProcessHeap(),0,(block))

//
// Forward references
//
TriState
CheckRestartValue(
    VOID
    );

BOOLEAN
SetRestartValue(
    VOID
    );

BOOLEAN
PrepareForGuiSetupRestart(
    VOID
    );

BOOLEAN
RestoreConfigDirectory(
    VOID
    );

NTSTATUS
CopyAFile(
    IN HANDLE DirectoryHandle,
    IN LONGLONG FileSize,
    IN PCWSTR ExistingFile,
    IN PCWSTR NewFile
    );

BOOLEAN
AreStringsEqual(
    IN PCWSTR String1,
    IN PCWSTR String2
    );

BOOLEAN
Message(
    IN ULONG MessageId,
    IN ULONG DotCount,
    ...
    );


int
__cdecl
main(
    VOID
    )
{
    int Result;

    SetupDelayedFileRename();

    //
    // Check the status of the RestartSetup flag.
    // If not present, do nothing.
    // If FALSE, set to TRUE.
    // If TRUE, clean up config directory.
    //

    switch(CheckRestartValue()) {

    case xFALSE:

        if(SetRestartValue()) {
            Result = SUCCESS;
        } else {
            Result = FAILURE;
            Message(MSG_WARNING_CANT_SET_RESTART,0);
        }
        break;

    case xTRUE:

        Result = PrepareForGuiSetupRestart();
        Message(MSG_CRLF,0);
        if(!Result) {
            Message(MSG_WARNING_CANT_CLEAN_UP,0);
        }
        break;

    default:

        Result = FAILURE;
        break;
    }

    return(Result);
}



TriState
CheckRestartValue(
    VOID
    )

/*++

Routine Description:

    Check if HKLM\System\Setup:RestartSetup is present as a REG_DWORD
    and if so get its value.

Arguments:

    None.

Return Value:

    Value indicating whether the flag is set (xTrue), not set (xFalse),
    or in an unknown state (ie, not present or not REG_DWORD, etc; xUnknown).

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    ULONG DataLength;
    UCHAR Buffer[1024];
    PKEY_VALUE_PARTIAL_INFORMATION KeyInfo;
    TriState b;

    //
    // Assume not present.
    //
    b = xUNKNOWN;

    //
    // Attempt to open the key.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,SetupRegistryKeyName);

    Status = NtOpenKey(
                &KeyHandle,
                READ_CONTROL | KEY_QUERY_VALUE,
                &ObjectAttributes
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: Unable to open %ws (%lx)\n",
                   SetupRegistryKeyName,
                   Status));

        goto c0;
    }

    //
    // Attempt to get the value of "RestartSetup"
    //
    RtlInitUnicodeString(&UnicodeString,RestartSetupValueName);

    Status = NtQueryValueKey(
                KeyHandle,
                &UnicodeString,
                KeyValuePartialInformation,
                Buffer,
                sizeof(Buffer),
                &DataLength
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: Unable to get value of %ws (%lx)\n",
                   RestartSetupValueName,
                   Status));

        goto c1;
    }

    //
    // Check for a REG_DWORD value and fetch.
    //
    KeyInfo = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;

    if((KeyInfo->Type == REG_DWORD) && (KeyInfo->DataLength == sizeof(ULONG))) {

        b = *(PULONG)KeyInfo->Data ? xTRUE : xFALSE;

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_INFO_LEVEL,
                   "RestartSetup: Restart value is %u\n",
                   b));

    } else {

        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: %ws is corrupt!\n",
                   RestartSetupValueName));
    }

c1:
    NtClose(KeyHandle);
c0:
    return(b);
}


BOOLEAN
SetRestartValue(
    VOID
    )

/*++

Routine Description:

    Set HKLM\System\Setup:RestartSetup to REG_DWORD 1.

Arguments:

    None.

Return Value:

    Boolean value indicating whether the operation was successful.

--*/

{
    UNICODE_STRING UnicodeString;
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE KeyHandle;
    BOOLEAN b;
    ULONG One;

    //
    // Assume failure.
    //
    b = FALSE;

    //
    // Attempt to open the key, which must already be present.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,SetupRegistryKeyName);

    Status = NtOpenKey(
                &KeyHandle,
                READ_CONTROL | KEY_SET_VALUE,
                &ObjectAttributes
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: Unable to open %ws (%lx)\n",
                   SetupRegistryKeyName,
                   Status));

        goto c0;
    }

    //
    // Attempt to set the value of "RestartSetup" to REG_DWORD 1.
    //
    RtlInitUnicodeString(&UnicodeString,RestartSetupValueName);
    One = 1;

    Status = NtSetValueKey(
                KeyHandle,
                &UnicodeString,
                0,
                REG_DWORD,
                &One,
                sizeof(ULONG)
                );

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: Unable to set value of %ws (%lx)\n",
                   RestartSetupValueName,
                   Status));

        goto c1;
    }

    //
    // Success.
    //
    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "RestartSetup: Value of %ws set to 1\n",
               RestartSetupValueName));

    b = TRUE;

c1:
    NtClose(KeyHandle);
c0:
    return(b);
}


BOOLEAN
PrepareForGuiSetupRestart(
    VOID
    )

/*++

Routine Description:

    Prepares the system for restarting gui mode setup.
    Currently this consists of erasing %sysroot%\system32\config\*,
    except *.sav, then copying *.sav to *.

Arguments:

    None.

Return Value:

    Boolean value indicating whether we were successful.

--*/

{
    BOOLEAN b;

    //
    // Display a message indicating that we are rolling back to the
    // start of gui mode setup.
    //
    Message(MSG_CRLF,0);
    Message(MSG_RESTARTING_SETUP,0);

    b = RestoreConfigDirectory();

    return b;
}

BOOLEAN
RestoreConfigDirectory(
    VOID
    )

/*++

Routine Description:

    Erase %sysroot%\system32\config\*, except *.sav, and userdiff,
    then copy *.sav to *.

Arguments:

    None.

Return Value:

    Boolean value indicating whether we were successful.

--*/

{
    NTSTATUS Status;
    HANDLE DirectoryHandle;
    HANDLE FileHandle;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    LONGLONG Buffer[2048/8];
    BOOLEAN FirstQuery;
    PFILE_DIRECTORY_INFORMATION FileInfo;
    ULONG LengthChars;
    BOOLEAN Ignore;
    FILE_DISPOSITION_INFORMATION Disposition;
    BOOLEAN AnyErrors;
    PCOPY_LIST_NODE CopyList,CopyNode,NextNode;
    ULONG DotCount;
    WCHAR FilenamePrefix[8];

    //
    // Open \SystemRoot\system32\config for list access.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,ConfigDirectory);

    Status = NtOpenFile(
                &DirectoryHandle,
                FILE_LIST_DIRECTORY | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_OPEN_FOR_BACKUP_INTENT
                );

    DotCount = 0;
    Message(MSG_RESTARTING_SETUP,++DotCount);

    if(!NT_SUCCESS(Status)) {
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: unable to open system32\\config for list access (%lx)\n",
                   Status));

        return(FALSE);
    }

    FirstQuery = TRUE;
    FileInfo = (PFILE_DIRECTORY_INFORMATION)Buffer;
    AnyErrors = FALSE;
    CopyList = NULL;
    do {

        Status = NtQueryDirectoryFile(
                    DirectoryHandle,
                    NULL,                           // no event to signal
                    NULL,                           // no apc routine
                    NULL,                           // no apc context
                    &IoStatusBlock,
                    Buffer,
                    sizeof(Buffer)-sizeof(WCHAR),   // leave room for terminating nul
                    FileDirectoryInformation,
                    TRUE,                           // want single entry
                    NULL,                           // get 'em all
                    FirstQuery
                    );

        if(NT_SUCCESS(Status)) {

            //
            // Got a file. First nul-terminate the name.
            // Then see if is one to be ignored, ie, ends in .sav.
            // Also ignore userdiff.
            //
            LengthChars = FileInfo->FileNameLength / sizeof(WCHAR);
            FileInfo->FileName[LengthChars] = 0;
            Ignore = FALSE;

            if(FileInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                Ignore = TRUE;
            } else {
                RtlCopyMemory(FilenamePrefix,FileInfo->FileName,7*sizeof(WCHAR));
                FilenamePrefix[7] = 0;
                if(AreStringsEqual(FilenamePrefix,L"userdif")) {
                    Ignore = TRUE;
                } else {
                    if((LengthChars > 4) && AreStringsEqual(FileInfo->FileName+LengthChars-4,L".sav")) {

                        Ignore = TRUE;

                        //
                        // Also, remember .sav files for later.
                        //
                        if(CopyNode = MALLOC(sizeof(COPY_LIST_NODE))) {
                            if(RtlCreateUnicodeString(&CopyNode->UnicodeString,FileInfo->FileName)) {
                                CopyNode->FileSize = FileInfo->EndOfFile.QuadPart;
                                CopyNode->Next = CopyList;
                                CopyList = CopyNode;
                            } else {
                                Status = STATUS_NO_MEMORY;
                                FREE(CopyNode);
                            }
                        } else {
                            Status = STATUS_NO_MEMORY;
                        }
                    }
                }
            }

            if(!Ignore) {
                //
                // Not supposed to ignore this file: delete it now.
                //
                Message(MSG_RESTARTING_SETUP,++DotCount);
                KdPrintEx((DPFLTR_SETUP_ID,
                           DPFLTR_INFO_LEVEL,
                           "RestartSetup: Deleting %ws\n",
                           FileInfo->FileName));

                INIT_OBJA(&ObjectAttributes,&UnicodeString,FileInfo->FileName);
                ObjectAttributes.RootDirectory = DirectoryHandle;

                Status = NtOpenFile(
                            &FileHandle,
                            DELETE,
                            &ObjectAttributes,
                            &IoStatusBlock,
                            FILE_SHARE_VALID_FLAGS,
                            FILE_NON_DIRECTORY_FILE | FILE_OPEN_FOR_BACKUP_INTENT
                            );

                if(NT_SUCCESS(Status)) {
                    //
                    // Perform actual delete operation.
                    //
                    Disposition.DeleteFile = TRUE;
                    Status = NtSetInformationFile(
                                FileHandle,
                                &IoStatusBlock,
                                &Disposition,
                                sizeof(Disposition),
                                FileDispositionInformation
                                );

                    if(!NT_SUCCESS(Status)) {
                        KdPrintEx((DPFLTR_SETUP_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "RestartSetup: Unable to delete %ws (%lx)\n",
                                   FileInfo->FileName,Status));

                        AnyErrors = TRUE;
                    }

                    NtClose(FileHandle);

                } else {
                    KdPrintEx((DPFLTR_SETUP_ID,
                               DPFLTR_WARNING_LEVEL,
                               "RestartSetup: Unable to delete %ws (%lx)\n",FileInfo->FileName,
                               Status));

                    AnyErrors = TRUE;
                }
            }

            FirstQuery = FALSE;
        }
    } while(NT_SUCCESS(Status));

    //
    // Check for normal loop termination.
    //
    if(Status == STATUS_NO_MORE_FILES) {
        Status = STATUS_SUCCESS;
    }

    //
    // Even if we got errors, try to keep going.
    //
    if(!NT_SUCCESS(Status)) {
        AnyErrors = TRUE;
        KdPrintEx((DPFLTR_SETUP_ID,
                   DPFLTR_WARNING_LEVEL,
                   "RestartSetup: Status %lx enumerating files\n",
                   Status));
    }

    //
    // Now run down our list of *.sav and copy to *.
    //
    for(CopyNode=CopyList; CopyNode; CopyNode=NextNode) {

        Message(MSG_RESTARTING_SETUP,++DotCount);

        //
        // Remember next node, because we're going to free this one.
        //
        NextNode = CopyNode->Next;

        //
        // Create the target name, which is the same as the source name
        // with the .sav stripped off.
        //
        if(RtlCreateUnicodeString(&UnicodeString,CopyNode->UnicodeString.Buffer)) {

            UnicodeString.Buffer[(UnicodeString.Length/sizeof(WCHAR))-4] = 0;
            UnicodeString.Length -= 4*sizeof(WCHAR);

            Status = CopyAFile(
                        DirectoryHandle,
                        CopyNode->FileSize,
                        CopyNode->UnicodeString.Buffer,
                        UnicodeString.Buffer
                        );

            RtlFreeUnicodeString(&UnicodeString);

        } else {
            Status = STATUS_NO_MEMORY;
        }

        if(!NT_SUCCESS(Status)) {
            AnyErrors = TRUE;
            KdPrintEx((DPFLTR_SETUP_ID,
                       DPFLTR_WARNING_LEVEL,
                       "RestartSetup: Unable to copy %ws (%lx)\n",
                       CopyNode->UnicodeString.Buffer,Status));
        }

        RtlFreeUnicodeString(&CopyNode->UnicodeString);
        FREE(CopyNode);
    }

    NtClose(DirectoryHandle);
    return((BOOLEAN)!AnyErrors);
}


NTSTATUS
CopyAFile(
    IN HANDLE DirectoryHandle,
    IN LONGLONG FileSize,
    IN PCWSTR ExistingFile,
    IN PCWSTR NewFile
    )

/*++

Routine Description:

    Performs a simple file copy within a directory.
    The target file must either not exist or be writable.
    Only the default stream is copied.

Arguments:

    DirectoryHandle - supplies handle to directory within which
        the file is to be copied. The handle must have appropriate
        access to allow this.

    FileSize - supplies size of file to be copied.

    ExistingFile - supplies filename of file within directory to
        be copied.

    NewFile - supplies name of file to be created as a copy of
        the existing file.

Return Value:

    NT Status code indicating outcome.

--*/

{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    HANDLE SourceHandle;
    HANDLE TargetHandle;
    ULONG XFerSize;


    KdPrintEx((DPFLTR_SETUP_ID,
               DPFLTR_INFO_LEVEL,
               "RestartSetup: Copying %ws to %ws\n",
               ExistingFile,
               NewFile));

    //
    // Open the source for reading. The source must exist.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,ExistingFile);
    ObjectAttributes.RootDirectory = DirectoryHandle;

    Status = NtOpenFile(
                &SourceHandle,
                FILE_READ_DATA | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                FILE_SHARE_READ,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT
                );

    if(!NT_SUCCESS(Status)) {
        goto c0;
    }

    //
    // Open/create the target for writing.
    //
    INIT_OBJA(&ObjectAttributes,&UnicodeString,NewFile);
    ObjectAttributes.RootDirectory = DirectoryHandle;

    Status = NtCreateFile(
                &TargetHandle,
                FILE_WRITE_DATA | SYNCHRONIZE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        goto c1;
    }

    //
    // Read/write buffers while there's still data to copy.
    //
    while(NT_SUCCESS(Status) && FileSize) {

        XFerSize = (FileSize < COPYBUF_SIZE) ? (ULONG)FileSize : COPYBUF_SIZE;

        Status = NtReadFile(
                    SourceHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    CopyBuffer,
                    XFerSize,
                    NULL,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {

            Status = NtWriteFile(
                        TargetHandle,
                        NULL,
                        NULL,
                        NULL,
                        &IoStatusBlock,
                        CopyBuffer,
                        XFerSize,
                        NULL,
                        NULL
                        );

            FileSize -= XFerSize;
        }
    }

    NtClose(TargetHandle);
c1:
    NtClose(SourceHandle);
c0:
    return(Status);
}


BOOLEAN
AreStringsEqual(
    IN PCWSTR String1,
    IN PCWSTR String2
    )

/*++

Routine Description:

    Compare 2 0-terminated unicode strings, case insensitively.

Arguments:

    String1 - supplies first string for comparison

    String2 - supplies second string for comparison

Return Value:

    Boolean value indicating whether strings are equal.
    TRUE = yes; FALSE = no.

--*/

{
    UNICODE_STRING u1;
    UNICODE_STRING u2;

    RtlInitUnicodeString(&u1,String1);
    RtlInitUnicodeString(&u2,String2);

    return((BOOLEAN)(RtlCompareUnicodeString(&u1,&u2,TRUE) == 0));
}


BOOLEAN
Message(
    IN ULONG MessageId,
    IN ULONG DotCount,
    ...
    )

/*++

Routine Description:

    Format and display a message, which is retreived from
    the image's message resources.

Arguments:

    MessageId - Supplies the message id of the message resource.

    DotCount - Supplies number of trailing dots to be appended to
        the message text prior to display. If this value is non-0,
        then the message shouldn't have a trailing cr/lf!

    Additional arguments specify message-specific inserts.

Return Value:

    Boolean value indicating whether the message was displayed.

--*/

{
    PVOID ImageBase;
    NTSTATUS Status;
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    va_list arglist;
    WCHAR Buffer[1024];
    ULONG u;

    //
    // Get our image base address
    //
    ImageBase = NtCurrentPeb()->ImageBaseAddress;
    if(!ImageBase) {
        return(FALSE);
    }

    //
    // Find the message.
    // For DBCS codepages we will use English resources instead of
    // default resource because we can only display ASCII characters onto
    // blue Screen via HalDisplayString()
    //
    Status = RtlFindMessage(
                ImageBase,
                11,
                NLS_MB_CODE_PAGE_TAG ? MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US) : 0,
                MessageId,
                &MessageEntry
                );

    if(!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    //
    // If the message is not unicode, convert to unicode.
    // Let the conversion routine allocate the buffer.
    //
    if(!(MessageEntry->Flags & MESSAGE_RESOURCE_UNICODE)) {

        RtlInitAnsiString(&AnsiString,MessageEntry->Text);
        Status = RtlAnsiStringToUnicodeString(&UnicodeString,&AnsiString,TRUE);
        if(!NT_SUCCESS(Status)) {
            return(FALSE);
        }

    } else {
        //
        // Message is already unicode. Make a copy.
        //
        if(!RtlCreateUnicodeString(&UnicodeString,(PWSTR)MessageEntry->Text)) {
            return(FALSE);
        }
    }

    //
    // Format the message.
    //
    va_start(arglist,DotCount);

    Status = RtlFormatMessage(
                UnicodeString.Buffer,
                0,                      // max width
                FALSE,                  // don't ignore inserts
                FALSE,                  // args are not ansi
                FALSE,                  // args are not an array
                &arglist,
                Buffer,
                sizeof(Buffer)/sizeof(Buffer[0]),
                NULL
                );

    va_end(arglist);

    //
    // We don't need the message source any more. Free it.
    //
    RtlFreeUnicodeString(&UnicodeString);

    //
    // Add dots and cr.
    //
    for(u=0; u<DotCount; u++) {
        wcscat(Buffer,L".");
    }
    wcscat(Buffer,L"\r");

    //
    // Print out the message
    //
    RtlInitUnicodeString(&UnicodeString,Buffer);
    Status = NtDisplayString(&UnicodeString);

    return(NT_SUCCESS(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sysprep\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sysprep.rc
//
#define IDS_NOAUTOEXEC                  1
#define IDS_NOCONFIGSYS                 2
#define IDS_REGOPEN1                    3
#define IDS_REVERT                      4
#define IDS_OEMRESET                    4
#define IDS_APPNAME                     5
#define IDS_HELP                        6
#define IDS_ERR_BADCMDLINE              7
#define IDS_MSG_IMAGECOMPLETE           8
#define IDS_APPTITLE                    9
#define IDS_SYSPREP                     10
#define IDS_ERR_FACTORYMODE             11
#define IDS_SHUTDOWN                    12
#define IDS_REBOOT                      13
#define IDS_QUIT                        14
#define IDS_ADMINISTRATOR1              15
#define IDS_OWNER1                      16
#define IDS_TEMP_DIR                    17
#define IDS_TEMP_INTERNET_DIR           18
#define IDS_SID_DIR1                    19
#define IDS_SID_DIR2                    20
#define IDS_SID_DIR3                    21 
#define IDS_HISTORY_DIR                 22
#define IDS_HISTORY_DIR_IE5             23
#define IDD_OEMREMINDER                 101
#define IDD_WAIT                        103
#define IDA_CLOCK_AVI                   104
#define IDAUDIT                         200
#define IDC_PROGRESS                    1000
#define ID_SHUTDOWN_NOW                 1001
#define ID_SHUTDOWN_CANCEL              1002
#define IDFACTORY                       1004
#define IDC_MINISETUP                   1007
#define IDC_PNP                         1008
#define IDC_NOSIDGEN                    1009
#define IDC_SHUTDOWN                    1010
#define IDC_ANIMATE                     1011
#define IDC_ACTIVATED                   1013
#define IDC_STATIC_AUDIT                1014
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sysprep\oemreset.c ===
/**************************************************************************
 *
 * OEMRESET
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1999
 *  All rights reserved
 *
 *  Main entry point 
 *
 *  Command line:   /A /Auto:   Enduser reboot
 *                  /S      :   Enduser power-down
 *                  /R      :   Audit reboot
 *                  /P      :   Audit power-down
 *                  /H      :   Hide dialog
 *                  /L      :   OEM logging enabled (c:\reset.txt)
 *
 *  Revision History:
 *  7/00 - Brian Ku (briank)     Port from Millennium to Whistler.
 *  5/01 - Adrian Cosma (acosma) Remove dead code and integrate more with sysprep.c.
 *
 *
 *************************************************************************/
#include <opklib.h>
#include <tchar.h>

#pragma warning( disable:4001 ) /* Disable new type remark warning */
#pragma warning( disable:4100 ) /* Disable unreferenced formal param */

#include <commctrl.h>
#include <winreg.h>
#include <regstr.h>
#include <shlwapi.h>

#include "sysprep.h"
#include "msg.h"
#include "resource.h"

// Action flags
//
extern BOOL NoSidGen;
extern BOOL SetupClPresent;
extern BOOL bMiniSetup;
extern BOOL PnP;
extern BOOL Reboot;
extern BOOL NoReboot;
extern BOOL ForceShutdown;
extern BOOL bActivated;
extern BOOL Reseal;
extern BOOL Factory;
extern BOOL Audit;
extern BOOL QuietMode;

extern TCHAR g_szLogFile[];
extern BOOL IsProfessionalSKU();
extern BOOL FProcessSwitches();

extern int
MessageBoxFromMessage(
    IN DWORD MessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    );

//***************************************************************************
//
// Definitions
//
//***************************************************************************

// Audit modes
//
#define MODE_NO_AUDIT            0
#define MODE_RESTORE_AUDIT       2
#define MODE_SIMULATE_ENDUSER    3

// User defined messages
//
#define WM_PROGRESS             (WM_USER + 0x0001)
#define WM_FINISHED             (WM_USER + 0x0002)



// Flags used for command line parsing
//
#define OEMRESET_AUTO       0x0001  // Auto /A or /AUTO
#define OEMRESET_SHUTDOWN   0x0002  // Shutdown /S
#define OEMRESET_AUDIT      0x0004  // Audit reboot /R
#define OEMRESET_AUDITPD    0x0008  // Audit power-down, when booted back up, you will still be in audit mode
#define OEMRESET_HIDE       0x0010  // Hide dialog /H
#define OEMRESET_LOG        0x0020  // Log enabled /L 
#define OEMRESET_OEMRUN     0x0040  // Launch oemrun items


// Configuration files/directories
//
#define DIR_BOOT            _T("BootDir")

#define FILE_RESET_LOG      _T("RESETLOG.TXT")
#define FILE_AFX_TXT        _T("\\OPTIONS\\AFC.TXT")

// Other constants
//
#define REBOOT_SECONDS      30

// Global Variables
//
HWND        ghwndOemResetDlg = 0;                   // HWND for OemReset Dialog
HINSTANCE   ghinstEXE = 0;
DWORD       gdwCmdlineFlags = 0;                    // Switches used 
BOOL        gbHide = FALSE;                         // Hide all dialogs
BOOL        gbLog = FALSE;                          // Enable logging
HFILE       ghf = 0;                                // Log file handle
HANDLE      ghMonitorThread = 0;
DWORD       gdwThreadID = 0;
UINT_PTR    gTimerID = 1;                           // Wait timer id
UINT        gdwMillSec = 120 * 1000;                // Wait millsec
HWND        ghwndProgressCtl;                       // Wait progress controls

/* Local Prototypes */
static HWND CreateOemResetDlg(HINSTANCE hInstance);
static void FlushAndDisableRegistry();
static BOOL FShutdown();
static BOOL ParseCmdLineSwitches(LPTSTR);
static TCHAR* ParseRegistrySwitches();
static void StartMonitorKeyValue();
static void HandleCommandSwitches();
static BOOL VerifySids();


/* Dialog functions */
INT_PTR CALLBACK RemindeOEMDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
void uiDialogTopRight(HWND hwndDlg);

//////////////////////////////////////////////////////////////////////////////
// Create the OEMRESET Dialog modeless so we can hide it if necessary
//
HWND CreateOemResetDlg(HINSTANCE hInstance)
{
    return CreateDialog(hInstance, MAKEINTRESOURCE(IDD_OEMREMINDER), NULL, (DLGPROC) RemindeOEMDlgProc);    
}

//////////////////////////////////////////////////////////////////////////////
// Find the boot drive in the registry
//
void GetBootDrive(TCHAR szBootDrive[])
{
    HKEY hKey = 0;
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_CURRENTVERSION_SETUP, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwSize = MAX_PATH;
        RegQueryValueEx(hKey, DIR_BOOT, 0L, NULL, (LPBYTE)szBootDrive, &dwSize);
        RegCloseKey(hKey);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Sets the flag determined by whether the dialog checkbox is checked or not
//
void SetFlag(HWND hDlg, WPARAM ctlId, BOOL* pfFlag)
{
    if (pfFlag) {
        if (IsDlgButtonChecked(hDlg, (INT)ctlId))
            *pfFlag = TRUE;
        else 
            *pfFlag = FALSE;
    }
}

//////////////////////////////////////////////////////////////////////////////
// Sets the flag determined by whether the dialog checkbox is checked or not
//
void SetCheck(HWND hDlg, WPARAM ctlId, BOOL fFlag)
{
        if (fFlag)
            CheckDlgButton(hDlg, (INT)ctlId, BST_CHECKED);
        else 
            CheckDlgButton(hDlg, (INT)ctlId, BST_UNCHECKED);
}

extern StartWaitThread();

//////////////////////////////////////////////////////////////////////////////
// Put up UI telling the OEM that they still have to execute this.
//
INT_PTR CALLBACK RemindeOEMDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) 
    {
        case WM_INITDIALOG:

            // Quiet is always FALSE when the UI is up.
            //
            QuietMode = FALSE;

            // IA64 always use mini-setup
            //
            if (IsIA64()) {
                SetCheck(hwnd, IDC_MINISETUP, bMiniSetup = TRUE);            
                EnableWindow(GetDlgItem(hwnd, IDC_MINISETUP), FALSE);
            }
            else {
                // Set check depending on flag
                //
                SetCheck(hwnd, IDC_MINISETUP, bMiniSetup);                               

                // Only Professional SKU can use both oobe or mini-setup otherwise 
                // disable the checkbox
                //
                if (!IsProfessionalSKU())
                    EnableWindow(GetDlgItem(hwnd, IDC_MINISETUP), FALSE);
            }

            // Disable the pnp checkbox if mini-setup is not checked.
            //
            if ( !bMiniSetup )
                EnableWindow(GetDlgItem(hwnd, IDC_PNP), FALSE);
            else
                SetCheck(hwnd, IDC_PNP, PnP);

            SetCheck(hwnd, IDC_NOSIDGEN, NoSidGen);            
            SetCheck(hwnd, IDC_ACTIVATED, bActivated);

            // If setupcl.exe is not present and they specified nosidgen
            // then we need to disable the checkbox
            //
            if ( !SetupClPresent && NoSidGen )
                EnableWindow(GetDlgItem(hwnd, IDC_NOSIDGEN), FALSE);

            // Disable Audit button if we are not in factory mode and change the caption.
            //
            if ( !RegCheck(HKLM, REGSTR_PATH_SYSTEM_SETUP, REGSTR_VALUE_AUDIT) )
            {
                EnableWindow(GetDlgItem(hwnd, IDAUDIT), FALSE);
            }
            
            // Init the combo box.
            //
            {
                HWND hCombo = NULL;
                                               
                if (hCombo = GetDlgItem(hwnd, IDC_SHUTDOWN)) {
                    TCHAR   szComboString[MAX_PATH] = _T("");                                       
                    LRESULT ret = 0;
                    
                    if ( LoadString(ghinstEXE, IDS_SHUTDOWN, szComboString, sizeof(szComboString)/sizeof(szComboString[0])) &&
                         ((ret = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) szComboString)) != CB_ERR) )
                    {
                        SendMessage(hCombo, CB_SETITEMDATA, ret, (LPARAM) NULL);
                    }

                    if ( LoadString(ghinstEXE, IDS_REBOOT, szComboString, sizeof(szComboString)/sizeof(szComboString[0])) &&
                         ((ret = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) szComboString)) != CB_ERR) )
                    {
                        SendMessage(hCombo, CB_SETITEMDATA, ret, (LPARAM) &Reboot);
                    }
                    
                    if ( LoadString(ghinstEXE, IDS_QUIT, szComboString, sizeof(szComboString)/sizeof(szComboString[0])) &&
                         ((ret = SendMessage(hCombo, CB_ADDSTRING, 0, (LPARAM) szComboString)) != CB_ERR) )
                    {
                        SendMessage(hCombo, CB_SETITEMDATA, ret, (LPARAM) &NoReboot);
                    }
                    
                    if (NoReboot)
                        SendMessage(hCombo, CB_SETCURSEL, (WPARAM) 2, 0);
                    else if (Reboot)
                        SendMessage(hCombo, CB_SETCURSEL, (WPARAM) 1, 0);
                    else
                        SendMessage(hCombo, CB_SETCURSEL, (WPARAM) 0, 0);
                }
            }

            uiDialogTopRight(hwnd);

            LockApplication(FALSE);

            break;

        case WM_CLOSE:

            LockApplication(FALSE);
            break;

        case WM_COMMAND:
            switch ( LOWORD(wParam) ) 
            {
                case IDCANCEL:
                    PostQuitMessage(0);
                    break;

                // Action buttons
                //
                case IDOK:   // Reseal
                    // Check whether SIDS have been regenerated and try to help the user 
                    // make a smart decision about doing it again.
                    if ( !VerifySids() )
                    {
                        SetFocus(GetDlgItem(hwnd, IDC_NOSIDGEN));
                        return FALSE;
                    }

                    if ( !LockApplication(TRUE) )
                    {
                        MessageBoxFromMessage( MSG_ALREADY_RUNNING,
                                               IDS_APPTITLE,
                                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
                        
                        return FALSE;
                    }
                    
                    Reseal = TRUE;

                    // Reseal the machine
                    //
                    FProcessSwitches();
                    LockApplication(FALSE);

                    break;

                case IDAUDIT:
                    {
                        // Prepare for pseudo factory but get back to audit 
                        //
                        TCHAR szFactoryPath[MAX_PATH] = NULLSTR;

                        if ( !LockApplication(TRUE) )
                        {
                            MessageBoxFromMessage( MSG_ALREADY_RUNNING,
                                                   IDS_APPTITLE,
                                                   MB_OK | MB_ICONERROR | MB_TASKMODAL );
                            return FALSE;
                        }
                        Audit = TRUE;

                        FProcessSwitches();
                        LockApplication(FALSE);
                    }
                    break;
                case IDFACTORY:  // Factory
                    if ( !LockApplication(TRUE) )
                    {
                        MessageBoxFromMessage( MSG_ALREADY_RUNNING,
                                               IDS_APPTITLE,
                                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
                        return FALSE;
                    }
                    Factory = TRUE;

                    // Prepare for factory mode
                    //
                    FProcessSwitches();
                    LockApplication(FALSE);
                    break;
                    
                // Action Flags checkboxes
                //
                case IDC_MINISETUP:
                    SetFlag(hwnd, wParam, &bMiniSetup);
                    // If mini-setup checkbox is set, then enable the PNP checkbox,
                    // otherwise disable it.
                    if ( !bMiniSetup ) {
                        PnP = FALSE;
                        SetCheck(hwnd, IDC_PNP, PnP);
                        EnableWindow(GetDlgItem(hwnd, IDC_PNP), FALSE);
                    }
                    else {
                        EnableWindow(GetDlgItem(hwnd, IDC_PNP), TRUE);
                    }
                    break;
                case IDC_PNP:
                    SetFlag(hwnd, wParam, &PnP);
                    break;
                case IDC_ACTIVATED:
                    SetFlag(hwnd, wParam, &bActivated);
                    break;
                case IDC_NOSIDGEN:
                    SetFlag(hwnd, wParam, &NoSidGen);
                    break;
                case IDC_SHUTDOWN:
                    if ( CBN_SELCHANGE == HIWORD(wParam) ) {
                        BOOL *lpbFlag;
                        
                        // Reset all flags to false first.
                        //
                        ForceShutdown = Reboot = NoReboot = FALSE;
                        
                        // lParam is the HWND of the ComboBox.
                        //
                        lpbFlag = (BOOL*) SendMessage((HWND) lParam, CB_GETITEMDATA, (SendMessage((HWND) lParam, CB_GETCURSEL, 0, 0)), 0);

                        // Set the flag associated with this choice.
                        //
                        if ( ((INT_PTR) lpbFlag != CB_ERR) && lpbFlag )
                        {
                            *lpbFlag = TRUE;
                        }
                    }
                    break;
                default:
                    break;
            }
            break;
            
        default:
            break;
   }

   return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// Shutdown - resets the oemaudit.inf file sections and removes  
//               HKLM\Software\Microsoft\Windows\CurrentVersion\AuditMode
//
BOOL FShutdown()
{
    BOOL        fReturn = TRUE;

    // Launch sysprep to reseal the machine
    //
    if (!(fReturn = ResealMachine()))
        LogFileStr(g_szLogFile, _T("SYSPREP: Shutdown could not reseal the machine!\r\n"));
   
    return fReturn;
}

//////////////////////////////////////////////////////////////////////////////
// FlushAndDisableRegistry - flushes registry keys
//
void FlushAndDisableRegistry()
{
    RegFlushKey(HKEY_LOCAL_MACHINE);
    RegFlushKey(HKEY_USERS);
}

//////////////////////////////////////////////////////////////////////////////
// uiDialogTopRight - this was copied over from SETUPX.DLL
//
void uiDialogTopRight(HWND hwndDlg)
{
    RECT        rc;
    int         cxDlg;
    int         cxScreen = GetSystemMetrics( SM_CXSCREEN );

    GetWindowRect(hwndDlg,&rc);
    cxDlg = rc.right - rc.left;

    // Position the dialog.    
    //
    SetWindowPos(hwndDlg, NULL, cxScreen - cxDlg, 8, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
}

//////////////////////////////////////////////////////////////////////////////
// ParseRegistrySwitches - checks the registry for oemreset switches
//
TCHAR* ParseRegistrySwitches()
{
    static TCHAR szCmdLineArgs[MAX_PATH] = _T("");
    HKEY hKey = 0;
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, &hKey) == ERROR_SUCCESS)
    {
        DWORD dwSize = MAX_PATH;
        RegQueryValueEx(hKey, REGSTR_VAL_OEMRESETSWITCH, 0L, NULL, (LPBYTE)szCmdLineArgs, &dwSize);
        RegSetValueEx(hKey, REGSTR_VAL_OEMRESETSWITCH, 0, REG_SZ, (LPBYTE)_T(""), sizeof(_T("")));
        RegCloseKey(hKey);
    }

    return szCmdLineArgs;
}

//////////////////////////////////////////////////////////////////////////////
// ParseCmdLineSwitches - this was copied over from OPKWIZ (JCOHEN)
//
BOOL ParseCmdLineSwitches(LPTSTR lpszCmdLineOrg)
{
    LPTSTR  lpLine = lpszCmdLineOrg,
            lpArg;
    TCHAR   szTmpBuf[MAX_PATH];
    INT     i;
    BOOL    bHandled= FALSE,
            bError  = FALSE,
            bLeftQ  = FALSE,
            bRegistry = FALSE;

    // If we have no command line, then return
    //
    if ( lpLine == NULL )
        return bHandled;

    // If empty command line, then try registry.
    //
    if ( *lpLine == NULLCHR )
    {
        lpLine = ParseRegistrySwitches();

        // If registry is empty then return not handled
        if (lpLine == NULL)
            return bHandled;
        
        // Registry switches don't have / or - and are separated by semi-colons
        bRegistry = TRUE;
    };

    // Loop through command line.
    //
    while ( *lpLine != NULLCHR )
    {
        // Move to first non-white TCHAR.
        //
        lpArg = lpLine;
        while ( isspace((int) *lpArg) )
            lpArg = CharNext (lpArg);

        if ( *lpArg ) 
        {
            // Move to next white TCHAR.
            //
            lpLine = lpArg;
            while ( ( *lpLine != NULLCHR ) && ( *lpLine != _T(';') ) && 
                    ( ( !bLeftQ && ( !isspace((int) *lpLine) ) ) ||
                    (  bLeftQ && ( *lpLine != _T('"') ) ) ) )
            {
                lpLine = CharNext (lpLine);
                if ( !bLeftQ && (*lpLine == _T('"')) )
                {
                    lpLine  = CharNext (lpLine);
                    bLeftQ = TRUE;
                }
            }

            // Copy arg to buffer.
            //
            i = (INT)(lpLine - lpArg + 1);  // +1 for NULL.
            lstrcpyn( szTmpBuf, lpArg, i );

            // Skip semi-colons
            if (bRegistry && *lpLine == _T(';'))
                lpLine = CharNext(lpLine);

            if ( bLeftQ )
            {
                lpLine  = CharNext (lpLine);  // skip the " from remander of command line.
                bLeftQ = FALSE;
            }

            // Command line comands starting with either '/' or '-' unless it's from 
            // the registry
            if ( !bRegistry && ( *szTmpBuf != _T('/') ) && ( *szTmpBuf != _T('-') ) )    
            {
                bError = TRUE;
                break;
            }
            else
            {
                // Skip pass '/' or '-' if not from registry
                TCHAR* pszSwitch = NULL;
                if (!bRegistry)
                    pszSwitch = CharNext(szTmpBuf);
                else 
                    pszSwitch = szTmpBuf;

                // Because we have switches that have multiple chars
                // I'm using an if/elseif otherwise I would use 
                // switch statements
                //
                if (_tcsicmp(pszSwitch, _T("R")) == 0)
                    gdwCmdlineFlags |= OEMRESET_AUDIT;
                else if ((_tcsicmp(pszSwitch, _T("AUTO")) == 0) || 
                    (_tcsicmp(pszSwitch, _T("A") ) == 0))
                    gdwCmdlineFlags |= OEMRESET_AUTO;
                else if (_tcsicmp(pszSwitch, _T("S")) == 0)
                    gdwCmdlineFlags |= OEMRESET_SHUTDOWN;   
                else if (_tcsicmp(pszSwitch, _T("L")) == 0)
                    gdwCmdlineFlags |= OEMRESET_LOG;
                else if (_tcsicmp(pszSwitch, _T("H")) == 0)
                    gdwCmdlineFlags |= OEMRESET_HIDE;
                else if (_tcsicmp(pszSwitch, _T("P")) == 0)
                    gdwCmdlineFlags |= OEMRESET_AUDITPD;
                else 
                    bError = TRUE;
            }
        }
        else 
            break;
    }    

    // If we hit an error, display the error and show the help.
    //
    if ( bError )
    {
        LPTSTR lpHelp = AllocateString(NULL, IDS_HELP);
        MsgBox(NULL, IDS_ERR_BADCMDLINE, IDS_APPNAME, MB_ERRORBOX, lpHelp ? lpHelp : NULLSTR);
        FREE(lpHelp);
        bHandled = TRUE;    // Exit the app if bad command line!
    }

    return bHandled;
}

//////////////////////////////////////////////////////////////////////////////
// MonitorKeyValueThread - we're monitoring the OEMReset_Switch in the registry
//                         
//
DWORD WINAPI MonitorKeyValueThread(LPVOID lpv)
{
    HKEY hKey;

    // Open the key we want to monitor
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, &hKey) == ERROR_SUCCESS)
    {
        do 
        {
            ParseCmdLineSwitches(_T(""));   // empty so it checks the registry
            HandleCommandSwitches();
        } while (ERROR_SUCCESS == RegNotifyChangeKeyValue(hKey, FALSE, REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET, 0, FALSE));

        RegCloseKey(hKey);
    }

    return 0;
}

//////////////////////////////////////////////////////////////////////////////
// Starts a thread to monitor a registry key for cmdline switches
//
void StartMonitorKeyValue()
{
    ghMonitorThread = CreateThread(NULL, 0, MonitorKeyValueThread, 0, 0, &gdwThreadID);
}

//////////////////////////////////////////////////////////////////////////////
// Processes the cmdline switches
//
static void HandleCommandSwitches()
{
    // Non-processing flags 1st
    if (gdwCmdlineFlags & OEMRESET_HIDE)
    {
        gbHide = TRUE;
    }
    if (gdwCmdlineFlags & OEMRESET_LOG)
    {
        gbLog = TRUE;
    }
     
    // Process switches precedence 2nd
    
    if (gdwCmdlineFlags & OEMRESET_SHUTDOWN)
    {
        if (FShutdown())                  // cleanup
            ShutdownOrReboot(EWX_SHUTDOWN, SYSPREP_SHUTDOWN_FLAGS); // Powers down using Enduser Path       
    }
    else if (gdwCmdlineFlags & OEMRESET_AUTO)
    {
        if (FShutdown())                  // cleanup
            ShutdownOrReboot(EWX_REBOOT, SYSPREP_SHUTDOWN_FLAGS);   // Reboots using Enduser Path   
    }
    else if (gdwCmdlineFlags & OEMRESET_AUDIT)
    {
        ShutdownOrReboot(EWX_REBOOT, SYSPREP_SHUTDOWN_FLAGS);   // Reboots using Audit Path   
    }
    else if (gdwCmdlineFlags & OEMRESET_AUDITPD)
    {
        ShutdownOrReboot(EWX_SHUTDOWN, SYSPREP_SHUTDOWN_FLAGS);   // Powers down using Audit Path    
    }
}

void ShowOemresetDialog(HINSTANCE hInstance)
{
    // First instance
    ghinstEXE = hInstance;

    // Set the error mode to avoid system error pop-ups.
    SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

    // Monitors a registry key for switches for Oemreset
    StartMonitorKeyValue();

    // Create our modeless dialog 
    if ((ghwndOemResetDlg = CreateOemResetDlg(hInstance)) != NULL)
    {
        MSG msg;
    
        // Hide ourself if needed and start a thread which 
        // monitors the reg key value
        if (gbHide)
        {
            ShowWindow(ghwndOemResetDlg, SW_HIDE);
        }

        // Message pump
        while (GetMessage(&msg, NULL, 0, 0)) 
        { 
            if (!IsWindow(ghwndOemResetDlg) || !IsDialogMessage(ghwndOemResetDlg, &msg)) 
            { 
                TranslateMessage(&msg);
                DispatchMessage(&msg); 
            } 
        } 
    }
    return;
}


// Make sure the user knows what he's doing with the Sids.
BOOL VerifySids()
{
    if ( RegExists(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGEN) )
    {
        if ( RegCheck(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGEN) )
        {
            if ( !NoSidGen )
            {
                return ( IDOK == MessageBoxFromMessage( MSG_DONT_GEN_SIDS, IDS_APPTITLE,
                    MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL | MB_DEFBUTTON2) );
            }
        }
        else 
        {
            if ( NoSidGen )
            {
                return ( IDOK == MessageBoxFromMessage( MSG_DO_GEN_SIDS, IDS_APPTITLE,
                    MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL | MB_DEFBUTTON2) );
            }
            
        }
    }
    else if ( !NoSidGen ) // If sids have never been regenerated.
    {
        return ( IDOK == MessageBoxFromMessage( MSG_DONT_GEN_SIDS, IDS_APPTITLE,
            MB_OKCANCEL | MB_ICONEXCLAMATION | MB_TASKMODAL | MB_DEFBUTTON2) );
    }
    
    // If we fall through to here we must be ok.
    //
    return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sysprep\sysprep.h ===
// Registry constants
//
#define REGSTR_PATH_CURRENTVERSION          _T("Software\\Microsoft\\Windows\\CurrentVersion")
#define REGSTR_PATH_CURRENTVERSION_SETUP    REGSTR_PATH_CURRENTVERSION _T("\\Setup")
#define REGSTR_PATH_SYSTEM_SETUP            _T("System\\Setup")
#define REGSTR_VALUE_AUDIT                  _T("AuditInProgress")
#define REGSTR_VAL_OEMRESET                 _T("OEMReset")
#define REGSTR_VAL_OEMCLEANUP               _T("OEMCLEANUP")
#define REGSTR_VAL_OEMRESETSWITCH           _T("OEMReset_Switch")
#define REGSTR_VAL_MASS_STORAGE             _T("CriticalDevicesInstalled")
#define REGSTR_PATH_SYSPREP                 _T("Software\\Microsoft\\Sysprep")
#define REGSTR_VAL_SIDGEN                   _T("SidsGenerated")
#define REGSTR_VAL_SIDGENHISTORY            _T("SidsGeneratedHistory")
#define REGSTR_VAL_DISKSIG                  _T("BootDiskSig")



// INF constants
//
#define INF_SEC_AUDITING            _T("Auditing")          // Section in oemaudit.inf
#define INF_SEC_SYSTEM_RESTORE      _T("System_restore")    // Section processed in oemaudit.inf
#define INF_SEC_OEMRESET            _T("OEMRESET")          // Section in oemaudit.inf



// Global defines
//
#define SYSPREP_SHUTDOWN_FLAGS    SHTDN_REASON_FLAG_PLANNED | SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_INSTALLATION


// ============================================================================
// FUNCTION DECLARATIONS
// ============================================================================

BOOL
CheckParams(
    LPSTR lpCmdLine
    );

extern BOOL
NukeMruList(
    VOID
    );

extern BOOL
IsSetupClPresent(
    VOID
    );

extern BOOL
IsUserAdmin(
    VOID
    );

extern BOOL
CheckOSVersion(
    VOID
    );

extern BOOL
IsDomainMember(
    VOID
    );

extern BOOL
DoesUserHavePrivilege(
    PCTSTR
    );

extern BOOL
EnablePrivilege(
    IN PCTSTR,
    IN BOOL
    );

extern BOOL
FDoFactoryPreinstall(
    VOID
    );

extern VOID
ShowOemresetDialog(
    HINSTANCE
    );

BOOL 
ResealMachine(
    VOID
    );

BOOL 
FPrepareMachine(
    VOID
    );


BOOL LockApplication(
    BOOL
    );

VOID
ShutdownOrReboot(
    UINT uFlags,
    DWORD dwReserved
    );

VOID 
SysprepShutdown();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\opktools\sysprep\sysprep.c ===
/*++

File Description:

    This file contains all the functions required to add a registry entry
    to force execution of the system clone worker upon reboot.

--*/

#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntpoapi.h>
#include <ntdddisk.h>
#include <windows.h>
#include <shlwapi.h>
#include <stdlib.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <regstr.h>
#include "sysprep.h"
#include "msg.h"
#include "resource.h"
#include <tchar.h>
#include <opklib.h>
#include <ntverp.h>
#include <spsyslib.h>
#include <sysprep_.c>
#include <winbom.h>


// External functions
//
extern void uiDialogTopRight(HWND hwndDlg);
extern HWND ghwndOemResetDlg;


                            //
                            // Does the user want a new SID?
                            //
BOOL    NoSidGen = FALSE;
BOOL    SetupClPresent = TRUE;

                            //
                            // Does the user want confirmation?
                            //
BOOL    QuietMode = FALSE;

                            //
                            // Do PnP re-enumeration?
                            //
BOOL    PnP = FALSE;

                            //
                            // Do we shutdown when we're done?
                            //
BOOL    NoReboot = FALSE;

                            //
                            // Instead of shutting down, do we reboot?
                            //
BOOL    Reboot = FALSE;

                            //
                            // Clean out the critical devices database?
                            //
BOOL    Clean = FALSE;

                            //
                            // Force the shutdown instead of trying to poweroff?
                            //
BOOL    ForceShutdown = FALSE;

                            //
                            // Generating an Image for Factory Preinstallation.
                            //
BOOL    Factory = FALSE;

                            //
                            // Reseal a machine after running FACTORY.EXE
                            //
BOOL    Reseal = FALSE;
                            // Per/Pro SKUs defaults to OOBE, Server SKUs always use MiniSetup.
                            // Pro SKU can override OOBE with -mini to use MiniSetup also 
                            // via sysprep.inf
BOOL    bMiniSetup = FALSE;

                            //
                            // Just do an audit boot if this switch is passed in. ( '-audit' )
                            //

BOOL    Audit = FALSE;
                            // 
                            // Rollback 
                            // 
BOOL    bActivated = FALSE;   

                            //
                            // Build list of pnpids in [sysprepmassstorage] section in sysprep.inf
                            //
BOOL    BuildMSD = FALSE;


//
// Internal Define(s):
//
#define SYSPREP_LOG                 _T("SYSPREP.LOG")   // Sysprep log file
#define SYSPREP_MUTEX               _T("SYSPREP-APP-5c9fbbd0-ee0e-11d2-9a21-0000f81edacc")    // GUID used to determine if sysprep is currently running
#define SYSPREP_LOCK_SLEEP          100 // Number of miliseconds to sleep in LockApplication function
#define SYSPREP_LOCK_SLEEP_COUNT    10 // Number of times to sleep during LockApplication function

// Path to the sysprep directory.
//
TCHAR       g_szSysprepDir[MAX_PATH]    = NULLSTR;

// Path to the SYSPREP.EXE.
//
TCHAR       g_szSysprepPath[MAX_PATH]    = NULLSTR;

// Path to the Sysprep log file.
//
TCHAR       g_szLogFile[MAX_PATH]       = NULLSTR;

// Path to the Winbom file.
//
TCHAR       g_szWinBOMPath[MAX_PATH]    = NULLSTR;

// Public functions
//
BOOL FProcessSwitches();

// Local functions
static BOOL RenameWinbom();
static INT  CleanupPhantomDevices();
static VOID CleanUpDevices();

#if !defined(_WIN64)
static BOOL SaveDiskSignature();
#endif // !defined(_WIN64)


//
// UI stuff...
//
HINSTANCE   ghInstance;
UINT        AppTitleStringId = IDS_APPTITLE;
HANDLE      ghWaitEvent = NULL, ghWaitThread = NULL;
BOOL        gbScreenSaver = FALSE;

void StartWaitThread();
void EndWaitThread();
void DisableScreenSaver(BOOL *pScreenSaver);
void EnableScreenSaver(BOOL *pScreenSaver);

int
MessageBoxFromMessageV(
    IN DWORD    MessageId,
    IN DWORD    CaptionStringId,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR   Caption[512];
    TCHAR   Buffer[5000];
    
    if(!LoadString(ghInstance,CaptionStringId,Caption,sizeof(Caption)/sizeof(TCHAR))) {
        Caption[0] = 0;
    }

    if( !FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                        ghInstance,
                        MessageId,
                        0,
                        Buffer,
                        sizeof(Buffer) / sizeof(TCHAR),
                        Args ) ) {
        return GetLastError();
    } else {
        return(MessageBox(NULL,Buffer,Caption,Style));
    }
}


int
MessageBoxFromMessage(
    IN DWORD MessageId,
    IN DWORD CaptionStringId,
    IN UINT  Style,
    ...
    )
{
    va_list arglist;
    int i = IDOK;  // Default return value of "OK".

    // If we're in the middle of a Wait thread kill it
    //
    EndWaitThread();

    if ( !QuietMode )
    {
        va_start(arglist,Style);

        i = MessageBoxFromMessageV(MessageId,CaptionStringId,Style,&arglist);

        va_end(arglist);
    }

    return(i);
}

/*++
===============================================================================
Routine Description:

    This routine will attempt to disjoin a user from a domain, if he
    is already in a domain

Arguments:

    none

Return Value:

    TRUE - Everything is okay.

    FALSE - Something bad happened.

===============================================================================
--*/
BOOL UnjoinNetworkDomain
(
    void
)
{
    if (IsDomainMember())
    {
        // He's a member of some domain.  Let's try and remove him
        // from the domain.
        if (NO_ERROR != NetUnjoinDomain( NULL, NULL, NULL, 0 ))
        {
            return FALSE;
        }
    }
    return TRUE;
}


/*++
===============================================================================
Routine Description:

    This routine will setup the setup for operation on the "factory floor"
    The purpose here is to run a process which will facilitate the installation
    of updated drivers for new devices, and to boot quickly into full GUI mode
    for application pre-install/config, as well as to customize the system.

Arguments:

    none

Return Value:

    TRUE if no errors, FALSE otherise

===============================================================================
--*/
BOOL SetupForFactoryFloor
(
    void
)
{
    TCHAR   szFactory[MAX_PATH] = NULLSTR,
            szSysprep[MAX_PATH] = NULLSTR,
            szSystem[MAX_PATH]  = NULLSTR;
    LPTSTR  lpFilePart          = NULLSTR;

    // Make sure we have the right privileges
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    // We need the path to sysprep.exe and factory.exe.
    //
    if ( !( GetModuleFileName(NULL, szSysprep, AS(szSysprep)) && szSysprep[0] &&
            GetFullPathName(szSysprep, AS(szFactory), szFactory, &lpFilePart) && szFactory[0] && lpFilePart ) )
    {
        return FALSE;
    }

    // Replace the sysprep.exe filename with factory.exe.
    //
    StringCchCopy ( lpFilePart, AS ( szFactory ) - ( lpFilePart - szFactory ), TEXT( "factory.exe" ) );
    
    // Make sure that sysprep.exe and factory.exe are on the system drive.
    //
    if ( ( ExpandEnvironmentStrings(TEXT("%SystemDrive%"), szSystem, AS(szSystem)) ) &&
         ( szSystem[0] ) &&
         ( szSystem[0] != szSysprep[0] ) )
    {
        // Well that sucks, we should try and copy the files over to the %SystemDrive%\sysprep folder.
        //
        AddPath(szSystem, TEXT("sysprep"));
        lpFilePart = szSystem + lstrlen(szSystem);
        CreateDirectory(szSystem, NULL);

        // First copy factory locally.
        //
        AddPath(szSystem, TEXT("factory.exe"));
        CopyFile(szFactory, szSystem, FALSE);
        StringCchCopy ( szFactory, AS ( szFactory ), szSystem );

        // Now try to copy sysprep.exe.
        //
        *lpFilePart = TEXT('\0');
        AddPath(szSystem, TEXT("sysprep.exe"));
        CopyFile(szSysprep, szSystem, FALSE);
        //lstrcpy(szSysprep, szSystem);
    }

    if (!SetFactoryStartup(szFactory))
        return FALSE;

    // Clear out any previous Factory.exe state settings
    RegDeleteKey(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Factory\\State");

    // Remove any setting before Factory
    //
    NukeMruList();  

    // Rearm 
    //
    if (!IsIA64() && !bActivated && (ERROR_SUCCESS != ReArm())) {
        // Display warning that grace period limit has reached and cannot
        // re-active grace period, and we continue thru.
        //
        MessageBoxFromMessage( MSG_REARM_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );        
    }

    return TRUE;
}

INT_PTR WaitDlgProc
(
    IN HWND   hwndDlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
{
    switch (msg) 
    { 
        case WM_INITDIALOG: 
            {
                // Centers the wait dialog in parent or screen
                //
                HWND hwndParent = GetParent(hwndDlg);
                CenterDialogEx(hwndParent, hwndDlg);

                // If no parent then make sure this is visible
                //
                if (hwndParent == NULL)
                    SetForegroundWindow(hwndDlg);

                // Play the animation 
                //
                Animate_Open(GetDlgItem(hwndDlg,IDC_ANIMATE),MAKEINTRESOURCE(IDA_CLOCK_AVI));
                Animate_Play(GetDlgItem(hwndDlg,IDC_ANIMATE),0,-1,-1);
            }
            break;
             
    } 
    return (BOOL) FALSE; 
}

DWORD WaitThread(LPVOID lpVoid)
{
    HWND hwnd;

    if ( hwnd = CreateDialog(ghInstance, MAKEINTRESOURCE(IDD_WAIT), ghwndOemResetDlg, (DLGPROC) WaitDlgProc) )
    {
        MSG     msg;
        HANDLE  hEvent = (HANDLE) lpVoid;

        ShowWindow(hwnd, SW_SHOWNORMAL);
        while ( MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT) == (WAIT_OBJECT_0 + 1) )
        {
            while ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }

        DestroyWindow(hwnd);
    }
    else 
        GetLastError();

    return 0;
}

void StartWaitThread()
{
    // Create a dialog to show progress is being made.
    //
    DWORD dwThread;

    // Disable the toplevel Oemreset dialog
    //
    if (ghwndOemResetDlg)
        EnableWindow(ghwndOemResetDlg, FALSE);

    if ( ghWaitEvent = CreateEvent(NULL, TRUE, FALSE, TEXT("SYSPREP_EVENT_WAIT")))
        ghWaitThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) WaitThread, (LPVOID) ghWaitEvent, 0, &dwThread);
}

void EndWaitThread()
{
    // Kill the Status Dialog.
    //
    if ( ghWaitEvent )
        SetEvent(ghWaitEvent);

    // Try and let the thread terminate nicely.
    //
    if ( ghWaitThread )
        WaitForSingleObject(ghWaitThread, 2000);

    // Clear the handles
    //
    ghWaitEvent = NULL;
    ghWaitThread = NULL;

    // Enable the toplevel OemReset dialog
    //
    if (ghwndOemResetDlg)
        EnableWindow(ghwndOemResetDlg, TRUE);
}

/*++
===============================================================================
Routine Description:

    This is the error callback handler for SetDefaultOEMApps()

===============================================================================
--*/

void ReportSetDefaultOEMAppsError(LPCTSTR pszAppName, LPCTSTR pszIniVar)
{
    MessageBoxFromMessage( MSG_SETDEFAULTS_NOTFOUND,
                           AppTitleStringId,
                           MB_OK | MB_ICONERROR | MB_TASKMODAL,
                           pszAppName, pszIniVar);
}

/*++
===============================================================================
Routine Description:

    This routine will perform the tasks necessary to reseal the machine,
    readying it to be shipped to the end user.

Arguments:

    BOOL fIgnoreFactory - ignores if factory floor was run

Return Value:

    TRUE if no errors, FALSE otherwise

===============================================================================
--*/
BOOL ResealMachine
(
    void
)
{
    // Make sure privileges have been set
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);
   
    // Prepare the machine to be hardware independent.
    //
    if (!FPrepareMachine()) {
        MessageBoxFromMessage( MSG_REGISTRY_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
        return FALSE;
    }


    //
    // Cleanup registry no matter what since factorymode=yes can set this
    // and winbom.ini can set this and sysprep -factory can set this, or else
    // PnP will hang on FactoryPreInstallInProgress being set.
    //
    CleanupRegistry();

    // Clean up the factory mess.
    //
    RegDelete(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", L"AutoAdminLogon");
    SHDeleteKey(HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\Factory");

    // Rearm 
    //
    if (!IsIA64() && !bActivated && (ERROR_SUCCESS != ReArm())) {
        // Display warning that grace period limit has reached and cannot
        // re-active grace period, and we continue thru.
        //
        MessageBoxFromMessage( MSG_REARM_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );        
    }

#if defined(_WIN64)

    //
    // For EFI machines set the boot timeout to 5 seconds so that developers get a chance to see
    // the boot menu and have the option to boot to the EFI shell, CD, or other menu options,
    // for development purposes.
    //
    ChangeBootTimeout(5);

#else

    ChangeBootTimeout(0);           // reset the timeout to 0 secs   

#endif // !defined(_WIN64)

    
    // 
    // First part of reseal.
    //
    AdjustFiles();

    //
    // Second part of reseal.
    //
    // This is common reseal code used by both Riprep and Sysprep.
    // These happen whether or not factory floor was run before.
    //
    if (!FCommonReseal()) {
        MessageBoxFromMessage( MSG_COMMON_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
        return FALSE;
    }

    // ISSUE-2000/06/06-DONALDM
    // We need to handle the network configuration problem for factory more cleanly
    // We need to define what the network state is when factory first comes up, and
    // what the network state is for final customer delivery. Simply disjoining from
    // a domain during reseal is probably not enough...
    //
    
//    if( !UnjoinNetworkDomain()) 
//    {
//        //  We failed to disjoin.  Our only option is to
//        // inform the user and bail.
//        MessageBoxFromMessage( MSG_DOMAIN_INCOMPATIBILITY,
//                               AppTitleStringId,
//                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );
//        return FALSE;                               
//    }

    //
    //  Set default middleware applications.
    //
    if (!SetDefaultOEMApps(g_szWinBOMPath))
    {
        // SetDefaultApplications will do its own MessageBoxFromMessage
        // with more detailed information
        return FALSE;
    }

    // Call functions in published SYSPREP_.C file that we skiped when the
    // FACTORY option was selected
  
    // ISSUE-2000/06/05-DONALDM - We need to really decide about how to handle network settings for
    // the factory case. I think we don't need this call, becase we should have 
    // already dealt with networking settings when FACTORY.EXE ran.
    // 
      
//    RemoveNetworkSettings(NULL);

    return TRUE;
}

// Macro for processing command line options.
// Setting bVar to 1 (not to 'TRUE') because we need it for mutually exclusive option checks below.
//
#define CHECK_PARAM(lpCmdLine, lpOption, bVar)     if ( LSTRCMPI(lpCmdLine, lpOption) == 0 ) bVar = 1

//
// Parse command line parameters
//
static BOOL ParseCmdLine()
{
    DWORD   dwArgs;
    LPTSTR  *lpArgs;
    BOOL    bError = FALSE;
    BOOL    bHelp = FALSE;

    if ( (dwArgs = GetCommandLineArgs(&lpArgs) ) && lpArgs )
    {
        LPTSTR  lpArg;
        DWORD   dwArg;

        // We want to skip over the first argument (it is the path
        // to the command being executed.
        //
        if ( dwArgs > 1 )
        {
            dwArg = 1;
            lpArg = *(lpArgs + dwArg);
        }
        else
            lpArg = NULL;

        // Loop through all the arguments.
        //
        while ( lpArg && !bError )
        {
            // Now we check to see if the first char is a dash or forward slash.
            //
            if ( *lpArg == _T('-') || *lpArg == _T('/'))
            {
                LPTSTR lpOption = CharNext(lpArg);

                // This is where you add command line options that start with a dash (-).
                //
                CHECK_PARAM( lpOption, _T("quiet"), QuietMode);
                CHECK_PARAM( lpOption, _T("nosidgen"), NoSidGen);
                CHECK_PARAM( lpOption, _T("pnp"), PnP);
                CHECK_PARAM( lpOption, _T("noreboot"), NoReboot);
                CHECK_PARAM( lpOption, _T("reboot"), Reboot);
                CHECK_PARAM( lpOption, _T("clean"), Clean);
                CHECK_PARAM( lpOption, _T("forceshutdown"), ForceShutdown);
                CHECK_PARAM( lpOption, _T("factory"), Factory);
                CHECK_PARAM( lpOption, _T("reseal"), Reseal);
                CHECK_PARAM( lpOption, _T("mini"), bMiniSetup);
                CHECK_PARAM( lpOption, _T("audit"), Audit);
                CHECK_PARAM( lpOption, _T("activated"), bActivated);
                CHECK_PARAM( lpOption, _T("bmsd"), BuildMSD);
                CHECK_PARAM( lpOption, _T("?"), bHelp);
            }
            else if ( *lpArg )
            {
                bError = TRUE;
            }

            // Setup the pointer to the next argument in the command line.
            //
            if ( ++dwArg < dwArgs )
                lpArg = *(lpArgs + dwArg);
            else
                lpArg = NULL;
        }

        // Make sure to free the two buffers allocated by the GetCommandLineArgs() function.
        //
        FREE(*lpArgs);
        FREE(lpArgs);
    }
     
    if (bError || bHelp)
    {
        // Set the quiet switch in this case so we display the error.
        // Note that we return FALSE and exit the application following this.
        //
        QuietMode = FALSE;
        MessageBoxFromMessage( MSG_USAGE,
                               AppTitleStringId,
                               MB_OK | MB_TASKMODAL );
        return FALSE;
    }    

    //
    // Now look at the switches passed in and make sure that they are consistent.
    // If they are not, display an error message and quit, unless we're in quiet 
    // mode where we do not display any error messages.
    //

    //
    // Check that the shutdown options are not conflicting with each other.
    if ( (NoReboot + Reboot + ForceShutdown) > 1 )
    {
        bError = TRUE;
    }
    // These top-level options are exclusive: -bmsd, -clean, -audit, -factory, -reseal.
    //
    else if ( (BuildMSD + Clean + Audit + Factory + Reseal) > 1 )
    {
        bError = TRUE;
    }
    // For Clean or BuildMSD none of the options except -quiet are valid.
    //
    else if ( Clean || BuildMSD )
    {
        if ( NoSidGen || PnP || NoReboot || Reboot || ForceShutdown || bMiniSetup || bActivated ) 
        {
            bError = TRUE;
        }
    }
    else if ( Audit )
    {
        if ( NoSidGen || PnP || bMiniSetup || bActivated )
        {
            bError = TRUE;
        }
    }
    else if ( Factory )
    {
        if ( PnP || bMiniSetup )
        {
            bError = TRUE;
        }
    }
    else if ( Reseal )
    {
        // If -pnp is specified -mini must have been specified unless we're running on server or ia64 (because
        // later we force bMiniSetup to be true on server and ia64.
        // 
        if ( PnP && !bMiniSetup && !(IsServerSKU() || IsIA64()) )
        {
            bError = TRUE;
        }
    }

    // If there was some inconsistency in the switches specified put up 
    // an error message.
    if ( bError )
    {
        // Reset the quiet switch in this case so we display the error.
        // Note that we return FALSE and exit the application following this.
        //
        QuietMode = FALSE;
        MessageBoxFromMessage( MSG_USAGE_COMBINATIONS,
                               AppTitleStringId,
                               MB_OK | MB_TASKMODAL | MB_ICONERROR);
        return FALSE;
    }
    // Force MiniSetup on IA64 and Servers.
    //
    if (IsIA64() || IsServerSKU())
    {
        bMiniSetup = TRUE;
    }
    else if ( IsPersonalSKU() )
    {
        if ( bMiniSetup )
        {
            // Can't specify mini-setup for personal sku
            //
            MessageBoxFromMessage( MSG_NO_MINISETUP,
                                   AppTitleStringId,
                                   MB_OK | MB_ICONERROR | MB_TASKMODAL );
            
            bMiniSetup = FALSE;
        }

        if ( PnP )
        {
            // Can't specify -pnp because we're not running mini-setup on personal sku.
            //
            MessageBoxFromMessage( MSG_NO_PNP,
                                   AppTitleStringId,
                                   MB_OK | MB_ICONERROR | MB_TASKMODAL );
            PnP = FALSE;
        }        
    }
    
    //
    // If we're cleaning up the critical device database,
    // then we'll be wanting to set some additional flags.
    //
    if (Clean || BuildMSD)
    {
        QuietMode = TRUE;
        NoReboot = TRUE;
    }
    return !bError;
}


BOOL
IsFactoryPresent(
    VOID
    )

/*++
===============================================================================
Routine Description:

    This routine tests to see if FACTORY.EXE is present on the machine.
    FACTORY.EXE will be required to run on reboot, so if it's not here,
    we need to know.

Arguments:

    None.

Return Value:

    TRUE - FACTORY.EXE is present.

    FALSE - FACTORY.EXE is not present.

===============================================================================
--*/

{
WCHAR               FileName[MAX_PATH];

    // Attempt to locate FACTORY.EXE
    //
    if (GetModuleFileName(NULL, FileName, MAX_PATH)) {
        if (PathRemoveFileSpec(FileName)) {
            OPKAddPathN(FileName, TEXT("FACTORY.EXE"), AS ( FileName ));
            if (FileExists(FileName))
                return TRUE;
        }
    }
    return FALSE;
}

void PowerOff(BOOL fForceShutdown)
{
    SYSTEM_POWER_CAPABILITIES   spc;
    ULONG                       uiFlags = EWX_POWEROFF;

    ZeroMemory(&spc, sizeof(spc));

    // Make sure we have privilege to shutdown
    //
    pSetupEnablePrivilege(SE_SHUTDOWN_NAME,TRUE);

    //
    // Use flag else query system for power capabilities
    //
    if (fForceShutdown)
        uiFlags = EWX_SHUTDOWN;
    else if (NT_SUCCESS(NtPowerInformation(SystemPowerCapabilities,
                                     NULL,
                                     0,
                                     &spc,
                                     sizeof(spc))))
    {
        //
        // spc.SystemS1 == sleep 1
        // spc.SystemS2 == sleep 2
        // spc.SystemS3 == sleep 3 
        // spc.SystemS4 == hibernate support
        // spc.SystemS5 == poweroff support
        //
        if (spc.SystemS5)
        {
            // ACPI capable
            uiFlags = EWX_POWEROFF;
        }
        else
        {
            // Non-ACPI 
            uiFlags = EWX_SHUTDOWN;
        }   
    }

    ExitWindowsEx(uiFlags|EWX_FORCE, SYSPREP_SHUTDOWN_FLAGS);
}

int APIENTRY WinMain( HINSTANCE hInstance,
                      HINSTANCE hPrevInstance,
                      LPSTR lpCmdLine,
                      int nCmdShow )
/*++
===============================================================================
Routine Description:

    This routine is the main entry point for the program.

    We do a bit of error checking, then, if all goes well, we update the
    registry to enable execution of our second half.

===============================================================================
--*/

{
    DWORD   dwVal;
    HKEY    hKey;
    LPTSTR  lpFilePart  = NULL;
    INITCOMMONCONTROLSEX icex;
    LPTSTR  lpAppName = NULL;

    ghInstance = hInstance;

    SetErrorMode(SEM_FAILCRITICALERRORS);

    memset(&icex, 0, sizeof(icex));
    icex.dwSize = sizeof(icex);
    icex.dwICC = ICC_PROGRESS_CLASS|ICC_ANIMATE_CLASS;
    InitCommonControlsEx(&icex);
    
    // We need the path to sysprep.exe and where it is located.
    //
    GetModuleFileName(NULL, g_szSysprepPath, AS(g_szSysprepPath));
    if ( GetFullPathName(g_szSysprepPath, AS(g_szSysprepDir), g_szSysprepDir, &lpFilePart) && g_szSysprepDir[0] && lpFilePart )
    {
        // Chop off the file name.
        //
        *lpFilePart = NULLCHR;
    }

    // If either of those file, we must quit (can't imagine that every happening).
    //
    if ( ( g_szSysprepPath[0] == NULLCHR ) || ( g_szSysprepDir[0] == NULLCHR ) )
    {
        // TODO:  Log this failure.
        //
        // LogFile(WINBOM_LOGFILE, _T("\n"));
        return 0;
    }

    // Need the full path to the log file.
    //    
    StringCchCopy ( g_szLogFile, AS ( g_szLogFile ), g_szSysprepDir);
    AddPath(g_szLogFile, SYSPREP_LOG);

    // Attempt to aquire a lock on the application
    //
    if ( !LockApplication(TRUE) )
    {
        // Let the user know that we are busy
        //

        MessageBoxFromMessage( MSG_ALREADY_RUNNING,
                               AppTitleStringId,
                               MB_OK | MB_ICONINFORMATION | MB_SYSTEMMODAL );
        return 0;

    }

    //
    // Check to see if we are allowed to run on this build of the OS
    //
    if ( !OpklibCheckVersion( VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE ) )
    {
        MessageBoxFromMessage( MSG_NOT_ALLOWED,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_SYSTEMMODAL );
        return 0;
    }
        
    // Ensure that the user has privilege/access to run this app.
    if(!pSetupIsUserAdmin()
        || !pSetupDoesUserHavePrivilege(SE_SHUTDOWN_NAME)
        || !pSetupDoesUserHavePrivilege(SE_BACKUP_NAME)
        || !pSetupDoesUserHavePrivilege(SE_RESTORE_NAME)
        || !pSetupDoesUserHavePrivilege(SE_SYSTEM_ENVIRONMENT_NAME))
    {

        MessageBoxFromMessage( MSG_NOT_AN_ADMINISTRATOR,
                               AppTitleStringId,
                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );

        LockApplication(FALSE);
        return 0;
    }

    // Check the command line
    if( !ParseCmdLine() )
    {
        LockApplication(FALSE);
        return 0;
    }

    // Determines whether we can run SidGen. If not quit the application
    // 
    // Make sure setupcl.exe is present in the system32 directory, if we need
    // to use it.
    if( !(SetupClPresent = IsSetupClPresent()) && !NoSidGen )
    {
        MessageBoxFromMessage( MSG_NO_SUPPORT,
                               AppTitleStringId,
                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );

        LockApplication(FALSE);
        return 1;
    }

    // Put up a dialog to identify ourselves and make sure the user
    // really wants to do this.
    
    if ( IDCANCEL == MessageBoxFromMessage( MSG_IDENTIFY_SYSPREP,
                                           AppTitleStringId,
                                           MB_OKCANCEL| MB_ICONEXCLAMATION | MB_SYSTEMMODAL )
       )
    {
        LockApplication(FALSE);
        return 0;
    }

    // Allocate memory for window
    //    
    if ( (lpAppName = AllocateString(NULL, IDS_APPNAME)) && *lpAppName )
    {
        ghwndOemResetDlg = FindWindow(NULL, lpAppName);

        // Free up the allocated memory
        //
        FREE(lpAppName);
    }

    DisableScreenSaver(&gbScreenSaver);

    //
    // Call RenameWinbom() once to initialize it.  First time it is called it will check the factory 
    // state registry key for the current winbom.ini that we are using.  The second time it gets called it 
    // will actually perform the rename if necessary. Make sure that the first time this gets called 
    // for intialization it is before LocateWinBom() because LocateWinBom() populates the registry with 
    // the winbom it finds.
    //
    RenameWinbom();
    
    // Need full path to winbom too.  It is not an error if the file is
    // not found.  (It is optional.)
    //
    LocateWinBom(g_szWinBOMPath, AS(g_szWinBOMPath), g_szSysprepDir, INI_VAL_WBOM_TYPE_FACTORY, LOCATE_NORMAL);
    
    // Process switches
    //
    if ( !FProcessSwitches() && !ghwndOemResetDlg)
    {
        ShowOemresetDialog(hInstance); 
    }

    EnableScreenSaver(&gbScreenSaver);

    // Unlock application and free up memory
    //
    LockApplication(FALSE);

    return 0;
}

// Factory Preinstall now also prepares the machine 
//
BOOL FDoFactoryPreinstall()
{
    HKEY  hKey;
    DWORD dwVal;

    if (!IsFactoryPresent()) {
        MessageBoxFromMessage( MSG_NO_FACTORYEXE,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );

        return FALSE;
    }

    // Setup factory.exe for factory floor
    //
    if (!SetupForFactoryFloor())
    {
        MessageBoxFromMessage( MSG_SETUPFACTORYFLOOR_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );

        return FALSE;
    }

    // Prepare machine to be hardware independent for factory floor 
    //
    if (!FPrepareMachine()) {
        MessageBoxFromMessage( MSG_REGISTRY_ERROR,
                               AppTitleStringId,
                               MB_OK | MB_ICONERROR | MB_TASKMODAL );
        return FALSE;
    }

    // Set the boot timeout for boot on factory floor
    if (!ChangeBootTimeout( 1 ))
        return FALSE;

    return TRUE;
}

// Prepares the machine to be hardware independent
// 
BOOL FPrepareMachine()
{
    TCHAR szSysprepInf[MAX_PATH] = TEXT("");

    //
    // Make sure we've got the required privileges to update the registry.
    //
    pSetupEnablePrivilege(SE_RESTORE_NAME,TRUE);
    pSetupEnablePrivilege(SE_BACKUP_NAME,TRUE);

    // Build path to sysprep.inf from where sysprep.exe is located
    //
    if (GetModuleFileName(NULL, szSysprepInf, MAX_PATH)) 
    {
        PathRemoveFileSpec(szSysprepInf);
        OPKAddPathN(szSysprepInf, TEXT("sysprep.inf"), AS ( szSysprepInf ) );
    }

    // Disable System Restore
    //
    DisableSR();

    // Make sure we're not a member of a domain.  If we are, then try and
    // force the unjoin.
    //
    
    if( !UnjoinNetworkDomain())
    {
        //  We failed to disjoin.  Our only option is to
        // inform the user and bail.
        MessageBoxFromMessage( MSG_DOMAIN_INCOMPATIBILITY,
                               AppTitleStringId,
                               MB_OK | MB_ICONSTOP | MB_TASKMODAL );
        return FALSE;
    }

#if !defined(_WIN64)
    // Set the boot disk signature in the registry.  The mount manager uses this
    // to avoid a PNP pop-up after imaging.
    //
    if ( !SaveDiskSignature() )
    {
        return FALSE;
    }
#endif // !defined(_WIN64)
    
    // Determine if we should set the BigLba support in registry
    //
    if ( !SetBigLbaSupport(szSysprepInf) )
    {
        return FALSE;
    }

    // Determine if we should remove the tapi settings
    //
    if ( !RemoveTapiSettings(szSysprepInf) )
    {
        return FALSE;
    }

    // Set OEMDuplicatorString
    if (!SetOEMDuplicatorString(szSysprepInf))
        return FALSE;


    // If we want to regenerate the SID's on the next boot do it.
    //
    if ( NoSidGen )
    {
        // Remember that we didn't generate SIDs
        //
        RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGEN, 0);
    }
    else
    {
        if ( PrepForSidGen() )
        {
            // Write out registry value so that we know that we've regenerated SIDs.
            //
            RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGEN, 1);

            // Set this registry key, only UpdateSecurityKeys can remove this key
            //
            RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_SIDGENHISTORY, 1);
            
        }
        else
        {
            return FALSE;
        }
    }

    // If Mass Storage Devices were installed, clean up the ones not being used.
    // Note: We only want to CleanUpDevices() if we are resealing. This is the equivalent of
    // automatically running "sysprep -clean" on reseal if we know that we need to do it.
    //
    if ( RegCheck(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE))
    {
        if ( Reseal )
        {
            // Clean the critical device database, since we might have put some
            // HDC and network drivers in there during factory floor from PopulateDeviceDatabase()
            CleanUpDevices();

            // Remove this key because we just ran CleanUpDevices().
            //
            RegDelete(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE);
        }
    }
    else 
    {   
        BOOL fPopulated = FALSE;

        // Set up Hardware independence for mass storage controllers.
        //
        BuildMassStorageSection(FALSE);
     
        if (!PopulateDeviceDatabase(&fPopulated))
            return FALSE;
    
        // Write out signature value to know that we have built the mass-storage section.
        //
        if ( fPopulated && !RegSetDword(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE, 1) ) 
                return FALSE;
    }

    // Remove network settings/card last so any errors during Device Database won't loose
    // networking.
    //
    if (!RemoveNetworkSettings(szSysprepInf))
        return FALSE;

    return TRUE;
}

// Reseal and Factory should behave the same according to the shutdown path.
// 
void DoShutdownTypes()
{
    pSetupEnablePrivilege(SE_SHUTDOWN_NAME,TRUE);

    if (Reboot) 
        ExitWindowsEx(EWX_REBOOT|EWX_FORCE, SYSPREP_SHUTDOWN_FLAGS);
    else if (NoReboot)
        PostQuitMessage(0);
    else 
        PowerOff(ForceShutdown); // Default
}

// Process action switches return TRUE if processed
//
BOOL FProcessSwitches()
{
    // There are currently 4 basic operating modes for SYSPREP:

    // 1) Factory floor mode. This mode is new for Whistler and will not completly
    // clone the system, but will prep the system for OEM factory floor installation
    // 2) Clean mode. In this mode, sysprep will clean up the critical device database
    // 3) Reseal mode. This is the complement to factory mode which will "complete" the
    // cloning process after factory floor mode has been used.
    // 4) "Audit" mode.  The system just executes an audit boot.  Used to restart the system
    // at the end of factory.exe processing.

    // These are just flags for reseal
    //
    if (Reseal)
    {
        StartWaitThread();
        // Ensure that we're running on the right OS.
        //
        if( !CheckOSVersion() )
        {
            MessageBoxFromMessage( MSG_OS_INCOMPATIBILITY,
                                   AppTitleStringId,
                                   MB_OK | MB_ICONSTOP | MB_TASKMODAL );
            return TRUE;
        }

        // Reseal the machine
        //
        if (!ResealMachine()) {
            MessageBoxFromMessage( MSG_RESEAL_ERROR,
                       AppTitleStringId,
                       MB_OK | MB_ICONSTOP | MB_TASKMODAL );

            return TRUE;

        }

        // Rename the current winbom so we don't use it again.
        //
        RenameWinbom();

        // Shutdown or reboot?
        DoShutdownTypes();

        EndWaitThread();
        return TRUE;
    }
    else if (Factory) 
    {
        StartWaitThread();

        // Set Factory to start on next boot and prepare for imaging
        //
        if (!FDoFactoryPreinstall()) 
            return TRUE;

        // Rename the current winbom so we don't use it again.
        //
        RenameWinbom();

        // Shutdown or reboot?
        DoShutdownTypes();

        EndWaitThread();

        return TRUE;
    }
    else if (Clean) 
    {
        CleanUpDevices();

        // Remove this key because we just ran CleanUpDevices().
        //
        RegDelete(HKLM, REGSTR_PATH_SYSPREP, REGSTR_VAL_MASS_STORAGE);
        return TRUE;
    }
    else if (Audit)
    {
        // Prepare for pseudo factory but get back to audit.
        //
       if ( RegCheck(HKLM, REGSTR_PATH_SYSTEM_SETUP, REGSTR_VALUE_AUDIT) )
       {
            TCHAR szFactoryPath[MAX_PATH] = NULLSTR;            
            // Going into Audit mode requires Factory.exe and winbom.ini
            // to exist.
            //
            if (FGetFactoryPath(szFactoryPath)) {
                SetFactoryStartup(szFactoryPath);
                DoShutdownTypes();
            }
            else {
                 LogFile(g_szLogFile, MSG_NO_FACTORYEXE);

                 MessageBoxFromMessage( MSG_NO_FACTORYEXE,
                                        IDS_APPTITLE,
                                        MB_OK | MB_ICONERROR | MB_TASKMODAL );
            }
       }
       else
       {
           LogFile(g_szLogFile, IDS_ERR_FACTORYMODE);
       }
       return TRUE;
    }
    else if (BuildMSD)
    {
        StartWaitThread();
        BuildMassStorageSection(TRUE /* Force build */);
        EndWaitThread();
        return TRUE;
    }
       
    // Return False to show the UI
    //
    Reseal = Factory = Clean = Audit = 0;
    return FALSE;
}


BOOL LockApplication(BOOL bState)
{
    static HANDLE hMutex;
    BOOL bReturn    = FALSE,
         bBail      = FALSE;
    DWORD dwSleepCount = 0;

    // We want to lock the application
    //
    if ( bState )
    {
        // Check to see if we can create the mutex and that the mutex did not
        // already exist
        //
        while ( !bReturn && (dwSleepCount < SYSPREP_LOCK_SLEEP_COUNT) && !bBail)
        {
            SetLastError(ERROR_SUCCESS);

            if ( hMutex = CreateMutex(NULL, FALSE, SYSPREP_MUTEX) )
            {
                if ( GetLastError() == ERROR_ALREADY_EXISTS )
                {
                    CloseHandle(hMutex);
                    hMutex = NULL;

                    dwSleepCount++;
                    Sleep(SYSPREP_LOCK_SLEEP);
                }
                else
                {
                    // Application successfully created lock
                    //
                    bReturn = TRUE;
                }
            }
            else
            {
                bBail = TRUE;
            }
        }
    }
    else if ( hMutex )
    {
        CloseHandle(hMutex);
        hMutex = NULL;
        bReturn = TRUE;
    }

    // Return whether or not the lock/unlock was successful
    //
    return bReturn;
}

//
// Shutdown or Reboot the machine
//
VOID ShutdownOrReboot(UINT uFlags, DWORD dwReserved)
{
    // Enable privileges for shutdown
    //
    EnablePrivilege(SE_SHUTDOWN_NAME, TRUE);

    // Shutdown or Reboot the machine
    //
    ExitWindowsEx(uFlags|EWX_FORCE, dwReserved);
}

// Remember the Screen Saver state and to disable it during Sysprep
//
void DisableScreenSaver(BOOL *pScreenSaver)
{
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, (PVOID)pScreenSaver, 0);
    if (*pScreenSaver == TRUE)
    {
        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, FALSE, 0, SPIF_SENDWININICHANGE); 
    }
}

// Remember the Screen Saver state and to re-enable it after Sysprep
//
void EnableScreenSaver(BOOL *pScreenSaver)
{
    if (*pScreenSaver == TRUE)
    {
        SystemParametersInfo(SPI_SETSCREENSAVEACTIVE, TRUE, 0, SPIF_SENDWININICHANGE); 
    }
}

// Rename the old winbom when going into factory or reseal so that we don't use it again by mistake.
static BOOL RenameWinbom()
{
    BOOL           bRet         = TRUE;
    static LPTSTR  lpszWinbom   = NULL;
    static BOOL    bInitialized = FALSE;

    if ( !bInitialized )
    {
        // Only bother to try if we are in audit mode and there
        // is a winbom in use.
        //
        if ( RegCheck(HKLM, _T("SYSTEM\\Setup"), _T("AuditInProgress")) )
        {
            lpszWinbom = RegGetExpand(HKLM, _T("SOFTWARE\\Microsoft\\Factory\\State"), _T("Winbom"));
        }
        
        bInitialized = TRUE;
    }
    else if ( lpszWinbom )
    {
        // Make sure the winbom in the registry exists.
        //
        if ( *lpszWinbom && FileExists(lpszWinbom) )
        {
            LPTSTR  lpszExtension;
            TCHAR   szBackup[MAX_PATH];
            DWORD   dwExtra;

            // At this point, if we don't rename the file then it
            // means there was an error.
            //
            bRet = FALSE;

            // Copy the full path to the winbom into our own buffer.
            //
            lstrcpyn(szBackup, lpszWinbom, AS(szBackup));

            // Get a pointer to the extension of the file name.
            //
            if ( lpszExtension = StrRChr(szBackup, NULL, _T('.')) )
            {
                // Set the extension pointer to after the '.' character.
                //
                lpszExtension = CharNext(lpszExtension);

                // See how many characters are in the current extension.
                //
                if ( (dwExtra = lstrlen(lpszExtension)) < 3 )
                {
                    // There is less then a 3 character extension, so
                    // we need some extra space for our 3 digit one.
                    //
                    dwExtra = 3 - dwExtra;
                }
                else
                {
                    // If there are already at least 3 characters in
                    // the exension, then no more space is required.
                    //
                    dwExtra = 0;
                }
            }
            else
            {
                // No extension, so we need 4 characters extra for
                // the '.' and the 3 digit extension.
                //
                dwExtra = 4;
            }

            // Make sure there is enough room for our extension to be
            // added to our buffer.
            //
            if ( ( lstrlen(lpszWinbom) < AS(szBackup) ) &&
                 ( lstrlen(szBackup) + dwExtra < AS(szBackup) ) )
            {
                DWORD dwNum = 0;

                // If there is no extension, add the dot.
                //
                if ( NULL == lpszExtension )
                {
                    // Add our '.' to the end of the string, and set the
                    // extension pointer past it.
                    //
                    lpszExtension = szBackup + lstrlen(szBackup);
                    *lpszExtension = _T('.');
                    lpszExtension = CharNext(lpszExtension);
                }

                // Try to find out new file name.  Keep increasing our
                // number from 000 until we find a name that doesn't exist.
                //
                do
                {
                    StringCchPrintf ( lpszExtension, AS ( szBackup ) - ( szBackup - lpszExtension), _T("%3.3d"), dwNum);
                }
                while ( ( FileExists(szBackup) ) &&
                        ( ++dwNum < 1000 ) );

                // If we found a name that doesn't exist, rename
                // the winbom.
                //
                if ( dwNum < 1000 )
                {
                    // If the move works, then return success.
                    //
                    bRet = MoveFile(lpszWinbom, szBackup);
                }
            }
        }

        // Free the buffer allocated.
        //
        FREE(lpszWinbom);
    }

    // Return TRUE if we didn't need to rename the winbom,
    // or we were able to do so successfully.
    //
    return bRet;
}

#if !defined(_WIN64)
  
static BOOL SaveDiskSignature()
{
    BOOL                bRet                = FALSE;
    WCHAR               szBuf[MAX_PATH]     = NULLSTR;
    HANDLE              hDisk;
    DWORD               dwBytesReturned     = 0;
    TCHAR               cDriveLetter;

    szBuf[0] = NULLCHR;
    if ( GetWindowsDirectory(szBuf, AS(szBuf)) && szBuf[0] )
    {
        // We only need the drive letter from this.
        cDriveLetter = szBuf[0];
        StringCchPrintf ( szBuf, AS ( szBuf ), _T("\\\\.\\%c:"), cDriveLetter);
    }
    else
    {
        return FALSE;
    }

    // Attempt to open the file
    //
    hDisk = CreateFile( szBuf,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

    // Check to see if we were able to open the disk
    //
    if ( INVALID_HANDLE_VALUE == hDisk )
    {
        bRet = FALSE;
        DbgPrint("SaveDiskSignature(): Unable to open file on %ws. Error (%lx)\n", szBuf, GetLastError());
    }
    else
    {
        PDRIVE_LAYOUT_INFORMATION_EX    pLayoutInfoEx   = NULL;
        ULONG                           lengthLayoutEx  = 0;
        
        DbgPrint("SaveDiskSignature(): Successfully opened file on %ws\n", szBuf);

        lengthLayoutEx = sizeof(DRIVE_LAYOUT_INFORMATION_EX) + (sizeof(PARTITION_INFORMATION_EX) * 128);
        pLayoutInfoEx = (PDRIVE_LAYOUT_INFORMATION_EX) MALLOC( lengthLayoutEx );
        
        if ( pLayoutInfoEx )
        {
            // Attempt to get the drive layout
            //
            bRet = DeviceIoControl( hDisk, 
                                    IOCTL_DISK_GET_DRIVE_LAYOUT_EX, 
                                    NULL, 
                                    0, 
                                    pLayoutInfoEx, 
                                    lengthLayoutEx, 
                                    &dwBytesReturned, 
                                    NULL
                                    );

            // Check the status of the drive layout
            //
            if ( bRet )
            {   // Only do this on MBR disks
                //
                if ( PARTITION_STYLE_MBR == pLayoutInfoEx->PartitionStyle )
                {
                    // Only set this value on MBR disks.
                    //
                    if ( !RegSetDword(HKEY_LOCAL_MACHINE, REGSTR_PATH_SYSTEM_SETUP, REGSTR_VAL_DISKSIG, pLayoutInfoEx->Mbr.Signature) )
                    {
                        DbgPrint("SaveDiskSignature(): Cannot write disk signature to registry\n.");
                        bRet = FALSE;
                    }
                }
                else
                {   // bRet = TRUE at this point.
                    DbgPrint("SaveDiskSignature(): Not supported on GPT disks.\n");
                }
            }
            else
            {
                DbgPrint("SaveDiskSignature(): Unable to open IOCTL on %ws. Error (%lx)\n", szBuf, GetLastError());
            }
            
            // Clean up. Macro checks for NULL;
            //
            FREE( pLayoutInfoEx );
        }
        else 
        {
            bRet = FALSE;
        }
    
        CloseHandle( hDisk );
    }
    return bRet;
}

#endif // !defined(_WIN64)


//
// Helper function for CleanupPhantomDevices.  Decides whether it is ok to remove 
// certain PNP devices.
//
BOOL
CanDeviceBeRemoved(
    HDEVINFO DeviceInfoSet,
    PSP_DEVINFO_DATA DeviceInfoData,
    PTSTR DeviceInstanceId
    )
{
    BOOL bCanBeRemoved = TRUE;

    if (_tcsicmp(DeviceInstanceId, TEXT("HTREE\\ROOT\\0")) == 0) {
        //
        // The device has the DeviceInstanceId of HTREE\ROOT\0 then it is the
        // root of the device tree and can NOT be removed!
        //
        bCanBeRemoved = FALSE;
    } else if (_tcsnicmp(DeviceInstanceId, TEXT("SW\\"), lstrlen(TEXT("SW\\"))) == 0) {
        //
        // If the DeviceInstanceId starts with SW\\ then it is a swenum (software
        // enumerated) device and should not be removed.
        //
        bCanBeRemoved = FALSE;
    } else if (IsEqualGUID(&(DeviceInfoData->ClassGuid), &GUID_DEVCLASS_LEGACYDRIVER)) {
        //
        // If the device is of class GUID_DEVCLASS_LEGACYDRIVER then do not 
        // uninstall it.
        //
        bCanBeRemoved = FALSE;
    }

    return bCanBeRemoved;
}


//
// Cleans up phantom PNP devices.  This is useful for cleaning up devices that existed
// on the machine that was imaged but do not exist on the target machine.
//
static INT
CleanupPhantomDevices(
    VOID
    )
{
    HDEVINFO DeviceInfoSet;
    HDEVINFO InterfaceDeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    SP_DEVICE_INTERFACE_DATA DeviceInterfaceData;
    INT DevicesRemoved = 0;
    INT MemberIndex, InterfaceMemberIndex;
    DWORD Status, Problem;
    CONFIGRET cr;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

    //
    // Get a list of all the devices on this machine, including present (live)
    // and not present (phantom) devices.
    //
    DeviceInfoSet = SetupDiGetClassDevs(NULL,
                                        NULL,
                                        NULL,
                                        DIGCF_ALLCLASSES
                                        );

    if (DeviceInfoSet != INVALID_HANDLE_VALUE) {

        DeviceInfoData.cbSize = sizeof(DeviceInfoData);
        MemberIndex = 0;

        //
        // Enumerate through the list of devices.
        //
        while (SetupDiEnumDeviceInfo(DeviceInfoSet,
                                     MemberIndex++,
                                     &DeviceInfoData
                                     )) {

            //
            // Check if this device is a Phantom
            //
            cr = CM_Get_DevNode_Status(&Status,
                                       &Problem,
                                       DeviceInfoData.DevInst,
                                       0
                                       );

            if ((cr == CR_NO_SUCH_DEVINST) ||
                (cr == CR_NO_SUCH_VALUE)) {

                //
                // This is a phantom.  Now get the DeviceInstanceId so we
                // can display/log this as output.
                //
                if (SetupDiGetDeviceInstanceId(DeviceInfoSet,
                                               &DeviceInfoData,
                                               DeviceInstanceId,
                                               sizeof(DeviceInstanceId)/sizeof(TCHAR),
                                               NULL)) {

                    if (CanDeviceBeRemoved(DeviceInfoSet,
                                           &DeviceInfoData,
                                           DeviceInstanceId)) {


#ifdef DEBUG_LOGLOG
                        LOG_Write(L"CLEANUP: %s will be removed.\n", DeviceInstanceId);
#endif
                        //
                        // Call DIF_REMOVE to remove the device's hardware
                        // and software registry keys.
                        //
                        if (SetupDiCallClassInstaller(DIF_REMOVE,
                                                      DeviceInfoSet,
                                                      &DeviceInfoData
                                                      )) {
                            DevicesRemoved++;
    
                        } else {
#ifdef DEBUG_LOGLOG
                            LOG_Write(L"CLEANUP: Error 0x%X removing phantom\n", GetLastError());
#endif
                        }
                    }
                }
            }
        }

        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
    }
    
    return DevicesRemoved;
}


// Cleans unused services and phantom PNP devices.
//
static VOID CleanUpDevices()
{
    // Cleanup the services that we installed in the [SysprepMassStorage] section.
    //
    CleanDeviceDatabase();
    
    // Cleanup phantom devices.
    //
    CleanupPhantomDevices();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\patchdll\nt_ob.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nt_obj.c

Abstract:

    1. Contains routines to access symbolic link objects

    2. Contains routines to convert between the DOS and ARC Name space

Author:

    Sunil Pai (sunilp) 20-Nov-1991

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include "rc_ids.h"
#include "patchdll.h"

#define BUFFER_SIZE      1024
#define SYMLINKTYPE      L"SymbolicLink"
#define ARCNAMEOBJDIR    L"\\ArcName"
#define DOSDEVOBJDIR     L"\\DosDevices"

extern CHAR ReturnTextBuffer[1024];

//
// Args[0]: $(SystemPartition)
// Args[1]: $(OsLoader)
// Args[2]: $(OsLoadPartition)
// Args[3]: $(OsLoadFilename)
// Args[4]: $(VolumeList)


BOOL
GetOsLoaderDest(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{

#if i386
    extern  WCHAR   x86DetermineSystemPartition(VOID);
            WCHAR   UnicodeDrive[4];
            CHAR    AnsiDrive[8];

    *TextOut = ReturnTextBuffer;
    SetReturnText("C:");
    UnicodeDrive[0] = x86DetermineSystemPartition();
    UnicodeDrive[1] = L':';
    UnicodeDrive[2] = L'\\';
    UnicodeDrive[3] = L'\0';

    if (WideCharToMultiByte(
        CP_ACP,
        0,
        UnicodeDrive,
        4,
        AnsiDrive,
        8,
        NULL,
        NULL) ) {

        SetReturnText(AnsiDrive);

    }
    return( TRUE );

#else

    RGSZ  rgszSystemPartition;
    RGSZ  rgszOsLoader;
    RGSZ  rgszOsLoadPartition;
    RGSZ  rgszOsLoadFilename;
    SZ    szOsLoader, szFileName, szDir;

    CHAR  szDrive[] = "?:";
    DWORD Disk;

    DWORD dwSystemPartition = 0;
    DWORD dwOsLoader = 0;
    DWORD dwOsLoadPartition = 0;
    DWORD dwOsLoadFilename = 0;

    CHAR  WindowsDirectory[MAX_PATH]  , ArcWindowsDirectory[MAX_PATH];
    CHAR  SystemPartition[MAX_PATH]   , ProcessedArcSysPart[MAX_PATH];
    CHAR  ArcForDosDrive[MAX_PATH]    , ProcessedArcForDosDrive[MAX_PATH];
    CHAR  OsLoaderDest[MAX_PATH];

    BOOL  Status = TRUE, Done, Found;



    *TextOut = ReturnTextBuffer;
    if(cArgs != 4) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    //
    // Find the windows directory
    //

    if( !GetWindowsDirectory( WindowsDirectory, MAX_PATH ) ) {
        SetErrorText(IDS_ERROR_GETWINDOWSDIR);
        return(FALSE);
    }

    //
    // Find the arcname for the windows dir
    //

    if (!DosPathToArcPathWorker( WindowsDirectory, ArcWindowsDirectory )) {
        return( FALSE );
    }

    //
    // Break all the lists into arrays
    //

    rgszSystemPartition = RgszFromSzListValue(Args[0]);
    rgszOsLoader        = RgszFromSzListValue(Args[1]);
    rgszOsLoadPartition = RgszFromSzListValue(Args[2]);
    rgszOsLoadFilename  = RgszFromSzListValue(Args[3]);

    if( !( rgszSystemPartition &&
           rgszOsLoader        &&
           rgszOsLoadPartition &&
           rgszOsLoadFilename
         )
      ) {

        Status = FALSE;
        SetErrorText(IDS_ERROR_DLLOOM);
        goto r0;
    }

    //
    // Go through the NVRAM Variables in tandem.  Note that the last one in
    // each list gets reused for the others.
    //

    // First ensure that atleast one component exists for each of the arc
    // boot vars

    if( rgszSystemPartition[0]  == NULL  ||
        rgszOsLoader[0]         == NULL  ||
        rgszOsLoadPartition[0]  == NULL  ||
        rgszOsLoadFilename[0]   == NULL
      ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_NONVRAMVARS);
        goto r0;
    }

    //
    // Pick up set by set till done
    //

    Found = FALSE;
    while( TRUE ) {

        CHAR ArcOsLoadWindowsDir[MAX_PATH];
        BOOL AnyAdvanced = FALSE;

        //
        // Combine the current OsLoadPartition with the OsLoadFilename
        // and compare it with the windows directory arc
        //

        strcpy( ArcOsLoadWindowsDir, rgszOsLoadPartition[dwOsLoadPartition] );
        strcat( ArcOsLoadWindowsDir, rgszOsLoadFilename[dwOsLoadFilename] );
        if( ArcOsLoadWindowsDir[lstrlen(ArcOsLoadWindowsDir) - 1] == '\\' ) {
            ArcOsLoadWindowsDir[lstrlen(ArcOsLoadWindowsDir) - 1] = '\0';
        }

        if( CompareArcNames( ArcOsLoadWindowsDir, ArcWindowsDirectory ) ) {
            Found = TRUE;
            break;
        }

        //
        // Advance to next step
        //

        if ( rgszSystemPartition[dwSystemPartition+1] ) { dwSystemPartition++ ; AnyAdvanced = TRUE ; }
        if ( rgszOsLoader[dwOsLoader+1]               ) { dwOsLoader++        ; AnyAdvanced = TRUE ; }
        if ( rgszOsLoadPartition[dwOsLoadPartition+1] ) { dwOsLoadPartition++ ; AnyAdvanced = TRUE ; }
        if ( rgszOsLoadFilename[dwOsLoadFilename+1]   ) { dwOsLoadFilename++  ; AnyAdvanced = TRUE ; }

        if ( !AnyAdvanced ) {
            break;
        }
    }

    if( !Found ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_OSLOADNOTFND);
        goto r0;
    }

    //
    // Set has been found, extract the osloader destination and the system
    // partition arc variables.
    //

    szOsLoader = rgszOsLoader[dwOsLoader];
    szFileName = strrchr( szOsLoader, '\\' );
    szDir      = strchr( szOsLoader, '\\' );
    if( !szFileName ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_BADOSLNVR);
        goto r0;
    }
    strncpy( SystemPartition, szOsLoader, (int)(szDir - szOsLoader) );
    SystemPartition[ szDir - szOsLoader ] = '\0';

    //
    // Process the names and run through the drive list to determine a
    // match
    //

    ProcessArcName( SystemPartition, ProcessedArcSysPart );
    Found = FALSE;

    for( Disk = 0; Disk < 26 ; Disk++ ) {
        *szDrive = (CHAR)(Disk) + (CHAR)'A';
        if( DosPathToArcPathWorker( szDrive, ArcForDosDrive ) ) {
            ProcessArcName( ArcForDosDrive, ProcessedArcForDosDrive );
            if( !lstrcmpi( ProcessedArcSysPart, ProcessedArcForDosDrive ) ) {
                Found = TRUE;
                strcpy( OsLoaderDest, szDrive );
                strncat( OsLoaderDest, szDir, (int)(szFileName - szDir) );
                break;
            }
        }
    }
    if( !Found ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_DOSNOTEXIST);
        goto r0;
    }

    Status = TRUE;
    SetReturnText( OsLoaderDest );

r0:
    if( rgszSystemPartition ) { RgszFree( rgszSystemPartition ); }
    if( rgszOsLoader        ) { RgszFree( rgszOsLoader        ); }
    if( rgszOsLoadPartition ) { RgszFree( rgszOsLoadPartition ); }
    if( rgszOsLoadFilename  ) { RgszFree( rgszOsLoadFilename  ); }

    return( Status );

#endif
}

VOID
ProcessArcName(
   IN LPSTR NameIn,
   IN LPSTR NameOut
   )
{
   DWORD i;

   for(i = 0; (NameOut[i] = *NameIn) != '\0'; i++, NameIn++) {
       if( *NameIn == '(' && *(NameIn + 1) == ')' ) {
          NameOut[++i] = '0';
       }
   }
   return;
}



BOOL
CompareArcNames(
   IN LPSTR Name1,
   IN LPSTR Name2
   )
{
   CHAR ProcessedName1[MAX_PATH];
   CHAR ProcessedName2[MAX_PATH];

   ProcessArcName( Name1, ProcessedName1 );
   ProcessArcName( Name2, ProcessedName2 );
   return( !lstrcmpi( ProcessedName1, ProcessedName2 ) );
}




BOOL
DosPathToArcPathWorker(
    IN  LPSTR DosPath,
    OUT LPSTR ArcPath
    )
{
    CHAR  Drive[] = "\\DosDevices\\?:";
    WCHAR NtNameDrive[MAX_PATH];
    WCHAR ArcNameDrive[MAX_PATH];

    ANSI_STRING       AnsiString;

    UNICODE_STRING    Drive_U, NtNameDrive_U, ObjDir_U, ArcNameDrive_U;
    ANSI_STRING       ArcNameDrive_A;

    BOOL              bStatus;
    NTSTATUS          Status;

    //
    // Validate the DOS Path passed in
    //

    if (lstrlen(DosPath) < 2 || DosPath[1] != ':') {
        SetErrorText(IDS_ERROR_INVALIDDISK);
        return ( FALSE );
    }

    //
    // Extract the drive
    //

    Drive[12] = DosPath[0];

    //
    // Get Unicode string for the drive
    //

    RtlInitAnsiString(&AnsiString, Drive);
    Status = RtlAnsiStringToUnicodeString(
                 &Drive_U,
                 &AnsiString,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }


    //
    // Initialise Unicode string to hold the Nt Name for the Drive
    //

    NtNameDrive_U.Buffer        = NtNameDrive;
    NtNameDrive_U.Length        = 0;
    NtNameDrive_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    // Initialise Unicode string to hold the ArcName for the drive
    //

    ArcNameDrive_U.Buffer        = ArcNameDrive;
    ArcNameDrive_U.Length        = 0;
    ArcNameDrive_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    // Initialise Unicode string to hold the \\ArcName objdir name
    //

    RtlInitUnicodeString(&ObjDir_U, ARCNAMEOBJDIR);

    //
    // Query symbolic link of the drive
    //

    bStatus = GetSymbolicLinkTarget(&Drive_U, &NtNameDrive_U);
    RtlFreeUnicodeString(&Drive_U);
    if (!bStatus) {
        return ( FALSE );
    }

    //
    // Find the object in the arcname directory
    //

    bStatus = GetSymbolicLinkSource(&ObjDir_U, &NtNameDrive_U, &ArcNameDrive_U);
    if (!bStatus) {

        return ( FALSE );
    }

    //
    // Convert the Unicode ArcName for drive to ansi
    //

    Status = RtlUnicodeStringToAnsiString(
                 &ArcNameDrive_A,
                 &ArcNameDrive_U,
                 TRUE
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_RTLOOM);
        return ( FALSE );
    }

    //
    // Copy the drive to the output variable
    //

    ArcNameDrive_A.Buffer[ArcNameDrive_A.Length] = '\0'; //Null terminate
    lstrcpy(ArcPath, ArcNameDrive_A.Buffer);
    RtlFreeAnsiString(&ArcNameDrive_A);

    //
    // concatenate the rest of the DosPath to this ArcPath
    //

    lstrcat(ArcPath, DosPath+2);

    return(TRUE);

}



/*
 *  OBJECT MANAGEMENT ROUTINES
 */

BOOL
GetSymbolicLinkSource(
    IN  PUNICODE_STRING pObjDir_U,
    IN  PUNICODE_STRING pTarget_U,
    OUT PUNICODE_STRING pSource_U
    )
{
    PCHAR             Buffer, FullNameObject, ObjectLink, SavedMatch;
    UNICODE_STRING    ObjName_U, ObjLink_U;

    UNICODE_STRING    SavedMatch_U;
    BOOLEAN           IsMatchSaved = FALSE;

    OBJECT_ATTRIBUTES Attributes;

    HANDLE            DirectoryHandle;
    ULONG             Context = 0;
    ULONG             ReturnedLength;
    BOOLEAN           RestartScan = TRUE;
    BOOLEAN           ReturnSingleEntry = TRUE;  //LATER change this to FALSE

    POBJECT_DIRECTORY_INFORMATION DirInfo;

    NTSTATUS          Status;
    BOOL              bStatus;

    //
    // Open the object directory.
    //

    InitializeObjectAttributes(
        &Attributes,
        pObjDir_U,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenDirectoryObject(
                 &DirectoryHandle,
                 STANDARD_RIGHTS_READ | DIRECTORY_QUERY | DIRECTORY_TRAVERSE,
                 &Attributes
                 );

    if (!NT_SUCCESS( Status ) ) {
        SetErrorText(IDS_ERROR_OBJDIROPEN);
        return ( FALSE );
    }


    //
    //  Find the symbolic link objects in the directory and query them for
    //  a match with the string passed in
    //

    //
    //  Allocate a buffer to query the directory objects
    //
    if ((Buffer = LocalAlloc(0, BUFFER_SIZE)) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        NtClose(DirectoryHandle);
        return ( FALSE );
    }

    //
    //  Form a Unicode string object to hold the symbolic link objects found
    //  in the object directory
    //

    if ((FullNameObject = LocalAlloc(0, MAX_PATH * sizeof(WCHAR))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        LocalFree (Buffer);
        NtClose (DirectoryHandle);
        return ( FALSE );
    }

    ObjName_U.Buffer        = (PWSTR)FullNameObject;
    ObjName_U.Length        = 0;
    ObjName_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    //
    //  Form a Unicode string object to hold the symbolic link objects found
    //  in the object directory
    //

    if ((ObjectLink = LocalAlloc(0, MAX_PATH * sizeof(WCHAR))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        LocalFree (Buffer);
        LocalFree (FullNameObject);
        NtClose (DirectoryHandle);
        return ( FALSE );
    }

    ObjLink_U.Buffer        = (PWSTR)ObjectLink;
    ObjLink_U.Length        = 0;
    ObjLink_U.MaximumLength = MAX_PATH * sizeof(WCHAR);


    if ((SavedMatch = LocalAlloc(0, MAX_PATH * sizeof(WCHAR))) == NULL) {
        SetErrorText(IDS_ERROR_DLLOOM);
        LocalFree (Buffer);
        LocalFree (FullNameObject);
        LocalFree (ObjectLink);
        NtClose (DirectoryHandle);
        return ( FALSE );
    }

    SavedMatch_U.Buffer        = (PWSTR)SavedMatch;
    SavedMatch_U.Length        = 0;
    SavedMatch_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

    while (TRUE) {
        //
        //  Clear the buffer
        //
        RtlZeroMemory( Buffer, BUFFER_SIZE);

        //
        // repeatedly Query the directory objects till done
        //

        Status = NtQueryDirectoryObject(
                     DirectoryHandle,
                     Buffer,
                     BUFFER_SIZE,
                     ReturnSingleEntry,  // fetch more than one entry
                     RestartScan,        // start rescan true on first go
                     &Context,
                     &ReturnedLength
                     );


        //
        //  Check the Status of the operation.
        //

        if (!NT_SUCCESS(Status) && (Status != STATUS_MORE_ENTRIES)) {
            if (Status == STATUS_NO_MORE_FILES || Status == STATUS_NO_MORE_ENTRIES) {
                SetErrorText(IDS_ERROR_INVALIDDISK);
            }
            else {
                SetErrorText(IDS_ERROR_OBJDIRREAD);
            }
            LocalFree(Buffer);
            LocalFree(FullNameObject);
            LocalFree(ObjectLink);
            if(IsMatchSaved) {
                RtlCopyUnicodeString (pSource_U, &SavedMatch_U);
                LocalFree(SavedMatch);
                return(TRUE);
            }
            LocalFree(SavedMatch);
            return(FALSE);
        }

        //
        // Make sure that restart scan is false for next go
        //
        RestartScan = FALSE;


        //
        //  For every record in the buffer, see if the type of the object
        //  is a symbolic link
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise Status would have been No More Files
        //

        DirInfo = (POBJECT_DIRECTORY_INFORMATION) Buffer;

        while (TRUE) {

            //
            //  Check if there is another record.  If there isn't, break out of
            //  the loop now
            //

            if (DirInfo->Name.Length == 0) {
                break;
            }

            //
            //  See if the object type is a symbolic link
            //
            if (IsSymbolicLinkType(&(DirInfo->TypeName))) {

                //
                // get full pathname of object
                //

                //
                // Check if we will overflow our buffer
                //
                if ((
                     pObjDir_U->Length      +
                     sizeof(WCHAR)         +
                     DirInfo->Name.Length  +
                     sizeof(WCHAR)
                    ) > ObjName_U.MaximumLength )  {

                    SetErrorText(IDS_ERROR_OBJNAMOVF);
                    LocalFree(Buffer);
                    LocalFree(FullNameObject);
                    LocalFree(ObjectLink);

                    if(IsMatchSaved) {
                        RtlCopyUnicodeString (pSource_U, &SavedMatch_U);
                        LocalFree(SavedMatch);
                        return(TRUE);
                    }
                    LocalFree(SavedMatch);
                    return( FALSE );

                }

                //
                // Copy the current object name over the the buffer prefixing
                // it with the \ArcName\ object directory name
                //

                RtlCopyUnicodeString ( &ObjName_U, pObjDir_U );
                RtlAppendUnicodeToString ( &ObjName_U, L"\\" );
                RtlAppendUnicodeStringToString ( &ObjName_U, &(DirInfo->Name));

                //
                // query the symbolic link target
                //

                ObjLink_U.Buffer        = (PWSTR)ObjectLink;
                ObjLink_U.Length        = 0;
                ObjLink_U.MaximumLength = MAX_PATH * sizeof(WCHAR);

                bStatus = GetSymbolicLinkTarget (&ObjName_U, &ObjLink_U);
                if (bStatus != TRUE) {
                    LocalFree(Buffer);
                    LocalFree(FullNameObject);
                    LocalFree(ObjectLink);

                    if(IsMatchSaved) {
                        RtlCopyUnicodeString (pSource_U, &SavedMatch_U);
                        LocalFree(SavedMatch);
                        return(TRUE);
                    }
                    LocalFree(SavedMatch);
                    return FALSE;
                }

                //
                // see if it compares to the name we are looking for
                //

                if (RtlEqualUnicodeString (pTarget_U, &ObjLink_U, TRUE)) {

#if i386
                    UNICODE_STRING Multi_U;

                    RtlInitUnicodeString(&Multi_U,L"multi(");
                    if(RtlPrefixUnicodeString(&Multi_U,&DirInfo->Name,TRUE)) {

                        RtlCopyUnicodeString(&SavedMatch_U,&DirInfo->Name);
                        IsMatchSaved = TRUE;

                    } else  // scsi, just return it.  Favor scsi over multi.
#endif
                    {
                        RtlCopyUnicodeString (pSource_U, &(DirInfo->Name));
                        LocalFree(Buffer);
                        LocalFree(FullNameObject);
                        LocalFree(ObjectLink);
                        LocalFree(SavedMatch);
                        return TRUE;
                    }
                }

            }

            //
            //  There is another record so advance DirInfo to the next entry
            //

            DirInfo = (POBJECT_DIRECTORY_INFORMATION) (((PCHAR) DirInfo) +
                          sizeof( OBJECT_DIRECTORY_INFORMATION ) );

        }  // while

    } // while

    return ( FALSE );

} // getarcname



/* Checks to see if a given object type is a symbolic link type */

BOOL
IsSymbolicLinkType(
    IN PUNICODE_STRING Type
    )
{
    UNICODE_STRING  TypeName;

    //
    // Check the length of the string
    //
    if (Type->Length == 0) {
        return FALSE;
    }

    //
    // compare it to the symbolic link type name
    //
    RtlInitUnicodeString(&TypeName, SYMLINKTYPE);
    return (RtlEqualUnicodeString(Type, &TypeName, TRUE));
}





BOOL
GetSymbolicLinkTarget(
    IN     PUNICODE_STRING pSourceString_U,
    IN OUT PUNICODE_STRING pDestString_U
    )
{

    NTSTATUS          Status;

    OBJECT_ATTRIBUTES Attributes;
    HANDLE            ObjectHandle;

    //
    // Initialise the object attributes structure for the symbolic
    // link object

    InitializeObjectAttributes(
        &Attributes,
        pSourceString_U,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    //
    // Open the symbolic link for link_query access
    //

    Status = NtOpenSymbolicLinkObject(
                 &ObjectHandle,
                 READ_CONTROL | SYMBOLIC_LINK_QUERY,
                 &Attributes
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_SYMLNKOPEN);
        return ( FALSE );
    }


    //
    // query the symbolic link target
    //

    Status = NtQuerySymbolicLinkObject(
                 ObjectHandle,
                 pDestString_U,
                 NULL
                 );

    if (!NT_SUCCESS(Status)) {
        SetErrorText(IDS_ERROR_SYMLNKREAD);
        NtClose(ObjectHandle);
        return(FALSE);
    }

    //
    // close the link object
    //

    NtClose(ObjectHandle);

    //
    // return the link target
    //
    return ( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\patch\update.c ===
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <windows.h>
#include <string.h>
#include <direct.h>
#include <errno.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>

#define UPDATE_INF "UPDATE.INF"
#define SETUP_EXE "SETUP.EXE"
BOOL FFileFound( CHAR *szPath);

int _cdecl
main (INT argc, CHAR ** argv) {

    CHAR  FileName[MAX_PATH];
    CHAR  Command[MAX_PATH];
    CHAR  CommandFormat[] = "%s -i %s -s %s";
    CHAR  szCWD[MAX_PATH];
    CHAR  *sz;

    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    BOOL                Status;

    //
    // Determine where this program is run from.  Look for update.inf in the
    // same directory
    //

    if (!GetModuleFileName( NULL, FileName, MAX_PATH )) {
        printf( "Update.exe: Failed to get the module file name\n" );
        exit(1);
    }

    if ( !( sz = strrchr( FileName, '\\' ) ) ) {
        printf( "Update.exe: Module file name not valid\n" );
        exit(1);
    }
    *sz = '\0';
    strcpy( szCWD, FileName );
    if( lstrlen( szCWD ) == 2 ) {
        strcat( szCWD, "\\" );
    }

    strcat( FileName, "\\");
    strcat( FileName, UPDATE_INF );
    if (!FFileFound( FileName )) {
        printf( "Update.exe: INF %s not found.\n", FileName );
        exit(1);
    }
    sprintf ( Command, CommandFormat, SETUP_EXE, FileName, szCWD );

    //
    // Run CreateProcess on setup.exe with the update.inf on this source
    //

    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpDesktop = NULL;
    si.lpTitle = NULL;
    si.dwX = si.dwY = si.dwXSize = si.dwYSize = 0L;
    si.dwFlags = 0L;
    si.wShowWindow = 0;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    Status = CreateProcess(
                 NULL,
                 Command,
                 NULL,
                 NULL,
                 FALSE,
                 DETACHED_PROCESS,
                 NULL,
                 szCWD,
                 (LPSTARTUPINFO)&si,
                 (LPPROCESS_INFORMATION)&pi
                 );

    //
    // Close the process and thread handles
    //

    if ( !Status ) {
        DWORD dw = GetLastError();

        printf( "Update.exe: Failed to run: %s, Error Code: %d\n", Command, dw );
        exit(1);
    }


    CloseHandle( pi.hThread  );
    CloseHandle( pi.hProcess );

    //
    // exit
    //

    exit(0);
    return(0);
}

BOOL FFileFound(szPath)
CHAR *szPath;
{
    WIN32_FIND_DATA ffd;
    HANDLE          SearchHandle;

    if ( (SearchHandle = FindFirstFile( szPath, &ffd )) == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }
    else {
        FindClose( SearchHandle );
        return( TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\patchdll\dllinit.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module contians the DLL attach/detach event entry point for
    a Setup support DLL.

Author:

    Sunil Pai (sunilp) Aug 1993

Revision History:

--*/

#include <windows.h>

HANDLE ThisDLLHandle;

BOOL
DLLInit(
    IN HANDLE DLLHandle,
    IN DWORD  Reason,
    IN LPVOID ReservedAndUnused
    )
{
    ReservedAndUnused;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:

        ThisDLLHandle = DLLHandle;
        break;

    case DLL_PROCESS_DETACH:

        //  Delete all automatically established connections
        //  See UNC handling in netcon.c.
        //
        //  BUGBUG:  This doesn't work, because the unload sequence
        //  is different for "lazy" load DLLs than for load-time DLLs.
        //  INFs must be responsible for calling DeleteAllConnections().
        //
        //  DeleteAllConnectionsWorker() ;
        //
        break ;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\patchdll\patchdll.h ===
// defines

#define BUFFER_SIZE 1024
#define RETURN_BUFFER_SIZE 1024
#define  cListItemsMax     0x07FF
#define  cbItemMax         (CB)0x2000

//
// stuff from comstf.h
//
typedef BYTE *SZ;
typedef BYTE *PB;
typedef BYTE **RGSZ;
typedef unsigned CB;
#define fFalse ((BOOL)0)
#define fTrue  ((BOOL)1)
#define SzNextChar(sz) ((SZ)AnsiNext(sz))


// external data

extern HANDLE ThisDLLHandle;

// common (shared) routines

//*************************************************************************
//
//                      RETURN BUFFER MANIPULATION
//
//*************************************************************************

VOID  SetErrorText( DWORD ResID );
VOID  SetReturnText( LPSTR Text );

//*************************************************************************
//
//                      MEMORY MANIPULATION
//
//*************************************************************************

PVOID MyMalloc( size_t  Size );
VOID  MyFree( PVOID p );
PVOID MyRealloc( PVOID p, size_t  Size );

//*************************************************************************
//
//                      LIST MANIPULATION
//
//*************************************************************************

BOOL  FListValue( SZ szValue );
RGSZ  RgszAlloc( DWORD   Size );
VOID  RgszFree( RGSZ rgsz );
RGSZ  RgszFromSzListValue( SZ szListValue );
SZ    SzListValueFromRgsz( RGSZ rgsz );
DWORD RgszCount( RGSZ rgsz );
SZ    SzDup( SZ sz );

//*************************************************************************
//
//                      FILE MANIPULATION
//
//*************************************************************************

BOOL  FFileFound( IN LPSTR szPath );
BOOL  FTransferSecurity( PCHAR Source, PCHAR Dest );



//*************************************************************************
//
//                      ARCNAME MANIPULATION
//
//*************************************************************************

VOID ProcessArcName( IN LPSTR NameIn, IN LPSTR NameOut );
BOOL CompareArcNames( IN LPSTR Name1, IN LPSTR Name2 );
BOOL DosPathToArcPathWorker( IN  LPSTR DosPath, OUT LPSTR ArcPath );

//*************************************************************************
//
//                      OBJECT MANIPULATION
//
//*************************************************************************

BOOL IsSymbolicLinkType( IN PUNICODE_STRING Type );
BOOL GetSymbolicLinkSource( IN PUNICODE_STRING pObjDir_U, IN  PUNICODE_STRING pTarget_U, OUT PUNICODE_STRING pSource_U);
BOOL GetSymbolicLinkTarget( IN PUNICODE_STRING pSourceString_U, IN OUT PUNICODE_STRING pDestString_U);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\patchdll\patchdll.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    patchdll.c

Abstract:

    This file contains the patchdll entry points for the Windows NT Patch
    Utility.

Author:

    Sunil Pai (sunilp) Aug 1993

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include "rc_ids.h"
#include "patchdll.h"

CHAR ReturnTextBuffer[ RETURN_BUFFER_SIZE ];

//
// Entry Point to Change the File Attributes of a list of files
//
BOOL
ChangeFileAttributes(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    DWORD   Attribs = 0;
    CHAR    *ptr = Args[0];

    *TextOut = ReturnTextBuffer;
    if(cArgs != 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    //
    // Determine what the file attributes to set by examining args[0]
    //

    while(*ptr) {
        switch(*ptr) {
        case 'S':
        case 's':
            Attribs |= FILE_ATTRIBUTE_SYSTEM;
            break;
        case 'A':
        case 'a':
            Attribs |= FILE_ATTRIBUTE_ARCHIVE;
            break;
        case 'H':
        case 'h':
            Attribs |= FILE_ATTRIBUTE_HIDDEN;
            break;
        case 'R':
        case 'r':
            Attribs |= FILE_ATTRIBUTE_READONLY;
            break;
        case 'T':
        case 't':
            Attribs |= FILE_ATTRIBUTE_TEMPORARY;
            break;
        default:
            Attribs |= FILE_ATTRIBUTE_NORMAL;
        }
        ptr++;
    }

    //
    // Find the file and set the new attribs
    //

    if(FFileFound( Args[1] ) && SetFileAttributes( Args[1], Attribs ) ) {
        SetReturnText( "YES" );
    } else {
        SetReturnText( "NO" );
    }
    return ( TRUE );
}


//
// Entry point to check build version we are installing on is not greater
// than our patch build version.
//

BOOL
CheckBuildVersion(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    DWORD dwPatch, dwCurVer;
    CHAR  VersionString[16];

    *TextOut = ReturnTextBuffer;
    dwCurVer = (GetVersion() & 0x7fff0000) >> 16;
    wsprintf( VersionString, "%d", dwCurVer );
    SetReturnText( VersionString );
    return ( TRUE );

}

//
// Entry point to find out if a file is opened with exclusive access
//
BOOL
IsFileOpenedExclusive(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    OFSTRUCT ofstruct;
    HFILE    hFile;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    SetReturnText( "NO" );
    if ( FFileFound( Args[0] ) ) {
        SetFileAttributes( Args[0], FILE_ATTRIBUTE_NORMAL );
        if( (hFile = OpenFile( Args[0], &ofstruct, OF_READ | OF_WRITE )) == HFILE_ERROR ) {

            CHAR TempPath[MAX_PATH];
            CHAR TempName[MAX_PATH];
            CHAR *LastSlash;

            //
            // Can the file be renamed - generate a temporary name and try
            // renaming it to this name.  If it works rename it back to the
            // old name.
            //

            lstrcpy (TempPath, Args[0]);
            LastSlash = strrchr( TempPath, '\\' );
            *LastSlash = '\0';

            if (GetTempFileName( TempPath, "temp", 0, TempName) == 0 ) {
                SetErrorText( IDS_ERROR_GENERATETEMP );
                return( FALSE );
            }
            else {
                DeleteFile( TempName );
            }

            if ( MoveFile ( Args[0], TempName ) ) {
                MoveFile( TempName, Args[0] );
            }
            else {
                SetReturnText( "YES" );
            }
        }
        else {
            CloseHandle( LongToHandle(hFile) );
        }
    }
    return ( TRUE );
}

//
// Entry point to generate a temporary file name
//
// Args[0] : Directory to create temporary file name in
//

BOOL
GenerateTemporary(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    CHAR  TempFile[ MAX_PATH ];
    CHAR  *sz;

    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    if (GetTempFileName( Args[0], "temp", 0, TempFile) == 0 ) {
        SetErrorText( IDS_ERROR_GENERATETEMP );
        return( FALSE );
    }

    if (sz = strrchr( TempFile, '\\')) {
        sz++;
        SetReturnText(sz);
    }
    else {
        SetReturnText( TempFile );
    }

    return( TRUE );
}


//
// Entry point to implement the MoveFileEx functionality to copy the file
// on reboot.
//

BOOL
CopyFileOnReboot(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{
    CHAR  Root[] = "?:\\";
    DWORD dw1, dw2;
    CHAR  VolumeFSName[MAX_PATH];


    *TextOut = ReturnTextBuffer;
    if(cArgs < 2) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }

    //
    // First Copy the security from Args[1] to Args[0] if it is on NTFS volume
    //

    Root[0] = Args[1][0];
    if(!GetVolumeInformation( Root, NULL, 0, NULL, &dw1, &dw2, VolumeFSName, MAX_PATH )) {
        SetErrorText(IDS_ERROR_GETVOLINFO);
        return(FALSE);
    }


    if(!lstrcmpi( VolumeFSName, "NTFS" )) {
        if(!FTransferSecurity( Args[1], Args[0] )) {
            SetErrorText(IDS_ERROR_TRANSFERSEC);
            return( FALSE );
        }
    }
    if ( MoveFileEx(
             Args[0],
             Args[1],
             MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT
             )
       ) {
        SetReturnText( "SUCCESS" );
    }
    else {
        SetReturnText("FAILURE");
    }

    return( TRUE );
}


//
// SUBROUTINES
//

//
// Entry point to search the setup.log file to determine the hal, kernel and
// boot scsi types.
//
// 1. Arg[0]: List of files whose source files are to be determined: eg.
//    {hal.dll, ntoskrnl.exe, ntbootdd.sys}

BOOL
GetFileTypes(
    IN  DWORD cArgs,
    IN  LPSTR Args[],
    OUT LPSTR *TextOut
    )
{

    CHAR    SetupLogFile[ MAX_PATH ];
    DWORD   nFiles, i, dwAttr = FILE_ATTRIBUTE_NORMAL;
    BOOL    Status = TRUE;
    RGSZ    FilesArray = NULL, FilesTypeArray = NULL;
    PCHAR   sz1, sz4;

    PCHAR   SectionNames = NULL;
    ULONG   BufferSizeForSectionNames;
    PCHAR   CurrentSectionName;
    ULONG   Count;
    CHAR    TmpFileName[ MAX_PATH + 1 ];


    //
    // Validate the argument passed in
    //


    *TextOut = ReturnTextBuffer;
    if(cArgs != 1) {
        SetErrorText(IDS_ERROR_BADARGS);
        return(FALSE);
    }
    *ReturnTextBuffer = '\0';

    //
    // Get the windows directory, check to see if the setup.log file is there
    // and if not present, return
    //

    if (!GetWindowsDirectory( SetupLogFile, MAX_PATH )) {
        SetErrorText(IDS_ERROR_GETWINDOWSDIR);
        return( FALSE );
    }
    strcat( SetupLogFile, "\\repair\\setup.log" );
    if( !FFileFound ( SetupLogFile ) ) {
        SetReturnText( "SETUPLOGNOTPRESENT" );
        return( TRUE );
    }


    //
    // Take the lists passed in and convert them into C Pointer Arrays.
    //

    if ((FilesArray = RgszFromSzListValue(Args[0])) == NULL ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_DLLOOM);
        goto r0;
    }
    nFiles = RgszCount( FilesArray );

    //
    // Form return types rgsz
    //

    if( !(FilesTypeArray = RgszAlloc( nFiles + 1 )) ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_DLLOOM);
        goto r0;
    }

    for ( i = 0; i < nFiles; i++ ) {
        if( !(FilesTypeArray[i] = SzDup( "" )) ) {
            Status = FALSE;
            SetErrorText(IDS_ERROR_DLLOOM);
            goto r1;
        }
    }

    //
    // Set the attributes on the file to normal attributes
    //

    if ( dwAttr = GetFileAttributes( SetupLogFile ) == 0xFFFFFFFF ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_GETATTRIBUTES);
        goto r1;
    }
    SetFileAttributes( SetupLogFile, FILE_ATTRIBUTE_NORMAL );


    BufferSizeForSectionNames = BUFFER_SIZE;
    SectionNames = ( PCHAR )MyMalloc( BufferSizeForSectionNames );
    if( SectionNames == NULL ) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_DLLOOM);
        goto r2;
    }

    //
    // Find out the names of all sections in setup.log
    //
    while( ( Count = GetPrivateProfileString( NULL,
                                              "",
                                              "",
                                              SectionNames,
                                              BufferSizeForSectionNames,
                                              SetupLogFile ) ) == BufferSizeForSectionNames - 2 ) {
        if( Count == 0 ) {
            Status = FALSE;
            SetErrorText( IDS_ERROR_READLOGFILE );
            goto r2;
        }

        BufferSizeForSectionNames += BUFFER_SIZE;
        SectionNames = ( PCHAR )MyRealloc( SectionNames, BufferSizeForSectionNames );
        if( SectionNames == NULL ) {
            Status = FALSE;
            SetErrorText(IDS_ERROR_DLLOOM);
            goto r1;
        }
    }

    for (i = 0; i < nFiles; i++) {
        for( CurrentSectionName = SectionNames;
             *CurrentSectionName  != '\0';
             CurrentSectionName += lstrlen( CurrentSectionName ) + 1 ) {
            //
            //  If the file is supposed to be found in [Files.WinNt] section,
            //  then use as key name, the full path without the drive letter.
            //  If the file is supposed to be found in [Files.SystemPartition]
            //  section, then use as key name the filename only.
            //  Note that one or neither call to GetPrivateProfileString API
            //  will succeed. It is necessary to make the two calls, since the
            //  files logged in [Files.WinNt] and [Files.SystemPartition] have
            //  different formats.
            //
            if( ( ( GetPrivateProfileString( CurrentSectionName,
                                             strchr( FilesArray[i], ':' ) + 1,
                                             "",
                                             TmpFileName,
                                             sizeof( TmpFileName ),
                                             SetupLogFile ) > 0 ) ||

                  ( GetPrivateProfileString( CurrentSectionName,
                                             strrchr( FilesArray[i], '\\' ) + 1,
                                             "",
                                             TmpFileName,
                                             sizeof( TmpFileName ),
                                             SetupLogFile ) > 0 )

                ) &&
                ( lstrlen( TmpFileName ) != 0 ) ) {
                if ( sz1 = strchr( TmpFileName, ',' )) {
                    *sz1 = '\0';
                    if( sz1 = strchr( TmpFileName, '.' )) {
                        *sz1 = '\0';
                    }
                    if( !(sz1 = SzDup( TmpFileName )) ) {
                        Status = FALSE;
                        SetErrorText(IDS_ERROR_DLLOOM);
                        goto r2;
                    }
                    MyFree( FilesTypeArray[i] );
                    FilesTypeArray[i] = sz1;
                    break;
                }
            }
        }
    }


    //
    // Convert the rgsz into a list
    //
    if( !(sz4 = SzListValueFromRgsz( FilesTypeArray ))) {
        Status = FALSE;
        SetErrorText(IDS_ERROR_DLLOOM);
    }
    else {
        SetReturnText( sz4 );
        MyFree( sz4 );
    }

r2:
    SetFileAttributes( SetupLogFile, dwAttr );

r1:
    //
    // Free pointers allocated
    //

    if ( FilesTypeArray ) {
        RgszFree( FilesTypeArray );
    }

    if ( FilesArray ) {
        RgszFree( FilesArray );
    }

    if( SectionNames ) {
        MyFree( ( PVOID )SectionNames );
    }
r0:
    return( Status );
}



//*************************************************************************
//
//                      MEMORY MANAGEMENT
//
//*************************************************************************


PVOID
MyMalloc(
    size_t  Size
    )
{
    return (PVOID)LocalAlloc( 0, Size );
}


VOID
MyFree(
    PVOID   p
    )
{
    LocalFree( (HANDLE)p );
}


PVOID
MyRealloc(
    PVOID   p,
    size_t  Size
    )
{
    return (PVOID)LocalReAlloc( p, Size, LMEM_MOVEABLE );
}



//*************************************************************************
//
//                      LIST MANIPULATION
//
//*************************************************************************

/*
**      Purpose:
**              Determines if a string is a list value.
**      Arguments:
**              szValue: non-NULL, zero terminated string to be tested.
**      Returns:
**              fTrue if a list; fFalse otherwise.
**
**************************************************************************/
BOOL FListValue(szValue)
SZ szValue;
{

        if (*szValue++ != '{')
                return(fFalse);

        while (*szValue != '}' && *szValue != '\0')
                {
                if (*szValue++ != '"')
                        return(fFalse);

                while (*szValue != '\0')
                        {
                        if (*szValue != '"')
                                szValue = SzNextChar(szValue);
                        else if (*(szValue + 1) == '"')
                                szValue += 2;
                        else
                                break;
                        }

                if (*szValue++ != '"')
                        return(fFalse);

                if (*szValue == ',')
                        if (*(++szValue) == '}')
                                return(fFalse);
                }

        if (*szValue != '}')
                return(fFalse);

        return(fTrue);
}


RGSZ
RgszAlloc(
    DWORD   Size
    )
{
    RGSZ    rgsz = NULL;
    DWORD   i;

    if ( Size > 0 ) {

        if ( (rgsz = MyMalloc( Size * sizeof(SZ) )) ) {

            for ( i=0; i<Size; i++ ) {
                rgsz[i] = NULL;
            }
        }
    }

    return rgsz;
}


VOID
RgszFree(
    RGSZ    rgsz
    )
{

    INT i;

    for (i = 0; rgsz[i]; i++ ) {
        MyFree( rgsz[i] );
    }

    MyFree(rgsz);
}



/*
**      Purpose:
**              Converts a list value into an RGSZ.
**      Arguments:
**              szListValue: non-NULL, zero terminated string to be converted.
**      Returns:
**              NULL if an error occurred.
**              Non-NULL RGSZ if the conversion was successful.
**
**************************************************************************/
RGSZ  RgszFromSzListValue(szListValue)
SZ szListValue;
{
        USHORT cItems;
        SZ     szCur;
        RGSZ   rgsz;


        if (!FListValue(szListValue))
                {
        if ((rgsz = (RGSZ)MyMalloc((CB)(2 * sizeof(SZ)))) == (RGSZ)NULL ||
                (rgsz[0] = SzDup(szListValue)) == (SZ)NULL)
                        return((RGSZ)NULL);
                rgsz[1] = (SZ)NULL;
                return(rgsz);
                }

    if ((rgsz = (RGSZ)MyMalloc((CB)((cListItemsMax + 1) * sizeof(SZ)))) ==
                        (RGSZ)NULL)
                return((RGSZ)NULL);

    cItems = 0;
    szCur = szListValue + 1;

    while (*szCur != '}' &&
           *szCur != '\0' &&
            cItems < cListItemsMax)
    {
            SZ szValue;
            SZ szAddPoint;

            if( *szCur != '"' ) {
                return( (RGSZ) NULL );
            }

                szCur++;
        if ((szAddPoint = szValue = (SZ)MyMalloc(cbItemMax)) == (SZ)NULL)
                        {
                        rgsz[cItems] = (SZ)NULL;
            RgszFree(rgsz);
                        return((RGSZ)NULL);
                        }

                while (*szCur != '\0')
                        {
                        if (*szCur == '"')
                                {
                                if (*(szCur + 1) != '"')
                                        break;
                                szCur += 2;
                                *szAddPoint++ = '"';
                                }
                        else
                                {
                                SZ szNext = SzNextChar(szCur);

                                while (szCur < szNext)
                                        *szAddPoint++ = *szCur++;
                                }
                        }

                *szAddPoint = '\0';

                if (*szCur++ != '"' ||
                lstrlen(szValue) >= cbItemMax ||
                (szAddPoint = SzDup(szValue)) == (SZ)NULL)
                        {
            MyFree((PB)szValue);
                        rgsz[cItems] = (SZ)NULL;
            RgszFree(rgsz);
                        return((RGSZ)NULL);
                        }

        MyFree((PB)szValue);

                if (*szCur == ',')
                        szCur++;
                rgsz[cItems++] = szAddPoint;
    }

    rgsz[cItems] = (SZ)NULL;

    if (*szCur != '}' || cItems >= cListItemsMax)
    {
        RgszFree(rgsz);
        return((RGSZ)NULL);
    }

    if (cItems < cListItemsMax)
        rgsz = (RGSZ)MyRealloc((PB)rgsz, (CB)((cItems + 1) * sizeof(SZ)));

        return(rgsz);
}

/*
**      Purpose:
**              Converts an RGSZ into a list value.
**      Arguments:
**              rgsz: non-NULL, NULL-terminated array of zero-terminated strings to
**                      be converted.
**      Returns:
**              NULL if an error occurred.
**              Non-NULL SZ if the conversion was successful.
**
**************************************************************************/
SZ  SzListValueFromRgsz(rgsz)
RGSZ rgsz;
{
        SZ   szValue;
        SZ   szAddPoint;
        SZ   szItem;
        BOOL fFirstItem = fTrue;

    //ChkArg(rgsz != (RGSZ)NULL, 1, (SZ)NULL);

    if ((szAddPoint = szValue = (SZ)MyMalloc(cbItemMax)) == (SZ)NULL)
                return((SZ)NULL);

        *szAddPoint++ = '{';
        while ((szItem = *rgsz) != (SZ)NULL)
                {
                if (fFirstItem)
                        fFirstItem = fFalse;
                else
                        *szAddPoint++ = ',';

                *szAddPoint++ = '"';
                while (*szItem != '\0')
                        {
                        if (*szItem == '"')
                                {
                                *szAddPoint++ = '"';
                                *szAddPoint++ = '"';
                                szItem++;
                                }
                        else
                                {
                                SZ szNext = SzNextChar(szItem);

                                while (szItem < szNext)
                                        *szAddPoint++ = *szItem++;
                                }
                        }

                *szAddPoint++ = '"';
                rgsz++;
                }

        *szAddPoint++ = '}';
        *szAddPoint = '\0';

    //AssertRet(CbStrLen(szValue) < cbItemMax, (SZ)NULL);
    szItem = SzDup(szValue);
    MyFree(szValue);

        return(szItem);
}



DWORD
RgszCount(
    RGSZ    rgsz
    )
    /*
        Return the number of elements in an RGSZ
     */
{
    DWORD i ;

    for ( i = 0 ; rgsz[i] ; i++ ) ;

    return i ;
}

SZ
SzDup(
    SZ  sz
    )
{
    SZ  NewSz = NULL;

    if ( sz ) {

        if ( (NewSz = (SZ)MyMalloc( strlen(sz) + 1 )) ) {

            strcpy( NewSz, sz );
        }
    }

    return NewSz;
}



//*************************************************************************
//
//                      RETURN BUFFER MANIPULATION
//
//*************************************************************************


//
// Return Text Routine
//

VOID
SetReturnText(
    IN LPSTR Text
    )

{
    lstrcpy( ReturnTextBuffer, Text );
}

VOID
SetErrorText(
    IN DWORD ResID
    )
{
    LoadString(ThisDLLHandle,(WORD)ResID,ReturnTextBuffer,sizeof(ReturnTextBuffer)-1);
    ReturnTextBuffer[sizeof(ReturnTextBuffer)-1] = '\0';     // just in case
}




//*************************************************************************
//
//                      FILE MANIPULATION
//
//*************************************************************************

BOOL
FFileFound(
    IN LPSTR szPath
    )
{
    WIN32_FIND_DATA ffd;
    HANDLE          SearchHandle;

    if ( (SearchHandle = FindFirstFile( szPath, &ffd )) == INVALID_HANDLE_VALUE ) {
        return( FALSE );
    }
    else {
        FindClose( SearchHandle );
        return( TRUE );
    }
}


BOOL
FTransferSecurity(
    PCHAR Source,
    PCHAR Dest
    )
{
    #define CBSDBUF 1024
    CHAR  SdBuf[CBSDBUF];
    SECURITY_INFORMATION Si;
    PSECURITY_DESCRIPTOR Sd = (PSECURITY_DESCRIPTOR)SdBuf;
    DWORD cbSd = CBSDBUF;
    DWORD cbSdReq;

    PVOID  AllocBuffer = NULL;
    BOOL  Status;

    //
    // Get the security information from the source file
    //

    Si = OWNER_SECURITY_INFORMATION |
         GROUP_SECURITY_INFORMATION |
         DACL_SECURITY_INFORMATION;

    Status = GetFileSecurity(
                 Source,
                 Si,
                 Sd,
                 cbSd,
                 &cbSdReq
                 );

    if(!Status) {
        if( cbSdReq > CBSDBUF  && (AllocBuffer = malloc( cbSdReq ))) {

            Sd   = (PSECURITY_DESCRIPTOR)AllocBuffer;
            cbSd = cbSdReq;
            Status = GetFileSecurity(
                         Source,
                         Si,
                         (PSECURITY_DESCRIPTOR)Sd,
                         cbSd,
                         &cbSdReq
                         );
        }
    }

    if( !Status ) {
        return( FALSE );
    }

    //
    // Set the Security on the dest file
    //

    Status = SetFileSecurity(
                 Dest,
                 Si,
                 Sd
                 );

    if ( AllocBuffer ) {
        free( AllocBuffer );
    }

    return ( Status );
}


DWORD
GetSizeOfFile(
    IN LPSTR szFile
    )
{

    HANDLE          hff;
    WIN32_FIND_DATA ffd;
    DWORD           Size  = 0;

    //
    // get find file information and get the size information out of
    // that
    //

    if ((hff = FindFirstFile(szFile, &ffd)) != INVALID_HANDLE_VALUE) {
        Size = ffd.nFileSizeLow;
        FindClose(hff);
    }

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\patchdll\i386\syspart.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

--*/

#define UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include "rc_ids.h"
#include "patchdll.h"

PWSTR
ArcPathToNtPath(
    IN PWSTR ArcPath
    )
{
    NTSTATUS Status;
    HANDLE ObjectHandle;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING UnicodeString;
    UCHAR Buffer[1024];
    PWSTR arcPath;
    PWSTR ntPath;

    //
    // Assume failure
    //
    ntPath = NULL;

    arcPath = MyMalloc(((wcslen(ArcPath)+1)*sizeof(WCHAR)) + sizeof(L"\\ArcName"));
    wcscpy(arcPath,L"\\ArcName\\");
    wcscat(arcPath,ArcPath);

    RtlInitUnicodeString(&UnicodeString,arcPath);

    InitializeObjectAttributes(
        &Obja,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenSymbolicLinkObject(
                &ObjectHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Obja
                );

    if(NT_SUCCESS(Status)) {

        //
        // Query the object to get the link target.
        //
        UnicodeString.Buffer = (PWSTR)Buffer;
        UnicodeString.Length = 0;
        UnicodeString.MaximumLength = sizeof(Buffer);

        Status = NtQuerySymbolicLinkObject(
                    ObjectHandle,
                    &UnicodeString,
                    NULL
                    );

        if(NT_SUCCESS(Status)) {

            ntPath = MyMalloc(UnicodeString.Length+sizeof(WCHAR));

            CopyMemory(ntPath,UnicodeString.Buffer,UnicodeString.Length);

            ntPath[UnicodeString.Length/sizeof(WCHAR)] = 0;
        }

        NtClose(ObjectHandle);
    }

    MyFree(arcPath);

    return(ntPath);
}

BOOL
GetPartitionInfo(
    IN  WCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )
{
    WCHAR DriveName[] = L"\\\\.\\?:";
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;

    DriveName[4] = Drive;

    hDisk = CreateFileW(
                DriveName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL,
                OPEN_EXISTING,
                0,
                NULL
                );

    if(hDisk == INVALID_HANDLE_VALUE) {
        return(FALSE);
    }

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_PARTITION_INFO,
            NULL,
            0,
            PartitionInfo,
            sizeof(PARTITION_INFORMATION),
            &DataSize,
            NULL
            );

    CloseHandle(hDisk);

    return(b);
}

BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN WCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    unsigned i;
    HANDLE FindHandle;
    WIN32_FIND_DATA FindData;

    PWSTR BootFiles[] = { L"BOOT.INI",
                          L"NTLDR",
                          L"NTDETECT.COM",
                          NULL
                        };

    WCHAR FileName[64];

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether an nt boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) {

        wsprintf(FileName,L"%wc:\\%s",Drive,BootFiles[i]);

        FindHandle = FindFirstFile(FileName,&FindData);
        if(FindHandle == INVALID_HANDLE_VALUE) {
            return(FALSE);
        } else {
            FindClose(FindHandle);
        }
    }

    return(TRUE);
}

UINT
MyGetDriveType(
    IN WCHAR Drive
    )
{
    WCHAR DriveNameNt[] = L"\\\\.\\?:";
    WCHAR DriveName[] = L"?:\\";
    HANDLE hDisk;
    BOOL b;
    UINT rc;
    DWORD DataSize;
    DISK_GEOMETRY MediaInfo;

    //
    // First, get the win32 drive type.  If it tells us DRIVE_REMOVABLE,
    // then we need to see whether it's a floppy or hard disk.  Otherwise
    // just believe the api.
    //
    //
    DriveName[0] = Drive;
    if((rc = GetDriveType(DriveName)) == DRIVE_REMOVABLE) {

        DriveNameNt[4] = Drive;

        hDisk = CreateFile(
                    DriveNameNt,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if(hDisk != INVALID_HANDLE_VALUE) {

            b = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_GET_DRIVE_GEOMETRY,
                    NULL,
                    0,
                    &MediaInfo,
                    sizeof(MediaInfo),
                    &DataSize,
                    NULL
                    );

            //
            // It's really a hard disk if the media type is removable.
            //
            if(b && (MediaInfo.MediaType == RemovableMedia)) {
                rc = DRIVE_FIXED;
            }

            CloseHandle(hDisk);
        }
    }

    return(rc);
}

WCHAR
x86DetermineSystemPartition(
    VOID
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    None

Return Value:

    Drive letter of system partition.

--*/

{
    BOOL  GotIt;
    PWSTR NtDevicePath;
    WCHAR Drive;
    WCHAR DriveName[3];
    WCHAR Buffer[512];
    DWORD NtDevicePathLen;
    PWSTR p;
    DWORD PhysicalDriveNumber;
    HANDLE hDisk;
    BOOL b;
    DWORD DataSize;
    PVOID DriveLayout;
    DWORD DriveLayoutSize;

    DriveName[1] = L':';
    DriveName[2] = 0;

    GotIt = FALSE;

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    //
    if(NtDevicePath = ArcPathToNtPath(L"multi(0)disk(0)rdisk(0)")) {

        //
        // The arc path for a disk device is usually linked
        // to partition0.  Get rid of the partition part of the name.
        //
        CharLowerW(NtDevicePath);
        if(p = wcsstr(NtDevicePath,L"\\partition")) {
            *p = 0;
        }

        NtDevicePathLen = lstrlenW(NtDevicePath);

        //
        // Determine the physical drive number of this drive.
        // If the name is not of the form \device\harddiskx then
        // something is very wrong.
        //
        if(!wcsncmp(NtDevicePath,L"\\device\\harddisk",16)) {

            PhysicalDriveNumber = wcstoul(NtDevicePath+16,NULL,10);

            wsprintfW(Buffer,L"\\\\.\\PhysicalDrive%u",PhysicalDriveNumber);

            //
            // Get drive layout info for this physical disk.
            //
            hDisk = CreateFileW(
                        Buffer,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        );

            if(hDisk != INVALID_HANDLE_VALUE) {

                //
                // Get partition information.
                //
                DriveLayout = MyMalloc(1024);
                DriveLayoutSize = 1024;

                retry:

                b = DeviceIoControl(
                        hDisk,
                        IOCTL_DISK_GET_DRIVE_LAYOUT,
                        NULL,
                        0,
                        DriveLayout,
                        DriveLayoutSize,
                        &DataSize,
                        NULL
                        );

                if(!b && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {

                    DriveLayoutSize += 1024;
                    DriveLayout = MyRealloc(DriveLayout,DriveLayoutSize);
                    goto retry;
                }

                CloseHandle(hDisk);

                if(b) {

                    //
                    // The system partition can only be a drive that is on
                    // this disk.  We make this determination by looking at NT drive names
                    // for each drive letter and seeing if the nt equivalent of
                    // multi(0)disk(0)rdisk(0) is a prefix.
                    //
                    for(Drive=L'C'; Drive<=L'Z'; Drive++) {

                        if(MyGetDriveType(Drive) == DRIVE_FIXED) {

                            DriveName[0] = Drive;

                            if(QueryDosDeviceW(DriveName,Buffer,sizeof(Buffer)/sizeof(WCHAR))) {

                                if(!_wcsnicmp(NtDevicePath,Buffer,NtDevicePathLen)) {

                                    //
                                    // Now look to see whether there's an nt boot sector and
                                    // boot files on this drive.
                                    //
                                    if(AppearsToBeSysPart(DriveLayout,Drive)) {
                                        GotIt = TRUE;
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }

                MyFree(DriveLayout);
            }
        }

        MyFree(NtDevicePath);
    }


    return(GotIt ? Drive : L'C');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\patchdll\rc_ids.h ===
// error text resource IDS

#define IDS_ERROR_BADARGS       100
#define IDS_ERROR_GENERATETEMP  101
#define IDS_ERROR_GETVOLINFO    102
#define IDS_ERROR_TRANSFERSEC   103
#define IDS_ERROR_DLLOOM        104
#define IDS_ERROR_GETSIZE       105
#define IDS_ERROR_OPENLOGFILE   106
#define IDS_ERROR_CREATEFILEMAP 107
#define IDS_ERROR_MAPVIEW       108
#define IDS_ERROR_UNMAPVIEW     109
#define IDS_ERROR_CLOSEFILEMAP  110
#define IDS_ERROR_CLOSELOGFILE  111
#define IDS_ERROR_GETATTRIBUTES 112
#define IDS_ERROR_GETSYSTEMDIR  113
#define IDS_ERROR_TEMPFILE      114
#define IDS_ERROR_CLOSETEMPFILE 115
#define IDS_ERROR_OPENTEMPFILE  116
#define IDS_ERROR_WRITETEMPFILE 117
#define IDS_ERROR_MOVETEMP      118
#define IDS_ERROR_READLOGFILE   119
#define IDS_ERROR_GETWINDOWSDIR 120
#define IDS_ERROR_NONVRAMVARS   121
#define IDS_ERROR_OSLOADNOTFND  122
#define IDS_ERROR_BADOSLNVR     123
#define IDS_ERROR_INVALIDDISK   124
#define IDS_ERROR_RTLOOM        125
#define IDS_ERROR_OBJDIROPEN    126
#define IDS_ERROR_OBJDIRREAD    127
#define IDS_ERROR_OBJNAMOVF     128
#define IDS_ERROR_SYMLNKOPEN    129
#define IDS_ERROR_SYMLNKREAD    130
#define IDS_ERROR_DOSNOTEXIST   131
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\inc\digpid.h ===
/*++ 

Copyright (c) 1985-1998, Microsoft Corporation

Module Name:


    digpid.h

Abstract:

--*/

// DigPid.h

#ifdef __cplusplus
extern "C" {
#endif

#define INVALID_PID 0xFFFFFFFF

typedef enum {
    ltFPP,
    ltCCP,
    ltOEM,
    ltSelect,
    ltMLP,
    ltMOLP,
    ltMSDN
} LICENSETYPE;
typedef DWORD DWLICENSETYPE;


typedef struct {
    DWORD dwLength;
    WORD  wVersionMajor;
    WORD  wVersionMinor;
    char  szPid2[24];
    DWORD dwKeyIdx;
    char  szSku[16];
    BYTE  abCdKey[16];
    DWORD dwCloneStatus;
    DWORD dwTime;
    DWORD dwRandom;
    DWLICENSETYPE dwlt;
    DWORD adwLicenseData[2];
    char  szOemId[8];
    DWORD dwBundleId;

    char  aszHardwareIdStatic[8];

    DWORD dwHardwareIdTypeStatic;
    DWORD dwBiosChecksumStatic;
    DWORD dwVolSerStatic;
    DWORD dwTotalRamStatic;
    DWORD dwVideoBiosChecksumStatic;

    char  aszHardwareIdDynamic[8];

    DWORD dwHardwareIdTypeDynamic;
    DWORD dwBiosChecksumDynamic;
    DWORD dwVolSerDynamic;
    DWORD dwTotalRamDynamic;
    DWORD dwVideoBiosChecksumDynamic;

    DWORD dwCrc32;
} DIGITALPID, *PDIGITALPID, FAR *LPDIGITALPID;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pidgen\ccrc32.h ===
/*++

Copyright (c) 1998-1999, Microsoft Corporation

Module Name:


    CCrc32.h

Abstract:

--*/

#ifndef CCRC32_H
#define CCRC32_H


#ifndef __WINDOWS_H
#include <windows.h>
#endif


// Used Definitions Declarations

#define CCRC32_CLASSID 0x13420808L

#define CRC32_POLYNOMIAL 0xEDB88320


// Class Declaration

class CCrc32
{
    public:
        CCrc32();
        virtual ~CCrc32();

    public:
        ULONG CalculateBlockCRC( LPVOID lpvBlock, INT nBlockLength );

    public:
        ULONG uClassID;

    private:
        VOID InitialiseCRCTable();

    private:
        ULONG m_uCRC32Table[ 256 ];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pidgen\pgentest\pgentest.cpp ===
#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>


#include "..\..\inc\pidgen.h"
#include "..\inc\DigPid.h"


extern "C" extern WORD _C000H;
extern "C" extern WORD _F000H;

// LPBYTE lpbSystemBiosRom = (LPBYTE)MAKELONG(0, &_F000H);
// LPBYTE lpbVideoBiosRom  = (LPBYTE)MAKELONG(0, &_C000H);


int PASCAL WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpszCmdLine,
    int cmdShow)
{

    BOOL fOk;
////char  *lpszProductKey;
    char  achPid2[32];
    BYTE  abPid3[DIGITALPIDMAXLEN];
    DWORD dwSeq = 0;
    BOOL  fCCP = FALSE;
    BOOL  fPSS = FALSE;
    int   iValidCnt = 0;
    int   iKeyCnt = 0;
    char  szLineBuf[128];
    char  szMsgBuf[128];
    FILE *pfIn = NULL;

    LPDIGITALPID pdp = (LPDIGITALPID) abPid3;

#if 0 /////////////////////////////////
    if (argc <= 1)
    {
        lpszProductKey = "PXGAD-G3CCE-G8DB8-PPXFT-DRPY3";
////    lpszProductKey = "GRHQ2-CDPWX-WWJBT-RXWFG-6CXCT";
    }
    else
    {
        lpszProductKey = argv[1]
    }
#endif ////////////////////////////////

    pfIn = fopen(lpszCmdLine,"r");

    if (NULL == pfIn)
    {
        sprintf(
            szMsgBuf,
            "Error: unable to open file '%s'\n",
            (char *)lpszCmdLine);

        MessageBoxA(
            NULL,
            (char *)szMsgBuf,
            "Doh!",
            MB_OK);
    }
    else
    {

        while (NULL != fgets(szLineBuf, sizeof(szLineBuf), pfIn))
        {
            szLineBuf[39] = '\0';
            ++iKeyCnt;
            *(LPDWORD)abPid3 = sizeof(abPid3);

            fOk = PIDGen(
                &szLineBuf[10],                 // [IN] 25-character Secure CD-Key (gets U-Cased)
                "12345",                        // [IN] 5-character Release Product Code
                "123-12345",                    // [IN] Stock Keeping Unit (formatted like 123-12345)
                "MSFT",                         // [IN] 4-character OEM ID or NULL
                NULL,                           // [IN] 24-character ordered set to use for decode base conversion or NULL for default set (gets U-Cased)
                NULL,                           // [IN] pointer to optional public key or NULL
                0,                              // [IN] byte length of optional public key
                0,                              // [IN] key index of optional public key
                FALSE,                          // [IN] is this an OEM install?

                achPid2,                        // [OUT] PID 2.0, pass in ptr to 24 character array
                abPid3,                         // [OUT] pointer to binary PID3 buffer. First DWORD is the length.
                &dwSeq,                         // [OUT] optional ptr to sequence number (can be NULL)
                &fCCP,                          // [OUT] optional ptr to Compliance Checking flag (can be NULL)
                &fPSS);                         // [OUT] optional ptr to 'PSS Assigned' flag (can be NULL)

            if (fOk)
            {
                ++iValidCnt;
            }
            else
            {
                sprintf(
                    szMsgBuf,
                    "Warning: failure to validate %s\n",
                    &szLineBuf[10]);

                MessageBoxA(
                    NULL,
                    szMsgBuf,
                    "Doh!",
                    MB_OK);
            }
        }

        sprintf(
            szMsgBuf,
            "Info: %d successful validations out of %d Product Keys\n",
            (int)iValidCnt,
            (int)iKeyCnt);

        MessageBoxA(
            NULL,
            (char *)szMsgBuf,
            (iValidCnt == iKeyCnt) ? "Woo Hoo!" : "Doh!",
            MB_OK);
    }

#if 0 /////////////////////////////////

    FILE *pf = fopen("test.dpi", "wb");
    fwrite(pdp, sizeof(*pdp), 1, pf);
    fclose(pf);

    MessageBox(
        NULL,
        (char *)&abPid3[8],
        fOk ? "Woo Hoo!" : "Doh!",
        MB_OK);

    if (fOk)
    {
        MessageBox(
            NULL,
            (char *)pdp->aszHardwareIdStatic,
            "Woo Hoo!",
            MB_OK);

        char szMessage[128];

        wsprintf(
            szMessage,
            "seq: %ld, %s%s - lictype: %ld",
            dwSeq,
            (fCCP) ? "CCP" : "FPP",
            (fPSS) ? ", PSS" : "",
            (LONG)pdp->dwlt);

        MessageBox(
            NULL,
            szMessage,
            (char *)&abPid3[8],
            MB_OK);
    }

#endif ////////////////////////////////

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\pencrypt\pencrypt.c ===
#include <windows.h>
#include <malloc.h>
#include <string.h>
#include <wchar.h>
#include <WINSOCK2.H>
#include <Ws2tcpip.h>
#include <Wincrypt.h>
#include <setupbat.h>

// 40 bit key length
//#define KEYLENGTH	0x00280000
// 128 bit key length
//#define KEYLENGTH	0x00800000
// 56 bit key length needed to use DES.
//#define KEYLENGTH	0x00380000
// 168 bit key length needed to use 3DES.
#define KEYLENGTH	0x00A80000
#define CRYPT_PROV  MS_ENHANCED_PROV_A
#define ENCRYPT_ALGORITHM CALG_3DES
//CALG_RC4
#define IsSpace(c)  ((c) == ' '  ||  (c) == '\t'  ||  (c) == '\r'  ||  (c) == '\n'  ||  (c) == '\v'  ||  (c) == '\f')
#define IsDigit(c)  ((c) >= '0'  &&  (c) <= '9')
// 32 bytes of random password data, generated once using CryptGenRandom
BYTE iPassword[] =  {0xc7, 0x1e, 0x6a, 0xab, 0xe3, 0x8f, 0x76, 0x5b, 0x0d, 0x7b, 0xe0, 0xcb, 0xbf, 0x1c, 0xee, 0x54,
                     0x9d, 0x62, 0xbd, 0xb6, 0x6a, 0x38, 0x69, 0x4b, 0xe1, 0x44, 0x9b, 0x76, 0x4a, 0xe4, 0x79, 0xce};

//=================================================================================================
//
// copied from msdev\crt\src\atox.c
//
// long MyAtoL(char *nptr) - Convert string to long
//
// Purpose:
//       Converts ASCII string pointed to by nptr to binary.
//       Overflow is not detected. So that this lib does not need CRT
//
// Entry:
//       nptr = ptr to string to convert
//
// Exit:
//       return long int value of the string
//
// Exceptions:
//       None - overflow is not detected.
//
//=================================================================================================
long MyAtoL(const char *nptr)
{
    int c;                  /* current char */
    long total;             /* current total */
    int sign;               /* if '-', then negative, otherwise positive */

    // NOTE: no need to worry about DBCS chars here because IsSpace(c), IsDigit(c),
    // '+' and '-' are "pure" ASCII chars, i.e., they are neither DBCS Leading nor
    // DBCS Trailing bytes -- pritvi

    /* skip whitespace */
    while ( IsSpace((int)(unsigned char)*nptr) )
        ++nptr;

    c = (int)(unsigned char)*nptr++;
    sign = c;               /* save sign indication */
    if (c == '-' || c == '+')
        c = (int)(unsigned char)*nptr++;        /* skip sign */

    total = 0;

    while (IsDigit(c)) {
        total = 10 * total + (c - '0');         /* accumulate digit */
        c = (int)(unsigned char)*nptr++;        /* get next char */
    }

    if (sign == '-')
        return -total;
    else
        return total;   /* return result, negated if necessary */
}

// Check that the time/date field has only digits, as a validation that no one manipulated the data
BOOL OnlyDigits(LPSTR szValue)
{
    BOOL bRet = TRUE;
    LPSTR pTemp = szValue;
    while (*pTemp)
    {
        if (!IsDigit(*pTemp))
        {
            bRet = FALSE;
        }
        pTemp++;
    }
    return bRet;
}

// To decode and encode the binary buffer we get from the encyption function
unsigned char * base64decode (unsigned char * bufcoded, DWORD * plDecodedSize)
{
    int pr2six[256];
    int i;
    int j=0;
    unsigned char * cCurr = bufcoded;
    int bDone = FALSE;
    long lBufSize = 0;
    long lCount = 0;
    unsigned char * bufin;
    unsigned char * bufout;
    unsigned char * temp = NULL;    
    unsigned char * pBufDecoded = NULL;
    int lop_off;
    HRESULT hr = S_OK;

    //
    // Build up the reverse index from base64 characters to values
    // The multiple loops are easier
    //
    for (i=65; i<91; i++) {
         pr2six[i]=j++;
    }
    
    for (i=97; i<123; i++) {
         pr2six[i]=j++;
    }
    
    for (i=48; i<58; i++) {
        pr2six[i]=j++;
    }

    pr2six[43]=j++;
    pr2six[47]=j++;
    pr2six[61]=0;

    //
    // The old code relied on the size of the original data provided before 
    // the encoding. We don't have that, so we'll just allocate as much as 
    // the encoded data, relying on the fact that the encoded data is always 
    // larger. (+4 for good measure)
    // 
    lBufSize=lstrlenA((char *)cCurr)-1+4;
    *plDecodedSize = lBufSize;

    pBufDecoded = GlobalAlloc(GPTR, lBufSize);
    if(!pBufDecoded) 
    {
	    //_tprintf(_T("Out of memory."));
	    return NULL;
    }
    ZeroMemory(pBufDecoded, lBufSize);
        
    lCount = lstrlenA((char *)cCurr);

    // Do the decoding to new buffer
    bufin = cCurr;
    bufout = pBufDecoded;

    while(lCount > 0) {
        *(bufout++) = (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) = (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) = (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        lCount -= 4;
    }

    //
    // The line below does not make much sense since \0 is really a valid 
    // binary value, so we can't add it to our data stream
    //
    //*(bufout++) = '\0';
    
    //
    // Let's calculate the real size of our data
    //
    *plDecodedSize=(ULONG)(bufout-pBufDecoded);
    
    // 
    // if there were pads in the encoded stream, lop off the nulls the 
    // NULLS they created
    //
    lop_off=0;
    if (bufin[-1]=='=') lop_off++;
    if (bufin[-2]=='=') lop_off++;
    
    *plDecodedSize=*plDecodedSize-lop_off;

    temp = GlobalAlloc(GPTR, (*plDecodedSize) + 2);
    if (temp==NULL) 
    {
	    //_tprintf(_T("Out of memory."));
	    return NULL;
    }
    ZeroMemory(temp, *plDecodedSize);
    memcpy(temp, pBufDecoded, *plDecodedSize);

    temp[(*plDecodedSize)+0] = 0;
    temp[(*plDecodedSize)+1] = 0;

    if (pBufDecoded) {
        GlobalFree(pBufDecoded);
    }
    return temp; 
}

//
// the map for the encoder, according to RFC 1521
//
char _six2pr64[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};


unsigned char * base64encode(unsigned char * bufin, int nbytes)
{
    unsigned char *outptr;
    unsigned char *to_return;
    long i;
    long OutBufSize;
    char *six2pr = _six2pr64;


    //  
    // Size of input buffer * 133%
    //  
    OutBufSize = nbytes + ((nbytes + 3) / 3) + 5; 

    //
    //  Allocate buffer with 133% of nbytes
    //
    outptr = GlobalAlloc(GPTR,OutBufSize + 1);
    if(outptr==NULL) {
	//_tprintf(_T("Out of memory."));
	return NULL;
    }
    ZeroMemory(outptr, OutBufSize + 1);
    to_return = outptr;

    nbytes = nbytes - 3;
    //
    // Encode everything
    //  
    for (i=0; i<nbytes; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; // c2
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];// c3
      *(outptr++) = six2pr[bufin[2] & 077];                                  // c4 
      bufin += 3;
    }

    //
    // If nbytes was not a multiple of 3, then we have encoded too
    // many characters.  Adjust appropriately.
    //
    if(i == nbytes) {
	// There are 3 bytes in the last group
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; // c2
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];// c3
      *(outptr++) = six2pr[bufin[2] & 077];                                  // c4 
    } else if(i == nbytes+1) {
      // There are only 2 bytes in the last group 
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; // c2
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((0 >> 6) & 03)];	     // c3
      *(outptr++) = '=';
    } else if(i == nbytes+2) {
      // There are only 1 byte in the last group 
      *(outptr++) = six2pr[*bufin >> 2];                                     // c1 
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((0 >> 4) & 017)];	     // c2
      *(outptr++) = '=';
      *(outptr++) = '=';
    }

    *outptr = '\0';

    return to_return;
}


// Unicode Ansi conversion function
LPSTR _PEConvertW2A (
    IN      LPCWSTR Unicode,
    IN      UINT CodePage
    )
{
    LPSTR ansi = NULL;
    DWORD rc;

    if (Unicode)
    {
        rc = WideCharToMultiByte (
                CodePage,
                0,
                Unicode,
                -1,
                NULL,
                0,
                NULL,
                NULL
                );

        if (rc || *Unicode == L'\0') {

            ansi = (LPSTR)GlobalAlloc(GPTR, (rc + 1) * sizeof (CHAR));
            if (ansi) {
                rc = WideCharToMultiByte (
                        CodePage,
                        0,
                        Unicode,
                        -1,
                        ansi,
                        rc + 1,
                        NULL,
                        NULL
                        );

                if (!(rc || *Unicode == L'\0')) {
                    rc = GetLastError ();
                    GlobalFree((PVOID)ansi);
                    ansi = NULL;
                    SetLastError (rc);
                }
            }
        }
    }
    return ansi;
}

// Ansi Unicode conversion function
LPWSTR _PEConvertA2W (
    IN      LPCSTR Ansi,
    IN      UINT CodePage
    )
{
    PWSTR unicode = NULL;
    DWORD rc;

    if (Ansi)
    {
        rc = MultiByteToWideChar (
                CodePage,
                MB_ERR_INVALID_CHARS,
                Ansi,
                -1,
                NULL,
                0
                );

        if (rc || *Ansi == '\0') {

            unicode = (LPWSTR) GlobalAlloc (GPTR, (rc + 1) * sizeof (WCHAR));
            if (unicode) {
                rc = MultiByteToWideChar (
                        CodePage,
                        MB_ERR_INVALID_CHARS,
                        Ansi,
                        -1,
                        unicode,
                        rc + 1
                        );

                if (!(rc || *Ansi == '\0')) {
                    rc = GetLastError ();
                    GlobalFree ((PVOID)unicode);
                    unicode = NULL;
                    SetLastError (rc);
                }
            }
        }
    }
    return unicode;
}

// Ansi version to Encypt the input data.
// The encrypted and base 64 encoded buffer is allocated and returned to the caller.
// The caller needs to GloblaFree the buffer.
HRESULT EncryptDataA(LPSTR szInData, DWORD chSizeIn, LPSTR *szOutData)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    HCRYPTPROV hCryptProv; 
    HCRYPTKEY hKey; 
    HCRYPTHASH hHash; 
    LPSTR pw;
    PBYTE pbData = NULL;

    *szOutData = NULL;
    pw = GlobalAlloc(GPTR, sizeof(iPassword)+1);
    if (pw == NULL)
    {
        return hr;
    }
    memcpy(pw, iPassword, sizeof(iPassword));
    // Get handle to the default provider. 
    if(CryptAcquireContextA(
        &hCryptProv, 
        NULL, 
        CRYPT_PROV,
        PROV_RSA_FULL, 
        CRYPT_VERIFYCONTEXT))
    {
        hr = E_FAIL;
        if(CryptCreateHash(
                        hCryptProv, 
                        CALG_MD5, 
                        0, 
                        0, 
                        &hHash))
        {
            if(CryptHashData(hHash, 
                                (BYTE *)pw, 
                                lstrlenA(pw), 
                                0))
            {
                if(CryptDeriveKey(
                    hCryptProv, 
                    ENCRYPT_ALGORITHM, 
                    hHash, 
                    KEYLENGTH,
                    &hKey))
                {
                    DWORD dwCryptDataLen = chSizeIn;
                    DWORD dwDataLen  = dwCryptDataLen;
                    CryptEncrypt(
                        hKey, 
                        0, 
                        TRUE, 
                        0, 
                        NULL, 
                        &dwCryptDataLen, 
                        dwDataLen);

                    pbData = GlobalAlloc(GPTR, dwCryptDataLen+1);
                    if (pbData != NULL)
                    {
                        memcpy(pbData, szInData, chSizeIn);
                        // size of the buffer
                        dwDataLen  = dwCryptDataLen;
                        // number of bytes to be encrypted
                        dwCryptDataLen = chSizeIn;

                        if(CryptEncrypt(
                            hKey, 
                            0, 
                            TRUE, 
                            0, 
                            pbData, 
                            &dwCryptDataLen, 
                            dwDataLen))
                        {
                            *szOutData = base64encode(pbData, (int)dwCryptDataLen);
                            if (*szOutData)
                            {
                                hr = S_OK;
                            }
                        }
					    else
					    {
						    hr = GetLastError();
					    }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                    }
                    CryptDestroyKey(hKey);
                }
				else
				{
					hr = GetLastError();
				}
            }
			else
			{
				hr = GetLastError();
			}
            CryptDestroyHash(hHash);
        }
		else
		{
			hr = GetLastError();
		}
        CryptReleaseContext(hCryptProv, 0);
    }
	else
	{
		hr = GetLastError();
	}

    if (pbData)
    {
        GlobalFree(pbData);
    }
    GlobalFree(pw);
    return hr;
}

// Unicode version to Encypt the input data.
// Converts the in data to Ansi and calls the Ansi version and converts the out data to unicode
// and returns the buffer to the caller.
HRESULT EncryptDataW(LPWSTR szInData, DWORD chSizeIn, LPWSTR *szOutData)
{
    HRESULT hr = E_FAIL;
    LPBYTE pBuffer = NULL;
    LPSTR  szData = NULL;

    *szOutData = NULL;
    pBuffer = (LPBYTE)_PEConvertW2A (szInData, CP_ACP);
    if (pBuffer == NULL)
    {
        return hr;
    }

    if ((hr = EncryptDataA(pBuffer, lstrlenA(pBuffer)+1, &szData)) == S_OK)
    {
        *szOutData = _PEConvertA2W (szData, CP_ACP);
        if ((*szOutData) == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        GlobalFree(szData);
    }
    GlobalFree(pBuffer);

    return hr;
}

HRESULT DecryptDataA(LPSTR szInData, LPSTR *szOutData)
{
    HRESULT hr = E_FAIL;
    HCRYPTPROV hCryptProv;
    HCRYPTKEY hKey; 
    HCRYPTHASH hHash; 
    DWORD dwErr;
    DWORD dwCipherTextLen = lstrlenA(szInData);
    char *pw;
    DWORD dwCount;
    char *pBuffer;

    *szOutData = NULL;

    pw = GlobalAlloc(GPTR, sizeof(iPassword)+1);
    if (pw == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        return hr;
    }
    memcpy(pw, iPassword, sizeof(iPassword));

	pBuffer = (char *) (base64decode((unsigned char *)szInData, &dwCount));
    if (pBuffer == NULL)
    {
        GlobalFree(pw);
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        return hr;
    }

    // Get a handle to the default provider. 
    if(CryptAcquireContextA(
        &hCryptProv, 
        NULL, 
        CRYPT_PROV,
        PROV_RSA_FULL, 
        CRYPT_VERIFYCONTEXT))
    {
        hr = E_FAIL;
        // Create a hash object. 
        if(CryptCreateHash(
            hCryptProv, 
            CALG_MD5, 
            0, 
            0, 
            &hHash))
        {
            if(CryptHashData(hHash, 
                                (BYTE *)pw, 
                                lstrlenA(pw), 
                                0))
            {
                if(CryptDeriveKey(
                    hCryptProv, 
                    ENCRYPT_ALGORITHM, 
                    hHash, 
                    KEYLENGTH,
                    &hKey))
                {
                    // pBuffer is bigger when the data is encrypted.
                    // The decrypted data (on output) is smaller, because we are using
                    // a block cyoher at encryption.
                    if(CryptDecrypt(
                        hKey, 
                        0, 
                        TRUE, 
                        0, 
                        pBuffer, 
                        &dwCount))
                    {
                        *szOutData = GlobalAlloc(GPTR, dwCount+1);
                        if (*szOutData)
                        {
                            // lstrcpyn includes the NULL in the count and makes sure there is one.
                            lstrcpynA(*szOutData, pBuffer, dwCount+1);
                            hr = S_OK;
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
                        }
                    }
                    else
                    {
                        hr = GetLastError();
                    }
                    CryptDestroyKey(hKey); 
                }
                else
                {
                    hr = GetLastError();
                }

            }
            else
            {
                hr = GetLastError();
            }
            CryptDestroyHash(hHash); 
            hHash = 0; 

        }
        else
        {
            hr = GetLastError();
        }
        CryptReleaseContext(hCryptProv, 0); 
    }
    else
    {
        hr = GetLastError();
    }
    GlobalFree(pBuffer);
    GlobalFree(pw);
    return hr;

}

HRESULT DecryptDataW(LPWSTR szInData, LPWSTR *szOutData)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    LPBYTE pBuffer = NULL;
    LPSTR  szData = NULL;

    *szOutData = NULL;
    pBuffer = (LPBYTE)_PEConvertW2A (szInData, CP_ACP);
    if (pBuffer == NULL)
    {
        return hr;
    }
    if ((hr = DecryptDataA(pBuffer, &szData)) == S_OK)
    {
        *szOutData = _PEConvertA2W (szData, CP_ACP);
        if ((*szOutData) == NULL)
        {
            hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
        }
        GlobalFree(szData);
    }
    GlobalFree(pBuffer);

    return hr;
}


#define _SECOND             ((__int64) 10000000)
#define _MINUTE             (60 * _SECOND)
#define _HOUR               (60 * _MINUTE)
#define _DAY                (24 * _HOUR)

// encode the position of the PID character. 0 is for the dashes
int iPID[] = {3  ,251,43 ,89 ,75,0,
              123,35 ,23 ,97 ,77,0,
              5  ,135,189,213,13,0,
              245,111,91 ,71 ,65,0,
              25 ,49 ,81 ,129,239};
int iTime1[] = {253, 247, 233, 221, 211, 191, 181, 171, 161, 151, 141, 131, 121, 112, 101, 93, 80, 70, 61, 51};
int iTime2[] = {250, 242, 237, 225, 215, 195, 185, 175, 165, 155, 145, 137, 125, 115, 105, 95, 85, 73, 67, 55};

HRESULT PrepareEncryptedPIDA(LPSTR szPID, UINT uiDays, LPSTR *szOut)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    HCRYPTPROV   hCryptProv;
    FILETIME ft1, ft2;
    LONGLONG ll;
    LONGLONG ll2;
    char szLine[256];

    GetSystemTimeAsFileTime(&ft1);
    ll = ((LONGLONG)ft1.dwHighDateTime << 32) + ft1.dwLowDateTime;
    ll2 = ll - (_HOUR*12); // Substract 12 hours
    ll += (uiDays*_DAY) + (_HOUR*24); // Add 24 hours

    ft1.dwLowDateTime = (DWORD)ll2;
    ft1.dwHighDateTime = (DWORD)(ll2 >> 32);

    ft2.dwLowDateTime = (DWORD)ll;
    ft2.dwHighDateTime = (DWORD)(ll >> 32);

    // Build a 256 character string that we encode. In the 256 character strign we hide
    // the PID and the time/date info for the interval the encypted data is valid.
    // We need 20 characters each for the start and end of the time interval
    // and we need 25 characters for the PID. 20+20+25 = 65 characters. All other characters
    // are random.
    // 1. fill the string with random characters
    // 2. replace some with the PID charactes
    // 3. replace some with the time/date info
    if(CryptAcquireContextA(&hCryptProv, NULL, NULL, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) 
    {
        int i;
        hr = S_OK;
        if(!CryptGenRandom(hCryptProv, sizeof(szLine), (PBYTE)szLine)) 
        {
            hr = GetLastError();
        }
        CryptReleaseContext(hCryptProv, 0);
        // in the case the random generator create 0x0 we want to replace it with 
        // some value, otherwise we cannot use it as a character string,
        // the string would be terminated.
        for (i = 0; i < sizeof(szLine); i++)
        {
            if (szLine[i] == '\0')
            {
                szLine[i] = 0x01;
            }
        }
        szLine[i-1] = '\0';   // Make sure we have a terminated string.
    }
    if (hr == S_OK)
    {
        char szTime[21];    // 10 digits for dwHighDateTime and 10 for dwLowDateTime + termination
        // The buffer is filled with random characters
        // Now insert the PID characters
        int i = 0;
        while (szPID[i])
        {
            if (szPID[i] != '-')
            {
                szLine[iPID[i]] = szPID[i];
            }
            i++;
        }
        // Now fill in the time-date info
        wsprintf(szTime, "%010lu%010lu", ft1.dwHighDateTime, ft1.dwLowDateTime);
        i = 0;
        while (szTime[i])
        {
            szLine[iTime1[i]] = szTime[i];
            i++;
        }
        wsprintf(szTime, "%010lu%010lu", ft2.dwHighDateTime, ft2.dwLowDateTime);
        i = 0;
        while (szTime[i])
        {
            szLine[iTime2[i]] = szTime[i];
            i++;
        }
        // szLine has the mengled data in it. Pass it to the encryption.
        hr = EncryptDataA(szLine, sizeof(szLine), szOut);
    }
    return hr;
}

HRESULT PrepareEncryptedPIDW(LPWSTR szPID, UINT uiDays, LPWSTR *szOutData)
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    LPSTR  pPID = NULL;
    LPSTR  szOut = NULL;

    *szOutData = NULL;
    pPID = _PEConvertW2A (szPID, CP_ACP);
    if (pPID != NULL)
    {
        hr = PrepareEncryptedPIDA(pPID, uiDays, &szOut);
        if (hr == S_OK)
        {
            *szOutData = _PEConvertA2W (szOut, CP_ACP);
            if (*szOutData)
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
            }
            GlobalFree(szOut);
        }
        GlobalFree(pPID);
    }
    return hr;
}

HRESULT ValidateEncryptedPIDA(LPSTR PID, LPSTR *szOutData)
{
    HRESULT hr = E_FAIL;
	LPSTR szDecrypt = NULL;
    FILETIME ft, ftCurrent;
    LONGLONG ll1, ll2, llCurrent;
    int   iCount = 0;
    char  szPID[(5*5)+5]; // 5 characters 5 times + '-' inbetween + termimation
    char  szTime[11];       // each part of hte time is 10 digits + termination

    GetSystemTimeAsFileTime(&ftCurrent);
    hr = DecryptDataA(PID, &szDecrypt);
    if (hr == S_OK)
    {
        int i = 0;
        hr = 0x01;
        // Extract the time values first.
        while (i < 10)
        {
            szTime[i] = szDecrypt[iTime1[i]];
            i++;
        }
        szTime[10] = '\0';
        if (OnlyDigits(szTime))       // 1. time
        {
            ft.dwHighDateTime = MyAtoL(szTime);
            while (i < 20)
            {
                szTime[i-10] = szDecrypt[iTime1[i]];
                i++;
            }
            szTime[10] = '\0';
            if (OnlyDigits(szTime))
            {
                ft.dwLowDateTime = MyAtoL(szTime);
                ll1 = ((LONGLONG)ft.dwHighDateTime << 32) + ft.dwLowDateTime;
                ll1 = ll1 /_HOUR; // FileTime in hours;
                hr = S_OK;
            }
        }
        if (hr == S_OK)
        {
            hr = 0x02;
            i = 0;
            while (i < 10)
            {
                szTime[i] = szDecrypt[iTime2[i]];
                i++;
            }
            szTime[10] = '\0';
            if (OnlyDigits(szTime))       // 1. time
            {
                ft.dwHighDateTime = MyAtoL(szTime);
                while (i < 20)
                {
                    szTime[i-10] = szDecrypt[iTime2[i]];
                    i++;
                }
                szTime[10] = '\0';
                if (OnlyDigits(szTime))
                {
                    ft.dwLowDateTime = MyAtoL(szTime);
                    ll2 = ((LONGLONG)ft.dwHighDateTime << 32) + ft.dwLowDateTime;
                    ll2 = ll2 /_HOUR; // FileTime in hours;
                    hr = S_OK;
                }
            }
        }
        if (hr == S_OK)
        {
            // Now that we have the time values, compare them and make sure that the current
            // time falls inside the time interval.
            hr = 0x03;
            llCurrent = ((LONGLONG)ftCurrent.dwHighDateTime << 32) + ftCurrent.dwLowDateTime;
            llCurrent = llCurrent /_HOUR; // FileTime in hours;

            if ((ll1 <= llCurrent) && ( llCurrent <= ll2))
            {
                i = 0;
                // Time is OK.
                // Extract the PID
           