    if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
        {
            if (!CallbackRegistered())
            {
                _pRequest->SetPPAbort(TRUE);
                dwRet = ERROR_INTERNET_LOGIN_FAILURE;
                goto exit;
            }
        }
        
        ::InternetIndicateStatusString(INTERNET_STATUS_REDIRECT, pszUrl);
    }
    else
    {
        if (!fRetrySameUrl)
        {
            if (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_AUTO_REDIRECT)
            {
                if (!CallbackRegistered())
                {
                    dwRet = ERROR_INTERNET_LOGIN_FAILURE;
                    goto exit;
                }

                ::InternetIndicateStatusString(INTERNET_STATUS_REDIRECT, pszUrl);
            }
        }
    }
    
    PCSTR lpszRetUrl = NULL;
    
    lpszRetUrl = fRetrySameUrl ? _pRequest->GetURL() : pszUrl;

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    m_lpszRetUrl = new CHAR[strlen(lpszRetUrl) + 1];
    if (m_lpszRetUrl)
    {
        strcpy(m_lpszRetUrl, lpszRetUrl);
    }

exit:
    if (pwszUrl)
    {
        FREE_MEMORY(pwszUrl);
    }
    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }

    return dwRet;
}

DWORD PASSPORT_CTX::SetCreds(BOOL* pfCredSet)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fUseDefaultCreds;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;
    
    AuthLock();
    
    if (_pPWC->lpszUser && _pPWC->lpszPass)
    {
        if (_pPWC->lpszUser[0] || _pPWC->lpszPass[0]) // either user pass is not blank -> don't use default creds
        {
            fUseDefaultCreds = FALSE;
        }
        else // both user and pass are blank -> use default creds
        {
            fUseDefaultCreds = TRUE;
        }
    }
    else
    {
        fUseDefaultCreds = TRUE;
    }

    if (!fUseDefaultCreds)
    {
        pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pPWC->lpszUser) + 1) * sizeof(WCHAR));
        pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pPWC->lpszPass) + 1) * sizeof(WCHAR));

        if (pwszUser && pwszPass)
        {
            ::MultiByteToWideChar(CP_ACP, 0, _pPWC->lpszUser, -1, pwszUser, strlen(_pPWC->lpszUser) + 1);
            ::MultiByteToWideChar(CP_ACP, 0, _pPWC->lpszPass, -1, pwszPass, strlen(_pPWC->lpszPass) + 1);
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }

        INET_ASSERT(m_pCredTimestamp != NULL);
    }

    AuthUnlock();

    if (dwError == ERROR_SUCCESS)
    {
        *pfCredSet = ::PP_SetCredentials(m_hLogon, m_wRealm, m_wTarget, pwszUser, pwszPass, m_pCredTimestamp);
    }

    if (pwszUser)
        FREE_MEMORY(pwszUser);
    if (pwszPass)
        FREE_MEMORY(pwszPass);
    
    return dwError;
}

DWORD PASSPORT_CTX::ModifyRequestBasedOnRU(void)
{
    DWORD dwError = ERROR_SUCCESS;
    
    INTERNET_SCHEME schemeType;
    INTERNET_SCHEME currentSchemeType;
    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;

    INTERNET_PORT port = 0;
    LPSTR pszHostName;
    DWORD dwHostNameLength = 0;
    LPSTR pszUrlPath;
    DWORD dwUrlPathLength = 0;
    LPSTR extra;
    DWORD extraLength;

    dwError = CrackUrl(m_lpszRetUrl,
             0,
             FALSE, // don't escape URL-path
             &schemeType,
             NULL,  // scheme name, don't care
             NULL,
             &pszHostName,
             &dwHostNameLength,
             &port,
             NULL,  // UserName, don't care
             NULL,  
             NULL,  // Password, don't care
             NULL,
             &pszUrlPath,
             &dwUrlPathLength,
             &extra,
             &extraLength,
             NULL);

    if (dwError != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    //
    // if there is an intra-page link on the redirected URL then get rid of it:
    // we don't send it to the server, and we have already indicated it to the
    // app
    //

    if (extraLength != 0) {

        INET_ASSERT(extra != NULL);
        INET_ASSERT(!IsBadWritePtr(extra, 1));

        if (*extra == '#') {
            *extra = '\0';
            // newUrlLength -= extraLength;
        } else {
            dwUrlPathLength += extraLength;
        }
    }

    if (port == INTERNET_INVALID_PORT_NUMBER) {
        port = (schemeType == INTERNET_SCHEME_HTTPS)
            ? INTERNET_DEFAULT_HTTPS_PORT
            : INTERNET_DEFAULT_HTTP_PORT;
    }

    currentHostPort = _pRequest->GetHostPort();
    currentHostName = _pRequest->GetHostName(&currentHostNameLength);

    if (port != currentHostPort) {
        _pRequest->SetHostPort(port);
    }
    if ((dwHostNameLength != currentHostNameLength)
    || (strnicmp(pszHostName, currentHostName, dwHostNameLength) != 0)) {

        char hostValue[INTERNET_MAX_HOST_NAME_LENGTH + sizeof(":4294967295")];
        LPSTR hostValueStr;
        DWORD hostValueSize; 

        CHAR chBkChar = pszHostName[dwHostNameLength]; // save off char

        pszHostName[dwHostNameLength] = '\0';
        _pRequest->SetHostName(pszHostName);

        hostValueSize = dwHostNameLength;
        hostValueStr = pszHostName;            

        if ((port != INTERNET_DEFAULT_HTTP_PORT)
        &&  (port != INTERNET_DEFAULT_HTTPS_PORT)) {
            if (hostValueSize > INTERNET_MAX_HOST_NAME_LENGTH)
            {
                pszHostName[dwHostNameLength] = chBkChar; // put back char
                dwError = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            hostValueSize = wsprintf(hostValue, "%s:%d", pszHostName, (port & 0xffff));
            hostValueStr = hostValue;
        }

        pszHostName[dwHostNameLength] = chBkChar; // put back char

        //
        // replace the "Host:" header
        //

        _pRequest->ReplaceRequestHeader(HTTP_QUERY_HOST,
                             hostValueStr,
                             hostValueSize,
                             0, // dwIndex
                             ADD_HEADER
                             );

        //
        // and get the corresponding server info, resolving the name if
        // required
        //

        _pRequest->SetServerInfo(FALSE);

        //
        // Since we are redirecting to a different host, force an update of the origin
        // server.  Otherwise, we will still pick up the proxy info of the first server.
        //
        _pRequest->SetOriginServer(TRUE);
    }

    currentSchemeType = ((INTERNET_FLAG_SECURE & _pRequest->GetOpenFlags()) ?
                            INTERNET_SCHEME_HTTPS :
                            INTERNET_SCHEME_HTTP);

    if ( currentSchemeType != schemeType )
    {
        DWORD OpenFlags = _pRequest->GetOpenFlags();

        // Switched From HTTPS to HTTP
        if ( currentSchemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(schemeType != INTERNET_SCHEME_HTTPS );

            OpenFlags &= ~(INTERNET_FLAG_SECURE);
        }

        // Switched From HTTP to HTTPS
        else if ( schemeType == INTERNET_SCHEME_HTTPS )
        {
            INET_ASSERT(currentSchemeType == INTERNET_SCHEME_HTTP );

            OpenFlags |= (INTERNET_FLAG_SECURE);
        }

        _pRequest->SetOpenFlags(OpenFlags);
        _pRequest->SetSchemeType(schemeType);

    }

    _pRequest->SetURL(m_lpszRetUrl);

    if (_pRequest->IsRequestUsingProxy())
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 m_lpszRetUrl,
                                 strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }
    else
    {
        _pRequest->ModifyRequest(_pRequest->GetMethodType(),
                                 pszUrlPath, // m_lpszRetUrl,
                                 strlen(pszUrlPath),//strlen(m_lpszRetUrl),
                                 NULL,
                                 0);
    }

cleanup:

    return dwError;
}

/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::PreAuthUser",
        "this=%#x pBuf=%#x pcbBuf=%#x {%d}",
        this,
        pBuf,
        pcbBuf,
        *pcbBuf
        ));

    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pwszFromPP = NULL;
    BOOL bGetCbText;

    // Prefix the header value with the auth type.
    const static BYTE szPassport[] = "Passport1.4 ";
    #define PASSPORT_LEN sizeof(szPassport)-1
    
    if (m_pszFromPP == NULL) 
    {
        if (m_hLogon == NULL)
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto cleanup;
        }

        DWORD dwFromPPLen = 0;
        BOOL fCredSet;
        dwError = SetCreds(&fCredSet);
        if (dwError != ERROR_SUCCESS)
        {
            goto cleanup;
        }

        LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
        m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
        ::InternetSetThreadInfo(m_pNewThreadInfo);

        DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                         FALSE,
                                         0,
                                         NULL,
                                         0);

        ::InternetSetThreadInfo(pCurrentThreadInfo);

        IndicatePrivacyEvents();

        if (dwLogonStatus != PP_LOGON_SUCCESS)
        {
            if (dwLogonStatus == PP_LOGON_REQUIRED)
            {
                m_hBitmap = NULL;

                if (m_pwszReqUserName)
                {
                    delete[] m_pwszReqUserName;
                    m_pwszReqUserName = NULL;
                }
                m_dwReqUserNameLen = 0;

                bGetCbText = (m_pwszCbText == NULL);
                //Get the size of CbText and UserName;
                ::PP_GetChallengeInfo(m_hLogon, 
                    NULL, NULL, NULL, (bGetCbText? &m_dwCbTextLen : NULL), NULL, 0,
                    NULL, &m_dwReqUserNameLen);
                
                if (bGetCbText)
                    m_pwszCbText = new WCHAR[m_dwCbTextLen + 1];

                m_pwszReqUserName = new WCHAR[m_dwReqUserNameLen + 1];

                if ((bGetCbText && !m_pwszCbText) || !m_pwszReqUserName)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanup;
                }

                ::PP_GetChallengeInfo(m_hLogon, 
                    &m_hBitmap, NULL, (bGetCbText ? m_pwszCbText : NULL), (bGetCbText ? &m_dwCbTextLen : NULL), 
                    m_wRealm, MAX_AUTH_REALM_LEN, m_pwszReqUserName, &m_dwReqUserNameLen);
            }
            else if (dwLogonStatus == PP_LOGON_FAILED)
            {

                m_fPreauthFailed = TRUE;
            }
            
            dwError = ERROR_INTERNET_INTERNAL_ERROR; // need to double check this return error
            // m_fCredsBad = TRUE;
            goto cleanup;
        }

        dwError = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, TRUE);

        if (dwError == ERROR_INTERNET_LOGIN_FAILURE)
        {
            goto cleanup;
        }

        m_pszFromPP = new CHAR [dwFromPPLen];
        if (m_pszFromPP == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        
        ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
    }

    // check to see if we need to update url

    if (m_lpszRetUrl)
    {
        dwError = ModifyRequestBasedOnRU();

        if (dwError != ERROR_SUCCESS)
        {
            delete [] m_lpszRetUrl;
            m_lpszRetUrl = NULL;
            
            goto cleanup;
        }
        
        delete [] m_lpszRetUrl;
        m_lpszRetUrl = NULL;
    }
    
    // Ticket and profile is already present
    
    // put in the header
    memcpy (pBuf, szPassport, PASSPORT_LEN);
    pBuf += PASSPORT_LEN;
    
    // append the ticket
    strcpy(pBuf, m_pszFromPP);
    *pcbBuf = (DWORD)(PASSPORT_LEN + strlen(m_pszFromPP));

cleanup:
    if (pwszFromPP)
        delete [] pwszFromPP;
    
    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PPEscapeUrl(LPCSTR lpszStringIn,
                 LPSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags);

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::UpdateFromHeaders", 
        "this=%#x request=%#x isproxy=%B",
        this,
        pRequest,
        fIsProxy
        ));

    DWORD dwAuthIdx, cbChallenge, dwError;
    LPSTR szChallenge = NULL;

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = NULL;
    LPINTERNET_THREAD_INFO pNewThreadInfo = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get the complete auth header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL, 
        &szChallenge, &cbChallenge, ALLOCATE_BUFFER, dwAuthIdx);

    if (dwError != ERROR_SUCCESS)
    {
        szChallenge = NULL;
        goto exit;
    }

    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    {
        LPSTR lpszVerb;
        DWORD dwVerbLength;
        lpszVerb = _pRequest->_RequestHeaders.GetVerb(&dwVerbLength);
        #define MAX_VERB_LENGTH 16
        CHAR szOrgVerb[MAX_VERB_LENGTH] = {0};
        if (dwVerbLength > MAX_VERB_LENGTH - 1)
        {
            goto exit;
        }
        strncpy(szOrgVerb, lpszVerb, dwVerbLength+1);

        // HTTP_METHOD_TYPE tOrgMethod = _pRequest->GetMethodType();
        // PCSTR pszOrgVerb;
        // ::MapHttpMethodType(tOrgMethod, &pszOrgVerb);
        PCSTR pszOrgUrl = _pRequest->GetURL();

        /*
        DWORD dwEscUrlLen = strlen(pszOrgUrl) * 3 + 1;
        DWORD dwEscUrlLenOut;
        PSTR pszEscapedUrl = new CHAR[dwEscUrlLen]; // should be long enough
        if (pszEscapedUrl == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        
        PPEscapeUrl(pszOrgUrl, pszEscapedUrl, &dwEscUrlLenOut, dwEscUrlLen, 0);
        
        EncodeUrlPath(NO_ENCODE_PATH_SEP,
                      SCHEME_HTTP,
                      (PSTR)pszOrgUrl,
                      strlen(pszOrgUrl),
                      pszEscapedUrl, 
                      &dwEscUrlLen);
        */

        const LPWSTR pwszOrgVerbAttr = L",OrgVerb=";
        const LPWSTR pwszOrgUrlAttr =  L",OrgUrl=";

        DWORD dwPartnerInfoLength = cbChallenge 
                                    +::wcslen(pwszOrgVerbAttr)
                                    +::strlen(szOrgVerb)
                                    +::wcslen(pwszOrgUrlAttr)
                                    +::strlen(pszOrgUrl)
                                    + 1; // NULL terminator
        
        DWORD dwSize = 0;
        PWSTR pwszPartnerInfo = NULL;

        m_pwszPartnerInfo = new WCHAR[dwPartnerInfoLength];
        if (m_pwszPartnerInfo == NULL)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            // delete [] pszEscapedUrl;
            goto exit;
        }

        pwszPartnerInfo = m_pwszPartnerInfo;

        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szChallenge, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgVerbAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgVerbAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgVerbAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, szOrgVerb, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;
        ::wcscat(pwszPartnerInfo, pwszOrgUrlAttr);
        pwszPartnerInfo += (dwSize + wcslen(pwszOrgUrlAttr));
        dwPartnerInfoLength -= (dwSize + wcslen(pwszOrgUrlAttr));
        dwSize = ::MultiByteToWideChar(CP_ACP, 0, pszOrgUrl, -1, pwszPartnerInfo, dwPartnerInfoLength) - 1;

        // delete [] pszEscapedUrl;

        dwError = ERROR_SUCCESS;
    }

exit:

    if (szChallenge)
        delete []szChallenge;

    DEBUG_LEAVE(dwError);
    return dwError;
}

BOOL PASSPORT_CTX::InitLogonContext(void)
{
    PP_CONTEXT hPP = 0; 

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);

    if (!m_hPP)
    {
        hPP = ::PP_InitContext(L"WinInet.Dll", NULL); // the Passport package does not support Async yet, so we'll have to 
        m_hPP = hPP;                                              // create a new Passport Session here.

        PCWSTR pwszRealm = ::wcsstr(m_pwszPartnerInfo, L"srealm");
        if (pwszRealm)
        {
            pwszRealm += ::wcslen(L"srealm");
            if (*pwszRealm == L'=')
            {
                pwszRealm++;
                DWORD i = 0;
                while (*pwszRealm != 0 && *pwszRealm != L',' && i < MAX_AUTH_REALM_LEN-1)
                {
                    m_wRealm[i++] = *pwszRealm++;
                }

                m_wRealm[i] = 0; // null-terminate it
            }
        }

        if (!m_wRealm[0])
        {
            DWORD dwRealmLen = MAX_AUTH_REALM_LEN;
            PP_GetRealm(hPP, m_wRealm, &dwRealmLen);
        }
    }
    
    if (!m_hLogon)
    {
        m_hLogon = ::PP_InitLogonContext(
            hPP,
            m_pwszPartnerInfo,
            (_pRequest->GetOpenFlags() & INTERNET_FLAG_NO_COOKIES)
            );
    }

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    return (m_hLogon != NULL);
}
/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD PASSPORT_CTX::PostAuthUser()
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::PostAuthUser",
        "this=%#x",
        this
        ));

    DWORD dwRet;
    BOOL bGetCbText;

    InitLogonContext();
    
    if (m_fPreauthFailed)
    {
        m_fPreauthFailed = FALSE; // reset the flag

        _pRequest->SetStatusCode(401);

        Transfer401ContentFromPP();
        dwRet = ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;
    
        DEBUG_LEAVE(dwRet);
        return dwRet;
    }

    if (m_hLogon == NULL)
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    /*
    if (_pPWC->lpszUser && _pPWC->lpszPass)
    {
        if (!m_fAuthDeferred)
        {
            dwRet = ERROR_INTERNET_FORCE_RETRY;
            m_fAuthDeferred = TRUE;
        }
        else
        {
            dwRet = ERROR_INTERNET_LOGIN_FAILURE;
        }

        _pRequest->SetStatusCode(401);

        return dwRet;
    }
    */
    
    BOOL fCredSet;
    dwRet = SetCreds(&fCredSet);
    if (dwRet != ERROR_SUCCESS)
    {
        DEBUG_LEAVE(dwRet);
        return dwRet;
    }
    
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    DWORD dwLogonStatus = ::PP_Logon(m_hLogon,
                                     m_fAnonymous,
                                     0, 
                                     NULL, 
                                     0);

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    IndicatePrivacyEvents();

    if (dwLogonStatus == PP_LOGON_REQUIRED /*|| dwLogonStatus == PP_LOGON_FAILED*/)
    {
        // change from 302 to 401
        _pRequest->ReplaceResponseHeader(HTTP_QUERY_STATUS_CODE,
                                        "401", strlen("401"),
                                        0, HTTP_ADDREQ_FLAG_REPLACE);

        // biaow-todo: 1) nice to replace the status text as well; weird to have "HTTP/1.1 401 object moved"
        // for example 2) remove the Location: header
        _pRequest->SetStatusCode(401);

        BOOL fPrompt;

        m_hBitmap = NULL;

        bGetCbText = (m_pwszCbText == NULL);

        if (m_pwszReqUserName)
        {
            delete[] m_pwszReqUserName;
            m_pwszReqUserName = NULL;
        }
        m_dwReqUserNameLen = 0;

        //Get the size of CbText and UserName;
        ::PP_GetChallengeInfo(m_hLogon, 
            NULL, NULL, NULL, (bGetCbText ? &m_dwCbTextLen : NULL), NULL, 0,
            NULL, &m_dwReqUserNameLen);
        
        if (bGetCbText)
            m_pwszCbText = new WCHAR[m_dwCbTextLen + 1];

        m_pwszReqUserName = new WCHAR[m_dwReqUserNameLen + 1];

        if (!m_pwszCbText || !m_pwszReqUserName)
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
            ::PP_GetChallengeInfo(m_hLogon, 
                &m_hBitmap, &fPrompt, (bGetCbText ? m_pwszCbText : NULL), (bGetCbText ? &m_dwCbTextLen : NULL),
                m_wRealm, MAX_AUTH_REALM_LEN, m_pwszReqUserName, &m_dwReqUserNameLen);

        if (/*::PP_SetCredentials(m_hLogon, m_wRealm, m_wTarget, NULL, NULL, NULL) == FALSE ||*/
            fPrompt)
        {
            dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
        }
        else
        {

            if (m_fAnonymous)
            {
                if (fCredSet)
                {
                    dwRet = ERROR_INTERNET_FORCE_RETRY;
                }
                else
                {
                    dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
                }

                m_fAnonymous = FALSE;
            }
            else
            {
                dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
            }
        }
        /*
        else
        {
            // we are not forced to prompt AND we have a cached credentials.

            if (m_fCredsBad)
            {
                dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
            }
            else
            {
                dwRet = ERROR_INTERNET_FORCE_RETRY;
            }
        }
        */

        if (dwRet == ERROR_INTERNET_INCORRECT_PASSWORD)
        {
            Transfer401ContentFromPP();
        }
        // dwRet = ERROR_INTERNET_INCORRECT_PASSWORD;
        // Transfer401ContentFromPP();
    }
    else if (dwLogonStatus == PP_LOGON_SUCCESS)
    {
        DWORD dwFromPPLen = 0;
        LPWSTR pwszFromPP = NULL;

        dwRet = HandleSuccessfulLogon(&pwszFromPP, &dwFromPPLen, FALSE);
        if (dwRet != ERROR_INTERNET_LOGIN_FAILURE)
        {
            if (m_pszFromPP)
            {
                delete [] m_pszFromPP;
            }

            m_pszFromPP = new CHAR [dwFromPPLen];
            if (m_pszFromPP)
            {
                ::WideCharToMultiByte(CP_ACP, 0, pwszFromPP, -1, m_pszFromPP, dwFromPPLen, NULL, NULL);
            }
        }
        if (pwszFromPP)
        {
            delete [] pwszFromPP;
        }

        m_fAnonymous = FALSE;
    }
    else
    {
        _pRequest->SetStatusCode(401);

        Transfer401ContentFromPP();

        dwRet = ERROR_INTERNET_LOGIN_FAILURE_DISPLAY_ENTITY_BODY;
    }

    DEBUG_LEAVE(dwRet);
    return dwRet;
}

BOOL PASSPORT_CTX::Transfer401ContentFromPP(void)
{
    DWORD ContentLength = 0;
    ::PP_GetChallengeContent(m_hLogon, 
                             NULL,
                             &ContentLength);
    if (ContentLength > 0)
    {
        LPBYTE pContent = (LPBYTE)ALLOCATE_FIXED_MEMORY(ContentLength);
        if (pContent == NULL)
        {
            return FALSE;
        }

        if (::PP_GetChallengeContent(m_hLogon, 
                             pContent,
                             &ContentLength) == TRUE)
        {
            BOOL fDrained;
            
            // play with socket mode to force DrainResponse to return synchronously

            ICSocket* pSocket = _pRequest->_Socket;
            if (pSocket)
            {
                BOOL fSocketModeSet = FALSE;
                if (pSocket->IsNonBlocking())
                {
                    pSocket->SetNonBlockingMode(FALSE);
                    fSocketModeSet = TRUE;
                }

                INET_ASSERT(pSocket->IsNonBlocking() == FALSE);

                _pRequest->DrainResponse(&fDrained);

                if (fSocketModeSet)
                {
                    pSocket->SetNonBlockingMode(TRUE);
                }
            }

            _pRequest->_ResponseHeaders.FreeHeaders();
            _pRequest->FreeResponseBuffer();
            _pRequest->ResetResponseVariables();
            _pRequest->_ResponseHeaders.Initialize();

            // _pRequest->_dwCurrentStreamPosition = 0;

            _pRequest->CloneResponseBuffer(pContent, ContentLength);
        }
        FREE_MEMORY(pContent);
    }

    return TRUE;
}

/*---------------------------------------------------------------------------
PASSPORT_CTX::PromptForCreds
---------------------------------------------------------------------------*/
BOOL PASSPORT_CTX::PromptForCreds(HBITMAP* phBitmap, PWSTR pwszCbText, PDWORD pdwTextLen, 
                                  PWSTR pwszReqUserName, PDWORD pdwReqUserNameLen )
{
    DEBUG_ENTER ((
        DBG_HTTPAUTH,
        Dword,
        "PASSPORT_CTX::PromptForCreds",
        "this=%#x",
        this
        ));

    if (phBitmap)
    {
        *phBitmap = m_hBitmap;
        m_hBitmap = NULL;
    }

    if (pdwTextLen)
    {
        if (pwszCbText && *pdwTextLen >= m_dwCbTextLen)
        {
            wcsncpy(pwszCbText, m_pwszCbText, *pdwTextLen);
            delete[] m_pwszCbText;
            m_pwszCbText = NULL;
            m_dwCbTextLen = 0;
        }
        else
            *pdwTextLen = m_dwCbTextLen;
    }

    if (pdwReqUserNameLen)
    {
        if (pwszReqUserName && m_dwReqUserNameLen && *pdwReqUserNameLen >= m_dwReqUserNameLen)
        {
            wcsncpy(pwszReqUserName, m_pwszReqUserName, *pdwReqUserNameLen); 
        }

        *pdwReqUserNameLen = m_dwReqUserNameLen;
    }

    DEBUG_LEAVE((DWORD) TRUE);
    return (DWORD) TRUE;
}


void PASSPORT_CTX::IndicatePrivacyEvents(void)
{
    PLIST_ENTRY pEventList = ::PP_GetPrivacyEvents(m_hLogon);
    INET_ASSERT(pEventList);

    while (!IsListEmpty(pEventList)) 
    {
        PLIST_ENTRY pEntry = RemoveHeadList(pEventList);
        PRIVACY_EVENT* pEvent = (PRIVACY_EVENT*)pEntry;
        
        InternetIndicateStatus(pEvent->dwStatus, pEvent->lpvInfo, pEvent->dwInfoLength);
        
        if (pEvent->dwStatus == INTERNET_STATUS_COOKIE_SENT)
        {
            delete [] ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }
        else
        {
            delete [] ((IncomingCookieState*)(pEvent->lpvInfo))->pszLocation;
            ((OutgoingCookieState*)(pEvent->lpvInfo))->pszLocation = NULL;
        }

        delete [] pEvent->lpvInfo;

        delete pEvent;
    }
}

//Determine if the character is unsafe under the URI RFC document
inline BOOL PPIsUnsafeUrlChar(TCHAR chIn) throw()
{
        unsigned char ch = (unsigned char)chIn;
        switch(ch)
        {
                case ';': case '\\': case '?': case '@': case '&':
                case '=': case '+': case '$': case ',': case ' ':
                case '<': case '>': case '#': case '%': case '\"':
                case '{': case '}': case '|':
                case '^': case '[': case ']': case '`':
                        return TRUE;
                default:
                {
                        if (ch < 32 || ch > 126)
                                return TRUE;
                        return FALSE;
                }
        }
}

BOOL PPEscapeUrl(LPCSTR lpszStringIn,
                 LPSTR lpszStringOut,
                 DWORD* pdwStrLen,
                 DWORD dwMaxLength,
                 DWORD dwFlags)
{
    TCHAR ch;
    DWORD dwLen = 0;
    BOOL bRet = TRUE;
    BOOL bSchemeFile = FALSE;
    DWORD dwColonPos = 0;
    DWORD dwFlagsInternal = dwFlags;
    while((ch = *lpszStringIn++) != '\0')
    {
        //if we are at the maximum length, set bRet to FALSE
        //this ensures no more data is written to lpszStringOut, but
        //the length of the string is still updated, so the user
        //knows how much space to allocate
        if (dwLen == dwMaxLength)
        {
            bRet = FALSE;
        }

        //if we are encoding and it is an unsafe character
        if (PPIsUnsafeUrlChar(ch))
        {
            {
                //if there is not enough space for the escape sequence
                if (dwLen >= (dwMaxLength-3))
                {
                        bRet = FALSE;
                }
                if (bRet)
                {
                        //output the percent, followed by the hex value of the character
                        *lpszStringOut++ = '%';
                        sprintf(lpszStringOut, "%.2X", (unsigned char)(ch));
                        lpszStringOut+= 2;
                }
                dwLen += 2;
            }
        }
        else //safe character
        {
            if (bRet)
                *lpszStringOut++ = ch;
        }
        dwLen++;
    }

    if (bRet)
        *lpszStringOut = '\0';
    *pdwStrLen = dwLen;
    return  bRet;
}

/////////////////
// MD5 Hash code

const CHAR g_rgchHexNumMap[] =
{
	'0', '1', '2', '3', '4', '5', '6', '7',
	'8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
};


PSTR 
GetMD5Key(PSTR pszChallengeInfo, PSTR pszPassword)
{
	int cbChallengeInfo = lstrlenA(pszChallengeInfo);
	int cbPassword = lstrlenA(pszPassword);

	PBYTE pbData = new BYTE[cbChallengeInfo + cbPassword + 1];
	
	if (!pbData)
	{
		return NULL;
	}

	PBYTE pCurrent = pbData;

	::CopyMemory(pCurrent, pszChallengeInfo, cbChallengeInfo);
	pCurrent += cbChallengeInfo;
	::CopyMemory(pCurrent, pszPassword, cbPassword);
	pCurrent += cbPassword;
	*pCurrent = '\0';

	return (PSTR)pbData;
}


//------------------------------------------------------------------------------------
//
//	Method: 	CAuthentication::GetMD5Result()
//
//	Synopsis:	Compute the MD5 hash result based on the ChallengeInfo and password.
//
//  pbHexHash must be at least MD5DIGESTLEN * 2 + 1 in size
//
//------------------------------------------------------------------------------------
BOOL 
GetMD5Result(PSTR pszChallengeInfo, PSTR pszPassword, PBYTE pbHexHash)
{

	BOOL bRetVal = FALSE;
	PSTR pMD5Key = GetMD5Key(pszChallengeInfo, pszPassword);

	if (pMD5Key)
	{
		MD5_CTX MD5Buffer;
		MD5Init(&MD5Buffer);
		MD5Update(&MD5Buffer, (const unsigned char*)pMD5Key, lstrlenA(pMD5Key));
		MD5Final(&MD5Buffer);

		PBYTE pbHash = MD5Buffer.digest;

//		pbHexHash = new BYTE[MD5DIGESTLEN * 2 + 1];
//		pbHexHash = (BYTE*)HeapAlloc (  GetProcessHeap(), HEAP_ZERO_MEMORY, MD5DIGESTLEN * 2 + 1);
		if (pbHexHash)
		{
			bRetVal = TRUE;
			PBYTE pCurrent = pbHexHash;

			// Convert the hash data to hex string.
			for (int i = 0; i < MD5DIGESTLEN; i++)
			{
				*pCurrent++ = g_rgchHexNumMap[pbHash[i]/16];
				*pCurrent++ = g_rgchHexNumMap[pbHash[i]%16];
			}

			*pCurrent = '\0';
		}

		delete pMD5Key;
	}

	return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\auth\urlzone.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    urlzone.cxx

Abstract:

    Glue layer to zone security manager, now residing in urlmon.dll

Author:

    Rajeev Dujari (rajeevd)  02-Aug-1997

Contents:

    UrlZonesAttach
    UrlZonesDetach
    GetCredPolicy

--*/


#include <wininetp.h>
#include "urlmon.h"

//
// prototypes
//
typedef HRESULT (*PFNCREATESECMGR)(IServiceProvider * pSP, IInternetSecurityManager **ppSM, DWORD dwReserved);
typedef HRESULT (*PFNCREATEZONEMGR)(IServiceProvider * pSP, IInternetZoneManager **ppZM, DWORD dwReserved);

//
// globals
//
IInternetSecurityManager* g_pSecMgr  = NULL;
IInternetZoneManager*     g_pZoneMgr = NULL;

static BOOL g_bAttemptedInit = FALSE;
static HINSTANCE g_hInstUrlMon = NULL;
static PFNCREATESECMGR  g_pfnCreateSecMgr  = NULL;
static PFNCREATEZONEMGR g_pfnCreateZoneMgr = NULL;

//
// Handy class which uses a stack buffer if possible, otherwise allocates.
//
struct FlexBuf
{
    BYTE Buf[512];
    LPBYTE pbBuf;

    FlexBuf()
    {
        pbBuf = NULL;
    }

    ~FlexBuf()
    {
        if (pbBuf != NULL) {
            delete [] pbBuf;
        }
    }

    LPBYTE GetPtr (DWORD cbBuf)
    {
        if (cbBuf < sizeof(Buf))
            return Buf;
        pbBuf = new BYTE [cbBuf];
        return pbBuf;
    }
};

struct UnicodeBuf : public FlexBuf
{
    LPWSTR Convert (LPCSTR pszUrl)
    {
        DWORD cbUrl = lstrlenA (pszUrl) + 1;
        LPWSTR pwszUrl = (LPWSTR) GetPtr (sizeof(WCHAR) * cbUrl);
        if (!pwszUrl)
            return NULL;
        MultiByteToWideChar
            (CP_ACP, 0, pszUrl, cbUrl, pwszUrl, cbUrl);
        return pwszUrl;
    }
};

//
// Dynaload urlmon and create security manager object on demand.
//

BOOL UrlZonesAttach (void)
{
    EnterCriticalSection(&ZoneMgrCritSec);
    BOOL bRet = FALSE;
    HRESULT hr;

    if (g_bAttemptedInit)
    {
        bRet = (g_pSecMgr != NULL && g_pZoneMgr != NULL);
        goto End;
    }

    g_bAttemptedInit = TRUE;

    g_hInstUrlMon = LoadLibraryA(URLMON_DLL);
    if (!g_hInstUrlMon)
    {
        bRet = FALSE;
        goto End;
    }

    g_pfnCreateSecMgr = (PFNCREATESECMGR)
        GetProcAddress(g_hInstUrlMon, "CoInternetCreateSecurityManager");
    if (!g_pfnCreateSecMgr)
    {
        bRet = FALSE;
        goto End;
    }

    g_pfnCreateZoneMgr = (PFNCREATEZONEMGR)
        GetProcAddress(g_hInstUrlMon, "CoInternetCreateZoneManager");
    if (!g_pfnCreateZoneMgr)
    {
        bRet = FALSE;
        goto End;
    }

    hr = (*g_pfnCreateSecMgr)(NULL, &g_pSecMgr, NULL);
    if( hr != S_OK )
    {
        bRet = FALSE;
        goto End;
    }

    hr = (*g_pfnCreateZoneMgr)(NULL, &g_pZoneMgr, NULL);
    bRet = (hr == S_OK);

End:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return bRet;
}

//
// Clean up upon process detach.
//

STDAPI_(void) UrlZonesDetach (void)
{
    EnterCriticalSection(&ZoneMgrCritSec);

    if (g_pSecMgr)
    {
        g_pSecMgr->Release();
        g_pSecMgr = NULL;
    }
    if (g_pZoneMgr)
    {
        g_pZoneMgr->Release();
        g_pZoneMgr = NULL;
    }
    if (g_hInstUrlMon)
    {
        FreeLibrary(g_hInstUrlMon);
        g_hInstUrlMon = NULL;
    }
    LeaveCriticalSection(&ZoneMgrCritSec);
}

extern "C" DWORD GetZoneFromUrl(LPCSTR pszUrl);
         
DWORD GetZoneFromUrl(LPCSTR pszUrl)
{
    DWORD dwZone;
    dwZone = URLZONE_UNTRUSTED; // null URL indicates restricted zone.

    UnicodeBuf ub;
    EnterCriticalSection(&ZoneMgrCritSec);
    if (!g_pSecMgr && !UrlZonesAttach())
         goto err;
    
    LPWSTR pwszUrl;
    if (!pszUrl)
        pwszUrl = NULL;
    else
    {   
        pwszUrl = ub.Convert (pszUrl);
        if (!pwszUrl)
            goto err;
    }            
    
    if (pszUrl)
    {
        // Otherwise determine the zone for this URL.
        g_pSecMgr->MapUrlToZone (pwszUrl, &dwZone, 0);
    }

err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwZone;
}

//
// Routine to get the Routine to indicate whether ntlm logon credential is allowed.
//

DWORD GetCredPolicy (LPSTR pszUrl)
{
   HRESULT hr;
   DWORD dwPolicy;

   UnicodeBuf ub;
   EnterCriticalSection(&ZoneMgrCritSec);

   if (!UrlZonesAttach())
        goto err;

    LPWSTR pwszUrl;
    if (!pszUrl)
        pwszUrl = NULL;
    else
    {   
        pwszUrl = ub.Convert (pszUrl);
        if (!pwszUrl)
            goto err;
    }            

    hr = g_pSecMgr->ProcessUrlAction (pwszUrl, URLACTION_CREDENTIALS_USE,
        (LPBYTE) &dwPolicy, sizeof(dwPolicy), NULL, 0, PUAF_NOUI, 0);


    // Resolve the ambiguous "Prompt if Intranet zone policy".

    if (dwPolicy == URLPOLICY_CREDENTIALS_CONDITIONAL_PROMPT)
    {
        DWORD dwZone;
        dwZone = URLZONE_UNTRUSTED; // null URL indicates restricted zone.

        if (pszUrl)
        {
            // Otherwise determine the zone for this URL.
            hr = g_pSecMgr->MapUrlToZone (pwszUrl, &dwZone, 0);
            if (hr != S_OK)
                goto err;
        }
        
        if (dwZone == URLZONE_INTRANET)
            dwPolicy = URLPOLICY_CREDENTIALS_SILENT_LOGON_OK;
        else
            dwPolicy = URLPOLICY_CREDENTIALS_MUST_PROMPT_USER;
    }
    
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwPolicy;

err:
    INET_ASSERT (FALSE);
    LeaveCriticalSection(&ZoneMgrCritSec);
    return URLPOLICY_CREDENTIALS_MUST_PROMPT_USER;
}

/*
Main-switch for the cookie feature has 3 states.
1. ALLOW: all cookies are accepted/replayed (including leashed ones)
2. QUERY: received cookies are subject to P3P evaluation, 
          leashed cookies are not replayed
3. DISALLOW:no cookies are accepted/replayed.
*/
DWORD   GetCookieMainSwitch(DWORD dwZone) {

    DWORD dwPolicy = URLPOLICY_DISALLOW;

    if (!UrlZonesAttach())
        return dwPolicy;

    EnterCriticalSection(&ZoneMgrCritSec);

    HRESULT hr = g_pZoneMgr->GetZoneActionPolicy(dwZone, URLACTION_COOKIES_ENABLED,
                                                 (LPBYTE)&dwPolicy, sizeof(dwPolicy),
                                                 URLZONEREG_DEFAULT);

    LeaveCriticalSection(&ZoneMgrCritSec);

    return SUCCEEDED(hr) ? dwPolicy : URLPOLICY_ALLOW;
}

DWORD   GetCookieMainSwitch(LPCSTR pszURL) {

    return GetCookieMainSwitch(GetZoneFromUrl(pszURL));
}

DWORD GetCookiePolicy (LPCSTR pszUrl, DWORD dwUrlAction, BOOL fRestricted)
{
    if (GlobalSuppressCookiesPolicy)
    {
        return URLPOLICY_ALLOW;
    }
    
    EnterCriticalSection(&ZoneMgrCritSec);
    UnicodeBuf ub;
    DWORD dwCP;

    if (!UrlZonesAttach())
        goto err;

    // Convert to unicode.
    LPWSTR pwszUrl;
    pwszUrl = ub.Convert (pszUrl);
    if (!pwszUrl)
        goto err;

    DWORD dwPolicy;
    HRESULT hr;
    DWORD dwFlags;
    
    dwFlags = PUAF_NOUI;
    if (fRestricted)
        dwFlags |= PUAF_ENFORCERESTRICTED;
        
    hr = g_pSecMgr->ProcessUrlAction (pwszUrl, dwUrlAction,
            (LPBYTE) &dwPolicy, sizeof(dwPolicy), NULL, 0, dwFlags, 0);

    if (!SUCCEEDED(hr) )
        goto err;

    dwCP = GetUrlPolicyPermissions(dwPolicy);
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwCP;

err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    INET_ASSERT (FALSE);
    return URLPOLICY_QUERY;
}

DWORD GetClientCertPromptPolicy (LPCSTR pszUrl, BOOL fRestricted /* = FALSE */)
{   
    EnterCriticalSection(&ZoneMgrCritSec);
    UnicodeBuf ub;
    DWORD dwCP;
    DWORD dwUrlAction = URLACTION_CLIENT_CERT_PROMPT;
    DWORD dwFlags;

    if (!UrlZonesAttach())
        goto err;

    // Convert to unicode.
    LPWSTR pwszUrl;
    pwszUrl = ub.Convert (pszUrl);
    if (!pwszUrl)
        goto err;

    DWORD dwPolicy;

    dwFlags = PUAF_NOUI;
    if (fRestricted)
        dwFlags |= PUAF_ENFORCERESTRICTED;

    HRESULT hr;

    hr = g_pSecMgr->ProcessUrlAction (pwszUrl, dwUrlAction,
            (LPBYTE) &dwPolicy, sizeof(dwPolicy), NULL, 0, dwFlags, 0);

    if (!SUCCEEDED(hr) )
        goto err;

    dwCP = GetUrlPolicyPermissions(dwPolicy);
    LeaveCriticalSection(&ZoneMgrCritSec);
    return dwCP;

err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    INET_ASSERT (FALSE);
    return URLPOLICY_QUERY;
}

VOID SetStopWarning( LPCSTR pszUrl, DWORD dwPolicy, DWORD dwUrlAction)
{
    EnterCriticalSection(&ZoneMgrCritSec);
    UnicodeBuf ub;
    ZONEATTRIBUTES za = {0};

    if (!UrlZonesAttach())
        goto err;

    // Convert to unicode.
    LPWSTR pwszUrl;
    pwszUrl = ub.Convert (pszUrl);
    if (!pwszUrl)
        goto err;

    HRESULT hr;
    DWORD  dwZone;
    hr = g_pSecMgr->MapUrlToZone(pwszUrl, &dwZone, 0);
    if (!SUCCEEDED(hr) )
        goto err;

    DWORD dwZonePolicy;

    hr = g_pZoneMgr->GetZoneActionPolicy(
        dwZone,
        dwUrlAction,
        (LPBYTE)&dwZonePolicy,
        sizeof(dwZonePolicy),
        URLZONEREG_DEFAULT );

    if (!SUCCEEDED(hr) )
        goto err;

    // set the policy back with passed value
    SetUrlPolicyPermissions(dwZonePolicy, dwPolicy);

    hr = g_pZoneMgr->SetZoneActionPolicy(
        dwZone,
        dwUrlAction,
        (LPBYTE) &dwZonePolicy,
        sizeof(dwZonePolicy),
        URLZONEREG_DEFAULT );

    if (!SUCCEEDED(hr) )
        goto err;

    // change the generic zone setting to 'custom' now we've changed something
    za.cbSize = sizeof(ZONEATTRIBUTES);
    g_pZoneMgr->GetZoneAttributes(dwZone, &za);
    za.dwTemplateCurrentLevel = URLTEMPLATE_CUSTOM;
    g_pZoneMgr->SetZoneAttributes(dwZone, &za);


err:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return;
}

//
// Set and query no cookies mode
//
BOOL IsNoCookies(DWORD dwZone)
{
    BOOL        fNoCookies = FALSE;
    HRESULT     hr;
    DWORD       dwZonePolicy;

    EnterCriticalSection(&ZoneMgrCritSec);

    if (!UrlZonesAttach())
        goto exit;

    hr = g_pZoneMgr->GetZoneActionPolicy(
                        dwZone,
                        URLACTION_COOKIES_ENABLED,
                        (LPBYTE)&dwZonePolicy,
                        sizeof(dwZonePolicy),
                        URLZONEREG_DEFAULT );

    if(SUCCEEDED(hr))
    {
        dwZonePolicy = GetUrlPolicyPermissions(dwZonePolicy);
        if(URLPOLICY_DISALLOW == dwZonePolicy)
        {
            fNoCookies = TRUE;
        }
    }

exit:
    LeaveCriticalSection(&ZoneMgrCritSec);
    return fNoCookies;
}

void SetNoCookies(DWORD dwZone, DWORD dwNewPolicy)
{
    DWORD   dwZonePolicy;
    HRESULT hr;

    EnterCriticalSection(&ZoneMgrCritSec);

    if (!UrlZonesAttach())
        goto exit;

    hr = g_pZoneMgr->GetZoneActionPolicy(
                        dwZone,
                        URLACTION_COOKIES_ENABLED,
                        (LPBYTE)&dwZonePolicy,
                        sizeof(dwZonePolicy),
                        URLZONEREG_DEFAULT );

    if(SUCCEEDED(hr))
    {
        SetUrlPolicyPermissions(dwZonePolicy, dwNewPolicy);

        g_pZoneMgr->SetZoneActionPolicy(
                        dwZone,
                        URLACTION_COOKIES_ENABLED,
                        (LPBYTE)&dwZonePolicy,
                        sizeof(dwZonePolicy),
                        URLZONEREG_DEFAULT );
    }

exit:
    LeaveCriticalSection(&ZoneMgrCritSec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\dllmain.cpp ===
/********************************************************************************
/    This is the base file to the Microsoft JScript Proxy Configuration 
/    This file implements the code to provide the script site and the JSProxy psuedo
/    object for the script engine to call against.
/
/    Created        11/27/96    larrysu
/
/
/
/
/
/
/
/
/
*/

#include "dllmain.h"

CScriptSite    *g_ScriptSite = NULL;
BOOL fOleInited = FALSE;

/*******************************************************************************
*    dll initialization and destruction

********************************************************************************/
EXTERN_C
BOOL APIENTRY DllMain(HMODULE hModule,DWORD ul_reason_for_call,LPVOID lpReserved)
{
    
    switch( ul_reason_for_call ) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hModule);
        break;
    case DLL_PROCESS_DETACH:        
        break;
    }
    return TRUE;
}


STDAPI_(BOOL) AUTOCONF_InternetInitializeAutoProxyDll(DWORD dwVersion, 
                                                      LPSTR lpszDownloadedTempFile,
                                                      LPSTR lpszMime,
                                                      AUTO_PROXY_HELPER_APIS *pAutoProxyCallbacks, 
                                                      LPAUTO_PROXY_EXTERN_STRUC lpExtraData)
{
    HRESULT    hr = E_FAIL;
    HANDLE    hFile = 0;
    LPSTR    szScript = NULL;
    DWORD    dwFileSize = 0;
    DWORD    dwBytesRead = 0;
    LPSTR    result;
    LPSTR   szAllocatedScript = NULL;


    if ( !fOleInited ) 
    {
#ifndef unix
        CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
        CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
#endif /* unix */
    }


    // get the script text from the downloaded file!
    // open the file

    if ( lpExtraData == NULL ||
         lpExtraData->dwStructSize != sizeof(AUTO_PROXY_EXTERN_STRUC) ||
         lpExtraData->lpszScriptBuffer == NULL )
    {
        if (!lpszDownloadedTempFile)
            return FALSE;

        hFile = CreateFile((LPCSTR)lpszDownloadedTempFile,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            return FALSE;

        // Get the size
        dwFileSize = GetFileSize(hFile,NULL);
        // allocate the buffer to hold the data.
        szScript = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwFileSize+1);
        szAllocatedScript = szScript;

        BOOL f = TRUE;
        // if the memory was allocated
        if (szScript)
        {
            // read the data
            f = ReadFile(hFile,(LPVOID) szScript,dwFileSize,&dwBytesRead,NULL);
        }
        CloseHandle(hFile);

        if (!f)
            goto Cleanup;
    }
    else
    {
        szScript = (LPSTR) lpExtraData->lpszScriptBuffer;
    }

    // Create a new CScriptSite object and initiate it with the autoconfig script.
    g_ScriptSite = new CScriptSite;
    if (g_ScriptSite)
        hr = g_ScriptSite->Init(pAutoProxyCallbacks, szScript);
    else
        hr = E_OUTOFMEMORY;

Cleanup:

    if ( szAllocatedScript ) 
    {
        // Free the script text
        GlobalFree(szAllocatedScript);
        szAllocatedScript = NULL;
    }

    if (SUCCEEDED(hr))
        return TRUE;
    else
        return FALSE;
}

// This function frees the script engine and destroys the script site.
EXTERN_C BOOL CALLBACK AUTOCONF_InternetDeInitializeAutoProxyDll(LPSTR lpszMime, DWORD dwReserved)
{

    // Release and destroy the CScriptSite object and initiate it with the autoconfig script.
    // DeInit the script site.
    if (g_ScriptSite)
    {
        g_ScriptSite->DeInit();
        g_ScriptSite->Release();
        g_ScriptSite = NULL;
    }

    if ( fOleInited ) 
    {
        CoUninitialize();    
    }

    return TRUE;
}

// This function is called when the host wants to run the script.
EXTERN_C BOOL CALLBACK InternetGetProxyInfo(LPCSTR lpszUrl,
                                            DWORD dwUrlLength,
                                            LPSTR lpszUrlHostName,
                                            DWORD dwUrlHostNameLength,
                                            LPSTR *lplpszProxyHostName,
                                            LPDWORD lpdwProxyHostNameLength)
{
    HRESULT    hr = S_OK;
    LPSTR    szHost;
    
    // The host passed in may be too big.  Copy it an make the 
    // HostLength + 1 position will be slammed with \0.
    szHost = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,dwUrlHostNameLength+1);
    if (!szHost)
        return FALSE;
    if(lpszUrlHostName && !lstrcpyn(szHost,lpszUrlHostName,dwUrlHostNameLength+1))
    {
        GlobalFree(szHost);
        return FALSE;
    }

    // construct a jscript call with the passed in url and host.
    if (g_ScriptSite)
//        hr = g_ScriptSite->RunScript(lpszUrl,lpszUrlHostName,lplpszProxyHostName);
        hr = g_ScriptSite->RunScript(lpszUrl,szHost,lplpszProxyHostName);

    GlobalFree(szHost);

    if (SUCCEEDED(hr))
    {
        *lpdwProxyHostNameLength = lstrlen(*lplpszProxyHostName) +1;
        return TRUE;
    }
    else
        return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\dllmain.h ===
#include <windows.h>
#include <olectl.h>
#include "cscpsite.h"

#include "crtfree.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\crtfree.h ===
#ifndef __CRTFREE_H_
#define __CRTFREE_H_


//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define CPP_FUNCTIONS
//

void *  __cdecl operator new(size_t nSize)
    {
    // Zero init just to save some headaches
    return((LPVOID)LocalAlloc(LPTR, nSize));
    }


void  __cdecl operator delete(void *pv)
    {
    LocalFree((HLOCAL)pv);
    }

extern "C" int __cdecl _purecall(void) {return 0;}

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\auth\winctxt.h ===
#ifndef _WIN_SIC_CTXT_H_
#define _WIN_SIC_CTXT_H_

#define DEFAULT_SERVER_NAME_LEN     128

typedef struct _WINCONTEXT  {

    //
    //  Buffer for storing exchange blob returned by SSPI before
    //  PreAuthenticateUser is called
    //
    char        *szOutBuffer;
    DWORD       cbOutBuffer;        // bytes associated with allocated szOutBuffer
    DWORD       dwOutBufferLength;

    char        *szInBuffer;
    DWORD       cbInBuffer;         // bytes associated with allocated szInBuffer
    PCHAR       pInBuffer;
    DWORD       dwInBufferLength;

    DWORD       dwCallId;

    DWORD       pkgId;

    CredHandle  Credential;     // SSPI credential handle for this connection
    PCredHandle pCredential;

    //
    // The SSPI Context Handle is stored here
    //
    CtxtHandle  SspContextHandle;
    PCtxtHandle pSspContextHandle;  // before any ctxt is created, this is NULL

    LPSTR       lpszServerName;

    char        szServerName[DEFAULT_SERVER_NAME_LEN];

} WINCONTEXT, *PWINCONTEXT;

#endif  // _WIN_SIC_CTXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\jsproxy.h ===
#ifndef __JSPROXY_H__
#define __JSPROXY_H__

#include <windows.h>
#include <olectl.h>
#include "utils.h"
#include "regexp.h"

#define VAL_isPlainHostName			0x01f9
#define VAL_dnsDomainIs				0x01f8
#define VAL_localHostOrDomainIs		0x020b
#define VAL_isResolvable			0x0206
#define VAL_isInNet					0x01e1
#define VAL_dnsResolve				0x01fc
#define VAL_myIpAddress				0x01e0
#define VAL_dnsDomainLevels			0x01f8
#define VAL_shExpMatch				0x0208
#define VAL_weekdayRange			0x0210
#define VAL_dateRange				0x01f0
#define VAL_timeRange				0x0201
#define VAL_alert				0x0218

#define DISPID_isPlainHostName		0x0001
#define DISPID_dnsDomainIs			0x0002
#define DISPID_localHostOrDomainIs	0x0003
#define DISPID_isResolvable			0x0004
#define DISPID_isInNet				0x0005
#define DISPID_dnsResolve			0x0006
#define DISPID_myIpAddress			0x0007
#define DISPID_dnsDomainLevels		0x0008
#define DISPID_shExpMatch			0x0009
#define DISPID_weekdayRange			0x000a
#define DISPID_dateRange			0x000b
#define DISPID_timeRange			0x000c
#define DISPID_alert				0x000d

/************************************************************************************************/
// This class implements the Dispatch interface that will allow the script engine to call the 
// auto-proxy configuration functions.  This interface does not have a typelib and does not provide type
// info.
class CJSProxy : public IDispatch
{

public:

	CJSProxy();
	~CJSProxy();
	// IUnknown Methods
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObject)
	{

#ifdef INET_DEBUG
        OutputDebugString( "IDispatch::QueryInterface\n" );
#endif

		if (riid == IID_IUnknown || 
            riid == IID_IDispatch)
		{
			*ppvObject = (LPVOID)(LPUNKNOWN)this;
            AddRef();
			return S_OK;
		}
		else
		{
			if (riid == IID_IDispatch)
			{
				*ppvObject = (LPVOID)(IDispatch*)this;
                AddRef();
				return S_OK;
			}
			else
			{
				*ppvObject = 0;
				return E_NOINTERFACE;
			}
		}

	}

	STDMETHODIMP_(ULONG) AddRef()
	{
#ifdef INET_DEBUG
        char szBuff[256];

        wsprintf(szBuff, "IDispatch::AddRef ref=%u\n", m_refCount );
        OutputDebugString(szBuff);
#endif

		return ++m_refCount;
	}

	STDMETHODIMP_(ULONG) Release()
	{
#ifdef INET_DEBUG
        char szBuff[256];

        wsprintf(szBuff, "IDispatch::Release ref=%u\n", m_refCount );
        OutputDebugString(szBuff);
#endif

		if (--m_refCount)
			return m_refCount;

		delete this;
		return 0;
	}

	// IDispatch Methods
    STDMETHODIMP GetTypeInfoCount(UINT* pctinfo)
	{
		*pctinfo = 0;
		return S_OK;
	}

    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return TYPE_E_ELEMENTNOTFOUND;
	}

    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid);

    STDMETHODIMP Invoke(
					DISPID dispidMember,
					REFIID riid,
					LCID lcid,
					WORD wFlags,
					DISPPARAMS* pdispparams,
					VARIANT* pvarResult,
					EXCEPINFO* pexcepinfo,
					UINT* puArgErr);

	//  JScript Auto-Proxy config functions.
	STDMETHODIMP isPlainHostName(BSTR host, VARIANT* retval);
	STDMETHODIMP dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval);
	STDMETHODIMP localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval);
	STDMETHODIMP isResolvable(BSTR host, VARIANT* retval);
	STDMETHODIMP isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval);
	STDMETHODIMP dnsResolve(BSTR host, VARIANT* retval);
	STDMETHODIMP myIpAddress(VARIANT* retval);
	STDMETHODIMP dnsDomainLevels(BSTR host, VARIANT* retval);
	STDMETHODIMP shExpMatch(BSTR str, BSTR shexp, VARIANT* retval);
	STDMETHODIMP alert(BSTR message, VARIANT* retval);

	// These are to do last!!!.
	STDMETHODIMP weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval);
	STDMETHODIMP dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval);
	STDMETHODIMP timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval);
	//	ProxyConfig.bindings 

	STDMETHODIMP Init(AUTO_PROXY_HELPER_APIS* pAPHA);
	STDMETHODIMP DeInit();
	
	// JScript private members
private:
	long					m_refCount;
	BOOL					m_fDestroyable;
	BOOL					m_fInitialized;
	AUTO_PROXY_HELPER_APIS*	m_pCallout;
	LPCWSTR					m_strings[13];
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\regexp.h ===
#ifndef __REGEXP_H__
#define __REGEXP_H__

#include <windows.h>
#include "utils.h"

#define PAT_START	128	/* Special beginning-of-pattern marker */
#define PAT_END		129	/* Special end-of-pattern marker */
#define PAT_STAR	130	/* Zero or more of any character */
#define PAT_QUES	131	/* Exactly one of any character */
#define PAT_AUGDOT	132	/* Literal '.' or end-of-string */
#define PAT_AUGQUES	133	/* Empty string or non-'.' */
#define PAT_AUGSTAR	134	/* Single character that isn't a '.' */

BOOL test_match(int m, LPSTR target, int pattern[]);
BOOL parse_pattern(LPSTR s, int pattern[]);
BOOL match( LPSTR target, LPSTR regexp);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\jsproxy.cpp ===
/********************************************************************************
/	This is the base file to the Microsoft JScript Proxy Configuration 
/	This file implements the code to provide the script site and the JSProxy psuedo
/	object for the script engine to call against.
/
/	Created		11/27/96	larrysu
/
/
/
/
/
/
/
/
/
*/
#include "jsproxy.h"


/*******************************************************************************
*	JSProxy functions.
********************************************************************************/
CJSProxy::CJSProxy()
{
	m_refCount = 1;
	m_fDestroyable = FALSE;
	m_fInitialized = FALSE;
	m_pCallout = NULL;
}

CJSProxy::~CJSProxy()
{
	if(m_fInitialized)
		DeInit();
}

STDMETHODIMP CJSProxy::Init(AUTO_PROXY_HELPER_APIS* pAPHA)
{

	m_strings[0] = L"isPlainHostName";
	m_strings[1] = L"dnsDomainIs";
	m_strings[2] = L"localHostOrDomainIs";
	m_strings[3] = L"isResolvable";
	m_strings[4] = L"isInNet";
	m_strings[5] = L"dnsResolve";
	m_strings[6] = L"myIpAddress";
	m_strings[7] = L"dnsDomainLevels";
	m_strings[8] = L"shExpMatch";
	m_strings[9] = L"weekdayRange";
	m_strings[10] = L"dateRange";
	m_strings[11] = L"timeRange";
	m_strings[12] = L"alert";
	
	m_pCallout = pAPHA;
	m_fInitialized = TRUE;
	return S_OK;
}

STDMETHODIMP CJSProxy::DeInit()
{
	m_pCallout = NULL;
	m_fInitialized = FALSE;
	return S_OK;
}
//IDispatch functions for JSProxy.  I want these to be light and fast.
STDMETHODIMP CJSProxy::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames,UINT cNames, LCID lcid, DISPID FAR* rgdispid)
{
	// Use addition of first 4 chars to make quick cheesy hash of which function wants to be called.
	// These are values are #defined in JSProxy.h
	HRESULT		hr = S_OK;
	long		strval = 0;
	unsigned long		nameindex = 0;
	OLECHAR*	currentName = NULL;

	if (!*rgszNames)
		return E_POINTER;
	if (cNames < 1)
		return E_INVALIDARG;

	while (nameindex < cNames)
	{
		currentName = rgszNames[nameindex];
		if (currentName == NULL)
			break;
		
		strval = currentName[0]+currentName[1]+currentName[2]+currentName[3]+currentName[4];

		switch (strval)
		{

			case VAL_myIpAddress :
					if (StrCmpW(m_strings[6],currentName) == 0)
						rgdispid[nameindex] = DISPID_myIpAddress;
					else
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;

			case VAL_isInNet :
					if (StrCmpW(m_strings[4],currentName) == 0)
						rgdispid[nameindex] = DISPID_isInNet;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_dateRange :
					if (StrCmpW(m_strings[10],currentName) == 0)
						rgdispid[nameindex] = DISPID_dateRange;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_dnsDomainIs : // This is also VAL_dnsDomainLevels check for both strings.
					if (StrCmpW(m_strings[7],currentName) == 0)
						rgdispid[nameindex] = DISPID_dnsDomainLevels;
					else 
					{
						if (StrCmpW(m_strings[1],currentName) == 0)
							rgdispid[nameindex] = DISPID_dnsDomainIs;
						else 
						{
							rgdispid[nameindex] = DISPID_UNKNOWN;
							hr = DISP_E_UNKNOWNNAME;
						}
					}
					break;
			
			case VAL_isPlainHostName :
					if (StrCmpW(m_strings[0],currentName) == 0)
						rgdispid[nameindex] = DISPID_isPlainHostName;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_dnsResolve :
					if (StrCmpW(m_strings[5],currentName) == 0)
						rgdispid[nameindex] = DISPID_dnsResolve;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_timeRange :
					if (StrCmpW(m_strings[11],currentName) == 0)
						rgdispid[nameindex] = DISPID_timeRange;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_isResolvable :
					if (StrCmpW(m_strings[3],currentName) == 0)
						rgdispid[nameindex] = DISPID_isResolvable;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_shExpMatch :
					if (StrCmpW(m_strings[8],currentName) == 0)
						rgdispid[nameindex] = DISPID_shExpMatch;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_localHostOrDomainIs :
					if (StrCmpW(m_strings[2],currentName) == 0)
						rgdispid[nameindex] = DISPID_localHostOrDomainIs;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_weekdayRange :
					if (StrCmpW(m_strings[9],currentName) == 0)
						rgdispid[nameindex] = DISPID_weekdayRange;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			case VAL_alert :
					if (StrCmpW(m_strings[12],currentName) == 0)
						rgdispid[nameindex] = DISPID_alert;
					else 
					{
						rgdispid[nameindex] = DISPID_UNKNOWN;
						hr = DISP_E_UNKNOWNNAME;
					}
					break;
			
			default :
					rgdispid[nameindex] = DISPID_UNKNOWN;
					hr = DISP_E_UNKNOWNNAME;
					break;

		}
		nameindex++;
	}
	return hr;
	
}

STDMETHODIMP CJSProxy::Invoke(
				DISPID dispidMember,
				REFIID riid,
				LCID lcid,
				WORD wFlags,
				DISPPARAMS* pdispparams,
				VARIANT* pvarResult,
				EXCEPINFO* pexcepinfo,
				UINT* puArgErr)
{
	HRESULT hr = S_OK;
	
	if (dispidMember > 0x000d)
		return DISP_E_MEMBERNOTFOUND;

	if (!(wFlags & (DISPATCH_PROPERTYGET|DISPATCH_METHOD)))
	{
		return DISP_E_MEMBERNOTFOUND;
	}

	// The big switch based on DISPID!
	switch (dispidMember)
	{
/*****************************************************************************
	Calling isPlainHostName 
*****************************************************************************/
	case DISPID_isPlainHostName :
		{
			// look in the DISPARAMS to make sure the signiture is correct for this function.
			if (pdispparams->cArgs != 1)
				hr = DISP_E_BADPARAMCOUNT;
			if (pdispparams->cNamedArgs > 0)
				hr = DISP_E_NONAMEDARGS;

			if (FAILED(hr))
				break;
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call isPlainHostName.
			hr = isPlainHostName(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling dnsDomainIs
*****************************************************************************/
	case DISPID_dnsDomainIs :
		{
			if (pdispparams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			VARIANT arg2;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg2 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			if (pdispparams->rgvarg[1].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[1];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call dnsDomainIs
			hr = dnsDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling localHostOrDomainIs
*****************************************************************************/
	case DISPID_localHostOrDomainIs :
		{
			if (pdispparams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			VARIANT arg2;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg2 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			if (pdispparams->rgvarg[1].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[1];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call localHostOrDomainIs
			hr = localHostOrDomainIs(arg1.bstrVal,arg2.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling isResolvable
*****************************************************************************/
	case DISPID_isResolvable :
		{
			if (pdispparams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call isResolvable
			hr = isResolvable(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling isInNet
*****************************************************************************/
	case DISPID_isInNet :
		{
			int x;

			if (pdispparams->cArgs != 3)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT args[3];
			
			for (x=0;x<3;x++)
			{
				// check the type of the variant in the disparams and if it is a bstr use it
				if (pdispparams->rgvarg[x].vt == VT_BSTR)
					args[x] = pdispparams->rgvarg[x];
				// otherwise change it into one!  if this fails the return an error.
				else
				{
					hr = VariantChangeType(&args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
					if (FAILED(hr))
					{
						hr = DISP_E_TYPEMISMATCH;
						break;
					}
				}
			}
			if (FAILED(hr))
            {
                pvarResult->vt = VT_BOOL;
                pvarResult->boolVal = VARIANT_FALSE;
                hr = S_OK;
				break;
            }
			// call isInNet.  Args need to be reversed
			hr = isInNet(args[2].bstrVal,args[1].bstrVal,args[0].bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling dnsResolve
*****************************************************************************/
	case DISPID_dnsResolve :
		{
			if (pdispparams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call dnsResolve
			hr = dnsResolve(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling myIpAddress
*****************************************************************************/
	case DISPID_myIpAddress :
		// Should have no args and 1 named arg and the name should be DISPATCH_PROPERTYGET!
/*		if (pdispparams->cNamedArgs != 1)
		{
			hr = DISP_E_BADPARAMCOUNT;
			break;
		}
*/
		// call myIpAddress
		hr = myIpAddress(pvarResult);
		break;
/*****************************************************************************
	Calling dnsDomainLevels
*****************************************************************************/
	case DISPID_dnsDomainLevels :
		{
			if (pdispparams->cArgs != 1)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call dnsDomainLevels
			hr = dnsDomainLevels(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling shExpMatch
*****************************************************************************/
	case DISPID_shExpMatch :
		{
			if (pdispparams->cArgs != 2)
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT arg1;
			VARIANT arg2;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg2 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg2,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			if (pdispparams->rgvarg[1].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[1];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[1]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call isPlainHostName.
			hr = shExpMatch(arg1.bstrVal,arg2.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Calling weekdayRange
*****************************************************************************/
	case DISPID_weekdayRange :
		{
			unsigned int x;

			if ((pdispparams->cArgs > 3) || (pdispparams->cArgs < 1))
			{
				hr = DISP_E_BADPARAMCOUNT;
				break;
			}
			if (pdispparams->cNamedArgs > 0)
			{
				hr = DISP_E_NONAMEDARGS;
				break;
			}
			
			VARIANT* args[3] = {NULL,NULL,NULL};
			
			for (x=0;x<pdispparams->cArgs;x++)
			{
				args[x] = new(VARIANT);
                if( !(args[x]) )
                {
                       hr = E_OUTOFMEMORY;
                       break;
                }

				// check the type of the variant in the disparams and if it is a bstr use it
				if (pdispparams->rgvarg[x].vt == VT_BSTR)
					*args[x] = pdispparams->rgvarg[x];
				// otherwise change it into one!  if this fails the return an error.
				else
				{
					hr = VariantChangeType(args[x],&(pdispparams->rgvarg[x]),NULL,VT_BSTR);
					if (FAILED(hr))
					{
						hr = DISP_E_TYPEMISMATCH;
						break;
					}
				}
			}
			if (FAILED(hr))
				break;
			// call isInNet.  Args need to be reversed
			switch (pdispparams->cArgs)
			{
			case 1:
				hr = weekdayRange(args[0]->bstrVal,NULL,NULL,pvarResult);
				break;
			case 2:
				if ((args[0]->bstrVal[0] == 'G') || (args[0]->bstrVal[0] == 'g'))
					hr = weekdayRange(args[1]->bstrVal,NULL,args[0]->bstrVal,pvarResult);
				else
					hr = weekdayRange(args[1]->bstrVal,args[0]->bstrVal,NULL,pvarResult);
				break;
			case 3:
				hr = weekdayRange(args[2]->bstrVal,args[1]->bstrVal,args[0]->bstrVal,pvarResult);
				break;
			}
			break;
		}
/*****************************************************************************
	Calling dateRange
*****************************************************************************/
	case DISPID_dateRange :
		break;
/*****************************************************************************
	Calling timeRange
*****************************************************************************/
	case DISPID_timeRange :
		break;
/*****************************************************************************
	Calling alert 
*****************************************************************************/
	case DISPID_alert :
		{
			// look in the DISPARAMS to make sure the signiture is correct for this function.
			if (pdispparams->cArgs != 1)
				hr = DISP_E_BADPARAMCOUNT;
			if (pdispparams->cNamedArgs > 0)
				hr = DISP_E_NONAMEDARGS;

			if (FAILED(hr))
				break;
			
			VARIANT arg1;
			
			// check the type of the variant in the disparams and if it is a bstr use it
			if (pdispparams->rgvarg[0].vt == VT_BSTR)
				arg1 = pdispparams->rgvarg[0];
			// otherwise change it into one!  if this fails the return an error.
			else
			{
				hr = VariantChangeType(&arg1,&(pdispparams->rgvarg[0]),NULL,VT_BSTR);
				if (FAILED(hr))
				{
					hr = DISP_E_TYPEMISMATCH;
					break;
				}
			}
			// call alert.
			hr = alert(arg1.bstrVal,pvarResult);
			break;
		}
/*****************************************************************************
	Default returning error code
*****************************************************************************/
	default:
		hr = DISP_E_MEMBERNOTFOUND;
	}

	return hr;
}


//  JScript Auto-Proxy config functions.
STDMETHODIMP CJSProxy::isPlainHostName(BSTR host, VARIANT* retval)
{
	WCHAR	*currentch;
	BOOL	bfound = FALSE;

	if (!host || !retval)
		return E_POINTER;

	retval->vt = VT_BOOL;

	// check to detemine whether this is a plain host name!
	currentch = host;
	while ((*currentch != '\0') && !bfound)
	{
		if (*currentch == '.')
			bfound = TRUE;
		else
			currentch++;
	}

	if (bfound)
		retval->boolVal = VARIANT_FALSE;
	else
		retval->boolVal = VARIANT_TRUE;

	return S_OK;
}

STDMETHODIMP CJSProxy::dnsDomainIs(BSTR host,BSTR domain, VARIANT* retval)
{
	WCHAR *result = NULL;

	if (!host || !domain || !retval)
		return E_POINTER;
	
	result = StrStrW(host,domain);
	retval->vt = VT_BOOL;
	if (result)
		retval->boolVal = VARIANT_TRUE;
	else
		retval->boolVal = VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CJSProxy::localHostOrDomainIs(BSTR host,BSTR hostdom, VARIANT* retval)
{
	HRESULT	hr = S_OK;

	if (!host || !hostdom || !retval)
		return E_POINTER;

	// check to see if it is a local host
	hr = isPlainHostName(host,retval);
	if (SUCCEEDED(hr))
	{
		if (retval->boolVal != VARIANT_TRUE)
        {
            //
            // this is a strange function, if its not a local hostname
            //  we do a strait compare against the passed in domain
            //  string.  If its not a direct match, then its FALSE,
            //  even if the root of the domain/hostname are the same.
            //  Blame Netscape for this, we are just following their
            //  behavior and docs.
            //

            if ( StrCmpIW(host, hostdom) == 0 )
            {
                retval->boolVal = VARIANT_TRUE;
            }
            else
            {
                retval->boolVal = VARIANT_FALSE;
            }

        }
	}

	return hr;
}

// Functions that need to call back on wininet.
STDMETHODIMP CJSProxy::isResolvable(BSTR host, VARIANT* retval)
{
	
	if (!host || !retval)
		return E_POINTER;
	// call into wininet provided functions!
	retval->vt = VT_BOOL;
	if (m_pCallout)
	{
		MAKE_ANSIPTR_FROMWIDE(szhost,host);
		if (m_pCallout->IsResolvable(szhost)) 
			retval->boolVal = VARIANT_TRUE;
		else
			retval->boolVal = VARIANT_FALSE;
	}
	else
		retval->boolVal = VARIANT_FALSE;

	return S_OK;
}

STDMETHODIMP CJSProxy::isInNet(BSTR host, BSTR pattern, BSTR mask, VARIANT* retval)
{
	VARIANT	myretval;
	HRESULT	hr = S_OK;
	
	// call into wininet provided functions!
	if (!host || !pattern || !mask || !retval)
		return E_POINTER;
	// call into wininet provided functions!
	retval->vt = VT_BOOL;
	VariantInit(&myretval);

	if (m_pCallout)
	{
		hr = dnsResolve(host,&myretval);
		if (SUCCEEDED(hr))
		{
			if (myretval.vt != VT_BSTR)
			{	
				VariantClear(&myretval);
				retval->boolVal = VARIANT_FALSE;		
				return hr;
			}
		}
		else
		{
			VariantClear(&myretval);
			retval->boolVal = VARIANT_FALSE;
			return hr;	
		}

		// Fallthrough to code to check IP/pattern and mask!
	
		MAKE_ANSIPTR_FROMWIDE(szhost,myretval.bstrVal);
		MAKE_ANSIPTR_FROMWIDE(szpattern,pattern);
		MAKE_ANSIPTR_FROMWIDE(szmask,mask);

		//  Check to see if IP address from dnsResolve matches the pattern/mask!
        if ( m_pCallout->IsInNet(szhost, szpattern, szmask ) ) 
			retval->boolVal = VARIANT_TRUE;
		else
			retval->boolVal = VARIANT_FALSE;
	}
	else
		retval->boolVal = VARIANT_FALSE;
	
	VariantClear(&myretval);
	return S_OK;
}

STDMETHODIMP CJSProxy::dnsResolve(BSTR host, VARIANT* retval)
{
	char ipaddress[16];
	DWORD dwretval;
	DWORD dwipsize = 16;

	if (!host || !retval)
		return E_POINTER;
	// call into wininet provided functions!

	if (m_pCallout)
	{
		MAKE_ANSIPTR_FROMWIDE(szhost,host);
		dwretval = m_pCallout->ResolveHostName(szhost,ipaddress,&dwipsize); 
		if (dwretval == ERROR_SUCCESS)
		{
			retval->vt = VT_BSTR;
			retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
		}
		else
		{
			retval->vt = VT_BOOL;
			retval->boolVal = VARIANT_FALSE;
		}
	}
	else
	{	
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_FALSE;
	}

	return S_OK;
}

STDMETHODIMP CJSProxy::myIpAddress(VARIANT* retval)
{
	char ipaddress[16];
	DWORD dwretval;
	DWORD dwipsize = 16;

	if (!retval)
		return E_POINTER;
	// call into wininet provided functions!

	if (m_pCallout)
	{
		dwretval = m_pCallout->GetIPAddress(ipaddress,&dwipsize);
		if (dwretval == ERROR_SUCCESS)
		{
			retval->vt = VT_BSTR;
			retval->bstrVal = MakeWideStrFromAnsi((LPSTR)ipaddress,STR_BSTR);
		}
		else
		{
			retval->vt = VT_BOOL;
			retval->boolVal = VARIANT_FALSE;
		}
	}
	else
	{	
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_FALSE;
	}

	return S_OK;
}

// Back to functions implemented here.
STDMETHODIMP CJSProxy::dnsDomainLevels(BSTR host, VARIANT* retval)
{
	WCHAR	*currentch;
	DWORD	dwlevels = 0;

	if (!host || !retval)
		return E_POINTER;

	retval->vt = VT_I4;

	// check to detemine whether this is a plain host name!
	currentch = host;
	while (*currentch != L'\0')
	{
		if (*currentch == L'.')
			dwlevels++;

		currentch++;
	}

	retval->lVal = dwlevels;

	return S_OK;
}

STDMETHODIMP CJSProxy::shExpMatch(BSTR str, BSTR shexp, VARIANT* retval)
{

	if (!str || !shexp || !retval)
		return E_POINTER;

	retval->vt = VT_BOOL;
	// convert BSTR to ansi - these macros allocate memory that is freed when they
	// go out of scope!  No need to free!
	MAKE_ANSIPTR_FROMWIDE(szstr, str);
	MAKE_ANSIPTR_FROMWIDE(szshexp, shexp);
	// Call into the regular expression matching code.
	if (match(szstr,szshexp))
		retval->boolVal = VARIANT_TRUE;
	else
		retval->boolVal = VARIANT_FALSE;

	return S_OK;
}

// These are to do last!!!.
STDMETHODIMP CJSProxy::weekdayRange(BSTR wd1, BSTR wd2, BSTR gmt, VARIANT* retval)
{
	SYSTEMTIME	systime;
	SYSTEMTIME	loctime;
	char		szday[4];
	int			today = -1;
	int			day1 = -1; // days are as follows SUN = 0; MON = 1; ...;SAT = 6.
	int			day2 = -1;  
	BOOL		bIsInRange = FALSE;

	if (!wd1)
		return E_POINTER;
	if (gmt)
		GetSystemTime(&systime);

	GetDateFormat(//LOCALE_SYSTEM_DEFAULT,
					MAKELCID(MAKELANGID(LANG_ENGLISH,SUBLANG_ENGLISH_US),SORT_DEFAULT),
					NULL,
					gmt? &systime:NULL,
					"ddd",
					szday,
					4);

	if (szday)
	{
		int lcv;
		//convert all chars to upper if lowercase (don't use runtimes)
		for (lcv=0;lcv<3;lcv++)
		{
			if ((short)szday[lcv] > 90)
				szday[lcv]-=32;
		}

		today = ConvertAnsiDayToInt(szday);
	}
	
	if (today == -1)
		return E_FAIL;
	
	// compare day ranges!
	if (wd2)
	{
		// These are by definition in ALL CAPS
		MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
		MAKE_ANSIPTR_FROMWIDE(szwd2, wd2);
		if (szwd1 && szwd2)
		{
			day1 = ConvertAnsiDayToInt(szwd1);
			day2 = ConvertAnsiDayToInt(szwd2);
		}

		if ((day1 == -1) || (day2 == -1))
			return E_INVALIDARG;

		if (day1 < day2)
		{
			if ((today >= day1) && (today <= day2))
				bIsInRange = TRUE;
			else
				bIsInRange = FALSE;
		}
        else if ( day1 == day2 )
        {
            if (today == day1)
            {
                bIsInRange = TRUE;
            }
            else
            {
                bIsInRange = FALSE;
            }
        }
		else
		{
			if ((today >= day1) || (today <= day2))
                bIsInRange = TRUE;
			else
				bIsInRange = FALSE;
		}

	}
	else // only one day to check!
	{
		MAKE_ANSIPTR_FROMWIDE(szwd1, wd1);
		if (lstrcmp(szday,szwd1) == 0)
			bIsInRange = TRUE;
		else
			bIsInRange = FALSE;
	}

	if (bIsInRange)
	{
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_TRUE;
	}
	else
	{
		retval->vt = VT_BOOL;
		retval->boolVal = VARIANT_FALSE;
	}

	return S_OK;
}

STDMETHODIMP CJSProxy::dateRange(long day, BSTR month, BSTR gmt, VARIANT* retval)
{
	return S_OK;
}
STDMETHODIMP CJSProxy::timeRange(long hour, long min, long sec, BSTR gmt, VARIANT* retval)
{
	return S_OK;
}

STDMETHODIMP CJSProxy::alert(BSTR message, VARIANT* retval)
{
    if (!message)
        return E_POINTER;

    // Return true if available...not needed?
    if (retval)
    {
	    retval->vt = VT_BOOL;
        retval->vt = VARIANT_TRUE;
    }

    MAKE_ANSIPTR_FROMWIDE(szMessage,message);

    // Display the alert which isn't truly modal to the browser.
    // Getting the appropriate window handle will be quite a chore from here.
    MessageBox(
        NULL,
        szMessage,
        TEXT("Microsoft Internet Explorer"),
        MB_OK | MB_ICONEXCLAMATION | MB_TOPMOST | MB_TASKMODAL
        );

    return S_OK;
}

// don't yet know what to do with ProxyConfig.bindings.
//ProxyConfig.bindings
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\cscpsite.cpp ===
#include "cscpsite.h"


/*******************************************************************************
*	CScriptSite Functions
********************************************************************************/
CScriptSite::CScriptSite()
{
	m_refCount = 1;
	m_pios = NULL;
	m_pasp = NULL; 
	m_pScriptDispatch = NULL;
	m_Scriptdispid = -1;
	m_fInitialized = FALSE;

}
CScriptSite::~CScriptSite()
{
	if (m_fInitialized)
		DeInit();
}

STDMETHODIMP CScriptSite::Init(AUTO_PROXY_HELPER_APIS* pAPHA, LPCSTR szScript)
{
	CHAR szClassId[64];	
	CLSID clsid;
	HRESULT hr = S_OK;
	BSTR	bstrClsID = NULL;
	BSTR	bstrScriptText = NULL;
	BSTR	rgbstrNames[1] = {L"FindProxyForURL"};
	EXCEPINFO	exceptinfo;

	// pAPHA can be null - it is checked in the autoproxy object!
	if (!szScript)
		return E_POINTER;

	if (m_fInitialized)
		return hr;
	// CoCreateInstance the JScript engine.

	// Get the class id of the desired language engine
	hr = GetScriptEngineClassIDFromName(
		"JavaScript",
		szClassId,
		sizeof(szClassId)
		);
	if (FAILED(hr)) {
		return E_FAIL;
	}
	//convert CLSID string to clsid

	bstrClsID = BSTRFROMANSI(szClassId);
	if (!bstrClsID)
		goto exit;
	hr = CLSIDFromString(bstrClsID, &clsid);
	SysFreeString(bstrClsID);
	if (FAILED(hr))
		goto exit;

	// Instantiate the script engine
	hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&m_pios);
	if (FAILED(hr))
		goto exit;

	// Get the IActiveScriptParse interface, if any
	hr = m_pios->QueryInterface(IID_IActiveScriptParse, (void**) &m_pasp);
	if (FAILED(hr))
		goto exit;

	hr = m_pasp->InitNew();
	if (FAILED(hr))
		goto exit;

	// SetScriptSite to this
	hr = m_pios->SetScriptSite((IActiveScriptSite *)this);
	if (FAILED(hr))
		goto exit;
	hr = m_pios->SetScriptState(SCRIPTSTATE_INITIALIZED);

	// AddNamedItem for pUnk and set m_punkJSProxy to pUnk.
	// If we added JSProxy to the name space the store away the JSProxy objects punk.
	m_punkJSProxy = new CJSProxy;
	if( !m_punkJSProxy )
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
	m_punkJSProxy->Init(pAPHA);
	hr = m_pios->AddNamedItem(L"JSProxy",SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS);
	if (FAILED(hr))
		goto exit;
	
	// Convert the ANSI script text to a bstr.
	bstrScriptText = BSTRFROMANSI(szScript);
	if (!bstrScriptText)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}
	// Add the script text to the parser
	hr = m_pasp->ParseScriptText(
							 bstrScriptText,
							 NULL,
							 NULL,
							 NULL,
							 0,
							 0,
							 SCRIPTTEXT_ISEXPRESSION|SCRIPTTEXT_ISVISIBLE,
							 NULL,
							 &exceptinfo);
	
	SysFreeString(bstrScriptText);
	if (FAILED(hr))
		goto exit;

	hr = m_pios->SetScriptState(SCRIPTSTATE_STARTED);
	if (FAILED(hr))
		goto exit;
	// Now get the script dispatch and find the DISPID for the method just added.  since this is a single use dll
	// I can do this otherwise this would be bad.
	hr = m_pios->GetScriptDispatch(NULL,&m_pScriptDispatch);
	if (FAILED(hr))
		goto exit;
	hr = m_pScriptDispatch->GetIDsOfNames(IID_NULL,rgbstrNames,1,LOCALE_SYSTEM_DEFAULT,&m_Scriptdispid);
	if (FAILED(hr))
		goto exit;

	m_fInitialized = TRUE;

	return hr;

exit: // we come here if something fails  -  release everything and set to null.
	if (m_pios)
	{
		m_pios->Close();
		m_pios->Release();
	}
	if (m_pasp)
		m_pasp->Release();
	if (m_pScriptDispatch)
		m_pScriptDispatch->Release();
	m_pios = NULL;
	m_pasp = NULL;
	m_pScriptDispatch = NULL;
	m_Scriptdispid = -1;
	
	return hr;
}

STDMETHODIMP CScriptSite::DeInit()
{
	HRESULT hr = S_OK;

	if (m_pios)
	{
		hr = m_pios->Close();
		m_pios->Release();
	}
	if (m_pasp)
		m_pasp->Release();
	if (m_pScriptDispatch)
		m_pScriptDispatch->Release();
	m_pios = NULL;
	m_pasp = NULL;
	m_pScriptDispatch = NULL;
	m_Scriptdispid = -1;
	m_fInitialized = FALSE;

	return hr;
}

STDMETHODIMP CScriptSite::RunScript(LPCSTR szURL, LPCSTR szHost, LPSTR* result)
{
	HRESULT		hr = S_OK;
	UINT		puArgErr = 0;
	EXCEPINFO	excep;
	VARIANT		varresult;
	DISPPARAMS	dispparams;
	VARIANT		args[2]; // We always call with 2 args!

	
	if (!szURL || !szHost || !result)
		return E_POINTER;

	VariantInit(&varresult);

	dispparams.cArgs = 2;
	VariantInit(&args[0]);
	VariantInit(&args[1]);

	args[0].vt = VT_BSTR;
	args[1].vt = VT_BSTR;

	args[0].bstrVal = BSTRFROMANSI(szHost);
	args[1].bstrVal = BSTRFROMANSI(szURL);

	dispparams.rgvarg = args;

	dispparams.cNamedArgs = 0;	
	dispparams.rgdispidNamedArgs = NULL; 

	// Call invoke on the stored dispid
	hr = m_pScriptDispatch->Invoke(m_Scriptdispid,
								   IID_NULL,LOCALE_SYSTEM_DEFAULT,
								   DISPATCH_METHOD,
								   &dispparams,
								   &varresult,
								   &excep,
								   &puArgErr);

	// convert result into bstr and return ansi version of the string!
	if (varresult.vt == VT_BSTR)
	{
		MAKE_ANSIPTR_FROMWIDE(rescpy, varresult.bstrVal);
		*result = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,lstrlen(rescpy)+1);
		if (!*result)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}
		lstrcpy(*result,rescpy);

	}
	else
	{
		VARIANT	resvar;

		VariantInit(&resvar);
		hr = VariantChangeType(&resvar,&varresult,NULL,VT_BSTR);
		if (SUCCEEDED(hr))
		{
			MAKE_ANSIPTR_FROMWIDE(rescpy, resvar.bstrVal);
			*result = (LPSTR) GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT,lstrlen(rescpy)+1);
			if (!*result)
			{
				hr = E_OUTOFMEMORY;
				VariantClear(&resvar);
				goto Cleanup;
			}
			lstrcpy(*result,rescpy);
		}
		else
			*result = NULL;
		VariantClear(&resvar);
	}

Cleanup:
    VariantClear(&varresult);
	VariantClear(&args[0]);
	VariantClear(&args[1]);
	
	return hr;
}

STDMETHODIMP CScriptSite::GetLCID(LCID *plcid)
{
	return E_NOTIMPL;
}
STDMETHODIMP CScriptSite::GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppTypeInfo)
{
	if (!pstrName || !ppunkItem)
		return E_POINTER;

	if ((StrCmpW(L"JSProxy",pstrName) == 0) && (dwReturnMask == SCRIPTINFO_IUNKNOWN))
	{
		*ppunkItem = (LPUNKNOWN)(IDispatch*)(CJSProxy*)m_punkJSProxy;
		(*ppunkItem)->AddRef();
		return S_OK;
	}
	else
		return TYPE_E_ELEMENTNOTFOUND;
}
STDMETHODIMP CScriptSite::GetDocVersionString(BSTR *pstrVersionString)
{
	return E_NOTIMPL;
}

// I am not interested it the transitioning of state or the status of where we are in
// the executing of the script.
STDMETHODIMP CScriptSite::OnScriptTerminate(const VARIANT *pvarResult,const EXCEPINFO *pexcepinfo)
{
	return S_OK;
}
STDMETHODIMP CScriptSite::OnStateChange(SCRIPTSTATE ssScriptState)
{
	return S_OK;
}
STDMETHODIMP CScriptSite::OnScriptError(IActiveScriptError *pase)
{
	return S_OK;
}
STDMETHODIMP CScriptSite::OnEnterScript()
{
	return S_OK;
}
STDMETHODIMP CScriptSite::OnLeaveScript()
{
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\cscpsite.h ===
#ifndef __CSCPSITE_H__
#define __CSCPSITE_H__

#include <windows.h>
#include <olectl.h>
#include <activscp.h>
#include "jsproxy.h"
#include "utils.h"


/********************************************************************************************/
// ScriptSite Class
//
//
//
class CScriptSite : public IActiveScriptSite
{

public:
	CScriptSite();
	~CScriptSite();
	// IUnknown Interface methods.
	STDMETHODIMP QueryInterface(REFIID riid, PVOID *ppvObject)
	{
		if (riid == IID_IUnknown)
		{            
			*ppvObject = (LPVOID)(LPUNKNOWN)this;
            AddRef();
			return S_OK;
		}
		else
		{
			if (riid == IID_IActiveScriptSite)
			{
				*ppvObject = (LPVOID)(IDispatch*)this;
                AddRef();
				return S_OK;
			}
			else
			{
				*ppvObject = 0;
				return E_NOINTERFACE;
			}
		}

	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return ++m_refCount;
	}

	STDMETHODIMP_(ULONG) Release()
	{
		if (--m_refCount)
			return m_refCount;

		delete this;
		return 0;
	}

	STDMETHODIMP GetLCID(LCID *plcid);
	STDMETHODIMP GetItemInfo(LPCOLESTR pstrName, DWORD dwReturnMask, IUnknown **ppunkItem, ITypeInfo **ppTypeInfo);
	STDMETHODIMP GetDocVersionString(BSTR *pstrVersionString);
	STDMETHODIMP OnScriptTerminate(const VARIANT *pvarResult,const EXCEPINFO *pexcepinfo);
	STDMETHODIMP OnStateChange(SCRIPTSTATE ssScriptState);
	STDMETHODIMP OnScriptError(IActiveScriptError *pase);
	STDMETHODIMP OnEnterScript();
	STDMETHODIMP OnLeaveScript();

	STDMETHODIMP Init(AUTO_PROXY_HELPER_APIS* pAPHA, LPCSTR szScript);
	STDMETHODIMP DeInit();
	STDMETHODIMP RunScript(LPCSTR szURL, LPCSTR szHost, LPSTR* result);

private:
	BOOL				m_fInitialized;
	long				m_refCount;
	IActiveScript		*m_pios;
	IActiveScriptParse	*m_pasp;
	CJSProxy			*m_punkJSProxy;
	IDispatch			*m_pScriptDispatch; // Stored dispatch for script
	DISPID				m_Scriptdispid; // DISPID for stored script to facilitate quicker invoke.

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\utils.h ===
#ifndef __UTILS_H__
#define __UTILS_H__

#include <windows.h>
#include <olectl.h>
#include <shlwapi.h>

// BUGBUG - remove and include wininet.h
#include "autoprox.hxx"

/********************************************************************************************/
// ClassID and GUID helpers
HRESULT GetScriptEngineClassIDFromName(LPCSTR pszLanguage,LPSTR pszBuff,UINT cBuffSize);

/********************************************************************************************/
// String Helper functions and macros
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? (char *)&m_szTmpBuf : (new(char[cBytes]));
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) delete m_pBuf;
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

LPWSTR MakeWideStrFromAnsi( LPCSTR, BYTE bType);
#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)

int ConvertAnsiDayToInt(LPSTR szday);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\auth\test\httpauth.cxx ===
// ===========================================================================
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdlib.h>
#include <io.h>
#include <wininet.h>

BOOL g_fAllowCustomUI;
DWORD g_dwConnectFlags;
BOOL g_fPreload;
BOOL g_fMonolithicUpload = TRUE;
LPSTR g_szVerb = NULL;

//==============================================================================
BOOL NeedAuth (HINTERNET hRequest, DWORD *pdwStatus)
{
    // Get status code.
    DWORD dwStatus;
    DWORD cbStatus = sizeof(dwStatus);
    HttpQueryInfo
    (
        hRequest,
        HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
        &dwStatus,
        &cbStatus,
        NULL
    );
    fprintf (stderr, "Status: %d\n", dwStatus);
    *pdwStatus = dwStatus;

    // Look for 401 or 407.
    DWORD dwFlags;
    switch (dwStatus)
    {
        case HTTP_STATUS_DENIED:
            dwFlags = HTTP_QUERY_WWW_AUTHENTICATE;
            break;
        case HTTP_STATUS_PROXY_AUTH_REQ:
            dwFlags = HTTP_QUERY_PROXY_AUTHENTICATE;
            break;            
        default:
            return FALSE;
    }

    // Enumerate the authentication types.
    BOOL fRet;
    char szScheme[64];
    DWORD dwIndex = 0;
    do
    {
        DWORD cbScheme = sizeof(szScheme);
        fRet = HttpQueryInfo
            (hRequest, dwFlags, szScheme, &cbScheme, &dwIndex);
        if (fRet)
            fprintf (stderr, "Found auth scheme: %s\n", szScheme);
    }
        while (fRet);

    return TRUE;
}


//==============================================================================
DWORD DoCustomUI (HINTERNET hRequest, BOOL fProxy)
{
    // Prompt for username and password.
    char  szUser[64], szPass[64];
    fprintf (stderr, "Enter Username: ");
    if (!fscanf (stdin, "%s", szUser))
        return ERROR_INTERNET_LOGIN_FAILURE;
    fprintf (stderr, "Enter Password: ");
    if (!fscanf (stdin, "%s", szPass))
        return ERROR_INTERNET_LOGIN_FAILURE;

    // Set the values in the handle.
    if (fProxy)
    {
        InternetSetOption
            (hRequest, INTERNET_OPTION_PROXY_USERNAME, szUser, sizeof(szUser));
        InternetSetOption
            (hRequest, INTERNET_OPTION_PROXY_PASSWORD, szPass, sizeof(szPass));
    }
    else
    {
        InternetSetOption
            (hRequest, INTERNET_OPTION_USERNAME, szUser, sizeof(szUser));
        InternetSetOption
            (hRequest, INTERNET_OPTION_PASSWORD, szPass, sizeof(szPass));
    }
    
    return ERROR_INTERNET_FORCE_RETRY;
}


//==============================================================================
int RequestLoop (int argc, char **argv)
{
    HINTERNET hInternet = NULL;
    HINTERNET hConnect  = NULL;
    HINTERNET hRequest  = NULL;
    PSTR pPostData = NULL;
    DWORD cbPostData = 0;

    PSTR pszErr = NULL;
    BOOL fRet;
    
#define CHECK_ERROR(cond, err) if (!(cond)) {pszErr=(err); goto done;}

    // Parse host:port
    PSTR pszHost     = argv[0];
    DWORD dwPort;
    PSTR pszColon = strchr(pszHost, ':');
    if (!pszColon)
        dwPort = INTERNET_INVALID_PORT_NUMBER;
    else
    {
        *pszColon++ = 0;
        dwPort = atol (pszColon);
    }
    
    PSTR pszObject   = argc >= 2 ? argv[1] : "/";
    PSTR pszUser     = argc >= 3 ? argv[2] : NULL;
    PSTR pszPass     = argc >= 4 ? argv[3] : NULL;
    PSTR pszPostFile = argc >= 5 ? argv[4] : NULL;

    if (pszPostFile)
        g_dwConnectFlags |= INTERNET_FLAG_RELOAD;


//#ifdef MONOLITHIC_UPLOAD

   if(g_fMonolithicUpload) 
   {

    // Read any POST data into a buffer.
    if (pszPostFile)
    {
        HANDLE hf =
            CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);
            pPostData = (PSTR) LocalAlloc (LMEM_FIXED, cbPostData + 1);
            if (pPostData)
                ReadFile (hf, pPostData, cbPostData, &cbPostData, NULL);
            pPostData[cbPostData] = 0;
            CloseHandle (hf);
        }
    }
  }  // g_fMonolithicUpload
//#endif

    // Initialize wininet.
    hInternet = InternetOpen
    (
        //"HttpAuth Sample",            // user agent
         "Mozilla/4.0 (compatible; MSIE 4.0b2; Windows 95",
        INTERNET_OPEN_TYPE_PRECONFIG, // access type
        NULL,                         // proxy server
        0,                            // proxy port
        0                             // flags
    );
    CHECK_ERROR (hInternet, "InternetOpen");


    // Connect to host.
    hConnect = InternetConnect
    (
        hInternet,                    // wininet handle,
        pszHost,                      // host
        (INTERNET_PORT)dwPort,                       // port
        pszUser,                      // user
        NULL,                         // password
        INTERNET_SERVICE_HTTP,        // service
        g_dwConnectFlags,             // flags
        0                             // context
    );
    CHECK_ERROR (hConnect, "InternetConnect");

    // Use SetOption to set the password since it handles empty strings.
    if (pszPass)
    {
        InternetSetOption
            (hConnect, INTERNET_OPTION_PASSWORD, pszPass, lstrlen(pszPass)+1);
    }

    if(!g_szVerb)
    {
    	if (pszPostFile)
		    g_szVerb = "PUT";
	    else
		    g_szVerb = "GET";
    }

    // Create request.
    hRequest = HttpOpenRequest
    (
        hConnect,                     // connect handle
        g_szVerb, // pszPostFile? "PUT" : "GET",  // request method
        pszObject,                    // object name
        NULL,                         // version
        NULL,                         // referer
        NULL,                         // accept types
        g_dwConnectFlags              // flags
            | INTERNET_FLAG_KEEP_CONNECTION
            | SECURITY_INTERNET_MASK, // ignore SSL warnings
        0                             // context
    );
    CHECK_ERROR (hRequest, "HttpOpenRequest");
    
resend:

//    if (!pszPostFile || pPostData)
    if (g_fMonolithicUpload)
    {
        // Send request.
        fRet = HttpSendRequest
        (
            hRequest,                     // request handle
            "",                           // header string
            0,                            // header length
            pPostData,                    // post data
            cbPostData                    // post length
        );
    }
    else
    {
        HANDLE hf = CreateFile
            (
                pszPostFile,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL
            );
        if (hf != INVALID_HANDLE_VALUE)
        {
            cbPostData = GetFileSize (hf, NULL);

            INTERNET_BUFFERS BufferIn;
            BufferIn.dwStructSize = sizeof( INTERNET_BUFFERSA );
            BufferIn.Next = NULL; 
            BufferIn.lpcszHeader = NULL;
            BufferIn.dwHeadersLength = 0;
            BufferIn.dwHeadersTotal = 0;
            BufferIn.lpvBuffer = NULL;
            BufferIn.dwBufferLength = 0;
            BufferIn.dwBufferTotal = cbPostData;
            BufferIn.dwOffsetLow = 0;
            BufferIn.dwOffsetHigh = 0;

            fRet = HttpSendRequestEx (hRequest, &BufferIn, NULL, 0, 0);
            CHECK_ERROR (fRet, "HttpSendRequestEx");

            while (1)
            {
                CHAR szTemp[512];
                DWORD cbRead;
                fRet = ReadFile (hf, szTemp, sizeof(szTemp), &cbRead, 0);
                CHECK_ERROR (fRet, "ReadFile");

                if (!fRet || !cbRead)
                    break;

                DWORD cbRead2;
                fRet = InternetWriteFile (hRequest, szTemp, cbRead, &cbRead2);
                CHECK_ERROR (fRet, "InternetWriteFile");
            }

            CloseHandle (hf);

            fRet = HttpEndRequest (hRequest, NULL, 0, 0);
            if (!fRet && GetLastError() == ERROR_INTERNET_FORCE_RETRY)
                goto resend;
        }
    }


    DWORD dwStatus;
   
    // Check if the status code is 401 or 407
    if (NeedAuth (hRequest, &dwStatus) && (g_fAllowCustomUI))
    {
        // Prompt for username and password.
        if (DoCustomUI (hRequest, dwStatus != HTTP_STATUS_DENIED))
            goto resend;
    }
    else
    {
        DWORD dwSendErr = fRet? ERROR_SUCCESS : GetLastError();

        DWORD dwDlgErr = InternetErrorDlg(
                GetDesktopWindow(),
                hRequest,  
                dwSendErr,
                FLAGS_ERROR_UI_FILTER_FOR_ERRORS  |     
                    FLAGS_ERROR_UI_FLAGS_CHANGE_OPTIONS |
                    FLAGS_ERROR_UI_FLAGS_GENERATE_DATA, 
                NULL
            );
        switch (dwSendErr)
        {
            case ERROR_SUCCESS:
            case ERROR_INTERNET_NAME_NOT_RESOLVED:
            case ERROR_INTERNET_CANNOT_CONNECT:
                if (dwDlgErr == ERROR_INTERNET_FORCE_RETRY)
                    goto resend;
                else
                    break;

            case ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION:
            default:
                if (dwDlgErr == ERROR_SUCCESS)
                    goto resend;
                else
                    break;
        }
    }

    // Dump some bytes.
    BYTE bBuf[1024];
    DWORD cbBuf;
    DWORD cbRead;
    cbBuf = sizeof(bBuf);
    _setmode( _fileno( stdout ), _O_BINARY );
    while (InternetReadFile (hRequest, bBuf, cbBuf, &cbRead) && cbRead)
        fwrite (bBuf, 1, cbRead, stdout);
    
done: // Clean up.

    if (pszErr)
        fprintf (stderr, "Failed on %s, last error %d\n", pszErr, GetLastError());
    if (hRequest)
        InternetCloseHandle (hRequest);
    if (hConnect)
        InternetCloseHandle (hConnect);
    if (hInternet)
        InternetCloseHandle (hInternet);
    if (pPostData)
        LocalFree (pPostData);
    return 0;
}

//==============================================================================
void ParseArguments 
(
    LPSTR  InBuffer,
    LPSTR* CArgv,
    DWORD* CArgc
)
{
    LPSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            if( *CurrentPtr == '"' ) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = '\0';     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == ' ') ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == '\0') )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
    }

    *CArgc = i;
    return;
}

//==============================================================================
int __cdecl main (int argc, char **argv)
{
	g_fAllowCustomUI = 0; //FALSE;
    g_dwConnectFlags = 0;
	HMODULE hmodShlwapi = NULL;
	char * port    ;
	// Discard program arg.
    argv++;
    argc--;

    // Parse options.
    while (argc && argv[0][0] == '-')
    {
        switch (tolower(argv[0][1]))
        {
            case 'c':
                g_fAllowCustomUI = TRUE;
                break;
                
            case 's':
                g_dwConnectFlags = INTERNET_FLAG_SECURE;
                break;
                
            case 'p':
                g_fPreload = TRUE;
                break;
                
            case 'v':
        		port = *argv;
        		port +=2;
        		fprintf(stderr,"Verb: %s\n", port);
                if(port)
        			g_szVerb = port;
                break;
                
            case 'm':
                g_fMonolithicUpload = TRUE;
                break;
                
            default:
                fprintf (stderr, "\nUsage: httpauth [-c] [-s] <server> [<object> [<user> [<pass> [<POST-file>]]]]");
                fprintf (stderr, "\n  -c: Custom UI to prompt for user/pass");
                fprintf (stderr, "\n  -s: Secure connection (ssl or pct)");
                fprintf (stderr, "\n  -m: Monolithic upload");
                fprintf (stderr, "\n  -o<port#> : Port Number");
                exit (1);
        }
        
        argv++;
        argc--;
    }

	if (g_fPreload)
	{
	//Get the current directory in case the user selects -p to preload shlwapi from current dir 
		char buf[256];
		GetCurrentDirectory((DWORD)256, buf); 
		strcat(buf,"\\shlwapi.dll");
		fprintf(stderr, "\nPreloading shlwapi.dll from %s", buf);
		if (!(hmodShlwapi=LoadLibrary(buf))) fprintf(stderr, "\nPreload of shlwapi.dll failed");
	}

    if (argc)
        RequestLoop (argc, argv);
        
    else // Enter command prompt loop
    {
        fprintf (stderr, "\nUsage: <server> [<object> [<user> [<pass> [<POST-file>]]]]");
        fprintf (stderr, "\n  quit - exit the command loop");
        fprintf (stderr, "\n  flush - flush pwd cache and authenticated sockets");
        
        while (1)
        {
            char szIn[1024];
            DWORD argcIn;
            LPSTR argvIn[10];

            fprintf (stderr, "\nhttpauth> ");
            gets (szIn);

            if (!lstrcmpi (szIn, "quit"))
                break;
            else if (!lstrcmpi (szIn, "flush"))
            {
                InternetSetOption
                    (NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0);
                continue;
            }
            
            argcIn = 0;
            ParseArguments (szIn, argvIn, &argcIn);
            if (!argcIn)
                break;
            RequestLoop (argcIn, argvIn);
        }                
    }

	//unload shlwapi if loaded
	if (hmodShlwapi) FreeLibrary(hmodShlwapi);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\bgtask.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    bgtask.cxx

Abstract:

    Contains background task and support functions 

    Contents:
        LoadBackgroundTaskMgr
        UnloadBackgroundTaskMgr
        NotifyBackgroundTaskMgr
        CreateAndQueueBackgroundWorkItem

        BackgroundTaskMgr::QueueBackgroundWorkItem
        BackgroundTaskMgr::DeQueueAndRunBackgroundWorkItem 
        BackgroundTaskMgr::CreateBackgroundFsm
        BackgroundTaskMgr::Release
        BackgroundTaskMgr::HasBandwidth

        CFsm_BackgroundTask::RunSM
        CFsm_BackgroundTask::DoSendReq
        CFsm_BackgroundTask::~CFsm_BackgroundTask
Author:

    Danpo Zhang (danpoz) 06-26-98

Environment:

    Win32 user-mode

Revision History:

    06-26-1998 danpoz 
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

BackgroundTaskMgr* g_BGTaskMgr = NULL;

//
// API: Init global BackgroundTaskManager
//
BOOL
LoadBackgroundTaskMgr()
{
    if( g_BGTaskMgr )
        return TRUE;

    BackgroundTaskMgr* bgMgr = NULL;
    bgMgr = new BackgroundTaskMgr();
    if( !bgMgr)
        return FALSE;

    g_BGTaskMgr = bgMgr;

    return TRUE;
}

//
// API: Unload global BackgroundTaskManager
//
void
UnloadBackgroundTaskMgr()
{
    if( g_BGTaskMgr )
    {
        //BUGBUG
        //what to do with unfinished task?
        delete g_BGTaskMgr;
    }

    g_BGTaskMgr = NULL;
}


//
// API: Select thread notifis now is a good time to do background task 
//
DWORD
NotifyBackgroundTaskMgr()
{
    DWORD error;

    // can we run another background item?
    if( !g_BGTaskMgr->HasBandwidth() )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    // get a background FSM if there is any 
    g_BGTaskMgr->DeQueueAndRunBackgroundWorkItem();

    error = ERROR_SUCCESS;
quit:
    return error;
}


//
// create a background task (fsm) and queue it on the background task
// list, the task item will be picked up later by a free async worker
// thread
//
DWORD
CreateAndQueueBackgroundWorkItem(
    IN  LPCSTR  szUrl
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CreateAndQueueBackgroundWorkItem",
                 "%q",
                 szUrl 
                 ));

    DWORD   error;
    CFsm*   pFsm = NULL;

    INET_ASSERT( szUrl );

    // get new fsm
    pFsm = g_BGTaskMgr->CreateBackgroundFsm(szUrl);
    if( !pFsm )
    {
        error = ERROR_NOT_ENOUGH_MEMORY; 
        goto quit;
    }

    // queue fsm
    error = g_BGTaskMgr->QueueBackgroundWorkItem(pFsm);
    if( error != ERROR_SUCCESS )
    {
        // delete the fsm to avoid leak
        delete pFsm;
    }

quit:
    DEBUG_LEAVE(error);
    return error;

}

DWORD
BackgroundTaskMgr::QueueBackgroundWorkItem(
    IN CFsm* pFsm
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueBackgroundWorkItem",
                 "%#x",
                 pFsm
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    INET_ASSERT(lpThreadInfo != NULL);

    if( lpThreadInfo != NULL )
    {
        _bgTaskQueue.Acquire();
        _bgTaskQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        _bgTaskQueue.Release();

        error = ERROR_SUCCESS;

        if (g_bHibernating)
        {
            InterruptSelect();
        }
    }

    DEBUG_LEAVE(error);
    return error;
}



DWORD 
BackgroundTaskMgr::DeQueueAndRunBackgroundWorkItem()
{

    // LOCK list
    _bgTaskQueue.Acquire();
    
    // check the list to see if it is empty
    if( _bgTaskQueue.Head() != _bgTaskQueue.Self() )
    {
        PLIST_ENTRY pEntry = NULL;
        PLIST_ENTRY pPrev = NULL;
        
        pPrev = _bgTaskQueue.Self();
        pEntry = ((CPriorityListEntry*)pPrev)->Next();

        CFsm* pFsm = ContainingFsm(pEntry);
        INET_ASSERT(pFsm);

        // deQueued, we can remove the task item from the queue 
        // remove from the blocked list
        _bgTaskQueue.Remove((CPriorityListEntry *)pFsm);

        // increment the active running fsm count
        InterlockedIncrement(&_lActiveFsm);

        // this fsm will be picked up by a waken worker thread
        pFsm->QueueWorkItem();
    }

    // UNLOCK list
    _bgTaskQueue.Release();

    return ERROR_SUCCESS;
}

CFsm*
BackgroundTaskMgr::CreateBackgroundFsm(LPCSTR szUrl)
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    // HACK - HACK for TESTING... 
    // correct solution is when lpThreadInfo->Fsm != NULL
    // we do not create a fsm so that we always make sure
    // there is one fsm on the select thread 
    //
    if( lpThreadInfo != NULL )
    {
        lpThreadInfo->Fsm = NULL;
    }

    return new CFsm_BackgroundTask(this, szUrl);
}
    

BOOL
BackgroundTaskMgr::HasBandwidth()
{
    // only one fsm can be picked at anytime
    return !_lActiveFsm;  
}


BackgroundTaskMgr::BackgroundTaskMgr() 
    : _lActiveFsm(0)
{
}

void 
BackgroundTaskMgr::NotifyFsmDone()
{
    InterlockedDecrement(&_lActiveFsm);
}



DWORD 
CFsm_BackgroundTask::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm_BackgroundTask::RunSM",
                 "%#x",
                 Fsm
                 ));

    
    CFsm_BackgroundTask* fsm = (CFsm_BackgroundTask*) Fsm;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL fIsAsyncWorkerThread = TRUE;

    if( lpThreadInfo )
    {
        fIsAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
        lpThreadInfo->IsAsyncWorkerThread = FALSE;
    }

    switch( fsm->GetState() ) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        fsm->DoSendReq();

    default:
        break;
    }

    fsm->SetDone(0);
    if( lpThreadInfo )
    {
        lpThreadInfo->IsAsyncWorkerThread = fIsAsyncWorkerThread;
    }
    DEBUG_LEAVE(0);
    return 0;
}


typedef HRESULT (WINAPI * pfnObtainUA)(DWORD, LPSTR, DWORD*);

DWORD
CFsm_BackgroundTask::DoSendReq()
{
    HINTERNET hInternet = NULL;
    HINTERNET hRequest = NULL;
    CHAR szBuffer[4000];
    DWORD dwBytesRead;
    BOOL  fSuccess;

    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;
    BOOL  fUAFromUrlmon = FALSE;


    CHAR*  pszUA = NULL;

    HINSTANCE hinst = GetModuleHandle(URLMON_DLL);
    if( hinst )
    {
        pfnObtainUA pfnUA = (pfnObtainUA)
            GetProcAddress(hinst, "ObtainUserAgentString");

        if( pfnUA )
        {
            DWORD dwSize = MAX_PATH;
            pszUA = new CHAR[dwSize];
            if( pszUA )
            {
                HRESULT hr = (*pfnUA)(0, pszUA, &dwSize);
            
                if( S_OK == hr )
                {
                    fUAFromUrlmon = TRUE;
                }
                else if( E_OUTOFMEMORY == hr )
                {
                    // the original pszUA is allocated too small
                    // we need bigger buffer size (returned by dwSize)
                    delete [] pszUA;
            
                    pszUA = new CHAR[dwSize];
                    if( pszUA )
                    { 
                        hr = (*pfnUA)(0, pszUA, &dwSize);
                        if( S_OK == hr )
                        {
                            fUAFromUrlmon = TRUE;
                        }
                    } 
                } // original buffer too small, create bigger one
            }  
        } // get the pFN to UA agent
    } // urlmon is loaded

    if( fUAFromUrlmon && pszUA)
    {
        hInternet = InternetOpen(
                pszUA, 
                INTERNET_OPEN_TYPE_PRECONFIG,
                NULL,
                NULL,
                0 );
    }
    else
    {
        hInternet = InternetOpen(
                gszDefaultUserAgent,
                INTERNET_OPEN_TYPE_PRECONFIG,
                NULL,
                NULL,
                0 );
    }

    if( !hInternet )
    {
        goto quit;
    }

    hRequest = InternetOpenUrl(
                hInternet,
                m_lpszUrl,
                "Accept: */*\r\n", 
                (DWORD) -1,
                INTERNET_FLAG_RESYNCHRONIZE | INTERNET_FLAG_BGUPDATE | INTERNET_FLAG_KEEP_CONNECTION,
                INTERNET_NO_CALLBACK
                );

    if( !hRequest )
    {
        DWORD dwLastErr = 0;
        dwLastErr = GetLastError();
        goto quit;
    }

    
    do {
        dwBytesRead = 0;

        fSuccess = InternetReadFile(
                        hRequest,
                        szBuffer,
                        sizeof(szBuffer)-1,
                        &dwBytesRead
                        );

        if( !fSuccess )
        {
            goto quit;
        }

    } while ( dwBytesRead != 0 );        

    error = ERROR_SUCCESS;

quit:
    if( hRequest )
        InternetCloseHandle(hRequest);
    if( hInternet )
        InternetCloseHandle(hInternet);

    if( fUAFromUrlmon && pszUA )
        delete [] pszUA;

    return error;
}

CFsm_BackgroundTask::~CFsm_BackgroundTask()
{
    DELETE_MANDATORY_PARAM(m_lpszUrl);
    m_pMgr->NotifyFsmDone();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\regexp.cpp ===
#include <regexp.h>

BOOL test_match(int m, LPSTR target, int pattern[])     /* m = length of target */
{
    int    *match;
    int     i = -1;     /* Will be advanced to 0 */
    int     j = 0;      /* i = index to pattern, j = index to target */
    BOOL    fResult = FALSE;

    match = new int[INTERNET_MAX_URL_LENGTH];
    if (match == NULL)
        goto Cleanup;

advance:
    ++i;
    if (j > m)
        goto Cleanup;

    switch (pattern[i]) {
    case PAT_START:  if (j != 0) goto Cleanup; match[i] = 0; goto advance;
    case PAT_END:    if (target[j] == 0) {fResult = TRUE; goto Cleanup;} else goto retreat;
    case PAT_STAR:   match[i] = j = m; goto advance;
    case PAT_QUES:   if (j < m) goto match_one; else goto retreat;
    case PAT_AUGDOT: if (target[j] == '.') goto match_one;
             else if (target[j] == 0) goto match_zero;
             else goto retreat;
    case PAT_AUGQUES: if (target[j] && target[j] != '.')
            goto match_one; else goto match_zero;
    case PAT_AUGSTAR: if (target[j] && target[j] != '.') 
            goto match_one; else goto retreat;
    default:          if (target[j] == pattern[i])
            goto match_one; else goto retreat;
    }
match_one: match[i] = ++j; goto advance;
match_zero: match[i] = j; goto advance;

retreat:
    --i;
    switch (pattern[i]) {
    case PAT_START:  goto Cleanup;
    case PAT_END:    goto Cleanup;     /* Cannot happen */
    case PAT_STAR:   if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_QUES:   goto retreat;
    case PAT_AUGDOT: goto retreat;
    case PAT_AUGQUES: if (match[i] == match[i-1]) goto retreat;
             j = --match[i]; goto advance;
    case PAT_AUGSTAR: goto retreat;
    default:          goto retreat;
    }

Cleanup:
    if (match)
        delete [] match;

    return fResult;
}

BOOL parse_pattern(LPSTR s, int pattern[])
{
    int i = 1;

    pattern[0] = PAT_START; /* Can be hard-coded into pattern[] */
    for (;;) {
    switch (*s) {
        case '*':   pattern[i] = PAT_STAR; break;
        case '?':   pattern[i] = PAT_QUES; break;
        case '^':
        switch (*++s) {
        case '.': pattern[i] = PAT_AUGDOT; break;
        case '?': pattern[i] = PAT_AUGQUES; break;
        case '*': pattern[i] = PAT_AUGSTAR; break;
        default: return FALSE;
        }
        break;
        case 0: pattern[i] = PAT_END; return TRUE;
        default:    pattern[i] = *s; break;
    }
    if (++i >= INTERNET_MAX_URL_LENGTH) return FALSE;
    ++s;
    }
}

BOOL match( LPSTR target, LPSTR regexp) 
{
    int *pattern;
    BOOL result;

    pattern = new int[INTERNET_MAX_URL_LENGTH];

    if (!target || (pattern==NULL))
        return FALSE;

    if (!parse_pattern(regexp,pattern)) 
        return FALSE;
    if (lstrlen(target) >= INTERNET_MAX_URL_LENGTH) 
        return FALSE;

    result = test_match(lstrlen(target),target,pattern);
    delete [] pattern;
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\unxutil.cpp ===
#include <windows.h>
#include <winsock.h>
#include <wininet.h>
#undef INTERNET_MAX_URL_LENGTH
#include "autoprox.hxx"

#define INET_ASSERT
#define DEBUG_PRINT(a,b,c)
#define PERF_LOG(a,b)

DWORD
AUTO_PROXY_HELPER_APIS::ResolveHostName(
    IN LPSTR lpszHostName,
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Resolves a HostName to an IP address by using Winsock DNS.
 
Arguments:
 
    lpszHostName   - the host name that should be used.
 
    lpszIPAddress  - the output IP address as a string.
 
    lpdwIPAddressSize - the size of the outputed IP address string.
 
Return Value:
 
    DWORD
        Win32 error code.
 
--*/
 
{
    //
    // figure out if we're being asked to resolve a name or an address. If
    // inet_addr() succeeds then we were given a string respresentation of an
    // address
    //
 
    DWORD ipAddr;
    LPBYTE address;
    LPHOSTENT lpHostent;
    DWORD ttl;
    DWORD dwIPAddressSize;
    BOOL bFromCache = FALSE;
 
    DWORD error = ERROR_SUCCESS;
 
    ipAddr = inet_addr(lpszHostName);
    if (ipAddr != INADDR_NONE)
    {
        dwIPAddressSize = lstrlen(lpszHostName);
 
        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
 
        lstrcpy(lpszIPAddress, lpszHostName);
        goto quit;
    }
 
    ipAddr = 0;
    address = (LPBYTE) &ipAddr;
 
    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //
 
//    if (QueryHostentCache(lpszHostName, address, &lpHostent, &ttl)) {
//        bFromCache = TRUE;
//    } else {
      {
 
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("resolving %q\n",
                    lpszHostName
                    ));
 
        PERF_LOG(PE_NAMERES_START, 0);
 
        lpHostent = gethostbyname(lpszHostName);
 
        PERF_LOG(PE_NAMERES_END, 0);
 
        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    lpHostent ? "" : "NOT "
                    ));
 
 
        //
        // if we successfully resolved the name or address then add the
        // information to the cache
        //
 
        if (lpHostent != NULL)
        {
//            CacheHostent(lpszHostName, lpHostent, LIVE_DEFAULT);
        }
    }
 
 
    if ( lpHostent )
    {
        char *pszAddressStr;
        LPBYTE * addressList;
        struct  in_addr sin_addr;
 
        //     *(LPDWORD)&lpSin->sin_addr = *(LPDWORD)addressList[i];
        //              ((struct sockaddr_in*)lpSockAddr)->sin_addr
        //                   struct  in_addr sin_addr
 
        addressList         = (LPBYTE *)lpHostent->h_addr_list;
        *(LPDWORD)&sin_addr = *(LPDWORD)addressList[0] ;
 
        pszAddressStr = inet_ntoa (sin_addr);
 
        INET_ASSERT(pszAddressStr);
 
        dwIPAddressSize = lstrlen(pszAddressStr);
 
        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
 
        lstrcpy(lpszIPAddress, pszAddressStr);
 
        goto quit;
 
    }
 
    //
    // otherwise, if we get here its an error
    //
 
    error = ERROR_INTERNET_NAME_NOT_RESOLVED;
 
quit:
 
    if (bFromCache) {
 
        INET_ASSERT(lpHostent != NULL);
 
//        ReleaseHostentCacheEntry(lpHostent);
    }

    return error;
}

BOOL
AUTO_PROXY_HELPER_APIS::IsResolvable(
    IN LPSTR lpszHost
    )
 
/*++
 
Routine Description:
 
    Determines wheter a HostName can be resolved.  Performs a Winsock DNS query,
      and if it succeeds returns TRUE.
 
Arguments:
 
    lpszHost   - the host name that should be used.
 
Return Value:
 
    BOOL
        TRUE - the host is resolved.
 
        FALSE - could not resolve.
 
--*/
 
{
 
    DWORD dwDummySize;
    DWORD error;
 
    error = ResolveHostName(
                lpszHost,
                NULL,
                &dwDummySize
                );
 
    if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        return TRUE;
    }
    else
    {
        INET_ASSERT(error != ERROR_SUCCESS );
        return FALSE;
    }
 
}
DWORD
AUTO_PROXY_HELPER_APIS::GetIPAddress(
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Acquires the IP address string of this client machine WININET is running on.
 
Arguments:
 
    lpszIPAddress   - the IP address of the machine, returned.
 
    lpdwIPAddressSize - size of the IP address string.
 
Return Value:
 
    DWORD
        Win32 Error.
 
--*/
 
{
 
    CHAR szHostBuffer[255];
    int serr;
 
    serr = gethostname(
                szHostBuffer,
                255-1 
                );
 
    if ( serr != 0)
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }
 
    return ResolveHostName(
                szHostBuffer,
                lpszIPAddress,
                lpdwIPAddressSize
                );
 
}

BOOL
AUTO_PROXY_HELPER_APIS::IsInNet(
    IN LPSTR   lpszIPAddress,
    IN LPSTR   lpszDest,
    IN LPSTR   lpszMask
    )
 
/*++
 
Routine Description:
 
    Determines whether a given IP address is in a given dest/mask IP address.
 
Arguments:
 
    lpszIPAddress   - the host name that should be used.
 
    lpszDest        - the IP address dest to check against.
 
    lpszMask        - the IP mask string
 
Return Value:
 
    BOOL
        TRUE - the IP address is in the given dest/mask
 
        FALSE - the IP address is NOT in the given dest/mask
 
--*/
 
{
    DWORD dwDest, dwIpAddr, dwMask;
 
    INET_ASSERT(lpszIPAddress);
    INET_ASSERT(lpszDest);
    INET_ASSERT(lpszMask);
 
    dwIpAddr = inet_addr(lpszIPAddress);
    dwDest = inet_addr(lpszDest);
    dwMask = inet_addr(lpszMask);
 
    if ( dwDest   == INADDR_NONE ||
         dwIpAddr == INADDR_NONE  )
 
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
 
        if ( (dwIpAddr & dwMask) != dwDest)
    {
        return FALSE;
        }
 
    //
    // Pass, its Matches.
    //
 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\autoconf\utils.cpp ===
#include "utils.h"

//----------------------------------------------------------------------------
// HELPER FUNCTIONS
//----------------------------------------------------------------------------


// Function to get the coclass ClassId of a script engine given its name

HRESULT GetScriptEngineClassIDFromName(
	LPCSTR pszLanguage,
	LPSTR pszBuff,
	UINT cBuffSize)
{
	HKEY hKey = NULL;
	HKEY hKeySub;
	LONG result;
	HRESULT hr;
	LONG cClassIdLen;

	// Open \HKEY_CLASSES_ROOT\[pszLanguage]

	// LONG RegOpenKeyEx(
    //	HKEY	hKey,		// handle of open key
    //	LPCTSTR	lpSubKey,	// address of name of subkey to open
    //	DWORD	ulOptions,	// reserved
    //	REGSAM	samDesired,	// security access mask
    //	PHKEY	phkResult 	// address of handle of open key
	// );	

	result = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszLanguage, 0, KEY_READ, &hKey);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	// Make sure this object supports OLE Scripting

	result = RegOpenKeyEx(hKey, "OLEScript", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	RegCloseKey(hKeySub);

	// Get the class ID

	// LONG RegQueryValueEx(
    //	HKEY	hKey,			// handle of key to query
    //	LPTSTR	lpValueName,	// address of name of value to query
    //	LPDWORD	lpReserved,		// reserved
    //	LPDWORD	lpType,			// address of buffer for value type
    //	LPBYTE	lpData,			// address of data buffer
    //	LPDWORD	lpcbData	 	// address of data buffer size
    // );

	result = RegOpenKeyEx(hKey, "CLSID", 0, KEY_READ, &hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	cClassIdLen = cBuffSize;
	result = RegQueryValue(hKeySub, NULL, pszBuff, &cClassIdLen);

	RegCloseKey(hKeySub);

	if (result != ERROR_SUCCESS) {
		hr = E_FAIL;
		goto exit;
	}

	pszBuff[cBuffSize-1] = '\0';

	hr = S_OK;

exit:
	if (hKey) {
		RegCloseKey(hKey);
	}

	return hr;
}


//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPCSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr, +1 for terminating null
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        return NULL;
                ;
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

int ConvertAnsiDayToInt(LPSTR szday)
{
	int today = -1;
	if (szday)  // GetDateFormat always returns mixed caps and since this comes from a Win32 API I will
	{			// assume a properly formatted string! :)
		switch (szday[0])
		{
		case 'S' :
			if (lstrcmp(szday,"SUN") == 0)
				today = 0;
			else
			{
				if (lstrcmp(szday,"SAT") == 0)	
					today = 6;
			}
			break;

		case 'M' :
			if (lstrcmp(szday,"MON") == 0)
				today = 1;
			break;

		case 'T' :
			if (lstrcmp(szday,"TUE") == 0)
				today = 2;
			else
			{
				if (lstrcmp(szday,"THU") == 0)	
				today = 4;
			}
			break;

		case 'W' :
			if (lstrcmp(szday,"WED") == 0)
				today = 3;
			break;

		case 'F' :
			if (lstrcmp(szday,"FRI") == 0)
				today = 5;
			break;
		
		}
	}
	return today;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\buffer.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    buffer.cxx

Abstract:

    Contains code to impliment a double buffering class used in SSL/PCT (secure channel)
        transactions.


Author:

    Arthur L Bierer (arthurbi) 20-March-1996

Revision History:

    20-March-1996 arthurbi
        Created

--*/

#include <wininetp.h>


BOOL
DBLBUFFER::InitBuffer(
    BOOL fDblBufferMode
    )

/*++

Routine Description:

    Allocates, and initalizes internal buffers.

Arguments:

    fDblBufferMode  - TRUE if we are to maintain to buffers,
                      FALSE if we treat the output and input buffers the same

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, not enough memory to allocate buffers.

Comments:


--*/

{
    DEBUG_ENTER((DBG_BUFFER,
                 Bool,
                 "DBLBUFFER::InitBuffer",
                 "%B",
                 fDblBufferMode
                 ));

    INET_ASSERT(_lpBuffer == NULL);
    INET_ASSERT(_dwInitDefaultBufferSize > 0 );

    _lpBuffer = (LPBYTE)ALLOCATE_FIXED_MEMORY(_dwInitDefaultBufferSize);

    DEBUG_PRINT(API,
                INFO,
                ("allocated %d byte buffer %#x\n",
                _dwInitDefaultBufferSize,
                _lpBuffer
                ));

    BOOL success = FALSE;

    if (_lpBuffer != NULL) {

        INET_ASSERT(_dwBufferOut == 0);
        INET_ASSERT(_dwBufferIn == 0);

        _fDblBufferMode = fDblBufferMode;

        _dwBufferLength = _dwInitDefaultBufferSize ;
        _lpBufferOut = _lpBuffer + _dwBufferLength;
        _lpBufferIn      = _lpBuffer + _dwBufferLength;

        success = TRUE;
    }

    DEBUG_LEAVE(success);

    return success;
}

DWORD
DBLBUFFER::GetInputBufferRemaining(
    VOID
    )

/*++

Routine Description:

    Determines the amount of free bytes availble for reading into the input buffer.
        Will attempt to push current data to the front of the buffer, to make the
        most room in the currently allocated buffer.

Arguments:

    none.

Return Value:

    DWORD
        Number of bytes free.

Comments:

        Assumed to only be called in DblBuffer mode.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Int,
                 "DBLBUFFER::GetInputBufferRemaining",
                 NULL
                 ));


    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );


    BOOL fIsInputBufferCompressed = (_lpBufferIn == _lpBuffer);

    if ( ! fIsInputBufferCompressed )
    {
        BOOL fIsSuccess;

        fIsSuccess = CompressInputBufferUsage( ) ;

        INET_ASSERT(fIsSuccess);
    }

    INET_ASSERT(_lpBufferIn == _lpBuffer );

    DEBUG_LEAVE((DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) ));

    return (DWORD) (_lpEndOfBuffer - (_dwBufferIn + _lpBuffer) );
}

BOOL
DBLBUFFER::CopyIn(
    IN LPBYTE lpBuffer,
    IN DWORD dwBufferSize
    )
{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyIn",
                 "%x, %d",
                 lpBuffer,
                 dwBufferSize
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(dwBufferSize > 0);

    LPBYTE pbPointer;
    DWORD  dwCurInputSize;

    //
    // Get the current input buffer size
    //

    dwCurInputSize = GetInputBufferSize();

    if ( ! ResizeBufferIfNeeded(dwBufferSize) )
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    pbPointer = GetInputBufferPointer()+dwCurInputSize;
    SetInputBufferSize(dwBufferSize+dwCurInputSize);


    CopyMemory(
        pbPointer,             // dest
        lpBuffer,              // src
        dwBufferSize           // size
        );


    DEBUG_LEAVE(TRUE);

    return TRUE;

}

BOOL
DBLBUFFER::CopyOut(
    OUT LPBYTE     lpBuffer,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN OUT LPDWORD lpdwBytesRead
    )

/*++

Routine Description:

    Fills passed in buffer with the contents of the output buffer.

Arguments:

    lpBuffer                    -       Buffer to fill with output buffer bytes

        lpdwBufferRemaining -   Number of bytes remaining in Buffer to fill.

        lpdwBytesReceived       -       Number of bytes currently in Buffer to fill.

        lpdwBytesRead           -       Current total of bytes copied into Buffer to fill.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:


--*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CopyOut",
                 "%x, %u, %u, %u",
                 lpBuffer,
                 (lpdwBufferRemaining ? *lpdwBufferRemaining : 0),
                 (lpdwBytesReceived ? *lpdwBytesReceived : 0),
                 (lpdwBytesRead ? *lpdwBytesRead : 0)
                 ));


    INET_ASSERT(lpBuffer);
    INET_ASSERT(lpdwBufferRemaining);
    INET_ASSERT(lpdwBytesReceived);
    INET_ASSERT(lpdwBytesRead);

    //
    // Figure out the max number of bytes we can copy into our user's buffer
    //      We need to make sure it will fit into the user's buffer.
    //

    DWORD dwBytesToCopy = (*lpdwBufferRemaining  >= _dwBufferOut)
            ? _dwBufferOut : *lpdwBufferRemaining;


    DEBUG_PRINT(API,
                INFO,
                ("DBLBUFFER::CopyOut: Copying ( to: %x bytes-to-copy=%d )\n",
                (lpBuffer+*lpdwBytesReceived),
                dwBytesToCopy
                ));


    //
    // Transfer Data to User's buffer.
    //

    CopyMemory ((lpBuffer+*lpdwBytesReceived),
                            _lpBufferOut,
                            dwBytesToCopy);


    //
    // Update the number of bytes we copied to the user buffer
    //

    *lpdwBytesRead                  += dwBytesToCopy;
    *lpdwBytesReceived              += dwBytesToCopy;
    *lpdwBufferRemaining    -= dwBytesToCopy;

    //
    // Update Our Internal Vars
    //

    _dwBufferOut                    -= dwBytesToCopy;
    _lpBufferOut                    += dwBytesToCopy;

    UpdateVars();

    //
    // We always succeed for now !
    //

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::CompressInputBufferUsage(
    VOID
    )
/*++

Routine Description:

        Moves the input buffer to the begining of the internal allocated buffer.
        This produces a larger block of internal free space.

Arguments:

        none.

Return Value:

    BOOL
    Success - TRUE

    Success     - FALSE, there was no need to compress the buffer.

Comments:

  Assumed to be called only if DblBufferMode is enabled.

--*/


{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::CompressInputBufferUsage",
                 NULL
                 ));

    BOOL bResult = FALSE;

    //
    // Maximize use of buffer by moving input data to the front
    // of the buffer.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0);
    INET_ASSERT(_fDblBufferMode);

    if (_lpBufferIn > _lpBuffer) {

        DEBUG_PRINT(API,
                    INFO,
                    ("compressing input buffer %d (%#x) @ %#x => %#x\n",
                    _dwBufferIn,
                    _dwBufferIn,
                    _lpBufferIn,
                    _lpBuffer
                    ));

        MoveMemory(_lpBuffer,
                   _lpBufferIn,
                   _dwBufferIn
                   );

        //
        // Input Buffer now starts at the begining of the allocated buffer
        //

        _lpBufferIn = _lpBuffer;
        bResult = TRUE;
    }

    DEBUG_LEAVE(bResult);

    return bResult;
}



BOOL
DBLBUFFER::ConcatenateOutputBufferUsage(
    IN LPBYTE lpSecondOutputBuffer,
    IN DWORD  dwSecondOutputBufferSize
    )

/*++

Routine Description:

    Combines the current output buffer with the contents of a new buffer.
    (Note: intented for use in combining decrypted data which may be seperated by
    header or trailer data)

Arguments:

    lpSecondOutputBuffer        - New Buffer to combine with internal output buffer.

    dwSecondOutputBufferSize    - Size of New Buffer in bytes.


Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    If the internal buffer is sized 0, the new buffer replaces the internal buffer.
    Its assumed that the New buffer is a former input buffer turned output by
    some external operation, such as a block decryption operation.
--*/

{


    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ConcatenateOutputBufferUsage",
                 "%x, %u",
                 lpSecondOutputBuffer,
                 dwSecondOutputBufferSize
                 ));


    //
    // Combinate Two buffers into one.
    //

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_fDblBufferMode );
    INET_ASSERT(lpSecondOutputBuffer);
    INET_ASSERT(dwSecondOutputBufferSize);

    INET_ASSERT(_lpBufferOut < _lpBufferIn );
    INET_ASSERT(lpSecondOutputBuffer >= _lpBuffer && lpSecondOutputBuffer <=_lpEndOfBuffer );



    if ( _dwBufferOut != 0 )
    {
        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ConcatenateOutputBufferUsage: Combining new data with output buffer\n"
                    ));

        MoveMemory((_lpBufferOut+_dwBufferOut),
                   lpSecondOutputBuffer,
                   dwSecondOutputBufferSize);
        //
        // Output Buffer is now bigger ( sum of orginal + new buffer size )
        //

        _dwBufferOut += dwSecondOutputBufferSize;

    }
    else
    {
        //
        // No previous output buffer, new buffer becomes output buffer
        //

        INET_ASSERT(_lpBufferOut == _lpEndOfBuffer );

        _lpBufferOut = lpSecondOutputBuffer;
        _dwBufferOut = dwSecondOutputBufferSize;

    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}


BOOL
DBLBUFFER::ResizeBufferIfNeeded(
    IN DWORD dwAddlBufferNeeded
    )

/*++

Routine Description:

    ReSizes internal buffer space to extend size of the buffer by dwAddlBufferNeeded.
    If the additional bytes can be made availble by compressing currently stored
    into one place ( ie the start of the buffer ), the reallocation of the buffer
    will not be done.

Arguments:

    dwAddlBufferNeeded  - Number of additional bytes to resize

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, the reallocation failed due to lack of memory.

Comments:

    Its assumed the caller will only use this function in dbl buffering mode.

 --*/

{

    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "DBLBUFFER::ResizeBufferIfNeeded",
                 "%u",
                 dwAddlBufferNeeded
                 ));

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(_dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DWORD dwInputBytesFree = GetInputBufferRemaining();

    INET_ASSERT(_lpBuffer == _lpBufferIn );

    //
    // #bytes needed > #bytes left free in Buffer.
    //

    if ( dwAddlBufferNeeded > dwInputBytesFree )
    {
        HLOCAL hBuffer;

        hBuffer = (HLOCAL) _lpBuffer;

        //
        // length increases by (bytes needed - current bytes free[in old buffer])
        //

        _dwBufferLength += (dwAddlBufferNeeded - dwInputBytesFree);

        DEBUG_PRINT(API,
                    INFO,
                    ("DBLBUFFER::ResizeBufferIfNeeded: Resizing Buffer to %d, addl=%d, free=%d\n",
                    _dwBufferLength,
                    dwAddlBufferNeeded,
                    dwInputBytesFree
                    ));

        INET_ASSERT(_dwBufferLength < DBLBUFFER_MAX_SIZE);

        //
        // Do Resize, and store result
        //

        _lpBuffer = (LPBYTE)ResizeBuffer(hBuffer, _dwBufferLength, FALSE);

        DEBUG_PRINT(BUFFER,
                    INFO,
                    ("resized %#x => %#x, %d bytes\n",
                    hBuffer,
                    _lpBuffer,
                    _dwBufferLength
                    ));

        if ( ! _lpBuffer )
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("DBLBUFFER::ResizeBufferIfNeeded: Failed while Resizing, Out of Mem?\n"
                        ));

            DEBUG_LEAVE(FALSE);

            return FALSE;  // failing due to NOT_ENOUGH_MEMORY
        }

        //
        // Update ReSized Buffer pointers
        //

        _lpBufferIn = _lpBuffer;

        UpdateVars();
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

BOOL
DBLBUFFER::SetOutputInputBuffer(
    IN LPBYTE lpNewOutputBuffer,
    IN DWORD  dwNewOutputBufferSize,
    IN LPBYTE lpNewInputBuffer,
    IN DWORD  dwNewInputBufferSize,
    IN BOOL   fConcatenatePreviousOutput
    )

/*++

Routine Description:

    Allows caller to specify new addresses for input and output buffer.
    If fConcatenatePreviousOutput is set, SetOutputInputBuffer will combine
    the passed in output buffer with any internal output buffer.
    Also allows size changes to buffers.

Arguments:

    lpNewOutputBuffer           - New Output Buffer.

    dwNewOutputBufferSize       - Size of New Output Buffer.

    lpNewInputBuffer            - New Input Buffer.

    dwNewInputBufferSize        - New Input Buffer Size.

    fConcatenatePreviousOutput  - TRUE if we are to combine internal output buffer
                                  with (passed in) new output buffer
                                  FALSE if we are to just replace output buffer pointers.

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE

Comments:

    Assumed to be called from double buffering mode.

--*/


{

    INET_ASSERT(_lpBuffer);
    INET_ASSERT(lpNewOutputBuffer >= _lpBuffer && lpNewOutputBuffer <= _lpEndOfBuffer );
    INET_ASSERT((lpNewInputBuffer >= _lpBuffer && lpNewInputBuffer <= _lpEndOfBuffer) || dwNewInputBufferSize == 0);
    INET_ASSERT(fConcatenatePreviousOutput || _dwBufferOut == 0 );
    INET_ASSERT(_fDblBufferMode );

    DEBUG_PRINT(API,
         INFO,
         ("DBLBUFFER::SetOutputInputBuffer: Getting New Output( %x, size=%d ) New Input( %x, size=%d)\n",
         lpNewOutputBuffer,
         dwNewOutputBufferSize,
         lpNewInputBuffer,
         dwNewInputBufferSize
         ));


    if ( fConcatenatePreviousOutput )
    {
        ConcatenateOutputBufferUsage(
                    lpNewOutputBuffer,
                    dwNewOutputBufferSize
                    );
    }
    else
    {
        _lpBufferOut = lpNewOutputBuffer;
        _dwBufferOut = dwNewOutputBufferSize;
    }


    _lpBufferIn = lpNewInputBuffer;
    _dwBufferIn = dwNewInputBufferSize;

    UpdateVars();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\fsm.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    fsm.cxx

Abstract:

    Contains CFsm class implementation

    Contents:
        ContainingFsm
        DoFsm
        CFsm::CFsm
        CFsm::~CFsm
        CFsm::Push
        CFsm::Pop
        CFsm::QueueWorkItem
        CFsm::RunWorkItem
        CFsm::Run
        [CFsm::MapType]
        [CFsm::StateName]

Author:

     Richard L Firth (rfirth) 11-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    11-Apr-1997 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

#ifdef USE_DINARES_FSM_ALLOC_CACHE

CRITICAL_SECTION        FsmAllocCritSec;
void *                  FsmAllocList;
size_t                  FsmAllocSize;

#endif

#if INET_DEBUG

struct { int size; char* name; } class_sizes[] = {
    sizeof(CFsm), "CFsm",
    sizeof(CFsm_ResolveHost), "CFsm_ResolveHost",
    sizeof(CFsm_FtpConnect), "CFsm_FtpConnect",
    sizeof(CFsm_FtpFindFirstFile), "CFsm_FtpFindFirstFile",
    sizeof(CFsm_FtpGetFile), "CFsm_FtpGetFile",
    sizeof(CFsm_FtpPutFile), "CFsm_FtpPutFile",
    sizeof(CFsm_FtpDeleteFile), "CFsm_FtpDeleteFile",
    sizeof(CFsm_FtpRenameFile), "CFsm_FtpRenameFile",
    sizeof(CFsm_FtpOpenFile), "CFsm_FtpOpenFile",
    sizeof(CFsm_FtpCreateDirectory), "CFsm_FtpCreateDirectory",
    sizeof(CFsm_FtpRemoveDirectory), "CFsm_FtpRemoveDirectory",
    sizeof(CFsm_FtpSetCurrentDirectory), "CFsm_FtpSetCurrentDirectory",
    sizeof(CFsm_FtpGetCurrentDirectory), "CFsm_FtpGetCurrentDirectory",
    sizeof(CFsm_GopherFindFirstFile), "CFsm_GopherFindFirstFile",
    sizeof(CFsm_GopherOpenFile), "CFsm_GopherOpenFile",
    sizeof(CFsm_GopherGetAttribute), "CFsm_GopherGetAttribute",
    sizeof(CFsm_InternetParseUrl), "CFsm_InternetParseUrl",
    sizeof(CFsm_InternetFindNextFile), "CFsm_InternetFindNextFile",
    sizeof(CFsm_InternetQueryDataAvailable), "CFsm_InternetQueryDataAvailable",
    sizeof(CFsm_InternetWriteFile), "CFsm_InternetWriteFile",
    sizeof(CFsm_InternetReadFile), "CFsm_InternetReadFile",
    sizeof(CFsm_SocketConnect), "CFsm_SocketConnect",
    sizeof(CFsm_SocketSend), "CFsm_SocketSend",
    sizeof(CFsm_SocketReceive), "CFsm_SocketReceive",
    //sizeof(CFsm_SocketDataAvailable), "CFsm_SocketDataAvailable",
    sizeof(CFsm_SecureConnect), "CFsm_SecureConnect",
    sizeof(CFsm_SecureHandshake), "CFsm_SecureHandshake",
    sizeof(CFsm_SecureNegotiate), "CFsm_SecureNegotiate",
    sizeof(CFsm_NegotiateLoop), "CFsm_NegotiateLoop",
    sizeof(CFsm_SecureSend), "CFsm_SecureSend",
    sizeof(CFsm_SecureReceive), "CFsm_SecureReceive",
    sizeof(CFsm_GetConnection), "CFsm_GetConnection",
    sizeof(CFsm_HttpSendRequest), "CFsm_HttpSendRequest",
    sizeof(CFsm_MakeConnection), "CFsm_MakeConnection",
    sizeof(CFsm_OpenConnection), "CFsm_OpenConnection",
    sizeof(CFsm_OpenProxyTunnel), "CFsm_OpenProxyTunnel",
    sizeof(CFsm_SendRequest), "CFsm_SendRequest",
    sizeof(CFsm_ReceiveResponse), "CFsm_ReceiveResponse",
    sizeof(CFsm_HttpReadData), "CFsm_HttpReadData",
    sizeof(CFsm_HttpWriteData), "CFsm_HttpWriteData",
    sizeof(CFsm_ReadData), "CFsm_ReadData",
    sizeof(CFsm_HttpQueryAvailable), "CFsm_HttpQueryAvailable",
    sizeof(CFsm_DrainResponse), "CFsm_DrainResponse",
    sizeof(CFsm_Redirect), "CFsm_Redirect",
    sizeof(CFsm_ReadLoop), "CFsm_ReadLoop",
    sizeof(CFsm_ParseHttpUrl), "CFsm_ParseHttpUrl",
    sizeof(CFsm_OpenUrl), "CFsm_OpenUrl",
    sizeof(CFsm_ParseUrlForHttp), "CFsm_ParseUrlForHttp",
    sizeof(CFsm_ReadFile), "CFsm_ReadFile",
    sizeof(CFsm_ReadFileEx), "CFsm_ReadFileEx",
    //sizeof(CFsm_WriteFile), "CFsm_WriteFile",
    sizeof(CFsm_BackgroundTask), "CFsm_BackgroundTask",
    sizeof(CFsm_QueryAvailable), "CFsm_QueryAvailable"
};

void dump_class_sizes() {
    for (int i = 0; i < ARRAY_ELEMENTS(class_sizes); ++i) {
        DEBUG_PRINT(ASYNC,INFO,("%s = %d\n", class_sizes[i].name, class_sizes[i].size));
    }
}

#endif

//
// functions
//

//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


VOID
FsmInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization required by functions in this module

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from LocalAlloc

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmInitialize",
                NULL
                ));

    InitializeCriticalSection(&FsmAllocCritSec);

    FsmAllocSize = sizeof(CFsm);
    if (FsmAllocSize < sizeof(CFsm_ResolveHost))
        FsmAllocSize = sizeof(CFsm_ResolveHost);
    if (FsmAllocSize < sizeof(CFsm_SocketConnect))
        FsmAllocSize = sizeof(CFsm_SocketConnect);
    if (FsmAllocSize < sizeof(CFsm_SocketSend))
        FsmAllocSize = sizeof(CFsm_SocketSend);
    if (FsmAllocSize < sizeof(CFsm_SocketReceive))
        FsmAllocSize = sizeof(CFsm_SocketReceive);
    if (FsmAllocSize < sizeof(CFsm_SecureConnect))
        FsmAllocSize = sizeof(CFsm_SecureConnect);
    if (FsmAllocSize < sizeof(CFsm_SecureHandshake))
        FsmAllocSize = sizeof(CFsm_SecureHandshake);
    if (FsmAllocSize < sizeof(CFsm_SecureNegotiate))
        FsmAllocSize = sizeof(CFsm_SecureNegotiate);
    if (FsmAllocSize < sizeof(CFsm_NegotiateLoop))
        FsmAllocSize = sizeof(CFsm_NegotiateLoop);
    if (FsmAllocSize < sizeof(CFsm_SecureSend))
        FsmAllocSize = sizeof(CFsm_SecureSend);
    if (FsmAllocSize < sizeof(CFsm_SecureReceive))
        FsmAllocSize = sizeof(CFsm_SecureReceive);
    if (FsmAllocSize < sizeof(CFsm_GetConnection))
        FsmAllocSize = sizeof(CFsm_GetConnection);
    if (FsmAllocSize < sizeof(CFsm_HttpSendRequest))
        FsmAllocSize = sizeof(CFsm_HttpSendRequest);
    if (FsmAllocSize < sizeof(CFsm_MakeConnection))
        FsmAllocSize = sizeof(CFsm_MakeConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenConnection))
        FsmAllocSize = sizeof(CFsm_OpenConnection);
    if (FsmAllocSize < sizeof(CFsm_OpenProxyTunnel))
        FsmAllocSize = sizeof(CFsm_OpenProxyTunnel);
    if (FsmAllocSize < sizeof(CFsm_SendRequest))
        FsmAllocSize = sizeof(CFsm_SendRequest);
    if (FsmAllocSize < sizeof(CFsm_ReceiveResponse))
        FsmAllocSize = sizeof(CFsm_ReceiveResponse);
    if (FsmAllocSize < sizeof(CFsm_HttpReadData))
        FsmAllocSize = sizeof(CFsm_HttpReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpWriteData))
        FsmAllocSize = sizeof(CFsm_HttpWriteData);
    if (FsmAllocSize < sizeof(CFsm_ReadData))
        FsmAllocSize = sizeof(CFsm_ReadData);
    if (FsmAllocSize < sizeof(CFsm_HttpQueryAvailable))
        FsmAllocSize = sizeof(CFsm_HttpQueryAvailable);
    if (FsmAllocSize < sizeof(CFsm_DrainResponse))
        FsmAllocSize = sizeof(CFsm_DrainResponse);
    if (FsmAllocSize < sizeof(CFsm_Redirect))
        FsmAllocSize = sizeof(CFsm_Redirect);
    if (FsmAllocSize < sizeof(CFsm_ReadLoop))
        FsmAllocSize = sizeof(CFsm_ReadLoop);
    if (FsmAllocSize < sizeof(CFsm_ParseHttpUrl))
        FsmAllocSize = sizeof(CFsm_ParseHttpUrl);
    if (FsmAllocSize < sizeof(CFsm_OpenUrl))
        FsmAllocSize = sizeof(CFsm_OpenUrl);
    if (FsmAllocSize < sizeof(CFsm_ParseUrlForHttp))
        FsmAllocSize = sizeof(CFsm_ParseUrlForHttp);
    if (FsmAllocSize < sizeof(CFsm_ReadFile))
        FsmAllocSize = sizeof(CFsm_ReadFile);
    if (FsmAllocSize < sizeof(CFsm_ReadFileEx))
        FsmAllocSize = sizeof(CFsm_ReadFileEx);
    if (FsmAllocSize < sizeof(CFsm_QueryAvailable))
        FsmAllocSize = sizeof(CFsm_QueryAvailable);

    //
    // Pre-allocate a pool of state-machines for locality of reference
    //

    for (int cPreAlloc = 8192 / FsmAllocSize; cPreAlloc > 0; --cPreAlloc)
    {
        void * pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);

        if (pFsm == NULL)
            break;

        *(void **)pFsm = FsmAllocList;
        FsmAllocList = pFsm;
    }
}


VOID
FsmTerminate(
    VOID
    )

/*++

Routine Description:

    Obverse of FsmInitialize - frees any system resources allocated by
    FsmInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                None,
                "FsmTerminate",
                NULL
                ));

    //
    // there shouldn't be any other threads active when this function is called
    // but we'll grab the critical section anyway, just to make sure
    //

    EnterCriticalSection(&FsmAllocCritSec);

    while (FsmAllocList)
    {
        void * pFsm = FsmAllocList;
        FsmAllocList = *(void **)pFsm;
        FREE_MEMORY((HLOCAL)pFsm);
    }

    LeaveCriticalSection(&FsmAllocCritSec);

    //
    // delete the critical section
    //

    DeleteCriticalSection(&FsmAllocCritSec);

    DEBUG_LEAVE(0);
}

#endif


CFsm *
ContainingFsm(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of CFsm object, including vtable

Arguments:

    lpAddress   - pointer to list inside CFsm object

Return Value:

    CFsm *  - pointer to start of object

--*/

{
    return CONTAINING_RECORD(lpAddress, CFsm, m_ListEntry);
}


//DWORD
//RunAll(
//    VOID
//    )
//{
//    DWORD error;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//
//    if (lpThreadInfo != NULL) {
//        while (lpThreadInfo->Fsm != NULL) {
//            lpThreadInfo->Fsm->Run();
//        }
//    } else {
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//    }
//    return error;
//}


DWORD
DoFsm(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Common FSM run processing

Arguments:

    pFsm    - FSM to run (maybe NULL if new failed)

Return Value:

    DWORD   - return code from running FSM

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "DoFsm",
                 "%#x (%s)",
                 pFsm,
                 pFsm->MapType()
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        if (pFsm != NULL) {
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                error = pFsm->Run(lpThreadInfo, NULL, NULL);
            } else {

                INET_ASSERT(FALSE);

                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = ERROR_INTERNET_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// methods
//


//
// This is Dinarte's experiement for reducing Mem alloc on
//  creating FSMs. Not used right now.
//

#ifdef USE_DINARES_FSM_ALLOC_CACHE


void *
CFsm::operator new(
    IN size_t Size
    )

/*++

Routine Description:

    Allocates memory for the new state-machine from a special memory pool.

Arguments:

    Size        - size of the state-machine

Return Value:

    None.

--*/

{
    VOID * pFsm;

    EnterCriticalSection(&FsmAllocCritSec);

    pFsm = FsmAllocList;

    if (pFsm)
    {
        FsmAllocList = *(void **)pFsm;
    }

    LeaveCriticalSection(&FsmAllocCritSec);

    if (pFsm == NULL)
    {
        INET_ASSERT(Size <= FsmAllocSize);

        pFsm = (void *)ALLOCATE_FIXED_MEMORY(FsmAllocSize);
    }

    return(pFsm);
}


VOID
CFsm::operator delete(
    IN VOID * pFsm
    )

/*++

Routine Description:

    Deallocates memory for the state-machine by adding it to a special
    memory pool.

Arguments:

    pFsm        - pointer to the state-machine

Return Value:

    None.

--*/

{
    if (pFsm)
    {
        EnterCriticalSection(&FsmAllocCritSec);

        *(void **)pFsm = FsmAllocList;
        FsmAllocList = pFsm;

        LeaveCriticalSection(&FsmAllocCritSec);
    }
}
#endif


CFsm::CFsm(
    IN DWORD (* lpfnHandler)(CFsm *),
    IN LPVOID lpvContext
    ) : CPriorityListEntry(0)

/*++

Routine Description:

    CFsm constructor. This gets called many times since its the base of all the
    derived FSMs

Arguments:

    lpfnHandler - state-machine handler

    lpvContext  - callee context

Return Value:

    None.

--*/

{
#if INET_DEBUG
    static bool b = TRUE;
    if (b) {
        dump_class_sizes();
        b=FALSE;
    }
#endif

    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::CFsm",
                 "{%#x}",
                 this
                 ));

    INIT_FSM();

    m_lpThreadInfo = InternetGetThreadInfo();
    if (m_lpThreadInfo == NULL) {

        INET_ASSERT(m_lpThreadInfo != NULL);

        SetError(ERROR_INTERNET_INTERNAL_ERROR);

        DEBUG_LEAVE(0);

        return;
    }
    m_dwContext = m_lpThreadInfo->Context;
    m_hObject = m_lpThreadInfo->hObject;
    m_hObjectMapped = (INTERNET_HANDLE_OBJECT *)m_lpThreadInfo->hObjectMapped;
    m_dwMappedErrorCode = m_lpThreadInfo->dwMappedErrorCode;
    m_State = FSM_STATE_INIT;
    m_NextState = FSM_STATE_CONTINUE;
    m_FunctionState = FSM_STATE_BAD;
    m_lpfnHandler = lpfnHandler;
    m_lpvContext = lpvContext;
    SetError(ERROR_SUCCESS);
    Push();
    m_Hint = FSM_HINT_SLOW;
    m_Socket = INVALID_SOCKET;
    m_Action = FSM_ACTION_NONE;
    m_dwBlockId = 0;
    m_dwTimeout = INFINITE;
    m_fTimeoutWraps = FALSE;
    m_dwTimer = 0;
    m_bTimerStarted = FALSE;
    m_bIsBlockingFsm = FALSE;
    m_bIsApi = FALSE;
    m_ApiType = ApiType_None;
    m_dwApiData = 0;
    m_ApiResult.Handle = NULL;

    DEBUG_LEAVE(0);
}


CFsm::~CFsm()

/*++

Routine Description:

    CFsm desctructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CFsm::~CFsm",
                 "{%#x}",
                 this
                 ));

    CHECK_FSM();
    CHECK_OWNED();

    Pop();    

#ifdef STRESS_BUG_DEBUG
    m_Link = (CFsm *) (DWORD_PTR)-3;
    m_dwError = 0xFEFEFEFE;
    m_lpThreadInfo = (LPINTERNET_THREAD_INFO) (DWORD_PTR)-3;
    m_dwContext = 0xFEFEFEFE;
    m_hObject = (HINTERNET)(DWORD_PTR)-3;
#endif

    DEBUG_LEAVE(0);
}


VOID
CFsm::Push(
    VOID
    )

/*++

Routine Description:

    Adds this FSM to the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Push",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    CHECK_FSM();
    CHECK_UNOWNED();
    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);

    m_Link = m_lpThreadInfo->Fsm;
    m_lpThreadInfo->Fsm = this;

    CHECK_FSM_OWNED(m_Link);
    RESET_FSM_OWNED(m_Link);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x unowned\n", m_Link
                ));

    SET_OWNED();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                this,
                GetCurrentThreadId()
                ));

    DEBUG_LEAVE(0);
}


VOID
CFsm::Pop(
    VOID
    )

/*++

Routine Description:

    Puts the next FSM (if any) at the head of the queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "CFsm::Pop",
                 "{%#x (%s:%s)}",
                 this,
                 MapState(),
                 MapFunctionState()
                 ));

    INET_ASSERT(m_lpThreadInfo != NULL);
    CHECK_INTERNET_THREAD_INFO(m_lpThreadInfo);
    CHECK_FSM();
    CHECK_OWNED();
    CHECK_FSM_UNOWNED(m_Link);

    CFsm * pNextFsm = m_Link;

    m_lpThreadInfo->Fsm = pNextFsm;

    SET_FSM_OWNED(pNextFsm);

    DEBUG_PRINT(ASYNC,
                INFO,
                ("!!! FSM %#x owned by %#x\n",
                pNextFsm,
                GetCurrentThreadId()
                ));

    if (pNextFsm != NULL) {
        pNextFsm->SetState(pNextFsm->GetNextState());
        pNextFsm->SetError(GetError());

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("next FSM %#x (%s), state %s, function-state %s\n",
                    pNextFsm,
                    pNextFsm->MapType(),
                    pNextFsm->MapState(),
                    pNextFsm->MapFunctionState()
                    ));

    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("last FSM\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


DWORD
CFsm::QueueWorkItem(
    VOID
    )

/*++

Routine Description:

    Queues this FSM to worker thread for processing. Worker thread callback is
    CFsm::RunWorkItem

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from SHQueueUserWorkItem

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::QueueWorkItem",
                 "{%#x [%s, socket %#x, block id %#x, timeout %#x, error %d, state %s:%s]}",
                 this,
                 MapType(),
                 GetSocket(),
                 GetBlockId(),
                 GetTimeout(),
                 GetError(),
                 MapState(),
                 MapFunctionState()
                 ));

    DWORD error = ERROR_IO_PENDING;

    RESET_OWNED();

    if (SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)RunWorkItem,
                            this,
                            0,
                            (DWORD_PTR)0,
                            (DWORD_PTR *)NULL,
                            NULL,
                            0)) {

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        INET_ASSERT(lpThreadInfo != NULL);

        if (lpThreadInfo != NULL) {
            lpThreadInfo->Fsm = NULL;
        }
    } else {
        error = GetLastError();
    }

    INET_ASSERT(error == ERROR_IO_PENDING);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::RunWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Run the current work item to the next block state or completion. This
    (class static) function is called in the context of a system thread pool
    callback function

Arguments:

    pFsm    - pointer to FSM to run

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    lpThreadInfo->IsAsyncWorkerThread = TRUE;

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "RunWorkItem",
                 "%#x",
                 pFsm
                 ));

    PERF_ENTER(Worker);

    DWORD error;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("%s Fsm %#x: socket %#x, block id %#x, timeout %#x, error %d\n",
                pFsm->MapType(),
                pFsm,
                pFsm->GetSocket(),
                pFsm->GetBlockId(),
                pFsm->GetTimeout(),
                pFsm->GetError()
                ));

    while (TRUE) {

        INET_ASSERT(pFsm != NULL);

        BOOL bIsApi = pFsm->IsApi();
        API_TYPE apiType = pFsm->GetApiType();

        lpThreadInfo->Fsm = pFsm;

        SET_FSM_OWNED(pFsm);

        DWORD   dwResult=0;
        DWORD   dwApiData=0;

        if (pFsm->IsInvalid())
        {
            pFsm->SetErrorState(ERROR_INTERNET_OPERATION_CANCELLED);
            pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }
        else
        {
            error = pFsm->Run(lpThreadInfo, &dwResult, &dwApiData);
        }

        //
        // We should follow the following rules for this.
        //
        //  1)  If Operation Failed
        //
        //      error != ERROR_SUCCESS && dwResult == 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      INTERNET_ASYNC_RESULT.dwResult = 0
        //      INTERNET_ASYNC_RESULT.dwError = error
                
        //  2) If operation Succeeded
        //
        //  error == ERROR_SUCCESS && dwResult != 0
        //
        //  To assign fields of INTERNET_ASYNC_RESULT, do:
        //
        //      if( ApiReturnType == HINTERNET )
        //          INTERNET_ASYNC_RESULT.dwResult = (HINTERNET)dwApiResult
        //      else
        //          if( ApiReturnType == BOOL )
        //              INTERNET_ASYNC_RESULT.dwResult = TRUE
        //          endif
        //      endif
        //
        //      INTERNET_ASYNC_RESULT.dwError = dwApiData

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("dwResult = %d [%#x], dwApiData=%d [%#x], apiType = %s, error = %d\n",
                    dwResult, dwResult,
                    dwApiData, dwApiData,
                    (apiType==ApiType_Handle)?"HANDLE":"BOOL",
                    error));



        if (error == ERROR_IO_PENDING) {
            break;
        }
        pFsm = lpThreadInfo->Fsm;
        if (pFsm == NULL) {
            if (bIsApi
            && ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                ->IsAsyncHandle()) {

                INET_ASSERT((apiType == ApiType_Handle)
                            || (apiType == ApiType_Bool));

                INTERNET_ASYNC_RESULT asyncResult;


		/*
                asyncResult.dwResult = (apiType == ApiType_Handle)
                                     ? dwResult
                                     : (BOOL)(error == ERROR_SUCCESS);
		*/

                asyncResult.dwResult = (error == ERROR_SUCCESS
                                            ?((apiType == ApiType_Handle)
                                                ? dwResult
                                                : TRUE)
                                            :0);

                //
                // InternetQueryDataAvailable uses dwApiData to return the
                // number of bytes available, in addition to returning the
                // the value through the lpdwNumberOfBytesAvailable parameter
                //

                asyncResult.dwError = (error == ERROR_SUCCESS)
                                        ? dwApiData
                                        : error;
                SetLastError(error);

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                InternetIndicateStatus(INTERNET_STATUS_REQUEST_COMPLETE,
                                       (LPVOID)&asyncResult,
                                       sizeof(asyncResult)
                                       );

                //INET_ASSERT(((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)
                //            ->GetObjectType() == TypeHttpRequestHandle);

                DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
            }
            break;
        } else if (bIsApi) {

            //
            // completing an async API that is not the last in the chain.
            // Typically, HttpSendRequest() within InternetOpenUrl()
            //

            DereferenceObject((LPVOID)lpThreadInfo->hObjectMapped);
        }
    }

    lpThreadInfo->IsAsyncWorkerThread = FALSE;

    PERF_LEAVE(Worker);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm::Run(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    OUT DWORD  *lpdwApiResult OPTIONAL,
    OUT DWORD  *lpdwApiData OPTIONAL
    )

/*++

Routine Description:

    Runs the state handler for this FSM

Arguments:

    lpThreadInfo    - INTERNET_THREAD_INFO for this thread

    lpdwApiResult   - where optional API result is written

    lpdwApiData     - where optional API data iswritten

Return Value:

    DWORD   - return code from state handler

--*/

{

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "CFsm::Run",
                 "%#x, %#x [%#x], %#x [%#x]",
                 lpThreadInfo,
                 lpdwApiResult,
                 (lpdwApiResult?*lpdwApiResult:NULL),
                 lpdwApiData,
                 (lpdwApiData?*lpdwApiData:NULL)
                 ));

    CHECK_FSM();
    CHECK_OWNED();
    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->Fsm != NULL);

    DWORD error = ERROR_SUCCESS;

    lpThreadInfo->Context = m_dwContext;
    _InternetSetObjectHandle(lpThreadInfo, m_hObject, m_hObjectMapped);

    m_lpThreadInfo = lpThreadInfo;

    while (TRUE) {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("%s Fsm %#x state %s (%d) function-state %s (%d) error %s (%d)\n",
                    MapType(),
                    this,
                    MapState(),
                    GetState(),
                    MapFunctionState(),
                    GetFunctionState(),
                    InternetMapError(GetError()),
                    GetError()
                    ));

        error = (*m_lpfnHandler)(this);

        if (error == ERROR_IO_PENDING) {
            break;
        }
        SetError(error);
        SetMappedError(lpThreadInfo->dwMappedErrorCode);
        if (IsDone()) {

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("%s Fsm %#x done, next is %s %#x\n",
                        MapType(),
                        this,
                        m_Link ? m_Link->MapType() : "",
                        m_Link
                        ));

            if (lpdwApiResult != NULL) {
                *lpdwApiResult = GetApiResult();
            }
            if (lpdwApiData != NULL) {
                *lpdwApiData = GetApiData();
            }


            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("Fsm %#x finished with lpdwApiResult = %#x[%#x], lpdwApiData = %#x[%#x]\n",
                        this,
                		lpdwApiResult,
                		(lpdwApiResult == NULL)?NULL:*lpdwApiResult,
                		lpdwApiData,
                		(lpdwApiData == NULL)?NULL:*lpdwApiData
                		));
            delete this;
            break;
        }
        SetState(GetNextState());
    }

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

#if !defined(CASE_OF)
#define CASE_OF(x) case x: return #x
#endif

DEBUG_FUNCTION
LPSTR
CFsm::MapType(
    VOID
    ) {
    switch (m_Type) {
    case FSM_TYPE_NONE:                     return "NONE";
    case FSM_TYPE_WAIT_FOR_COMPLETION:      return "WAIT_FOR_COMPLETION";
    case FSM_TYPE_RESOLVE_HOST:             return "RESOLVE_HOST";
    case FSM_TYPE_SOCKET_CONNECT:           return "SOCKET_CONNECT";
    case FSM_TYPE_SOCKET_SEND:              return "SOCKET_SEND";
    case FSM_TYPE_SOCKET_RECEIVE:           return "SOCKET_RECEIVE";
    case FSM_TYPE_SOCKET_QUERY_AVAILABLE:   return "SOCKET_QUERY_AVAILABLE";
    case FSM_TYPE_SECURE_CONNECT:           return "SECURE_CONNECT";
    case FSM_TYPE_SECURE_HANDSHAKE:         return "SECURE_HANDSHAKE";
    case FSM_TYPE_SECURE_NEGOTIATE:         return "SECURE_NEGOTIATE";
    case FSM_TYPE_NEGOTIATE_LOOP:           return "NEGOTIATE_LOOP";
    case FSM_TYPE_SECURE_SEND:              return "SECURE_SEND";
    case FSM_TYPE_SECURE_RECEIVE:           return "SECURE_RECEIVE";
    case FSM_TYPE_GET_CONNECTION:           return "GET_CONNECTION";
    case FSM_TYPE_HTTP_SEND_REQUEST:        return "HTTP_SEND_REQUEST";
    case FSM_TYPE_MAKE_CONNECTION:          return "MAKE_CONNECTION";
    case FSM_TYPE_OPEN_CONNECTION:          return "OPEN_CONNECTION";
    case FSM_TYPE_OPEN_PROXY_TUNNEL:        return "OPEN_PROXY_TUNNEL";
    case FSM_TYPE_SEND_REQUEST:             return "SEND_REQUEST";
    case FSM_TYPE_RECEIVE_RESPONSE:         return "RECEIVE_RESPONSE";
    case FSM_TYPE_HTTP_READ:                return "HTTP_READ";
    case FSM_TYPE_HTTP_WRITE:               return "HTTP_WRITE";
    case FSM_TYPE_READ_DATA:                return "READ_DATA";
    case FSM_TYPE_HTTP_QUERY_AVAILABLE:     return "HTTP_QUERY_AVAILABLE";
    case FSM_TYPE_DRAIN_RESPONSE:           return "DRAIN_RESPONSE";
    case FSM_TYPE_REDIRECT:                 return "REDIRECT";
    case FSM_TYPE_READ_LOOP:                return "READ_LOOP";
    case FSM_TYPE_PARSE_HTTP_URL:           return "PARSE_HTTP_URL";
    case FSM_TYPE_PARSE_URL_FOR_HTTP:       return "PARSE_URL_FOR_HTTP";
    case FSM_TYPE_READ_FILE:                return "READ_FILE";
    case FSM_TYPE_READ_FILE_EX:             return "READ_FILE_EX";
    case FSM_TYPE_WRITE_FILE:               return "WRITE_FILE";
    case FSM_TYPE_QUERY_DATA_AVAILABLE:     return "QUERY_DATA_AVAILABLE";
    case FSM_TYPE_FTP_CONNECT:              return "FTP_CONNECT";
    case FSM_TYPE_FTP_FIND_FIRST_FILE:      return "FTP_FIND_FIRST_FILE";
    case FSM_TYPE_FTP_GET_FILE:             return "FTP_GET_FILE";
    case FSM_TYPE_FTP_PUT_FILE:             return "FTP_PUT_FILE";
    case FSM_TYPE_FTP_DELETE_FILE:          return "FTP_DELETE_FILE";
    case FSM_TYPE_FTP_RENAME_FILE:          return "FTP_RENAME_FILE";
    case FSM_TYPE_FTP_OPEN_FILE:            return "FTP_OPEN_FILE";
    case FSM_TYPE_FTP_CREATE_DIRECTORY:     return "FTP_CREATE_DIRECTORY";
    case FSM_TYPE_FTP_REMOVE_DIRECTORY:     return "FTP_REMOVE_DIRECTORY";
    case FSM_TYPE_FTP_SET_CURRENT_DIRECTORY:    return "FTP_SET_CURRENT_DIRECTORY";
    case FSM_TYPE_FTP_GET_CURRENT_DIRECTORY:    return "FTP_GET_CURRENT_DIRECTORY";
    case FSM_TYPE_GOPHER_FIND_FIRST_FILE:   return "GOPHER_FIND_FIRST_FILE";
    case FSM_TYPE_GOPHER_OPEN_FILE:         return "GOPHER_OPEN_FILE";
    case FSM_TYPE_GOPHER_GET_ATTRIBUTE:     return "GOPHER_GET_ATTRIBUTE";
    case FSM_TYPE_INTERNET_PARSE_URL:       return "INTERNET_PARSE_URL";
    case FSM_TYPE_INTERNET_FIND_NEXT_FILE:  return "INTERNET_FIND_NEXT_FILE";
    case FSM_TYPE_INTERNET_QUERY_DATA_AVAILABLE:    return "INTERNET_QUERY_DATA_AVAILABLE";
    case FSM_TYPE_INTERNET_WRITE_FILE:      return "INTERNET_WRITE_FILE";
    case FSM_TYPE_INTERNET_READ_FILE:       return "INTERNET_READ_FILE";
    }
    return "?";
}

DEBUG_FUNCTION
LPSTR
CFsm::StateName(
    IN DWORD State
    ) {
    switch (State) {
    CASE_OF(FSM_STATE_BAD);
    CASE_OF(FSM_STATE_INIT);
    CASE_OF(FSM_STATE_WAIT);
    CASE_OF(FSM_STATE_DONE);
    CASE_OF(FSM_STATE_ERROR);
    CASE_OF(FSM_STATE_CONTINUE);
    CASE_OF(FSM_STATE_FINISH);
    CASE_OF(FSM_STATE_1);
    CASE_OF(FSM_STATE_2);
    CASE_OF(FSM_STATE_3);
    CASE_OF(FSM_STATE_4);
    CASE_OF(FSM_STATE_5);
    CASE_OF(FSM_STATE_6);
    CASE_OF(FSM_STATE_7);
    CASE_OF(FSM_STATE_8);
    CASE_OF(FSM_STATE_9);
    CASE_OF(FSM_STATE_10);
    }
    return "?";
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\ckcnv\ckcnv.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  ckcnv.cxx

Abstract:
  Upgrades cookies to present urlcache format by enumerating cookie files in the
  cache cookies directory and creates cookie cache index entries in the format of 
  the current wininet.dll. 
    
Author:
    Adriaan Canter (adriaanc) 09-Jan-1997
        Created

    Adriaan Canter (adriaanc) 01-Feb-1997    
        Modified for per-user caches. The class CCookieLoader definition 
        can now be pasted into the urlcache build without re-definition
        and work correctly, as long as the HKLM and HKCU cache keys are
        not modified. BUGBUG - do this.

-----------------------------------------------------------------------------*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wininet.h>
#include "cachedef.h"

#define INET_ASSERT(condition) Assert(condition)

/*-----------------------------------------------------------------------------
    GetHKLMHistoryDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKLMHistoryDirectory(CHAR *szHistoryDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    // Skip the level of indirection for url history.
    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Url History",
        NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szHistoryDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;


exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKCUHistoryDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKCUHistoryDirectory(CHAR *szHistoryDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szHistoryDirRegKey[MAX_PATH];
    strcpy(szHistoryDirRegKey, OLD_CACHE_KEY);
    strcat(szHistoryDirRegKey, "\\");
    strcat(szHistoryDirRegKey, HISTORY_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER, 
        szHistoryDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_PATH_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szHistoryDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}


/*-----------------------------------------------------------------------------
    GetHKLMCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, OLD_CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, CACHE_SPECIAL_PATHS_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKCUCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKCUCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, OLD_CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER, 
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_PATH_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKLMContentDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKLMContentDirectory(CHAR *szContentDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szContentDirRegKey[MAX_PATH];
    strcpy(szContentDirRegKey, CACHE_PATHS_FULL_KEY);

    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        szContentDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szContentDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    GetHKCUContentDirectory
  ----------------------------------------------------------------------------*/
DWORD GetHKCUContentDirectory(CHAR *szContentDirectory)
{
    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szContentDirRegKey[MAX_PATH];
    strcpy(szContentDirRegKey, OLD_CACHE_KEY);
    strcat(szContentDirRegKey, "\\");
    strcat(szContentDirRegKey, CONTENT_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER, 
        szContentDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_PATH_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szContentDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}



/*-----------------------------------------------------------------------------
    class CCookieLoader

    Class used to perform cookie conversion
  ----------------------------------------------------------------------------*/
class CCookieLoader
{
public:
    CHAR* ParseNextCookie(CHAR*, CHAR**, FILETIME*, FILETIME*);    
    DWORD LoadCookies(BOOL);
};


// Debug assert code.
#if DBG
#define Assert(Predicate) \
    { \
        if (!(Predicate)) \
            AssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
AssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else
#define Assert(_x_)
#endif // DBG


/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0 
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;
   
    __try
    {
        // Get the first token (cookie name).
        pszName           = strtok(ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = strtok(NULL, "\n");      // Cookie value.
        *ppszHash         = strtok(NULL, "\n");      // Combo of domain and path.
        pszFlags          = strtok(NULL, "\n");      // Cookie flags.
        pszExpireTimeLow  = strtok(NULL, "\n");      // Expire time.
        pszExpireTimeHigh = strtok(NULL, "\n");             
        pszLastTimeLow    = strtok(NULL, "\n");      // Last Modified time.
        pszLastTimeHigh   = strtok(NULL, "\n");
        pszDelimiter      = strtok(NULL, "\n");      // Delimiter should be "*"

    
        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            INET_ASSERT(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);        

        pszNextCookie = pszDelimiter+2;
    }
    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        pszNextCookie = 0;
        goto exit;
    }

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(BOOL fConvertToPerUser)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szHKCUCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],    
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];
                    
    CHAR               *pszHash, *ptr, *pszCookiesPath,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE bCacheEntryInfoBuffer[2 * PAGE_SIZE];
    INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer;

    // Strictly enforced syntax: requires this to be initialized
    // before the try block is entered.
    szBuffer = 0;

    __try
    {   

        // Check to see if we are upgrading cookies
        // from local machine to per user.
        if (fConvertToPerUser)
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.            
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            if (dwError = GetHKLMCookiesDirectory(szHKLMCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);

            // Get the cookies directory as specified by HKCU.
            if (dwError = GetHKCUCookiesDirectory(szHKCUCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            strcat(szCookieFileNamePattern, "\\");
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");
        
            // Enumerate the users cache files        
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind == INVALID_HANDLE_VALUE)
            {
                // OK, No cookie files to upgrade.
                dwError = ERROR_SUCCESS;
                goto exit;
            }    
        
            // One or more cookie files exist.
            do
            {
                // Construct absolute path from HKLM to cookies file.
                strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                strcat(szHKLMCookieFileName, "\\");
                strcat(szHKLMCookieFileName, FindData.cFileName);
                
                // Construct absolute path from HKCU to cookies file.
                strcpy(szHKCUCookieFileName, szHKCUCookiesPath);
                strcat(szHKCUCookieFileName, "\\");
                strcat(szHKCUCookieFileName, FindData.cFileName);
            
                // Copy the file to the per-user directory.
                CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);

            } while (FindNextFile(hFind, &FindData)); 
        
            // Close the Find handle.
            if (hFind != INVALID_HANDLE_VALUE)
            {
                FindClose(hFind);        
                hFind = INVALID_HANDLE_VALUE;
            }

        } // Per-user upgrade.
        else
        {
            // No per-user upgrade. szCookieFileNamePattern will look like
            // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, "\\*@*.txt");
        }

        // We now have the appropriate cookie filename pattern, also need a copy
        // of the cookies directory associated with the current user.
        pszCookiesPath = (fConvertToPerUser ? szHKCUCookiesPath : szHKLMCookiesPath);
        
        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }    

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            strcpy(szCookieFileName, pszCookiesPath);
            strcat(szCookieFileName, "\\");
            strcat(szCookieFileName, FindData.cFileName);
            
            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );                   

            // File handle must be valid.
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? -> 
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                INET_ASSERT(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie, 
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"            
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);
                        ptr = strstr(szCookieName, "@");
                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (INTERNET_CACHE_ENTRY_INFO*) bCacheEntryInfoBuffer;
                        cbCacheEntryInfoBuffer = sizeof(bCacheEntryInfoBuffer);

                        dwError = GetUrlCacheEntryInfo(szCookieName, pCacheEntryInfo, 
                            &cbCacheEntryInfoBuffer);

                        if (dwError == ERROR_SUCCESS 
                            && CompareFileTime(&pCacheEntryInfo->LastModifiedTime, &ftLast) > 0)
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or 
                            // it was found and the last modified time on it is 
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.
                            BOOL bCommit;
                            bCommit = CommitUrlCacheEntry(
                                szCookieName,           // cookie:user@foobar.com.
                                szCookieFileName,       // c:\winnt\cookies\user@foobar.txt.
                                ftExpire,               // Expire time.
                                ftLast,                 // Last modified time.
                                0,                      // CacheEntryType.
                                0,                      // HeaderInfo.
                                0,                      // HeaderSize.
                                0,                      // FileExtension.
                                0);                     // Reserved.

                            INET_ASSERT(bCommit);
                        } 

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.
                    
        } while (FindNextFile(hFind, &FindData)); 

        
        // No more cookie files or an error occured.        
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);

        return dwError;

    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
                
        INET_ASSERT(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
        return dwError;
    }

}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    DWORD dwError;
    CHAR szFilename[MAX_PATH];
    CHAR szHistoryIndexFile[MAX_PATH];
    CHAR szCookiesIndexFile[MAX_PATH];
    CHAR szContentIndexFile[MAX_PATH];
    CCookieLoader cc;

    __try
    {
    
        // Convert cookies. Note, for ckcnv, we never
        // upgrade to per-user.
        dwError = cc.LoadCookies(FALSE);

        // Nuke all index.dat files so that re-installations will init properly.
        // Take care of HKLM entries only.

        // Content
        if (GetHKLMContentDirectory(szContentIndexFile) == ERROR_SUCCESS)
        {
            strcat(szContentIndexFile, "\\");
            strcat(szContentIndexFile, MEMMAP_FILE_NAME);
            DeleteFile(szContentIndexFile);
        }

        // Cookies
        if (GetHKLMCookiesDirectory(szCookiesIndexFile) == ERROR_SUCCESS)
        {
            strcat(szCookiesIndexFile, "\\");
            strcat(szCookiesIndexFile, MEMMAP_FILE_NAME);
            DeleteFile(szCookiesIndexFile);
        }

        // History
        if (GetHKLMHistoryDirectory(szHistoryIndexFile) == ERROR_SUCCESS)
        {
            strcat(szHistoryIndexFile, "\\");
            strcat(szHistoryIndexFile, MEMMAP_FILE_NAME);
            DeleteFile(szHistoryIndexFile);
        }

        // See if we're supposed to delete this
        // executable after the user reboots.
        if (!_strnicmp(lpCmdLine, "/D", sizeof("/D")))
        {

            // Got this filename?
            if (GetModuleFileName(NULL, szFilename, MAX_PATH))
            {
                OSVERSIONINFO osVersionInfo;
                osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
                if (GetVersionEx(&osVersionInfo))
                {
                    // Two different methods of deleting this file
                    // depending on the platform ID.
                    if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
                    {
                        // Platform is Windows NT.
                        MoveFileEx(szFilename, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                    }
                    else
                    {
                        // Platform is Windows 95.
                        CHAR szString[MAX_PATH];
                        strcpy(szString, "NUL=");
                        strcat(szString, szFilename);
                        WritePrivateProfileSection("Rename", szString, "wininit.ini");

                    }
                }
            }
        }
    }
    

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_EXTENDED_ERROR;
    }

    return (dwError == ERROR_SUCCESS ? 0 : 1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\caddrlst.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    caddrlst.cxx

Abstract:

    Contains CAddressList class definition

    Contents:
        CAddressList::FreeList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::SetList
        CAddressList::GetNextAddress
        CAddressList::InvalidateAddress
        CAddressList::ResolveHost
        CFsm_ResolveHost::RunSM
        (CAddressList::IPAddressToAddressList)
        (CAddressList::HostentToAddressList)
        (CAddressList::AddrInfoToAddressList)

Author:

    Richard L Firth (rfirth) 19-Apr-1997

Environment:

    Win32 user-mode DLL

Revision History:

    19-Apr-1997 rfirth
        Created

    28-Jan-1998 rfirth
        No longer randomly index address list. NT5 and Win98 are modified to
        return the address list in decreasing order of desirability by RTT/
        route

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include <autodial.h>

//#define TEST_CODE

//
// methods
//

VOID
CAddressList::FreeList(
    VOID
    )

/*++

Routine Description:

    Free address list

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (m_Addresses != NULL) {
        m_Addresses = (LPRESOLVED_ADDRESS)FREE_MEMORY((HLOCAL)m_Addresses);

        INET_ASSERT(m_Addresses == NULL);

        m_AddressCount = 0;
        m_BadAddressCount = 0;
        m_CurrentAddress = 0;
    }
}


DWORD
CAddressList::SetList(
    IN DWORD dwIpAddress
    )

/*++

Routine Description:

    Sets the list contents from the IP address

Arguments:

    dwIpAddress - IP address from which to create list contents

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    Acquire();
    FreeList();

    DWORD error = IPAddressToAddressList(dwIpAddress);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Sets the list contents from the hostent

Arguments:

    lpHostent   - pointer to hostent containing resolved addresses to add

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    Acquire();
    FreeList();

    DWORD error = HostentToAddressList(lpHostent);

    Release();

    return error;
}


DWORD
CAddressList::SetList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Sets the list contents from the addrinfo.  Basically just a wrapper
    around AddrInfoToAddressList() that also grabs the critical section.

Arguments:

    lpAddrInfo  - Pointer to addrinfo containing resolved addresses to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    Acquire();
    FreeList();

    DWORD error = AddrInfoToAddressList(lpAddrInfo);

    Release();

    return error;
}


BOOL
CAddressList::GetNextAddress(
    OUT LPDWORD lpdwResolutionId,
    IN OUT LPDWORD lpdwIndex,
    IN INTERNET_PORT nPort,
    OUT LPCSADDR_INFO lpAddressInfo
    )

/*++

Routine Description:

    Get next address to use when connecting. If we already have a preferred
    address, use that. We make a copy of the address to use in the caller's
    data space

Arguments:

    lpdwResolutionId    - used to determine whether the address list has been
                          resolved between calls

    lpdwIndex           - IN: current index tried; -1 if we want to try default
                          OUT: index of address address returned if successful

    nPort               - which port we want to connect to

    lpAddressInfo       - pointer to returned address if successful

Return Value:

    BOOL
        TRUE    - lpResolvedAddress contains resolved address to use

        FALSE   - need to (re-)resolve name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CAddressList::GetNextAddress",
                 "%#x [%d], %#x [%d], %d, %#x",
                 lpdwResolutionId,
                 *lpdwResolutionId,
                 lpdwIndex,
                 *lpdwIndex,
                 nPort,
                 lpAddressInfo
                 ));

    PERF_ENTER(GetNextAddress);

    BOOL bOk = TRUE;

    //
    // if we tried all the addresses and failed already, re-resolve the name
    //

    Acquire();
    if (m_BadAddressCount < m_AddressCount) {
        if (*lpdwIndex != (DWORD)-1) {

            INET_ASSERT(m_BadAddressCount < m_AddressCount);

            INT i = 0;

            m_CurrentAddress = *lpdwIndex;

            INET_ASSERT((m_CurrentAddress >= 0)
                        && (m_CurrentAddress < m_AddressCount));

            if ((m_CurrentAddress < 0) || (m_CurrentAddress >= m_AddressCount)) {
                m_CurrentAddress = 0;
            }
            do {
                NextAddress();
                if (++i == m_AddressCount) {
                    bOk = FALSE;
                    break;
                }
            } while (!IsCurrentAddressValid());
        }

        //
        // check to make sure this address hasn't expired
        //

        //if (!CheckHostentCacheTtl()) {
        //    bOk = FALSE;
        //}
    } else {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("exhausted %d addresses\n",
                    m_BadAddressCount
                    ));

        bOk = FALSE;
    }
    if (bOk) {

        DWORD dwLocalLength = LocalSockaddrLength();
        LPBYTE lpRemoteAddr = (LPBYTE)(lpAddressInfo + 1) + dwLocalLength;

        memcpy(lpAddressInfo + 1, LocalSockaddr(), dwLocalLength);
        memcpy(lpRemoteAddr, RemoteSockaddr(), RemoteSockaddrLength());
        lpAddressInfo->LocalAddr.lpSockaddr = (LPSOCKADDR)(lpAddressInfo + 1);
        lpAddressInfo->LocalAddr.iSockaddrLength = dwLocalLength;
        lpAddressInfo->RemoteAddr.lpSockaddr = (LPSOCKADDR)lpRemoteAddr;
        lpAddressInfo->RemoteAddr.iSockaddrLength = RemoteSockaddrLength();
        lpAddressInfo->iSocketType = SocketType();
        lpAddressInfo->iProtocol = Protocol();
        //
        // The port number field is in the same location in both a
        // sockaddr_in and a sockaddr_in6, so it is safe to cast the
        // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
        //
        INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) ==
                    offsetof(SOCKADDR_IN6, sin6_port));
        ((LPSOCKADDR_IN)lpAddressInfo->RemoteAddr.lpSockaddr)->sin_port =
            _I_htons((unsigned short)nPort);
        *lpdwIndex = m_CurrentAddress;

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("current address = %d.%d.%d.%d\n",
                    ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                    ((LPBYTE)RemoteSockaddr())[7] & 0xff
                    ));

//dprintf("returning address %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        m_ResolutionId,
//        m_CurrentAddress
//        );
    }
    *lpdwResolutionId = m_ResolutionId;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("ResolutionId = %d, Index = %d\n",
                m_ResolutionId,
                m_CurrentAddress
                ));

    Release();

    PERF_LEAVE(GetNextAddress);

    DEBUG_LEAVE(bOk);

    return bOk;
}


VOID
CAddressList::InvalidateAddress(
    IN DWORD dwResolutionId,
    IN DWORD dwAddressIndex
    )

/*++

Routine Description:

    We failed to create a connection. Invalidate the address so other requests
    will try another address

Arguments:

    dwResolutionId  - used to ensure coherency of address list

    dwAddressIndex  - which address to invalidate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "CAddressList::InvalidateAddress",
                 "%d, %d",
                 dwResolutionId,
                 dwAddressIndex
                 ));
//dprintf("invalidating %d.%d.%d.%d, index %d:%d\n",
//        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
//        ((LPBYTE)RemoteSockaddr())[7] & 0xff,
//        dwResolutionId,
//        dwAddressIndex
//        );
    Acquire();

    //
    // only do this if the list is the same age as when the caller last tried
    // an address
    //

    if (dwResolutionId == m_ResolutionId) {

        INET_ASSERT(((INT)dwAddressIndex >= 0)
                    && ((INT)dwAddressIndex < m_AddressCount));

        if (dwAddressIndex < (DWORD)m_AddressCount) {
            m_Addresses[dwAddressIndex].IsValid = FALSE;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("invalidated address %d.%d.%d.%d\n",
                        ((LPBYTE)RemoteSockaddr())[4] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[5] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[6] & 0xff,
                        ((LPBYTE)RemoteSockaddr())[7] & 0xff
                        ));

            INET_ASSERT(m_BadAddressCount <= m_AddressCount);

            if (m_BadAddressCount < m_AddressCount) {
                ++m_BadAddressCount;
                if (m_BadAddressCount < m_AddressCount) {
                    for (int i = 0;
                         !IsCurrentAddressValid() && (i < m_AddressCount);
                         ++i) {
                        NextAddress();
                    }
                }
            }
        }
    }
    Release();

    DEBUG_LEAVE(0);
}


DWORD
CAddressList::ResolveHost(
    IN LPSTR lpszHostName,
    IN OUT LPDWORD lpdwResolutionId,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resolves host name (or (IP-)address)

    BUGBUG: Ideally, we don't want to keep hold of worker threads if we are in
            the blocking gethostbyname() call. But correctly handling this is
            difficult, so we always block the thread while we are resolving.
            For this reason, an async request being run on an app thread should
            have switched to a worker thread before calling this function.

Arguments:

    lpszHostName        - host name (or IP-address) to resolve

    lpdwResolutionId    - used to determine whether entry changed

    dwFlags             - controlling request:

                            SF_INDICATE - if set, make indications via callback

                            SF_FORCE    - if set, force (re-)resolve

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Name successfully resolved

        Failure - ERROR_INTERNET_NAME_NOT_RESOLVED
                    Couldn't resolve the name

                  ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate memory for the FSM
--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost",
                 "%q, %d, %#x",
                 lpszHostName,
                 *lpdwResolutionId,
                 dwFlags
                 ));

    DWORD error;

    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    error = DoFsm(new CFsm_ResolveHost(lpszHostName,
                                       lpdwResolutionId,
                                       dwFlags,
                                       this
                                       ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ResolveHost::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_ResolveHost::RunSM",
                 "%#x",
                 Fsm
                 ));

    CAddressList * pAddressList = (CAddressList *)Fsm->GetContext();
    CFsm_ResolveHost * stateMachine = (CFsm_ResolveHost *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pAddressList->ResolveHost_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        Fsm->SetDone();
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CAddressList::ResolveHost_Fsm(
    IN CFsm_ResolveHost * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CAddressList::ResolveHost_Fsm",
                 "%#x(%q, %#x [%d], %#x)",
                 Fsm,
                 Fsm->m_lpszHostName,
                 Fsm->m_lpdwResolutionId,
                 *Fsm->m_lpdwResolutionId,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(ResolveHost);

    //
    // restore variables from FSM object
    //

    CFsm_ResolveHost & fsm = *Fsm;
    LPSTR lpszHostName = fsm.m_lpszHostName;
    LPDWORD lpdwResolutionId = fsm.m_lpdwResolutionId;
    DWORD dwFlags = fsm.m_dwFlags;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    INTERNET_HANDLE_OBJECT * pHandle = fsm.GetMappedHandleObject();
    DWORD error = ERROR_SUCCESS;

    //
    // BUGBUG - RLF 04/23/97
    //
    // This is sub-optimal. We want to block worker FSMs and free up the worker
    // thread. Sync client threads can wait. However, since a clash is not very
    // likely, we'll block all threads for now and come up with a better
    // solution later (XTLock).
    //
    // Don't have time to implement the proper solution now
    //

    Acquire();

    //
    // if the resolution id is different then the name has already been resolved
    //

    if (*lpdwResolutionId != m_ResolutionId) {
        goto done;
    }

    //
    // if we're an app thread making an async request then go async now rather
    // than risk blocking the app thread. This will be the typical scenario for
    // IE, and we care about little else
    //
    // BUGBUG - RLF 05/20/97
    //
    // We should really lock & test the cache first, but let's do that after
    // Beta2 (its perf work)
    //

    if (!lpThreadInfo->IsAsyncWorkerThread
        && pHandle->IsAsyncHandle()
        && (fsm.GetAppContext() != INTERNET_NO_CALLBACK)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("async request on app thread - jumping to hyper-drive\n"
                    ));

        error = Fsm->QueueWorkItem();
        goto done;
    }

    //
    // throw out current list (if any)
    //

    FreeList();

    //
    // let the app know we are resolving the name
    //

    if (dwFlags & SF_INDICATE) {
        InternetIndicateStatusString(INTERNET_STATUS_RESOLVING_NAME,
                                     lpszHostName
                                     );
    }

//dprintf("resolving %q\n", lpszHostName);

    //
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo with the AI_NUMERICHOST flag succeeds then we were
    // given a string representation of an IPv6 or IPv4 address.  Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }

        //
        // An IP address (either v4 or v6) was passed in.
        // Simply convert to address list representation and quit.
        //
        // NOTE: Previous versions of this code had a function here to
        // make sure the string didn't contain additional info that would
        // invalidate the string.  For example, "111.111.111.111 .msn.com"
        // would allow the navigation to succeed, but the cookies for
        // .msn.com would be retrievable, violating cross-domain security.
        // We no longer need this check because getaddrinfo is far pickier
        // than inetaddr was - getaddrinfo with the AI_NUMERICHOST flag set
        // will only accept a string that parses *exactly* as an IP address
        // literal.  No extra data is allowed.
        //

        error = SetList(lpAddrInfo);
        _I_freeaddrinfo(lpAddrInfo);
        goto quit;
    }

    //
    // 255.255.255.255 (or 65535.65535 or 16777215.255) would never work anyway
    //

    INET_ASSERT(lstrcmp(lpszHostName, "255.255.255.255"));

    //
    // now try to find the name or address in the cache. If it's not in the
    // cache then resolve it
    //

    DWORD ttl;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    if (!(dwFlags & SF_FORCE)
    && (lpResolverCacheEntry=QueryResolverCache(lpszHostName, NULL, &lpAddrInfo, &ttl))) {
        error = SetList(lpAddrInfo);
        ReleaseResolverCacheEntry(lpResolverCacheEntry);
        ++m_ResolutionId;
    } else
        {
        if (dwFlags & SF_FORCE) {
            //ThrowOutResolverCacheEntry(lpszHostName);
        }

        //
        // If we call winsock getaddrinfo() then we don't get to find out the
        // time-to-live as returned by DNS, so we have to use the default value
        // (LIVE_DEFAULT)
        //

        Hints.ai_flags = AI_CANONNAME;

        LPSTR lpszUTF8HostName = NULL;
        LPSTR lpszTempHostName;
        if (GlobalUseUTF8ServerForNameRes)
        {
            DWORD dwUTF8StrLen;
            if (lpszUTF8HostName = ConvertMBCSToUTF8(lpszHostName, 
                                                    lstrlen(lpszHostName), 
                                                    GetACP(),
                                                    &dwUTF8StrLen,
                                                    FALSE))
            {
                lpszTempHostName = lpszHostName;
                lpszHostName = lpszUTF8HostName;
            }
        }            
                    
        error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    error ? "NOT " : ""
                    ));

        if (lpszUTF8HostName)
        {
            delete [] lpszUTF8HostName;
            lpszHostName = lpszTempHostName;
        }
        
        if (error == 0) {
            error = SetList(lpAddrInfo);
            AddResolverCacheEntry(lpszHostName, lpAddrInfo, LIVE_DEFAULT);
            ++m_ResolutionId;
        } else {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
        }
    }

quit:

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // inform the app that we have resolved the name
        //

        InternetIndicateStatusAddress(INTERNET_STATUS_NAME_RESOLVED,
                                      RemoteSockaddr(),
                                      RemoteSockaddrLength()
                                      );
    }
    *lpdwResolutionId = m_ResolutionId;

done:

    Release();

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        //PERF_LEAVE(ResolveHost);
    }

    PERF_LEAVE(ResolveHost);

    DEBUG_LEAVE(error);

    return error;
}

//
// private methods
//


PRIVATE
DWORD
CAddressList::IPAddressToAddressList(
    IN DWORD ipAddr
    )

/*++

Routine Description:

    Converts an IP-address to a RESOLVED_ADDRESS

Arguments:

    ipAddr  - IP address to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    LPRESOLVED_ADDRESS address = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                        LMEM_FIXED,
                                                        sizeof(RESOLVED_ADDRESS)

                                                        //
                                                        // 1 local and 1 remote
                                                        // socket address
                                                        //

                                                        + 2 * sizeof(SOCKADDR)
                                                        );
    if (address == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    LPBYTE lpVariable;
    LPSOCKADDR_IN lpSin;

    lpVariable = (LPBYTE)address + (sizeof(RESOLVED_ADDRESS));

    //
    // For this IP address, build a CSADDR_INFO structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value and the IP address
    // presented in the arguments
    //

    address->AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
    address->AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
    lpSin = (LPSOCKADDR_IN)lpVariable;
    lpVariable += sizeof(*lpSin);
    lpSin->sin_family = AF_INET;
    lpSin->sin_port = 0;
    *(LPDWORD)&lpSin->sin_addr = ipAddr;
    memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

    address->AddrInfo.iSocketType = SOCK_STREAM;
    address->AddrInfo.iProtocol = IPPROTO_TCP;
    address->IsValid = TRUE;

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = 1;
    m_BadAddressCount = 0;
    m_Addresses = address;
    m_CurrentAddress = 0;   // only one to choose from
    return ERROR_SUCCESS;
}


PRIVATE
DWORD
CAddressList::HostentToAddressList(
    IN LPHOSTENT lpHostent
    )

/*++

Routine Description:

    Converts a HOSTENT structure to an array of RESOLVED_ADDRESSs

Arguments:

    lpHostent   - pointer to HOSTENT to convert

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpHostent != NULL);

    LPBYTE * addressList = (LPBYTE *)lpHostent->h_addr_list;

    INET_ASSERT(addressList[0]);

    //
    // first off, figure out how many addresses there are in the hostent
    //

    int nAddrs;

    if (fDontUseDNSLoadBalancing) {
        nAddrs = 1;
    } else {
        for (nAddrs = 0; addressList[nAddrs] != NULL; ++nAddrs) {
            /* NOTHING */
        }
#ifdef TEST_CODE
        nAddrs = 4;
#endif
    }

    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)ALLOCATE_MEMORY(
                                                LMEM_FIXED,
                                                nAddrs * (sizeof(RESOLVED_ADDRESS)

                                                //
                                                // need 1 local and 1 remote socket
                                                // address for each
                                                //

                                                + 2 * sizeof(SOCKADDR))
                                                );
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // for each IP address in the hostent, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family (AF_INET),
    // everything else is zeroed; create a remote SOCKADDR containing the
    // address family (AF_INET), zero port value, and the IP address from
    // the hostent presented in the arguments
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));
    LPSOCKADDR_IN lpSin;

    for (int i = 0; i < nAddrs; ++i) {

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
        *(LPDWORD)&lpSin->sin_addr = INADDR_ANY;
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));
        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR);
        lpSin = (LPSOCKADDR_IN)lpVariable;
        lpVariable += sizeof(*lpSin);
        lpSin->sin_family = AF_INET;
        lpSin->sin_port = 0;
#ifdef TEST_CODE
        //if (i) {
            *(LPDWORD)&lpSin->sin_addr = 0x04030201;
            //*(LPDWORD)&lpSin->sin_addr = 0x1cfe379d;
        //}
#else
        *(LPDWORD)&lpSin->sin_addr = *(LPDWORD)addressList[i];
#endif
        memset(lpSin->sin_zero, 0, sizeof(lpSin->sin_zero));

        addresses[i].AddrInfo.iSocketType = SOCK_STREAM;
        addresses[i].AddrInfo.iProtocol = IPPROTO_TCP;
        addresses[i].IsValid = TRUE;
    }
#ifdef TEST_CODE
    *((LPDWORD)&((LPSOCKADDR_IN)addresses[3].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = *(LPDWORD)addressList[0];
    //((LPSOCKADDR_IN)addresses[7].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr = ((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr;
    //*((LPDWORD)&((LPSOCKADDR_IN)addresses[0].AddrInfo.RemoteAddr.lpSockaddr)->sin_addr) = 0x04030201;
#endif

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}



PRIVATE
DWORD
CAddressList::AddrInfoToAddressList(
    IN struct addrinfo FAR *lpAddrInfo
    )

/*++

Routine Description:

    Converts an addrinfo structure(s) to an array of RESOLVED_ADDRESSes.

Arguments:

    lpAddrInfo  - pointer to AddrInfo chain to convert.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    INET_ASSERT(lpAddrInfo != NULL);

    struct addrinfo *lpCurrentInfo = lpAddrInfo;

    //
    // First off, figure out how many addrinfo structs are on the chain.
    // And how much memory we'll need to hold them as RESOLVED_ADDRESSes.
    // Note we also need space to hold the actual local and remote sockaddrs,
    // the RESOLVED_ADDRESS struct only contains the pointers to them.
    //

    int SpaceNeeded = 0;
    int nAddrs = 0;

    for (; lpCurrentInfo != NULL; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        SpaceNeeded += sizeof(RESOLVED_ADDRESS) + 
            2 * lpCurrentInfo->ai_addrlen;

        nAddrs++;

        if (fDontUseDNSLoadBalancing)
            break;  // Leave after one.
    }

    //
    // Allocate enough memory to hold these as RESOLVED_ADDRESSes.
    //
    LPRESOLVED_ADDRESS addresses = (LPRESOLVED_ADDRESS)
        ALLOCATE_MEMORY(LMEM_FIXED, SpaceNeeded);
    if (addresses == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // For each IP address in the chain, build a RESOLVED_ADDRESS structure:
    // create a local SOCKADDR containing only the address family,
    // everything else is zeroed; create a remote SOCKADDR containing all
    // the values from the addrinfo structure.
    //

    LPBYTE lpVariable = (LPBYTE)addresses + (nAddrs * sizeof(RESOLVED_ADDRESS));

    lpCurrentInfo = lpAddrInfo;
    for (int i = 0; i < nAddrs; lpCurrentInfo = lpCurrentInfo->ai_next) {

        if ((lpCurrentInfo->ai_family != PF_INET) &&
            (lpCurrentInfo->ai_family != PF_INET6)) {

            //
            // Ignore any non-internet addrsses.
            // We won't get any with the current getaddrinfo,
            // but maybe someday.
            //
            continue;
        }

        addresses[i].AddrInfo.LocalAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.LocalAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memset(lpVariable, 0, lpCurrentInfo->ai_addrlen);
        addresses[i].AddrInfo.LocalAddr.lpSockaddr->sa_family = 
            (unsigned short)lpCurrentInfo->ai_family;

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.RemoteAddr.lpSockaddr = (LPSOCKADDR)lpVariable;
        addresses[i].AddrInfo.RemoteAddr.iSockaddrLength =
            lpCurrentInfo->ai_addrlen;
        memcpy(lpVariable, lpCurrentInfo->ai_addr, lpCurrentInfo->ai_addrlen);

        lpVariable += lpCurrentInfo->ai_addrlen;

        addresses[i].AddrInfo.iSocketType = lpCurrentInfo->ai_socktype;
        addresses[i].AddrInfo.iProtocol = lpCurrentInfo->ai_protocol;
        addresses[i].IsValid = TRUE;

        i++;
    }

    //
    // update the object
    //

    INET_ASSERT(m_AddressCount == 0);
    INET_ASSERT(m_Addresses == NULL);

    m_AddressCount = nAddrs;
    m_BadAddressCount = 0;
    m_Addresses = addresses;
    m_CurrentAddress = 0;
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\icstring.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    icstring.cxx

Abstract:

    Contains ICSTRING class methods. Split from ICSTRING.HXX (inline methods)

    Contents:
        ICSTRING::ICSTRING(ICSTRING&)
        ICSTRING::~ICSTRING()
        ICSTRING::operator=(LPSTR)
        ICSTRING::operator=(ICSTRING&)
        ICSTRING::operator+=(LPSTR)
        ICSTRING::operator+=(char)
        ICSTRING::strncat(LPVOID, DWORD)
        ICSTRING::CreateStringBuffer(LPVOID, DWORD, DWORD)
        ICSTRING::CreateOffsetString(DWORD, DWORD)
        ICSTRING::CopyTo(LPSTR)
        ICSTRING::CopyTo(LPSTR, LPSTR)
        ICSTRING::CopyTo(LPSTR, DWORD)
        ICSTRING::CopyTo(LPSTR, LPDWORD)

Author:

    Richard L Firth (rfirth) 18-Dec-1995

Revision History:

    18-Dec-1995 rfirth
        Created

--*/

#include <wininetp.h>

//
// methods
//

//
//ICSTRING::ICSTRING(
//    IN ICSTRING& String
//    )
//
///*++
//
//Routine Description:
//
//    copy constructor. We now create an entirely new string (used to be just a
//    reference of the rvalue)
//
//Arguments:
//
//    String  - to copy
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    //
//    // can't already have string in lvalue, & rvalue mustn't be an offset string
//    //
//
//    INET_ASSERT(!HaveString());
//    INET_ASSERT(!String.IsOffset());
//    INET_ASSERT(!String.IsError());
//
//    *this = String.StringAddress();
//}


ICSTRING::~ICSTRING(
    VOID
    )

/*++

Routine Description:

    destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // can only free the string if it is not a reference. Offset type
    // implies reference
    //

    if (!IsReference() && (_String != NULL)) {

        INET_ASSERT(!IsOffset());

        (VOID)ResizeBuffer((HLOCAL)_String, 0, FALSE);
        _String = NULL;
    }
}


ICSTRING&
ICSTRING::operator=(
    IN LPSTR String
    )

/*++

Routine Description:

    Copy/assigment. Copies a string to this object. If NULL, frees up the
    current buffer

Arguments:

    String  - to be assigned

Return Value:

    ICSTRING&

--*/

{
    //
    // if this is an offset string then there's not much to do
    //

    if (IsOffset()) {
        Initialize();
        return *this;
    }

    //
    // string MUST NOT be a copy (we'll free the real string pointer, owned
    // by another object) and SHOULD NOT be copied itself (the objects with
    // copies of the string will potentially have a bad pointer)
    //

    INET_ASSERT((String == NULL) ? TRUE : !IsReference());
    INET_ASSERT(!IsReferenced());

    //
    // if the pointer is NULL or the string is empty then we are freeing the
    // string pointer
    //

    DWORD len;

    if (String == NULL) {
        len = 0;
    } else {
        len = ::strlen(String);
        if (len != 0) {
            INET_ASSERT(len < 0xffffffff);
            ++len;
        }
    }

    //
    // free or grow the buffer, depending on requirements
    //

    if ((len > _BufferLength) || ((len == 0) && (_String != NULL))) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, len, FALSE);
        _BufferLength = (_String != NULL) ? len : 0;
    }
    if (_String != NULL) {

        INET_ASSERT(len != 0);

        memcpy((LPVOID)_String, (LPVOID)String, len);
        _StringLength = len - 1;
        SetHaveString(TRUE);
        SetError(FALSE);
    } else {
        _StringLength = 0;
        SetHaveString(FALSE);
        SetError(len != 0); // an error might have occurred
    }
    return *this;
}


ICSTRING&
ICSTRING::operator=(
    IN ICSTRING& String
    )

/*++

Routine Description:

    Copy/assignment. Makes new copy of object (used to just make a reference)

Arguments:

    String  - ICSTRING object to be assigned

Return Value:

    ICSTRING&

--*/

{
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!String.IsReferenced());
    INET_ASSERT(!String.IsError());

    //
    // if we're copying an offset, make sure that any string we may already
    // have is freed
    //

    if (String.IsOffset()) {
        if (_String != NULL) {
            ResizeBuffer(_String, 0, FALSE);
        }
        _String = String._String;
        _StringLength = String._StringLength;
        _BufferLength = String._BufferLength;
        _Union.Dword = String._Union.Dword;
    } else {

        INET_ASSERT(!IsOffset() && !String.IsOffset());

        //
        // use string assignment to correctly setup this object
        //

        *this = String.StringAddress();
    }
    return *this;
}


VOID
ICSTRING::operator+=(
    IN LPSTR String
    )

/*++

Routine Description:

    Concatenates a string to the buffer. Reallocates it if necessary. String
    CANNOT be NULL

Arguments:

    String  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());
    INET_ASSERT(String != NULL);

    if (IsError()) {
        return;
    }

    if (*String == '\0') {
        return;
    }

    DWORD len = ::strlen(String);
    DWORD newlen = _StringLength + len + 1;

    INET_ASSERT ((newlen > _StringLength) && (newlen > len));

    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        memcpy((LPVOID)((LPBYTE)_String + _StringLength),
               (LPVOID)String,
               len + 1
               );
        _StringLength += len;
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::operator+=(
    IN char Ch
    )

/*++

Routine Description:

    Concatenates a character to the buffer. Reallocates it if necessary. Ch
    CAN be '\0'

Arguments:

    Ch  - to concatenate

Return Value:

    None.

--*/

{
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());
    INET_ASSERT(!IsOffset());

    if (IsError()) {
        return;
    }

    DWORD newlen = _StringLength + 2;

    INET_ASSERT (newlen > _StringLength);

    if (_BufferLength < newlen) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newlen, FALSE);

        INET_ASSERT((_String == NULL) ? (newlen == 0) : TRUE);

        _BufferLength = newlen;
    }
    if (_String != NULL) {
        _String[_StringLength] = Ch;
        ++_StringLength;
        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::Strncat(
    IN LPVOID Pointer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies Length characters from Pointer to the end of _String

Arguments:

    Pointer - place to copy from

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    if (IsError()) {
        return;
    }

    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(Length != 0);
    INET_ASSERT(_String != NULL);
    INET_ASSERT(!IsReference());
    INET_ASSERT(!IsReferenced());

    DWORD newLength;

    newLength = _StringLength + Length + 1;

    INET_ASSERT ((newLength > _StringLength) && (newLength > Length));

    if (_BufferLength < newLength) {
        _String = (LPSTR)ResizeBuffer((HLOCAL)_String, newLength, FALSE);
        _BufferLength = newLength;
    }
    if (_String != NULL) {
        memcpy((LPVOID)&_String[_StringLength], Pointer, Length);
        _StringLength += Length;

        INET_ASSERT(_StringLength < _BufferLength);

        _String[_StringLength] = '\0';
    } else {
        _StringLength = 0;
        _BufferLength = 0;
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateStringBuffer(
    IN LPVOID Pointer,
    IN DWORD StringLength,
    IN DWORD BufferLength
    )

/*++

Routine Description:

    In order to avoid reallocations, if we know the size of the buffer we
    want for several strcat()'s, e.g., we can allocate it once, copy the
    initial string here, then perform multiple concatenate operations (+=)

Arguments:

    Pointer         - place to start copying from

    StringLength    - length of string

    BufferLength    - length of buffer required

Return Value:

    None.

--*/

{
    INET_ASSERT(Pointer != NULL);
    INET_ASSERT(BufferLength > StringLength);
    INET_ASSERT(BufferLength != 0);

    //
    // if we currently have an offset string then initialize to a non-offset
    //

    if (IsOffset()) {
        Initialize();
    }
    _String = (LPSTR)ResizeBuffer(_String, BufferLength, FALSE);
    if (_String != NULL) {
        _StringLength = StringLength;
        _BufferLength = BufferLength;
        memcpy((LPVOID)_String, Pointer, _StringLength);
        _String[_StringLength] = '\0';
        SetHaveString(TRUE);
        SetReference(FALSE);
        SetReferenced(FALSE);
        SetOffset(FALSE);
        SetError(FALSE);
    } else {
        SetError(TRUE);
    }
}


VOID
ICSTRING::CreateOffsetString(
    IN DWORD Offset,
    IN DWORD Length
    )

/*++

Routine Description:

    Create a reference ICSTRING that is an offset within another buffer

Arguments:

    Offset  - offset into buffer

    Length  - of string

Return Value:

    None.

--*/

{
    _String = (LPSTR)(DWORD_PTR)Offset;
    _StringLength = Length;
    _BufferLength = Length;
    ZapFlags();
    SetHaveString(TRUE);    // ICSTRING initialized with non-NULL
    SetReference(TRUE);     // reference to another string buffer
    SetOffset(TRUE);        // offset from base
    SetError(FALSE);
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies source _String to destination Buffer

Arguments:

    Buffer  - place to copy to

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    memcpy((LPVOID)Buffer, (LPVOID)_String, _StringLength);
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Base,
    IN LPSTR Buffer
    )

/*++

Routine Description:

    Copies a based (offset) string from source Base + _String to destination
    Buffer

Arguments:

    Base    - value for base

    Buffer  - place to write string

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    //INET_ASSERT(IsOffset() ? (Base != NULL) : (Base == NULL));

    memcpy((LPVOID)Buffer,
           IsOffset() ? (Base + (DWORD_PTR)_String) : _String,
           _StringLength
           );
    Buffer[_StringLength] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN DWORD Length
    )

/*++

Routine Description:

    Copies at most Length characters from source _String to destination
    Buffer

Arguments:

    Buffer  - place to write string

    Length  - number of characters to copy

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
}


VOID
ICSTRING::CopyTo(
    IN LPSTR Buffer,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Copies at most *Length characters from source _String to destination
    Buffer. Updates *Length to be number of characters copied, not including
    terminating NUL

Arguments:

    Buffer  - place to write string

    Length  - IN: length of buffer
              OUT: number of characters copied

Return Value:

    None.

--*/

{
    INET_ASSERT(Buffer != NULL);
    INET_ASSERT(!IsOffset());

    DWORD length = min(*Length - 1, _StringLength);

    memcpy((LPVOID)Buffer, (LPVOID)_String, length);
    Buffer[length] = '\0';
    *Length = length;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\icasync.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    icasync.cxx

Abstract:

    Contains async socket (select) thread and support functions. Work items now
    processed by SHLWAPI/KERNEL32 thread pool

    Contents:
        InitializeAsyncSupport
        TerminateAsyncSupport
        QueueSocketWorkItem
        BlockWorkItem
        UnblockWorkItems
        CheckForBlockedWorkItems
        ICAsyncThread::~ICAsyncThread
        ICAsyncThread::QueueSocketWorkItem
        ICAsyncThread::BlockWorkItem
        ICAsyncThread::UnblockWorkItems
        ICAsyncThread::CheckForBlockedWorkItems
        ICAsyncThread::SelectThreadWrapper
        ICAsyncThread::SelectThread
        (ICAsyncThread::CreateSelectSocket)
        (ICAsyncThread::DestroySelectSocket)
        (ICAsyncThread::RecreateSelectSocket)
        (ICAsyncThread::InterruptSelect)
        (ICAsyncThread::DrainSelectSocket)

Author:

    Richard L Firth (rfirth) 04-Mar-1998

Environment:

    Win32 user-mode

Revision History:

    04-Mar-1998 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>


//
// private classes
//

class ICAsyncThread {

#define DEFAULT_ASYNC_THREAD_TIMEOUT    5000

private:

    CPriorityList m_BlockedQueue;
    SOCKET m_SelectSocket;
    LONG m_lSelectInterrupts;
    BOOL m_bTerminating;
    DWORD m_dwError;
    HANDLE m_hThread;

public:

    ICAsyncThread() {

        DEBUG_ENTER((DBG_ASYNC,
                     None,
                     "ICAsyncThread::ICAsyncThread",
                     NULL
                     ));

        m_SelectSocket = INVALID_SOCKET;
        m_lSelectInterrupts = -1;
        m_bTerminating = FALSE;
        m_dwError = ERROR_SUCCESS;

        DWORD dwThreadId;

        m_hThread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE)ICAsyncThread::SelectThreadWrapper,
                    (LPVOID)this,
                    0,
                    &dwThreadId
                    );
        if (m_hThread == NULL) {
            SetError();
        }

        DEBUG_LEAVE(0);
    }

    ~ICAsyncThread();

    DWORD GetError(VOID) const {
        return m_dwError;
    }

    VOID SetError(DWORD dwError = GetLastError()) {
        m_dwError = dwError;
    }

    BOOL IsTerminating(VOID) const {
        return m_bTerminating;
    }

    VOID SetTerminating(VOID) {
        m_bTerminating = TRUE;
    }

    DWORD
    QueueSocketWorkItem(
        IN CFsm * pFsm
        );

    DWORD
    BlockWorkItem(
        IN CFsm * WorkItem,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwTimeout = TP_NO_TIMEOUT
        );

    DWORD
    UnblockWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId,
        IN DWORD dwError,
        IN LONG lPriority = TP_NO_PRIORITY_CHANGE
        );

    DWORD
    CheckForBlockedWorkItems(
        IN DWORD dwCount,
        IN DWORD_PTR dwBlockId
        );

    static
    DWORD
    SelectThreadWrapper(
        IN ICAsyncThread * pThread
        );

    DWORD
    SelectThread(
        VOID
        );

    DWORD
    CreateSelectSocket(
        VOID
        );

    PRIVATE
    VOID
    DestroySelectSocket(
        VOID
        );

    VOID
    RecreateSelectSocket(
        VOID
        );

    VOID
    InterruptSelect(
        VOID
        );

    BOOL
    DrainSelectSocket(
        VOID
        );
};

//
// private data
//

PRIVATE ICAsyncThread * p_AsyncThread = NULL;

//
// functions
//


DWORD
InitializeAsyncSupport(
    VOID
    )

/*++

Routine Description:

    Create async select thread object

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS


        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "InitializeAsyncSupport",
                 NULL
                 ));

    DWORD error = ERROR_INTERNET_SHUTDOWN;

    if (!InDllCleanup) {
        EnterCriticalSection(&GeneralInitCritSec);
        if (!InDllCleanup) {
            if (p_AsyncThread == NULL) {
                p_AsyncThread = new ICAsyncThread();
                if (p_AsyncThread == NULL) {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                } else {
                    error = p_AsyncThread->GetError();
                    if (error != ERROR_SUCCESS) {
                        TerminateAsyncSupport();
                    }
                }
            } else {
                error = ERROR_SUCCESS;
            }
        }
        LeaveCriticalSection(&GeneralInitCritSec);
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
TerminateAsyncSupport(
    VOID
    )

/*++

Routine Description:

    Terminates async support

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "TerminateAsyncSupport",
                 NULL
                 ));

    ICAsyncThread * pThread;

    pThread = (ICAsyncThread *)InterlockedExchangePointer((PVOID*)&p_AsyncThread,
                                                   (PVOID)NULL
                          );

    if (pThread != NULL) {
        delete pThread;
    }

    DEBUG_LEAVE(0);
}


DWORD
QueueSocketWorkItem(
    IN CFsm * pFsm,
    IN SOCKET Socket
    )

/*++

Routine Description:

    Adds a blocked socket operation/work item to the blocked queue

Arguments:

    pFsm    - in-progress socket operation (FSM)

    Socket  - socket handle to wait on

Return Value:

    DWORD
        Success - ERROR_IO_PENDING

        Failure - ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "QueueSocketWorkItem",
                 "%#x, %#x",
                 pFsm,
                 Socket
                 ));

    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        pFsm->SetSocket(Socket);
        error = p_AsyncThread->QueueSocketWorkItem(pFsm);
        if (error == ERROR_SUCCESS) {
            error = ERROR_IO_PENDING;
        }
    }

    INET_ASSERT(error != ERROR_INTERNET_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item

Arguments:

    pFsm        - work item to block

    dwBlockId   - block on this id

    dwTimeout   - for this number of milliseconds

Return Value:

    DWORD
        Error   - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "BlockWorkItem",
                 "%#x, %#x, %d",
                 pFsm,
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    if (p_AsyncThread != NULL) {
        error = p_AsyncThread->BlockWorkItem(pFsm, dwBlockId, dwTimeout);
    }

    INET_ASSERT(error != ERROR_INTERNET_INTERNAL_ERROR);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblocks 1 or more work items

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - that are blocked on this id

    dwError     - with this error

    lPriority   - new priority unless default value of TP_NO_PRIORITY_CHANGE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    if (p_AsyncThread != NULL) {
        dwUnblocked = p_AsyncThread->UnblockWorkItems(dwCount,
                                                      dwBlockId,
                                                      dwError,
                                                      lPriority
                                                      );
    }

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Checks if there are any items blocked on dwBlockId

Arguments:

    dwCount     - number of items to look for

    dwBlockId   - blocked on this id

Return Value:

    DWORD
        Number of blocked items found

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    if (p_AsyncThread != NULL) {
        dwFound = p_AsyncThread->CheckForBlockedWorkItems(dwCount, dwBlockId);
    }

    DEBUG_LEAVE(dwFound);

    return dwFound;
}

//
// private functions
//

//
// ICAsyncThread methods
//


ICAsyncThread::~ICAsyncThread(
    VOID
    )

/*++

Routine Description:

    ICAsyncThread destructor. If we are being dynamically unloaded, signal the
    selecter thread and allow it to cleanup. Else the thread is already dead and
    we just need to reclaim the resources

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::~ICAsyncThread",
                 NULL
                 ));

    SetTerminating();
    if (GlobalDynaUnload) {
        InterruptSelect();

        //
        // Assuming the async thread was successfully created, the above clean-up
        // will have put it in a state where it's going to exit.  Need to wait
        // for it to exit before returning from here so it doesn't get scheduled
        // after wininet has been unloaded.
        //
        if(m_hThread)
        {
            DWORD dwRes = WaitForSingleObject(m_hThread, 5 * 1000);
            INET_ASSERT(dwRes == WAIT_OBJECT_0);
        }
    }
    DestroySelectSocket();

    if(m_hThread)
    {
        CloseHandle(m_hThread);
    }

    DEBUG_LEAVE(0);
}


DWORD
ICAsyncThread::QueueSocketWorkItem(
    IN CFsm * pFsm
    )

/*++

Routine Description:

    Add the work-item waiting on a blocked socket to the blocked queue.
    Interrupt the SelectThread to alert it to new work

Arguments:

    pFsm    - blocked work-item to queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INTERNAL_ERROR

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::QueueSocketWorkItem",
                 "%#x",
                 pFsm
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_INTERNET_INTERNAL_ERROR;

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->StartTimer();
        m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        InterruptSelect();
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICAsyncThread::BlockWorkItem(
    IN CFsm * pFsm,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Blocks a work item (FSM)

Arguments:

    pFsm        - work item (FSM) to block

    dwBlockId   - block on this

    dwTimeout   - for this amount of time (mSec)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::BlockWorkItem",
                 "%#x [%d], %#x, %d",
                 pFsm,
                 pFsm->GetPriority(),
                 dwBlockId,
                 dwTimeout
                 ));

    DWORD error = error = ERROR_INTERNET_INTERNAL_ERROR;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    if (lpThreadInfo != NULL) {
        pFsm->SetBlockId(dwBlockId);
        pFsm->SetTimeout(dwTimeout);

        RESET_FSM_OWNED(pFsm);

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("!!! FSM %#x unowned\n",
                    pFsm
                    ));

        m_BlockedQueue.Insert((CPriorityListEntry *)pFsm->List());
        lpThreadInfo->Fsm = NULL;
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);
    return error;
}


DWORD
ICAsyncThread::UnblockWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId,
    IN DWORD dwError,
    IN LONG lPriority
    )

/*++

Routine Description:

    Unblock a nunber of work items waiting on a block id

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

    dwError     - unblock work items with this error code

    lPriority   - if not TP_NO_PRIORITY_CHANGE, change priority to this value

Return Value:

    DWORD
        Number of work items unblocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::UnblockWorkItems",
                 "%d, %#x, %d (%s), %d",
                 dwCount,
                 dwBlockId,
                 dwError,
                 InternetMapError(dwError),
                 lPriority
                 ));

    DWORD dwUnblocked = 0;

    m_BlockedQueue.Acquire();

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        //CHECK_FSM_UNOWNED(pFsm);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
            pFsm->SetError(dwError);
            if (lPriority != TP_NO_PRIORITY_CHANGE) {
                pFsm->SetPriority(lPriority);
            }
//dprintf("UNBLOCKED %s FSM %#x state %s socket %#x\n", pFsm->MapType(), pFsm, pFsm->MapState(), pFsm->GetSocket());
            pFsm->QueueWorkItem();
            ++dwUnblocked;
            --dwCount;
        } else {
            pPrev = pCur;
        }
        pCur = (CPriorityListEntry *)pPrev->Next();
    }
    m_BlockedQueue.Release();

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}


DWORD
ICAsyncThread::CheckForBlockedWorkItems(
    IN DWORD dwCount,
    IN DWORD_PTR dwBlockId
    )

/*++

Routine Description:

    Examines to see if a blocked FSM is still blocked in order to prevent
        wasted processing if it isn't.

Arguments:

    dwCount     - unblock this many work items

    dwBlockId   - unblock work items waiting on this id

Return Value:

    DWORD
        Number of work items that are currently blocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "ICAsyncThread::CheckForBlockedWorkItems",
                 "%d, %#x",
                 dwCount,
                 dwBlockId
                 ));

    DWORD dwFound = 0;

    m_BlockedQueue.Acquire();

    CPriorityListEntry * pCur = (CPriorityListEntry *)m_BlockedQueue.Head();
    CPriorityListEntry * pPrev = (CPriorityListEntry *)m_BlockedQueue.Self();

    while ((dwCount != 0) && (pCur != (CPriorityListEntry *)m_BlockedQueue.Self())) {

        CFsm * pFsm = ContainingFsm((LPVOID)pCur);

        if (pFsm->IsBlockedOn(dwBlockId)) {
            ++dwFound;
            --dwCount;
        }
        pCur = (CPriorityListEntry *)pCur->Next();
    }
    m_BlockedQueue.Release();

    DEBUG_LEAVE(dwFound);

    return dwFound;
}


DWORD
ICAsyncThread::SelectThreadWrapper(
    IN ICAsyncThread * pThread
    )

/*++

Routine Description:

    Kicks off select thread as member function of pThread object

Arguments:

    pThread - pointer to thread object

Return Value:

    DWORD
        return code from SelectThread (not used)

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThreadWrapper",
                 "%#x",
                 pThread
                 ));

    DWORD error = pThread->SelectThread();

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICAsyncThread::SelectThread(
    VOID
    )

/*++

Routine Description:

    Waits for completed items on blocked queue to finish, either due to timeout,
    invalidated request handle or successful or error completion of the socket
    operation.

    Completed items are put on the work queue and a worker signalled to process
    it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    //
    // we need thread info for debug output
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(ASYNC,
                    FATAL,
                    ("Can't get thread info block\n"
                    ));

        INET_ASSERT(FALSE);

        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::SelectThread",
                 NULL
                 ));

    //
    // have to create select socket in this thread or winsock blocks main thread
    // on Win95 when autodial enabled
    //

    DWORD error = CreateSelectSocket();

    if (error != ERROR_SUCCESS) {

        DEBUG_LEAVE(error);

        return error;
    }

    DWORD ticks = GetTickCountWrap();

    while (!IsTerminating()) {

        //
        // run through the blocked items finding sockets to wait on and minimum
        // time to wait. If we find any items already timed out or invalidated
        // then remove them and put on the work queue
        //

        m_BlockedQueue.Acquire();

        PLIST_ENTRY pEntry;
        PLIST_ENTRY pPrev;

        pPrev = m_BlockedQueue.Self();

        //
        // BUGBUG - queue limited by size of FD_SET
        //

        struct fd_set read_fds;
        struct fd_set write_fds;
        struct fd_set except_fds;
        int n = 0;
        BOOL bLazy = FALSE;
        DWORD timeout = 0xffffffff;
        DWORD timeNow = GetTickCountWrap();

        FD_ZERO(&read_fds);
        FD_ZERO(&write_fds);
        FD_ZERO(&except_fds);

        FD_SET(m_SelectSocket, &read_fds);
        ++n;

        CFsm * pFsm;

        for (pEntry = m_BlockedQueue.Head();
             pEntry != m_BlockedQueue.Self();
             pEntry = ((CPriorityListEntry *)pPrev)->Next()) {

            pFsm = ContainingFsm((LPVOID)pEntry);
            if (pFsm->IsInvalid() || pFsm->IsTimedOut(timeNow)) {

                DEBUG_PRINT(ASYNC,
                            INFO,
                            ("%s FSM %#x %s\n",
                            pFsm->MapType(),
                            pFsm,
                            pFsm->IsInvalid() ? "invalid" : "timed out"
                            ));

                m_BlockedQueue.Remove((CPriorityListEntry *)pEntry);
                pFsm->SetErrorState(pFsm->IsInvalid()
                                        ? ERROR_INTERNET_OPERATION_CANCELLED
                                        : ERROR_INTERNET_TIMEOUT
                                        );
                pFsm->ResetSocket();
                pFsm->QueueWorkItem();
                continue;
            } else if (pFsm->IsActive()) {

                SOCKET sock = pFsm->GetSocket();

                if (pFsm->GetAction() == FSM_ACTION_RECEIVE) {

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("FSM %#x READ waiting on socket %#x\n",
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &read_fds);
                } else {

                    //
                    // connect() & send()
                    //

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x WRITE waiting on socket %#x\n",
                                pFsm->MapType(),
                                pFsm,
                                sock
                                ));

                    FD_SET(sock, &write_fds);
                }

                //
                // all sockets are checked for exception
                //

                FD_SET(sock, &except_fds);
                ++n;
//DWORD t;
//if ((t = pFsm->GetElapsedTime()) > 10) {
//    dprintf("%s FSM %#x socket %#x on queue %d mSec times-out in %d\n",
//    pFsm->MapType(),
//    pFsm,
//    sock,
//    t,
//    pFsm->GetTimeout() - GetTickCount());
//}
            }

            DWORD interval = pFsm->GetTimeout() - timeNow;

            if (interval < timeout) {
                timeout = interval;
//dprintf("min timeout = %d\n", timeout);
            }
            pPrev = pEntry;
        }

        m_BlockedQueue.Release();

        //
        // BUGBUG - wait for default (5 secs) timeout if nothing currently on
        //          list
        //

        if (n == 1) {
            timeout = g_bHibernating ? INFINITE : DEFAULT_ASYNC_THREAD_TIMEOUT;
            bLazy = TRUE;
        }

        INET_ASSERT(n <= FD_SETSIZE);

        struct timeval to;

        to.tv_sec = timeout / 1000;
        to.tv_usec = (timeout % 1000) * 1000;

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("waiting %d mSec (%d.%06d) for select(). %d sockets\n",
                    timeout,
                    to.tv_sec,
                    to.tv_usec,
                    n
                    ));

        //SuspendCAP();

        if (IsTerminating()) {
            break;
        }
        n = PERF_Select(n, &read_fds, &write_fds, &except_fds, &to);
        if (IsTerminating()) {
            break;
        }

        //ResumeCAP();

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("select() returns %d\n",
                    n
                    ));

        //
        // if the only thing that's happened is that a new request has been
        // added to the list then rebuild the list and re-select
        //

        if ((n == 1) && FD_ISSET(m_SelectSocket, &read_fds)) {
            if (!DrainSelectSocket() && !IsTerminating()) {
                RecreateSelectSocket();
            }
            continue;
        }

        //
        // if any items are completed (either successfully or with an error)
        // or timed out or invalidated then put them on the work queue
        //

        if (n >= 0) {
            m_BlockedQueue.Acquire();

            pPrev = m_BlockedQueue.Self();
            timeNow = GetTickCountWrap();

            for (pEntry = m_BlockedQueue.Head();
                 pEntry != m_BlockedQueue.Self();
                 pEntry = ((CPriorityListEntry *)pPrev)->Next()) {

                DWORD dwEntryError;
                BOOL bComplete = FALSE;
                LONG lPriority = TP_NO_PRIORITY_CHANGE;

                pFsm = ContainingFsm((LPVOID)pEntry);
                if (pFsm->IsInvalid()) {

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x invalid\n",
                                pFsm->MapType(),
                                pFsm
                                ));

                    dwEntryError = ERROR_INTERNET_OPERATION_CANCELLED;
                    bComplete = TRUE;
                } else if (pFsm->IsTimedOut(timeNow)) {

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("%s FSM %#x timed out\n",
                                pFsm->MapType(),
                                pFsm
                                ));

                    dwEntryError = ERROR_INTERNET_TIMEOUT;
                    bComplete = TRUE;
                } else if (pFsm->IsActive()) {

                    SOCKET sock = pFsm->GetSocket();

                    if (FD_ISSET(sock, &except_fds)) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x socket %#x exception\n",
                                    pFsm->MapType(),
                                    pFsm,
                                    sock
                                    ));

                        switch (pFsm->GetAction()) {
                        case FSM_ACTION_CONNECT:
                            dwEntryError = ERROR_INTERNET_CANNOT_CONNECT;
                            break;

                        case FSM_ACTION_SEND:
                        case FSM_ACTION_RECEIVE:
                            dwEntryError = ERROR_INTERNET_CONNECTION_RESET;
                            break;

                        default:

                            INET_ASSERT(FALSE);

                            break;
                        }
                        bComplete = TRUE;
                    } else if (FD_ISSET(sock, &read_fds)
                    || FD_ISSET(sock, &write_fds)) {

                        DEBUG_PRINT(ASYNC,
                                    INFO,
                                    ("%s FSM %#x socket %#x completed\n",
                                    pFsm->MapType(),
                                    pFsm,
                                    sock
                                    ));

                        dwEntryError = ERROR_SUCCESS;
                        bComplete = TRUE;

                        //
                        // BUGBUG - the priority needs to be boosted
                        //

                    }
                }
                if (bComplete) {
                    m_BlockedQueue.Remove((CPriorityListEntry *)pFsm);
                    if (dwEntryError != ERROR_SUCCESS) {
                        pFsm->SetErrorState(dwEntryError);
                    } else {
                        pFsm->SetError(ERROR_SUCCESS);
                        pFsm->SetState(pFsm->GetNextState());
                    }
                    pFsm->SetPriority(lPriority);

//dprintf("%s FSM %#x socket %#x signalled, time on queue = %d\n", pFsm->MapType(), pFsm, pFsm->GetSocket(), pFsm->StopTimer());
                    //
                    // no longer waiting on this socket handle
                    //

                    pFsm->ResetSocket();

                    //
                    // BUGBUG - if the next operation will complete quickly
                    //          (FSM_HINT_QUICK) then we should run it here
                    //          instead of queuing to another thread
                    //

                    pFsm->QueueWorkItem();
                } else {
                    pPrev = pEntry;
                }
            }
            m_BlockedQueue.Release();
        } else {
            error = _I_WSAGetLastError();

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("select() returns %d (%s)\n",
                        error,
                        InternetMapError(error)
                        ));

            //
            // WSAENOTSOCK can happen if the socket was cancelled just
            // before we waited on it. We can also get WSAEINTR if
            // select() is terminated early (by APC)
            //

            INET_ASSERT((error == WSAENOTSOCK) || (error == WSAEINTR) || (error == WSAEBADF));

            if (error == WSAEINTR) {
                continue;
            }

            //
            // when running on a portable (& probably desktops also), if we
            // suspend & resume, the select socket can be invalidated. We
            // need to recognize this situation and handle it
            //

            if (error == WSAENOTSOCK) {

                //
                // the select socket may be dead. Throw it away & create a new
                // one. We should pick up any blocked requests that tried
                // unsuccessfully to interrupt the old select socket
                //

                RecreateSelectSocket();
            } else {

                //
                // some socket(s) other than the select socket has become
                // invalid. Cancel the corresponding request(s)
                //
            }
        }

        //
        // perform timed events
        //

        if ((GetTickCountWrap() - ticks) >= DEFAULT_ASYNC_THREAD_TIMEOUT) {
            if( bLazy == TRUE && !InDllCleanup && !IsTerminating())
            {
                //
                // wake background task mgr
                // this may involve one of the background workitem
                // to be queued and get executed
                //
                NotifyBackgroundTaskMgr();
            }
            PurgeServerInfoList(FALSE);
            ticks = GetTickCountWrap();
        }
    }
    TerminateAsyncSupport();

    DEBUG_LEAVE(error);
//dprintf("!!! Waiter FSM is done\n");
    return error;
}


DWORD
ICAsyncThread::CreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    In order to not have to keep inefficiently polling select() with a short
    time-out, we create a 'trick' datagram socket that we can use to interrupt
    select() with: this is a local socket, and if we send something to ourself
    then select() will complete (assuming one of the sockets we are waiting on
    is the one we create here)

    N.B. Sockets support must be initialized by the time we get here

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - mapped socket error

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "ICAsyncThread::CreateSelectSocket",
                 NULL
                 ));

    INET_ASSERT(m_SelectSocket == INVALID_SOCKET);

    DWORD error;
    SOCKET sock;

    sock = _I_socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (sock == INVALID_SOCKET) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("socket() failed\n"
                    ));

        goto socket_error;
    }

    SOCKADDR_IN sockAddr;

    sockAddr.sin_family = AF_INET;
    sockAddr.sin_port = 0;
    *(LPDWORD)&sockAddr.sin_addr = _I_htonl(INADDR_LOOPBACK);
    memset(&sockAddr.sin_zero, 0, sizeof(sockAddr.sin_zero));

    int rc;

    DEBUG_PRINT(ASYNC,
                INFO,
                ("binding socket %#x to address %d.%d.%d.%d\n",
                sock,
                ((LPBYTE)&sockAddr.sin_addr)[0] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[1] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[2] & 0xff,
                ((LPBYTE)&sockAddr.sin_addr)[3] & 0xff
                ));

    rc = _I_bind(sock, (LPSOCKADDR)&sockAddr, sizeof(sockAddr));
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("bind() failed\n"
                    ));

        goto socket_error;
    }

    int namelen;
    SOCKADDR sockname;
    namelen = sizeof(sockname);

    rc = _I_getsockname(sock, &sockname, &namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("getsockname() failed\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(ASYNC,
                INFO,
                ("connecting to address %d.%d.%d.%d\n",
                ((LPBYTE)&sockname.sa_data)[2] & 0xff,
                ((LPBYTE)&sockname.sa_data)[3] & 0xff,
                ((LPBYTE)&sockname.sa_data)[4] & 0xff,
                ((LPBYTE)&sockname.sa_data)[5] & 0xff
                ));

    rc = _I_connect(sock, &sockname, namelen);
    if (rc == SOCKET_ERROR) {

        DEBUG_PRINT(ASYNC,
                    ERROR,
                    ("connect() failed\n"
                    ));

        goto socket_error;
    }

    m_SelectSocket = sock;
    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    DestroySelectSocket();
    goto quit;
}


VOID
ICAsyncThread::DestroySelectSocket(
    VOID
    )

/*++

Routine Description:

    Just closes SelectSocket (if we think its open)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::DestroySelectSocket",
                 NULL
                 ));

    if (m_SelectSocket != INVALID_SOCKET) {
        _I_closesocket(m_SelectSocket);
        m_SelectSocket = INVALID_SOCKET;
    }

    DEBUG_LEAVE(0);
}


VOID
ICAsyncThread::RecreateSelectSocket(
    VOID
    )

/*++

Routine Description:

    Attempt to destroy & recreate select socket. Required when socket is killed
    due to suspend, e.g.

    Since the underlying net components may take a while to restart, we loop up
    to 12 times, waiting up to ~16 secs (~32 secs cumulative)

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::RecreateSelectSocket",
                 NULL
                 ));

    DestroySelectSocket();

    DEBUG_PRINT(ASYNC,
                INFO,
                ("current interrupt count = %d\n",
                m_lSelectInterrupts
                ));

    m_lSelectInterrupts = -1;

    int iterations = 12;
    DWORD time = 8;
    DWORD error;

    do {
        error = CreateSelectSocket();
        if (error != ERROR_SUCCESS) {
            PERF_Sleep(time);
            time <<= 1;
        }
    } while ((error != ERROR_SUCCESS) && --iterations);

    DEBUG_LEAVE(0);
}

VOID 
InterruptSelect(
    VOID
    )
{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "InterruptSelect",
                 NULL
                 ));

    __try 
    {
        if (p_AsyncThread != NULL) 
        {
            p_AsyncThread->InterruptSelect();
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    ENDEXCEPT

    DEBUG_LEAVE(0);

    return;
}


VOID
ICAsyncThread::InterruptSelect(
    VOID
    )

/*++

Routine Description:

    We interrupt a waiting select() by sending a small amount of data to ourself
    on the 'trick datagram socket'

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "ICAsyncThread::InterruptSelect",
                 NULL
                 ));

    //
    // if the async select socket is already created then interrupt it. If it is
    // not yet created then it probably means that the async scheduler thread
    // hasn't gotten around to it yet, ipso facto the async scheduler can't be
    // stuck in a select(), hence its okay to skip
    //

    if (m_SelectSocket != INVALID_SOCKET) {
        if (InterlockedIncrement(&m_lSelectInterrupts) == 0) {
            if (_I_send != NULL) {
#if INET_DEBUG
                int nSent =
#endif
                _I_send(m_SelectSocket, gszBang, 1, 0);

#if INET_DEBUG
                if (nSent < 0) {

                    DWORD error = _I_WSAGetLastError();

                    DEBUG_PRINT(ASYNC,
                                INFO,
                                ("send(%#x) returns %s (%d)\n",
                                m_SelectSocket,
                                InternetMapError(error),
                                error
                                ));

                }

                INET_ASSERT(!InDllCleanup ? (nSent == 1) : TRUE);
#endif
            }
        } else {
            InterlockedDecrement(&m_lSelectInterrupts);

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("select() already interrupted, count = %d\n",
                        m_lSelectInterrupts
                        ));

        }
    } else {

        DEBUG_PRINT(ASYNC,
                    WARNING,
                    ("select socket not yet created\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


BOOL
ICAsyncThread::DrainSelectSocket(
    VOID
    )

/*++

Routine Description:

    Just reads the data written to the async select socket in order to wake up
    select()

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - successfully drained

        FALSE   - error occurred

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Bool,
                 "ICAsyncThread::DrainSelectSocket",
                 NULL
                 ));

    BOOL bSuccess = TRUE;

    if (m_SelectSocket != INVALID_SOCKET) {

        //
        // reduce the interrupt count. Threads making async requests will cause
        // the select() to be interrupted again
        //

        InterlockedDecrement(&m_lSelectInterrupts);

        char buf[32];
        int nReceived;

        nReceived = _I_recv(m_SelectSocket, buf, sizeof(buf), 0);

#ifdef unix
        if(nReceived > -1)
        {
#endif /* unix */

        //INET_ASSERT(nReceived == 1);
        //INET_ASSERT(buf[0] == '!');

#ifdef unix
        }
#endif /* unix */

        if (nReceived < 0) {

            DWORD error = _I_WSAGetLastError();

            INET_ASSERT(error != ERROR_SUCCESS);

            DEBUG_PRINT(ASYNC,
                        ERROR,
                        ("recv() returns %s [%d]\n",
                        InternetMapError(error),
                        error
                        ));

            bSuccess = FALSE;
        }
    } else {

        DEBUG_PRINT(ASYNC,
                    INFO,
                    ("m_SelectSocket == INVALID_SOCKET\n"
                    ));

        bSuccess = FALSE;
    }

    DEBUG_LEAVE(bSuccess);

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\priolist.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    priolist.cxx

Abstract:

    Contains prioritized, serialized list class implementation

    Contents:
        CPriorityList::Insert
        CPriorityList::Remove

Author:

    Richard L Firth (rfirth) 03-May-1997

Notes:

    Properly, the CPriorityList class should extend a CSerializedList class, but
    we don't currently have one, just a serialized list type (common\serialst.cxx).

    WARNING: Code in this module makes assumptions about the contents of a
    SERIALIZED_LIST

Revision History:

    03-May-1997 rfirth
        Created

--*/

#include <wininetp.h>

//
// class methods
//


VOID
CPriorityList::Insert(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Insert prioritized list entry into prioritized, serialized list

Arguments:

    pEntry  - pointer to prioritized list entry to add

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Insert",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    Acquire();

    INET_ASSERT(!IsOnSerializedList(&m_List, pEntry->List()));
    INET_ASSERT(pEntry->Next() == NULL);
    INET_ASSERT(pEntry->Prev() == NULL);

    CPriorityListEntry * pCur;

    for (pCur = (CPriorityListEntry *)m_List.List.Flink;
         pCur != (CPriorityListEntry *)&m_List.List.Flink;
         pCur = (CPriorityListEntry *)pCur->Next()) {

        if (pCur->GetPriority() < pEntry->GetPriority()) {
            break;
        }
    }
    InsertHeadList(pCur->Prev(), pEntry->List());
    ++m_List.ElementCount;
    Release();

    DEBUG_LEAVE(0);
}


VOID
CPriorityList::Remove(
    IN CPriorityListEntry * pEntry
    )

/*++

Routine Description:

    Remove entry from prioritized serialized list

Arguments:

    pEntry  - address of entry to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 None,
                 "CPriorityList::Remove",
                 "{%#x} %#x",
                 this,
                 pEntry
                 ));

    Acquire();

    INET_ASSERT(IsOnSerializedList(&m_List, pEntry->List()));

    pEntry->Remove();
    --m_List.ElementCount;
    Release();

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\parsers.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    parsers.cxx

Abstract:

    Common text parsing functions (generally moved here from other protocols)

    Contents:
        ExtractWord
        ExtractDword
        ExtractInt
        SkipWhitespace
        SkipSpaces
        SkipLine
        FindToken
        NiceNum

Author:

    Richard L Firth (rfirth) 03-Jul-1996

Revision History:

    03-Jul-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
ExtractWord(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned short
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    WORD number;
    BOOL exact;
    LPSTR string;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("65535") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    number = 0;
    string = *pString;
    while (NumberLength && isdigit(*string)) {
        number = number * 10 + (WORD)((BYTE)(*string++) - (BYTE)'0');
        --NumberLength;
    }
    *pConvertedNumber = number;
    *pString = string;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractDword(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPDWORD pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an unsigned long
                2. A whole number is contained within *pString

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    DWORD number;
    BOOL exact;

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("4294967295") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength--; ) {
        number = number * 10 + (DWORD)((BYTE)*((*pString)++) - (BYTE)'0');
    }
    *pConvertedNumber = number;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
ExtractInt(
    IN OUT LPSTR* pString,
    IN DWORD NumberLength,
    OUT LPINT pConvertedNumber
    )

/*++

Routine Description:

    pulls a <NumberLength> character number out of a string.

    Assumes:    1. The number to be converted is an signed integer (32-bits)

Arguments:

    pString             - pointer to pointer to string from which to get number

    NumberLength        - number of characters that comprise number string, if
                          not equal to 0, else if 0, we don't know the length
                          of the number string a priori

    pConvertedNumber    - pointer to variable where converted number written

Return Value:

    BOOL
        TRUE    - number converted OK

        FALSE   - one of the characters in the number is not a digit

--*/

{
    int number;
    int sign;
    BOOL exact;

    if ((**pString == '-') || (**pString == '+')) {
        sign = (**pString == '-') ? -1 : +1;
        if (NumberLength) {
            --NumberLength;
        }
        ++*pString;
    } else {
        sign = 1;
    }

    //
    // if the caller doesn't know how many characters comprise the number, then
    // we will convert until the next non-digit character, or until we have
    // converted the maximum number of digits that can comprise an unsigned
    // short value
    //

    if (NumberLength == 0) {
        NumberLength = sizeof("2147483647") - 1;
        exact = FALSE;
    } else {
        exact = TRUE;
    }
    for (number = 0; isdigit(**pString) && NumberLength; ) {
        number = number * 10 + (INT)(((BYTE)**pString) - (BYTE)'0');
        ++*pString;
        --NumberLength;
    }
    *pConvertedNumber = number * sign;

    //
    // if we were asked to convert a certain number of characters but failed
    // because we hit a non-digit character, then return FALSE. Anything else
    // (we converted required number of characters, or the caller didn't know
    // how many characters comprised the number) is TRUE
    //

    return (exact && (NumberLength != 0)) ? FALSE : TRUE;
}


BOOL
SkipWhitespace(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any whitespace characters

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipSpaces(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Skips any space characters. We only look for the actual space character

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer == ' ')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


BOOL
SkipLine(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Positions text pointer at start of next non-empty line

Arguments:

    lpBuffer        - pointer to string. Updated on output

    lpBufferLength  - pointer to remaining length of string. Updated on output

Return Value:

    BOOL
        TRUE    - found start of next non-empty line

        FALSE   - ran out of buffer

--*/

{
    while ((*lpBufferLength != 0) && (**lpBuffer != '\r') && (**lpBuffer != '\n')) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && ((**lpBuffer == '\r') || (**lpBuffer == '\n'))) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


#undef  isspace
#define isspace(ch) ((ch==0x20) || ((ch >= 0x09) && (ch <= 0x0d)))

BOOL
FindToken(
    IN OUT LPSTR* lpBuffer,
    IN OUT LPDWORD lpBufferLength
    )

/*++

Routine Description:

    Moves over the current token, past any spaces, and to the start of the next
    token

Arguments:

    lpBuffer        - pointer to pointer to buffer

    lpBufferLength  - pointer to remaining buffer length

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. No more data left in buffer

--*/

{
    while ((*lpBufferLength != 0) && !isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    while ((*lpBufferLength != 0) && isspace(**lpBuffer)) {
        ++*lpBuffer;
        --*lpBufferLength;
    }
    return *lpBufferLength != 0;
}


LPSTR
NiceNum(
    OUT LPSTR Buffer,
    IN SIZE_T Number,
    IN int FieldWidth
    )

/*++

Routine Description:

    Converts a number to a string. The string is very human-sensible (i.e.
    1,234,567 instead of 1234567. Sometimes its hard to make out these numbers
    when your salary is so large)

Arguments:

    Buffer      - place to put resultant string

    Number      - to convert

    FieldWidth  - maximum width of the field, or 0 for "don't care"

Return Value:

    LPSTR
        pointer to Buffer

--*/

{
    int i;

    if (Number == 0) {
        if (FieldWidth == 0) {
            Buffer[0] = '0';
            Buffer[1] = '\0';
        } else {
            memset(Buffer, ' ', FieldWidth);
            Buffer[FieldWidth - 1] = '0';
            Buffer[FieldWidth] = '\0';
        }
    } else {

        //
        // if the caller specified zero for the field width then work out how
        // many characters the string will occupy
        //

        if (FieldWidth == 0) {

            SIZE_T n;

            n = Number;
            ++FieldWidth;
            while (n >= 10) {
                n /= 10;
                ++FieldWidth;
            }

            FieldWidth += (FieldWidth / 3) - (((FieldWidth % 3) == 0) ? 1 : 0);
        }

        //
        // now create the representation
        //

        Buffer[FieldWidth] = '\0';
        Buffer += FieldWidth;
        i = 0;
        while (Number && FieldWidth) {
            *--Buffer = (char)((Number % 10) + '0');
            --FieldWidth;
            Number /= 10;
            if ((++i == 3) && FieldWidth) {
                if (Number) {
                    *--Buffer = ',';
                    --FieldWidth;
                    i = 0;
                }
            }
        }
        while (FieldWidth--) {
            *--Buffer = ' ';
        }
    }
    return Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\rescache.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    rescache.cxx

Abstract:

    Contains functions which manipulate resolver cache for winsock
    name resolution calls

    Contents:
        InitializeResolverCache
        TerminateResolverCache
        QueryResolverCache
        AddResolverCacheEntry
        FlushResolverCache
        ReleaseResolverCacheEntry
        (RemoveCacheEntry)
        (ResolverCacheHit)
        (AddrInfoMatch)
        (CreateCacheEntry)

Author:

    Richard L Firth (rfirth) 10-Jul-1994

Environment:

    Win-16/32 user level

Revision History:

    rfirth 10-Jul-1994
        Created

--*/

//
// includes
//

#include "wininetp.h"

//
// private manifests
//

//
// private macros
//

#define SET_EXPIRATION_TIME(cacheEntry)

//
// private data
//

PRIVATE BOOL ResolverCacheInitialized = FALSE;

//
// DnsCachingEnabled - caching is enabled by default
//

PRIVATE BOOL DnsCachingEnabled = TRUE;

//
// DnsCacheTimeout - number of seconds before a cache entry expires. This value
// is added to the current time (in seconds) to get the expiry time
//

PRIVATE DWORD DnsCacheTimeout = DEFAULT_DNS_CACHE_TIMEOUT;

//
// MaximumDnsCacheEntries - the maximum number of RESOLVER_CACHE_ENTRYs in the
// cache before we start throwing out the LRU
//

PRIVATE INT MaximumDnsCacheEntries = DEFAULT_DNS_CACHE_ENTRIES;

//
// CurrentDnsCacheEntries - the number of RESOLVER_CACHE_ENTRYs currently in the
// cache
//

PRIVATE INT CurrentDnsCacheEntries = 0;

//
// ResolverCache - serialized list of RESOLVER_CACHE_ENTRYs, kept in MRU order.
// We only need to remove the tail of the list to remove the LRU entry
//

PRIVATE SERIALIZED_LIST ResolverCache = {0};

//
// private prototypes
//

PRIVATE
VOID
RemoveCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    );

PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    );

PRIVATE
BOOL
AddrInfoMatch(
    IN LPADDRINFO AddrInfo,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    );

PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive
    );

#if INET_DEBUG

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(
    IN DWORD Time
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheAddrInfoStr(
    IN LPADDRINFO AddrInfo
    );

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapSockAddress(
    IN LPSOCKADDR Address
    );

#endif

//
// functions
//


VOID
InitializeResolverCache(
    VOID
    )

/*++

Routine Description:

    Initializes the resolver cache:

        * Initializes the cache list anchor
        * loads the cache

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "InitializeResolverCache",
                 NULL
                 ));


    if (!(BOOL)InterlockedExchange((LPLONG)&ResolverCacheInitialized, TRUE)) {
        InternetReadRegistryDword("DnsCacheEnabled", (LPDWORD)&DnsCachingEnabled);
        InternetReadRegistryDword("DnsCacheEntries", (LPDWORD)&MaximumDnsCacheEntries);
        InternetReadRegistryDword("DnsCacheTimeout", &DnsCacheTimeout);
        InitializeSerializedList(&ResolverCache);

        //
        // if the size of the cache in the registry is 0 then its the same as
        // no caching
        //

        if (MaximumDnsCacheEntries == 0) {
            DnsCachingEnabled = FALSE;
        }
    } else {

        //
        // shouldn't be calling this more than once
        //

        INET_ASSERT(FALSE);

    }

    DEBUG_LEAVE(0);
}


VOID
TerminateResolverCache(
    VOID
    )

/*++

Routine Description:

    Free up all resources allocated by InitializeResolverCache()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "TerminateResolverCache",
                 NULL
                 ));

    if (InterlockedExchange((LPLONG)&ResolverCacheInitialized, FALSE)) {

        //
        // short-circuit any other cache attempts (shouldn't be any by now)
        //

        DnsCachingEnabled = FALSE;

        //
        // and clear out the list
        //

        FlushResolverCache();

        //
        // we are done with the serialized list
        //

        TerminateSerializedList(&ResolverCache);
    }

    DEBUG_LEAVE(0);
}


LPRESOLVER_CACHE_ENTRY
QueryResolverCache(
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL,
    OUT LPADDRINFO * AddrInfo,
    OUT LPDWORD TimeToLive
    )

/*++

Routine Description:

    Checks if Name is stored in the last resolved name cache. If the entry is
    found, but has expired then it is removed from the cache

Arguments:

    Name        - pointer to name string

    Address     - pointer to IP address (in sockaddr format)

    AddrInfo    - pointer to returned pointer to addrinfo

    TimeToLive  - pointer to returned time to live

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "QueryResolverCache",
                 "%q, %s, %#x, %#x",
                 Name,
                 CacheMapSockAddress(Address),
                 AddrInfo,
                 TimeToLive
                 ));

    LPRESOLVER_CACHE_ENTRY lpEntry;

    if (!DnsCachingEnabled) {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled\n"
                    ));

        *AddrInfo = NULL;
        lpEntry = NULL;
        goto quit;
    }

    LockSerializedList(&ResolverCache);

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;
    DWORD timeNow;

    cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(&ResolverCache);
    timeNow = (DWORD)time(NULL);

    while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache)) {

        //
        // on every cache lookup, purge any stale entries. LIVE_FOREVER means
        // that we don't expect the entry's net address to expire, but it
        // DOESN'T mean that we can't throw out the entry if its the LRU and
        // we're at maximum cache capacity. We can't do this if the item is
        // still in-use. In this case, we mark it stale
        //

        if ((cacheEntry->ExpirationTime != LIVE_FOREVER)
        && (cacheEntry->ExpirationTime <= timeNow)) {

            //
            // if reference count not zero then another thread is using
            // this entry - mark as stale else delete it
            //

            if (cacheEntry->ReferenceCount != 0) {

                INET_ASSERT(cacheEntry->State == ENTRY_IN_USE);

                cacheEntry->State = ENTRY_DELETE;
            } else {

                //
                // this entry is stale; throw it out
                // "my hovercraft is full of eels"
                //

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out stale DNS entry %q, expiry = %s\n",
                            cacheEntry->AddrInfo->ai_canonname,
                            CacheTimestr(cacheEntry->ExpirationTime)
                            ));

                //
                // BUGBUG - what happens if ExpirationTime == timeNow?
                //

                previousEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
                RemoveCacheEntry(cacheEntry);
                cacheEntry = previousEntry;
            }
        } else if (ResolverCacheHit(cacheEntry, Name, Address)
        && ((cacheEntry->State == ENTRY_UNUSED)
        || (cacheEntry->State == ENTRY_IN_USE))) {

            //
            // we found the entry, and it still has time to live. Make it the
            // head of the list (MRU first), set the state to in-use and increase
            // the reference count
            //

            RemoveFromSerializedList(&ResolverCache, &cacheEntry->ListEntry);
            InsertAtHeadOfSerializedList(&ResolverCache, &cacheEntry->ListEntry);
            cacheEntry->State = ENTRY_IN_USE;
            ++cacheEntry->ReferenceCount;
            *AddrInfo = cacheEntry->AddrInfo;
            lpEntry = cacheEntry;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("entry found in DNS cache\n"
                        ));

            goto done;
        }
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
    }

    *AddrInfo = NULL;
    lpEntry = NULL;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("didn't find entry in DNS cache\n"
                ));

done:

    UnlockSerializedList(&ResolverCache);

quit:

    DEBUG_LEAVE(lpEntry);
    return lpEntry;
}


VOID
AddResolverCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive
    )

/*++

Routine Description:

    Adds an addrinfo pointer to the cache. Creates a new entry to hold it
    and links it into the cache list, displacing the LRU entry if required.
    If we cannot create the entry, the addrinfo is freed, no errors returned

    N.B.: Calling this routine gives the resolver cache "ownership" of the
    addrinfo chain. Caller should not use AddrInfo pointer afterwards.

Arguments:

    lpszHostName    - the name we originally requested be resolved. May be
                      different than the names returned by the resolver, e.g.
                      "proxy" => "proxy1.microsoft.com, proxy2.microsoft.com"

    AddrInfo        - pointer to addrinfo chain to add to the cache

    TimeToLive      - amount of time this information has to live. Can be:

                        LIVE_FOREVER    - don't timeout (but can be discarded)

                        LIVE_DEFAULT    - use the default value

                        anything else   - number of seconds to live

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "AddResolverCacheEntry",
                 "%q, %#x, %d",
                 lpszHostName,
                 AddrInfo,
                 TimeToLive
                 ));

    BOOL bAdded = FALSE;

    if (!DnsCachingEnabled) {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled\n"
                    ));

        goto quit;
    }

    LockSerializedList(&ResolverCache);

    //
    // check that the entry is not already in the cache - 2 or more threads may
    // have been simultaneously resolving the same name
    //

    LPADDRINFO lpAddrInfo;
    DWORD ttl;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

    INET_ASSERT(lpszHostName != NULL);

    if (!(lpResolverCacheEntry = QueryResolverCache(lpszHostName, NULL, &lpAddrInfo, &ttl))) {

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        //
        // remove as many entries as we can beginning at the tail of the list.
        // We try to remove enough to get the cache size back below the limit.
        // This may consist of removing expired entries or entries marked as
        // DELETE. If there are expired, in-use entries then we mark them as
        // DELETE. This may result in the cache list growing until those threads
        // which have referenced cache entries release them
        //

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)TailOfSerializedList(&ResolverCache);

        while ((CurrentDnsCacheEntries >= MaximumDnsCacheEntries)
        && (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache))) {

            //
            // cache has maximum entries: throw out the Least Recently Used (its
            // the one at the back of the queue, ma'am) but only if no-one else
            // is currently accessing it
            //

            if ((cacheEntry->State != ENTRY_IN_USE)
            && (cacheEntry->ReferenceCount == 0)) {

                INET_ASSERT((cacheEntry->State == ENTRY_UNUSED)
                            || (cacheEntry->State == ENTRY_DELETE));

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("throwing out LRU %q\n",
                            cacheEntry->AddrInfo->ai_canonname
                            ));

                LPRESOLVER_CACHE_ENTRY nextEntry;

                nextEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Flink;
                RemoveCacheEntry(cacheEntry);
                cacheEntry = nextEntry;
            } else if (cacheEntry->State == ENTRY_IN_USE) {

                //
                // this entry needs to be freed when it is released
                //

                cacheEntry->State = ENTRY_DELETE;
            }
            cacheEntry = (LPRESOLVER_CACHE_ENTRY)cacheEntry->ListEntry.Blink;
        }

        //
        // add the entry at the head of the queue - it is the Most Recently Used
        // after all. If we fail to allocate memory, its no problem: it'll just
        // take a little longer if this entry would have been hit before we needed
        // to throw out another entry
        //

        if (cacheEntry = CreateCacheEntry(lpszHostName, AddrInfo, TimeToLive)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("caching %q, expiry = %s\n",
                        CacheAddrInfoStr(cacheEntry->AddrInfo),
                        CacheTimestr(cacheEntry->ExpirationTime)
                        ));

            InsertAtHeadOfSerializedList(&ResolverCache, &cacheEntry->ListEntry);
            ++CurrentDnsCacheEntries;
            bAdded = TRUE;
        }

    } else {

        //
        // this entry is already in the cache. 2 or more threads must have been
        // resolving the same name simultaneously. We just bump the expiration
        // time to the more recent value
        //

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("found %q already in the cache!?\n",
                    lpszHostName
                    ));

        ReleaseResolverCacheEntry(lpResolverCacheEntry);
    }

    UnlockSerializedList(&ResolverCache);

quit:

    if (!bAdded) {
        //
        // failed to add this entry to the cache, so free it
        //
        _I_freeaddrinfo(AddrInfo);
    }

    DEBUG_LEAVE(0);
}


VOID
FlushResolverCache(
    VOID
    )

/*++

Routine Description:

    Removes all entries in DNS resolver cache

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "FlushResolverCache",
                 NULL
                 ));

    LPRESOLVER_CACHE_ENTRY cacheEntry;
    LPRESOLVER_CACHE_ENTRY previousEntry;

    LockSerializedList(&ResolverCache);

    previousEntry = (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache);
    cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(&ResolverCache);
    while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache)) {
        if (cacheEntry->State == ENTRY_UNUSED) {
            RemoveCacheEntry(cacheEntry);
        } else {

            DEBUG_PRINT(SOCKETS,
                        WARNING,
                        ("cache entry %#x (%q) still in-use\n",
                        cacheEntry->HostName
                        ));

            cacheEntry->State = ENTRY_DELETE;
            previousEntry = cacheEntry;
        }
        cacheEntry = (LPRESOLVER_CACHE_ENTRY)previousEntry->ListEntry.Flink;
    }

    UnlockSerializedList(&ResolverCache);

    DEBUG_LEAVE(0);
}


VOID
ReleaseResolverCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY cacheEntry
    )

/*++

Routine Description:

    Either mark a entry unused or if it is stale, delete it

Arguments:

    lpAddrInfo   - pointer to AddrInfo field of entry to free

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ReleaseResolverCacheEntry",
                 "%#x, %#x",
                 cacheEntry, (cacheEntry ? cacheEntry->AddrInfo : NULL)
                 ));
                 
    LockSerializedList(&ResolverCache);

    //
    // reference count should never go below zero!
    //

    INET_ASSERT(cacheEntry->ReferenceCount > 0);

    if (--cacheEntry->ReferenceCount <= 0) {

        //
        // last releaser gets to decide what to do - mark unused or delete
        //

        if (cacheEntry->State == ENTRY_IN_USE) {
            cacheEntry->State = ENTRY_UNUSED;
        } else if (cacheEntry->State == ENTRY_DELETE) {

            //
            // entry is already stale - throw it out
            //

            RemoveCacheEntry(cacheEntry);
        } else {

            //
            // unused? or bogus value? Someone changed state while refcount
            // not zero?
            //

            INET_ASSERT((cacheEntry->State == ENTRY_IN_USE)
                        || (cacheEntry->State == ENTRY_DELETE));

        }
    }

    UnlockSerializedList(&ResolverCache);

    DEBUG_LEAVE(0);
}


VOID
ThrowOutResolverCacheEntry(
    IN LPADDRINFO lpAddrInfo
    )

/*++

Routine Description:

    Removes this entry from the DNS cache, based on the host name. We assume
    that the entry came from the cache, so unless it has been already purged,
    we should be able to throw it out

Arguments:

    lpAddrInfo  - pointer to addrinfo field with name of entry to throw out

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ThrowOutResolverCacheEntry",
                 "%#x [%q]",
                 lpAddrInfo,
                 lpAddrInfo->ai_canonname
                 ));

    if (DnsCachingEnabled) {
        LockSerializedList(&ResolverCache);

        LPRESOLVER_CACHE_ENTRY cacheEntry;

        cacheEntry = (LPRESOLVER_CACHE_ENTRY)HeadOfSerializedList(&ResolverCache);
        while (cacheEntry != (LPRESOLVER_CACHE_ENTRY)SlSelf(&ResolverCache)) {
            if (AddrInfoMatch(cacheEntry->AddrInfo, lpAddrInfo->ai_canonname, NULL)) {

                //
                // if the entry is unused then we can delete it, else we have
                // to leave it to the thread with the last reference
                //

                if (cacheEntry->State == ENTRY_UNUSED) {
                    RemoveCacheEntry(cacheEntry);
                } else {
                    cacheEntry->State = ENTRY_DELETE;
                }
                break;
            }
        }

        UnlockSerializedList(&ResolverCache);
    } else {

        DEBUG_PRINT(SOCKETS,
                    WARNING,
                    ("DNS caching disabled\n"
                    ));

    }

    DEBUG_LEAVE(0);
}


PRIVATE
VOID
RemoveCacheEntry(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry
    )

/*++

Routine Description:

    Takes a cache entry off the list and frees it

    N.B.: This function must be called with the resolver cache serialized list
    already locked

Arguments:

    lpCacheEntry    - currently queued entry to remove

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "RemoveCacheEntry",
                 "%#x",
                 lpCacheEntry
                 ));

    RemoveFromSerializedList(&ResolverCache, &lpCacheEntry->ListEntry);

    INET_ASSERT(lpCacheEntry->ReferenceCount == 0);
    INET_ASSERT((lpCacheEntry->State == ENTRY_UNUSED)
                || (lpCacheEntry->State == ENTRY_DELETE));

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("throwing out %q, expiry = %s\n",
                CacheAddrInfoStr(lpCacheEntry->AddrInfo),
                CacheTimestr(lpCacheEntry->ExpirationTime)
                ));

    _I_freeaddrinfo(lpCacheEntry->AddrInfo);
    lpCacheEntry = (LPRESOLVER_CACHE_ENTRY)FREE_MEMORY((HLOCAL)lpCacheEntry);

    INET_ASSERT(lpCacheEntry == NULL);

    --CurrentDnsCacheEntries;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("CurrentDnsCacheEntries = %d\n",
                CurrentDnsCacheEntries
                ));

    INET_ASSERT((CurrentDnsCacheEntries >= 0) 
                && (CurrentDnsCacheEntries <= MaximumDnsCacheEntries));

    DEBUG_LEAVE(0);
}


PRIVATE
BOOL
ResolverCacheHit(
    IN LPRESOLVER_CACHE_ENTRY lpCacheEntry,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    )

/*++

Routine Description:

    Checks this RESOLVER_CACHE_ENTRY for a match with Name or Address. If Name,
    can match with ai_canonname in addrinfo, or with originally resolved name

Arguments:

    lpCacheEntry    - pointer to RESOLVER_CACHE_ENTRY to check

    Name            - optional name to check

    Address         - optional server address to check

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ResolverCacheHit",
                 "%#x, %q, %s",
                 lpCacheEntry,
                 Name,
                 CacheMapSockAddress(Address)
                 ));

    BOOL found;

    if ((Name != NULL)
    && (lpCacheEntry->HostName != NULL)
    && (lstrcmpi(lpCacheEntry->HostName, Name) == 0)) {

        DEBUG_PRINT(SOCKETS,
        INFO,
        ("matched name %q\n",
        lpCacheEntry->HostName
        ));

        found = TRUE;
    } else {
       found = FALSE;
       Name = NULL;
    }    
    
    if (!found && Address) {
        found = AddrInfoMatch(lpCacheEntry->AddrInfo, Name, Address);
    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
BOOL
AddrInfoMatch(
    IN LPADDRINFO AddrInfo,
    IN LPSTR Name OPTIONAL,
    IN LPSOCKADDR Address OPTIONAL
    )

/*++

Routine Description:

    Compares a getaddrinfo result for a match with a host name or address

Arguments:

    AddrInfo - pointer to addrinfo chain to compare

    Name     - pointer to name string

    Address  - pointer to IP address (as a sockaddr)

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "AddrInfoMatch",
                 "%#x, %q, %s",
                 AddrInfo,
                 Name,
                 CacheMapSockAddress(Address)
                 ));

    BOOL found = FALSE;

    if (Name) {
        if ((AddrInfo->ai_canonname != NULL) &&
        (lstrcmpi(AddrInfo->ai_canonname, Name) == 0))
            found = TRUE;
    } else {

        INET_ASSERT(Address != NULL);

        do {
            if ((AddrInfo->ai_addr->sa_family == Address->sa_family)
            && (memcmp(AddrInfo->ai_addr, Address, AddrInfo->ai_addrlen) == 0)) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("matched %s\n",
                            CacheMapSockAddress(Address)
                            ));

                found = TRUE;
                break;
            }

        } while (AddrInfo = AddrInfo->ai_next);
    }

    if (found) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("addrinfo = %q\n",
                    CacheAddrInfoStr(AddrInfo)
                    ));

    }

    DEBUG_LEAVE(found);

    return found;
}


PRIVATE
LPRESOLVER_CACHE_ENTRY
CreateCacheEntry(
    IN LPSTR lpszHostName,
    IN LPADDRINFO AddrInfo,
    IN DWORD TimeToLive
    )

/*++

Routine Description:

    Allocates a RESOLVER_CACHE_ENTRY and packs it with the addrinfo information
    and sets the ExpirationTime

Arguments:

    lpszHostName    - name we resolved

    AddrInfo        - pointer to addrinfo chain to store in new entry

    TimeToLive      - amount of time before this entry expires

Return Value:

    LPRESOLVER_CACHE_ENTRY

--*/

{
    LPRESOLVER_CACHE_ENTRY cacheEntry;

    INET_ASSERT(lpszHostName != NULL);

    //
    // only copy lpszHostName if it is different from the name in addrinfo
    //

    UINT hostNameSize;

    if ((AddrInfo->ai_canonname != NULL)
    && lstrcmpi(AddrInfo->ai_canonname, lpszHostName) != 0) 
    {
        hostNameSize = lstrlen(lpszHostName) + 1;
    }
    else if (AddrInfo->ai_canonname == NULL)
    {
        // if ap_canonname is null, we have to save the lpszHoatName
        hostNameSize = lstrlen(lpszHostName) + 1;
    }
    else 
    {
        hostNameSize = 0;
    }

    //
    // allocate space for the cache entry
    //

    cacheEntry = (LPRESOLVER_CACHE_ENTRY)ALLOCATE_MEMORY(LMEM_FIXED,
                                                         sizeof(RESOLVER_CACHE_ENTRY)
                                                         + hostNameSize
                                                         );
    if (cacheEntry != NULL) {

        //
        // cache the getaddrinfo result
        //

        cacheEntry->AddrInfo = AddrInfo;

        //
        // copy the host name to the end of the buffer if required
        //

        if (hostNameSize != 0) {
            cacheEntry->HostName = (LPSTR)(cacheEntry + 1);
            RtlCopyMemory(cacheEntry->HostName, lpszHostName, hostNameSize);
        } else {
            cacheEntry->HostName = NULL;
        }

        //
        // calculate the expiration time as the current time (in seconds since
        // 1/1/70) + number of seconds to live OR indefinite if TimeToLive is
        // specified as LIVE_FOREVER, which is what we use if the host
        // information didn't originate from DNS
        //

        cacheEntry->ExpirationTime = (DWORD)((TimeToLive == LIVE_FOREVER)
                                        ? LIVE_FOREVER
                                        : time(NULL)
                                            + ((TimeToLive == LIVE_DEFAULT)
                                                ? DnsCacheTimeout
                                                : TimeToLive) );

        //
        // the entry state is initially unused
        //

        cacheEntry->State = ENTRY_UNUSED;

        //
        // and reference is zero
        //

        cacheEntry->ReferenceCount = 0;
    }

    return cacheEntry;
}

#if INET_DEBUG

//
// CAVEAT - can only call these functions once per printf() etc. because of
//          static buffers (but still thread-safe)
//

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheTimestr(IN DWORD Time) {

    //
    // previous code - writes formatted human-sensible date/time to buffer
    //

    //LPSTR p;
    //
    ////
    //// remove the LF from the time string returned by ctime()
    ////
    //
    //p = ctime((const time_t *)&Time);
    //p[strlen(p) - 1] = '\0';
    //return p;

    //
    // abbreviated CRT version - just write # seconds since 1970 to buffer
    //

    static char buf[16];

    wsprintf(buf, "%d", Time);
    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheAddrInfoStr(IN LPADDRINFO AddrInfo) {

    static char buf[2048];
    LPSTR p;
    int Count;

    p = buf;

    for (Count = 1; AddrInfo != NULL; AddrInfo = AddrInfo->ai_next) {
        p += wsprintf(p, "AddrInfo #%u:\n", Count++);
        p += wsprintf(p, "ai_flags = %u\n", AddrInfo->ai_flags);
        p += wsprintf(p, "ai_family = %u\n", AddrInfo->ai_family);
        p += wsprintf(p, "ai_socktype = %u\n", AddrInfo->ai_socktype);
        p += wsprintf(p, "ai_protocol = %u\n", AddrInfo->ai_protocol);
        p += wsprintf(p, "ai_addrlen = %u\n", AddrInfo->ai_addrlen);
        p += wsprintf(p, "ai_canonname = %s\n", AddrInfo->ai_canonname ? AddrInfo->ai_canonname : "NULL");
        p += wsprintf(p, "ai_addr:\n%s\n", CacheMapSockAddress(AddrInfo->ai_addr));
    }

    return (LPSTR)buf;
}

PRIVATE
DEBUG_FUNCTION
LPSTR
CacheMapSockAddress(IN LPSOCKADDR Address) {

    if (!Address) {
        return "<null>";
    }

    static char buf[1024];
    LPSTR p;

    p = buf;
    if (Address->sa_family == AF_INET) {
        struct sockaddr_in *sin;

        sin = (struct sockaddr_in *)Address;
        p += wsprintf(p, "sin_family = %u\n", sin->sin_family);
        p += wsprintf(p, "sin_port = %u\n", _I_ntohs(sin->sin_port));
        p += wsprintf(p, "sin_addr = %s\n", _I_inet_ntoa(sin->sin_addr));

    } else if (Address->sa_family == AF_INET6) {
        struct sockaddr_in6 *sin6;

        sin6 = (struct sockaddr_in6 *)Address;
        p += wsprintf(p, "sin6_family = %u\n", sin6->sin6_family);
        p += wsprintf(p, "sin6_port = %u\n", _I_ntohs(sin6->sin6_port));
        p += wsprintf(p, "sin6_flowinfo = %u\n", sin6->sin6_flowinfo);
        p += wsprintf(p, "sin6_scope_id = %u\n", sin6->sin6_scope_id);
        p += wsprintf(p, "sin6_addr = %2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x:%2x%2x\n",
             sin6->sin6_addr.u.Byte[0],
             sin6->sin6_addr.u.Byte[1],
             sin6->sin6_addr.u.Byte[2],
             sin6->sin6_addr.u.Byte[3],
             sin6->sin6_addr.u.Byte[4],
             sin6->sin6_addr.u.Byte[5],
             sin6->sin6_addr.u.Byte[6],
             sin6->sin6_addr.u.Byte[7],
             sin6->sin6_addr.u.Byte[8],
             sin6->sin6_addr.u.Byte[9],
             sin6->sin6_addr.u.Byte[10],
             sin6->sin6_addr.u.Byte[11],
             sin6->sin6_addr.u.Byte[12],
             sin6->sin6_addr.u.Byte[13],
             sin6->sin6_addr.u.Byte[14],
             sin6->sin6_addr.u.Byte[15]);

    } else {
        p += wsprintf(p, "sa_family = %u\n", Address->sa_family);
    }

    return (LPSTR)buf;
}

#endif

#if defined(RNR_SUPPORTED)

/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    rescache.c

Abstract:

    Contains name resolution cache

    Contents:

Author:

    Shishir Pardikar    2-14-96

Environment:

    Win32 user mode

Revision History:

        2-14-96 shishirp
        Created

--*/

//
//BUGBUG: This include should be removed, duplicate of above
//
#ifndef SPX_SUPPORT
#include <wininetp.h>
#endif


//
// private manifests
//

#define NAMERES_CACHE_USED            0x00000001
#define NAMERES_CACHE_USES_GUID       0x00000002

#define ENTERCRIT_NAMERESCACHE()  EnterCriticalSection(&vcritNameresCache)
#define LEAVECRIT_NAMERESCACHE()  LeaveCriticalSection(&vcritNameresCache)
#define IS_EMPTY(indx)            ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USED) == 0)
#define USES_GUID(indx)           ((vlpNameresCache[(indx)].dwFlags & NAMERES_CACHE_USES_GUID))

// number of cache entries
#define DEFAULT_NAMERES_CACHE_ENTRIES   10

// expiry time for an addresslist
#define DEFAULT_EXPIRY_DELTA            (24 * 60 * 60 * (LONGLONG)10000000)


//
//  structure definition
//

typedef struct tagNAMERES_CACHE {
    DWORD               dwFlags;       // general flags to be used as needed
    DWORD               dwNameSpace;   // namespace ??
    GUID                sGuid;         // GUID describing service type
    LPSTR               lpszName;      // ptr to name that needs resolution
    FILETIME            ftLastUsedTime;    // last accesstime, mainly for purging
    FILETIME            ftCreationTime;// When it was created
    ADDRESS_INFO_LIST   sAddrList;     // List of address (defined in ixport.h)
} NAMERES_CACHE, far *LPNAMERES_CACHE;





//
// private variables for name resolution cache
//


// Name cache size allocated in init
LPNAMERES_CACHE vlpNameresCache = NULL;

// Number of elements allowed in the nameres cache
int vcntNameresCacheEntries = DEFAULT_NAMERES_CACHE_ENTRIES;


// time in 100ns after which an address is expired
LONGLONG vftExpiryDelta = DEFAULT_EXPIRY_DELTA;

BOOL vfNameresCacheInited = FALSE;

// serialization
CRITICAL_SECTION vcritNameresCache;

//
// private function prototypes
//


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    INT     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
);


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
);


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
);


PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
);

PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
);


PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
);

//
// functions
//


DWORD
InitNameresCache(
    VOID
)
/*++

Routine Description:

    Init name resolution cache. This routine a) allocates a table of
    name cache entries b)

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.

--*/
{


    if (vfNameresCacheInited) {
        return (ERROR_SUCCESS);
    }

    // first try to alloc the memory, if it fails just quit
    vlpNameresCache = (LPNAMERES_CACHE)ALLOCATE_MEMORY(
                        LPTR,
                        vcntNameresCacheEntries * sizeof(NAMERES_CACHE)
                        );

    if (!vlpNameresCache) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    InitializeCriticalSection(&vcritNameresCache);

    ENTERCRIT_NAMERESCACHE();

    vfNameresCacheInited = TRUE;

    LEAVECRIT_NAMERESCACHE();

    return (ERROR_SUCCESS);

}


DWORD
AddNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    int      cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_SUCCESS;

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTERCRIT_NAMERESCACHE();

    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);

    // if indx is valid, delete the entry, do some purging too
    if (indx != -1) {
        DeleteNameresCacheEntry(indx);
        PurgeEntries(FALSE);
    }
    else {
        // create atleast one hole
        indx = PurgeEntries(TRUE);
    }

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    dwError = CreateNameresCacheEntry(indx,
                            dwNameSpace,
                            lpGuid,
                            lpName,
                            cntAddresses,
                            lpCsaddrInfo);

    LEAVECRIT_NAMERESCACHE();

    return (dwError);
}




DWORD
RemoveNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {

        ENTERCRIT_NAMERESCACHE();

        indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpszName);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND; //yuk
        }

        LEAVECRIT_NAMERESCACHE();
    }
    return (dwError);
}


#ifdef MAYBE

DWORD
RemoveNameresCacheEntryByAddr(
    int cntAddresses,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD dwError = ERROR_INVALID_PARAMETER;

    if (vfNameresCacheInited) {
        ENTERCRIT_NAMERESCACHE();

        indx = FindNameresCacheEntryByAddr(cntAddresses, lpCsaddrInfo);

        if (indx != -1) {

            DeleteNameresCacheEntry(indx);

            dwError = ERROR_SUCCESS;
        }
        else {
            dwError = ERROR_FILE_NOT_FOUND;
        }

        LEAVECRIT_NAMERESCACHE();
    }
    return (dwError);

}
#endif //MAYBE

DWORD
GetNameresCacheEntry(
    DWORD    dwNameSpace,
    LPGUID   lpGuid,
    LPSTR    lpName,
    INT      *lpcntAddresses,
    LPCSADDR_INFO  *lplpCsaddrInfo
)
/*++

Routine Description:

    This routine looks up the cache and returns the list of addresses
    corresponding to lpGuid/lpName.

Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int indx;
    DWORD   dwError = ERROR_FILE_NOT_FOUND; // poor error

    if (!vfNameresCacheInited) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTERCRIT_NAMERESCACHE();

    // is this entry already cached?
    indx = FindNameresCacheEntry(dwNameSpace, lpGuid, lpName);


    if (indx != -1) {
        // yes, let use give back the info

        *lpcntAddresses = vlpNameresCache[indx].sAddrList.AddressCount;

        if ((dwError = CopyCsaddr(vlpNameresCache[indx].sAddrList.Addresses, *lpcntAddresses, lplpCsaddrInfo))
            != ERROR_SUCCESS) {

            goto bailout;
        }
        // update the last used time, we will use this to
        // age out the entries

        GetCurrentGmtTime(&(vlpNameresCache[indx].ftLastUsedTime));
        dwError = ERROR_SUCCESS;
    }

bailout:

    LEAVECRIT_NAMERESCACHE();

    return (dwError);
}


DWORD
DeinitNameresCache(
    VOID
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    if (vfNameresCacheInited) {
        ENTERCRIT_NAMERESCACHE();

        for (i = 0; i < vcntNameresCacheEntries; ++i) {
            if (!IS_EMPTY(i)) {
                DeleteNameresCacheEntry(i);
            }
        }

        FREE_MEMORY(vlpNameresCache);

        vlpNameresCache = NULL;

        vfNameresCacheInited = FALSE;

        LEAVECRIT_NAMERESCACHE();
        DeleteCriticalSection(&vcritNameresCache);
    }
    return (ERROR_SUCCESS);
}


PRIVATE
DWORD
CreateNameresCacheEntry(
    int     indx,
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName,
    int     cntAddresses,
    LPCSADDR_INFO  lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    DWORD dwError = ERROR_NOT_ENOUGH_MEMORY;

    INET_ASSERT((indx >=0 && (indx < vcntNameresCacheEntries)));

    INET_ASSERT(IS_EMPTY(indx));


    memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));

    // we could get a name or a guid
    // do it for name first before doing it for GUID

    // BUGBUG in future we should consider name+GUID+port
    if (lpszName) {
       vlpNameresCache[indx].lpszName = (LPSTR)ALLOCATE_MEMORY(LPTR, lstrlen(lpszName)+1);
       if (!vlpNameresCache[indx].lpszName) {
           goto bailout;
       }
       strcpy(vlpNameresCache[indx].lpszName, lpszName);
    }
    else if (lpGuid) {
        INET_ASSERT(FALSE); // rigth now. In future this should go away
        memcpy(&(vlpNameresCache[indx].sGuid), lpGuid, sizeof(GUID));
        vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USES_GUID;
    }
    else {
        dwError = ERROR_INVALID_PARAMETER;
        goto bailout;
    }

    INET_ASSERT(cntAddresses > 0);

    if (CopyCsaddr(lpCsaddrInfo, cntAddresses, &(vlpNameresCache[indx].sAddrList.Addresses))
        != ERROR_SUCCESS) {
        goto bailout;
    }

    vlpNameresCache[indx].sAddrList.AddressCount = cntAddresses;

    // mark this as being non-empty
    vlpNameresCache[indx].dwFlags |= NAMERES_CACHE_USED;

    // set the creation and last-used times as now

    GetCurrentGmtTime(&(vlpNameresCache[indx].ftCreationTime));
    vlpNameresCache[indx].ftLastUsedTime = vlpNameresCache[indx].ftCreationTime ;

    dwError = ERROR_SUCCESS;

bailout:

    if (dwError != ERROR_SUCCESS) {
        if (vlpNameresCache[indx].sAddrList.Addresses) {
            FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);
            vlpNameresCache[indx].sAddrList.Addresses = NULL;
        }
        if (vlpNameresCache[indx].lpszName) {
            FREE_MEMORY(vlpNameresCache[indx].lpszName);
            vlpNameresCache[indx].lpszName = NULL;
        }
        memset(&vlpNameresCache[indx], 0, sizeof(vlpNameresCache[indx]));
    }

    return (dwError);
}


PRIVATE
DWORD
DeleteNameresCacheEntry(
    int indx
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    INET_ASSERT((indx >=0) && (indx < vcntNameresCacheEntries));

    if (vlpNameresCache[indx].lpszName) {
        FREE_MEMORY(vlpNameresCache[indx].lpszName);
    }

    INET_ASSERT(vlpNameresCache[indx].sAddrList.Addresses);

    FREE_MEMORY(vlpNameresCache[indx].sAddrList.Addresses);

    memset(&vlpNameresCache[indx], 0, sizeof(NAMERES_CACHE));

    return (ERROR_SUCCESS);
}

#ifdef MAYBE

PRIVATE
int
FindNameresCacheEntryByAddr(
    int cntAddr,
    LPCSADDR_INFO lpCsaddrInfo
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i) && // not empty
            (vlpNameresCache[i].sAddrList.AddressCount == cntAddr) && // count is the same
            (!memcmp(vlpNameresCache[i].sAddrList.Addresses,    // list matches
                     lpCsaddrInfo,
                     cntAddr * sizeof(CSADDR_INFO)))) {
            return (i);
        }
    }
    return (-1);
}
#endif //MAYBE


PRIVATE
int
FindNameresCacheEntry(
    DWORD   dwNameSpace,
    LPGUID  lpGuid,
    LPSTR   lpszName
)
/*++

Routine Description:


Arguments:


Return Value:

    ERROR_SUCCESS if successful.

--*/
{
    int i;

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {
            if (vlpNameresCache[i].dwNameSpace == dwNameSpace) {
                if (!USES_GUID(i)) {

                    INET_ASSERT(vlpNameresCache[i].lpszName);

                    if (lpszName &&
                        !lstrcmpi(lpszName, vlpNameresCache[i].lpszName)) {
                        return (i);
                    }
                }
                else{

                    if (lpGuid && !memcmp(lpGuid, &vlpNameresCache[i].sGuid, sizeof(GUID))) {
                        return (i);
                    }
                }
            }
        }
    }
    return (-1);
}


PRIVATE
int
PurgeEntries(
    BOOL    fForce  // purge atleast one entry
)
/*++

Routine Description:


Arguments:


Return Value:

    index of a free entry

--*/
{
    int i, indxlru = -1, indxHole=-1;
    FILETIME ft;
    BOOL fFoundHole = FALSE;

    GetCurrentGmtTime(&ft);

    for (i = 0; i < vcntNameresCacheEntries; ++i) {
        if (!IS_EMPTY(i)) {

            // purge stale entries
            if ( (FT2LL(ft) - FT2LL(vlpNameresCache[i].ftCreationTime))
                    > FT2LL(vftExpiryDelta)) {
                DeleteNameresCacheEntry(i);
                indxHole = i;
            }
            else if (FT2LL(vlpNameresCache[i].ftLastUsedTime) <= FT2LL(ft)) {
                ft = vlpNameresCache[i].ftLastUsedTime;
                indxlru = i; // LRU entry if we need to purge it
            }
        }
        else {
            indxHole = i;
        }
    }

    // if there is no hole, purge the LRU entry if forced
    if (indxHole == -1) {

        INET_ASSERT(indxlru != -1);

        if (fForce) {
            DeleteNameresCacheEntry(indxlru);
            indxHole = indxlru;
        }
    }
    return (indxHole);
}

PRIVATE
DWORD
CopyCsaddr(
    LPCSADDR_INFO   lpSrc,
    int             cntAddr,
    LPCSADDR_INFO   *lplpDst
)
{
    int i;
    LPCSADDR_INFO lpDst;
    UINT uSize;


    // BUGBUG assumes the way Compressaddress (ixport.cxx) allocates memory
    uSize = LocalSize(lpSrc);
    if (!uSize) {
        return (GetLastError());
    }

    *lplpDst = (LPCSADDR_INFO)ALLOCATE_MEMORY(LPTR, uSize);

    if (!*lplpDst) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    lpDst = *lplpDst;


    memcpy(lpDst, lpSrc, uSize);

    // now start doing fixups
    for (i=0; i<cntAddr; ++i) {
        lpDst[i].LocalAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].LocalAddr.lpSockaddr) - (DWORD)lpSrc));
        lpDst[i].RemoteAddr.lpSockaddr = (LPSOCKADDR)((LPBYTE)lpDst+((DWORD)(lpSrc[i].RemoteAddr.lpSockaddr) - (DWORD)lpSrc));
    }
    return (ERROR_SUCCESS);
}

#endif // defined(RNR_SUPPORTED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains functions to allocate and deallocate handle values for various
    Windows Internet Extensions DLL 'objects'

    Functions in this module generate pseudo-handle values and free them when
    no longer required. Each handle value is generated from its position within
    a (2K) bitmap (== 16K handles max.). We also maintain an array that is used
    to map the generated handle to the address of the handle object that it
    represents

    Contents:
        HandleInitialize
        HandleTerminate
        AllocateHandle
        FreeHandle
        MapHandleToAddress
        DereferenceObject
        (BitToIndex)

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    11-Jan-1996 rfirth
        Use fixed memory instead of moveable (Win95 has a bug w/ LocalUnlock)

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>

//
// manifests
//

#define BASE_HANDLE_VALUE       0x00cc0000
#define HANDLE_INCREMENT        4
#define BITS_PER_BYTE           8
#define BITS_IN_DWORD           (sizeof(DWORD) * BITS_PER_BYTE)
#define FULL_DWORD              ((DWORD)-1)
#define MAXIMUM_HANDLE_NUMBER   (64 K)
#define MAXIMUM_HANDLE_COUNT    ((MAXIMUM_HANDLE_NUMBER / HANDLE_INCREMENT) - 1)
#define MAXIMUM_DWORD_INDEX     ((MAXIMUM_HANDLE_COUNT + BITS_IN_DWORD - 1) / BITS_IN_DWORD)
#define MINIMUM_HANDLE_VALUE    (BASE_HANDLE_VALUE + HANDLE_INCREMENT)
#define MAXIMUM_HANDLE_VALUE    (BASE_HANDLE_VALUE + MAXIMUM_HANDLE_NUMBER - HANDLE_INCREMENT)
#define INITIAL_MAP_LENGTH      16  // 512 handles == 2048 bytes
#define HANDLE_MAP_INCREMENT    16

// Warning: In order for 64-bit compatibility, the range of handle
// values must be restricted to quantities representable by 32-bits.
// If maximum handle value >= 4GB the implementation has to change 
// use 64-bit integral types internally.

//
// macros
//

#define NEXT_HANDLE_VALUE(d, i) (BASE_HANDLE_VALUE + ((d) * BITS_IN_DWORD + ((i) + 1)) * HANDLE_INCREMENT)

//
// private prototypes
//

PRIVATE
inline
DWORD
BitToIndex(
    IN DWORD Bit
    );

//
// private data
//

PRIVATE CRITICAL_SECTION HandleMapCritSec;  // protects access to following variables
PRIVATE LPDWORD HandleMap = NULL;           // bitmap of allocated handles
PRIVATE DWORD HandleMapLength;              // number of DWORDs in HandleMap
PRIVATE DWORD NextHandleMapDword = 0;       // first bitmap DWORD to check
PRIVATE DWORD NextHandleMapBit = 1;         // map of first bit to check
PRIVATE DWORD NextHandleMapBitIndex = 0;    // position of first bit in first DWORD
PRIVATE DWORD NextHandleValue = MINIMUM_HANDLE_VALUE;
PRIVATE DWORD NextHandleIndex = 0;
PRIVATE BOOL Initialized = FALSE;
PRIVATE LPVOID * MapArray = NULL;
PRIVATE DWORD MapArrayLength = 0;

//
// functions
//

DWORD
HandleInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization required by functions in this module

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - return code from LocalAlloc

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "HandleInitialize",
                NULL
                ));

    InitializeCriticalSection(&HandleMapCritSec);
    HandleMapLength = INITIAL_MAP_LENGTH;

    DWORD error;

    //
    // ResizeBuffer() doesn't use LMEM_ZEROINIT
    //

    HandleMap = (LPDWORD)ALLOCATE_MEMORY(LMEM_ZEROINIT,
                                         HandleMapLength * sizeof(DWORD)
                                         );
    if (HandleMap != NULL) {
        MapArrayLength = INITIAL_MAP_LENGTH * BITS_IN_DWORD;
        MapArray = (LPVOID *)ALLOCATE_MEMORY(LMEM_ZEROINIT,
                                             MapArrayLength * sizeof(LPVOID)
                                             );
        if (MapArray != NULL) {
            Initialized = TRUE;
            error = ERROR_SUCCESS;
        }
    }

    if (!HandleMap || !MapArray) {
        error = GetLastError();
        HandleTerminate();
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
HandleTerminate(
    VOID
    )

/*++

Routine Description:

    Obverse of HandleInitialize - frees any system resources allocated by
    HandleInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                None,
                "HandleTerminate",
                NULL
                ));

    if (Initialized) {

        //
        // there shouldn't be any other threads active when this function is
        // called but we'll grab the critical section anyway, just to make sure
        //

        EnterCriticalSection(&HandleMapCritSec);

        //
        // free up the memory occupied by the handle bitmap and map array
        //

        if (HandleMap != NULL) {
            HandleMap = (LPDWORD)FREE_MEMORY((HLOCAL)HandleMap);
        }

        INET_ASSERT(HandleMap == NULL);

        if (MapArray != NULL) {
            MapArray = (LPVOID *)FREE_MEMORY((HLOCAL)MapArray);
        }

        INET_ASSERT(MapArray == NULL);

        //
        // no longer initialized
        //

        Initialized = FALSE;

        //
        // and reset the variables
        //

        HandleMapLength = 0;
        NextHandleMapDword = 0;
        NextHandleMapBit = 1;
        NextHandleMapBitIndex = 0;
        NextHandleValue = MINIMUM_HANDLE_VALUE;
        NextHandleIndex = 0;
        MapArrayLength = 0;

        LeaveCriticalSection(&HandleMapCritSec);

        //
        // delete the critical section
        //

        DeleteCriticalSection(&HandleMapCritSec);
    }

    DEBUG_LEAVE(0);
}


DWORD
AllocateHandle(
    IN LPVOID Address,
    OUT LPHINTERNET lpHandle
    )

/*++

Routine Description:

    Generic handle allocator function which generates a unique handle value for
    any object. The handle value is simply a number, slightly massaged to give a
    value that can be easily differentiated from other Win32 handle ranges (for
    debugging purposes mainly, and also to protect against illegal use of
    handles (such as treating as a pointer and dereferencing it)).

    The range of handles are kept in a bitmap, composed of DWORDs. The next
    allocated handle is simply the index of the next free bit in the map. The
    map is extended if we run out of handles (up to 16K-1 handles (== 2K bytes)).

    If the map needs to be extended we don't go to the trouble to reduce it
    again. For the sake of 2K bytes max (currently), its not worth the effort.

    This function does not rely on knowing the type of object for which the
    handle is being generated, and only requires serialization via a critical
    section.

    This function can increase the values of these variables:

        NextHandleMapDword
        NextHandleMapBit
        NextHandleMapBitIndex
        NextHandleValue
        NextHandleIndex

Arguments:

    Address     - the (object address) value which will be associated with the
                  returned handle

    lpHandle    - place to return the allocated handle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_OUT_OF_HANDLES
                    16K-1 (currently) handles are outstanding!

                  ERROR_NOT_ENOUGH_MEMORY etc.
                    problems with Win32 memory/heap management?

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "AllocateHandle",
                "%#x, %#x",
                Address,
                lpHandle
                ));

    DWORD error;

    //
    // can't associate a NULL address with the generated handle
    //

    INET_ASSERT(Address != NULL);

    //
    // default returned handle
    //

    *lpHandle = NULL;

    //
    // in case this function is being called before we have initialized this
    // module, or after we have terminated it, return an error
    //

    if (!Initialized) {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    error = ERROR_INTERNET_OUT_OF_HANDLES;

    EnterCriticalSection(&HandleMapCritSec);

    if (HandleMap == NULL) {

        //
        // don't ever expect this?
        //

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto unlock_exit;
    }

    while (NextHandleMapDword != MAXIMUM_DWORD_INDEX) {

        //
        // if we reached the end of the map the last time, we must reallocate
        //

        if (NextHandleMapDword == HandleMapLength) {

            HLOCAL newHandleMap;

            newHandleMap = REALLOCATE_MEMORY((HLOCAL)HandleMap,
                                             (HandleMapLength + HANDLE_MAP_INCREMENT)
                                             * sizeof(DWORD),
                                             LMEM_MOVEABLE | LMEM_ZEROINIT
                                             );

            HLOCAL newMapArray;

            newMapArray = REALLOCATE_MEMORY((HLOCAL)MapArray,
                                            (HandleMapLength + HANDLE_MAP_INCREMENT)
                                            * BITS_IN_DWORD
                                            * sizeof(LPVOID),
                                            LMEM_MOVEABLE | LMEM_ZEROINIT
                                            );
            if ((newHandleMap != NULL) && (newMapArray != NULL)) {
                HandleMapLength += HANDLE_MAP_INCREMENT;
                HandleMap = (LPDWORD)newHandleMap;
                MapArrayLength += HANDLE_MAP_INCREMENT * BITS_IN_DWORD;
                MapArray = (LPVOID *)newMapArray;

                DEBUG_PRINT(HANDLE,
                            INFO,
                            ("re-allocated %d DWORDs: HandleMap = %#x MapArray = %#x\n",
                            HandleMapLength,
                            HandleMap,
                            MapArray
                            ));

            } else {

                error = GetLastError();

                DEBUG_PRINT(HANDLE,
                            ERROR,
                            ("REALLOCATE_MEMORY() returns %d\n",
                            error
                            ));

                break;
            }
        } else if (NextHandleValue <= MAXIMUM_HANDLE_VALUE) {
            HandleMap[NextHandleMapDword] |= NextHandleMapBit;

            //
            // first handle value returned is 0x00cc0004
            //

            DEBUG_PRINT(HANDLE,
                        INFO,
                        ("handle = %#x, index = %d\n",
                        NextHandleValue,
                        NextHandleIndex
                        ));

            *lpHandle = (HINTERNET)(DWORD_PTR)NextHandleValue;

            //
            // store it in the map array at the specified index
            //

            INET_ASSERT(MapArray[NextHandleIndex] == NULL);

            MapArray[NextHandleIndex] = Address;

            error = ERROR_SUCCESS;

            //
            // find the next available bit for the next caller. Search up
            // to the end of the currently allocated map. If we don't find
            // it, the next caller will attempt to allocate a new DWORD
            // (unless a lower handle gets freed meantime)
            //

            while (NextHandleMapDword < HandleMapLength) {
                if (HandleMap[NextHandleMapDword] != FULL_DWORD) {
                    while (HandleMap[NextHandleMapDword] & NextHandleMapBit) {
                        NextHandleMapBit <<= 1;
                        ++NextHandleMapBitIndex;
                        NextHandleValue += HANDLE_INCREMENT;
                        ++NextHandleIndex;
                    }
                } else {
                    NextHandleMapBit = 0;
                }
                if (NextHandleMapBit != 0) {
                    break;
                } else {

                    //
                    // reached the end of a DWORD. Start the next
                    //

                    ++NextHandleMapDword;
                    NextHandleMapBit = 1;
                    NextHandleMapBitIndex = 0;

                    //
                    // recalculate the next handle value
                    //

                    NextHandleValue = NEXT_HANDLE_VALUE(NextHandleMapDword,
                                                        NextHandleMapBitIndex
                                                        );

                    //
                    // and map array index
                    //

                    NextHandleIndex = NextHandleMapDword * BITS_IN_DWORD;
                }
            }
            break;
        } else {

            //
            // reached maximum handle value - return error
            //

            break;
        }
    }

unlock_exit:

    LeaveCriticalSection(&HandleMapCritSec);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
FreeHandle(
    IN HINTERNET Handle
    )

/*++

Routine Description:

    The obverse function to AllocateHandle. Frees up a previously allocated
    handle value. If this handle has a lower index than the currently selected
    next index (Dword and Bit) then the next index is modified

    This function can reduce the values of these variables:

        NextHandleMapDword
        NextHandleMapBit
        NextHandleMapBitIndex
        NextHandleValue
        NextHandleIndex

Arguments:

    Handle  - handle value previously allocated via AllocateHandle

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    We don't think this handle was generated by AllocateHandle
                    or the corresponding bit in the map is already 0

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "FreeHandle",
                "%#x",
                Handle
                ));

    DWORD error;

    //
    // ensure that we are in the correct state
    //

    if (!Initialized) {
        error = ERROR_INTERNET_SHUTDOWN;
        goto quit;
    }

    error = ERROR_INVALID_HANDLE;

    //
    // error if 0x00cc0000 > Handle > 0x00ccfffc
    //

    if ((PtrToUlong(Handle) < MINIMUM_HANDLE_VALUE)
     || (PtrToUlong(Handle) > MAXIMUM_HANDLE_VALUE)) {
        goto quit;
    }

    //
    // get the map DWORD index and bit mask from the handle
    //
    DWORD index;

    index = (PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / (BITS_IN_DWORD * HANDLE_INCREMENT);

    DWORD bit;

    bit = 1 << (((PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / HANDLE_INCREMENT) & (BITS_IN_DWORD - 1));

    DWORD mapIndex;

    mapIndex = (PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / HANDLE_INCREMENT;

    EnterCriticalSection(&HandleMapCritSec);

    //
    // the index may be in range, but greater than the currently allocated
    // map length, in which case its an error
    //

    if (index < HandleMapLength) {
        if (HandleMap != NULL) {
            if (HandleMap[index] & bit) {

                BOOL recalc = FALSE;

                DEBUG_PRINT(HANDLE,
                            INFO,
                            ("handle = %#x, index = %d, address = %#x\n",
                            Handle,
                            mapIndex,
                            MapArray[mapIndex]
                            ));

                HandleMap[index] &= ~bit;
                MapArray[mapIndex] = NULL;

                error = ERROR_SUCCESS;

                //
                // if we have cleared a bit lower in the bitmap than the current
                // index and bit indicators, then reset the indicators to the
                // new position
                //

                if (index < NextHandleMapDword) {

                    //
                    // new DWORD is lower than current: change all variables
                    // to those for this handle
                    //

                    NextHandleMapDword = index;
                    recalc = TRUE;
                } else if ((index == NextHandleMapDword) && (bit < NextHandleMapBit)) {

                    //
                    // same DWORD index, lower bit position
                    //

                    recalc = TRUE;
                }
                if (recalc) {
                    NextHandleMapBit = bit;
                    NextHandleMapBitIndex = BitToIndex(bit);

                    //
                    // recalculate the next handle value
                    //

                    NextHandleValue = NEXT_HANDLE_VALUE(NextHandleMapDword,
                                                        NextHandleMapBitIndex
                                                        );

                    //
                    // and map array index
                    //

                    NextHandleIndex = (NextHandleMapDword * BITS_IN_DWORD)
                                    + NextHandleMapBitIndex;
                }
            } else {

                DEBUG_PRINT(HANDLE,
                            ERROR,
                            ("Handle = %#x. HandleMap[%d].%#x not set\n",
                            Handle,
                            index,
                            bit
                            ));
            }
        } else {

            //
            // don't ever expect this to happen
            //

            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

        }
    } else {

        DEBUG_PRINT(HANDLE,
                    ERROR,
                    ("Handle = %#x, index = %d, HandleMapLength = %d\n",
                    Handle,
                    index,
                    HandleMapLength
                    ));

    }

    LeaveCriticalSection(&HandleMapCritSec);

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
MapHandleToAddress(
    IN HINTERNET Handle,
    OUT LPVOID * lpAddress,
    IN BOOL Invalidate
    )

/*++

Routine Description:

    Given a handle, retrieve its associated address from the map array. The
    handle object represented by Handle is referenced

    Assumes:    1. only HINTERNETs visible at the API are presented to this
                   function. Even though we AllocateHandle() for arbitrary
                   objects (e.g. gopher views) we never map their addresses

Arguments:

    Handle      - handle value generated by AllocateHandle()

    lpAddress   - place to store mapped address. If the handle has been closed
                  and unmapped, NULL is returned. If the handle is still
                  mapped, even though it has been invalidated, its address will
                  be returned, and its reference count incremented

    Invalidate  - TRUE if we are invalidating this handle

Return Value:

    LPVOID
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE
                    if *lpAddress == NULL then the handle has been closed and
                    unmapped, else it is still mapped, but invalidated. In
                    this case, we incremented the reference count

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "MapHandleToAddress",
                "%#x, %#x, %B",
                Handle,
                lpAddress,
                Invalidate
                ));

    LPVOID address = NULL;
    DWORD error = ERROR_INVALID_HANDLE;

    //
    // error if 0x00cc0000 > Handle > 0x00ccfffc
    //

    if ((PtrToUlong(Handle) >= MINIMUM_HANDLE_VALUE)
    &&  (PtrToUlong(Handle) <= MAXIMUM_HANDLE_VALUE)
    && !InDllCleanup) {

        DWORD index = (PtrToUlong(Handle) - MINIMUM_HANDLE_VALUE) / HANDLE_INCREMENT;

        //
        // the caller could have supplied a value which has the correct range
        // but may not yet have been generated, causing us to index past the
        // end of the array
        //

        if (index < MapArrayLength) {

            //
            // we have to acquire the critical section in case another thread
            // is reallocating the array
            //

            EnterCriticalSection(&HandleMapCritSec);

            address = MapArray[index];

            DEBUG_PRINT(HANDLE,
                        INFO,
                        ("Handle %#x mapped to address %#x\n",
                        Handle,
                        address
                        ));

            if (address != NULL) {

                //
                // although we store addresses of arbitrary structures (e.g.
                // FTP_SESSION_INFO), we are only calling this function to map
                // pseudo-handles to object addresses at the API. Therefore it
                // should be safe to assume that the pointer references a handle
                // object
                // However, there's nothing to stop an app passing in a random
                // handle value that just happens to map to an FTP or gopher
                // session or gopher view, and since we don't want to treat that
                // as a handle object, we must make this test full-time
                //

                if (((HANDLE_OBJECT *)address)->IsValid(TypeWildHandle) == ERROR_SUCCESS) {

                    //
                    // this is also a very good time to increment the reference
                    // count. We are using the fact that we are serialized on the
                    // handle map critical section here. If Reference() returns
                    // ERROR_INVALID_HANDLE then the handle object has been
                    // invalidated, but its reference count will have been
                    // incremented. The caller should perform as little work as
                    // necessary and get out.
                    //
                    // If Refrerence() returns ERROR_ACCESS_DENIED, then the object
                    // is being destroyed (refcount already went to zero).
                    //
                    // If the reference count is incremented to 1 then there is
                    // another thread waiting to finish deleting this handle. It
                    // is virtually deleted, and if we return its address, the
                    // caller will have a deleted object
                    //

                    if (((HANDLE_OBJECT *)address)->ReferenceCount() == 0) {

                        DEBUG_PRINT(HANDLE,
                                    ERROR,
                                    ("handle %#x [%#x] about to be deleted\n",
                                    Handle,
                                    address
                                    ));

                        address = NULL;
                    } else {
                        error = ((HANDLE_OBJECT *)address)->Reference();
                        if (error == ERROR_SUCCESS) {
                            if (Invalidate) {

                                //
                                // we were called from a handle close API.
                                // Subsequent API calls will discover that the
                                // handle is already invalidated and will quit
                                //

                                ((HANDLE_OBJECT *)address)->Invalidate();
                            }
                        } else if (error == ERROR_ACCESS_DENIED) {
                            //
                            // if we get ERROR_ACCESS_DENIED, this means that the object is 
                            // being destructed, so we *have* to return NULL.
                            //
                            DEBUG_PRINT(HANDLE,
                                        ERROR,
                                        ("Reference() failed - handle %#x [%#x] about to be deleted\n",
                                        Handle,
                                        address
                                        ));
                            address = NULL;
                        } else {
                            DEBUG_PRINT(HANDLE,
                                        ERROR,
                                        ("Reference() returns %d\n",
                                        error
                                        ));

                            //
                            // if invalid and reference count already zero, we
                            // didn't increment ref count: handle already being
                            // deleted
                            //

                            if (((HANDLE_OBJECT *)address)->ReferenceCount() == 0) {
                                address = NULL;
                            }
                        }
                    }
                } else {

                    //
                    // we still want to know about it in debug version
                    //

                    DEBUG_PRINT(HANDLE,
                                ERROR,
                                ("invalid handle object: %#x [%#x]\n",
                                Handle,
                                address
                                ));

                    IF_DEBUG(INVALID_HANDLES) {
                        //INET_ASSERT(FALSE);
                    }
                }
            } else {

                //
                // lets also catch this one (NULL address)
                //

                DEBUG_PRINT(HANDLE,
                            ERROR,
                            ("NULL handle: %#x\n",
                            Handle
                            ));

                IF_DEBUG(INVALID_HANDLES) {
                    //INET_ASSERT(FALSE);
                }
            }
            LeaveCriticalSection(&HandleMapCritSec);
        }
    } else if (InDllCleanup) {
        error = ERROR_INTERNET_SHUTDOWN;
    } else {

        DEBUG_PRINT(HANDLE,
                    ERROR,
                    ("bad handle value: %#x\n",
                    Handle
                    ));

        IF_DEBUG(INVALID_HANDLES) {
            //INET_ASSERT(FALSE);
        }
    }

    *lpAddress = address;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
DereferenceObject(
    IN LPVOID lpObject
    )

/*++

Routine Description:

    Undoes the reference added to the handle object by MapHandleToAddress(). May
    result in the handle object being deleted

Arguments:

    lpObject    - address of object to dereference. This MUST be the mapped
                  object address as returned by MapHandleToAddress()

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    The handle object was destroyed

        Failure - ERROR_INVALID_HANDLE
                    The object was not a valid handle

                  ERROR_INTERNET_HANDLE_EXISTS
                    The handle is still alive

--*/

{
    DEBUG_ENTER((DBG_HANDLE,
                Dword,
                "DereferenceObject",
                "%#x",
                lpObject
                ));

    INET_ASSERT(lpObject != NULL);

    HANDLE_OBJECT * object = (HANDLE_OBJECT *)lpObject;
    DWORD error = object->IsValid(TypeWildHandle);

    if (error == ERROR_SUCCESS) {
        if (!object->Dereference()) {
            error = ERROR_INTERNET_HANDLE_EXISTS;
        }
    } else {

        //
        // IsValid() should never return an error if the reference counts
        // are correct
        //

        INET_ASSERT(FALSE);

    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
inline
DWORD
BitToIndex(
    IN DWORD Bit
    )

/*++

Routine Description:

    Returns the index of the first bit set in a DWORD

Arguments:

    Bit - bitmap

Return Value:

    DWORD   - 0..(BITS_IN_DWORD - 1) if bit found, else BITS_IN_DWORD

--*/

{
    if (Bit == 0) {
        return BITS_IN_DWORD;
    } else {

        DWORD index;
        DWORD testBit;

        for (index = 0, testBit = 1; !(Bit & testBit); ++index, testBit <<= 1) {
            ;
        }
        return index;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\icsocket.cxx ===
/*++


Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    icsocket.cxx

Abstract:

    Contains sockets functions and ICSocket methods

    Contents:
        ContainingICSocket
        MapNetAddressToName
        ICSocket::ICSocket
        ICSocket::~ICSocket
        ICSocket::Destroy
        ICSocket::Reference
        ICSocket::Dereference
        ICSocket::EnableSocks
        ICSocket::Connect
        CFsm_SocketConnect::RunSM
        ICSocket::Connect_Start
        ICSocket::Connect_Continue
        ICSocket::Connect_Error
        ICSocket::Connect_Finish
        ICSocket::SocksConnect
        ICSocket::Disconnect
        ICSocket::Close
        ICSocket::Abort
        ICSocket::Shutdown
        ICSocket::IsReset
        ICSocket::SetTimeout
        ICSocket::SetLinger
        ICSocket::SetNonBlockingMode
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID)
        ICSocket::GetBufferLength(SOCKET_BUFFER_ID, LPDWORD)
        ICSocket::SetBufferLength
        ICSocket::SetSendCoalescing
        SetSourcePort
        ICSocket::Send
        CFsm_SocketSend::RunSM
        ICSocket::Send_Start
        ICSocket::SendTo
        ICSocket::Receive
        CFsm_SocketReceive::RunSM
        ICSocket::Receive_Start
        ICSocket::Receive_Continue
        ICSocket::AllocateQueryBuffer
        //ICSocket::FreeQueryBuffer
        //ICSocket::ReceiveFrom
        ICSocket::DataAvailable
        //ICSocket::DataAvailable2
        ICSocket::WaitForReceive
        //ICSocket::GetBytesAvailable
        ICSocket::CreateSocket
        ICSocket::GetSockName
        ICSocket::GetPeerName
        ICSocket::Listen
        ICSocket::DirectConnect
        ICSocket::SelectAccept

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "autodial.h"

//
// private prototypes
//

//
// functions
//

#if INET_DEBUG

PRIVATE LPSTR MapFamily(int family) {
    switch (family) {
    case AF_UNSPEC:     return "AF_UNSPEC";
    case AF_UNIX:       return "AF_UNIX";
    case AF_INET:       return "AF_INET";
    case AF_IMPLINK:    return "AF_IMPLINK";
    case AF_PUP:        return "AF_PUP";
    case AF_CHAOS:      return "AF_CHAOS";
    case AF_IPX:        return "AF_IPX";
    case AF_OSI:        return "AF_OSI";
    case AF_ECMA:       return "AF_ECMA";
    case AF_DATAKIT:    return "AF_DATAKIT";
    case AF_CCITT:      return "AF_CCITT";
    case AF_SNA:        return "AF_SNA";
    case AF_DECnet:     return "AF_DECnet";
    case AF_DLI:        return "AF_DLI";
    case AF_LAT:        return "AF_LAT";
    case AF_HYLINK:     return "AF_HYLINK";
    case AF_APPLETALK:  return "AF_APPLETALK";
    case AF_NETBIOS:    return "AF_NETBIOS";
#if defined(AF_VOICEVIEW)
    case AF_VOICEVIEW:  return "AF_VOICEVIEW";
#endif /* AF_VOICEVIEW */
#if defined(AF_FIREFOX)
    case AF_FIREFOX:    return "AF_FIREFOX";
#endif /* AF_FIREFOX */
#if defined(AF_UNKNOWN1)
    case AF_UNKNOWN1:   return "AF_UNKNOWN1";
#endif /* AF_UNKNOWN1 */
#if defined(AF_BAN)
    case AF_BAN:        return "AF_BAN";
#endif /* AF_BAN */
#if defined(AF_INET6)
    case AF_INET6:      return "AF_INET6";
#endif /* AF_INET6 */
    }
    return "?";
}

PRIVATE LPSTR MapSock(int sock) {
    switch (sock) {
    case SOCK_STREAM:       return "SOCK_STREAM";
    case SOCK_DGRAM:        return "SOCK_DGRAM";
    case SOCK_RAW:          return "SOCK_RAW";
    case SOCK_RDM:          return "SOCK_RDM";
    case SOCK_SEQPACKET:    return "SOCK_SEQPACKET";
    }
    return "?";
}

PRIVATE LPSTR MapProto(int proto) {
    switch (proto) {
    case IPPROTO_IP:    return "IPPROTO_IP";
    case IPPROTO_ICMP:  return "IPPROTO_ICMP";
    case IPPROTO_IGMP:  return "IPPROTO_IGMP";
    case IPPROTO_GGP:   return "IPPROTO_GGP";
    case IPPROTO_TCP:   return "IPPROTO_TCP";
    case IPPROTO_PUP:   return "IPPROTO_PUP";
    case IPPROTO_UDP:   return "IPPROTO_UDP";
    case IPPROTO_IDP:   return "IPPROTO_IDP";
    case IPPROTO_ND:    return "IPPROTO_ND";
    }
    return "?";
}

#endif // INET_DEBUG



ICSocket *
ContainingICSocket(
    LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of start of ICSocket (i.e. vtable) given address of list

Arguments:

    lpAddress   - address of m_List part of ICSocket

Return Value:

    ICSocket *  - address of start of ICSocket object (also ICSecureSocket)

--*/

{
    return CONTAINING_RECORD(lpAddress, ICSocket, m_List);
}

//
// ICSocket methods
//


ICSocket::ICSocket(
    VOID
    )

/*++

Routine Description:

    ICSocket constructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::ICSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_ICSOCKET();

    m_List.Flink = NULL;
    m_List.Blink = NULL;
    m_dwTimeout = 0;
    m_fTimeoutWraps = 0;
    m_Socket = INVALID_SOCKET;
    m_dwFlags = 0;
    m_bAborted = FALSE;
    m_SocksAddress = 0;
    m_SocksPort = 0;
    m_ReferenceCount = 1;
    m_fExemptConnLImit = FALSE;

    DEBUG_LEAVE(0);
}


ICSocket::~ICSocket()

/*++

Routine Description:

    ICSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::~ICSocket",
                 "{%#x [sock=%#x, port=%d, ref=%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 ReferenceCount()
                 ));

    CHECK_ICSOCKET();

    INET_ASSERT(!IsOnList());
    INET_ASSERT(m_ReferenceCount == 0);

    if (IsOpen()) {
        Close();
    }

    DEBUG_LEAVE(0);
}


VOID
ICSocket::Destroy(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSocket::Destroy",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    INET_ASSERT(ReferenceCount() == 1);

    m_ReferenceCount = 0;
    delete this;

    DEBUG_LEAVE(0);
}


VOID
ICSocket::Reference(
    VOID
    )

/*++

Routine Description:

    Just increases the reference count

Arguments:

    None.

Return Value:

    None.

--*/

{
    CHECK_ICSOCKET();

    InterlockedIncrement(&m_ReferenceCount);
}


BOOL
ICSocket::Dereference(
    VOID
    )

/*++

Routine Description:

    Reduces the reference count. If it goes to zero, the object is deleted

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - object deleted

        FALSE   - object still alive

--*/

{
    CHECK_ICSOCKET();

    if (InterlockedDecrement(&m_ReferenceCount) == 0) {

        INET_ASSERT(m_ReferenceCount == 0);

        delete this;
        return TRUE;
    }
    return FALSE;
}


PRIVATE
DWORD
ICSocket::EnableSocks(
    IN LPSTR lpSocksHost,
    IN INTERNET_PORT ipSocksPort
    )

/*++

Routine Description:

    Set SOCKS gateway IP address and port in this socket object

Arguments:

    lpSocksHost - IP address or host name of SOCKS host

    ipSocksPort - port address of SOCKS host

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_NAME_NOT_RESOLVED
                    failed to resolve SOCKS host name

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::EnableSocks",
                 "{%#x/%d} %q, %d",
                 GetSocket(),
                 GetSourcePort(),
                 lpSocksHost,
                 ipSocksPort
                 ));

    DWORD error = ERROR_SUCCESS;

    m_SocksPort = ipSocksPort;
    m_SocksAddress = _I_inet_addr(lpSocksHost);
    if (m_SocksAddress == INADDR_NONE) {    // 0xffffffff

        LPHOSTENT lpHostent = _I_gethostbyname(lpSocksHost);

        if (lpHostent != NULL) {
            m_SocksAddress = **(LPDWORD*)&lpHostent->h_addr_list[0];
        } else {
            m_SocksAddress = 0;
            error = ERROR_INTERNET_NAME_NOT_RESOLVED;
        }
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("SOCKS address = %d.%d.%d.%d:%d\n",
                ((BYTE*)&m_SocksAddress)[0] & 0xff,
                ((BYTE*)&m_SocksAddress)[1] & 0xff,
                ((BYTE*)&m_SocksAddress)[2] & 0xff,
                ((BYTE*)&m_SocksAddress)[3] & 0xff,
                m_SocksPort
                ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SocketConnect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags,
    IN CServerInfo *pServerInfo
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

    pServerInfo - Server Info to connect with

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SocketConnect",
                 "{%#x [%#x]} %d, %d, %#x, %x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags,
                 pServerInfo
                 ));


    DWORD error;

    CFsm_SocketConnect * pFsm;

    pFsm = new CFsm_SocketConnect(Timeout, Retries, dwFlags, this);

    if ( pFsm )
    {
        pFsm->SetServerInfo(pServerInfo);
    }

    error = DoFsm(pFsm);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
ICSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

#ifdef TEST_CODE
    Timeout *= 20;
    Retries *= 20;
#endif

    DWORD error;

    error = DoFsm(new CFsm_SocketConnect(Timeout, Retries, dwFlags, this));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketConnect::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketConnect state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketConnect * stateMachine = (CFsm_SocketConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Connect_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
        error = pSocket->Connect_Continue(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = pSocket->Connect_Error(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Start(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Starts a socket connect operation - creates a socket and connects it to a
    server using the address information returned by GetServiceAddress(). There
    may be several addresses to try. We return as soon as we successfully
    generate a connection, or after we have tried <Retries> attempts, or until
    <Timeout> milliseconds have elapsed

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Start",
                 "{%#x [%#x]}, %#x(%d, %d, %#x)",
                 this,
                 m_Socket,
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Start);

    CFsm_SocketConnect & fsm = *Fsm;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();

    INET_ASSERT(lpThreadInfo != NULL);

    DWORD error = ERROR_SUCCESS;
    int serr = SOCKET_ERROR;

    INET_ASSERT(IsClosed());

    //
    // ensure the next state is CONTINUE. It may be INIT because we could have
    // been looping through bad addresses (if sufficient timeout & retries)
    //

    if(Fsm->GetState() == FSM_STATE_INIT)
    {
        fsm.SetErrorState(error);
    }

    fsm.SetNextState(FSM_STATE_CONTINUE);

    //
    // if we are offline then quit now - we can't make any network requests
    //
    InternetAutodialIfNotLocalHost(NULL, fsm.m_pServerInfo->GetHostName());
    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    //
    // get address to use. If exhausted, re-resolve
    //


    if (fsm.GetFunctionState() == FSM_STATE_2) {
        fsm.SetFunctionState(FSM_STATE_1);
        goto resolve_continue;
    }
    if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                           &fsm.m_dwAddressIndex,
                                           GetPort(),
                                           fsm.m_pAddress
                                           )) {
        if (fsm.m_bResolved) {
            error = ERROR_INTERNET_CANNOT_CONNECT;
        } else {
            fsm.SetFunctionState(FSM_STATE_2);
            fsm.SetNextState(FSM_STATE_INIT);
            error = fsm.m_pServerInfo->ResolveHost(&fsm.m_dwResolutionId,
                                                   fsm.m_dwFlags
                                                   );
            if (error == ERROR_IO_PENDING) {
                goto quit;
            }

resolve_continue:

            fsm.m_bResolved = TRUE;
            if (error == ERROR_SUCCESS) {
                if (!fsm.m_pServerInfo->GetNextAddress(&fsm.m_dwResolutionId,
                                                       &fsm.m_dwAddressIndex,
                                                       GetPort(),
                                                       fsm.m_pAddress
                                                       )) {
                    error = ERROR_INTERNET_CANNOT_CONNECT;
                }
            }
            else if (error == ERROR_INTERNET_NAME_NOT_RESOLVED)
            {
                fsm.SetNextState(FSM_STATE_CONTINUE);
                goto quit; // exit out NOW with ERROR_INTERNET_NAME_NOT_RESOLVED, instead of CANNOT_CONNECT
            }
        }
    }
    if (error != ERROR_SUCCESS) {

        //
        // name resolution failed - done
        //

        goto quit;
    }

    //
    // Update port for keep-alive info.
    //
    // The port number field is in the same location in both a
    // sockaddr_in and a sockaddr_in6, so it is safe to cast the
    // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
    //
    INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) == offsetof(SOCKADDR_IN6, sin6_port));
    SetPort(_I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port));

    //
    // BUGBUG - this code was supplying AF_UNSPEC to socket(), which should
    //          be okay, but because of a bug in the Win95 wsipx driver
    //          which manifests itself when we call bind(), we must send in
    //          the address family supplied in the local socket address by
    //          GetAddressByName()
    //

    int protocol;
    DWORD dwConnFlags;

    protocol = fsm.m_pAddress->iProtocol;

#if defined(SITARA)

    //
    // Only enable Sitara if we're connected via modem
    //

//dprintf("connect_start: IsSitara = %B, IsModemConn=%B\n",GlobalEnableSitara, GlobalHasSitaraModemConn);

    if (GlobalEnableSitara && GlobalHasSitaraModemConn) {
        protocol = (int)GetSitaraProtocol();
    }

#endif // SITARA

    m_Socket = _I_socket(fsm.m_pAddress->LocalAddr.lpSockaddr->sa_family,
                         fsm.m_pAddress->iSocketType,
                         protocol
                         );
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto check_socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    //
    // inform the app that we are connecting to the server (but only on the
    // first attempt)
    //

    //if ((fsm.m_dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatusAddress(INTERNET_STATUS_CONNECTING_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
    }

    //
    // if requested to, put the socket in non-blocking mode
    //

    if (fsm.m_dwFlags & SF_NON_BLOCKING
    && (GlobalRunningNovellClient32 ? GlobalNonBlockingClient32 : TRUE)) {
        error = SetNonBlockingMode(TRUE);
        if (error != ERROR_SUCCESS) {
            fsm.SetErrorState(error);
            goto quit;
        }
    }

    //
    // bind the socket to the local address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("binding to local address %d.%d.%d.%d, port %d, index %d\n",
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->LocalAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->LocalAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    serr = _I_bind(m_Socket,
                   fsm.m_pAddress->LocalAddr.lpSockaddr,
                   fsm.m_pAddress->LocalAddr.iSockaddrLength
                   );
    if (serr == SOCKET_ERROR) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to bind socket %#x\n",
                    m_Socket
                    ));

        goto check_socket_error;
    }

    //
    // record source port (useful for matching with net sniff)
    //

    SetSourcePort();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("socket %#x bound to port %d (%#x)\n",
                m_Socket,
                m_SourcePort,
                m_SourcePort
                ));

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->SetAbortHandle(this);
    }

    //
    // try to connect to the next address
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting %#x/%d to remote address %d.%d.%d.%d, port %d, index %d\n",
                m_Socket,
                m_SourcePort,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[4] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[5] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[6] & 0xff,
                ((LPBYTE)fsm.m_pAddress->RemoteAddr.lpSockaddr)[7] & 0xff,
                _I_ntohs(((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr)->sin_port),
                fsm.m_dwAddressIndex
                ));

    fsm.SetNextState(FSM_STATE_CONTINUE);
    fsm.StartTimer();

#ifdef TEST_CODE
    SetLastError(-1);
    serr = -1;
#else
    if (IsSocks()) {
        serr = SocksConnect((LPSOCKADDR_IN)fsm.m_pAddress->RemoteAddr.lpSockaddr,
                            fsm.m_pAddress->RemoteAddr.iSockaddrLength
                            );
    } else {
        serr = _I_connect(m_Socket,
                          fsm.m_pAddress->RemoteAddr.lpSockaddr,
                          fsm.m_pAddress->RemoteAddr.iSockaddrLength
                          );
    }
#endif

    //
    // here if a socket operation failed, in which case serr will be SOCKET_ERROR
    //

check_socket_error:

    if (serr == 0) {

        //
        // successful (probably synchronous) connect completion
        //

        //
        // in the sync case, we just call the continue handler. No need to
        // return to the state handler
        //

        Connect_Continue(Fsm);
        goto quit;
    }

    //
    // here if a socket operation failed. We have to read the socket error in
    // this thread before doing anything else or we'll lose the error. We handle
    // it in Connect_Error()
    //

    error = _I_WSAGetLastError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect(%#x) returns %d\n",
                m_Socket,
                error
                ));

    //
    // if we are using non-blocking sockets then we need to wait until the
    // connect has completed, or an error occurs.
    // If we got any status other than WSAEWOULDBLOCK then we have to handle
    // the error
    //

    if (IsNonBlocking() && (error == WSAEWOULDBLOCK)) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("connect() blocked, socket %#x, port %d\n",
                    m_Socket,
                    m_SourcePort
                    ));

        fsm.SetAction(FSM_ACTION_CONNECT);

        DWORD timeout = GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT);
        INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

        if (pObject != NULL) {
            if (pObject->IsFromCacheTimeoutSet()
            && (pObject->GetObjectType() == TypeHttpRequestHandle)
            && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                timeout = GetTimeoutValue(INTERNET_OPTION_FROM_CACHE_TIMEOUT);

                DWORD connectTime = fsm.m_pServerInfo->GetConnectTime();

                if (connectTime == 0) {
                    connectTime = timeout;
                }
                timeout += connectTime;
            }
        }
        fsm.SetTimeout(timeout);
        fsm.SetNextState(FSM_STATE_CONTINUE);

        //
        // after we set the state to waiting, and get ERROR_IO_PENDING from
        // QueueSocketWorkItem() then we can no longer touch this FSM until
        // it completes asynchronously
        //

        //
        // perf - test the socket. If this completes quickly we don't take a
        // context switch
        //

        //error = WaitForReceive(0);
        //if (error == ERROR_INTERNET_TIMEOUT) {
            error = QueueSocketWorkItem(Fsm, m_Socket);
        //}
        if (error == ERROR_SUCCESS) {

            //
            // in the unlikely event the request completed quickly and
            // successfully
            //

            serr = 0;
            goto check_socket_error;
        } else if (error == ERROR_IO_PENDING) {

            //
            // the request is pending. We already set waiting state
            //

            goto quit;
        }

        //
        // if here then QueueSocketWorkItem() returned some other error
        //

    } else {

        //
        // some other socket error occurred. Convert to INTERNET error
        //

        fsm.SetErrorState(MapInternetError(error));
        error = Connect_Continue(Fsm);
    }

    fsm.SetErrorState(error);

quit:

    //
    // we are done if not pending AND we will not re-enter this state in order
    // to re-do the name resolution/find another address
    //

    if ((error != ERROR_IO_PENDING) && (fsm.GetNextState() != FSM_STATE_INIT)) {
        fsm.SetDone();

        PERF_LEAVE(Connect_Start);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Continue(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Performs common processing after connect completion or failure

Arguments:

    Fsm - reference to socket connect finite state machine

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Continue",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Continue);

    CFsm_SocketConnect & fsm = *Fsm;
    fsm.StopTimer();

//    INET_ASSERT((fsm.GetMappedHandleObject() != NULL)
//        ? (fsm.GetMappedHandleObject()->GetAbortHandle() != NULL)
//        : TRUE);

    DWORD error = fsm.GetError();

    //INET_ASSERT(error != SOCKET_ERROR);

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connect() resumed, socket %#x, port %d\n",
                m_Socket,
                m_SourcePort
                ));

    //
    // check for aborted request
    //

    if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
        error = ERROR_INTERNET_CANNOT_CONNECT;
    }
    if (error == ERROR_SUCCESS) {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x/port %d connected; time = %d mSec\n",
                    m_Socket,
                    m_SourcePort,
                    fsm.ReadTimer()
                    ));

        error = Connect_Finish(Fsm);
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to connect socket %#x/port %d: error %s\n",
                    m_Socket,
                    m_SourcePort,
                    InternetMapError(error)
                    ));

        fsm.SetError(error);
        error = Connect_Error(Fsm);
    }

    PERF_LEAVE(Connect_Continue);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Error(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called to handle a connect error. Either causes the FSM to terminate or
    prepares the FSM to try another connection

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Error",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Error);

    CFsm_SocketConnect & fsm = *Fsm;

    fsm.StopTimer();

    if (fsm.IsInvalid()) 
    {
        fsm.SetDone(ERROR_INTERNET_OPERATION_CANCELLED);
        return ERROR_INTERNET_OPERATION_CANCELLED;
    }


    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(pObject != NULL);

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    DWORD error = fsm.GetError();
    BOOL bRestartable = FALSE;

    //INET_ASSERT(error != SOCKET_ERROR);
    INET_ASSERT(error != ERROR_SUCCESS);

    //
    // check for aborted request - this overrides any socket error
    //

    if (IsAborted() || error == ERROR_INTERNET_OPERATION_CANCELLED) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (fsm.IsCountedOut()
               || fsm.IsTimedOut()  // entire request timeout
               || (error == ERROR_INTERNET_TIMEOUT)) {  // just this request t/o

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("counted out or timed out\n"
                    ));

        //
        // CANNOT_CONNECT takes precedence over TIMEOUT
        //

        if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
            error = ERROR_INTERNET_CANNOT_CONNECT;
        } else if (fsm.IsTimedOut()) {
            error = ERROR_INTERNET_TIMEOUT;
        } else if (fsm.IsCountedOut()) {
            error = ERROR_INTERNET_CANNOT_CONNECT;
        }
    } else if (error != ERROR_INTERNET_OFFLINE) {

        //
        // not aborted, timed-out, counted-out, or offline. We can try again
        //

        bRestartable = TRUE;
    }

    //
    // if the socket is open, close it and try the next connection. Invalidate
    // the address we tried
    //

    if (IsOpen()) {
        Close();
    }

    DWORD mappedError = fsm.GetMappedError();

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped error = %d [%s]\n",
                mappedError,
                InternetMapError(mappedError)
                ));

    //
    // don't invalidate address if from-cache-if-net-fail timeout
    //

    BOOL bInvalidate = TRUE;

    if ((pObject != NULL) && pObject->IsFromCacheTimeoutSet()) {
        bInvalidate = FALSE;
    }
    if ((mappedError == WSAENETUNREACH)
        || (mappedError == WSAETIMEDOUT)
        || ((error == ERROR_INTERNET_TIMEOUT) && bInvalidate)
        || (error == ERROR_INTERNET_CANNOT_CONNECT)
#ifdef TEST_CODE
        || (error == (DWORD)-1)
#endif
        ) {
        fsm.m_pServerInfo->InvalidateAddress(fsm.m_dwResolutionId,
                                             fsm.m_dwAddressIndex
                                             );
    }

    //
    // if the operation was cancelled or we lost connectivity then quit
    //

    if (bRestartable) {
        fsm.SetNextState(FSM_STATE_INIT);
    } else {
        fsm.SetDone(error);

        PERF_LEAVE(Connect_Error);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Connect_Finish(
    IN CFsm_SocketConnect * Fsm
    )

/*++

Routine Description:

    Called when the connection has been successfully established

Arguments:

    Fsm - socket connect FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Connect_Finish",
                 "{%#x [%#x/%d]}, %#x(%d, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_Timeout,
                 Fsm->m_Retries,
                 Fsm->m_dwFlags
                 ));

    PERF_ENTER(Connect_Finish);

    CFsm_SocketConnect & fsm = *Fsm;

    INET_ASSERT(IsOpen());

    //
    // store the average connect time to this server in our CServerInfo
    //

    if (fsm.m_pServerInfo != NULL) {
        fsm.m_pServerInfo->UpdateConnectTime(fsm.ReadTimer());
    }
    if (fsm.m_pOriginServer != NULL) {
        fsm.m_pOriginServer->UpdateConnectTime(fsm.ReadTimer());
    }

#ifdef TEST_CODE
    BOOL optval;
    int optlen = sizeof(optval);
    int serr = _I_getsockopt(GetSocket(),
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (char FAR *)&optval,
                             &optlen
                             );

    if (serr != 0) {
        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("getsockopt(TCP_NODELAY) returns %s (%d)\n",
                    InternetMapError(_I_WSAGetLastError()),
                    _I_WSAGetLastError()
                    ));
    }
#endif

    //
    // no longer performing socket operation - clear abort handle
    //

    INET_ASSERT(fsm.GetMappedHandleObject() != NULL);

    if (fsm.GetMappedHandleObject() != NULL) {
        fsm.GetMappedHandleObject()->ResetAbortHandle();
    }

    //
    // set the send & receive buffer sizes if not -1 (meaning don't change)
    //

    DWORD bufferLength;

    bufferLength = GetBufferLength(ReceiveBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(ReceiveBuffer, bufferLength);
    }
    bufferLength = GetBufferLength(SendBuffer);
    if (bufferLength != (DWORD)-1) {
        SetBufferLength(SendBuffer, bufferLength);
    }

    //
    // disable send coalescing
    //

    SetSendCoalescing(FALSE);

    //
    // let the app know we connected to the server successfully
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatusAddress(INTERNET_STATUS_CONNECTED_TO_SERVER,
                                      fsm.m_pAddress->RemoteAddr.lpSockaddr,
                                      fsm.m_pAddress->RemoteAddr.iSockaddrLength
                                      );
    }

    fsm.SetDone();

    PERF_LEAVE(Connect_Finish);

    DEBUG_LEAVE(ERROR_SUCCESS);

    return ERROR_SUCCESS;
}


int
ICSocket::SocksConnect(
    IN LPSOCKADDR_IN pSockaddr,
    IN INT nLen
    )

/*++

Routine Description:

    Connect to remote host via SOCKS proxy. Modified from original. If we are
    here then we are going specifically via a known SOCKS proxy. There is now
    only one Hosts object, containing a single SOCKD socks proxy address and
    user name

    N.B. Irrespective of whether we are non-blocking, this function executes
    in blocking mode (we expect that we are on an intranet and complete quickly)

Arguments:

    pSockaddr   - address of remote host (on other side of SOCKS firewall)

    nLen        - length of *pSockaddr

Return Value:

    int
        Success - 0

        Failure - -1

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::SocksConnect",
                 "{%#x} %#x, %d",
                 GetSocket(),
                 pSockaddr,
                 nLen
                 ));

    //
    // BUGBUG - should check if the socket type is SOCK_STREAM or if we have
    //          already connected this socket. This code was part of original
    //          general purpose solution. We don't need it
    //

    //
    // initialize sockaddr for connecting to SOCKS firewall
    //

    struct sockaddr_in sin;

    sin.sin_family = AF_INET;
    sin.sin_port = _I_htons(m_SocksPort);
    sin.sin_addr.s_addr = m_SocksAddress;
    memset(&sin.sin_zero, 0, sizeof(sin.sin_zero));

    //
    // initialize SOCKS request packet
    //

    struct {
        unsigned char VN;
        unsigned char CD;
        unsigned short DSTPORT;
        unsigned long  DSTIP;
        char UserId[255];
    } request;

    request.VN = 4;
    request.CD = 1;
    request.DSTPORT = pSockaddr->sin_port;
    request.DSTIP = pSockaddr->sin_addr.s_addr;

    DWORD length = sizeof(request.UserId);

    GlobalUserName.Get(request.UserId, &length);

    length += 8 + 1; // 8 == sizeof fixed portion of request;
                     // +1 for additional '\0'

    //
    // put socket into blocking mode
    //

    BOOL non_blocking = IsNonBlocking();

    if (non_blocking) {
        SetNonBlockingMode(FALSE);
    }

    //
    // communicate with SOCKS firewall: send SOCKS request & receive response
    //

    int serr = _I_connect(m_Socket, (LPSOCKADDR)&sin, sizeof(sin));

    if (serr != SOCKET_ERROR) {
        serr = _I_send(m_Socket, (char *)&request, length, 0);
        if (serr == (int)length) {

            char response[256];


            serr = _I_recv(m_Socket, (char *)response, sizeof(response), 0);
            if( serr == 1 ) {
                // need to read at least 2 bytes
                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("need to read one more byte\n"));
                serr = _I_recv(  
                    m_Socket, (char *)(&response[1]), sizeof(response) - 1, 0);
            }

            if (serr != SOCKET_ERROR) {
                if (response[1] != 90) {
                    serr = SOCKET_ERROR;
                }

            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("recv(%#x) returns %d\n",
                            m_Socket,
                            _I_WSAGetLastError()
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("send(%#x) returns %d\n",
                        m_Socket,
                        _I_WSAGetLastError()
                        ));

            serr = SOCKET_ERROR;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("connect(%#x) returns %d\n",
                    m_Socket,
                    _I_WSAGetLastError()
                    ));

    }

    //
    // if originally non-blocking, make socket non-blocking again
    //

    if (non_blocking) {
        SetNonBlockingMode(TRUE);
    }

    //
    // if success, mark the socket as being connected through firewall
    //

    if (serr == SOCKET_ERROR) {
        _I_WSASetLastError(WSAECONNREFUSED);
    }

    DEBUG_LEAVE(serr);

    return serr;
}


DWORD
ICSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Disconnect",
                 "{%#x/%d} %#x",
                 GetSocket(),
                 GetSourcePort(),
                 dwFlags
                 ));

    //
    // let the app know we are closing the connection
    //

    if (dwFlags & SF_INDICATE) {
        InternetIndicateStatus(INTERNET_STATUS_CLOSING_CONNECTION, NULL, 0);
    }

    DWORD error = Close();

    if ((error == ERROR_SUCCESS) && (dwFlags & SF_INDICATE)) {

        //
        // let the app know the connection is closed
        //

        InternetIndicateStatus(INTERNET_STATUS_CONNECTION_CLOSED, NULL, 0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Close(
    VOID
    )

/*++

Routine Description:

    Closes a connected socket. Assumes that any linger or shutdown etc.
    requirements have already been applied to the socket

Arguments:

    none.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Close",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {
//dprintf("**** closing %#x\n", m_Socket);

        int serr;

        __try {
            serr = _I_closesocket(m_Socket);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            serr = 0;
        }
        ENDEXCEPT
        error = (serr == SOCKET_ERROR)
            ? MapInternetError(_I_WSAGetLastError())
            : ERROR_SUCCESS;
    }

    //
    // the socket is now closed
    //

    m_Socket = INVALID_SOCKET;

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Abort(
    VOID
    )

/*++

Routine Description:

    Aborts a socket by simply closing it

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Abort",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = Close();

    if (error == ERROR_SUCCESS) {
        SetAborted();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Shutdown(
    IN DWORD dwControl
    )

/*++

Routine Description:

    Stops any more send/receives from the socket

Arguments:

    dwControl   - 0 to stop receives, 1 to stop sends, 2 to stop both

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Shutdown",
                 "{%#x/%d}",
                 GetSocket(),
                 GetSourcePort()
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsOpen()) {

        int serr = _I_shutdown(m_Socket, dwControl);

        if (serr == SOCKET_ERROR) {

            //
            // map any sockets error to WinInet error
            //

            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL
ICSocket::IsReset(
    VOID
    )

/*++

Routine Description:

    Determines if the socket has been closed. We peek the socket for 1 byte. If
    the socket is in blocking mode, we temporarily switch to non-blocking to
    perform the test - we don't want to block, nor remove any data from the
    socket

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - socket reset (closed by server)

        FALSE   - socket alive

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "ICSocket::IsReset",
                 "{%#x [%#x/%d]}",
                 this,
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_ICSOCKET();

    BOOL bReset = FALSE;
    BOOL bSetBlocking = FALSE;

    if (IsOpen()) {
        if (!IsNonBlocking()) {
            SetNonBlockingMode(TRUE);
            bSetBlocking = TRUE;
        }

        char ch;
#ifndef unix
        int n = _I_recv(m_Socket, &ch, 1, MSG_PEEK);
        if (n < 0) {

            DWORD error = _I_WSAGetLastError();

            if (error != WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() returns %s (%d)\n",
                            InternetMapError(error),
                            error
                            ));

                n = 0;
            }
        }
        if (n == 0) {
#else
        DWORD dwAvail = 0;
        int n = _I_ioctlsocket(m_Socket,FIONREAD,&dwAvail);
        if (n != 0) {
#endif /* unix */
            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x/port %d is reset\n",
                        m_Socket,
                        m_SourcePort
                        ));

            bReset = TRUE;
        }
        if (bSetBlocking) {
            SetNonBlockingMode(FALSE);
        }
    } else {
        bReset = TRUE;
    }

    DEBUG_LEAVE(bReset);

    return bReset;
}


DWORD
ICSocket::SetTimeout(
    IN DWORD Type,
    IN int Timeout
    )

/*++

Routine Description:

    Sets a timeout value for a connected socket

Arguments:

    Type            - type of timeout to set - send, or receive

    Timeout         - timeout value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetTimeout",
                 "{%#x/%d} %s (%d), %d",
                 GetSocket(),
                 GetSourcePort(),
                 (Type == SEND_TIMEOUT) ? "SEND_TIMEOUT"
                    : (Type == RECEIVE_TIMEOUT) ? "RECEIVE_TIMEOUT"
                    : "?",
                 Type,
                 Timeout
                 ));

    INET_ASSERT((Type == SEND_TIMEOUT) || (Type == RECEIVE_TIMEOUT));

    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             (Type == SEND_TIMEOUT)
                                ? SO_SNDTIMEO
                                : SO_RCVTIMEO,
                             (const char FAR *)&Timeout,
                             sizeof(Timeout)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetLinger(
    IN BOOL Linger,
    IN int Timeout
    )

/*++

Routine Description:

    Sets the linger option for a connected socket

Arguments:

    Linger  - FALSE if the caller wants immediate shutdown of the socket
              when closed, or TRUE if we are to wait around until
              queued data has been sent

    Timeout - timeout value to use if Linger is TRUE

Return Value:

    DWORD
        Success - ERROR_SUCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetLinger",
                 "{%#x/%d} %B, %d",
                 GetSocket(),
                 GetSourcePort(),
                 Linger,
                 Timeout
                 ));

    DWORD error = ERROR_SUCCESS;

    if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (IsOpen()) {

        LINGER linger;

        INET_ASSERT(Timeout <= USHRT_MAX);

        linger.l_onoff = (u_short)(Linger ? 1 : 0);
        linger.l_linger = (u_short)Timeout;


        //
        // in some shutdown situations, we are hitting exception in winsock
        // on win95 (!). Handle exception
        //

        __try {
            if (_I_setsockopt(m_Socket,
                              SOL_SOCKET,
                              SO_LINGER,
                              (const char FAR *)&linger,
                              sizeof(linger)
                              ) == SOCKET_ERROR) {
                error = MapInternetError(_I_WSAGetLastError());
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {

            //
            // do nothing except catch exception in retail
            //

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("exception closing socket %#x/%d\n",
                        GetSocket(),
                        GetSourcePort()
                        ));

            INET_ASSERT(IsOpen());

        }
        ENDEXCEPT
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetNonBlockingMode(
    IN BOOL bNonBlocking
    )

/*++

Routine Description:

    Sets socket non-blocking/blocking mode

Arguments:

    bNonBlocking    - TRUE if non-blocking, FALSE if blocking

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetNonBlockingMode",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bNonBlocking
                 ));

    u_long on = (bNonBlocking) ? 1 : 0;
    DWORD error = ERROR_SUCCESS;

    if (_I_ioctlsocket(m_Socket, FIONBIO, &on) == 0) {
        if (on) {
            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            m_dwFlags &= ~SF_NON_BLOCKING;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to put socket %#x/port %d into %sblocking mode\n",
                    m_Socket,
                    m_SourcePort,
                    on ? "non-" : ""
                    ));

        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId
    )

/*++

Routine Description:

    Returns the send or receive buffer length for this socket object

Arguments:

    SocketBufferId  - which buffer length to return

Return Value:

    DWORD

--*/

{
    //
    // BUGBUG - RLF 04/29/96
    //
    // This function should access first the current object, then the parent
    // object, then the globals for this data
    //

    HINTERNET hInternet;
    DWORD dwBufferLength = (DWORD)-1;
    DWORD error;
    switch (SocketBufferId) 
    {
    case ReceiveBuffer:

        dwBufferLength = GlobalSocketReceiveBufferLength;
        break;
        
    case SendBuffer:

        hInternet = InternetGetMappedObjectHandle();
        
        if (hInternet != NULL) 
        {
            //
            // ensure the handle is valid
            //
            error = ((HANDLE_OBJECT*)hInternet)->IsValid(TypeHttpRequestHandle);
            if (error == ERROR_SUCCESS) 
            {
                dwBufferLength = ((HTTP_REQUEST_HANDLE_OBJECT*)hInternet)->GetSocketSendBufferLength();
            }
        }
        if (dwBufferLength == (DWORD)-1)
        {
            dwBufferLength =  GlobalSocketSendBufferLength;
        }
        break;
        
    default:
        dwBufferLength = (DWORD)-1;
    }
    
    return dwBufferLength;
}


DWORD
ICSocket::GetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Gets the socket send or receive buffer length (if supported)

Arguments:

    SocketBufferId      - which buffer to set

    lpdwBufferLength    - where to write length

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "ICSocket::GetBufferLength",
                 "{%#x/%d} %s, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : ((SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?")
                 ));

    DWORD size = sizeof(*lpdwBufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (char FAR *)lpdwBufferLength,
                             (int FAR *)&size
                             );

    DWORD error;

    if (serr != SOCKET_ERROR) {
        error = ERROR_SUCCESS;
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetBufferLength(
    IN SOCKET_BUFFER_ID SocketBufferId,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the socket send or receive buffer length

Arguments:

    SocketBufferId  - which buffer to set

    dwBufferLength  - length to set it to

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetBufferLength",
                 "{%#x/%d} %s, %d",
                 GetSocket(),
                 GetSourcePort(),
                 (SocketBufferId == ReceiveBuffer)
                    ? "ReceiveBuffer"
                    : (SocketBufferId == SendBuffer)
                        ? "SendBuffer"
                        : "?",
                 dwBufferLength
                 ));

    INET_ASSERT((int)dwBufferLength >= 0);

    DWORD size = sizeof(dwBufferLength);

    int serr = _I_setsockopt(m_Socket,
                             SOL_SOCKET,
                             SocketBufferId,
                             (const char FAR *)&dwBufferLength,
                             (int)size
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SetSendCoalescing(
    IN BOOL bOnOff
    )

/*++

Routine Description:

    Enables or disables Nagle algorithm

Arguments:

    bOnOff  - FALSE to disable, TRUE to enable

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SetSendCoalescing",
                 "{%#x/%d} %B",
                 GetSocket(),
                 GetSourcePort(),
                 bOnOff
                 ));

    int optval = bOnOff ? 0 : 1;
    int serr = _I_setsockopt(m_Socket,
                             IPPROTO_TCP,
                             TCP_NODELAY,
                             (const char FAR *)&optval,
                             sizeof(optval)
                             );

    DWORD error = ERROR_SUCCESS;

    if (serr == SOCKET_ERROR) {
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else {
            error = MapInternetError(_I_WSAGetLastError());
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
ICSocket::SetSourcePort(
    VOID
    )

/*++

Routine Description:

    Record the port we are connected to locally. Useful for debugging & matching
    up socket with net sniff

Arguments:

    None.

Return Value:

    None.

--*/

{
    sockaddr_storage address;  // Large enough for any address family.
    int namelen = sizeof(address);

    if (_I_getsockname(GetSocket(), (LPSOCKADDR)&address, &namelen) == 0) {
        //
        // The port number field is in the same location in both a
        // sockaddr_in and a sockaddr_in6, so it is safe to cast the
        // sockaddr to sockaddr_in here - this works for IPv4 or IPv6.
        //
        INET_ASSERT(offsetof(SOCKADDR_IN, sin_port) == offsetof(SOCKADDR_IN6, sin6_port));
        m_SourcePort = (INTERNET_PORT)_I_ntohs(((LPSOCKADDR_IN)&address)->sin_port);
    } else {
        m_SourcePort = 0;
    }
}


DWORD
ICSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over connected socket

Arguments:

    lpBuffer        - pointer to buffer containing data to send

    dwBufferLength  - length of lpBuffer in bytes

    dwFlags         - flags controlling send:

                        SF_INDICATE     - make status callbacks to the app when
                                          we are starting to send data and when
                                          we finish

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send",
                 "{%#x [%#x/%d]} %#x, %d, %#x",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);

    DWORD error = DoFsm(new CFsm_SocketSend(lpBuffer,
                                            dwBufferLength,
                                            dwFlags,
                                            this
                                            ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketSend state

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketSend * stateMachine = (CFsm_SocketSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Send_Start(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Send_Start(
    IN CFsm_SocketSend * Fsm
    )

/*++

Routine Description:

    Continues send request - sends the data

Arguments:

    Fsm - socket send FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Send_Start",
                 "{%#x [%#x/%d]} %#x(%#x, %d, %#x)",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lpBuffer,
                 Fsm->m_dwBufferLength,
                 Fsm->m_dwFlags
                 ));

    CFsm_SocketSend & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (fsm.IsInvalid()) 
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

    if (error != ERROR_SUCCESS) {
        if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
            error = ERROR_INTERNET_CONNECTION_RESET;
        }
        goto quit;
    }
    if (state == FSM_STATE_INIT) {
        if (!(m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))) {

            DEBUG_DUMP_API(SOCKETS,
                           "sending data:\n",
                           fsm.m_lpBuffer,
                           fsm.m_dwBufferLength
                           );

        }

        if (pObject != NULL) {
            pObject->SetAbortHandle(this);
        }

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_SENDING_REQUEST, NULL, 0);
        }

        fsm.StartTimer();
    }
    while (fsm.m_dwBufferLength != 0) {

        //
        // if we are offline then quit now - we can't make any network
        // requests
        //

        if (IsOffline()) {
            error = ERROR_INTERNET_OFFLINE;
            break;
        }

        //
        // the socket may have already been aborted
        //

        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
            break;
        }

        if (fsm.m_pServerInfo != NULL) {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        int nSent = _I_send(m_Socket,
                            (char FAR *)fsm.m_lpBuffer,
                            fsm.m_dwBufferLength,
                            0
                            );
        if (nSent != SOCKET_ERROR) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("sent %d bytes @ %#x to socket %#x/port %d\n",
                        nSent,
                        fsm.m_lpBuffer,
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.m_iTotalSent += nSent;
            fsm.m_lpBuffer = (LPBYTE)fsm.m_lpBuffer + nSent;
            fsm.m_dwBufferLength -= nSent;
        } else {

            //
            // check first to see if the error was due to the socket being
            // closed as a result of the request being cancelled
            //

            if (IsAborted()) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
                break;
            } else {
                error = _I_WSAGetLastError();
            }
            if (IsNonBlocking() && (error == WSAEWOULDBLOCK)) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("send() blocked, socket %#x, port %d\n",
                            m_Socket,
                            m_SourcePort
                            ));
//dprintf("!!! send() blocked - socket %#x\n", m_Socket);
                fsm.SetAction(FSM_ACTION_SEND);

                DWORD timeout = GetTimeoutValue(INTERNET_OPTION_SEND_TIMEOUT);

                if (pObject != NULL) {
                    if (pObject->IsFromCacheTimeoutSet()
                    && (pObject->GetObjectType() == TypeHttpRequestHandle)
                    && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                        timeout = GetTimeoutValue(INTERNET_OPTION_FROM_CACHE_TIMEOUT);

                        DWORD RTT = fsm.m_pOriginServer->GetRTT();

                        if (RTT == 0) {
                            RTT = timeout;
                        }
                        timeout += RTT;
                    }
                }
                fsm.SetTimeout(timeout);
                error = QueueSocketWorkItem(Fsm, m_Socket);
                if (error != ERROR_SUCCESS) {
                    break;
                }
            } else {

                //
                // map any sockets error to WinInet error and terminate this
                // request
                //

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("send() returns %d (%s)\n",
                            error,
                            InternetMapError(error)
                            ));

                error = MapInternetError(error);
                break;
            }
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.StopTimer();
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->ResetAbortHandle();
        }
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        } else if (error == ERROR_SUCCESS) {
            if (fsm.m_dwFlags & SF_INDICATE) {
                InternetIndicateStatus(INTERNET_STATUS_REQUEST_SENT,
                                       &fsm.m_iTotalSent,
                                       sizeof(fsm.m_iTotalSent)
                                       );
            }
            if (fsm.m_pServerInfo != NULL) {
                //fsm.m_pServerInfo->UpdateSendTime(fsm.ReadTimer());
            }
        }
        fsm.SetDone(error);
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::SendTo(
//    IN LPSOCKADDR lpDestination,
//    IN DWORD dwDestinationLength,
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesSent,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for sendto()
//
//Arguments:
//
//    lpDestination       - pointer to remote address to send to
//
//    dwDestinationLength - length of *lpDestination
//
//    lpBuffer            - pointer to buffer containing data to send
//
//    dwBufferLength      - number of bytes to send from lpBuffer
//
//    lpdwBytesSent       - number of bytes sent to destination
//
//    dwWinsockFlags      - flags to pass through to sendto()
//
//    dwFlags             - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_INTERNET_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_INTERNET_TIMEOUT
//                    The operation timed out
//
//                  ERROR_INTERNET_CONNECTION_RESET
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::SendTo",
//                 "{%#x} %#x, %d, %#x, %d, %#x, %#x, %#x",
//                 m_Socket,
//                 lpDestination,
//                 dwDestinationLength,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesSent,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesSent != NULL);
//
//    int totalSent = 0;
//    DWORD error = ERROR_SUCCESS;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL fNonBlocking;
//
//    //
//    // if we are offline then quit now - we can't make any network requests
//    //
//
//    if (IsOffline()) {
//        error = ERROR_INTERNET_OFFLINE;
//        goto quit;
//    }
//
//    if (IsAborted()) {
//        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//
//    //
//    // set the cancel socket in the object
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, m_Socket, SEND);
//    }
//
//    if (dwFlags & SF_INDICATE) {
//
//        //
//        // let the app know we are starting to send data
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_SENDING_REQUEST,
//                               NULL,
//                               0
//                               );
//    }
//
//    DEBUG_DUMP(SOCKETS,
//               "sending data:\n",
//               lpBuffer,
//               dwBufferLength
//               );
//
//    int nSent;
//
//    //
//    // loop until all data sent
//    //
//
//    do {
//
//        nSent = _I_sendto(m_Socket,
//                          (char FAR *)lpBuffer + totalSent,
//                          dwBufferLength,
//                          dwWinsockFlags,
//                          lpDestination,
//                          dwDestinationLength
//                          );
//        if (nSent != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("sent %d bytes @ %#x on socket %#x\n",
//                        nSent,
//                        (LPBYTE)lpBuffer + totalSent,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nSent > 0);
//
//            totalSent += nSent;
//            dwBufferLength -= nSent;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) would block\n",
//                            m_Socket
//                            ));
//
//                lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                SwitchToAsyncScheduler(m_Socket);
//
//                error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                DEBUG_PRINT(SOCKETS,
//                            INFO,
//                            ("sendto(%#x) resumed, returns %s\n",
//                            m_Socket,
//                            InternetMapError(error)
//                            ));
//
//                if (error != ERROR_SUCCESS) {
//                    if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
//                        error = ERROR_INTERNET_CONNECTION_RESET;
//                    }
//                }
//            } else {
//
//                //
//                // some other error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//
//        INET_ASSERT((int)dwBufferLength >= 0);
//
//    } while ((dwBufferLength != 0) && (error == ERROR_SUCCESS));
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//
//        //
//        // let the app know we have finished sending
//        //
//
//        InternetIndicateStatus(INTERNET_STATUS_REQUEST_SENT,
//                               &totalSent,
//                               sizeof(totalSent)
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know that we no longer require this socket
//    //
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, SEND);
//    }
//
//quit:
//
//    *lpdwBytesSent = totalSent;
//
//    //
//    // no longer performing operation on this socket
//    //
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_INTERNET_OPERATION_CANCELLED;
//        }
//    }
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::Receive(
    IN OUT LPVOID * lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

    This function returns user data, so if the stream we are receiving from is
    encrypted, we must decrypt the data before returning. This may require
    receiving more data than the user expects because we have to decrypt at
    message boundaries

    This function is intended to be called in a loop. The buffer pointer and
    buffer sizes are intended to be updated by each successive call to this
    function, and should therefore have the same values the next time this
    function is called

Arguments:

    lplpBuffer          - pointer to pointer to users buffer. If supplied, the
                          buffer should be LMEM_FIXED

    lpdwBufferLength    - size of buffer

    lpdwBufferRemaining - number of bytes left in the buffer

    lpdwBytesReceived   - number of bytes received

    dwExtraSpace        - number of additional bytes caller wants at end of
                          buffer (only useful if resizing AND only applied at
                          end of receive)

    dwFlags             - flags controlling receive:

                            SF_EXPAND       - lpBuffer can be expanded to fit
                                              data

                            SF_COMPRESS     - if set, we will shrink the buffer
                                              to compress out any unused space

                            SF_RECEIVE_ALL  - if set, this function will loop
                                              until all data received, or the
                                              supplied buffer is filled

                            SF_INDICATE     - if set, we will make status
                                              callbacks to the app when we are
                                              starting to receive data, and when
                                              we finish

                            SF_WAIT         - (used with SF_NON_BLOCKING). Even
                                              though the socket is non-blocking,
                                              the caller wants us to not
                                              relinquish control under the
                                              request has been satisfied

    lpbEof              - TRUE if we got end-of-connection indication
                          (recv() returns 0)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't allocate/grow buffer

                  ERROR_INSUFFICIENT_BUFFER
                    The initial buffer was insufficient (i.e. caller supplied
                    buffer pointer was NULL, or we ran out of buffer space and
                    are not allowed to resize it)

                  WSA error
                    Sockets error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    INET_ASSERT((int)*lpdwBufferLength >= 0);
    INET_ASSERT((int)*lpdwBufferRemaining >= 0);
    INET_ASSERT((int)*lpdwBytesReceived >= 0);

#define SF_MUTEX_FLAGS  (SF_RECEIVE_ALL | SF_NO_WAIT)

    INET_ASSERT((dwFlags & SF_MUTEX_FLAGS) != SF_MUTEX_FLAGS);

    DWORD error = DoFsm(new CFsm_SocketReceive(lplpBuffer,
                                               lpdwBufferLength,
                                               lpdwBufferRemaining,
                                               lpdwBytesReceived,
                                               dwExtraSpace,
                                               dwFlags,
                                               lpbEof,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SocketReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_SocketReceive state

Arguments:

    Fsm - socket receive FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SocketReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSocket * pSocket = (ICSocket *)Fsm->GetContext();
    CFsm_SocketReceive * stateMachine = (CFsm_SocketReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        error = pSocket->Receive_Start(stateMachine);
        break;

    case FSM_STATE_CONTINUE:
    case FSM_STATE_ERROR:
        error = pSocket->Receive_Continue(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Start(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Initiates a receive request - grows the buffer if required and kicks off the
    first receive operation

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Start",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer, fsm.m_dwBufferLength, FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error == ERROR_SUCCESS) {
        if (fsm.GetMappedHandleObject() != NULL) {
            fsm.GetMappedHandleObject()->SetAbortHandle(this);
        }

        //
        // keep the app informed (if requested to do so)
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE, NULL, 0);
        }

        //
        // kick off the receive request. If we complete synchronously (with
        // an error or successfully), then call the finish handler here
        //

        error = Receive_Continue(Fsm);
    } else {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::Receive_Continue(
    IN CFsm_SocketReceive * Fsm
    )

/*++

Routine Description:

    Receives data from connected socket. Depending on flags settings, we will
    perform a single receive, loop until we have filled the buffer and/or loop
    until we have received all the data.

Arguments:

    Fsm - reference to FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::Receive_Continue",
                 "{%#x [%#x/%d]} %#x(%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B])",
                 this,
                 GetSocket(),
                 GetSourcePort(),
                 Fsm,
                 Fsm->m_lplpBuffer,
                 *Fsm->m_lplpBuffer,
                 Fsm->m_lpdwBufferLength,
                 *Fsm->m_lpdwBufferLength,
                 Fsm->m_lpdwBufferRemaining,
                 *Fsm->m_lpdwBufferRemaining,
                 Fsm->m_lpdwBytesReceived,
                 *Fsm->m_lpdwBytesReceived,
                 Fsm->m_dwExtraSpace,
                 Fsm->m_dwFlags,
                 Fsm->m_lpbEof,
                 *Fsm->m_lpbEof
                 ));

    CFsm_SocketReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    INTERNET_HANDLE_OBJECT * pObject = fsm.GetMappedHandleObject();

    if (fsm.IsInvalid() && fsm.GetState() == FSM_STATE_ERROR) 
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto error_exit;
    }

    if (error != ERROR_SUCCESS) {
        goto error_exit;
    }

    fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;

    //
    // receive some data
    //

    do {
        if (fsm.m_pServerInfo != NULL) {
            fsm.m_pServerInfo->SetLastActiveTime();
        }

        INET_ASSERT((int)fsm.m_dwBufferLeft > 0);

        int nRead = _I_recv(m_Socket,
                            (char FAR *)fsm.m_lpBuffer,
                            (int)fsm.m_dwBufferLeft,
                            0
                            );

        //
        // hackorama # 95, subparagraph 13
        //
        // RLF 07/15/96
        //
        // On Win95 (wouldn't you know it?) in low-memory conditions, we can get
        // into a situation where one or more pages of our receive buffer is
        // filled with zeroes.
        //
        // The reason this happens is that the winsock VxD creates an alias to
        // our buffer, locks the buffer & writes into it, then marks the alias
        // dirty, but not the original buffer. If the buffer is paged out then
        // back in, one or more pages are zeroed because the O/S didn't know
        // they had been written to; it decides to initialize the pages with
        // zeroes.
        //
        // We try to circumvent this by immediately probing each page (we read
        // a byte then write it back).
        //
        // This doesn't fix the problem, just makes the window a lot smaller.
        // However, apart from writing a device driver or modifying the VxD,
        // there's not much else we can do
        //

        ProbeWriteBuffer(fsm.m_lpBuffer, fsm.m_dwBufferLeft);

        if (nRead == 0) {

            //
            // done
            //

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("EOF connection %#x/port %d\n",
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.m_bEof = TRUE;
            break;
        } else if (nRead > 0) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("received %d bytes from socket %#x/port %d\n",
                        nRead,
                        m_Socket,
                        m_SourcePort
                        ));

            fsm.m_dwBytesReceived += nRead;
            fsm.m_dwBytesRead += nRead;
            fsm.m_lpBuffer += nRead;
            fsm.m_dwBufferLeft -= nRead;

            //
            // if SF_RECEIVE_ALL is not set then the caller just wants us to
            // perform a single receive. We're done
            //

            if (!(fsm.m_dwFlags & SF_RECEIVE_ALL) ) {
                break;
            }

            //
            // if we've filled the current buffer, then either we're done, or
            // the caller wants us to receive the entire response, in which
            // case we attempt to grow the buffer and receive the next part
            // of the message. Note that we may have already received the
            // entire response if it just happened to be the same size as our
            // buffer
            //

            // BUGBUG [arthurbi] we're broken for SSL/PCT case !!!
            //  We need to handle expanding the buffer.
            //

            if (fsm.m_dwBufferLeft == 0) {

                //
                // BUGBUG - RLF - why are we testing for SF_DECRYPT here?
                //

                if (!(fsm.m_dwFlags & SF_EXPAND) || (m_dwFlags & SF_DECRYPT)) {
                    break;
                } else {

                    //
                    // BUGBUG - the buffer increment should come from the handle
                    //          object
                    //

                    fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
                    fsm.m_dwBufferLength += DEFAULT_RECEIVE_BUFFER_INCREMENT;

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("resizing %#x to %d\n",
                                fsm.m_hBuffer,
                                fsm.m_dwBufferLength
                                ));

                    fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                                 fsm.m_dwBufferLength,
                                                 FALSE
                                                 );
                    if (fsm.m_hBuffer != NULL) {
                        fsm.m_lpBuffer = (LPBYTE)fsm.m_hBuffer + fsm.m_dwBytesReceived;
                    } else {
                        error = GetLastError();

                        INET_ASSERT(error != ERROR_SUCCESS);

                        fsm.m_dwBytesReceived = 0;
                        fsm.m_dwBufferLength = 0;
                        fsm.m_dwBufferLeft = 0;
                    }
                }
            }
        } else {
            error = _I_WSAGetLastError();
            if ((error != WSAEWOULDBLOCK) || (fsm.m_dwFlags & SF_NO_WAIT)) {

                //
                // a real error occurred. We need to get out
                //

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("recv() on socket %#x/port %d returns %d\n",
                            m_Socket,
                            m_SourcePort,
                            error
                            ));

                if (!(fsm.m_dwFlags & SF_NO_WAIT)) {
                    error = MapInternetError(error);
                }
                break;
            }

            //
            // socket would block. If SF_NON_BLOCKING is set then the caller is
            // expecting that we complete asynchronously. If SF_WAIT is set then
            // the caller wants to force synchronous behaviour, so we wait here
            // until the socket unblocks. If neither is set then the caller just
            // wants us to return what we have
            //

            if (IsNonBlocking()) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() blocked, socket %#x/port %d\n",
                            m_Socket,
                            m_SourcePort
                            ));

                fsm.SetAction(FSM_ACTION_RECEIVE);

                DWORD timeout = GetTimeoutValue(INTERNET_OPTION_RECEIVE_TIMEOUT);

                if (pObject != NULL) {
                    if (pObject->IsFromCacheTimeoutSet()
                    && (pObject->GetObjectType() == TypeHttpRequestHandle)
                    && ((HTTP_REQUEST_HANDLE_OBJECT *)pObject)->CanRetrieveFromCache()) {
                        timeout = GetTimeoutValue(INTERNET_OPTION_FROM_CACHE_TIMEOUT);

                        DWORD RTT = fsm.m_pOriginServer->GetRTT();

                        if (RTT == 0) {
                            RTT = timeout;
                        }
                        timeout += RTT;
                    }
                }
                fsm.SetTimeout(timeout);
                error = QueueSocketWorkItem(Fsm, m_Socket);
                if (error != ERROR_SUCCESS) {
                    break;
                }

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("recv() resumed, socket %#x/port %d, returns %s\n",
                            m_Socket,
                            m_SourcePort,
                            InternetMapError(error)
                            ));

            } else if (fsm.m_dwFlags & SF_WAIT) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("waiting for socket %#x/port %d to become unblocked\n",
                            m_Socket,
                            m_SourcePort
                            ));

                //error = WaitForReceive(INFINITE);
            } else {

                //
                // return what we have (non-blocking, non-waiting read). But we
                // *should* have read *something*
                //

                if (fsm.m_dwBytesRead == 0) {

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("bogus - 0 bytes read from non-blocking recv(). Waiting\n"
                                ));

                    //
                    // AOL problem:
                    //

                    //error = WaitForReceive(INFINITE);
                } else {
                    error = ERROR_SUCCESS;
                    break;
                }
            }
        }
    } while (error == ERROR_SUCCESS);

error_exit:

    //
    // get correct error based on settings
    //

    if (error == ERROR_IO_PENDING) {
        goto done;
    } else if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
    } else if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
    } else if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
        error = ERROR_INTERNET_CONNECTION_RESET;
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();
    }

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
                                   &fsm.m_dwBytesRead,
                                   sizeof(fsm.m_dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE
                                         );

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("read %d bytes @ %#x from socket %#x/port %d\n",
                    fsm.m_dwBytesRead,
                    (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                    m_Socket,
                    m_SourcePort
                    ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    } else if (fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {

        //
        // if we failed but allocated a buffer then we need to free it (we were
        // leaking this buffer if the request was cancelled)
        //

        fsm.m_hBuffer = FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;
    *fsm.m_lpbEof = fsm.m_bEof;

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone(error);
    }

done:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::ReceiveFrom(
//    IN LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesReceived,
//    OUT LPSOCKADDR lpDestination OPTIONAL,
//    IN OUT LPDWORD lpdwDestinationLength OPTIONAL,
//    IN DWORD dwTimeout,
//    IN DWORD dwWinsockFlags,
//    IN DWORD dwFlags
//    )
//
///*++
//
//Routine Description:
//
//    Wrapper for recvfrom()
//
//Arguments:
//
//    lpBuffer                - pointer to buffer where data returned
//
//    dwBufferLength          - size of lpBuffer in bytes
//
//    lpdwBytesReceived       - pointer to returned number of bytes received
//
//    lpDestination           - pointer to returned destination address
//
//    lpdwDestinationLength   - IN: size of lpDestination buffer
//                              OUT: length of returned destination address info
//
//    dwTimeout               - number of milliseconds to wait for response
//
//    dwWinsockFlags          - flags to pass through to recvfrom()
//
//    dwFlags                 - ICSocket flags
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_INTERNET_OPERATION_CANCELLED
//                    The operation was cancelled by the caller
//
//                  ERROR_INTERNET_TIMEOUT
//                    The operation timed out
//
//                  ERROR_INTERNET_CONNECTION_RESET
//                    An error occurred. We approximate to connection reset
//
//                  WSA error
//                    Some other sockets error occurred
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::ReceiveFrom",
//                 "{%#x} %#x, %d, %#x, %#x, %#x [%d], %d, %#x, %#x",
//                 m_Socket,
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesReceived,
//                 lpDestination,
//                 lpdwDestinationLength,
//                 lpdwDestinationLength ? *lpdwDestinationLength : 0,
//                 dwTimeout,
//                 dwWinsockFlags,
//                 dwFlags
//                 ));
//
//    //INET_ASSERT(IsSocketValid());
//    INET_ASSERT(lpdwBytesReceived != NULL);
//
//    //
//    // most ICSocket flags not allowed for this operation
//    //
//
//    INET_ASSERT(!(dwFlags
//                  & (SF_ENCRYPT
//                     | SF_DECRYPT
//                     | SF_EXPAND
//                     | SF_COMPRESS
//                     | SF_SENDING_DATA
//                     | SF_SCH_REDO
//                     )
//                  )
//                );
//
//    DWORD error = ERROR_SUCCESS;
//    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
//    BOOL bStopOfflineTimer = FALSE;
//    BOOL fNonBlocking;
//    DWORD bytesReceived;
//    INTERNET_HANDLE_OBJECT * pObject = NULL;
//
//    if (lpThreadInfo == NULL) {
//
//        INET_ASSERT(FALSE);
//
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    //
//    // the socket may have already been aborted
//    //
//
//    if (IsAborted()) {
//        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        goto quit;
//    }
//
//    //
//    // if we are offline then quit now - we can't make any network requests
//    //
//
//    if (IsOffline()) {
//        error = ERROR_INTERNET_OFFLINE;
//        goto quit;
//    }
//
//    //
//    // let another thread know the socket to cancel if it wants to kill this
//    // operation
//    //
//
//    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
//    if (pObject != NULL) {
//        pObject->SetAbortHandle(this);
//    }
//
//    //
//    // keep the app informed (if requested to do so)
//    //
//
//    if (dwFlags & SF_INDICATE) {
//        InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE,
//                               NULL,
//                               0
//                               );
//    }
//
//    //
//    // if we are in async (== non-blocking) mode, let the async request
//    // scheduler know what operation we will be waiting on
//    //
//
//    fNonBlocking = lpThreadInfo->IsAsyncWorkerThread;
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION_TIMEOUT(lpThreadInfo->lpArb,
//                                         m_Socket,
//                                         RECEIVE,
//                                         dwTimeout
//                                         );
//
//        DWORD timerError = StartOfflineTimerForArb(lpThreadInfo->lpArb);
//
//        INET_ASSERT(timerError == ERROR_SUCCESS);
//
//        bStopOfflineTimer = (timerError == ERROR_SUCCESS) ? TRUE : FALSE;
//    }
//
//    int nBytes;
//
//    bytesReceived = 0;
//
//    do {
//
//        nBytes = _I_recvfrom(m_Socket,
//                             (char FAR *)lpBuffer + bytesReceived,
//                             dwBufferLength,
//                             dwWinsockFlags,
//                             lpDestination,
//                             (int FAR *)lpdwDestinationLength
//                             );
//        if (nBytes != SOCKET_ERROR) {
//
//            DEBUG_PRINT(SOCKETS,
//                        INFO,
//                        ("received %d bytes from socket %#x\n",
//                        nBytes,
//                        m_Socket
//                        ));
//
//            INET_ASSERT(nBytes > 0);
//
//            bytesReceived += nBytes;
//            dwBufferLength -= nBytes;
//
//            //
//            // for recvfrom(), we quit as soon as we get some data
//            //
//
//            error = ERROR_SUCCESS;
//            break;
//        } else {
//            error = _I_WSAGetLastError();
//            if ((error == WSAEWOULDBLOCK) && fNonBlocking) {
//
//                INET_ASSERT(_dwFlags & SF_NON_BLOCKING);
//
//                //
//                // if this function is called expedited (we expect the request
//                // to complete quickly) then we test to see if it already
//                // completed before switching to the async scheduler
//                //
//
//                BOOL switchFiber = TRUE;
//
//                if (dwFlags & SF_EXPEDITED) {
//                    error = WaitForReceive(1);
//
//                    //
//                    // if the socket is already readable then we don't switch
//                    // fibers (only to virtually immediately come back here,
//                    // incurring a couple of thread switches
//                    //
//
//                    if (error == ERROR_SUCCESS) {
//                        switchFiber = FALSE;
//
//                        //
//                        // use this error to go round loop once again
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//                if (switchFiber) {
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) blocked\n",
//                                m_Socket
//                                ));
//
//                    lpThreadInfo->lpArb->Header.dwResultCode = ERROR_SUCCESS;
//
//                    SwitchToAsyncScheduler(m_Socket);
//
//                    error = lpThreadInfo->lpArb->Header.dwResultCode;
//
//                    DEBUG_PRINT(SOCKETS,
//                                INFO,
//                                ("recvfrom(%#x) resumed, returns %s\n",
//                                m_Socket,
//                                InternetMapError(error)
//                                ));
//
//                    if (error != ERROR_SUCCESS) {
//                        if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
//                            error = ERROR_INTERNET_CONNECTION_RESET;
//                        }
//                    } else {
//
//                        //
//                        // use this error to force another loop now we believe
//                        // we have the data
//                        //
//
//                        error = WSAEWOULDBLOCK;
//                    }
//                }
//            } else {
//
//                //
//                // real error
//                //
//
//                error = MapInternetError(error);
//            }
//        }
//    } while (error == WSAEWOULDBLOCK);
//
//    if (error == ERROR_SUCCESS) {
//
//        DEBUG_DUMP(SOCKETS,
//                   "received data:\n",
//                   lpBuffer,
//                   bytesReceived
//                   );
//
//    }
//
//    if (fNonBlocking) {
//
//        INET_ASSERT(lpThreadInfo->lpArb != NULL);
//
//        SET_ARB_SOCKET_OPERATION(lpThreadInfo->lpArb, INVALID_SOCKET, RECEIVE);
//
//        if (bStopOfflineTimer) {
//            StopOfflineTimerForArb(lpThreadInfo->lpArb);
//        }
//    }
//
//    //
//    // inform the app that we finished, and tell it how much we received this
//    // time
//    //
//
//    if ((dwFlags & SF_INDICATE) && (error == ERROR_SUCCESS)) {
//        InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
//                               &bytesReceived,
//                               sizeof(bytesReceived)
//                               );
//    }
//
//    *lpdwBytesReceived = bytesReceived;
//
//    if (pObject != NULL) {
//        pObject->ResetAbortHandle();
//
//        //
//        // if the operation has been cancelled, then this error overrides any
//        // other
//        //
//
//        //if (pObject->IsInvalidated()) {
//        //    error = pObject->GetError();
//        //    if (error == ERROR_SUCCESS) {
//        //        error = ERROR_INTERNET_OPERATION_CANCELLED;
//        //    }
//        //}
//        if (IsAborted()) {
//            error = ERROR_INTERNET_OPERATION_CANCELLED;
//        }
//    }
//
//quit:
//
//    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::DataAvailable(
    OUT LPDWORD lpdwBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data available to be read on the socket

Arguments:

    lpdwBytesAvailable  - pointer to returned data available


Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DataAvailable",
                 "%#x",
                 lpdwBytesAvailable
                 ));

    //
    // sanity check parameters
    //

    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(lpdwBytesAvailable != NULL);

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if we are offline then quit now - we can't make any network requests
    //

    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    //
    // the socket may already be aborted
    //

    if (IsAborted()) {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // if we're in async mode, we have to perform a zero-length receive in order
    // to get the information from the socket
    //

    int nRead;

    //
    // we actually have to peek a non-zero number of bytes because on Win95,
    // attempting to perform a receive of 0 bytes (to put the socket in blocked
    // read mode) results in zero bytes being returned, and the socket never
    // blocks
    //

    nRead = _I_recv(m_Socket, NULL, 0, 0);

    //
    // N.B. buf[] will only ever be used if there is data to peek right now
    //

    char buf[1];

    PERF_LOG(PE_PEEK_RECEIVE_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    nRead = _I_recv(m_Socket, buf, sizeof(buf), MSG_PEEK);
    if (nRead == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
        if ((error == WSAEWOULDBLOCK) && (m_dwFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) blocked, socket %#x\n",
                        m_Socket
                        ));

            PERF_LOG(PE_PEEK_RECEIVE_END,
                     m_Socket,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("peek(1) resumed, socket %#x, returns %s\n",
                        m_Socket,
                        InternetMapError(error)
                        ));

            if (error != ERROR_SUCCESS) {
                if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
                    error = ERROR_INTERNET_CONNECTION_RESET;
                }
            }
        }
    /*} else if ((nRead == 0) && !(m_dwFlags & SF_NON_BLOCKING)) {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nothing to peek right now. If the socket is in blocking mode then
        // we wait here until there is something to receive
        //

        error = WaitForReceive(INFINITE);*/
    } else {

        PERF_LOG(PE_PEEK_RECEIVE_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        //
        // nRead == 0 but non-blocking, or nRead > 0
        //

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("peek(1) returns %d\n",
                    nRead
                    ));

        error = ERROR_SUCCESS;
    }

    if (error == ERROR_SUCCESS) {

        //
        // now we can get the amount from the socket
        //

        error = (DWORD)_I_ioctlsocket(m_Socket,
                                      FIONREAD,
                                      (u_long FAR *)lpdwBytesAvailable
                                      );

        //
        // N.B. assumes ioctlsocket() returns 0 on success == ERROR_SUCCESS
        //

        if (error == SOCKET_ERROR) {
            error = _I_WSAGetLastError();
        } else {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("ioctlsocket(FIONREAD) returns %d\n",
                        *lpdwBytesAvailable
                        ));

        }
    }

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//ICSocket::DataAvailable2(
//    OUT LPVOID lpBuffer,
//    IN DWORD dwBufferLength,
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines the amount of data available to be read on the socket
//
//Arguments:
//
//    lplpBuffer          - pointer to pointer to buffer where data read
//
//    dwBufferLength      - size of the buffer
//
//    lpdwBytesAvailable  - pointer to returned data available
//
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - WSA error
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::DataAvailable2",
//                 "%#x, %d, %#x",
//                 lpBuffer,
//                 dwBufferLength,
//                 lpdwBytesAvailable
//                 ));
//
//    //
//    // sanity check parameters
//    //
//
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // we're about to receive data from the socket. The amount of data currently
//    // on hand must be 0
//    //
//
//    INET_ASSERT(*lpdwBytesAvailable == 0);
//    INET_ASSERT(lpBuffer != NULL);
//
//    DWORD error;
//
//    //
//    // new scheme: actually read the data from sockets into our buffer. This is
//    // the only way on Win95 to determine the correct number of bytes available.
//    // We only perform a single receive
//    //
//
//    DWORD bufferLeft = dwBufferLength;
//    BOOL eof;
//
//    error = Receive(&lpBuffer,
//                    &dwBufferLength,
//                    &bufferLeft,  // don't care about this
//                    lpdwBytesAvailable,
//                    0,
//                    0,
//                    &eof          // don't care about this either
//                    );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
ICSocket::WaitForReceive(
    IN DWORD Timeout
    )

/*++

Routine Description:

    Waits until a receive socket becomes unblocked (readable)

Arguments:

    Timeout - milliseconds to wait, or INFINITE

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error
                    sockets error

                  ERROR_INTERNET_TIMEOUT
                    Receive timed out

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::WaitForReceive",
                 "{%#x} %d",
                 m_Socket,
                 Timeout
                 ));

    struct fd_set read_fds;
    struct fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);

    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    int n;

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("waiting on socket %#x\n",
                m_Socket
                ));

    TIMEVAL timeout;
    LPTIMEVAL lpTimeout;

    if (Timeout != INFINITE) {
        timeout.tv_sec  = Timeout / 1000;
        timeout.tv_usec = (Timeout % 1000) * 1000;
        lpTimeout = &timeout;
    } else {
        lpTimeout = NULL;
    }

    n = _I_select(0, &read_fds, NULL, &except_fds, lpTimeout);

    DWORD error;

    if (n == SOCKET_ERROR) {

        //
        // real error?
        //

        error = _I_WSAGetLastError();

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("select() returns %d\n",
                    error
                    ));

        INET_ASSERT(FALSE);

        error = MapInternetError(error);
    } else if (n != 0) {
        if (FD_ISSET(m_Socket, &except_fds)) {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("socket %#x exception\n",
                        m_Socket
                        ));

            error = ERROR_INTERNET_CONNECTION_RESET;
        } else {

            //
            // it *must* be unblocked (i.e. readable)
            //

            INET_ASSERT(FD_ISSET(m_Socket, &read_fds));

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket %#x unblocked\n",
                        m_Socket
                        ));

            error = ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("timed out\n"
                    ));

        error = ERROR_INTERNET_TIMEOUT;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::AllocateQueryBuffer(
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Allocates a query buffer for the socket

Arguments:

    lplpBuffer          - returned pointer to allocated query buffer

    lpdwBufferLength    - returned length of allocated query buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::AllocateQueryBuffer",
                 "{%#x/%d} %#x, %#x",
                 GetSocket(),
                 GetSourcePort(),
                 lplpBuffer,
                 lpdwBufferLength
                 ));

    DWORD error;
    DWORD bufferLength;
    DWORD size = sizeof(bufferLength);

    int serr = _I_getsockopt(m_Socket,
                             SOL_SOCKET,
                             SO_RCVBUF,
                             (char FAR *)&bufferLength,
                             (int FAR *)&size
                             );
    if (serr != SOCKET_ERROR) {
        bufferLength = min(bufferLength, DEFAULT_SOCKET_QUERY_BUFFER_LENGTH);
        if (bufferLength == 0) {
            bufferLength = DEFAULT_SOCKET_QUERY_BUFFER_LENGTH;
        }
        *lplpBuffer = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, bufferLength);
        if (*lplpBuffer != NULL) {
            *lpdwBufferLength = bufferLength;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        error = MapInternetError(_I_WSAGetLastError());
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//VOID
//ICSocket::FreeQueryBuffer(
//    IN LPVOID lpBuffer
//    )
//
///*++
//
//Routine Description:
//
//    description-of-function.
//
//Arguments:
//
//    lpBuffer    -
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    lpBuffer = (LPVOID)FREE_MEMORY((HLOCAL)lpBuffer);
//
//    INET_ASSERT(lpBuffer == NULL);
//}

//
//DWORD
//ICSocket::GetBytesAvailable(
//    OUT LPDWORD lpdwBytesAvailable
//    )
//
///*++
//
//Routine Description:
//
//    Determines amount of data available to be read from socket
//
//Arguments:
//
//    lpdwBytesAvailable  - pointer to returned available length
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "ICSocket::GetBytesAvailable",
//                 "{%#x} %#x",
//                 m_Socket,
//                 lpdwBytesAvailable
//                 ));
//
//    //INET_ASSERT(m_Socket != INVALID_SOCKET);
//    INET_ASSERT(lpdwBytesAvailable != NULL);
//
//    //
//    // get the amount from the socket. If the socket has been reset or shutdown
//    // by the server then we expect to get an error, else 0 (== ERROR_SUCCESS)
//    //
//
//    DWORD error = (DWORD)_I_ioctlsocket(m_Socket,
//                                        FIONREAD,
//                                        (u_long FAR *)lpdwBytesAvailable
//                                        );
//    if (error == SOCKET_ERROR) {
//        error = _I_WSAGetLastError();
//    } else {
//
//        DEBUG_PRINT(SOCKETS,
//                    INFO,
//                    ("ioctlsocket(FIONREAD) returns %d\n",
//                    *lpdwBytesAvailable
//                    ));
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//

DWORD
ICSocket::CreateSocket(
    IN DWORD dwFlags,
    IN int nAddressFamily,
    IN int nType,
    IN int nProtocol
    )

/*++

Routine Description:

    Opens a socket handle for this ICSocket object

Arguments:

    dwFlags         - flags to use for new socket

    nAddressFamily  - parameter to socket()

    nType           - parameter to socket()

    nProtocol       - parameter to socket()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::CreateSocket",
                 "%#x, %s (%d), %s (%d), %s (%d)",
                 dwFlags,
                 MapFamily(nAddressFamily),
                 nAddressFamily,
                 MapSock(nType),
                 nType,
                 MapProto(nProtocol),
                 nProtocol
                 ));

    INET_ASSERT(m_Socket == INVALID_SOCKET);

    int serr;
    DWORD error;
    DWORD dwConnFlags;

#if defined(SITARA)

    //
    // Only enable Sitara if we're connected via modem
    //

//dprintf("create socket: IsSitara = %B, IsModemConn=%B\n",GlobalEnableSitara, GlobalHasSitaraModemConn);
    if (GlobalEnableSitara && GlobalHasSitaraModemConn) {
        nProtocol = (int)GetSitaraProtocol();
    }

#endif

    m_Socket = _I_socket(nAddressFamily, nType, nProtocol);
    if (m_Socket == INVALID_SOCKET) {

        DEBUG_PRINT(SOCKETS,
                    ERROR,
                    ("failed to create socket\n"
                    ));

        goto socket_error;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("created socket %#x\n",
                m_Socket
                ));

    if (dwFlags & SF_NON_BLOCKING) {
        INET_ASSERT(FALSE);

        error = SetNonBlockingMode(TRUE);
        if (error == ERROR_SUCCESS) {

            //
            //  ICSocket is non-blocking socket object
            //

            m_dwFlags |= SF_NON_BLOCKING;
        } else {
            goto close_socket;
        }
    }

    //
    // bind our data socket to an endpoint, so that we know an address to
    // tell the FTP server
    //

    struct sockaddr_storage ourDataAddr;

    ourDataAddr.ss_family = (short)nAddressFamily;

    if (nAddressFamily == AF_INET6) {
        struct in_addr6 in6addr_any = IN6ADDR_ANY_INIT;

        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_port = 0;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_flowinfo = 0;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_addr = in6addr_any;
        ((LPSOCKADDR_IN6)&ourDataAddr)->sin6_scope_id = 0;
    } else {
        ((LPSOCKADDR_IN)&ourDataAddr)->sin_port = 0;
        ((LPSOCKADDR_IN)&ourDataAddr)->sin_addr.s_addr = INADDR_ANY;
    }

    serr = _I_bind(m_Socket,
                   (PSOCKADDR)&ourDataAddr,
                   sizeof(ourDataAddr)
                   );

    if (serr == SOCKET_ERROR) {
        goto socket_error;
    }

    error = ERROR_SUCCESS;

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());

close_socket:

    Close();
    m_dwFlags &= ~SF_NON_BLOCKING;
    goto quit;
}


DWORD
ICSocket::GetSockName(
    IN PSOCKADDR psaSockName,
    IN int SockNameSize
    )
/*++

Routine Description:

    Returns the socket address for this socket.

Arguments:

    psaSocketName    - pointer to sockaddr buffer to fill in.

    SockNameSize - size of sockaddr buffer;

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(psaSockName);
    INET_ASSERT(SockNameSize >= sizeof(SOCKADDR));

    int serr;
    DWORD error;

    serr = ERROR_SUCCESS;
    error = ERROR_SUCCESS;

    //
    // get the address info .
    //

    serr = _I_getsockname(m_Socket,
                          psaSockName,
                          &SockNameSize
                          );


    if ( serr == SOCKET_ERROR )
    {
        error = _I_WSAGetLastError();
    }

    return error;
}


DWORD
ICSocket::GetPeerName(
    IN PSOCKADDR psaSockName,
    IN int SockNameSize
    )
/*++

Routine Description:

    Returns the socket address for this socket's connected peer.

Arguments:

    psaSocketName    - pointer to sockaddr buffer to fill in.

    SockNameSize - size of sockaddr buffer;

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);
    INET_ASSERT(psaSockName);
    INET_ASSERT(SockNameSize >= sizeof(SOCKADDR));

    int serr;
    DWORD error;

    serr = ERROR_SUCCESS;
    error = ERROR_SUCCESS;

    //
    // get the address info .
    //

    serr = _I_getpeername(m_Socket,
                          psaSockName,
                          &SockNameSize
                          );


    if ( serr == SOCKET_ERROR )
    {
        error = _I_WSAGetLastError();
    }

    return error;
}


DWORD
ICSocket::Listen(
    VOID
    )
{
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error = ERROR_SUCCESS;

    //
    // Listen on the socket.
    //

    if (_I_listen(m_Socket, 1) == SOCKET_ERROR) {
        error = _I_WSAGetLastError();
    }
    return error;
}


DWORD
ICSocket::DirectConnect(
    PSOCKADDR psaRemoteSock
    )

/*++

Routine Description:

    Connects a ICSocket to the remote address

Arguments:

    psaRemoteSock   - pointer to remote socket address (TCP/IP!)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::DirectConnectSocket",
                 "{%#x} %#x",
                 m_Socket,
                 psaRemoteSock
                 ));

    INET_ASSERT(m_Socket != INVALID_SOCKET);

    DWORD error;
    BOOL bStopOfflineTimer = FALSE;

    //
    // we need the thread info for async processing
    //

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if we are offline then quit now - we can't make any network requests
    //

    if (IsOffline()) {
        error = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    BOOL isAsync;

    isAsync = lpThreadInfo->IsAsyncWorkerThread;

    //
    // BUGBUG - this is essentially common to ConnectSocket()
    //

    //
    // let another thread know the socket to cancel if it wants to kill
    // this operation
    //

    INTERNET_HANDLE_OBJECT * pObject;

    pObject = (INTERNET_HANDLE_OBJECT * )lpThreadInfo->hObjectMapped;
    if (pObject != NULL) {
        pObject->SetAbortHandle(this);
    }

#if defined(UNIX) && defined(ux10)
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[0],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[1],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[2],
                ((LPBYTE)&((LPSOCKADDR_IN)psaRemoteSock)->sin_addr)[3],
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#else
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("connecting to remote address %d.%d.%d.%d, port %d\n",
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b1,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b2,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b3,
                ((LPSOCKADDR_IN)psaRemoteSock)->sin_addr.S_un.S_un_b.s_b4,
                _I_ntohs(((LPSOCKADDR_IN)psaRemoteSock)->sin_port)
                ));
#endif

    DWORD connectTime;

    connectTime = GetTickCountWrap();

    int serr;

    PERF_LOG(PE_CONNECT_START,
             m_Socket,
             lpThreadInfo->ThreadId,
             lpThreadInfo->hObject
             );

    if (IsSocks()) {
        // BUGBUG: We only support IPv4 Socks.
        serr = SocksConnect((LPSOCKADDR_IN)psaRemoteSock, sizeof(SOCKADDR_IN));
    } else {
        int RemoteSockSize;

        if (psaRemoteSock->sa_family == AF_INET6) {
            RemoteSockSize = sizeof(SOCKADDR_IN6);
        } else {
            RemoteSockSize = sizeof(SOCKADDR_IN);
        }
        serr = _I_connect(m_Socket, psaRemoteSock, RemoteSockSize);
    }
    if (serr != 0) {
        error = _I_WSAGetLastError();

        //
        // if we are using non-blocking sockets then we need to wait until
        // the connect has completed, or an error occurs
        //

        if (isAsync) {
            if (error == WSAEWOULDBLOCK) {

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() blocked, socket %#x\n",
                            m_Socket
                            ));

                PERF_LOG(PE_CONNECT_END,
                         m_Socket,
                         lpThreadInfo->ThreadId,
                         lpThreadInfo->hObject
                         );

                connectTime = (GetTickCountWrap() - connectTime);

                DEBUG_PRINT(SOCKETS,
                            INFO,
                            ("connect() resumed, socket %#x, returns %s\n",
                            m_Socket,
                            InternetMapError(error)
                            ));

                if (error != ERROR_SUCCESS) {
                    if (error == ERROR_INTERNET_INTERNAL_SOCKET_ERROR) {
                        error = ERROR_INTERNET_CANNOT_CONNECT;
                    }
                }
            } else {

                DEBUG_PRINT(SOCKETS,
                            ERROR,
                            ("failed to connect non-blocking socket %#x, error %d\n",
                            m_Socket,
                            error
                            ));

            }
        } else {

            DEBUG_PRINT(SOCKETS,
                        ERROR,
                        ("failed to connect blocking socket %#x, error %d\n",
                        m_Socket,
                        error
                        ));

        }
    } else {

        PERF_LOG(PE_CONNECT_END,
                 m_Socket,
                 lpThreadInfo->ThreadId,
                 lpThreadInfo->hObject
                 );

        connectTime = (GetTickCountWrap() - connectTime);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("socket %#x connected, time = %d mSec\n",
                    m_Socket,
                    connectTime
                    ));

        error = ERROR_SUCCESS;
    }

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

    if (pObject != NULL) {
        pObject->ResetAbortHandle();

        //
        // if the operation has been cancelled, then this error overrides any
        // other
        //

        if (pObject->IsInvalidated()) {
            error = pObject->GetError();
            if (error == ERROR_SUCCESS) {
                error = ERROR_INTERNET_OPERATION_CANCELLED;
            }
        }
        if (IsAborted()) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }
    }

quit:

    INET_ASSERT((pObject != NULL) ? (pObject->GetAbortHandle() == NULL) : TRUE);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSocket::SelectAccept(
    IN ICSocket & acceptSocket,
    IN DWORD dwTimeout
    )

/*++

Routine Description:

    Wait until listening socket has connection to accept. We use the socket
    handle in this ICSocket object to accept a connection & create a socket
    handle in another ICSocket object (in acceptSocket)

Arguments:

    acceptSocket    - socket object to wait on

    dwTimeout       - number of milliseconds to wait

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error mapped to INTERNET error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSocket::SelectAccept",
                 "%#x, %d",
                 &acceptSocket,
                 dwTimeout
                 ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    fd_set read_fds;
    fd_set except_fds;

    FD_ZERO(&read_fds);
    FD_ZERO(&except_fds);
    FD_SET(m_Socket, &read_fds);
    FD_SET(m_Socket, &except_fds);

    TIMEVAL timeout;

    timeout.tv_sec  = dwTimeout / 1000;
    timeout.tv_usec = dwTimeout % 1000;

    int n;

    n = _I_select(0, &read_fds, NULL, &except_fds, &timeout);
    if (n == 1) {
        if (FD_ISSET(m_Socket, &read_fds)) {
            error = ERROR_SUCCESS;
        } else if (FD_ISSET(m_Socket, &except_fds)) {
            error = ERROR_INTERNET_CANNOT_CONNECT;

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("select(): listening socket %#x in error (%d)\n",
                        m_Socket,
                        error
                        ));

            INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);
        }
    } else if (n == 0) {

        //
        // timeout
        //

        error = ERROR_INTERNET_TIMEOUT;

        DEBUG_PRINT(FTP,
                    WARNING,
                    ("select() timed out (%d.%d)\n",
                    timeout.tv_sec,
                    timeout.tv_usec
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

    } else {

        //
        // socket error
        //

        DEBUG_PRINT(FTP,
                    ERROR,
                    ("select() returns %d\n",
                    _I_WSAGetLastError()
                    ));

        INET_ASSERT(acceptSocket.m_Socket == INVALID_SOCKET);

        goto socket_error;
    }

    //
    // if we have a success indication then accept the connection; it may still
    // fail
    //

    if (error == ERROR_SUCCESS) {
        acceptSocket.m_Socket = _I_accept(m_Socket, NULL, NULL);
        if (acceptSocket.m_Socket != INVALID_SOCKET) {

            //
            // copy non-blocking indication to new socket
            //

            INET_ASSERT(!(m_dwFlags & SF_NON_BLOCKING));
            //acceptSocket.m_dwFlags |= (m_dwFlags & SF_NON_BLOCKING);
        } else {

            DEBUG_PRINT(FTP,
                        ERROR,
                        ("accept() returns %d\n",
                        error
                        ));

            goto socket_error;
        }
    }

quit:

    DEBUG_LEAVE(error);

    return error;

socket_error:

    error = MapInternetError(_I_WSAGetLastError());
    goto quit;
}


LPSTR
MapNetAddressToName(
    IN LPSTR lpszAddress,
    OUT LPSTR * lplpszMappedName
    )

/*++

Routine Description:

    Given a network address, tries to map it to the corresponding host name. We
    consult the name resolution cache to determine this

Arguments:

    lpszAddress         - pointer to network address to map

    lplpszMappedName    - pointer to pointer to mapped name. Caller must free

Return Value:

    LPSTR
        Success - pointer to mapped name

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Pointer,
                "MapNetAddressToName",
                "%q, %#x",
                lpszAddress,
                lplpszMappedName
                ));

    INET_ASSERT(lpszAddress != NULL);
    INET_ASSERT(lplpszMappedName != NULL);

    LPSTR lpszMappedName = NULL;

    //
    // now try to find the address in the cache. If it's not in the cache then
    // we don't resolve it, simply return the address
    //

    //
    // BUGBUG - if required, we need to resolve the name, but we need to know
    //          whether the address can be resolved on the intranet
    //

    //
    // If getaddrinfo with the AI_NUMERICHOST flag succeeds then we were
    // given a string representation of an IPv6 or IPv4 address.
    //

    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.

    if (_I_getaddrinfo(lpszAddress, NULL, &Hints, &lpAddrInfo) == 0) {

        //
        // An IP address literal (either v4 or v6) was passed in.
        // See if we have a name cached that maps to it.
        //

        DWORD ttl;
        LPADDRINFO CachedAddrInfo;
        LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry;

        if ((lpResolverCacheEntry=QueryResolverCache(NULL, lpAddrInfo->ai_addr, &CachedAddrInfo, &ttl))) {

            INET_ASSERT(CachedAddrInfo != NULL);

            if (CachedAddrInfo->ai_canonname != NULL)
                lpszAddress = lpszMappedName = NewString(CachedAddrInfo->ai_canonname);
            ReleaseResolverCacheEntry(lpResolverCacheEntry);
        }

        _I_freeaddrinfo(lpAddrInfo);
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("mapped name is %q\n",
                lpszAddress
                ));

    DEBUG_LEAVE(lpszAddress);

    *lplpszMappedName = lpszMappedName;

    return lpszAddress;
}


DWORD
AUTO_PROXY_HELPER_APIS::ResolveHostName(
    IN LPSTR lpszHostName,
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )

/*++

Routine Description:

    Resolves a HostName to an IP address literal by using Winsock DNS.

Arguments:

    lpszHostName   - the host name that should be used.

    lpszIPAddress  - the output IP address as a string.

    lpdwIPAddressSize - the size of the outputed IP address string.

Return Value:

    DWORD
        Win32 error code.

--*/

{
    //
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo() with the AI_NUMERICHOST flag succeeds then we were
    // given a string respresentation of an IPv6 or IPv4 address. Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    DWORD dwIPAddressSize;
    LPRESOLVER_CACHE_ENTRY lpResolverCacheEntry = NULL;
    BOOL bResolved = FALSE;
    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;
    DWORD error;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }

        //
        // An IP address (either v4 or v6) was passed in.
        // This is precisely what we want, so if we have the room,
        // just copy it back out.
        //

        _I_freeaddrinfo(lpAddrInfo);

        dwIPAddressSize = lstrlen(lpszHostName);

        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }

        lstrcpy(lpszIPAddress, lpszHostName);
        goto quit;
    }

    //
    // now try to find the name in the cache. If it's not in the
    // cache then resolve it
    //

    DWORD ttl;

    if (!(lpResolverCacheEntry=QueryResolverCache(lpszHostName, NULL, &lpAddrInfo, &ttl))) 
    {

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("resolving %q\n",
                    lpszHostName
                    ));

        PERF_LOG(PE_NAMERES_START, 0);

        Hints.ai_flags = 0;  // No special treatment this time.

        error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

        PERF_LOG(PE_NAMERES_END, 0);

        DEBUG_PRINT(SOCKETS,
                    INFO,
                    ("%q %sresolved\n",
                    lpszHostName,
                    (error == 0) ? "" : "NOT "
                    ));


        //
        // if we successfully resolved the name then remember to add the
        // information to the cache when we're done with it
        //

        if (error == 0) {
            bResolved = TRUE;
        } else {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }
    }

    INET_ASSERT(lpAddrInfo != NULL);

    //
    // We have an addrinfo struct for lpszHostName.
    // Convert its IP address into a string.
    //

    //
    // BUGBUG: Until our caller can deal with IPv6 addresses, we'll only
    // return IPv4 addresses here, regardless of what may be in the cache.
    // Step through chain until we find an IPv4 address.
    //

    LPADDRINFO IPv4Only;

    IPv4Only = lpAddrInfo;
    while (IPv4Only->ai_family != AF_INET) {

        IPv4Only = IPv4Only->ai_next;
        if (IPv4Only == NULL) {
            error = ERROR_INTERNET_NAME_NOT_RESOLVED;
            goto quit;
        }
    }

    error = _I_getnameinfo(IPv4Only->ai_addr, IPv4Only->ai_addrlen,
                           lpszIPAddress, *lpdwIPAddressSize, NULL, 0,
                           NI_NUMERICHOST);
    if (error != 0) {
        error = ERROR_INTERNET_NAME_NOT_RESOLVED;
    }

quit:

    if (lpResolverCacheEntry) {

        INET_ASSERT(!bResolved);
        INET_ASSERT(lpAddrInfo != NULL);

        ReleaseResolverCacheEntry(lpResolverCacheEntry);

    } else if (bResolved) {

        INET_ASSERT(lpAddrInfo != NULL);

        AddResolverCacheEntry(lpszHostName, lpAddrInfo, LIVE_DEFAULT);
    }

    return error;
}

BOOL
AUTO_PROXY_HELPER_APIS::IsResolvable(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Determines wheter a HostName can be resolved.  Performs a Winsock DNS query,
      and if it succeeds returns TRUE.

Arguments:

    lpszHost   - the host name that should be used.

Return Value:

    BOOL
        TRUE - the host is resolved.

        FALSE - could not resolve.

--*/

{

    char szDummy[] = "1111:2222:3333:4444:5555:6666:255.255.255.255%4294967295";
    DWORD dwDummySize = sizeof(szDummy);
    DWORD error;

    error = ResolveHostName(
                lpszHost,
                szDummy,
                &dwDummySize
                );

    if (error == 0)
    {
        return TRUE;
    }
    else
    {
        INET_ASSERT(error != ERROR_SUCCESS );
        return FALSE;
    }

}

DWORD
AUTO_PROXY_HELPER_APIS::GetIPAddress(
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )

/*++

Routine Description:

    Acquires the IP address string of this client machine WININET is running on.

Arguments:

    lpszIPAddress   - the IP address of the machine, returned.

    lpdwIPAddressSize - size of the IP address string.

Return Value:

    DWORD
        Win32 Error.

--*/

{

    CHAR szHostBuffer[255];
    int serr;

    serr = _I_gethostname(
                szHostBuffer,
                ARRAY_ELEMENTS(szHostBuffer)-1
                );

    if ( serr != ERROR_SUCCESS)
    {
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    return ResolveHostName(
                szHostBuffer,
                lpszIPAddress,
                lpdwIPAddressSize
                );

}


BOOL
AUTO_PROXY_HELPER_APIS::IsInNet(
    IN LPSTR   lpszIPAddress,
    IN LPSTR   lpszDest,
    IN LPSTR   lpszMask
    )

/*++

Routine Description:

    Determines whether a given IP address is in a given dest/mask IP address.

Arguments:

    lpszIPAddress   - the host name that should be used.

    lpszDest        - the IP address dest to check against.

    lpszMask        - the IP mask string

Return Value:

    BOOL
        TRUE - the IP address is in the given dest/mask

        FALSE - the IP address is NOT in the given dest/mask

--*/

{
    DWORD dwDest, dwIpAddr, dwMask;

    INET_ASSERT(lpszIPAddress);
    INET_ASSERT(lpszDest);
    INET_ASSERT(lpszMask);

    dwIpAddr = _I_inet_addr(lpszIPAddress);
    dwDest = _I_inet_addr(lpszDest);
    dwMask = _I_inet_addr(lpszMask);

    if ( dwDest   == INADDR_NONE ||
         dwIpAddr == INADDR_NONE  )

    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

        if ( (dwIpAddr & dwMask) != dwDest)
    {
        return FALSE;
        }

    //
    // Pass, its Matches.
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\iwinsock.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    iwinsock.cxx

Abstract:

    Contains functions to load sockets DLL and entry points. Functions and data
    in this module take care of indirecting sockets calls, hence _I_ in front
    of the function name

    Contents:
        IwinsockInitialize
        IwinsockTerminate
        LoadWinsock
        UnloadWinsock
        SafeCloseSocket

Author:

    Richard L Firth (rfirth) 12-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    12-Apr-1995 rfirth
        Created

    08-May-1996 arthurbi
        Added support for Socks Firewalls.

    05-Mar-1998 rfirth
        Moved SOCKS support into ICSocket class. Removed SOCKS library
        loading/unloading from this module (revert to pre-SOCKS)

--*/

#include <wininetp.h>

#if defined(__cplusplus)
extern "C" {
#endif


#if INET_DEBUG

#if defined(RETAIL_LOGGING)
#define DPRINTF (void)
#else
#define DPRINTF dprintf
#endif

VOID
InitDebugSock(
    VOID
    );

VOID
TerminateDebugSock(
    VOID
    );

#else
#define DPRINTF (void)
#endif

//
// private types
//

typedef struct {
#if defined(unix)
    LPSTR FunctionOrdinal;
#else
    DWORD FunctionOrdinal;
#endif /* unix */
    FARPROC * FunctionAddress;
} SOCKETS_FUNCTION;


//
// global data
//

GLOBAL
SOCKET
(PASCAL FAR * _I_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_bind)(
    SOCKET s,
    const struct sockaddr FAR *addr,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_connect)(
    SOCKET s,
    const struct sockaddr FAR *name,
    int namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_gethostname)(
    char FAR * name,
    int namelen
    ) = NULL;

GLOBAL
LPHOSTENT
(PASCAL FAR * _I_gethostbyname)(
    const char FAR * lpHostName
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockname)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getpeername)(
    SOCKET s,
    struct sockaddr FAR *name,
    int FAR * namelen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getsockopt)(
    SOCKET s,
    int level,
    int optname,
    char FAR * optval,
    int FAR *optlen
    );

GLOBAL
u_long
(PASCAL FAR * _I_htonl)(
    u_long hostlong
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_htons)(
    u_short hostshort
    ) = NULL;

GLOBAL
unsigned long
(PASCAL FAR * _I_inet_addr)(
    const char FAR * cp
    ) = NULL;

GLOBAL
char FAR *
(PASCAL FAR * _I_inet_ntoa)(
    struct in_addr in
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_ioctlsocket)(
    SOCKET s,
    long cmd,
    u_long FAR *argp
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_listen)(
    SOCKET s,
    int backlog
    ) = NULL;

GLOBAL
u_short
(PASCAL FAR * _I_ntohs)(
    u_short netshort
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recv)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_recvfrom)(
    SOCKET s,
    char FAR * buf,
    int len,
    int flags,
    struct sockaddr FAR *from, 
    int FAR * fromlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_select)(
    int nfds,
    fd_set FAR *readfds,
    fd_set FAR *writefds,
    fd_set FAR *exceptfds,
    const struct timeval FAR *timeout
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_send)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_sendto)(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR *to, 
    int tolen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_setsockopt)(
    SOCKET s,
    int level,
    int optname,
    const char FAR * optval,
    int optlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_shutdown)(
    SOCKET s,
    int how
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _I_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSAStartup)(
    WORD wVersionRequired,
    LPWSADATA lpWSAData
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSACleanup)(
    void
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSAGetLastError)(
    void
    ) = NULL;

GLOBAL
void
(PASCAL FAR * _I_WSASetLastError)(
    int iError
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I___WSAFDIsSet)(
    SOCKET,
    fd_set FAR *
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getaddrinfo)(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    ) = NULL;

GLOBAL
void
(PASCAL FAR * _I_freeaddrinfo)(
    IN struct addrinfo *ai
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_getnameinfo)(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    ) = NULL;


GLOBAL
int
(PASCAL FAR * _I_WSALookupServiceBeginW)(
    IN  LPWSAQUERYSETW lpqsRestrictions,
    IN  DWORD          dwControlFlags,
    OUT LPHANDLE       lphLookup
    ) = NULL;


GLOBAL
int
(PASCAL FAR * _I_WSALookupServiceNextW)(
    IN     HANDLE           hLookup,
    IN     DWORD            dwControlFlags,
    IN OUT LPDWORD          lpdwBufferLength,
    OUT    LPWSAQUERYSETW   lpqsResults
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _I_WSALookupServiceEnd)(
    IN HANDLE  hLookup
    ) = NULL;


GLOBAL
int
(PASCAL FAR * _I_WSANSPIoctl)(
    IN  HANDLE           hLookup,
    IN  DWORD            dwControlCode,
    IN  LPVOID           lpvInBuffer,
    IN  DWORD            cbInBuffer,
    OUT LPVOID           lpvOutBuffer,
    IN  DWORD            cbOutBuffer,
    OUT LPDWORD          lpcbBytesReturned,
    IN  LPWSACOMPLETION  lpCompletion
    ) = NULL;

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

//
// private data
//

//
// InitializationLock - protects against multiple threads loading WSOCK32.DLL
// and entry points
//

PRIVATE CRITICAL_SECTION InitializationLock = {0};

//
// hWinsock - NULL when WSOCK32.DLL is not loaded
// hWs2_32 - NULL when WS2_32.DLL is not loaded.
// hAddrResLib - NULL when WS2_32.DLL/WSHIPV6.DLL is not loaded
//      If WS2_32.DLL is loaded in the process and it has IPv6 entry points,
//      hAddrResLib==hWs2_32, otherwise it is handle to WSHIPV6.DLL if
//      the latter is present and usable (IPv6 is present).
//

PRIVATE HINSTANCE hWinsock = NULL;
PRIVATE HINSTANCE hWs2_32 = NULL;
PRIVATE HINSTANCE hAddrResLib = NULL;

//
// WinsockLoadCount - the number of times we have made calls to LoadWinsock()
// and UnloadWinsock(). When this reaches 0 (again), we can unload the Winsock
// DLL for real
//

PRIVATE DWORD WinsockLoadCount = 0;

//
// SocketsFunctions - this is the list of entry points in WSOCK32.DLL that we
// need to load for WININET.DLL
//

#if !defined(unix)

PRIVATE
SOCKETS_FUNCTION
SocketsFunctions[] = {
    1,      (FARPROC*)&_I_accept,
    2,      (FARPROC*)&_I_bind,
    3,      (FARPROC*)&_I_closesocket,
    4,      (FARPROC*)&_I_connect,
    5,      (FARPROC*)&_I_getpeername,
    6,      (FARPROC*)&_I_getsockname,
    7,      (FARPROC*)&_I_getsockopt,
    8,      (FARPROC*)&_I_htonl,
    9,      (FARPROC*)&_I_htons,
    10,     (FARPROC*)&_I_inet_addr,
    11,     (FARPROC*)&_I_inet_ntoa,
    12,     (FARPROC*)&_I_ioctlsocket,
    13,     (FARPROC*)&_I_listen,
    15,     (FARPROC*)&_I_ntohs,
    16,     (FARPROC*)&_I_recv,
    17,     (FARPROC*)&_I_recvfrom,
    18,     (FARPROC*)&_I_select,
    19,     (FARPROC*)&_I_send,
    20,     (FARPROC*)&_I_sendto,
    21,     (FARPROC*)&_I_setsockopt,
    22,     (FARPROC*)&_I_shutdown,
    23,     (FARPROC*)&_I_socket,
    52,     (FARPROC*)&_I_gethostbyname,
    57,     (FARPROC*)&_I_gethostname,
    111,    (FARPROC*)&_I_WSAGetLastError,
    112,    (FARPROC*)&_I_WSASetLastError,
    115,    (FARPROC*)&_I_WSAStartup,
    116,    (FARPROC*)&_I_WSACleanup,
    151,    (FARPROC*)&_I___WSAFDIsSet
};

#else

PRIVATE
SOCKETS_FUNCTION
SocketsFunctions[] = {
    "MwAccept",         (FARPROC*)&_I_accept,
    "MwBind",           (FARPROC*)&_I_bind,
    "closesocket",      (FARPROC*)&_I_closesocket,
    "MwConnect",        (FARPROC*)&_I_connect,
    "MwGetpeername",    (FARPROC*)&_I_getpeername,
    "MwGetsockname",    (FARPROC*)&_I_getsockname,
    "MwGetsockopt",     (FARPROC*)&_I_getsockopt,
    "MwHtonl",          (FARPROC*)&_I_htonl,
    "MwHtons",          (FARPROC*)&_I_htons,
    "MwInet_addr",      (FARPROC*)&_I_inet_addr,
    "MwInet_ntoa",      (FARPROC*)&_I_inet_ntoa,
    "ioctlsocket",      (FARPROC*)&_I_ioctlsocket,
    "MwListen",         (FARPROC*)&_I_listen,
    "MwNtohs",          (FARPROC*)&_I_ntohs,
    "MwRecv",           (FARPROC*)&_I_recv,
    "MwRecvfrom",       (FARPROC*)&_I_recvfrom,
    "MwSelect",         (FARPROC*)&_I_select,
    "MwSend",           (FARPROC*)&_I_send,
    "MwSendto",         (FARPROC*)&_I_sendto,
    "MwSetsockopt",     (FARPROC*)&_I_setsockopt,
    "MwShutdown",       (FARPROC*)&_I_shutdown,
    "MwSocket",         (FARPROC*)&_I_socket,
    "MwGethostbyname",  (FARPROC*)&_I_gethostbyname,
    "MwGethostname",    (FARPROC*)&_I_gethostname,
    "WSAGetLastError",  (FARPROC*)&_I_WSAGetLastError,
    "WSASetLastError",  (FARPROC*)&_I_WSASetLastError,
    "WSAStartup",       (FARPROC*)&_I_WSAStartup,
    "WSACleanup",       (FARPROC*)&_I_WSACleanup,
#if 0
    "",                 (FARPROC*)&_I___WSAFDIsSet
#endif
};

#endif /* unix */

//
// private prototypes
//

#if INET_DEBUG

void SetupSocketsTracing(void);

#endif

int
PASCAL FAR
LimitedGetAddrInfo(
    IN const char FAR * nodename,
    IN const char FAR * servname,
    IN const struct addrinfo FAR * hints,
    OUT struct addrinfo FAR * FAR * res
    );

void
PASCAL FAR
LimitedFreeAddrInfo(
    IN struct addrinfo *ai
    );

int
PASCAL FAR
LimitedGetNameInfo(
    IN const struct sockaddr FAR * sa,
    IN socklen_t salen,
    OUT char FAR * host,
    IN size_t hostlen,
    OUT char FAR * serv,
    IN size_t servlen,
    IN int flags
    );

//
// functions
//


VOID
IwinsockInitialize(
    VOID
    )

/*++

Routine Description:

    Performs initialization/resource allocation for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // initialize the critical section that protects against multiple threads
    // trying to initialize Winsock
    //

    InitializeCriticalSection(&InitializationLock);

#if INET_DEBUG
    InitDebugSock();
#endif
}


VOID
IwinsockTerminate(
    VOID
    )

/*++

Routine Description:

    Performs termination & resource cleanup for this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    DeleteCriticalSection(&InitializationLock);

#if INET_DEBUG
    TerminateDebugSock();
#endif
}


DWORD
LoadWinsock(
    VOID
    )

/*++

Routine Description:

    Dynamically loads Windows sockets library

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error
                    e.g. LoadLibrary() failure

                  WSA error
                    e.g. WSAStartup() failure

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "LoadWinsock",
                NULL
                ));

    DWORD error = ERROR_SUCCESS;

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    EnterCriticalSection(&InitializationLock);

    if (hWinsock == NULL) {

        BOOL failed = FALSE;

        DPRINTF("Attempting to load winsock\n");

        //
        // Even though we attempt to load WinSock 2 (ws2_32.dll) below,
        // we still load WinSock 1 (wsock32.dll) here because some of the
        // supposedly identical ordinal numbers were changed between
        // versions, thus breaking pure binary compatibility.
        //

        hWinsock = LoadLibrary("wsock32");
        if (hWinsock != NULL) {

            //
            // Load function entry points from the WinSock library.
            //

            FARPROC farProc;

            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {

                farProc = GetProcAddress(
                                hWinsock,
                                (LPCSTR)(DWORD_PTR)SocketsFunctions[i].FunctionOrdinal
                                );
                if (farProc == NULL) {
                    failed = TRUE;
                    DPRINTF("Can't find entry %d in function array\n", i);
                    break;
                }
                *SocketsFunctions[i].FunctionAddress = farProc;
            }
            if (!failed) {

                //
                // although we need a WSADATA for WSAStartup(), it is an
                // expendible structure (not required for any other sockets
                // calls)
                //

                WSADATA wsaData;

                error = _I_WSAStartup(0x0101, &wsaData);
                if (error == ERROR_SUCCESS) {

                    DEBUG_PRINT(SOCKETS,
                                INFO,
                                ("winsock description: %q\n",
                                wsaData.szDescription
                                ));

                    int stringLen;

                    stringLen = lstrlen(wsaData.szDescription);
                    if (strnistr(wsaData.szDescription, "novell", stringLen)
                    && strnistr(wsaData.szDescription, "wsock32", stringLen)) {

                        DEBUG_PRINT(SOCKETS,
                                    INFO,
                                    ("running on Novell Client32 stack\n"
                                    ));

                        GlobalRunningNovellClient32 = TRUE;
                    }
#if INET_DEBUG
                    SetupSocketsTracing();
#endif

                    //
                    // We may need to load ws2_32 for several purposes.
                    // If the functionality is actually not available,
                    // we do not want to keep around unnecessarily.
                    // This refcount will help us decide.
                    //
                    INT ws2_32RefCount = 0;

                    //
                    // Attempt load ws2_32.dll.  
                    //
                    DPRINTF("Checking for presence of ws2_32\n");
                    hWs2_32 = LoadLibrary ("ws2_32");
                    if (hWs2_32!=NULL) {
                        //
                        // Try to locate name resolution API
                        // necessary to access Network Location Awareness
                        // service (available on Whistler).
                        //
                        if (GlobalPlatformWhistler) {
                            farProc = GetProcAddress (hWs2_32,
                                                        "WSALookupServiceBeginW");
                            if (farProc!=NULL) {
                                *(FARPROC *)&_I_WSALookupServiceBeginW = farProc;
                                farProc = GetProcAddress (hWs2_32,
                                                        "WSALookupServiceEnd");
                                if (farProc!=NULL) {
                                    *(FARPROC *)&_I_WSALookupServiceEnd = farProc;
                                    farProc = GetProcAddress (hWs2_32,
                                                        "WSALookupServiceNextW");
                                    if (farProc!=NULL) {
                                        *(FARPROC *)&_I_WSALookupServiceNextW = farProc;
                                        farProc = GetProcAddress (hWs2_32,
                                                        "WSANSPIoctl");
                                        if (farProc!=NULL) {
                                            *(FARPROC *)&_I_WSANSPIoctl = farProc;
                                        }
                                    }
                                }
                            }

                            if (farProc!=NULL) {
                                //
                                // Increment ws2_32 ref count for
                                // the purpose of NLA
                                //
                                ws2_32RefCount += 1;
                            }
                            else {
                                _I_WSALookupServiceBeginW = NULL;
                                _I_WSALookupServiceEnd = NULL;
                                _I_WSALookupServiceNextW = NULL;
                                _I_WSANSPIoctl = NULL;
                            }
                        }

                        //
                        // Try to locate the address family independent name
                        // resolution routines (i.e. getaddrinfo, getnameinfo).
                        // In Whistler and beyond, these will be present in
                        // the WinSock 2 library (ws2_32.dll).
                        //

                        // Restricting to Whistler only.
                        if (GlobalPlatformWhistler) 
                        {
                            DPRINTF("Looking in ws2_32 for getaddrinfo\n");
                            farProc = GetProcAddress(hWs2_32, "getaddrinfo");
                            if (farProc != NULL) {
                                //
                                // Increment ws2_32 ref count for
                                // the purpose of IPv6 address resolution.
                                //
                                ws2_32RefCount += 1;
                                hAddrResLib = hWs2_32;
                            }
                        }
                    }

                    // Restricting to Whistler only.
                    if ((hAddrResLib == NULL) 
                        && GlobalPlatformWhistler) 
                    {
                        //
                        // In the IPv6 Technology Preview, the address family
                        // independent name resolution calls are snuck in via
                        // the IPv6 WinSock helper library (wship6.dll).
                        // So look there next.
                        //
                        DPRINTF("Looking in wship6 for getaddrinfo\n");
                        hAddrResLib = LoadLibrary("wship6");
                        if (hAddrResLib != NULL) {
                            farProc = GetProcAddress(hAddrResLib,
                                                     "getaddrinfo");
                            if (farProc == NULL) {
                                FreeLibrary(hAddrResLib);
                                hAddrResLib = NULL;

                            } else {
                                //
                                // The Tech Preview version of the address
                                // family independent APIs doesn't check that
                                // an IPv6 stack is present before returning
                                // IPv6 addresses.  So we need to check for it.
                                //
                                SOCKET Test;
                                struct sockaddr_in6 TestSA;

                                DPRINTF("Checking for active IPv6 stack\n");
                                error = SOCKET_ERROR;
                                Test = _I_socket(PF_INET6, 0, 0);
                                if (Test != INVALID_SOCKET) {
                                    memset(&TestSA, 0, sizeof(TestSA));
                                    TestSA.sin6_family = AF_INET6;
                                    TestSA.sin6_addr.s6_addr[15] = 1;
                                    error = _I_bind(Test, (LPSOCKADDR)&TestSA,
                                                    sizeof(TestSA));
                                    _I_closesocket(Test);
                                }
                                if (error != 0) {
                                    DPRINTF("IPv6 stack is not active\n");
                                    FreeLibrary(hAddrResLib);
                                    hAddrResLib = NULL;
                                    error = 0;
                                }
                            }
                        }
                    }

                    if (hAddrResLib != NULL) {
                        //
                        // Use routines from this library.  Since getaddrinfo
                        // is here, we expect the others to be also, but will
                        // fall back to IPv4-only if any of them is missing.
                        //
                        *(FARPROC *)&_I_getaddrinfo = farProc;
                        farProc = GetProcAddress(hAddrResLib, "freeaddrinfo");
                        if (farProc != NULL) {
                            *(FARPROC *)&_I_freeaddrinfo = farProc;
                            farProc = GetProcAddress(hAddrResLib,
                                                     "getnameinfo");
                            if (farProc != NULL)
                                *(FARPROC *)&_I_getnameinfo = farProc;
                        }
                        if (farProc == NULL) {
                            if (hAddrResLib!=hWs2_32) {
                                FreeLibrary(hAddrResLib);
                            }
                            else {
                                ws2_32RefCount -= 1;
                            }
                            hAddrResLib = NULL;
                        }
                    }

                    if (hAddrResLib == NULL) {
                        //
                        // If we can't find getaddrinfo lying around on the
                        // system somewhere, assume we're still in the
                        // IPv4-only dark ages.
                        //
                        DPRINTF("Using IPv4-only name res functions\n");
                        _I_getaddrinfo = LimitedGetAddrInfo;
                        _I_freeaddrinfo = LimitedFreeAddrInfo;
                        _I_getnameinfo = LimitedGetNameInfo;
                    }

                    //
                    // Check if we actually used ws2_32 for anything
                    // and unload it if not.
                    //
                    if (ws2_32RefCount==0 && hWs2_32!=NULL) {
                        FreeLibrary (hWs2_32);
                        hWs2_32 = NULL;
                    }

                } else {
                    DPRINTF("Winsock failed to start\n");
                    failed = TRUE;
                }
            }
        } else {
            DPRINTF("Couldn't load the winsock library\n");
            failed = TRUE;
        }

        //
        // if we failed to find an entry point or WSAStartup() returned an error
        // then unload the library
        //

        if (failed) {

            //
            // important: there should be no API calls between determining the
            // failure and coming here to get the error code
            //
            // if error == ERROR_SUCCESS then we have to get the last error, else
            // it is the error returned by WSAStartup()
            //

            if (error == ERROR_SUCCESS) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

            }
            DPRINTF("Unloading winsock due to error 0x%x\n", error);
            UnloadWinsock();
        }
    } else {

        //
        // just increment the number of times we have called LoadWinsock()
        // without a corresponding call to UnloadWinsock();
        //

        ++WinsockLoadCount;
    }

    LeaveCriticalSection(&InitializationLock);

    //
    // if we failed for any reason, need to report that TCP/IP not available
    //

    if (error != ERROR_SUCCESS) {
        error = ERROR_INTERNET_TCPIP_NOT_INSTALLED;
    }

    DEBUG_LEAVE(error);

    return error;
}


VOID
UnloadWinsock(
    VOID
    )

/*++

Routine Description:

    Unloads winsock DLL and prepares hWinsock and SocketsFunctions[] for reload

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "UnloadWinsock",
                 NULL
                 ));

    //
    // ensure no 2 threads are trying to modify the loaded state of winsock at
    // the same time
    //

    EnterCriticalSection(&InitializationLock);

    //
    // only unload the DLL if it has been mapped into process memory
    //

    if (hWinsock != NULL) {

        //
        // and only if this is the last load instance
        //

        if (WinsockLoadCount == 0) {

            INET_ASSERT(_I_WSACleanup != NULL);

            if (_I_WSACleanup != NULL) {

                //
                // need to terminate async support too - it is reliant on
                // Winsock
                //

                TerminateAsyncSupport();

                int serr = _I_WSACleanup();

                if (serr != 0) {

                    DEBUG_PRINT(SOCKETS,
                                ERROR,
                                ("WSACleanup() returns %d; WSA error = %d\n",
                                serr,
                                (_I_WSAGetLastError != NULL)
                                    ? _I_WSAGetLastError()
                                    : -1
                                ));

                }
            }
            if (hAddrResLib != NULL) {
                *(FARPROC *)&_I_getaddrinfo = (FARPROC)NULL;
                *(FARPROC *)&_I_freeaddrinfo = (FARPROC)NULL;
                *(FARPROC *)&_I_getnameinfo = (FARPROC)NULL;
                if (hAddrResLib!=hWs2_32) {
                    FreeLibrary(hAddrResLib);
                }
                hAddrResLib = NULL;
            }
            if (hWs2_32!=NULL) {
                *(FARPROC *)&_I_WSALookupServiceBeginW = (FARPROC)NULL;
                *(FARPROC *)&_I_WSALookupServiceEnd = (FARPROC)NULL;
                *(FARPROC *)&_I_WSALookupServiceNextW = (FARPROC)NULL;
                *(FARPROC *)&_I_WSANSPIoctl = (FARPROC)NULL;
                FreeLibrary (hWs2_32);
                hWs2_32 = NULL;
            }
            for (int i = 0; i < ARRAY_ELEMENTS(SocketsFunctions); ++i) {
                *SocketsFunctions[i].FunctionAddress = (FARPROC)NULL;
            }
            FreeLibrary(hWinsock);
            hWinsock = NULL;
        } else {

            //
            // if there have been multiple virtual loads, then just reduce the
            // load count
            //

            --WinsockLoadCount;
        }
    }

    LeaveCriticalSection(&InitializationLock);

    DEBUG_LEAVE(0);
}

//
// Following is v4-only version of getaddrinfo and friends.
//
// Note that we use LocalAlloc/LocalFree instead of malloc/free
// to avoid introducing a dependency on msvcrt.dll.
//


//* LimitedFreeAddrInfo - Free an addrinfo structure (or chain of structures).
//
//  As specified in RFC 2553, Section 6.4.
//
void WSAAPI
LimitedFreeAddrInfo(
    struct addrinfo *Free)  // Structure (chain) to free.
{
    struct addrinfo *Next;

    for (Next = Free; Next != NULL; Free = Next) {
        if (Free->ai_canonname != NULL)
            LocalFree(Free->ai_canonname);
        if (Free->ai_addr != NULL)
            LocalFree(Free->ai_addr);
        Next = Free->ai_next;
        LocalFree(Free);
    }
}


//* NewAddrInfo - Allocate an addrinfo structure and populate some fields.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Returns a partially filled-in addrinfo struct, or NULL if out of memory.
//
static struct addrinfo *
NewAddrInfo(
    int SocketType,           // SOCK_*.  Can be wildcarded (zero).
    int Protocol,             // IPPROTO_*.  Can be wildcarded (zero).
    struct addrinfo ***Prev)  // In/out param for accessing previous ai_next.
{
    struct addrinfo *New;

    //
    // Allocate a new addrinfo structure.
    //
    New = (struct addrinfo *)LocalAlloc(0, sizeof(struct addrinfo));
    if (New == NULL)
        return NULL;

    //
    // Fill in the easy stuff.
    //
    New->ai_flags = 0;
    New->ai_family = PF_INET;
    New->ai_socktype = SocketType;
    New->ai_protocol = Protocol;
    New->ai_addrlen = sizeof(struct sockaddr_in);
    New->ai_canonname = NULL;
    New->ai_addr = (LPSOCKADDR)LocalAlloc(0, New->ai_addrlen);
    if (New->ai_addr == NULL) {
        LocalFree(New);
        return NULL;
    }
    New->ai_next = NULL;

    //
    // Link this one onto the end of the chain.
    //
    **Prev = New;
    *Prev = &New->ai_next;

    return New;
}


//* LookupNode - Resolve a nodename and add any addresses found to the list.
//
//  Internal function, not exported.  Expects to be called with valid
//  arguments, does no checking.
//
//  Returns 0 on success, an EAI_* style error value otherwise.
//
static int
LookupNode(
    const char *NodeName,     // Name of node to resolve.
    int SocketType,           // SOCK_*.  Can be wildcarded (zero).
    int Protocol,             // IPPROTO_*.  Can be wildcarded (zero).
    int Flags,                // Flags.
    struct addrinfo ***Prev)  // In/out param for accessing previous ai_next.
{
    struct addrinfo *CurrentInfo;
    struct sockaddr_in *sin;
    struct hostent *hA;
    char **addrs;
    int Error = 0;

    hA = _I_gethostbyname(NodeName);
    if (hA != NULL) {
        if ((hA->h_addrtype == AF_INET) &&
            (hA->h_length == sizeof(struct in_addr))) {

            //
            // Loop through all the addresses returned by gethostbyname,
            // allocating an addrinfo structure and filling in the address
            // field for each.
            //
            for (addrs = hA->h_addr_list; *addrs != NULL; addrs++) {

                CurrentInfo = NewAddrInfo(SocketType, Protocol, Prev);
                if (CurrentInfo == NULL) {
                    Error = EAI_MEMORY;
                    break;
                }

                //
                // We fill in the ai_canonname field in the first addrinfo
                // structure that we return if we've been asked to do so.
                //
                if (Flags & AI_CANONNAME) {
                    if (hA->h_name != NULL) {
                        int NameLength;

                        NameLength = strlen(hA->h_name) + 1;
                        CurrentInfo->ai_canonname = (char *)LocalAlloc(0, NameLength);
                        if (CurrentInfo->ai_canonname == NULL) {
                            Error = EAI_MEMORY;
                            break;
                        }
                        memcpy(CurrentInfo->ai_canonname, hA->h_name, NameLength);
                    }

                    // Turn off flag so we only do this once.
                    Flags &= ~AI_CANONNAME;
                }

                //
                // We're returning IPv4 addresses.
                //
                sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
                sin->sin_family = AF_INET;
                sin->sin_port = 0;
                memcpy(&sin->sin_addr, (struct in_addr *)*addrs, sizeof sin->sin_addr);
                memset(sin->sin_zero, 0, sizeof sin->sin_zero);
            }
        }
    } else {

        Error = _I_WSAGetLastError();
        if (Error == WSANO_DATA) {
            Error = EAI_NODATA;
        } else if (Error == WSAHOST_NOT_FOUND) {
            Error = EAI_NONAME;
        } else {
            Error = EAI_FAIL;
        }
    }

    return Error;
}


//* ParseV4Address
//
//  Helper function for parsing a literal v4 address, because
//  WSAStringToAddress is too liberal in what it accepts.
//  Returns FALSE if there is an error, TRUE for success.
//
//  The syntax is a.b.c.d, where each number is between 0 - 255.
//
static int
ParseV4Address(const char *String, struct in_addr *Addr)
{
    u_int Number;
    int NumChars;
    char Char;
    int i;

    for (i = 0; i < 4; i++) {
        Number = 0;
        NumChars = 0;
        for (;;) {
            Char = *String++;
            if (Char == '\0') {
                if ((NumChars > 0) && (i == 3))
                    break;
                else
                    return FALSE;
            }
            else if (Char == '.') {
                if ((NumChars > 0) && (i < 3))
                    break;
                else
                    return FALSE;
            }
            else if (('0' <= Char) && (Char <= '9')) {
                if ((NumChars != 0) && (Number == 0))
                    return FALSE;
                else if (++NumChars <= 3)
                    Number = 10 * Number + (Char - '0');
                else
                    return FALSE;
            } else
                return FALSE;
        }
        if (Number > 255)
            return FALSE;
        ((u_char *)Addr)[i] = (u_char)Number;
    }

    return TRUE;
}


//* LimitedGetAddrInfo - Protocol-independent name-to-address translation.
//
//  As specified in RFC 2553, Section 6.4.
//
//  This is the hacked version that only supports IPv4.
//
//  Returns zero if successful, an EAI_* error code if not.
//
int WSAAPI
LimitedGetAddrInfo(
    const char *NodeName,          // Node name to lookup.
    const char *ServiceName,       // Service name to lookup.
    const struct addrinfo *Hints,  // Hints about how to process request.
    struct addrinfo **Result)      // Where to return result.
{
    struct addrinfo *CurrentInfo, **Next;
    int ProtocolId = 0;
    u_short ProtocolFamily = PF_UNSPEC;
    int SocketType = 0;
    int Flags = 0;
    int Error;
    struct sockaddr_in *sin;
    struct in_addr TempAddr;

    //
    // This special cut-down version for wininet doesn't do service lookup.
    // So the request must be for nodename lookup.
    //
    INET_ASSERT(ServiceName == NULL);
    INET_ASSERT(NodeName != NULL);

    //
    // In case we have to bail early, make it clear to our caller
    // that we haven't allocated an addrinfo structure.
    //
    *Result = NULL;
    Next = Result;

    //
    // Validate hints argument.
    //
    if (Hints != NULL) {
        //
        // Wininet can be trusted to call us correctly.
        //
        INET_ASSERT((Hints->ai_addrlen == 0) &&
                    (Hints->ai_canonname == NULL) &&
                    (Hints->ai_addr == NULL) &&
                    (Hints->ai_next == NULL));

        Flags = Hints->ai_flags;
        INET_ASSERT(!((Flags & AI_CANONNAME) && (Flags & AI_NUMERICHOST)));

        ProtocolFamily = (u_short)Hints->ai_family;
        INET_ASSERT((ProtocolFamily == PF_UNSPEC) ||
                    (ProtocolFamily == PF_INET));

        SocketType = Hints->ai_socktype;
        INET_ASSERT((SocketType == 0) ||
                    (SocketType == SOCK_STREAM) ||
                    (SocketType == SOCK_DGRAM));

        ProtocolId = Hints->ai_protocol;
    }

    //
    // We have a node name (either alpha or numeric) we need to look up.
    //

    //
    // First, see if this is a numeric string address that we can
    // just convert to a binary address.
    //
    if (ParseV4Address(NodeName, &TempAddr)) {
        //
        // Conversion from IPv4 numeric string to binary address
        // was sucessfull.  Create an addrinfo structure to hold it,
        // and return it to the user.
        //
        CurrentInfo = NewAddrInfo(SocketType, ProtocolId, &Next);
        if (CurrentInfo == NULL) {
            Error = EAI_MEMORY;
            goto Bail;
        }
        sin = (struct sockaddr_in *)CurrentInfo->ai_addr;
        sin->sin_family = AF_INET;
        sin->sin_port = 0;
        sin->sin_addr = TempAddr;
        memset(sin->sin_zero, 0, sizeof sin->sin_zero);

        return 0;  // Success!
    }

    //
    // It's not a numeric string address.  If our caller only wants us
    // to convert numeric addresses, give up now.
    //
    if (Flags & AI_NUMERICHOST) {
        Error = EAI_NONAME;
        goto Bail;
    }

    //
    // Since it's non-numeric, we have to do a regular node name lookup.
    //
    Error = LookupNode(NodeName, SocketType, ProtocolId, Flags, &Next);
    if (Error != 0)
        goto Bail;

    return 0;  // Success!

  Bail:
    if (*Result != NULL) {
        LimitedFreeAddrInfo(*Result);
        *Result = NULL;
    }
    return Error;
}


//* LimitedGetNameInfo - Protocol-independent address-to-name translation.
//
//  As specified in RFC 2553, Section 6.5.
//
//  This is a special version for wininet that only supports IPv4.
//  All extraneous checks have been removed, only the specific calls
//  that wininet makes are supported.
//
//  Note that unless the IE team decides to attempt the FTP EPRT command
//  for IPv4 as well as IPv6 (see comments in ftp\protocol.cxx), this
//  routine will never be called.
//
int WSAAPI
LimitedGetNameInfo(
    const struct sockaddr *SocketAddress,  // Socket address to translate.
    socklen_t SocketAddressLength,         // Length of above socket address.
    char *NodeName,                        // Where to return the node name.
    size_t NodeBufferSize,                 // Size of above buffer.
    char *ServiceName,                     // Where to return the service name.
    size_t ServiceBufferSize,              // Size of above buffer.
    int Flags)                             // Flags of type NI_*.
{
    //
    // Wininet doesn't do service lookup.
    //
    INET_ASSERT((ServiceName == NULL) && (ServiceBufferSize == 0));

    //
    // Wininet can be trusted to call us correctly.
    //
    INET_ASSERT((NodeName != NULL) && (SocketAddress != NULL) &&
                (SocketAddressLength == sizeof(struct sockaddr_in)));

    //
    // This version is IPv4 only.
    //
    INET_ASSERT(SocketAddress->sa_family == AF_INET);

    //
    // Wininet will only call this routine to translate the given address
    // to an IPv4 address literal.
    //
    INET_ASSERT(Flags & NI_NUMERICHOST);
    INET_ASSERT(NodeBufferSize >= sizeof("255.255.255.255"));
    strcpy(NodeName, _I_inet_ntoa(((struct sockaddr_in *)SocketAddress)->sin_addr));

    return 0;
}



DWORD
SafeCloseSocket(
    IN SOCKET Socket
    )

/*++

Routine Description:

    closesocket() call protected by exception handler in case winsock DLL has
    been unloaded by system before Wininet DLL unloaded

Arguments:

    Socket  - socket handle to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - socket error mapped to ERROR_INTERNET_ error

--*/

{
    int serr;

    __try {
        serr = _I_closesocket(Socket);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        serr = 0;
    }
    ENDEXCEPT
    return (serr == SOCKET_ERROR)
        ? MapInternetError(_I_WSAGetLastError())
        : ERROR_SUCCESS;
}

#if INET_DEBUG

//
// debug data types
//

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    );

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    );

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    );

GLOBAL
SOCKET
(PASCAL FAR * _P_accept)(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    ) = NULL;

GLOBAL
int
(PASCAL FAR * _P_closesocket)(
    SOCKET s
    ) = NULL;

GLOBAL
SOCKET
(PASCAL FAR * _P_socket)(
    int af,
    int type,
    int protocol
    ) = NULL;

#define MAX_STACK_TRACE     5
#define MAX_SOCK_ENTRIES    1000

typedef struct _DEBUG_SOCK_ENTRY {
    SOCKET Socket;
    DWORD StackTraceLength;
    PVOID StackTrace[ MAX_STACK_TRACE ];
} DEBUG_SOCK_ENTRY, *LPDEBUG_SOCK_ENTRY;

CRITICAL_SECTION DebugSockLock;
DEBUG_SOCK_ENTRY GlobalSockEntry[MAX_SOCK_ENTRIES];

DWORD GlobalSocketsCount = 0;


#define LOCK_DEBUG_SOCK()   EnterCriticalSection( &DebugSockLock )
#define UNLOCK_DEBUG_SOCK() LeaveCriticalSection( &DebugSockLock )

HINSTANCE NtDllHandle;

typedef USHORT (*RTL_CAPTURE_STACK_BACK_TRACE)(
   IN ULONG FramesToSkip,
   IN ULONG FramesToCapture,
   OUT PVOID *BackTrace,
   OUT PULONG BackTraceHash
   );

RTL_CAPTURE_STACK_BACK_TRACE pRtlCaptureStackBackTrace;

VOID
InitDebugSock(
    VOID
    )
{
    InitializeCriticalSection( &DebugSockLock );
    memset( GlobalSockEntry, 0x0, sizeof(GlobalSockEntry) );
    GlobalSocketsCount = 0;
    return;
}

VOID
TerminateDebugSock(
    VOID
    )
{
    DeleteCriticalSection(&DebugSockLock);
}

VOID
SetupSocketsTracing(
    VOID
    )
{
    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }
    if (!IsPlatformWinNT()) {
        return ;
    }
    if ((NtDllHandle = LoadLibrary("ntdll.dll")) == NULL) {
        return ;
    }
    if ((pRtlCaptureStackBackTrace =
        (RTL_CAPTURE_STACK_BACK_TRACE)
            GetProcAddress(NtDllHandle, "RtlCaptureStackBackTrace")) == NULL) {
        FreeLibrary(NtDllHandle);
        return ;
    }

//#ifdef DONT_DO_FOR_NOW
    _P_accept = _I_accept;
    _I_accept = _II_accept;
    _P_closesocket = _I_closesocket;
    _I_closesocket = _II_closesocket;
    _P_socket = _I_socket;
    _I_socket = _II_socket;
//#endif
}

VOID
AddSockEntry(
    SOCKET S
    )
{
    DWORD i;
    DWORD Hash;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    //
    // search for a free entry.
    //

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == 0 ) {

            DWORD Hash;

            //
            // found a free entry.
            //

            GlobalSockEntry[i].Socket = S;

            //
            // get caller stack.
            //

#if i386
            Hash = 0;

            GlobalSockEntry[i].StackTraceLength =
                pRtlCaptureStackBackTrace(
                    2,
                    MAX_STACK_TRACE,
                    GlobalSockEntry[i].StackTrace,
                    &Hash );
#else // i386
            GlobalSockEntry[i].StackTraceLength = 0;
#endif // i386


            GlobalSocketsCount++;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("socket count = %ld\n",
                        GlobalSocketsCount
                        ));

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

    //
    // we have reached a high handle limit, which is unusal, needs to be
    // debugged.
    //

    INET_ASSERT( FALSE );
    UNLOCK_DEBUG_SOCK();

    return;
}

VOID
RemoveSockEntry(
    SOCKET S
    )
{
    DWORD i;

    if (!(InternetDebugCategoryFlags & DBG_TRACE_SOCKETS)) {
        return ;
    }

    LOCK_DEBUG_SOCK();

    for( i = 0; i < MAX_SOCK_ENTRIES; i++ ) {

        if( GlobalSockEntry[i].Socket == S ) {

            //
            // found the entry. Free it now.
            //

            memset( &GlobalSockEntry[i], 0x0, sizeof(DEBUG_SOCK_ENTRY) );

            GlobalSocketsCount--;

#ifdef IWINSOCK_DEBUG_PRINT

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("count(%ld), RemoveSock(%lx)\n",
                        GlobalSocketsCount,
                        S
                        ));

#endif // IWINSOCK_DEBUG_PRINT

            DPRINTF("%d sockets\n", GlobalSocketsCount);

            UNLOCK_DEBUG_SOCK();
            return;
        }
    }

#ifdef IWINSOCK_DEBUG_PRINT

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("count(%ld), UnknownSock(%lx)\n",
                GlobalSocketsCount,
                S
                ));

#endif // IWINSOCK_DEBUG_PRINT

    //
    // socket entry is not found.
    //

    // INET_ASSERT( FALSE );

    UNLOCK_DEBUG_SOCK();
    return;
}

SOCKET
PASCAL FAR
_II_socket(
    int af,
    int type,
    int protocol
    )
{
    SOCKET S;

    S = _P_socket( af, type, protocol );
    AddSockEntry( S );
    return( S );
}

int
PASCAL FAR
_II_closesocket(
    SOCKET s
    )
{
    int Ret;

    RemoveSockEntry( s );
    Ret = _P_closesocket( s );
    return( Ret );
}

SOCKET
PASCAL FAR
_II_accept(
    SOCKET s,
    struct sockaddr FAR *addr,
    int FAR *addrlen
    )
{
    SOCKET S;

    S = _P_accept( s, addr, addrlen );
    AddSockEntry( S );
    return( S );

}

VOID
IWinsockCheckSockets(
    VOID
    )
{
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("GlobalSocketsCount = %d\n",
                GlobalSocketsCount
                ));

    for (DWORD i = 0; i < MAX_SOCK_ENTRIES; ++i) {

        SOCKET sock;

        if ((sock = GlobalSockEntry[i].Socket) != 0) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Socket %#x\n",
                        sock
                        ));

        }
    }
}

#endif // INET_DEBUG

#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\reslock.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    reslock.cxx

Abstract:

    Contains methods for RESOURCE_LOCK class

    Contents:
        RESOURCE_LOCK::Acquire()
        RESOURCE_LOCK::Release()

Author:

    Richard L Firth (rfirth) 18-Jun-1996

Revision History:

    18-Jun-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// class members
//

#ifdef OLD_VERSION


BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )

/*++

Routine Description:

    Acquires the resource protected by this lock. Acquires for non-exclusive
    (read) or exclusive (write) ownership

Arguments:

    bExclusiveMode  - TRUE if we are acquiring the resource for exclusive
                      (write) ownership

Return Value:

    BOOL
        TRUE    - resource is acquired

        FALSE   - failed to acquire resource (timeout?)

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(FALSE);

        return FALSE;
    }

    BOOL acquired = TRUE;

    //EnterCriticalSection(&_CritSect);
    if (bExclusiveMode) {

        //
        // acquired for exclusive ownership (write access). Set the owning
        // thread id and wait for the last current reader to release. Note
        // that if we're being re-entered, EnterCriticalSection() has already
        // done the work of checking the thread id and updating re-entrancy
        // counts, so if its already not zero, we know it must be us
        //

        ++_WriteCount;
        if (_ThreadId == 0) {
            _ThreadId = GetCurrentThreadId();
#if INET_DEBUG
            INET_ASSERT(_ThreadId != _ThreadIdReader);
#endif
            acquired = Wait(_hWriteEvent);
            EnterCriticalSection(&_CritSect);
        } else {

            INET_ASSERT(_ThreadId == GetCurrentThreadId());

        }
    } else {

        //
        // don't allow re-entry if already held for exclusive access
        //

        INET_ASSERT(_ThreadId == 0);

        //
        // acquired for non-exclusive ownership (read access). Just increase
        // the number of active readers. If this is the first then inhibit the
        // writer
        //

        if (InterlockedIncrement(&_Readers) == 0) {
#if INET_DEBUG
            if (_ThreadIdReader == 0) {
                _ThreadIdReader = GetCurrentThreadId();
            }
#endif
            ResetEvent(_hWriteEvent);
        }

        //
        // reader doesn't need to keep hold of critical section
        //

        //LeaveCriticalSection(&_CritSect);
    }

    DEBUG_LEAVE(acquired);

    return acquired;
}


VOID
RESOURCE_LOCK::Release(
    VOID
    )

/*++

Routine Description:

    Releases a resource previously acquired by RESOURCE_LOCK::Acquire()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    INET_ASSERT(this != NULL);
    //INET_ASSERT(IsInitialized());
    //INET_ASSERT(IsValid());

    if (!IsInitialized()) {

        DEBUG_LEAVE(0);

        return;
    }

    if ((_ThreadId != 0) && (_ThreadId == GetCurrentThreadId())) {

        INET_ASSERT(_WriteCount > 0);

        if (--_WriteCount == 0) {

            //
            // we acquired _hWriteEvent; signal it to allow next writer to continue
            //

            SetEvent(_hWriteEvent);

            //
            // this resource no longer owned for exclusive access
            //

            _ThreadId = 0;
        }
        LeaveCriticalSection(&_CritSect);
    } else if (InterlockedDecrement(&_Readers) < 0) {

        INET_ASSERT(_Readers >= -1);

        //
        // we are last currently active reader; allow waiting writer to continue
        //

#if INET_DEBUG
        if (_ThreadIdReader == GetCurrentThreadId()) {
            _ThreadIdReader = 0;
        }
#endif
        SetEvent(_hWriteEvent);
    }

    DEBUG_LEAVE(0);
}

#else

BOOL
RESOURCE_LOCK::Acquire(
    IN BOOL bExclusiveMode
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                Bool,
                "RESOURCE_LOCK::Acquire",
                "%B",
                bExclusiveMode
                ));

    if (!IsInitialized()) {

        DEBUG_LEAVE(FALSE);

        return FALSE;
    }

    if (bExclusiveMode) {
        do {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Waiting on WriteEvent\n")
                        );

            if (_ThreadId != GetCurrentThreadId()) {
                Wait(_hWriteEvent);
            }
            EnterCriticalSection(&_CritSect);

            INET_ASSERT((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()));

            if ((_Readers == -1)
                && ((_ThreadId == 0) || (_ThreadId == GetCurrentThreadId()))) {
                _ThreadId = GetCurrentThreadId();
                if (++_WriteCount == 1) {
                    ResetEvent(_hWriteEvent);
                }
                break;
            }

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("trying again\n")
                        );

            LeaveCriticalSection(&_CritSect);
        } while ( 1 );
    } else {
        EnterCriticalSection(&_CritSect);
        if (++_Readers == 0) {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Resetting WriteEvent\n")
                        );

            ResetEvent(_hWriteEvent);
        }
        LeaveCriticalSection(&_CritSect);
    }

    DEBUG_LEAVE(TRUE);

    return TRUE;
}

VOID
RESOURCE_LOCK::Release(
    VOID
    )
{
    DEBUG_ENTER((DBG_RESLOCK,
                None,
                "RESOURCE_LOCK::Release",
                NULL
                ));

    if (IsInitialized()) {
        if (_ThreadId == GetCurrentThreadId()) {

            DEBUG_PRINT(RESLOCK,
                        INFO,
                        ("Clearing writer\n")
                        );

            if (--_WriteCount == 0) {
                _ThreadId = 0;
                SetEvent(_hWriteEvent);
            }
            LeaveCriticalSection(&_CritSect);
        } else {
            EnterCriticalSection(&_CritSect);
            if (--_Readers == -1) {

                DEBUG_PRINT(RESLOCK,
                            INFO,
                            ("Setting WriteEvent\n")
                            );

                SetEvent(_hWriteEvent);
            }
            LeaveCriticalSection(&_CritSect);
        }
    }

    DEBUG_LEAVE(0);
}

#endif // OLD_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\secinit.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    secinit.cxx

Abstract:

    Contains load function for security.dll on NT and secur32.dll on win95
    Also handles WinTrust.dll function loading.

Author:

    Sophia Chung (sophiac)  6-Feb-1996

Environment:

    User Mode - Win32

Revision History:

--*/
#include <wininetp.h>

//
// InitializationLock - protects against multiple threads loading security.dll
// (secur32.dll) and entry points
//

CRITICAL_SECTION InitializationSecLock = {0};

CRITICAL_SECTION InitFortezzaLock = {0};

HCRYPTPROV  GlobalFortezzaCryptProv;

//
// GlobalSecFuncTable - Pointer to Global Structure of Pointers that are used
//  for storing the entry points into the SCHANNEL.dll
//

PSecurityFunctionTable GlobalSecFuncTable = NULL;

//
// pWinVerifyTrust - Pointer to Entry Point in WINTRUST.DLL
//

WIN_VERIFY_TRUST_FN pWinVerifyTrust;
WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN pWTHelperProvDataFromStateData;

//
// pSslCrackCertificate - Pointer to SCHANNEL.dll utility function that
//      is used for parsing X509 certificates.
//

SSL_CRACK_CERTIFICATE_FN pSslCrackCertificate;

//
// pSslFreeCertificate - Pointer to Schannel.dll function for freeing Certs
//

SSL_FREE_CERTIFICATE_FN  pSslFreeCertificate;

//
// hSecurity - NULL when security.dll/secur32.dll  is not loaded
//

HINSTANCE hSecurity = NULL;

//
// hWinTrust - NULL when WinTrust DLL is not loaded.
//

HINSTANCE hWinTrust = NULL;
BOOL g_fDoSpecialMagicForSGCCerts = FALSE;

HCERTSTORE g_hMyCertStore = NULL;
BOOL  g_bOpenMyCertStore = FALSE;

BOOL g_bFortezzaInstalled = FALSE;
BOOL g_bCheckedForFortezza = FALSE;
BOOL g_bAttemptedFortezzaLogin = FALSE;

CRYPT_INSTALL_DEFAULT_CONTEXT_FN g_CryptInstallDefaultContext = NULL;
CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN g_CryptUninstallDefaultContext = NULL;
CERT_FIND_CHAIN_IN_STORE_FN g_CertFindChainInStore = NULL;
CERT_FREE_CERTIFICATE_CHAIN_FN g_CertFreeCertificateChain = NULL;

#define LOCK_FORTEZZA()   EnterCriticalSection( &InitFortezzaLock )
#define UNLOCK_FORTEZZA() LeaveCriticalSection( &InitFortezzaLock )

DWORD
LoadWinTrust(
    VOID
    )

/*++

Routine Description:

    This function loads the WinTrust.DLL and binds a pointer to a function
    that is needed in the WinTrust DLL.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD error = ERROR_SUCCESS;

    LOCK_SECURITY();

    if( hWinTrust == NULL )
    {
        LPSTR lpszDllFileName = WINTRUST_DLLNAME;
        pWinVerifyTrust = NULL;

        //
        // Load the DLL
        //

        hWinTrust       = LoadLibrary(lpszDllFileName);

        if ( hWinTrust )
        {
            pWinVerifyTrust = (WIN_VERIFY_TRUST_FN)
                            GetProcAddress(hWinTrust, WIN_VERIFY_TRUST_NAME);
            pWTHelperProvDataFromStateData = (WT_HELPER_PROV_DATA_FROM_STATE_DATA_FN)
                            GetProcAddress(hWinTrust, WT_HELPER_PROV_DATA_FROM_STATE_DATA_NAME);
        }


        if ( !hWinTrust || !pWinVerifyTrust )
        {
            error = GetLastError();

            if ( error == ERROR_SUCCESS )
            {
                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        }
        {
            // To show SGC certificates we need to do some special magic (see schnlui.cxx) which 
            // depends on some fixes in Wintrust.dll. We have 
            // Figure out the version info for WinTrust.dll
            TCHAR rgchWinTrustFileName[MAX_PATH];
            
            g_fDoSpecialMagicForSGCCerts = FALSE;

            if (GetModuleFileName(hWinTrust, rgchWinTrustFileName, ARRAY_ELEMENTS(rgchWinTrustFileName)) != 0)
            {
                DWORD cbFileVersionBufSize;
                DWORD dwTemp = 0;

                if ((cbFileVersionBufSize = GetFileVersionInfoSize(rgchWinTrustFileName, &dwTemp)) != 0)
                {
                    BYTE* pVerBuffer = NULL;

                    pVerBuffer = (BYTE *) _alloca(cbFileVersionBufSize);
                     
                    if ( (pVerBuffer != NULL) && 
                         (GetFileVersionInfo(rgchWinTrustFileName, 0, cbFileVersionBufSize, pVerBuffer) != 0))
                    {
                        VS_FIXEDFILEINFO *lpVSFixedFileInfo;
                        unsigned uiLength;

                        if( VerQueryValue( pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) != 0
                            && uiLength != 0)
                        {
                            // NT5 Beta3 wintrust version is 5.131.2001.0 which is the Min version we need.
                            // 0x50083 ==> 5.131
                            // 0x7db0000 ==> 2001.0
                            if ((lpVSFixedFileInfo->dwFileVersionMS > 0x50083) 
                                || (lpVSFixedFileInfo->dwFileVersionMS == 0x50083 && lpVSFixedFileInfo->dwFileVersionLS >= 0x07db0000))
                                g_fDoSpecialMagicForSGCCerts = TRUE;
                        }
                    }
                }
            }
        }
            
    }

    INET_ASSERT(pWinVerifyTrust);


    if ( error != ERROR_SUCCESS )
    {
        if (hWinTrust)
        {
            FreeLibrary(hWinTrust);
            hWinTrust = NULL;
        }
    }

    UNLOCK_SECURITY();

    return error;
}



VOID
SecurityInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    InitializeCriticalSection( &InitializationSecLock );
    InitializeCriticalSection( &InitFortezzaLock );
}

VOID
SecurityTerminate(
    VOID
    )
/*++

Routine Description:

    This function Deletes the global lock required for the security
    pkgs.

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/
{
    DeleteCriticalSection(&InitializationSecLock);
    DeleteCriticalSection(&InitFortezzaLock);
}


VOID
UnloadSecurity(
    VOID
    )

/*++

Routine Description:

    This function terminates the global data required for the security
    pkgs and dynamically unloads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.

--*/

{
    DWORD i;

    LOCK_SECURITY();

    //
    //  free all security pkg credential handles
    //

    for (i = 0; SecProviders[i].pszName != NULL; i++) {
         if (SecProviders[i].fEnabled)  {
             if (SecProviders[i].pCertCtxt == NULL && !IsCredClear(SecProviders[i].hCreds)) {
                // Beta1 Hack. Because of some circular dependency between dlls
                // both crypt32 and schannel's PROCESS_DETACH gets called before wininet.
                // This is catastrophic if we have a cert context attached to the credentials
                // handle. In this case we will just leak the handle since the process is dying
                // anyway. We really need to fix this.
                g_FreeCredentialsHandle(&SecProviders[i].hCreds);
            }
         }
#if 0 // See comments above.
         if (SecProviders[i].pCertCtxt != NULL) {
            CertFreeCertificateContext(SecProviders[i].pCertCtxt);
            SecProviders[i].pCertCtxt = NULL;
        }
#endif

    }

    //
    // close cert store. Protect against fault if DLL already unloaded
    //

    __try {
        if (g_hMyCertStore != NULL) {
            CertCloseStore(g_hMyCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    ENDEXCEPT
    g_hMyCertStore = NULL;
    g_bOpenMyCertStore = FALSE;

    // IMPORTANT : Don't free GlobalFortezzaCryptProv. When we free the cert context
    // from the SecProviders[] array above it gets freed automatically.
    if (GlobalFortezzaCryptProv != NULL)
    {
        GlobalFortezzaCryptProv = NULL;
    }


    //
    // unload dll
    //

    if (hSecurity != NULL) {
        FreeLibrary(hSecurity);
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

}

//  
DWORD
ReopenMyCertStore(
        VOID
        )
{
    DWORD Error = ERROR_SUCCESS;
    LOCK_SECURITY();

    if (g_hMyCertStore == NULL) {

        //
        // CRYPT32.DLL is delayloaded. Need SEH in case it fails
        //

        __try {
            g_hMyCertStore = CertOpenSystemStore(0, "MY");
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Error = GetLastError();
        }
        ENDEXCEPT
    }

    UNLOCK_SECURITY();
    return Error;

}

DWORD
CloseMyCertStore(
	VOID
	)
{
    DWORD Error = ERROR_SUCCESS;

    LOCK_SECURITY();

    //
    // close cert store. Protect against fault if DLL already unloaded
    //

    __try {
        if (g_hMyCertStore != NULL) {
            CertCloseStore(g_hMyCertStore, CERT_CLOSE_STORE_FORCE_FLAG);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
    ENDEXCEPT
    g_hMyCertStore = NULL;
	
	UNLOCK_SECURITY();
	return Error;
}

DWORD
LoadSecurity(
    VOID
    )
/*++

Routine Description:

    This function dynamically loads security APIs from security.dll (NT)
    or secur32.dll (WIN95).

Arguments:

    NONE.

Return Value:

    WINDOWS Error Code.
--*/
{
    DWORD Error = ERROR_SUCCESS;
    INITSECURITYINTERFACE pfInitSecurityInterface = NULL;

    LOCK_SECURITY();

    if (g_hMyCertStore == NULL) {

        //
        // CRYPT32.DLL is delayloaded. Need SEH in case it fails
        //

        __try {
            g_hMyCertStore = CertOpenSystemStore(0, "MY");
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            Error = GetLastError();
        }
        ENDEXCEPT
    }
    if( g_hMyCertStore != NULL)
        g_bOpenMyCertStore = TRUE; 

    if (Error == ERROR_SUCCESS) {
        Error = LoadWinTrust();
    }
    if ( Error != ERROR_SUCCESS )
    {
        goto quit;
    }

    if( hSecurity != NULL )
    {
        goto quit;
    }

        //
        // load dll.
        //

       //
       // This is better for performance. Rather than call through
       //    SSPI, we go right to the DLL doing the work.
       //

       hSecurity = LoadLibrary( "schannel" );

        if ( hSecurity == NULL ) {
            Error = GetLastError();
            goto quit;
        }

        //
        // get function addresses.
        //

#ifdef UNICODE
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceW" );
#else
        pfInitSecurityInterface =
            (INITSECURITYINTERFACE) GetProcAddress( hSecurity,
                                                     "InitSecurityInterfaceA" );
#endif


        if ( pfInitSecurityInterface == NULL )
        {
             Error = GetLastError();
             goto quit;
        }

    //
    // Get SslCrackCertificate func pointer,
    //  utility function declared in SCHANNEL that
    //  is used for parsing X509 certificates.
    //

        pSslCrackCertificate =
            (SSL_CRACK_CERTIFICATE_FN) GetProcAddress( hSecurity,
                                                     SSL_CRACK_CERTIFICATE_NAME );


    if ( pSslCrackCertificate == NULL )
    {
        Error = GetLastError();
        goto quit;
    }



        pSslFreeCertificate =
            (SSL_FREE_CERTIFICATE_FN) GetProcAddress( hSecurity,
                                                     SSL_FREE_CERTIFICATE_NAME );


    if ( pSslFreeCertificate == NULL )
    {
        Error = GetLastError();
        goto quit;
    }

    GlobalSecFuncTable = (SecurityFunctionTable*) ((*pfInitSecurityInterface) ());

    if ( GlobalSecFuncTable == NULL ) {
         Error = GetLastError(); // BUGBUG does this work?
         goto quit;
    }

    HMODULE hCrypt32;
    hCrypt32 = GetModuleHandle("crypt32");

    INET_ASSERT(hCrypt32 != NULL);

    // We don't error out here because not finding these entry points
    // just affects Fortezza. The rest will still work fine.
    if (hCrypt32)
    {
        if (FALSE == GlobalPlatformVersion5)
        {
            TCHAR rgchCrypt32FileName[MAX_PATH];

            g_fDoSpecialMagicForSGCCerts = FALSE;

            if (GetModuleFileName(hCrypt32, rgchCrypt32FileName, ARRAY_ELEMENTS(rgchCrypt32FileName)) != 0)
            {
                DWORD cbFileVersionBufSize;
                DWORD dwTemp = 0;

                if ((cbFileVersionBufSize = GetFileVersionInfoSize(rgchCrypt32FileName, &dwTemp)) != 0)
                {
                    BYTE* pVerBuffer = NULL;

                    pVerBuffer = (BYTE *) _alloca(cbFileVersionBufSize);
                 
                    if ( (pVerBuffer != NULL) && 
                         (GetFileVersionInfo(rgchCrypt32FileName, 0, cbFileVersionBufSize, pVerBuffer) != 0))
                    {
                        VS_FIXEDFILEINFO *lpVSFixedFileInfo;
                        unsigned uiLength;

                        if( VerQueryValue( pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) != 0
                            && uiLength != 0)
                        {
                            // Crypt32.dll version is 5.131.1877.9 which is the Min version we need.
                            // 0x50083 ==> 5.131
                            // 0x07550009 ==> 1877.9
                            if ((lpVSFixedFileInfo->dwFileVersionMS > 0x50083) 
                                || (lpVSFixedFileInfo->dwFileVersionMS == 0x50083 && lpVSFixedFileInfo->dwFileVersionLS >= 0x07550009))
                                g_fDoSpecialMagicForSGCCerts = TRUE;
                        }
                    }
                }
            }
        }

        g_CryptInstallDefaultContext = (CRYPT_INSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_INSTALL_DEFAULT_CONTEXT_NAME);

        g_CryptUninstallDefaultContext = (CRYPT_UNINSTALL_DEFAULT_CONTEXT_FN)
                                    GetProcAddress(hCrypt32, CRYPT_UNINSTALL_DEFAULT_CONTEXT_NAME);

        g_CertFindChainInStore = (CERT_FIND_CHAIN_IN_STORE_FN)
                                    GetProcAddress(hCrypt32, CERT_FIND_CHAIN_IN_STORE_NAME);

        g_CertFreeCertificateChain = (CERT_FREE_CERTIFICATE_CHAIN_FN)
                                    GetProcAddress(hCrypt32, CERT_FREE_CERTIFICATE_CHAIN_NAME);
    }

quit:

    if ( Error != ERROR_SUCCESS )
    {
        FreeLibrary( hSecurity );
        hSecurity = NULL;
    }

    UNLOCK_SECURITY();

    return( Error );
}



// Fortezza related functionality.


//Private functions used by the Fortezza implementation.
static PCCERT_CONTEXT GetCurrentFortezzaCertContext();
static BOOL SetCurrentFortezzaCertContext(PCCERT_CONTEXT);
static DWORD AcquireFortezzaCryptProv(HWND, HCRYPTPROV *);
static DWORD ReleaseFortezzaCryptProv(HCRYPTPROV, BOOL);
static DWORD AcquireFortezzaCertContext(HCRYPTPROV, PCCERT_CONTEXT*);


// Should we do anything regarding Fortezza.
BOOL IsFortezzaInstalled ( )
{
    LOCK_FORTEZZA( );

    if (!g_bCheckedForFortezza)
    {
        g_bCheckedForFortezza = TRUE;
        g_bFortezzaInstalled = FALSE;

        // Try and get the Fortezza CSP context to see if it is present.
        HCRYPTPROV hCryptProv = NULL;
        if (GlobalEnableFortezza)
        {
            if (CryptAcquireContext(&hCryptProv, NULL, NULL, PROV_FORTEZZA, CRYPT_SILENT))
            {
                // Weird: we should not be allowed to get the context without putting up UI.
                // But we will assume Fortezza is enabled.
                g_bFortezzaInstalled = TRUE;
                CryptReleaseContext(hCryptProv, 0);
            }
            else
            {
                DWORD dwError = GetLastError();

                // If the last error was NTE_PROV_TYPE_NOT_DEF it means that Fortezza CSP is not
                // installed and we should not be trying to get a Fortezza context.
                g_bFortezzaInstalled = ((dwError != NTE_PROV_TYPE_NOT_DEF) && (dwError != NTE_PROV_TYPE_NO_MATCH));

            }
        }
    }

    UNLOCK_FORTEZZA( );

    return g_bFortezzaInstalled;
}


BOOL AttemptedFortezzaLogin( )
{
    BOOL bRet ;

    LOCK_FORTEZZA();
    bRet = g_bAttemptedFortezzaLogin;
    UNLOCK_FORTEZZA();

    return bRet;
}


// Log's on to the fortezza card. Returns success if you are already logged on.  
DWORD FortezzaLogOn(HWND hwnd)
{
    DWORD dwError;
    LOCK_FORTEZZA();

    // If we are already logged on, don't bother. Just succeed.
    if (GetCurrentFortezzaCertContext() != NULL)
    {
        INET_ASSERT(g_bAttemptedFortezzaLogin);
        INET_ASSERT(GlobalFortezzaCryptProv);
        dwError = ERROR_SUCCESS;
    }
    else
    {
        HCRYPTPROV hProv;
        g_bAttemptedFortezzaLogin = TRUE;

        INET_ASSERT(GlobalFortezzaCryptProv == NULL);

        dwError = AcquireFortezzaCryptProv(hwnd, &GlobalFortezzaCryptProv);

        if (dwError == ERROR_SUCCESS)
        {
            INET_ASSERT(GlobalFortezzaCryptProv != NULL);
            PCCERT_CONTEXT pCertContext = NULL;
            
            dwError = AcquireFortezzaCertContext(GlobalFortezzaCryptProv, &pCertContext);

            if (dwError == ERROR_SUCCESS)
            {
                //Logged in succesfully.
                SetCurrentFortezzaCertContext(pCertContext);
            }
        }
    
        if (dwError != ERROR_SUCCESS && GlobalFortezzaCryptProv != NULL)    
        {
            ReleaseFortezzaCryptProv(GlobalFortezzaCryptProv, FALSE);
            GlobalFortezzaCryptProv = NULL;
        }
        
    }

    if (dwError == ERROR_SUCCESS)
    {
        INET_ASSERT(GetCurrentFortezzaCertContext());
        INET_ASSERT(GlobalFortezzaCryptProv != NULL);
    } 
                   
    UNLOCK_FORTEZZA( );
    
    return dwError;                  

}


DWORD FortezzaLogOff(HWND /* hwnd */)
{
    LOCK_FORTEZZA();

    BOOL bGotCertContext = (GetCurrentFortezzaCertContext() != NULL);
    SetCurrentFortezzaCertContext(NULL);
    ReleaseFortezzaCryptProv(GlobalFortezzaCryptProv, bGotCertContext);
    GlobalFortezzaCryptProv = NULL;

    UNLOCK_FORTEZZA( );

    return ERROR_SUCCESS;
}


DWORD FortezzaChangePersonality(HWND hwnd)
{
    DWORD dwError = ERROR_SUCCESS;

    LOCK_FORTEZZA( );
    
    PCCERT_CONTEXT pOldCertContext = GetCurrentFortezzaCertContext( );
    
    if (pOldCertContext != NULL)
    {
        INET_ASSERT(GlobalFortezzaCryptProv != NULL);
        HCRYPTPROV hNewCryptProv = NULL;
        PCCERT_CONTEXT pNewCertContext = NULL;
        
        // For the change personality to work we need to get a new handle to a 
        // Fortezza crypt provider without freeing the old one. ,
        // If we free the old one first it will re-prompt the user for the password.

        dwError = AcquireFortezzaCryptProv(hwnd, &hNewCryptProv);
        if (dwError == ERROR_SUCCESS)
        {
            dwError = AcquireFortezzaCertContext(hNewCryptProv, &pNewCertContext);

            if (dwError == ERROR_SUCCESS)
            {
                // free up the old CryptProv context
                ReleaseFortezzaCryptProv(GlobalFortezzaCryptProv, TRUE);
                GlobalFortezzaCryptProv = hNewCryptProv;
                // This will automatically free the old cert context.
                SetCurrentFortezzaCertContext(pNewCertContext);
            }
            else 
            {
                ReleaseFortezzaCryptProv(hNewCryptProv, FALSE);
            }
        }
    }
    else
    {
        // We are trying to change personalities when not logged on.
        // This is not allowed.                         

        dwError = ERROR_INVALID_PARAMETER;
    }

    UNLOCK_FORTEZZA( );
    
    return dwError;
}


// Entry points exported outside wininet.
INTERNETAPI_(BOOL) InternetQueryFortezzaStatus(DWORD * pdwStatus, DWORD_PTR dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryFortezzaStatus",
                     "%#x %#x",
                     pdwStatus, dwReserved
                     ));

    BOOL bRet;
    DWORD dwError = ERROR_SUCCESS;

    // Initialize the GlobalData since this is an exported entry point.
    if (dwReserved!=0)
    {
        dwError = ERROR_INVALID_PARAMETER;
    }
    else if (!GlobalDataInitialized)
    {
        dwError = GlobalDataInitialize( );
    }
    
    if (dwError != ERROR_SUCCESS)
    {
        bRet = FALSE;
    }
    else if (pdwStatus == NULL)
    {
        bRet = FALSE;
        dwError = ERROR_INVALID_PARAMETER;
    }
    else
    {
        if (IsFortezzaInstalled( ))
        {
            *pdwStatus |= (FORTSTAT_INSTALLED);
        }
        
        if (GetCurrentFortezzaCertContext() != NULL)
        {
            *pdwStatus |= (FORTSTAT_LOGGEDON);
        }
        bRet = TRUE;
    }

    if (!bRet)
    {
        SetLastError(dwError);
        DEBUG_ERROR(INET, dwError);
    }
    DEBUG_LEAVE_API(bRet);
    return bRet;
}
                        

INTERNETAPI_(BOOL) InternetFortezzaCommand(DWORD dwCommand, HWND hwnd, DWORD_PTR dwReserved)
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetFortezzaCommand",
                     "%d, %#x, %#x",
                     dwCommand, hwnd, dwReserved
                     ));

    BOOL bRet = TRUE;
    DWORD dwError = ERROR_SUCCESS;

    // Initialize the GlobalData since this is an exported entry point.
    if (dwReserved!=0)
    {
        dwError = ERROR_INVALID_PARAMETER;
    }
    else if (!GlobalDataInitialized)
    {
        dwError = GlobalDataInitialize( );
    }
    
    // Next make sure that the security dlls are loaded.
    if (dwError == ERROR_SUCCESS)
        dwError = LoadSecurity( );

    // If all is fine, then try the actual command.
    if (dwError == ERROR_SUCCESS)
    {
        // Dispatch based on the command.
        switch (dwCommand) 
        {
            case FORTCMD_LOGON:
                dwError = FortezzaLogOn(hwnd);
                break;
            case FORTCMD_LOGOFF:
                dwError = FortezzaLogOff(hwnd);
                break;
            case FORTCMD_CHG_PERSONALITY:
                dwError = FortezzaChangePersonality(hwnd);
                break;
            default:
                dwError = ERROR_INVALID_PARAMETER;
        }
    }            

    if (dwError != ERROR_SUCCESS)
    {
        bRet = FALSE;
        DEBUG_ERROR(INET, dwError);
        SetLastError(dwError);
    }
    else
    {
        LOCK_SECURITY( );

        // If we were successful to this point we should re-init the security packages so 
        // we acquire a credentials handle with the new cert context selected correctly.

        // The Last error will be set by SecurityPkgInitialize if it fails.
        bRet = SecurityPkgInitialize(TRUE);

        UNLOCK_SECURITY( );
    }

    DEBUG_LEAVE_API(bRet);
    return bRet;
}



/*++
    Gets the cert context being used for Fortezza connections.
    
Routine description
    
Returns:

    pCertContext if one is in use. NULL otherwise.
*/            
    
PCCERT_CONTEXT GetCurrentFortezzaCertContext()
{
    PCCERT_CONTEXT pCertContext = NULL;
    DWORD dwIndex;

    LOCK_FORTEZZA( );

    // Find the unified service provider entry.
    for ( dwIndex = 0 ; SecProviders[dwIndex].pszName != NULL ; dwIndex++ )
    {
        if (0 == stricmp(UNISP_NAME, SecProviders[dwIndex].pszName))
        {
            pCertContext = SecProviders[dwIndex].pCertCtxt ;

            break;
        }
    }
    // Something is wrong if we didn't find the Unified Service provider in our list.

    INET_ASSERT(SecProviders[dwIndex].pszName != NULL);

    UNLOCK_FORTEZZA( );
    
    return pCertContext;
}

               
/*++
    Sets the passed in cert context to be the one that is used for Fortezza 
    connections.
    
Routine description
    This function simply takes a Fortezza context and remembers it on the unified 
    secure providers table. 
    
Arguments:

    pCertContext - The cert context to be saved away.
*/            

BOOL SetCurrentFortezzaCertContext(PCCERT_CONTEXT pCertContext)
{
    DWORD dwIndex;

    LOCK_FORTEZZA( );

    // Find the unified service provider entry.
    for ( dwIndex = 0 ; SecProviders[dwIndex].pszName != NULL ; dwIndex++ )
    {
        if (0 == stricmp(UNISP_NAME, SecProviders[dwIndex].pszName))
        {
            if (SecProviders[dwIndex].pCertCtxt)
                CertFreeCertificateContext(SecProviders[dwIndex].pCertCtxt);

            SecProviders[dwIndex].pCertCtxt = pCertContext;

            break;
        }
    }
    
    // Something is wrong if we didn't find the Unified Service provider in our list.

    INET_ASSERT(SecProviders[dwIndex].pszName != NULL);

    UNLOCK_FORTEZZA( );

    return TRUE;
}



/*++
    Acquire a fortezza crypt provider.

Routine Description
    This function calls the Fortezza CSP which might prompt the end-user for 
    the PIN # to read the certificates of the Fortezza card. If the user is 
    already logged on to the card the logon UI will not be shown. 

Arguments:

    hwnd - used to put up the pin UI.

    pCryptProv - returns a handle to a crypt provider if succesful.

Return Value:
    
    WINDOWS Error Code.

--*/
DWORD AcquireFortezzaCryptProv(HWND hwnd, HCRYPTPROV *pCryptProv)
{
    DWORD dwError = NOERROR;
    BOOL bResethwnd = FALSE;

    if (pCryptProv == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    // Set up to do the UI.

    if ( CryptSetProvParam(NULL, PP_CLIENT_HWND, (BYTE *)&hwnd, 0))
    {
        bResethwnd = TRUE;
    }

    //
    // Attempt to log on to Fortezza card. This call will typically
    // display a dialog box.
    //
    // Note that within the CryptAcquireContext function, the Fortezza
    // CSP populated the MY store with the Fortezza certificate chain.
    // At least, it will once it's finished.
    //

    if(!CryptAcquireContext(pCryptProv, NULL, NULL, PROV_FORTEZZA, 0))
    {
        dwError = GetLastError();
    }

    if (bResethwnd)
    {
        CryptSetProvParam(NULL, PP_CLIENT_HWND, NULL, 0);
    }

    return(dwError);
}        


/*++
    Releases the Fortezza Crypt Provider

Routine Description:
    Frees the crypt provider if the second argument is FALSE. 
    Does nothing if the second argument is TRUE.
    The crypto API has this strange behavior ( i am being gracious 
    in my description here) where when a hCryptProv is passed into 
    CertSetCertificateContextProperty it holds on to the pointer but does not increment the 
    refcount. When the cert context is freed it does free the hCryptProv. 
    To workaround this behavior we never free the hCryptProv, just the Fortezza cert context.

Arguments:
    hCryptProv - The CryptProv to free.
    bGotCertContext - did we get a Fortezza Cert Context using this provider. 
**/

DWORD ReleaseFortezzaCryptProv(HCRYPTPROV hCryptProv, BOOL bGotCertContext )
{
    DWORD dwError;

    if (hCryptProv==NULL)
    {
        dwError = NOERROR;
    }
    else
    {
        if (!CryptReleaseContext(hCryptProv, 0))
            dwError = GetLastError();
        else
            dwError = NOERROR;
    }

    return dwError;
}
        


DWORD AcquireFortezzaCertContext(HCRYPTPROV hFortezzaCryptProv, PCCERT_CONTEXT *ppCertContext)                                               
/*++

Routine Description:

    This function calls the Fortezza CSP which will prompt the
    user for the PIN # to read the certificates off the Fortezza
    card.

Arguments:

    [IN]    hCryptProv - Handle to the Fortezza Crypt Provider.
    [OUT]   ppCertContext - will have the cert context if returns succesfully.
Return Value:

    WINDOWS Error Code.

--*/
{
    DWORD error = ERROR_SUCCESS;   // Return code.
    DWORD status = ERROR_SUCCESS;  // Error value if one of the crypto APIs failed.
    CRYPT_HASH_BLOB HashBlob;
    BYTE            rgbHash[20];
    DWORD           cbHash;
    PBYTE           pbChain = NULL;
    DWORD           cbChain;
    PBYTE           pbCert;
    DWORD           cbCert;
    PCCERT_CONTEXT  pCertContext = NULL;
    BOOL            bResethwnd = FALSE;
    DWORD           dwIndex;

    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "AcquireFortezzaContext",
                 "%#x",
                 hFortezzaCryptProv
                 ));

    if (hFortezzaCryptProv == NULL || ppCertContext == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    LOCK_FORTEZZA();

    if (!IsFortezzaInstalled( ))
    {
        INET_ASSERT(FALSE); // Should not get called if Fortezza is not installed.
        goto done;       // Just ignore the request.
    }


    if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
        ReopenMyCertStore();

    if(g_hMyCertStore == NULL)
    {
        status = SEC_E_NO_CREDENTIALS;
        goto done;
    }

    //
    // Read the appropriate leaf certificate from the card, and
    // obtain its MD5 thumbprint.
    //

    // Get length of certificate chain.
    if(!CryptGetProvParam(hFortezzaCryptProv, PP_CERTCHAIN, NULL, &cbChain, 0))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x reading certificate from CSP\n",
                    status
                    ));
        goto done;
    }

    // Allocate memory for certificate chain.
    pbChain = (BYTE *)ALLOCATE_MEMORY(LMEM_FIXED | LMEM_ZEROINIT, cbChain);
    if(pbChain == NULL)
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Out of memory\n"));
        goto done;
    }

    // Download certificate chain from CSP.
    if(!CryptGetProvParam(hFortezzaCryptProv, PP_CERTCHAIN, pbChain, &cbChain, 0))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x reading certificate from CSP\n",
                    status
                    ));
        goto done;
    }

    // Parse out the leaf certificate.
    cbCert = *(PDWORD)pbChain;
    pbCert = pbChain + sizeof(DWORD);

    // Decode the leaf certificate.
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                pbCert,
                                                cbCert);
    if(pCertContext == NULL)
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x parsing certificate\n",
                    status
                    ));
        goto done;
    }

    // Get thumbprint of certificate.
    cbHash = sizeof(rgbHash);
    if(!CertGetCertificateContextProperty(pCertContext,
                                          CERT_MD5_HASH_PROP_ID,
                                          rgbHash,
                                          &cbHash))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x reading MD5 property\n",
                    status
                    ));
        goto done;
    }

    // Free certificate chain.
    FREE_MEMORY(pbChain);
    pbChain = NULL;

    // Free certificate context.
    CertFreeCertificateContext(pCertContext);
    pCertContext = NULL;


    //
    // Search the "MY" certificate store for the certificate with
    // the matching thumbprint.
    //

    HashBlob.cbData = cbHash;
    HashBlob.pbData = rgbHash;
    if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
        ReopenMyCertStore();
    pCertContext = CertFindCertificateInStore(g_hMyCertStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_MD5_HASH,
                                              &HashBlob,
                                              NULL);
    if(pCertContext == NULL)
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Leaf certificate not found in MY store\n"));

        status = SEC_E_NO_CREDENTIALS;
        goto done;
    }


    //
    // Attach the Fortezza hProv to the certificate context.
    //

    if(!CertSetCertificateContextProperty(
            pCertContext,
            CERT_KEY_PROV_HANDLE_PROP_ID,
            0,
            (PVOID)hFortezzaCryptProv))
    {
        status = GetLastError();
        DEBUG_PRINT(API,
                    ERROR,
                    ("**** Error 0x%x setting KEY_PROV_HANDLE property\n",
                    status
                    ));
        goto done;
    }


    INET_ASSERT(pCertContext != NULL);

    *ppCertContext = pCertContext;
    pCertContext = NULL;

    status = SEC_E_OK;

done:

    if(pbChain) FREE_MEMORY(pbChain);
    if(pCertContext) CertFreeCertificateContext(pCertContext);

    UNLOCK_FORTEZZA();
    DEBUG_LEAVE(error);
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\serialst.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    serialst.cxx

Abstract:

    Functions to deal with a serialized list. These are replaced by macros in
    the retail version

    Contents:
        [InitializeSerializedList]
        [TerminateSerializedList]
        [LockSerializedList]
        [UnlockSerializedList]
        [InsertAtHeadOfSerializedList]
        [InsertAtTailOfSerializedList]
        [RemoveFromSerializedList]
        [IsSerializedListEmpty]
        [HeadOfSerializedList]
        [TailOfSerializedList]
        [CheckEntryOnSerializedList]
        [(CheckEntryOnList)]
        SlDequeueHead
        SlDequeueTail
        IsOnSerializedList

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win-32 user level

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>

#if INET_DEBUG

//
// manifests
//

#define SERIALIZED_LIST_SIGNATURE   'tslS'

//
// private prototypes
//

PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    );

//
// data
//

BOOL fCheckEntryOnList = FALSE;
BOOL ReportCheckEntryOnListErrors = FALSE;

//
// functions
//


DEBUG_FUNCTION
VOID
InitializeSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    initializes a serialized list

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);

    SerializedList->Signature = SERIALIZED_LIST_SIGNATURE;
    SerializedList->LockCount = 0;

    INITIALIZE_RESOURCE_INFO(&SerializedList->ResourceInfo);

    InitializeListHead(&SerializedList->List);
    SerializedList->ElementCount = 0;
    InitializeCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
TerminateSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Undoes InitializeSerializeList

Arguments:

    SerializedList  - pointer to serialized list to terminate

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList != NULL);
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ElementCount == 0);

    if (SerializedList->ElementCount != 0) {

        DEBUG_PRINT(SERIALST,
                    ERROR,
                    ("list @ %#x has %d elements, first is %#x\n",
                    SerializedList,
                    SerializedList->ElementCount,
                    SerializedList->List.Flink
                    ));

    } else {

        INET_ASSERT(IsListEmpty(&SerializedList->List));

    }
    DeleteCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
LockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Acquires a serialized list locks

Arguments:

    SerializedList  - SERIALIZED_LIST to lock

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->LockCount >= 0);

    EnterCriticalSection(&SerializedList->Lock);
    if (SerializedList->LockCount != 0) {

        INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());

    }
    ++SerializedList->LockCount;
    SerializedList->ResourceInfo.Tid = GetCurrentThreadId();
}


DEBUG_FUNCTION
VOID
UnlockSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Releases a serialized list lock

Arguments:

    SerializedList  - SERIALIZED_LIST to unlock

Return Value:

    None.

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);
    INET_ASSERT(SerializedList->ResourceInfo.Tid == GetCurrentThreadId());
    INET_ASSERT(SerializedList->LockCount > 0);

    --SerializedList->LockCount;
    LeaveCriticalSection(&SerializedList->Lock);
}


DEBUG_FUNCTION
VOID
InsertAtHeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, FALSE);
    }
    InsertHeadList(&SerializedList->List, Entry);
    ++SerializedList->ElementCount;

    INET_ASSERT(SerializedList->ElementCount > 0);

    UnlockSerializedList(SerializedList);
}


DEBUG_FUNCTION
VOID
InsertAtTailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Adds an item to the head of a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to update

    Entry           - thing to update it with

Return Value:

    None.

--*/

{
    INET_ASSERT(Entry != &SerializedList->List);

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, FALSE);
    }
    InsertTailList(&SerializedList->List, Entry);
    ++SerializedList->ElementCount;

    INET_ASSERT(SerializedList->ElementCount > 0);

    UnlockSerializedList(SerializedList);
}


VOID
DEBUG_FUNCTION
RemoveFromSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Removes the entry from a serialized list

Arguments:

    SerializedList  - SERIALIZED_LIST to remove entry from

    Entry           - pointer to entry to remove

Return Value:

    None.

--*/

{
    INET_ASSERT((Entry->Flink != NULL) && (Entry->Blink != NULL));

    LockSerializedList(SerializedList);
    if (fCheckEntryOnList) {
        CheckEntryOnList(&SerializedList->List, Entry, TRUE);
    }

    INET_ASSERT(SerializedList->ElementCount > 0);

    RemoveEntryList(Entry);
    --SerializedList->ElementCount;
    Entry->Flink = NULL;
    Entry->Blink = NULL;
    UnlockSerializedList(SerializedList);
}


DEBUG_FUNCTION
BOOL
IsSerializedListEmpty(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Checks if a serialized list contains any elements

Arguments:

    SerializedList  - pointer to list to check

Return Value:

    BOOL

--*/

{
    LockSerializedList(SerializedList);

    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    BOOL empty;

    if (IsListEmpty(&SerializedList->List)) {

        INET_ASSERT(SerializedList->ElementCount == 0);

        empty = TRUE;
    } else {

        INET_ASSERT(SerializedList->ElementCount != 0);

        empty = FALSE;
    }

    UnlockSerializedList(SerializedList);

    return empty;
}


DEBUG_FUNCTION
PLIST_ENTRY
HeadOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Flink;
}


DEBUG_FUNCTION
PLIST_ENTRY
TailOfSerializedList(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Returns the element at the tail of the list, without taking the lock

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

Return Value:

    PLIST_ENTRY
        pointer to element at tail of list

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    return SerializedList->List.Blink;
}


DEBUG_FUNCTION
BOOL
CheckEntryOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )

/*++

Routine Description:

    Checks an entry exists (or doesn't exist) on a list

Arguments:

    SerializedList  - pointer to serialized list

    Entry           - pointer to entry

    ExpectedResult  - TRUE if expected on list, else FALSE

Return Value:

    BOOL
        TRUE    - expected result

        FALSE   - unexpected result

--*/

{
    INET_ASSERT(SerializedList->Signature == SERIALIZED_LIST_SIGNATURE);

    LockSerializedList(SerializedList);

    BOOL result;

    __try {
        result = CheckEntryOnList(&SerializedList->List, Entry, ExpectedResult);
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(SERIALST,
                    FATAL,
                    ("List @ %#x (%d elements) is bad\n",
                    SerializedList,
                    SerializedList->ElementCount
                    ));

        result = FALSE;
    }
    ENDEXCEPT
    UnlockSerializedList(SerializedList);

    return result;
}


PRIVATE
DEBUG_FUNCTION
BOOL
CheckEntryOnList(
    IN PLIST_ENTRY List,
    IN PLIST_ENTRY Entry,
    IN BOOL ExpectedResult
    )
{
    BOOLEAN found = FALSE;
    PLIST_ENTRY p;

    if (!IsListEmpty(List)) {
        for (p = List->Flink; p != List; p = p->Flink) {
            if (p == Entry) {
                found = TRUE;
                break;
            }
        }
    }
    if (found != ExpectedResult) {
        if (ReportCheckEntryOnListErrors) {

            LPSTR description;

            description = found
                        ? "Entry %#x already on list %#x\n"
                        : "Entry %#x not found on list %#x\n"
                        ;

            DEBUG_PRINT(SERIALST,
                        ERROR,
                        (description,
                        Entry,
                        List
                        ));

            DEBUG_BREAK(SERIALST);

        }
        return FALSE;
    }
    return TRUE;
}

#endif // INET_DEBUG

//
// functions that are always functions
//


LPVOID
SlDequeueHead(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the head of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            entry = (LPVOID)HeadOfSerializedList(SerializedList);
            RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
        } else {
            entry = NULL;
        }
        UnlockSerializedList(SerializedList);
    } else {
        entry = NULL;
    }
    return entry;
}


LPVOID
SlDequeueTail(
    IN LPSERIALIZED_LIST SerializedList
    )

/*++

Routine Description:

    Dequeues the element at the tail of the queue and returns its address or
    NULL if the queue is empty

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST to dequeue from

Return Value:

    LPVOID

--*/

{
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            entry = (LPVOID)TailOfSerializedList(SerializedList);
            RemoveFromSerializedList(SerializedList, (PLIST_ENTRY)entry);
        } else {
            entry = NULL;
        }
        UnlockSerializedList(SerializedList);
    } else {
        entry = NULL;
    }
    return entry;
}


BOOL
IsOnSerializedList(
    IN LPSERIALIZED_LIST SerializedList,
    IN PLIST_ENTRY Entry
    )

/*++

Routine Description:

    Checks if an entry is on a serialized list. Useful to call before
    RemoveFromSerializedList() if multiple threads can remove the element

Arguments:

    SerializedList  - pointer to SERIALIZED_LIST

    Entry           - pointer to element to check

Return Value:

    BOOL
        TRUE    - Entry is on SerializedList

        FALSE   -   "    " not on     "

--*/

{
    BOOL onList = FALSE;
    LPVOID entry;

    if (!IsSerializedListEmpty(SerializedList)) {
        LockSerializedList(SerializedList);
        if (!IsSerializedListEmpty(SerializedList)) {
            for (PLIST_ENTRY entry = HeadOfSerializedList(SerializedList);
                entry != (PLIST_ENTRY)SlSelf(SerializedList);
                entry = entry->Flink) {

                if (entry == Entry) {
                    onList = TRUE;
                    break;
                }
            }
        }
        UnlockSerializedList(SerializedList);
    }
    return onList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\vdhcpapi.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    vdhcpapi.h

Abstract:

    Worker functions for VDHCP APIs.

Author:

    Madan Appiah (madana)  28-May-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#define DHCP_QUERY_INFO             1
#define DHCP_RENEW_IPADDRESS        2
#define DHCP_RELEASE_IPADDRESS      3

typedef struct _DHCP_NIC_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
    DWORD IpAddress;
    DWORD Lease;
    DWORD LeaseObtainedTime;
    DWORD LeaseExpiresTime;
    DWORD DhcpServerAddress;
    DWORD DNSServersLen;
    DWORD OffsetDNSServers;
    DWORD DomainNameLen;
    DWORD OffsetDomainName;
} DHCP_NIC_INFO, *LPDHCP_NIC_INFO;

typedef struct _DHCP_HW_INFO {
    DWORD OffsetHardwareAddress;
    DWORD HardwareLength;
} DHCP_HW_INFO, *LPDHCP_HW_INFO;

typedef struct _DHCP_QUERYINFO {
    DWORD NumNICs;
    DHCP_NIC_INFO NicInfo[1];
} DHCP_QUERYINFO, *LPDHCP_QUERYINFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\servinfo.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    servinfo.cxx

Abstract:

    Class implementation for global server info list

    Contents:
        GetServerInfo
        FindServerInfo
        FindNearestServer
        ReleaseServerInfo
        PurgeServerInfoList
        PingServerInfoList
        LoadServerInfoDatabase
        SaveServerInfoDatabase
        CServerInfo::CServerInfo
        CServerInfo::~CServerInfo
        CServerInfo::Reference
        CServerInfo::Dereference
        CServerInfo::ResolveHostName
        CServerInfo::UpdateConnectTime
        CServerInfo::UpdateRTT
        CServerInfo::UpdateDownloadRate
        CServerInfo::UpdateUploadRate
        CServerInfo::GetConnection
        CFsm_GetConnection::RunSM
        CServerInfo::GetConnection_Fsm
        CServerInfo::ReleaseConnection
        CServerInfo::RemoveWaiter
        (CServerInfo::FindKeepAliveConnection)
        (CServerInfo::KeepAliveWaiters)
        (CServerInfo::RunOutOfConnections)
        (CServerInfo::UpdateConnectionLimit)
        CServerInfo::PurgeKeepAlives
        ContainingServerInfo

Author:

    Richard L Firth (rfirth) 07-Oct-1996

Revision History:

    07-Oct-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private macros
//

//#define CHECK_CONNECTION_COUNT() \
//    INET_ASSERT(!UnlimitedConnections() \
//        ? (TotalAvailableConnections() <= ConnectionLimit()) : TRUE)

#define CHECK_CONNECTION_COUNT()    /* NOTHING */

//#define RLF_DEBUG   1

#if INET_DEBUG
#ifdef RLF_DEBUG
#define DPRINTF dprintf
#else
#define DPRINTF (void)
#endif
#else
#define DPRINTF (void)
#endif

//
// functions
//


DWORD
GetServerInfo(
    IN LPSTR lpszHostName,
    IN DWORD dwServiceType,
    IN BOOL bDoResolution,
    OUT CServerInfo * * lplpServerInfo
    )

/*++

Routine Description:

    Finds or creates a CServerInfo entry

Arguments:

    lpszHostName    - pointer to server name to get info for

    dwServiceType   - type of service for which CServerInfo requested

    bDoResolution   - TRUE if we are to resolve host name

    lplpServerInfo  - pointer to created/found CServerInfo if successful

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create the CServerInfo

                  ERROR_INTERNET_NAME_NOT_RESOLVED
                    We were asked to resolve the name, but failed

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "GetServerInfo",
                 "%q, %s (%d), %B, %#x",
                 lpszHostName,
                 InternetMapService(dwServiceType),
                 dwServiceType,
                 bDoResolution,
                 lplpServerInfo
                 ));

    ICSTRING hostName(lpszHostName);
    CServerInfo * lpServerInfo;
    BOOL bCreated = FALSE;
    DWORD error = ERROR_SUCCESS;

    if (hostName.HaveString()) {
        hostName.MakeLowerCase();

        LPSTR lpszHostNameLower = hostName.StringAddress();

        LockSerializedList(&GlobalServerInfoList);

        lpServerInfo = FindServerInfo(lpszHostNameLower);

        if (lpServerInfo == NULL) {
            lpServerInfo = new CServerInfo(lpszHostNameLower,
                                           &error,
                                           dwServiceType
                                           );
            if (lpServerInfo != NULL) {
                if (error != ERROR_SUCCESS) {
                    delete lpServerInfo;
                    lpServerInfo = NULL;
                }
                else {
                    bCreated = TRUE;
                    // Reference this to keep it alive beyond the unlock/
                    lpServerInfo->Reference();
                }
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        UnlockSerializedList(&GlobalServerInfoList);
    } else {

        //
        // failed to create ICSTRING
        //

        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        lpServerInfo = NULL;
    }

    //
    // if we created a new CServerInfo and we are instructed to resolve the host
    // name then do it now, outside of the global server info list lock. This
    // operation may take some time
    //

    if (bDoResolution && (lpServerInfo != NULL)) {
        //error = lpServerInfo->ResolveHostName();
        if (error != ERROR_SUCCESS) {
            ReleaseServerInfo(lpServerInfo);
            lpServerInfo = NULL;
        }
    }

    *lplpServerInfo = lpServerInfo;

    DEBUG_LEAVE(error);

    return error;
}


CServerInfo *
FindServerInfo(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    Walks the server info list looking for the requested server

Arguments:

    lpszHostName    - pointer to server name to find (IN LOWER CASE!)

Return Value:

    CServerInfo *
        Success - pointer to found list entry

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "FindServerInfo",
                 "%q",
                 lpszHostName
                 ));

    DWORD hashHostName = CalculateHashValue(lpszHostName);

    CServerInfo * lpServerInfo;
    BOOL found = FALSE;

    LockSerializedList(&GlobalServerInfoList);

    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
        lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
        lpServerInfo = lpServerInfo->Next()) {

        if (lpServerInfo->Match(hashHostName, lpszHostName)) {
            found = TRUE;
            break;
        }
    }

    if (!found) 
    {
        lpServerInfo = NULL;
    }

    // Need to keep this alive beyond the lock.
    if (lpServerInfo)
    {
        lpServerInfo->Reference();
    }
    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(lpServerInfo);
    return lpServerInfo;
}


CServerInfo *
FindNearestServer(
    VOID
    )

/*++

Routine Description:

    Returns pointer to the CServerInfo which has the shortest connect time.
    Returned info is referenced, so caller must call ReleaseServerInfo() when
    done

Arguments:

    None.

Return Value:

    CServerInfo *
        Success - valid pointer

        Failure - NULL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "FindNearestServer",
                 NULL
                 ));

    CServerInfo * lpServerInfo;
    CServerInfo * lpsiResult = NULL;
    DWORD connectTime = (DWORD)-1;

    LockSerializedList(&GlobalServerInfoList);

    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
        lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
        lpServerInfo = lpServerInfo->Next()) {

        if (lpServerInfo->GetConnectTime() < connectTime) {
            lpsiResult = lpServerInfo;
            connectTime = lpServerInfo->GetConnectTime();
        }
    }

    // We used to reference this in the caller, which is a bad idea, since it 
    // can get deleted between unlocking the serialized list and getting to the addref.
    if(lpsiResult) 
    {
        lpsiResult->Reference();
    }

    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(lpsiResult);

    return lpsiResult;
}


VOID
ReleaseServerInfo(
    IN CServerInfo * lpServerInfo
    )

/*++

Routine Description:

    Release a CServerInfo by dereferencing it. If the reference count goes to
    zero, the CServerInfo will be destroyed

Arguments:

    lpServerInfo    - pointer to CServerInfo to release

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "ReleaseServerInfo",
                 "%#x [%q]",
                 lpServerInfo,
                 lpServerInfo->GetHostName()
                 ));

    lpServerInfo->Dereference();

    DEBUG_LEAVE(0);
}


VOID
PurgeServerInfoList(
    IN BOOL bForce
    )

/*++

Routine Description:

    Throw out any CServerInfo entries that have expired or any KEEP_ALIVE
    entries (for any CServerInfo) that have expired

Arguments:

    bForce  - TRUE if we forcibly remove entries which have not yet expired but
              which have a reference count of 1, else FALSE to remove only
              entries that have expired

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeServerInfoList",
                 "%B",
                 bForce
                 ));

    BOOL bActivate = FALSE;
    
    LockSerializedList(&GlobalServerInfoList);

    PLIST_ENTRY pEntry = HeadOfSerializedList(&GlobalServerInfoList);
    PLIST_ENTRY pPrevious = (PLIST_ENTRY)SlSelf(&GlobalServerInfoList);

    while (TRUE) {
        if (pEntry == (PLIST_ENTRY)SlSelf(&GlobalServerInfoList)) {
            break;
        }

        CServerInfo * pServerInfo;

        //pServerInfo = (CServerInfo *)pEntry;
        //pServerInfo = CONTAINING_RECORD(pEntry, CONNECTION_LIMIT, m_List);
        pServerInfo = ContainingServerInfo(pEntry);

        BOOL deleted = FALSE;

        if (pServerInfo->ReferenceCount() == 1) {
            if (bForce || pServerInfo->Expired()) {
//dprintf("purging server info entry for %q\n", pServerInfo->GetHostName());
                deleted = pServerInfo->Dereference();
            } else {
                pServerInfo->PurgeKeepAlives(PKA_NO_FORCE);
                bActivate = TRUE;
            }
        }
        if (!deleted) {
            pPrevious = pEntry;
        }
        pEntry = pPrevious->Flink;
    }

    UnlockSerializedList(&GlobalServerInfoList);

    if (bActivate && g_bHibernating)
    {
        InterruptSelect();
    }

    DEBUG_LEAVE(0);
}


VOID
PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Throw out any KEEP_ALIVE entries from any CServerInfo that have expired or
    which have failed authentication or which are unused, depending on dwForce

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "PurgeKeepAlives",
                 "%s [%d]",
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    LockSerializedList(&GlobalServerInfoList);

    PLIST_ENTRY pEntry = HeadOfSerializedList(&GlobalServerInfoList);

    while (pEntry != (PLIST_ENTRY)SlSelf(&GlobalServerInfoList)) {

        CServerInfo * lpServerInfo = ContainingServerInfo(pEntry);

        lpServerInfo->PurgeKeepAlives(dwForce);
        pEntry = pEntry->Flink;
    }

    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(0);
}

//
//DWORD
//PingServerInfoList(
//    OUT LPBOOL lpbUnreachable
//    )
//
///*++
//
//Routine Description:
//
//    Determines online/offline state by attempting to ping a known server address.
//    If any ping succeeds, this function succeeds. If all pings fail, then this
//    function fails
//
//    Assumes:    1. global ping object has been instantiated
//
//Arguments:
//
//    lpbUnreachable  - TRUE if one or more servers were unreachable (the network
//                      seems to be alive, just that we couldn't reach one or more
//                      servers. Useful to indicate that an address we are in the
//                      process of resolving is bad
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//                    at least one address pinged
//
//        Failure - ERROR_INTERNET_NO_KNOWN_SERVERS (internal)
//                    There are no known server addresses (there may be items in
//                    the list, but the addresses are not yet resolved)
//
//                  ERROR_INTERNET_PING_FAILED (internal)
//                    We have (resolved) addresses, but couldn't successfully ping
//                    any. We believe we have connectivity
//
//                  ERROR_INTERNET_NO_PING_SUPPORT (internal)
//                    We couldn't ping any addresses because ping support is not
//                    loaded, or globally disabled
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SOCKETS,
//                 Dword,
//                 "PingServerInfoList",
//                 "%#x",
//                 lpbUnreachable
//                 ));
//
//    DWORD error;
//
//    *lpbUnreachable = FALSE;
//
//    CServerInfo * lpServerInfo;
//
//    error = ERROR_INTERNET_NO_KNOWN_SERVERS;
//
//    LockSerializedList(&GlobalServerInfoList);
//
//    for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
//        lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
//        lpServerInfo = lpServerInfo->Next()) {
//
//        DWORD err;
//        DWORD dwIpAddress;
//        DWORD addressLength = sizeof(dwIpAddress);
//
//        //
//        // just use first address from each address list
//        //
//
//        err = DestinationAddressFromAddressList(lpServerInfo->GetAddressList(),
//                                                0,
//                                                (LPBYTE)&dwIpAddress,
//                                                &addressLength
//                                                );
//
//        INET_ASSERT(IS_VALID_NON_LOOPBACK_IP_ADDRESS(dwIpAddress));
//
//        if ((err == ERROR_SUCCESS)
//        && IS_VALID_NON_LOOPBACK_IP_ADDRESS(dwIpAddress)) {
//            error = Ping(dwIpAddress);
//            if (error == ERROR_SUCCESS) {
//
//                //
//                // ping succeeded, net is alive. All we need to know for now
//                //
//
//                lpServerInfo->SetReachable();
//                break;
//            } else if (error == ERROR_INTERNET_SERVER_UNREACHABLE) {
//
//                //
//                // our equivalent of net unreachable
//                //
//
//                lpServerInfo->SetUnreachable();
//                *lpbUnreachable = TRUE;
//
//                //
//                // although the server is unreachable, we still have
//                // connectivity (the ping would have failed completely
//                // otherwise)
//                //
//
//                error = ERROR_SUCCESS;
//            } else if (error == ERROR_INTERNET_NO_PING_SUPPORT) {
//
//                //
//                // can't ping - no ping support. quit
//                //
//
//                break;
//            }
//        }
//    }
//
//    UnlockSerializedList(&GlobalServerInfoList);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//LoadServerInfoDatabase(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Populates the server info database from the registry. This allows us to
//    avoid server capability negotiation each time we start IE/Wininet
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    return ERROR_SUCCESS;
//}
//
//
//DWORD
//SaveServerInfoDatabase(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Copies the contents of the current server info database to the registry.
//    This information is read the next time we start IE/Wininet
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    return ERROR_SUCCESS;
//}

//
// methods
//


CServerInfo::CServerInfo(
    IN LPSTR lpszHostName,
    OUT LPDWORD pdwError,
    IN DWORD dwService,
    IN DWORD dwMaxConnections
    )

/*++

Routine Description:

    CServerInfo constructor

Arguments:

    lpszHostName        - server for which to create CServerInfo

    pdwError            - return status in case a failure occurs during init

    dwService           - which service to create CServerInfo for

    dwMaxConnections    - maximum number of simultaneous connections to this
                          server

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::CServerInfo",
                 "%q, %s (%d), %d",
                 lpszHostName,
                 InternetMapService(dwService),
                 dwService,
                 dwMaxConnections
                 ));

    INIT_SERVER_INFO();

    //GlobalServerInfoAllocCount++;
    *pdwError = ERROR_SUCCESS;

    InitializeListHead(&m_List);
    m_Expires = 0;
    m_Wrap = 0;
    m_ReferenceCount = 1;
    m_HostName = lpszHostName;
    if (!m_HostName.StringAddress())
    {
        *pdwError = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    m_HostName.MakeLowerCase();
    m_Hash = CalculateHashValue(m_HostName.StringAddress());
    m_Services.Word = 0;
    m_HttpSupport.Word = 0;
    m_Flags.Word = 0;
    m_ProxyLink = NULL;

    switch (dwService) {
    case INTERNET_SERVICE_HTTP:
        SetHTTP();
        break;

    case INTERNET_SERVICE_FTP:
        SetFTP();
        break;

    case INTERNET_SERVICE_GOPHER:
        SetGopher();
        break;

    default:

        INET_ASSERT(FALSE);

    }

    //
    // only initialize the keep-alive and connection limit lists if we are
    // creating the server info entry for a HTTP server (or CERN proxy)
    //

    //
    // BUGBUG - we only want to do this on demand
    //

    //if (IsHTTP()) {
        InitializeSerializedList(&m_KeepAliveList);
        InitializeSerializedList(&m_PipelinedList);
        //InitializeSerializedList(&m_Waiters);
        SetKeepAliveListInitialized();

        //
        // the maximum number of connections per server is initialized to the
        // default (registry) value unless overridden by the caller
        //

if (dwMaxConnections == 0) {
    dwMaxConnections = DEFAULT_MAX_CONNECTIONS_PER_SERVER;
}
        m_ConnectionLimit = dwMaxConnections;
    //} else {
    //    m_ConnectionLimit = UNLIMITED_CONNECTIONS;
    //}
//dprintf("*** %s: limit = %d\n", GetHostName(), m_ConnectionLimit);
    //
    // BUGBUG - only create event if limiting connections. Need method to manage
    //          connection limit count/event creation
    //

    m_NewLimit = m_ConnectionLimit;
    m_ConnectionsAvailable = m_ConnectionLimit;
    //m_ActiveConnections = 0;
    m_LastActiveTime = 0;
    m_ConnectTime = (DWORD)-1;
    m_RTT = 0;
    m_DownloadRate = 0;
    m_UploadRate = 0;
    m_dwError = ERROR_SUCCESS;

    //
    // add to the global list. We are assuming here that the caller has already
    // checked for dupes
    //

    InsertAtHeadOfSerializedList(&GlobalServerInfoList, &m_List);

quit:
    DEBUG_LEAVE(0);
}


CServerInfo::~CServerInfo()

/*++

Routine Description:

    CServerInfo destructor

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "CServerInfo::~CServerInfo",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();

    //GlobalServerInfoDeAllocCount++;

    // unlink if we have a nested obj
    if ( m_ProxyLink ) {
        CServerInfo *pDerefObj;

        LockSerializedList(&GlobalServerInfoList);        
        pDerefObj = m_ProxyLink;
        m_ProxyLink = NULL;
        UnlockSerializedList(&GlobalServerInfoList);        

        if (pDerefObj) {
            pDerefObj->Dereference();
        }
    }


    RemoveFromSerializedList(&GlobalServerInfoList, &m_List);

    INET_ASSERT(m_ReferenceCount == 0);

    if (IsKeepAliveListInitialized()) {
        LockSerializedList(&m_KeepAliveList);
        while (!IsSerializedListEmpty(&m_KeepAliveList)) {
//dprintf("%#x ~S-I killing K-A %#x\n", GetCurrentThreadId(), HeadOfSerializedList(&m_KeepAliveList));

            LPVOID pEntry = SlDequeueHead(&m_KeepAliveList);

            INET_ASSERT(pEntry != NULL);

            if (pEntry != NULL) {

                ICSocket * pSocket = ContainingICSocket(pEntry);

//dprintf("~CServerInfo: destroying socket %#x\n", pSocket->GetSocket());
                pSocket->Destroy();
            }
        }
        UnlockSerializedList(&m_KeepAliveList);
        TerminateSerializedList(&m_KeepAliveList);
        TerminateSerializedList(&m_PipelinedList);
        //TerminateSerializedList(&m_Waiters);
    }

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::Reference(
    VOID
    )

/*++

Routine Description:

    Increments the reference count for the CServerInfo

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Reference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    InterlockedIncrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    DEBUG_LEAVE(0);
}


BOOL
CServerInfo::Dereference(
    VOID
    )

/*++

Routine Description:

    Dereferences the SESSION_INFO. If the reference count goes to zero then this
    entry is deleted. If the reference count goes to 1 then the expiry timer is
    started

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - entry was deleted

        FALSE   - entry was not deleted

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::Dereference",
                 "{%q}",
                 GetHostName()
                 ));

    CHECK_SERVER_INFO();
    INET_ASSERT(m_ReferenceCount > 0);

    //
    // we need to grab the list - we may be removing this entry or updating
    // the reference count and expiry fields which must be done atomically
    //

    LockSerializedList(&GlobalServerInfoList);

    LONG result = InterlockedDecrement(&m_ReferenceCount);
//dprintf("CServerInfo %s - %d\n", GetHostName(), m_ReferenceCount);

    DEBUG_PRINT(SESSION,
                INFO,
                ("Reference count = %d\n",
                ReferenceCount()
                ));

    BOOL deleted = FALSE;

    if (result == 0) {
        delete this;
        deleted = TRUE;
    } else if (result == 1) {

        //
        // start expiration proceedings...
        //

        SetExpiryTime();
    }

    UnlockSerializedList(&GlobalServerInfoList);

    DEBUG_LEAVE(deleted);

    return deleted;
}


DWORD    
CServerInfo::SetCachedProxyServerInfo(
    IN CServerInfo * pProxyServer,
    IN DWORD dwProxyVersion,
    IN BOOL fUseProxy,
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    IN INTERNET_SCHEME ProxyScheme,
    IN INTERNET_PORT ProxyPort
    )
/*++

Routine Description:

    If the Version information match up, copies
     the proxy information and links this server object
     to the appopriate proxy server object

    Assumes that this is called on successful use of the proxy
      object.

Arguments:

    None.

Return Value:

    DWORD
        ERROR_SUCCESS

        FALSE   - entry was not deleted

--*/


{
    DWORD error=ERROR_SUCCESS;

    LockSerializedList(&GlobalServerInfoList);            

    if ( dwProxyVersion != GlobalProxyVersionCount ) 
    {
        SetProxyScriptCached(FALSE);
        goto quit; // bail, we don't accept out of date additions to the cache
    }

    if ( m_ProxyLink )
    {
        if ( IsProxyScriptCached() && 
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort &&
             fUseProxy )
        {
            if ( pProxyServer == m_ProxyLink ) {            
                INET_ASSERT(dwProxyVersion == GlobalProxyVersionCount);
                m_dwProxyVersion = dwProxyVersion; // we're now up to date
                goto quit; // match, no version or host changes
            }

            INET_ASSERT(pProxyServer != m_ProxyLink );            
        }
        //
        // unlink, because we have a new entry to save,
        //  and the previous entry is bad
        //
        m_ProxyLink->Dereference();
        m_ProxyLink = NULL;
    }

    //
    // Add new cached entry
    //

    SetProxyScriptCached(TRUE);

    m_HostScheme     = HostScheme;
    m_HostPort       = HostPort;

    m_dwProxyVersion = dwProxyVersion; // we're now up to date

    if ( fUseProxy )
    {
        INET_ASSERT(this != pProxyServer);

        m_ProxyLink = pProxyServer;
        m_ProxyLink->Reference();

        m_ProxyLink->m_HostScheme = ProxyScheme;
        m_ProxyLink->m_HostPort   = ProxyPort;

        switch (ProxyScheme)
        {
            case INTERNET_SCHEME_HTTP:
                m_ProxyLink->SetCernProxy();
                break;
            case INTERNET_SCHEME_SOCKS: 
                m_ProxyLink->SetSocksGateway();
                break;
            case INTERNET_SCHEME_FTP:
                m_ProxyLink->SetFTPProxy();
                break;
        }
    }

quit:

    UnlockSerializedList(&GlobalServerInfoList);        

    return error;
}

CServerInfo * 
CServerInfo::GetCachedProxyServerInfo(
    IN INTERNET_SCHEME HostScheme,
    IN INTERNET_PORT HostPort,
    OUT BOOL *pfCachedEntry
    )

/*++

Routine Description:

   Retrieves a cached server object, that indicates
    a probable proxy to use

   On Success, the return has an additional increment
    on its ref count, assumition that caller derefs

Arguments:

    None.

Return Value:

    CServerInfo *     
        NULL on failure

--*/

{
    CServerInfo *pProxyServer = NULL;

    LockSerializedList(&GlobalServerInfoList);        

    *pfCachedEntry = FALSE; 

    if ( IsProxyScriptCached() )
    {        
        //
        // Examine Version Count
        //

        if ( GlobalProxyVersionCount == m_dwProxyVersion &&
             HostScheme == m_HostScheme &&
             HostPort == m_HostPort
             )
        {
            *pfCachedEntry = TRUE;

            if ( m_ProxyLink ) {
                // matched cached entry
                m_ProxyLink->Reference();
                pProxyServer = m_ProxyLink;                    
            }
        }
        else
        {
            // version is expired, remove reference
            SetProxyScriptCached(FALSE);
            if ( m_ProxyLink ) {                
                m_ProxyLink->Dereference();
                m_ProxyLink = NULL;
            }
        }            
    }
        
    UnlockSerializedList(&GlobalServerInfoList);        
    return pProxyServer;
}

BOOL    
CServerInfo::CopyCachedProxyInfoToProxyMsg(
    IN OUT AUTO_PROXY_ASYNC_MSG *pQueryForProxyInfo
    )

/*++

Routine Description:

   Retrieves Cached Proxy info from object

Arguments:

    None.

Return Value:

    BOOL
        TRUE - sucess

--*/

{
    BOOL fSuccess = FALSE;

    // really only need to lock to proctect m_HostPort && m_HostScheme
    LockSerializedList(&GlobalServerInfoList);        

    pQueryForProxyInfo->SetUseProxy(FALSE);
    pQueryForProxyInfo->_lpszProxyHostName =  
        m_HostName.StringAddress() ? 
        NewString(m_HostName.StringAddress()) :
        NULL;

    if ( pQueryForProxyInfo->_lpszProxyHostName != NULL ) {
        // copy out cached entry to proxy message structure
        pQueryForProxyInfo->_nProxyHostPort        = m_HostPort;
        pQueryForProxyInfo->_tProxyScheme          = m_HostScheme;
        pQueryForProxyInfo->_bFreeProxyHostName    = TRUE;
        pQueryForProxyInfo->_dwProxyHostNameLength = 
            strlen((pQueryForProxyInfo)->_lpszProxyHostName);
        pQueryForProxyInfo->SetUseProxy(TRUE);
        fSuccess = TRUE; // success
    }

    UnlockSerializedList(&GlobalServerInfoList);        
    return fSuccess;
}



//
//DWORD
//CServerInfo::ResolveHostName(
//    IN BOOL bForce
//    )
//
///*++
//
//Routine Description:
//
//    Resolves the host name for a CServerInfo. If we already have a resolved
//    name for this info then it is freed. There can be only one thread updating
//    or using the host name info
//
//Arguments:
//
//    bForce  - TRUE if we need to force a re-resolution
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::ResolveHostName",
//                 "{%q} %B",
//                 GetHostName(),
//                 bForce
//                 ));
//
//    DWORD error = ERROR_SUCCESS;
//
//    if (bForce || IsAddressListEmpty(&m_AddressList)) {
//        EnterCriticalSection(&m_AddressListCritSec);
//
//        //
//        // BUGBUG - ideally, we want to test TTL here if bForce is TRUE to stop
//        //          multiple simultaneous forced requests re-resolving the same
//        //          info
//        //
//
//        if (bForce || IsAddressListEmpty(&m_AddressList)) {
//
//            //
//            // FreeAddressList() checks for an empty list
//            //
//
//            FreeAddressList(&m_AddressList);
//
//            //
//            // resolve the name & generate an address list. Since we don't know
//            // the port address we want to talk to right now, we will generate a
//            // list containing a default port number (0) which we must override
//            // when we really connect to the server
//            //
//
//            error = ::GetServiceAddress(GetHostName(),
//                                        NULL, // service name
//                                        NULL, // service guid
//                                        NS_DEFAULT,
//                                        INTERNET_INVALID_PORT_NUMBER,
//                                        0,    // protocol characteristics
//                                        &m_AddressList
//                                        );
//        }
//        LeaveCriticalSection(&m_AddressListCritSec);
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


VOID
CServerInfo::UpdateConnectTime(
    IN DWORD dwConnectTime
    )

/*++

Routine Description:

    Calculates average connect time

Arguments:

    dwConnectTime   - current connect time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectTime",
                 "{%q} %d",
                 GetHostName(),
                 dwConnectTime
                 ));

    DWORD connectTime = m_ConnectTime;

    if (connectTime == (DWORD)-1) {
        connectTime = dwConnectTime;
    } else {
        connectTime = (connectTime + dwConnectTime) / 2;
    }
//dprintf("%s: connect time = %d, ave = %d\n", GetHostName(), dwConnectTime, connectTime);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average connect time = %d mSec\n",
                connectTime
                ));

    InterlockedExchange((LPLONG)&m_ConnectTime, connectTime);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateRTT(
    IN DWORD dwRTT
    )

/*++

Routine Description:

    Calculates rolling average round-trip time

Arguments:

    dwRTT   - current round-trip time

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateRTT",
                 "{%q} %d",
                 GetHostName(),
                 dwRTT
                 ));

    DWORD RTT = m_RTT;

    if (RTT == 0) {
        RTT = dwRTT;
    } else {
        RTT = (RTT + dwRTT) / 2;
    }
//dprintf("%s: RTT = %d, ave = %d\n", GetHostName(), dwRTT, RTT);

    DEBUG_PRINT(SESSION,
                INFO,
                ("average round trip time = %d mSec\n",
                RTT
                ));

    InterlockedExchange((LPLONG)&m_RTT, RTT);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateDownloadRate(
    IN DWORD dwBytesPerSecond
    )

/*++

Routine Description:

    Calculates average download rate

Arguments:

    dwBytesPerSecond    - current download rate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateDownloadRate",
                 "{%q} %d",
                 GetHostName(),
                 dwBytesPerSecond
                 ));

    DWORD downloadRate = m_DownloadRate;

    if (downloadRate == 0) {
        downloadRate = dwBytesPerSecond;
    } else {
        downloadRate = (downloadRate + dwBytesPerSecond) / 2;
    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("average download rate = %d bytes/second\n",
                downloadRate
                ));

    InterlockedExchange((LPLONG)&m_DownloadRate, downloadRate);

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::UpdateUploadRate(
    IN DWORD dwBytesPerSecond
    )

/*++

Routine Description:

    Calculates average upload rate

Arguments:

    dwBytesPerSecond    - current upload rate

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateUploadRate",
                 "{%q} %d",
                 GetHostName(),
                 dwBytesPerSecond
                 ));

    DWORD uploadRate = m_UploadRate;

    if (uploadRate == 0) {
        uploadRate = dwBytesPerSecond;
    } else {
        uploadRate = (uploadRate + dwBytesPerSecond) / 2;
    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("average upload rate = %d bytes/second\n",
                uploadRate
                ));

    InterlockedExchange((LPLONG)&m_UploadRate, uploadRate);

    DEBUG_LEAVE(0);
}

//
//DWORD
//CServerInfo::GetConnection(
//    IN DWORD dwSocketFlags,
//    IN INTERNET_PORT nPort,
//    IN DWORD dwTimeout,
//    OUT ICSocket * * lplpSocket
//    )
//
///*++
//
//Routine Description:
//
//    Combines connection limiting and keep-alive list management. If keep-alive
//    connection requested and one is available, it is given out. If we can create
//    a connection, the connection count is increased (actually decremented) and
//    an OK-to-continue indication returned to the caller. If all connections are
//    currently in use, we wait for one to become available. If this is a sync
//    operation, we block waiting for the waiter event. If this is an async
//    operation, we return ERROR_IO_PENDING and pick up the request on a worker
//    thread when it becomes unblocked or times out proper
//
//Arguments:
//
//    dwSocketFlags   - flags identifying what type of connection we want:
//
//                        SF_SECURE       - we want https connection
//
//                        SF_KEEP_ALIVE   - we want persistent connection
//
//                        SF_NON_BLOCKING - we want non-blocking (async) socket
//
//    nPort           - required port
//
//    dwTimeout       - number of milliseconds we are willing to wait for
//                      connection to become available
//
//    lplpSocket      - returned pointer to ICSocket. ONLY used if the request is
//                      for a keep-alive socket and we had one available
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//                    Depending on *lplpSocket, we either returned the socket to
//                    use, or its okay to create a new connection
//
//                  ERROR_IO_PENDING
//                    Request will complete asynchronously
//
//        Failure - ERROR_INTERNET_TIMEOUT
//                    Failed to get connection in time allowed
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::GetConnection",
//                 "{%q} %#x, %d, %d, %#x",
//                 GetHostName(),
//                 dwSocketFlags,
//                 nPort,
//                 dwTimeout,
//                 lplpSocket
//                 ));
//
//    *lplpSocket = NULL;
//
//    DWORD error = DoFsm(new CFsm_GetConnection(dwSocketFlags,
//                                               nPort,
//                                               dwTimeout,
//                                               lplpSocket,
//                                               this
//                                               ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}


DWORD
CFsm_GetConnection::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    Runs next CFsm_GetConnection state

Arguments:

    Fsm - FSM controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
//dprintf("%#x: %s FSM %#x state %s\n", GetCurrentThreadId(), Fsm->MapType(), Fsm, Fsm->MapState());
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CFsm_GetConnection::RunSM",
                 "%#x",
                 Fsm
                 ));

    CServerInfo * pServerInfo = (CServerInfo *)Fsm->GetContext();
    CFsm_GetConnection * stateMachine = (CFsm_GetConnection *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
        stateMachine->StartTimer();

        //
        // fall through
        //

    case FSM_STATE_CONTINUE:

#ifdef NEW_CONNECTION_SCHEME
    case FSM_STATE_ERROR:
#endif
        error = pServerInfo->GetConnection_Fsm(stateMachine);
        break;

#ifndef NEW_CONNECTION_SCHEME

    case FSM_STATE_ERROR:

        INET_ASSERT((Fsm->GetError() == ERROR_INTERNET_TIMEOUT)
                    || (Fsm->GetError() == ERROR_INTERNET_OPERATION_CANCELLED));

        pServerInfo->RemoveWaiter((DWORD_PTR)Fsm);
        error = Fsm->GetError();
        Fsm->SetDone();
//dprintf("%#x: FSM_STATE_ERROR - %d\n", GetCurrentThreadId(), error);
        break;

#endif

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}

#ifdef NEW_CONNECTION_SCHEME
//
//
//DWORD
//CServerInfo::GetConnection_Fsm(
//    IN CFsm_GetConnection * Fsm
//    )
//
///*++
//
//Routine Description:
//
//    Tries to get a connection of requested type for caller. If no connection is
//    available then one of the following happens:
//
//        * If there are available keep-alive connections of a different type then
//          one is closed and the caller allowed to create a new connection
//
//        * If this is an async request, the FSM is blocked and the thread returns
//          to the pool if a worker, or back to the app if an app thread
//
//        * If this is a sync request, we wait on an event for a conneciton to be
//          made available, or the connect timeout to elapse
//
//        * In the situation where we are being run out of connections (number of
//          active connections >= connection limit AND no activity has taken place
//          on any connection in the last dwLimitTimeout mSec (in FSM)) then we
//          allow a new connection to be created
//
//Arguments:
//
//    Fsm - get connection FSM
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//                    Depending on *lplpSocket, we either returned the socket to
//                    use, or its okay to create a new connection
//
//                  ERROR_IO_PENDING
//                    Request will complete asynchronously
//
//        Failure - ERROR_INTERNET_TIMEOUT
//                    Failed to get connection in time allowed
//
//                  ERROR_INTERNET_INTERNAL_ERROR
//                    Something unexpected happened
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::GetConnection_Fsm",
//                 "{%q [%d+%d/%d]} %#x(%#x, %d, %d, %d)",
//                 GetHostName(),
//                 AvailableConnections(),
//                 KeepAliveConnections(),
//                 ConnectionLimit(),
//                 Fsm,
//                 Fsm->m_dwSocketFlags,
//                 Fsm->m_nPort,
//                 Fsm->m_dwTimeout,
//                 Fsm->m_dwLimitTimeout
//                 ));
//
//    DEBUG_PRINT(SESSION,
//                INFO,
//                ("FSM %#x state %s elapsed %d\n",
//                Fsm,
//                Fsm->MapState(),
//                Fsm->GetElapsedTime()
//                ));
//
//    DPRINTF("%#x: FSM %#x state %s elapsed %d\n",
//            GetCurrentThreadId(),
//            Fsm,
//            Fsm->MapState(),
//            Fsm->GetElapsedTime()
//            );
//
//    PERF_ENTER(GetConnection);
//
//    CFsm_GetConnection & fsm = *Fsm;
//    DWORD error = fsm.GetError();
//    FSM_STATE state = fsm.GetState();
//    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
//    ICSocket * pSocket = NULL;
//    BOOL bUnlockList = FALSE;
//    BOOL bKeepAliveWaiters;
//
//    *fsm.m_lplpSocket = NULL;
//
//    //
//    // FSM_STATE_ERROR processing. Typically a timeout has occurred. We now want
//    // to force a new connection instead of timing out
//    //
//
//    if (error != ERROR_SUCCESS) {
//        RemoveWaiter((DWORD)Fsm);
//    }
//
//    //
//    // timeout error is OK - we just try again until we get cancelled out or hit
//    // the retry limit. Any other error causes failure. We should not be getting
//    // ERROR_SUCCESS (test put here for defensive purposes only)
//    //
//
//    if ((state == FSM_STATE_ERROR)
//    && (error != ERROR_INTERNET_TIMEOUT)
//    && (error != ERROR_SUCCESS)) {
//
//        DPRINTF("%#x: FSM %#x FSM_STATE_ERROR, error = %d\n",
//                GetCurrentThreadId(),
//                Fsm,
//                error
//                );
//
//        DEBUG_PRINT(SESSION,
//                    ERROR,
//                    ("FSM %#x FSM_STATE_ERROR, error = %s (%d)\n",
//                    Fsm,
//                    InternetMapError(error),
//                    error
//                    ));
//
//        INET_ASSERT(error != ERROR_SUCCESS);
//
//        goto quit;
//    }
//
//    INET_ASSERT(lpThreadInfo != NULL);
//    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
//
//    if ((lpThreadInfo == NULL) || (lpThreadInfo->hObjectMapped == NULL)) {
//        error = ERROR_INTERNET_INTERNAL_ERROR;
//        goto quit;
//    }
//
//    BOOL bAsyncRequest;
//
//    bAsyncRequest = lpThreadInfo->IsAsyncWorkerThread
//                    || ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
//                        IsAsyncHandle();
//
//    //
//    // before we do anything, check if we've been run out of connections. If we
//    // don't do this check here and we are out, then we'll wait unnecessarily
//    // (assuming connections are not returned)
//    //
//
//    if ((state == FSM_STATE_INIT) && RunOutOfConnections()) {
//
//        DPRINTF("%#x: out of connections on first attempt: %d+%d/%d\n",
//                GetCurrentThreadId(),
//                AvailableConnections(),
//                KeepAliveConnections(),
//                ConnectionLimit()
//                );
//
//        DEBUG_PRINT(SESSION,
//                    ERROR,
//                    ("out of connections on first attempt: %d+%d/%d\n",
//                    AvailableConnections(),
//                    KeepAliveConnections(),
//                    ConnectionLimit()
//                    ));
//
//        error = ERROR_SUCCESS;
//        pSocket = NULL;
//        goto quit;
//    }
//
//try_again:
//
//    bUnlockList = TRUE;
//
//    //
//    // use m_Waiters to serialize access. N.B. - we will acquire m_KeepAliveList
//    // from within m_Waiters
//    //
//
//    LockSerializedList(&m_Waiters);
//    bKeepAliveWaiters = KeepAliveWaiters();
//    if (fsm.m_dwSocketFlags & SF_KEEP_ALIVE) {
//
//        //
//        // maintain requester order - if there are already waiters then queue
//        // this request, else try to satisfy the requester. HOWEVER, only check
//        // for existing requesters the FIRST time through. If we're here with
//        // FSM_STATE_CONTINUE then we've been unblocked and we can ignore any
//        // waiters that came after us
//        //
//
//        if ((state == FSM_STATE_CONTINUE) || !bKeepAliveWaiters) {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("continuing or no current waiters for K-A connections\n"
//                        ));
//
//            while (pSocket = FindKeepAliveConnection(fsm.m_dwSocketFlags, fsm.m_nPort)) {
//                if (pSocket->IsReset()) {
//
//                    DPRINTF("%#x: ********* socket %#x is closed already\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket()
//                            );
//
//                    DEBUG_PRINT(SESSION,
//                                INFO,
//                                ("K-A connection %#x [%#x] is closed\n",
//                                pSocket,
//                                pSocket->GetSocket()
//                                ));
//
//                    pSocket->SetLinger(FALSE, 0);
//                    pSocket->Shutdown(2);
////dprintf("GetConnection: destroying reset socket %#x\n", pSocket->GetSocket());
//                    pSocket->Destroy();
//                    if (!UnlimitedConnections()) {
//                        ++m_ConnectionsAvailable;
//                    }
//                    CHECK_CONNECTION_COUNT();
//                } else {
//
//                    DPRINTF("%#x: *** matched %#x, %#x\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket(),
//                            pSocket->GetFlags()
//                            );
//
//                    break;
//                }
//            }
//            if (pSocket == NULL) {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("no available K-A connections\n"
//                            ));
//
//                /*
//                //
//                // if all connections are in use as keep-alive connections then
//                // since we're here, we want a keep-alive connection that doesn't
//                // match the currently available keep-alive connections. Terminate
//                // the oldest keep-alive connection (at the head of the queue)
//                // and generate a new connection
//                //
//
//                LockSerializedList(&m_KeepAliveList);
//                if (ElementsOnSerializedList(&m_KeepAliveList) == m_ConnectionLimit) {
//                    pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
//                    pSocket->SetLinger(FALSE, 0);
//                    pSocket->Shutdown(2);
//                    pSocket->Destroy();
//                    if (!UnlimitedConnections()) {
//                        ++m_ConnectionsAvailable;
//                    }
//                    CHECK_CONNECTION_COUNT();
//                }
//                UnlockSerializedList(&m_KeepAliveList);
//                */
//            }
//        } else {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("%d waiters for K-A connection to %q\n",
//                        ElementsOnSerializedList(&m_KeepAliveList),
//                        GetHostName()
//                        ));
//
//        }
//    }
//
//    //
//    // if we found a matching keep-alive connection or we are not limiting
//    // connections then we're done
//    //
//
//    if ((pSocket != NULL) || UnlimitedConnections()) {
//
//        INET_ASSERT(error == ERROR_SUCCESS);
//
//        error = ERROR_SUCCESS;
//        goto exit;
//    }
//
//    //
//    // no keep-alive connections matched, or there are already waiters for
//    // keep-alive connections
//    //
//
//    INET_ASSERT((AvailableConnections() >= 0)
//                && (AvailableConnections() <= ConnectionLimit()));
//
//    if (AvailableConnections() > 0) {
//
//        //
//        // can create a connection
//        //
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("%s: OK to create new connection: %d/%d\n",
//                    GetHostName(),
//                    AvailableConnections(),
//                    ConnectionLimit()
//                    ));
//
//        DPRINTF("%#x: *** %s: OK to create connection: %d/%d\n",
//                GetCurrentThreadId(),
//                GetHostName(),
//                AvailableConnections(),
//                ConnectionLimit()
//                );
//
//        INET_ASSERT(error == ERROR_SUCCESS);
//        INET_ASSERT(pSocket == NULL);
//
//        --m_ConnectionsAvailable;
//    //} else if (fsm.GetElapsedTime() > fsm.m_dwTimeout) {
//    //    error = ERROR_INTERNET_TIMEOUT;
//    } else {
//
//        //
//        // if there are keep-alive connections but no keep-alive waiters
//        // then either we don't want a keep-alive connection, or the ones
//        // available don't match our requirements.
//        // If we need a connection of a different type - e.g. SSL when all
//        // we have is non-SSL then close a connection & generate a new one.
//        // If we need a non-keep-alive connection then its okay to return
//        // a current keep-alive connection, the understanding being that the
//        // caller will not add Connection: Keep-Alive header (HTTP 1.0) or
//        // will add Connection: Close header (HTTP 1.1)
//        //
//
//        //
//        // BUGBUG - what about waiters for non-keep-alive connections?
//        //
//        // scenario - limit of 1 connection:
//        //
//        //  A. request for k-a
//        //      continue & create connection
//        //  B. request non-k-a
//        //      none available; wait
//        //  C. release k-a connection; unblock sync waiter B
//        //  D. request non-k-a
//        //      k-a available; return it; caller converts to non-k-a
//        //  E. unblocked waiter B request non-k-a
//        //      none available; wait
//        //
//        // If this situation continues, eventually B will time-out, whereas it
//        // could have had the connection taken by D. Request D is younger and
//        // therefore can afford to wait while B continues with the connection
//        //
//
//        BOOL fHaveConnection = FALSE;
//
//        if (!bKeepAliveWaiters) {
//            LockSerializedList(&m_KeepAliveList);
//            if (KeepAliveConnections() != 0) {
//                pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
//                fHaveConnection = TRUE;
//
//#define SOCK_FLAGS  (SF_ENCRYPT | SF_DECRYPT | SF_SECURE)
//
//                DWORD dwSocketTypeFlags = pSocket->GetFlags() & SOCK_FLAGS;
//                DWORD dwRequestTypeFlags = fsm.m_dwSocketFlags & SOCK_FLAGS;
//
//                if (dwSocketTypeFlags ^ dwRequestTypeFlags) {
//
//                    DEBUG_PRINT(SESSION,
//                                INFO,
//                                ("different socket types requested: %#x, %#x\n",
//                                fsm.m_dwSocketFlags,
//                                pSocket->GetFlags()
//                                ));
//
//                    DPRINTF("%#x: *** closing socket %#x: %#x vs. %#x\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket(),
//                            pSocket->GetFlags(),
//                            fsm.m_dwSocketFlags
//                            );
//
//                    pSocket->SetLinger(FALSE, 0);
//                    pSocket->Shutdown(2);
////dprintf("GetConnection: destroying different type socket %#x\n", pSocket->GetSocket());
//                    pSocket->Destroy();
//                    pSocket = NULL;
//                } else {
//
//                    DPRINTF("%#x: *** returning k-a connection %#x as non-k-a\n",
//                            GetCurrentThreadId(),
//                            pSocket->GetSocket()
//                            );
//
//                }
//                CHECK_CONNECTION_COUNT();
//            }
//            UnlockSerializedList(&m_KeepAliveList);
//            if (fHaveConnection) {
//                goto exit;
//            }
//        }
//
//        //
//        // about to wait for a connection. If it looks as though we're being run
//        // out of connections, then create a new one
//        //
//
//        if (RunOutOfConnections()) {
//            pSocket = NULL;
//            error = ERROR_SUCCESS;
//            goto exit;
//        }
//
//        DPRINTF("%#x: blocking %s FSM %#x state %s %d/%d elapsed: %d mSec\n",
//                GetCurrentThreadId(),
//                Fsm->MapType(),
//                Fsm,
//                Fsm->MapState(),
//                AvailableConnections(),
//                ConnectionLimit(),
//                Fsm->GetElapsedTime()
//                );
//
//        //
//        // we have to wait for a connection to become available. If we are an
//        // async request then we queue this FSM & return the thread to the pool
//        // or, if app thread, return pending indication to the app. If this is
//        // a sync request (in an app thread) then we block on an event waiting
//        // for a connection to become available
//        //
//
//        HANDLE hEvent = NULL;
//
//        if (!bAsyncRequest) {
//
//            //
//            // create unnamed, initially unsignalled, auto-reset event
//            //
//
//            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
//            if (hEvent == NULL) {
//                error = GetLastError();
//                goto exit;
//            }
//        }
//
//        CConnectionWaiter * pWaiter;
//
//#if INET_DEBUG
//
//        for (pWaiter = (CConnectionWaiter *)HeadOfSerializedList(&m_Waiters);
//             pWaiter != (CConnectionWaiter *)SlSelf(&m_Waiters);
//             pWaiter = (CConnectionWaiter *)pWaiter->Next()) {
//
//            INET_ASSERT(pWaiter->Id() != (DWORD)(bAsyncRequest ? (DWORD)Fsm : lpThreadInfo->ThreadId));
//        }
//#endif
//
//        pWaiter = new CConnectionWaiter(&m_Waiters,
//                                        !bAsyncRequest,
//                                        (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
//                                            ? TRUE
//                                            : FALSE,
//                                        bAsyncRequest
//                                            ? (DWORD)Fsm
//                                            : lpThreadInfo->ThreadId,
//                                        hEvent);
//        if (pWaiter == NULL) {
//            error = ERROR_NOT_ENOUGH_MEMORY;
//            goto exit;
//        }
//        if (bAsyncRequest) {
//
//            //
//            // ensure that when the FSM is unblocked normally, the new state
//            // is STATE_CONTINUE
//            //
//
//            DWORD dwWaitTime = min(fsm.m_dwLimitTimeout, fsm.m_dwTimeout);
//
//            ////
//            //// make wait time elastic: we don't want to time out after the
//            //// connect timeout value elapses. We keep expanding the wait time
//            //// for a connection until we get one, or the request is cancelled
//            ////
//            //
//            //fsm.m_dwTimeout += dwWaitTime;
//            //if (fsm.m_dwTimeout == 0xffffffff) {
//            //    --fsm.m_dwTimeout;
//            //}
//            fsm.SetState(FSM_STATE_CONTINUE);
//            fsm.SetNextState(FSM_STATE_CONTINUE);
//            error = BlockWorkItem(Fsm, (DWORD)pWaiter, dwWaitTime);
//            if (error == ERROR_SUCCESS) {
//                error = ERROR_IO_PENDING;
//            }
//        } else {
//            UnlockSerializedList(&m_Waiters);
//            bUnlockList = FALSE;
//
//            DPRINTF("%#x: %s FSM %#x %s waiting %d mSec\n",
//                    GetCurrentThreadId(),
//                    Fsm->MapType(),
//                    Fsm,
//                    Fsm->MapState(),
//                    fsm.m_dwTimeout
//                    );
//
//            //DWORD dwWaitTime = fsm.m_dwTimeout - fsm.GetElapsedTime();
//            DWORD dwWaitTime = fsm.m_dwTimeout;
//
//            if ((int)dwWaitTime <= 0) {
//
//                DEBUG_PRINT(SESSION,
//                            ERROR,
//                            ("SYNC wait timed out (%d mSec)\n",
//                            fsm.m_dwTimeout
//                            ));
//
//                error = ERROR_INTERNET_TIMEOUT;
//            } else {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("waiting %d mSec for SYNC event %#x\n",
//                            dwWaitTime,
//                            hEvent
//                            ));
//
//                //
//                // we'd better not be doing a sync wait if we are in the
//                // context of an app thread making an async request
//                //
//
//                INET_ASSERT(!lpThreadInfo->IsAsyncWorkerThread
//                            && !((INTERNET_HANDLE_OBJECT *)lpThreadInfo->
//                                hObjectMapped)->IsAsyncHandle());
//
//                //INET_ASSERT(dwWaitTime <= 60000);
//
//                DWORD dwDeltaWaitTime = min(dwWaitTime, fsm.m_dwLimitTimeout);
//                DWORD dwTimeStarted = GetTickCount();
//
//                do {
//
//                    DPRINTF("%#x: sync wait %d mSec\n",
//                            GetCurrentThreadId(),
//                            dwDeltaWaitTime
//                            );
//
//                    error = WaitForSingleObject(hEvent, dwDeltaWaitTime);
//                    if (error == STATUS_TIMEOUT) {
//                        if (RunOutOfConnections()) {
//
//                            DPRINTF("%#x: run out of connections\n",
//                                    GetCurrentThreadId()
//                                    );
//
//                            break;
//                        }
//                    }
//                } while (((GetTickCount() - dwTimeStarted) < dwWaitTime)
//                         && (error == STATUS_TIMEOUT));
//
//                DPRINTF("%#x: sync waiter unblocked - error = %d\n",
//                        GetCurrentThreadId(),
//                        error
//                        );
//
//            }
//            if (error == STATUS_TIMEOUT) {
//
//                DPRINTF("%#x: %s %d+%d/%d: timed out %#x (%s FSM %#x %s)\n",
//                        GetCurrentThreadId(),
//                        GetHostName(),
//                        AvailableConnections(),
//                        KeepAliveConnections(),
//                        ConnectionLimit(),
//                        GetCurrentThreadId(),
//                        Fsm->MapType(),
//                        Fsm,
//                        Fsm->MapState()
//                        );
//
//                RemoveWaiter(lpThreadInfo->ThreadId);
//                //bUnlockList = FALSE;
//                /*
//                LockSerializedList(&m_Waiters);
//                for (pWaiter = (CConnectionWaiter *)HeadOfSerializedList(&m_Waiters);
//                     pWaiter != (CConnectionWaiter *)SlSelf(&m_Waiters);
//                     pWaiter = (CConnectionWaiter *)pWaiter->Next()) {
//
//                    if (pWaiter->Id() == lpThreadInfo->ThreadId) {
//                        RemoveFromSerializedList(&m_Waiters, pWaiter->List());
//                        delete pWaiter;
//                        break;
//                    }
//                }
//                */
//                error = RunOutOfConnections()
//                        ? WAIT_OBJECT_0
//                        : ERROR_INTERNET_TIMEOUT;
//            //} else {
//            //    bUnlockList = FALSE;
//            }
//
//            BOOL bOk;
//
//            bOk = CloseHandle(hEvent);
//
//            INET_ASSERT(bOk);
//
//            if (error == WAIT_OBJECT_0) {
//
//                DPRINTF("%#x: sync requester trying again\n",
//                        GetCurrentThreadId()
//                        );
//
//                fsm.SetState(FSM_STATE_CONTINUE);
//                goto try_again;
//            }
//        }
//    }
//
//exit:
//
//    //
//    // if we are returning a (keep-alive) socket that has a different blocking
//    // mode from that requested, change it
//    //
//
//    if (pSocket != NULL) {
//        if ((pSocket->GetFlags() & SF_NON_BLOCKING)
//            ^ (fsm.m_dwSocketFlags & SF_NON_BLOCKING)) {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("different blocking modes requested: %#x, %#x\n",
//                        fsm.m_dwSocketFlags,
//                        pSocket->GetFlags()
//                        ));
//
//            DPRINTF("%#x: *** changing socket %#x to %sBLOCKING\n",
//                    GetCurrentThreadId(),
//                    pSocket->GetSocket(),
//                    fsm.m_dwSocketFlags & SF_NON_BLOCKING
//                        ? "NON-"
//                        : ""
//                    );
//
//            pSocket->SetNonBlockingMode(fsm.m_dwSocketFlags
//                                        & SF_NON_BLOCKING);
//        }
//        *fsm.m_lplpSocket = pSocket;
//    }
//
//    if (bUnlockList) {
//        UnlockSerializedList(&m_Waiters);
//    }
//
//quit:
//
//    if (error != ERROR_IO_PENDING) {
//        fsm.SetDone();
//    }
//
//    DPRINTF("%#x: %s %d+%d/%d: get: %d, %#x, %d\n",
//            GetCurrentThreadId(),
//            GetHostName(),
//            AvailableConnections(),
//            KeepAliveConnections(),
//            ConnectionLimit(),
//            error,
//            pSocket ? pSocket->GetSocket() : 0,
//            ElementsOnSerializedList(&m_Waiters)
//            );
//
//    PERF_LEAVE(GetConnection);
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//CServerInfo::ReleaseConnection(
//    IN ICSocket * lpSocket OPTIONAL
//    )
//
///*++
//
//Routine Description:
//
//    Returns a keep-alive connection to the pool, or allows another requester to
//    create a connection.
//
//    If we will break the connection limit then we assume we created an additional
//    connection when we were being starved, and we discard this one
//
//Arguments:
//
//    lpSocket    - pointer to ICSocket if we are returning a keep-alive connection
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DPRINTF("%#x: rls %#x %d+%d/%d\n",
//            GetCurrentThreadId(),
//            lpSocket ? lpSocket->GetSocket() : 0,
//            AvailableConnections(),
//            KeepAliveConnections(),
//            ConnectionLimit()
//            );
//
//    //return ERROR_SUCCESS;
//    DEBUG_ENTER((DBG_SESSION,
//                 Dword,
//                 "CServerInfo::ReleaseConnection",
//                 "{%q [%d+%d/%d]} %#x [%#x]",
//                 GetHostName(),
//                 AvailableConnections(),
//                 KeepAliveConnections(),
//                 ConnectionLimit(),
//                 lpSocket,
//                 lpSocket ? lpSocket->GetSocket() : 0
//                 ));
//
//    PERF_ENTER(ReleaseConnection);
//
//    DWORD error = ERROR_SUCCESS;
//    BOOL bRelease = FALSE;
//
//    LockSerializedList(&m_Waiters);
//
//    //
//    // quite often (at least with catapult proxy based on IIS) the server may
//    // drop the connection even though it indicated it would keep it open. This
//    // typically happens on 304 (frequent) and 302 (less so) responses. If we
//    // determine the server has dropped the connection then throw it away and
//    // allow the app to create a new one
//    //
//
//    if (lpSocket != NULL) {
//        if (TotalAvailableConnections() >= ConnectionLimit()) {
//
//            DPRINTF("%#x: !!! too many K-A connections %d+%d/%d - discarding %#x\n",
//                    GetCurrentThreadId(),
//                    AvailableConnections(),
//                    KeepAliveConnections(),
//                    ConnectionLimit(),
//                    lpSocket->GetSocket()
//                    );
//
//            //
//            // trying to return keep-alive socket would overflow limit (if we
//            // are not already over). If we have less than the max. keep-alive
//            // connections, we will keep this one else close it
//            //
//
//            if (KeepAliveConnections() >= ConnectionLimit()) {
//
//                INET_ASSERT(KeepAliveConnections() == ConnectionLimit());
//
//                //
//                // BUGBUG - discarding k-a connection: it should be the oldest
//                //          (if oldest not this one)
//                //
//
//                DPRINTF("%#x: closing k-a %#x\n",
//                        GetCurrentThreadId(),
//                        lpSocket->GetSocket()
//                        );
//
//                lpSocket->Close();
//            } else {
//
//                INET_ASSERT(AvailableConnections() > 0);
//
//                if (AvailableConnections() > 0) {
//                    --m_ConnectionsAvailable;
//                }
//            }
//        }
//        if (lpSocket->IsClosed() || lpSocket->IsReset()) {
//
//            DEBUG_PRINT(SESSION,
//                        INFO,
//                        ("socket %#x already dead - throwing it out\n",
//                        lpSocket->GetSocket()
//                        ));
//
//            DPRINTF("%#x: socket %#x: already reset\n",
//                    GetCurrentThreadId(),
//                    lpSocket->GetSocket()
//                    );
//
////dprintf("ReleaseConnection: destroying already closed socket %#x\n", lpSocket->GetSocket());
//
//            BOOL bDestroyed = lpSocket->Dereference();
//
//            INET_ASSERT(bDestroyed);
//
//            lpSocket = NULL;
//        } else {
//
//            //
//            // if we are returning a keep-alive socket, put it in non-blocking
//            // mode if not already. Typically, Internet Explorer uses non-blocking
//            // sockets. In the infrequent cases where we want a blocking socket
//            // - mainly when doing java downloads - we will convert the socket
//            // to blocking mode when we get it from the pool
//            //
//
//            if (!lpSocket->IsNonBlocking()) {
//
//                DPRINTF("%#x: ***** WARNING: releasing BLOCKING k-a socket %#x\n",
//                        GetCurrentThreadId(),
//                        lpSocket->GetSocket()
//                        );
//
//                lpSocket->SetNonBlockingMode(TRUE);
//            }
//        }
//    }
//    if (lpSocket != NULL) {
//
//        DPRINTF("%#x: releasing K-A %#x (%d/%d)\n",
//                GetCurrentThreadId(),
//                lpSocket ? lpSocket->GetSocket() : 0,
//                AvailableConnections(),
//                ConnectionLimit()
//                );
//
//        INET_ASSERT(lpSocket->IsOpen());
//        INET_ASSERT(!lpSocket->IsOnList());
//        //INET_ASSERT(!lpSocket->IsReset());
//
//        lpSocket->SetKeepAlive();
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("releasing keep-alive socket %#x\n",
//                    lpSocket->GetSocket()
//                    ));
//
//        lpSocket->SetExpiryTime(GlobalKeepAliveSocketTimeout);
//
//        INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, lpSocket->List()));
//
//        InsertAtTailOfSerializedList(&m_KeepAliveList, lpSocket->List());
//
//        INET_ASSERT(UnlimitedConnections()
//                    ? TRUE
//                    : (KeepAliveConnections() <= ConnectionLimit()));
//
//        bRelease = TRUE;
//    } else {
//
//        DPRINTF("%#x: releasing connection (%d+%d/%d)\n",
//                GetCurrentThreadId(),
//                AvailableConnections(),
//                KeepAliveConnections(),
//                ConnectionLimit()
//                );
//
//        if (!UnlimitedConnections()) {
//            if (AvailableConnections() < ConnectionLimit()) {
//                ++m_ConnectionsAvailable;
//            } else {
//
//                DPRINTF("%#x: !!! not increasing avail cons (%d+%d) - at limit (%d)\n",
//                        GetCurrentThreadId(),
//                        AvailableConnections(),
//                        KeepAliveConnections(),
//                        ConnectionLimit()
//                        );
//
//            }
//        }
//
//        CHECK_CONNECTION_COUNT();
//
//        bRelease = TRUE;
//    }
//    if (bRelease && !UnlimitedConnections()) {
//
//        CHECK_CONNECTION_COUNT();
//
//        CConnectionWaiter * pWaiter;
//        BOOL bFreed = FALSE;
//
//        //
//        // loop here until we free a waiter or until there are no waiters left.
//        // The reason we do this is that we must free a waiter if there are any
//        // but the waiter corresponding to pWaiter may have been concurrently
//        // timed out and cannot be unblocked by us
//        //
//
//        do {
//            pWaiter = (CConnectionWaiter *)SlDequeueHead(&m_Waiters);
//            if (pWaiter != NULL) {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("unblocking %s waiter %#x\n",
//                            pWaiter->IsSync() ? "Sync" : "Async",
//                            pWaiter->Id()
//                            ));
//
//                DPRINTF("%#x: Unblocking %s connection waiter %#x\n",
//                        GetCurrentThreadId(),
//                        pWaiter->IsSync() ? "Sync" : "Async",
//                        pWaiter->Id()
//                        );
//
//                if (pWaiter->IsSync()) {
//                    pWaiter->Signal();
//                    bFreed = TRUE;
//                } else {
//
//                    int n = (int)UnblockWorkItems(1, (DWORD)pWaiter, ERROR_SUCCESS);
//
//                    if (n >= 1) {
//
//                        //
//                        // should never be > 1
//                        //
//
//                        INET_ASSERT(n == 1);
//
//                        bFreed = TRUE;
//
//                        DPRINTF("%#x: unblocked waiting FSM %#x\n",
//                                GetCurrentThreadId(),
//                                pWaiter->Id()
//                                );
//
//                        DEBUG_PRINT(SESSION,
//                                    INFO,
//                                    ("unblocked waiting FSM %#x\n",
//                                    pWaiter->Id()
//                                    ));
//
//                    } else {
//
//                        //
//                        // should never be < 0
//                        //
//
//                        INET_ASSERT(n == 0);
//
//                        DPRINTF("%#x: ********* waiting FSM %#x NOT UNBLOCKED\n",
//                                GetCurrentThreadId(),
//                                pWaiter->Id()
//                                );
//
//                        DEBUG_PRINT(SESSION,
//                                    ERROR,
//                                    ("waiting FSM %#x not unblocked\n",
//                                    pWaiter->Id()
//                                    ));
//
//                    }
//                }
//                delete pWaiter;
//            } else {
//
//                DEBUG_PRINT(SESSION,
//                            INFO,
//                            ("no waiters\n"
//                            ));
//
//                DPRINTF("%#x: !!! NOT unblocking connection waiter\n",
//                        GetCurrentThreadId()
//                        );
//
//            }
//        } while ((pWaiter != NULL) && !bFreed);
//    } else {
//
//        DPRINTF("%#x: !!! NOT releasing or unlimited?\n",
//                GetCurrentThreadId()
//                );
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("bRelease = %B, UnlimitedConnections() = %B\n",
//                    bRelease,
//                    UnlimitedConnections()
//                    ));
//
//    }
//
//    if (TotalAvailableConnections() >= ConnectionLimit()) {
//        ResetLastActiveTime();
//    }
//
//    DEBUG_PRINT(SESSION,
//                INFO,
//                ("avail+k-a/limit = %d+%d/%d\n",
//                AvailableConnections(),
//                KeepAliveConnections(),
//                ConnectionLimit()
//                ));
//
//    UnlockSerializedList(&m_Waiters);
//
//    PERF_LEAVE(ReleaseConnection);
//
//    DEBUG_LEAVE(error);
//
//    DPRINTF("%#x: %s %d+%d/%d: rls %#x: %d, %d\n",
//            GetCurrentThreadId(),
//            GetHostName(),
//            AvailableConnections(),
//            KeepAliveConnections(),
//            ConnectionLimit(),
//            lpSocket ? lpSocket->GetSocket() : 0,
//            error,
//            ElementsOnSerializedList(&m_Waiters)
//            );
//
//    return error;
//}
//
#else


DWORD
CServerInfo::GetConnection_Fsm(
    IN CFsm_GetConnection * Fsm
    )

/*++

Routine Description:

    Tries to get a connection of requested type for caller. If no connection is
    available then one of the following happens:

        * If there are available keep-alive connections of a different type then
          one is closed and the caller allowed to create a new connection

        * If this is an async request, the FSM is blocked and the thread returns
          to the pool if a worker, or back to the app if an app thread

        * If this is a sync request, we wait on an event for a connection to be
          made available, or the connect timeout to elapse

Arguments:

    Fsm - get connection FSM

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    Depending on *lplpSocket, we either returned the socket to
                    use, or its okay to create a new connection

                  ERROR_IO_PENDING
                    Request will complete asynchronously

        Failure - ERROR_INTERNET_TIMEOUT
                    Failed to get connection in time allowed

                  ERROR_INTERNET_INTERNAL_ERROR
                    Something unexpected happened

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::GetConnection_Fsm",
                 "{%q [%d+%d/%d]} %#x(%#x, %d, %d)",
                 GetHostName(),
                 m_ConnectionsAvailable,
                 ElementsOnSerializedList(&m_KeepAliveList),
                 m_ConnectionLimit,
                 Fsm,
                 Fsm->m_dwSocketFlags,
                 Fsm->m_nPort,
                 Fsm->m_dwTimeout
                 ));

    PERF_ENTER(GetConnection);

    BOOL bFound = FALSE;
    DWORD error = ERROR_SUCCESS;
    CFsm_GetConnection & fsm = *Fsm;
    ICSocket * pSocket = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = fsm.GetThreadInfo();
    HANDLE hEvent = NULL;
    BOOL bUnlockList = TRUE;
    BOOL bKeepAliveWaiters;
    BOOL fExemptConnLimit = FALSE;

    if (fsm.IsInvalid()) 
    {
        error = ERROR_INTERNET_OPERATION_CANCELLED;
        goto quit;
    }


    INET_ASSERT(lpThreadInfo != NULL);
    INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);
    INET_ASSERT(((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                GetHandleType() == TypeHttpRequestHandle);

    fExemptConnLimit = ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->ConnLimitExempted();

    if ((lpThreadInfo == NULL) || (lpThreadInfo->hObjectMapped == NULL)) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    BOOL bAsyncRequest;

    bAsyncRequest = lpThreadInfo->IsAsyncWorkerThread
                    || ((INTERNET_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                        IsAsyncHandle();

    *fsm.m_lplpSocket = NULL;

try_again:

    bUnlockList = TRUE;

    //
    // use m_Waiters to serialize access. N.B. - we will acquire m_KeepAliveList
    // from within m_Waiters
    //

    m_Waiters.Acquire();
    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }
    bKeepAliveWaiters = KeepAliveWaiters();
    if (fsm.m_dwSocketFlags & SF_KEEP_ALIVE) {

        //
        // maintain requester order - if there are already waiters then queue
        // this request, else try to satisfy the requester. HOWEVER, only check
        // for existing requesters the FIRST time through. If we're here with
        // FSM_STATE_CONTINUE then we've been unblocked and we can ignore any
        // waiters that came after us
        //

        if ((fsm.GetState() == FSM_STATE_CONTINUE) || !bKeepAliveWaiters) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no current waiters for K-A connections\n"
                        ));

            while (pSocket = FindKeepAliveConnection(fsm.m_dwSocketFlags,
                                                     fsm.m_nPort,
                                                     fsm.m_lpszSecureTunnelHost)) {
                if (pSocket->IsReset() || pSocket->HasExpired()) {

                    DPRINTF("%#x: %#x: ********* socket %#x is closed already\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("K-A connection %#x [%#x/%d] is reset (%B) or expired (%B)\n",
                                pSocket,
                                pSocket->GetSocket(),
                                pSocket->GetSourcePort(),
                                pSocket->IsReset(),
                                pSocket->HasExpired()
                                ));

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying reset socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                } else {

                    DPRINTF("%#x: %#x: *** matched %#x, %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags()
                            );

                    break;
                }
            }
            if (pSocket == NULL) {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("no available K-A connections\n"
                            ));

                /*
                //
                // if all connections are in use as keep-alive connections then
                // since we're here, we want a keep-alive connection that doesn't
                // match the currently available keep-alive connections. Terminate
                // the oldest keep-alive connection (at the head of the queue)
                // and generate a new connection
                //

                LockSerializedList(&m_KeepAliveList);
                if (ElementsOnSerializedList(&m_KeepAliveList) == m_ConnectionLimit) {
                    pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
                    pSocket->Destroy();
                    if (!UnlimitedConnections()) {
                        ++m_ConnectionsAvailable;
                    }
                    CHECK_CONNECTION_COUNT();
                }
                UnlockSerializedList(&m_KeepAliveList);
                */
            }
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("%d waiters for K-A connection to %q\n",
                        ElementsOnSerializedList(&m_KeepAliveList),
                        GetHostName()
                        ));

        }
    }

    //
    // if we found a matching keep-alive connection or we are not limiting
    // connections then we're done
    //

    if ((pSocket != NULL) || UnlimitedConnections()) {

        INET_ASSERT(error == ERROR_SUCCESS);

        if (pSocket != NULL && fExemptConnLimit)
        {
            // Passport grabs a connection from the pool, so we need to bump up the availabilty to let 
            // others get one more. Effectively we excempt the passport connection
            if (!UnlimitedConnections() /*&& !pSocket->ConnLimitExempted()*/) 
            {
                // we convert a connection that is subjecting to connection limit to one that isn't,
                // therefore, we need to up the availability by 1.
                pSocket->ExemptConnLimit();
                ++m_ConnectionsAvailable;
            }
        }
        goto exit;
    }

    //
    // no keep-alive connections matched, or there are already waiters for
    // keep-alive connections
    //

    INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

    if (m_ConnectionsAvailable > 0) {

        if (fsm.m_lpszSecureTunnelHost)
            goto exit;  // don't create a connection here for SSL tunneling

        //
        // can create a connection
        //

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("OK to create new connection\n"
                    ));

        DPRINTF("%#x: %#x: *** %s OK to create connection %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                GetHostName(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        if (!fExemptConnLimit) // make this a freeby for passport connection
        {
            --m_ConnectionsAvailable;
        }

    } else if (fsm.GetElapsedTime() > fsm.m_dwTimeout) {
        error = ERROR_INTERNET_TIMEOUT;
    } else {
        
        //
        // if there are keep-alive connections but no keep-alive waiters
        // then either we don't want a keep-alive connection, or the ones
        // available don't match our requirements.
        // If we need a connection of a different type - e.g. SSL when all
        // we have is non-SSL then close a connection & generate a new one.
        // If we need a non-keep-alive connection then its okay to return
        // a current keep-alive connection, the understanding being that the
        // caller will not add Connection: Keep-Alive header (HTTP 1.0) or
        // will add Connection: Close header (HTTP 1.1)
        //

        //
        // BUGBUG - what about waiters for non-keep-alive connections?
        //
        // scenario - limit of 1 connection:
        //
        //  A. request for k-a
        //      continue & create connection
        //  B. request non-k-a
        //      none available; wait
        //  C. release k-a connection; unblock sync waiter B
        //  D. request non-k-a
        //      k-a available; return it; caller converts to non-k-a
        //  E. unblocked waiter B request non-k-a
        //      none available; wait
        //
        // If this situation continues, eventually B will time-out, whereas it
        // could have had the connection taken by D. Request D is younger and
        // therefore can afford to wait while B continues with the connection
        //

        BOOL fHaveConnection = FALSE;

        if (!bKeepAliveWaiters || (fsm.GetState() == FSM_STATE_CONTINUE)) {

            LockSerializedList(&m_KeepAliveList);
            if (ElementsOnSerializedList(&m_KeepAliveList) != 0) {
                pSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                fHaveConnection = TRUE;

#define SOCK_FLAGS  (SF_ENCRYPT | SF_DECRYPT | SF_SECURE | SF_TUNNEL)

                DWORD dwSocketTypeFlags = pSocket->GetFlags() & SOCK_FLAGS;
                DWORD dwRequestTypeFlags = fsm.m_dwSocketFlags & SOCK_FLAGS;

                if ((dwSocketTypeFlags ^ dwRequestTypeFlags)
                    || (fsm.m_nPort != pSocket->GetPort())) {

                    DEBUG_PRINT(SESSION,
                                INFO,
                                ("different socket types (%#x, %#x) or ports (%d, %d) requested\n",
                                fsm.m_dwSocketFlags,
                                pSocket->GetFlags(),
                                fsm.m_nPort,
                                pSocket->GetPort()
                                ));

                    DPRINTF("%#x: %#x: *** closing socket %#x: %#x vs. %#x\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket(),
                            pSocket->GetFlags(),
                            fsm.m_dwSocketFlags
                            );

                    pSocket->SetLinger(FALSE, 0);
                    pSocket->Shutdown(2);
//dprintf("GetConnection: destroying different type socket %#x\n", pSocket->GetSocket());
                    pSocket->Destroy();
                    pSocket = NULL;
                    // If we were trying to wait for established SSL tunnel,
                    // but one wasn't found, then this connection is open
                    // for anyone.
                    if (!UnlimitedConnections() && fsm.m_lpszSecureTunnelHost) {
                        ++m_ConnectionsAvailable;
                    }
                } else {

                    DPRINTF("%#x: %#x: *** returning k-a connection %#x as non-k-a\n",
                            GetCurrentThreadId(),
                            Fsm,
                            pSocket->GetSocket()
                            );
                }
                CHECK_CONNECTION_COUNT();
                if (fExemptConnLimit)
                {
                    if (!UnlimitedConnections() /*&& !pSocket->ConnLimitExempted()*/) 
                    {
                        // we convert a connection that is subjecting to connection limit to one that isn't,
                        // therefore, we need to up the availability by 1.
                        
                        if (pSocket)
                        {
                            pSocket->ExemptConnLimit();
                        }
                        
                        ++m_ConnectionsAvailable;
                    }
                }
            }
            UnlockSerializedList(&m_KeepAliveList);
            if (fHaveConnection) {
                goto exit;
            }
        }

        DPRINTF("%#x: %#x: blocking %s FSM %#x state %s %d/%d\n",
                GetCurrentThreadId(),
                Fsm,
                Fsm->MapType(),
                Fsm,
                Fsm->MapState(),
                m_ConnectionsAvailable,
                m_ConnectionLimit
                );

        //
        // we have to wait for a connection to become available. If we are an
        // async request then we queue this FSM & return the thread to the pool
        // or, if app thread, return pending indication to the app. If this is
        // a sync request (in an app thread) then we block on an event waiting
        // for a connection to become available
        //

        if (fExemptConnLimit)
        {
            goto exit;
        }

        if (!bAsyncRequest) {

            //
            // create unnamed, initially unsignalled, auto-reset event
            //

            hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (hEvent == NULL) {
                error = GetLastError();
                goto exit;
            }
        }

        CConnectionWaiter * pWaiter;

#if INET_DEBUG

        for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
             pWaiter != (CConnectionWaiter *)m_Waiters.Self();
             pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

            INET_ASSERT(pWaiter->Id() != (DWORD_PTR)(bAsyncRequest ? (DWORD_PTR)Fsm : lpThreadInfo->ThreadId));
        }
#endif

        pWaiter = new CConnectionWaiter(&m_Waiters,
                                        !bAsyncRequest,
                                        (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                                            ? TRUE
                                            : FALSE,
                                        bAsyncRequest
                                            ? (DWORD_PTR)Fsm
                                            : lpThreadInfo->ThreadId,
                                        hEvent,

                                        //
                                        // priority in request handle object
                                        // controls relative position in list
                                        // of waiters
                                        //

                                        ((HTTP_REQUEST_HANDLE_OBJECT *)
                                            lpThreadInfo->hObjectMapped)->
                                                GetPriority()
                                        );

        DPRINTF("%#x: %#x: new waiter %#x: as=%B, K-A=%B, id=%#x, hE=%#x, pri=%d, sf=%#x, preq=%#x ssl=%s, url=%s\n",
                GetCurrentThreadId(),
                Fsm,
                pWaiter,
                bAsyncRequest,
                (fsm.m_dwSocketFlags & SF_KEEP_ALIVE)
                    ? TRUE
                    : FALSE,
                bAsyncRequest
                    ? (DWORD_PTR)Fsm
                    : lpThreadInfo->ThreadId,
                hEvent,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->
                    GetPriority(),
                fsm.m_dwSocketFlags,
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped),
                fsm.m_lpszSecureTunnelHost ? fsm.m_lpszSecureTunnelHost : "",
                ((HTTP_REQUEST_HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->GetOriginalUrl()
                );

        if (pWaiter == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        if (bAsyncRequest) {

            //
            // ensure that when the FSM is unblocked normally, the new state
            // is STATE_CONTINUE
            //

            Fsm->SetState(FSM_STATE_CONTINUE);
            error = BlockWorkItem(Fsm,
                                  (DWORD_PTR)pWaiter,
                                  fsm.m_dwTimeout
                                  );
            if (error == ERROR_SUCCESS) {
                error = ERROR_IO_PENDING;
            }
        } else {
            m_Waiters.Release();
            bUnlockList = FALSE;

            DPRINTF("%#x: %#x: %s FSM %#x %s waiting %d msec\n",
                    GetCurrentThreadId(),
                    Fsm,
                    Fsm->MapType(),
                    Fsm,
                    Fsm->MapState(),
                    fsm.m_dwTimeout
                    );

            DWORD dwWaitTime = fsm.m_dwTimeout - fsm.GetElapsedTime();

            if ((int)dwWaitTime <= 0) {

                DEBUG_PRINT(SESSION,
                            ERROR,
                            ("SYNC wait timed out (%d mSec)\n",
                            fsm.m_dwTimeout
                            ));

                error = ERROR_INTERNET_TIMEOUT;
            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("waiting %d mSec for SYNC event %#x\n",
                            dwWaitTime,
                            hEvent
                            ));

                //
                // we'd better not be doing a sync wait if we are in the
                // context of an app thread making an async request
                //

                INET_ASSERT(lpThreadInfo->IsAsyncWorkerThread
                            || !((INTERNET_HANDLE_OBJECT *)lpThreadInfo->
                                hObjectMapped)->IsAsyncHandle());

                //INET_ASSERT(dwWaitTime <= 60000);

                error = WaitForSingleObject(hEvent, dwWaitTime);

                DPRINTF("%#x: %#x: sync waiter unblocked - error = %d\n",
                        GetCurrentThreadId(),
                        Fsm,
                        error
                        );

            }
            if (error == STATUS_TIMEOUT) {

                DPRINTF("%#x: %#x: %s: %d+%d/%d: timed out %#x (%s FSM %#x %s)\n",
                        GetCurrentThreadId(),
                        Fsm,
                        GetHostName(),
                        m_ConnectionsAvailable,
                        ElementsOnSerializedList(&m_KeepAliveList),
                        m_ConnectionLimit,
                        GetCurrentThreadId(),
                        Fsm->MapType(),
                        Fsm,
                        Fsm->MapState()
                        );

                RemoveWaiter(lpThreadInfo->ThreadId);
                error = ERROR_INTERNET_TIMEOUT;
            }

            BOOL bOk;

            bOk = CloseHandle(hEvent);

            INET_ASSERT(bOk);

            if (error == WAIT_OBJECT_0) {

                DPRINTF("%#x: %#x: sync requester trying again\n",
                        GetCurrentThreadId(),
                        Fsm
                        );

                fsm.SetState(FSM_STATE_CONTINUE);
                goto try_again;
            }
        }
    }

exit:

    //
    // if we are returning a (keep-alive) socket that has a different blocking
    // mode from that requested, change it
    //

    if (pSocket != NULL) {
        if ((pSocket->GetFlags() & SF_NON_BLOCKING)
            ^ (fsm.m_dwSocketFlags & SF_NON_BLOCKING)) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("different blocking modes requested: %#x, %#x\n",
                        fsm.m_dwSocketFlags,
                        pSocket->GetFlags()
                        ));

            DPRINTF("%#x: %#x: *** changing socket %#x to %sBLOCKING\n",
                    GetCurrentThreadId(),
                    Fsm,
                    pSocket->GetSocket(),
                    fsm.m_dwSocketFlags & SF_NON_BLOCKING ? "NON-" : ""
                    );

            if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                pSocket->SetNonBlockingMode(fsm.m_dwSocketFlags & SF_NON_BLOCKING);
            }
        }
        *fsm.m_lplpSocket = pSocket;
    }

    if (bUnlockList) {
        m_Waiters.Release();
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DPRINTF("%#x: %#x: %s: %d+%d/%d: get: %d, %#x, %d\n",
            GetCurrentThreadId(),
            Fsm,
            GetHostName(),
            m_ConnectionsAvailable,
            ElementsOnSerializedList(&m_KeepAliveList),
            m_ConnectionLimit,
            error,
            pSocket ? pSocket->GetSocket() : 0,
            m_Waiters.Count()
            );

    PERF_LEAVE(GetConnection);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CServerInfo::ReleaseConnection(
    IN ICSocket * lpSocket OPTIONAL,
    IN BOOL fExemptConnLimit
    )

/*++

Routine Description:

    Returns a keep-alive connection to the pool, or allows another requester to
    create a connection

Arguments:

    lpSocket    - pointer to ICSocket if we are returning a keep-alive connection

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Dword,
                 "CServerInfo::ReleaseConnection",
                 "{%q [%d+%d/%d]} %#x [%#x]",
                 GetHostName(),
                 AvailableConnections(),
                 KeepAliveConnections(),
                 ConnectionLimit(),
                 lpSocket,
                 lpSocket ? lpSocket->GetSocket() : 0
                 ));

    PERF_ENTER(ReleaseConnection);

    DWORD error = ERROR_SUCCESS;
    BOOL bRelease = FALSE;

    m_Waiters.Acquire();

    //
    // quite often (at least with catapult proxy based on IIS) the server may
    // drop the connection even though it indicated it would keep it open. This
    // typically happens on 304 (frequent) and 302 (less so) responses. If we
    // determine the server has dropped the connection then throw it away and
    // allow the app to create a new one
    //

    if (lpSocket != NULL) {
        if (lpSocket->IsClosed() || lpSocket->IsReset()) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("socket %#x already dead - throwing it out\n",
                        lpSocket->GetSocket()
                        ));

            DPRINTF("%#x: socket %#x: already reset\n",
                    GetCurrentThreadId(),
                    lpSocket->GetSocket()
                    );

//dprintf("ReleaseConnection: destroying already closed socket %#x\n", lpSocket->GetSocket());
            BOOL bDestroyed = lpSocket->Dereference();

            INET_ASSERT(bDestroyed);

            lpSocket = NULL;
        } else {

            //
            // if we are returning a keep-alive socket, put it in non-blocking
            // mode if not already. Typically, Internet Explorer uses non-blocking
            // sockets. In the infrequent cases where we want a blocking socket
            // - mainly when doing java downloads - we will convert the socket
            // to blocking mode when we get it from the pool
            //

            if (!lpSocket->IsNonBlocking()) {

                DPRINTF("%#x: ***** WARNING: releasing BLOCKING k-a socket %#x\n",
                        GetCurrentThreadId(),
                        lpSocket->GetSocket()
                        );

                if (!(GlobalRunningNovellClient32 && !GlobalNonBlockingClient32)) {
                    lpSocket->SetNonBlockingMode(TRUE);
                }
            }
        }
    }
    if (lpSocket != NULL) {

        DPRINTF("%#x: releasing K-A %#x (%d+%d/%d)\n",
                GetCurrentThreadId(),
                lpSocket ? lpSocket->GetSocket() : 0,
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        INET_ASSERT(lpSocket->IsOpen());
        INET_ASSERT(!lpSocket->IsOnList());
        //INET_ASSERT(!lpSocket->IsReset());

        lpSocket->SetKeepAlive();

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("releasing keep-alive socket %#x\n",
                    lpSocket->GetSocket()
                    ));

        lpSocket->SetExpiryTime(GlobalKeepAliveSocketTimeout);

        INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, lpSocket->List()));

        InsertAtTailOfSerializedList(&m_KeepAliveList, lpSocket->List());

        if (lpSocket->ConnLimitExempted())
        {
            lpSocket->ResetExemptFlag();
            --m_ConnectionsAvailable;
        
            if (KeepAliveConnections() > ConnectionLimit())
            {
                INET_ASSERT(KeepAliveConnections() - ConnectionLimit() == 1);

                ICSocket* pOldestSocket = ContainingICSocket(SlDequeueHead(&m_KeepAliveList));
                pOldestSocket->SetLinger(FALSE, 0);
                pOldestSocket->Shutdown(2);
                pOldestSocket->Destroy();
                pOldestSocket = NULL;
            }
        }

        lpSocket = NULL;

        INET_ASSERT(UnlimitedConnections()
           ? TRUE
           : (KeepAliveConnections() <= ConnectionLimit()));

        bRelease = TRUE;
    } else {

        DPRINTF("%#x: releasing connection (%d+%d/%d)\n",
                GetCurrentThreadId(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                );

        if (!UnlimitedConnections() && !fExemptConnLimit) {
            ++m_ConnectionsAvailable;
        }

        CHECK_CONNECTION_COUNT();

        bRelease = TRUE;
    }
    if (bRelease && !UnlimitedConnections() && !fExemptConnLimit) {

        CHECK_CONNECTION_COUNT();

        CConnectionWaiter * pWaiter = (CConnectionWaiter *)m_Waiters.RemoveHead();

        if (pWaiter != NULL) {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("unblocking %s waiter %#x, pri=%d\n",
                        pWaiter->IsSync() ? "SYNC" : "ASYNC",
                        pWaiter->Id(),
                        pWaiter->GetPriority()
                        ));

            DPRINTF("%#x: Unblocking %s connection waiter %#x, pri=%d\n",
                    GetCurrentThreadId(),
                    pWaiter->IsSync() ? "Sync" : "Async",
                    pWaiter->Id(),
                    pWaiter->GetPriority()
                    );

            if (pWaiter->IsSync()) {
                pWaiter->Signal();
            } else {

                DWORD n = UnblockWorkItems(1, (DWORD_PTR)pWaiter, ERROR_SUCCESS);

                //INET_ASSERT(n == 1);
            }
            delete pWaiter;
        } else {

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("no waiters\n"
                        ));

            DPRINTF("%#x: !!! NOT unblocking connection waiter\n",
                    GetCurrentThreadId()
                    );

        }
    } else {

        DPRINTF("%#x: !!! NOT releasing or unlimited?\n",
                GetCurrentThreadId()
                );

        DEBUG_PRINT(SESSION,
                    INFO,
                    ("bRelease = %B, UnlimitedConnections() = %B\n",
                    bRelease,
                    UnlimitedConnections()
                    ));

    }

    DEBUG_PRINT(SESSION,
                INFO,
                ("avail+k-a/limit = %d+%d/%d\n",
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    if (IsNewLimit()) {
        UpdateConnectionLimit();
    }

    m_Waiters.Release();

    PERF_LEAVE(ReleaseConnection);

    DEBUG_LEAVE(error);

    DPRINTF("%#x: %s: %d+%d/%d: rls %#x: %d, %d\n",
            GetCurrentThreadId(),
            GetHostName(),
            AvailableConnections(),
            KeepAliveConnections(),
            ConnectionLimit(),
            lpSocket ? lpSocket->GetSocket() : 0,
            error,
            m_Waiters.Count()
            );

    return error;
}

#endif // NEW_CONNECTION_SCHEME


VOID
CServerInfo::RemoveWaiter(
    IN DWORD_PTR dwId
    )

/*++

Routine Description:

    Removes a CConnectionWaiter corresponding to the FSM

Arguments:

    dwId    - waiter id to match

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::RemoveWaiter",
                 "%#x",
                 dwId
                 ));

    m_Waiters.Acquire();

    CConnectionWaiter * pWaiter;
    BOOL found = FALSE;

    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->Id() == dwId) {
            m_Waiters.Remove((CPriorityListEntry *)pWaiter);
            delete pWaiter;
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

    //INET_ASSERT(found);

    DEBUG_LEAVE(0);
}

//
// private CServerInfo methods
//


ICSocket *
CServerInfo::FindKeepAliveConnection(
    IN DWORD dwSocketFlags,
    IN INTERNET_PORT nPort,
    IN LPSTR pszTunnelServer
    )

/*++

Routine Description:

    Find a keep-alive connection with the requested attributes and port number

Arguments:

    dwSocketFlags   - socket type flags (e.g. SF_SECURE)

    nPort           - port to server

    pszTunnelServer - hostname of server through SSL tunnel, or
                      NULL if not checked.

Return Value:

    ICSocket *

--*/

{
    DPRINTF("%#x: *** looking for K-A connection\n", GetCurrentThreadId());

    DEBUG_ENTER((DBG_SESSION,
                 Pointer,
                 "CServerInfo::FindKeepAliveConnection",
                 "{%q} %#x, %d",
                 GetHostName(),
                 dwSocketFlags,
                 nPort
                 ));

    ICSocket * pSocket = NULL;
    BOOL bFound = FALSE;

    //
    // don't check whether socket is non-blocking - we only really want to match
    // on secure/non-secure. Possible flags to check on are:
    //
    //  SF_ENCRYPT          - should be subsumed by SF_SECURE
    //  SF_DECRYPT          - should be subsumed by SF_SECURE
    //  SF_NON_BLOCKING     - this isn't criterion for match
    //  SF_CONNECTIONLESS   - not implemented?
    //  SF_AUTHORIZED       - must be set if authorized & in pool
    //  SF_SECURE           - opened for SSL/PCT if set
    //  SF_KEEP_ALIVE       - must be set
    //  SF_TUNNEL           - must be set if we're looking for a CONNECT tunnel to proxy
    //

    dwSocketFlags &= ~SF_NON_BLOCKING;

    LockSerializedList(&m_KeepAliveList);

    PLIST_ENTRY pEntry;

    for (pEntry = HeadOfSerializedList(&m_KeepAliveList);
         pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
         pEntry = pEntry->Flink) {

        pSocket = ContainingICSocket(pEntry);

        INET_ASSERT(pSocket->IsKeepAlive());

        //
        // We make sure the socket we request is the correct socket,
        //  Match() is a bit confusing and needs a bit of explaining,
        //  Match IS NOT AN EXACT MATCH, it mearly checks to make sure 
        //  that the requesting flags (dwSocketFlags) are found in the 
        //  socket flags.  So this can lead to a secure socket being returned
        //  on a non-secure open request, now realistically this doesn't happen
        //  because of the port number.  But in the case of tunnelling this may be
        //  an issue, so we add an additional check to make sure that we only
        //  get a tunneled socket to a proxy if we specifically request one.
        //

        if (pSocket->Match(dwSocketFlags)
        && (pSocket->GetPort() == nPort)
        &&  pSocket->MatchTunnelSemantics(dwSocketFlags, pszTunnelServer)) {
            RemoveFromSerializedList(&m_KeepAliveList, pSocket->List());

            INET_ASSERT(!IsOnSerializedList(&m_KeepAliveList, pSocket->List()));

            bFound = TRUE;

            DEBUG_PRINT(SESSION,
                        INFO,
                        ("returning keep-alive socket %#x\n",
                        pSocket->GetSocket()
                        ));

            DPRINTF("%#x: *** %s keep-alive connection %#x (%d/%d), wantf=%#x, gotf=%#x\n",
                    GetCurrentThreadId(),
                    GetHostName(),
                    pSocket->GetSocket(),
                    AvailableConnections(),
                    ConnectionLimit(),
                    dwSocketFlags,
                    pSocket->GetFlags()
                    );

            break;
        }
    }
    UnlockSerializedList(&m_KeepAliveList);
    if (!bFound) {
        pSocket = NULL;
    }

    DEBUG_LEAVE(pSocket);

    return pSocket;
}


BOOL
CServerInfo::KeepAliveWaiters(
    VOID
    )

/*++

Routine Description:

    Determine if any of the waiters on the list are for keep-alive connections

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Bool,
                 "CServerInfo::KeepAliveWaiters",
                 NULL
                 ));

    BOOL found = FALSE;
    CConnectionWaiter * pWaiter;

    m_Waiters.Acquire();
    for (pWaiter = (CConnectionWaiter *)m_Waiters.Head();
         pWaiter != (CConnectionWaiter *)m_Waiters.Self();
         pWaiter = (CConnectionWaiter *)pWaiter->Next()) {

        if (pWaiter->IsKeepAlive()) {
            found = TRUE;
            break;
        }
    }
    m_Waiters.Release();

    DEBUG_LEAVE(found);

    return found;
}

#ifdef NEW_CONNECTION_SCHEME
//
//
//BOOL
//CServerInfo::RunOutOfConnections(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Determines whether we have been run out of connections. Criteria for being
//    out of connections is: no available connections or keep-alive connections
//    and no recorded connection activity within GlobalConnectionInactiveTimeout
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    BOOL
//        TRUE    - we are out of connections
//
//        FALSE   - not
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_SESSION,
//                 Bool,
//                 "CServerInfo::RunOutOfConnections",
//                 NULL
//                 ));
//
//    BOOL bOut = FALSE;
//
//    if ((TotalAvailableConnections() == 0)
//    && (GetLastActiveTime() != 0)
//    && !ConnectionActivity()) {
//
//        DPRINTF("%#x: >>>>>>>> Run out of connections. Last activity %d mSec ago. Create new\n",
//                GetCurrentThreadId(),
//                (GetLastActiveTime() == 0)
//                    ? -1
//                    : (GetTickCount() - GetLastActiveTime())
//                );
//
//        INET_ASSERT(!UnlimitedConnections());
//
//        DEBUG_PRINT(SESSION,
//                    WARNING,
//                    ("out of connections! Last activity %d mSec ago. Creating new\n",
//                    (GetLastActiveTime() == 0)
//                        ? -1
//                        : (GetTickCount() - GetLastActiveTime())
//                    ));
//
//        bOut = TRUE;
//    } else if (TotalAvailableConnections() == 0) {
//
//        DPRINTF("%#x: no connections, last activity %d mSec ago\n",
//                GetCurrentThreadId(),
//                (GetLastActiveTime() == 0)
//                    ? -1
//                    : (GetTickCount() - GetLastActiveTime())
//                );
//
//        DEBUG_PRINT(SESSION,
//                    INFO,
//                    ("no connections, last activity %d mSec ago\n",
//                    (GetLastActiveTime() == 0)
//                        ? -1
//                        : (GetTickCount() - GetLastActiveTime())
//                    ));
//
//    }
//
//    DEBUG_LEAVE(bOut);
//
//    return bOut;
//}
//
#endif // NEW_CONNECTION_SCHEME


VOID
CServerInfo::UpdateConnectionLimit(
    VOID
    )

/*++

Routine Description:

    Change connection limit to new limit

    Assumes: 1. Caller has acquired this object before calling this function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::UpdateConnectionLimit",
                 "{%q: %d=>%d (%d+%d)}",
                 GetHostName(),
                 ConnectionLimit(),
                 GetNewLimit(),
                 AvailableConnections(),
                 KeepAliveConnections()
                 ));

    LONG difference = GetNewLimit() - ConnectionLimit();

    //
    // BUGBUG - only handling increases in limit for now
    //

    INET_ASSERT(difference > 0);

    if (difference > 0) {
        m_ConnectionsAvailable += difference;
    }
    m_ConnectionLimit = m_NewLimit;

    DEBUG_PRINT(SESSION,
                INFO,
                ("%q: new: %d+%d/%d\n",
                GetHostName(),
                AvailableConnections(),
                KeepAliveConnections(),
                ConnectionLimit()
                ));

    DEBUG_LEAVE(0);
}


VOID
CServerInfo::PurgeKeepAlives(
    IN DWORD dwForce
    )

/*++

Routine Description:

    Purges any timed-out keep-alive connections

Arguments:

    dwForce - force to apply when purging. Value can be:

                PKA_NO_FORCE    - only purge timed-out sockets or sockets in
                                  close-wait state (default)

                PKA_NOW         - purge all sockets

                PKA_AUTH_FAILED - purge sockets that have been marked as failing
                                  authentication

Return Value:

    None.

--*/

{
//dprintf("%#x PurgeKeepAlives(%d)\n", GetCurrentThreadId(), dwForce);
    DEBUG_ENTER((DBG_SESSION,
                 None,
                 "CServerInfo::PurgeKeepAlives",
                 "{%q [ref=%d, k-a=%d]} %s [%d]",
                 GetHostName(),
                 ReferenceCount(),
                 KeepAliveConnections(),
                 (dwForce == PKA_NO_FORCE) ? "NO_FORCE"
                 : (dwForce == PKA_NOW) ? "NOW"
                 : (dwForce == PKA_AUTH_FAILED) ? "AUTH_FAILED"
                 : "?",
                 dwForce
                 ));

    if (IsKeepAliveListInitialized()) {

        INET_ASSERT(ReferenceCount() >= 1);

        m_Waiters.Acquire();
        LockSerializedList(&m_KeepAliveList);

        PLIST_ENTRY last = (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
        DWORD ticks = GetTickCountWrap();

        for (PLIST_ENTRY pEntry = HeadOfSerializedList(&m_KeepAliveList);
            pEntry != (PLIST_ENTRY)SlSelf(&m_KeepAliveList);
            pEntry = last->Flink) {

            ICSocket * pSocket = ContainingICSocket(pEntry);
            BOOL bDelete;

            if (pSocket->IsReset()) {
//dprintf("%q: socket %#x/%d CLOSE-WAIT\n", GetHostName(), pSocket->GetSocket(), pSocket->GetSourcePort());
                bDelete = TRUE;
            } else if (dwForce == PKA_NO_FORCE) {
                bDelete = pSocket->HasExpired(ticks);
            } else if (dwForce == PKA_NOW) {
                bDelete = TRUE;
            } else if (dwForce == PKA_AUTH_FAILED) {
                bDelete = pSocket->IsAuthorized();
            }
            if (bDelete) {
//dprintf("%q: socket %#x/%d. Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
//        GetHostName(),
//        pSocket->GetSocket(),
//        pSocket->GetSourcePort(),
//        pSocket->IsReset(),
//        pSocket->HasExpired(ticks),
//        (dwForce == PKA_NOW),
//        (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
//        );

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("purging keep-alive socket %#x/%d: Close-Wait=%B, Expired=%B, Now=%B, Auth=%B\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->IsReset(),
                            pSocket->HasExpired(ticks),
                            (dwForce == PKA_NOW),
                            (dwForce == PKA_AUTH_FAILED) && pSocket->IsAuthorized()
                            ));

                RemoveFromSerializedList(&m_KeepAliveList, pEntry);

                BOOL bDestroyed;

                bDestroyed = pSocket->Dereference();

                INET_ASSERT(bDestroyed);

                if (!UnlimitedConnections()) {
                    ++m_ConnectionsAvailable;

                    INET_ASSERT(m_ConnectionsAvailable <= m_ConnectionLimit);

                }

            } else {

                DEBUG_PRINT(SESSION,
                            INFO,
                            ("socket %#x/%d expires in %d mSec\n",
                            pSocket->GetSocket(),
                            pSocket->GetSourcePort(),
                            pSocket->GetExpiryTime() - ticks
                            ));

                last = pEntry;
            }
        }

        UnlockSerializedList(&m_KeepAliveList);
        m_Waiters.Release();
    }

    DEBUG_LEAVE(0);
}

//
// friend functions
//


CServerInfo *
ContainingServerInfo(
    IN LPVOID lpAddress
    )

/*++

Routine Description:

    Returns address of CServerInfo given address of m_List

Arguments:

    lpAddress   - address of m_List

Return Value:

    CServerInfo *

--*/

{
    return CONTAINING_RECORD(lpAddress, CServerInfo, m_List);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\handle.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    handle.cxx

Abstract:

    Contains function to return number of open handles owned by this process

    Contents:
        InternetHandleCount

Author:

    Richard L Firth (rfirth) 02-May-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-May-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// private types
//

typedef (*NT_QUERY_SYSTEM_INFORMATION)(ULONG, PVOID, ULONG, PULONG);

//
// functions
//


DWORD
InternetHandleCount(
    VOID
    )

/*++

Routine Description:

    Gets the number of system handles owned by this process. We LoadLibrary()
    NTDLL.DLL so that the debug version of this DLL still works on Win95

Arguments:

    None.

Return Value:

    DWORD

--*/

{
    static HINSTANCE hNtdll = NULL;
    static NT_QUERY_SYSTEM_INFORMATION _NtQuerySystemInformation;

    if (IsPlatformWin95()) {
        return 0;
    }

    if (hNtdll == NULL) {
        hNtdll = LoadLibrary("ntdll");
        if (hNtdll == NULL) {
            return 0;
        }
        _NtQuerySystemInformation = (NT_QUERY_SYSTEM_INFORMATION)GetProcAddress(hNtdll, "NtQuerySystemInformation");
        if (_NtQuerySystemInformation == 0) {
            FreeLibrary(hNtdll);
            hNtdll = NULL;
        }
    }

    if (_NtQuerySystemInformation) {

        DWORD idProcess;
        NTSTATUS status;
        ULONG outputLength;
        BYTE buffer[32768];
        PSYSTEM_PROCESS_INFORMATION info;

        status = _NtQuerySystemInformation(SystemProcessInformation,
                                           (PVOID)buffer,
                                           sizeof(buffer),
                                           &outputLength
                                           );
        if (!NT_SUCCESS(status)) {
            return 0;
        }
        info = (PSYSTEM_PROCESS_INFORMATION)buffer;
        idProcess = GetCurrentProcessId();
        while (TRUE) {
            if ((DWORD_PTR)info->UniqueProcessId == idProcess) {
                return info->HandleCount;
            }
            if (info->NextEntryOffset == 0) {
                return 0;
            }
            info = (PSYSTEM_PROCESS_INFORMATION)((PCHAR)info + info->NextEntryOffset);
        }
    }
    return 0;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\rprintf.h ===
/*****************************************************************************
 *
 *  RPRINTF.C   RLF 06/15/89
 *
 *  CONTENTS    rprintf     limited re-entrant version of printf
 *              rsprintf    limited re-entrant version of sprintf
 *              _sprintf    routine which does the work
 *
 *  NOTES       Tab Stops = 4
 *
 *  $Log:   T:/pvcs/h/rprintf.h_v  $
 *
 *    Rev 1.1   29 Oct 1989 11:50:16   Richard Firth
 * Added defines for PRINTF and SPRINTF to allow easy modification when MS gets
 * the real thing working for multi-threaded programs
 *
 *    Rev 1.0   29 Aug 1989 20:04:40   RICHARDF
 * Initial revision.
 *
 ****************************************************************************/

#ifdef UNUSED
// UNUSED - causes unneed crt bloat
int cdecl rprintf(char*, ...);
#endif
int cdecl rsprintf(char*, char*, ...);
int cdecl _sprintf(char*, char*, va_list);

#define SPRINTF rsprintf
#define PRINTF  rprintf

//#define rsprintf wsprintf
//#define _sprintf wsprintf

#define RPRINTF_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\util.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains utility functions

    Contents:
        new
        delete
        NewString
        CatString
        ResizeBuffer
        _memrchr
        strnistr
        PrivateStrChr
        PlatformType
        PlatformSupport
        GetTimeoutValue
        ProbeReadBuffer
        ProbeWriteBuffer
        ProbeAndSetDword
        ProbeString
        LoadDllEntryPoints
        UnloadDllEntryPoints
        MapInternetError
        CalculateHashValue
        GetCurrentGmtTime
        GetFileExtensionFromUrl
        CheckExpired
        FTtoString
        PrintFileTimeInInternetFormat
        InternetSettingsChanged
        RefreshSslState
        CertHashToStr
        ConvertSecurityInfoIntoCertInfoStruct
        FormatCertInfo
        UnicodeToUtf8
        CountUnicodeToUtf8
        ConvertUnicodeToUtf8
        StringContainsHighAnsi
        IsAddressValidIPString
        IsInGUIModeSetup

Author:

    Richard L Firth (rfirth) 31-Oct-1994

Revision History:

    31-Oct-1994 rfirth
        Created

--*/

#include <wininetp.h>

#if !defined(PAGE_SIZE)
#define PAGE_SIZE   4096
#endif
#define DEFAULT_MAX_EXTENSION_LENGTH    8

#pragma warning(disable: 4102)

//
// private prototypes
//



//
// functions
//
void * __cdecl operator new(size_t Size) {
    return (void *)ALLOCATE_FIXED_MEMORY((UINT)Size);
}

void __cdecl operator delete(void * Pointer) {
    FREE_MEMORY((HLOCAL)Pointer);
}

LPSTR
NewString(
    IN LPCSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : strlen(lpszIn));
    LPSTR lpszOut;

    if (lpszOut = (LPSTR)ALLOCATE_FIXED_MEMORY(len+1)) {
        memcpy(lpszOut, lpszIn, len);
        *(lpszOut + len) = '\0';
    }
    return lpszOut;
}

LPWSTR
NewStringW(
    IN LPCWSTR lpszIn,
    IN DWORD dwLen
    )

/*++

Routine Description:

    kind of version of strdup() but using LocalAlloc to allocate memory

Arguments:

    String  - pointer to string to make copy of

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

{
    int len = (dwLen ? dwLen : lstrlenW(lpszIn));
    LPWSTR lpszOut;

    if (lpszOut = (LPWSTR)ALLOCATE_FIXED_MEMORY((sizeof(WCHAR)*(len+1)))) {
        memcpy(lpszOut, lpszIn, len*sizeof(WCHAR));
        *(lpszOut + len) = L'\0';
    }
    return lpszOut;
}

/*++

Routine Description:

    kind of version of strcat() but using LocalAlloc to allocate memory

Arguments:

    strings to concatenate

Return Value:

    LPSTR
        Success - pointer to duplicated string
        Failure - NULL

--*/

LPSTR
CatString (
    IN LPCSTR lpszLeft,
    IN LPCSTR lpszRight
    )
{
    int cbLeft  = strlen(lpszLeft);
    int cbRight = strlen(lpszRight) + 1; // include null termination
    LPSTR lpszOut;

    if (lpszOut = (LPSTR) ALLOCATE_FIXED_MEMORY (cbLeft + cbRight)) {
        memcpy (lpszOut, lpszLeft, cbLeft);
        memcpy (lpszOut + cbLeft, lpszRight, cbRight);
    }
    return lpszOut;
}



HLOCAL
ResizeBuffer(
    IN HLOCAL BufferHandle,
    IN DWORD Size,
    IN BOOL Moveable
    )

/*++

Routine Description:

    Allocate, reallocate or free a buffer. If the buffer is moveable memory
    then it must be unlocked. If reallocating, the buffer can be grown or
    shrunk, depending on the current and required sizes

    Caveat Programmer:

    Regardless of whether a pre-existing buffer is moveable or fixed memory,
    it will be reallocated with the LMEM_MOVEABLE flag, possibly causing the
    output pointer to be different from the pre-existing pointer

Arguments:

    BufferHandle    - current handle of memory buffer. If NULL, a buffer will
                      be allocated

    Size            - size of buffer to allocate (or shrink to). If 0, the
                      buffer will be freed

    Moveable        - if TRUE and allocating memory then allocates a moveable
                      memory buffer, else fixed

Return Value:

    HLOCAL
        Success - handle of moveable memory buffer

        Failure - NULL;

--*/

{
    INET_ASSERT(!Moveable);

    if (BufferHandle == NULL) {

        //
        // don't allocate anything if no size - LocalAlloc() will return pointer
        // to memory object marked as discarded if we request a zero-length
        // moveable buffer. But I know that if Size is also 0, I don't want a
        // buffer at all, discarded or otherwise
        //

        if (Size != 0) {
            BufferHandle = ALLOCATE_MEMORY(Moveable ? LMEM_MOVEABLE : LMEM_FIXED, Size);
        }
    } else if (Size == 0) {
        BufferHandle = FREE_MEMORY(BufferHandle);

        INET_ASSERT(BufferHandle == NULL);

    } else {
        HLOCAL temp = BufferHandle;
        BufferHandle = REALLOCATE_MEMORY(BufferHandle, Size, LMEM_MOVEABLE);
        if(!BufferHandle)
        {
            FREE_MEMORY(temp);
        }
    }
    return BufferHandle;
}


LPSTR
_memrchr(
    IN LPSTR lpString,
    IN CHAR cTarget,
    IN INT iLength
    )

/*++

Routine Description:

    Reverse find character in string

Arguments:

    lpString    - pointer to string in which to locate character

    cTarget     - target character to find

    iLength     - length of string

Return Value:

    LPSTR   - pointer to located character or NULL

--*/

{
    for (--iLength; (iLength >= 0) && (lpString[iLength] != cTarget); --iLength) {

        //
        // empty loop
        //

    }
    return (iLength < 0) ? NULL : &lpString[iLength];
}


LPSTR
strnistr(
    IN LPSTR str1,
    IN LPSTR str2,
    IN DWORD Length
    )

/*++

Routine Description:

    Case-insensitive search for substring

Arguments:

    str1    - string to search in

    str2    - substring to find

    Length  - of str1

Return Value:

    LPSTR   - pointer to located str2 in str1 or NULL

--*/

{
    if (!*str2) {
        return str1;
    }

    for (LPSTR cp = str1; *cp && Length; ++cp, --Length) {

        LPSTR s1 = cp;
        LPSTR s2 = str2;
        DWORD l2 = Length;

        while (*s1 && *s2 && l2 && (toupper(*s1) == toupper(*s2))) {
            ++s1;
            ++s2;
            --l2;
        }

        if (!*s2) {
            return cp;
        }

        if (!l2) {
            break;
        }
    }

    return NULL;
}

LPSTR
FASTCALL
PrivateStrChr(
    IN LPCSTR lpStart,
    IN WORD wMatch
    )
/*++

Routine Description:

    Find first occurrence of character in string

    Private implimentation of StrChrA, this code is based on
     a code snipet from ShlWapi, but by placing it here,
     we can remove the extra NLS support that was needed
     in SHLWAPI.   This piece of code is over twice as fast
     as the call into SHLWAPI.

Arguments:

    lpStart - points to start of null terminated string

    wMatch  - the character to match

Return Value:

    LPSTR   - ptr to the first occurrence of ch in str, NULL if not found.

--*/
{
    for ( ; *lpStart; lpStart++)
    {
        if ((BYTE)*lpStart == LOBYTE(wMatch)) {
            return((LPSTR)lpStart);
        }
    }

    return (NULL);
}


DWORD
GetTickCountWrap()
{
#ifdef DEBUG_GETTICKCOUNT
    static BOOL fInit = FALSE;
    static DWORD dwDelta = 0;
    static DWORD dwBasis = 0;

    if (!fInit)
    {
        HKEY clientKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                                 0, // reserved
                                 KEY_QUERY_VALUE,
                                 &clientKey))
        {
            DWORD dwSize = sizeof(dwDelta);
            RegQueryValueEx(clientKey, "RollOverDelta", NULL, NULL, (LPBYTE)&dwDelta, &dwSize);
        }
        dwBasis = GetTickCount();
        fInit = TRUE;
    }
    DWORD dwResult = GetTickCount() - dwBasis + dwDelta;
    return dwResult;
#else
    return GetTickCount();
#endif
}


DWORD
PlatformType(
    IN OUT LPDWORD lpdwVersion5os
    )

/*++

Routine Description:

    Returns the platform type based on the operating system information. We use
    our own platform types

Arguments:

    lpdwVersion5os - optional pointer to value, set to TRUE if we on NT 5

Return Value:

    DWORD
        Failure - PLATFORM_TYPE_UNKNOWN
                    either GetVersionEx() failed, or we are running on an
                    unrecognized operating system

        Success - PLATFORM_TYPE_WIN95
                    The world's favourite desktop O/S

                  PLATFORM_TYPE_WINNT
                    The world's best O/S on top of anything

--*/

{
#ifndef UNIX
    OSVERSIONINFO versionInfo;

    *lpdwVersion5os = FALSE;

    versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);
    if (GetVersionEx(&versionInfo)) {
        switch (versionInfo.dwPlatformId) {
        case VER_PLATFORM_WIN32_WINDOWS:
            if(versionInfo.dwMinorVersion >= 90) {
                GlobalPlatformMillennium = TRUE;
            }
            return PLATFORM_TYPE_WIN95;

        case VER_PLATFORM_WIN32_NT:

            if ( lpdwVersion5os && 
                versionInfo.dwMajorVersion >= 5 ) {                
                *lpdwVersion5os = TRUE;

                if (versionInfo.dwMinorVersion >= 1) {
                    GlobalPlatformWhistler = TRUE;
                }
            }
            return PLATFORM_TYPE_WINNT;

        }

    }
    return PLATFORM_TYPE_UNKNOWN;
#else
    return PLATFORM_TYPE_UNIX;
#endif /* UNIX */
}

//
//DWORD
//PlatformSupport(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Returns a bitmap of capabilities supported by this operating system
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    DWORD
//
//--*/
//
//{
//    switch (PlatformType()) {
//    case PLATFORM_TYPE_WINNT:
//        return PLATFORM_SUPPORTS_UNICODE;
//    }
//    return 0;
//}


DWORD
GetTimeoutValue(
    IN DWORD TimeoutOption
    )

/*++

Routine Description:

    Gets a timeout value. The timeout is retrieved from the current handle. If
    it is not available in the current handle then the parent handle is checked
    (actually the current handle is derived from the parent, so this doesn't
    really do anything). If the value is still not available, then the global
    default is used

Arguments:

    TimeoutOption   - INTERNET_OPTION_ value used to specify the timeout value

Return Value:

    DWORD
        Requested timeout value

--*/

{
    HINTERNET hInternet;
    DWORD timeout;
    DWORD error;

    hInternet = InternetGetMappedObjectHandle();
    if (hInternet != NULL) {
        error = RGetTimeout(hInternet, TimeoutOption, &timeout);
    }
    if ((hInternet == NULL) || (error != ERROR_SUCCESS)) {
        switch (TimeoutOption) {
        case INTERNET_OPTION_SEND_TIMEOUT:
            timeout = GlobalSendTimeout;
            break;

        case INTERNET_OPTION_RECEIVE_TIMEOUT:
            timeout = GlobalReceiveTimeout;
            break;

        case INTERNET_OPTION_DATA_SEND_TIMEOUT:
            timeout = GlobalDataSendTimeout;
            break;

        case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
            timeout = GlobalDataReceiveTimeout;
            break;

        case INTERNET_OPTION_CONNECT_TIMEOUT:
            timeout = GlobalConnectTimeout;
            break;

        case INTERNET_OPTION_CONNECT_RETRIES:
            timeout = GlobalConnectRetries;
            break;

        case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
            timeout = GlobalFromCacheTimeout;
            break;
        }
    }
    return timeout;
}


DWORD
ProbeReadBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for readability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_INVALID_PARAMETER;
    }

    return error;
}


DWORD
ProbeWriteBuffer(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Probes a buffer for writeability. Used as part of API parameter validation,
    this function tests the first and last locations in a buffer. This is not
    as strict as the IsBadXPtr() Windows APIs, but it means we don't have to
    test every location in the buffer

Arguments:

    lpBuffer        - pointer to buffer to test

    dwBufferLength  - length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    //
    // the buffer can be NULL if the probe length is 0. Otherwise, its an error
    //

    if (lpBuffer == NULL) {
        error = (dwBufferLength == 0) ? ERROR_SUCCESS : ERROR_INVALID_PARAMETER;
    } else if (dwBufferLength != 0) {
        __try {

            LPBYTE p;
            LPBYTE end;
            volatile BYTE b;

            p = (LPBYTE)lpBuffer;
            end = p + dwBufferLength - 1;
            b = *end;
            *end = b;

            //
            // visit every page in the buffer - it doesn't matter that we may
            // test a character in the middle of a page
            //

            for (; p < end; p += PAGE_SIZE) {
                b = *p;
                *p = b;
            }
            error = ERROR_SUCCESS;
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    } else {

        //
        // zero-length buffer
        //

        error = ERROR_SUCCESS;
    }

    return error;
}


DWORD
ProbeAndSetDword(
    IN LPDWORD lpDword,
    IN DWORD dwValue
    )

/*++

Routine Description:

    Probes a single DWORD buffer for writeability, and as a side-effect sets it
    to a default value. Used as part of API parameter validation

Arguments:

    lpDword - pointer to DWORD buffer to test

    dwValue - default value to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;

    __try {
        *lpDword = dwValue;
        error = ERROR_SUCCESS;
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
    return error;
}


DWORD
ProbeString(
    IN LPSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}

DWORD
ProbeStringW(
    IN LPWSTR lpString,
    OUT LPDWORD lpdwStringLength
    )

/*++

Routine Description:

    Probes a wide string buffer for readability, and returns the length of the string

Arguments:

    lpString            - pointer to string to check

    lpdwStringLength    - returned length of string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    DWORD length;

    //
    // initialize string length and return code
    //

    length = 0;
    error = ERROR_SUCCESS;

    //
    // the buffer can be NULL
    //

    if (lpString != NULL) {
        __try {

            //
            // unfortunately, for a string, we have to visit every location in
            // the buffer to find the terminator
            //

            while (*lpString != '\0') {
                ++length;
                ++lpString;
            }
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            error = ERROR_INVALID_PARAMETER;
        }
        ENDEXCEPT
    }

    *lpdwStringLength = length;

    return error;
}


DWORD
LoadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Dynamically loads a DLL and the entry points described in lpDllEntryPoints

    Assumes:    1. Any thread serialization taken care of by caller

                2. Module handle, entry point addresses and reference count
                   already set to 0 if this is first time the DLL_INFO is
                   being used to load the DLL

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and entry points to load

    dwFlags     - flags controlling how this function operates:

                    LDEP_PARTIAL_LOAD_OK
                        - not fatal if we can't load all entry points

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "LoadDllEntryPoints",
                 "%x [%q, %d], %#x",
                 lpDllInfo,
                 lpDllInfo->lpszDllName,
                 lpDllInfo->dwNumberOfEntryPoints,
                 dwFlags
                 ));

    DWORD error = ERROR_SUCCESS;

    if (lpDllInfo->hModule == NULL) {

        DWORD dwMode = SetErrorMode(SEM_FAILCRITICALERRORS);
        HMODULE hDll = LoadLibrary(lpDllInfo->lpszDllName);

        if (hDll != NULL) {
            lpDllInfo->hModule = hDll;
            lpDllInfo->LoadCount = 1;

            for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {

                FARPROC proc = GetProcAddress(
                                    hDll,
                                    lpDllInfo->lpEntryPoints[i].lpszProcedureName
                                    );

                *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = proc;
                if ((proc == NULL) && !(dwFlags & LDEP_PARTIAL_LOAD_OK)) {
                    error = GetLastError();
                    UnloadDllEntryPoints(lpDllInfo, TRUE);
                    break;
                }
            }
        } else {
            error = GetLastError();
        }
        SetErrorMode(dwMode);
    } else {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("info for %q already loaded\n",
                    lpDllInfo->lpszDllName
                    ));

        InterlockedIncrement(&lpDllInfo->LoadCount);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
UnloadDllEntryPoints(
    IN OUT LPDLL_INFO lpDllInfo,
    IN BOOL bForce
    )

/*++

Routine Description:

    Undoes the work of LoadDllEntryPoints()

    Assumes:    1. Any thread serialization taken care of by caller

Arguments:

    lpDllInfo   - pointer to DLL_INFO structure containing all info about DLL
                  and (loaded) entry points

    bForce      - TRUE if the DLL will be unloaded irrespective of the usage
                  count

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "UnloadDllEntryPoints",
                "%x [%q, %d], %B",
                lpDllInfo,
                lpDllInfo->lpszDllName,
                lpDllInfo->dwNumberOfEntryPoints,
                bForce
                ));

    DWORD error = ERROR_SUCCESS;

    if (bForce) {
        lpDllInfo->LoadCount = 0;
    } else if (InterlockedDecrement(&lpDllInfo->LoadCount) == 0) {
        bForce = TRUE;
    }
    if (bForce && (lpDllInfo->hModule != NULL)) {
        if (!FreeLibrary(lpDllInfo->hModule)) {
            error = GetLastError();
        }

        //
        // even if FreeLibrary() failed we clear out the load info
        //

        lpDllInfo->hModule = NULL;
        for (DWORD i = 0; i < lpDllInfo->dwNumberOfEntryPoints; ++i) {
            *lpDllInfo->lpEntryPoints[i].lplpfnProcedure = NULL;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

#ifndef CERT_E_WRONG_USAGE
#   define CERT_E_WRONG_USAGE              _HRESULT_TYPEDEF_(0x800B0110)
#endif


DWORD
MapInternetError(
    IN DWORD dwErrorCode
    )

/*++

Routine Description:

    Maps a winsock/RPC/transport error into a more user-friendly WinInet error,
    and stores the original error in the per-thread context so that the app can
    retrieve it if it really cares

    N.B. We should no longer be receiving winsock errors directly at the WinInet
    interface. They are available via InternetGetLastResponseInfo()

Arguments:

    dwErrorCode - original (winsock) error code to map

Return Value:

    DWORD
        Mapped error code, or the orignal error if its not one that we handle

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    DEBUG_ENTER((DBG_UTIL,
                Dword,
                "MapInternetError",
                "%#x [%s]",
                dwErrorCode,
                InternetMapError(dwErrorCode)
                ));

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo) {
        lpThreadInfo->dwMappedErrorCode = dwErrorCode;
    }

    switch (dwErrorCode) {

    case SEC_E_INSUFFICIENT_MEMORY        :
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case SEC_E_INVALID_HANDLE             :
    case SEC_E_UNSUPPORTED_FUNCTION       :
    case SEC_E_TARGET_UNKNOWN             :
    case SEC_E_INTERNAL_ERROR             :
    case SEC_E_SECPKG_NOT_FOUND           :
    case SEC_E_NOT_OWNER                  :
    case SEC_E_CANNOT_INSTALL             :
    case SEC_E_INVALID_TOKEN              :
    case SEC_E_CANNOT_PACK                :
    case SEC_E_QOP_NOT_SUPPORTED          :
    case SEC_E_NO_IMPERSONATION           :
    case SEC_E_LOGON_DENIED               :
    case SEC_E_UNKNOWN_CREDENTIALS        :
    case SEC_E_NO_CREDENTIALS             :
    case SEC_E_MESSAGE_ALTERED            :
    case SEC_E_OUT_OF_SEQUENCE            :
    case SEC_E_NO_AUTHENTICATING_AUTHORITY:
    case SEC_I_CONTINUE_NEEDED            :
    case SEC_I_COMPLETE_NEEDED            :
    case SEC_I_COMPLETE_AND_CONTINUE      :
    case SEC_I_LOCAL_LOGON                :
    case SEC_E_BAD_PKGID                  :
    case SEC_E_CONTEXT_EXPIRED            :
    case SEC_E_INCOMPLETE_MESSAGE         :
        dwErrorCode = ERROR_INTERNET_SECURITY_CHANNEL_ERROR;
        break;

    // Cert and Encryption errors

    case CERT_E_EXPIRED:
    case CERT_E_VALIDITYPERIODNESTING:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_DATE_INVALID;
        break;

    case CERT_E_UNTRUSTEDROOT:
        dwErrorCode = ERROR_INTERNET_INVALID_CA;
        break;

    case CERT_E_CN_NO_MATCH:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_CN_INVALID;
        break;

    case CRYPT_E_REVOKED:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_REVOKED;
        break;

    // ignore revocation if the certificate does not have a CDP
    case CRYPT_E_NO_REVOCATION_CHECK:
        dwErrorCode = ERROR_SUCCESS;
        break;

    case CRYPT_E_REVOCATION_OFFLINE:
        dwErrorCode = ERROR_INTERNET_SEC_CERT_REV_FAILED;
        break;

    case CERT_E_ROLE:
    case CERT_E_PATHLENCONST:
    case CERT_E_CRITICAL:
    case CERT_E_PURPOSE:
    case CERT_E_ISSUERCHAINING:
    case CERT_E_MALFORMED:
    case CERT_E_CHAINING:
    // We can't allow connection if server doesn't have a server auth certificate.
    // To force CERT_E_WRONG_USAGE to error out we map it to the error below.
    // In the future we need to map it to it's own non-recoverable error, so we can 
    // give the user a specific error message.
    case CERT_E_WRONG_USAGE:
        dwErrorCode = ERROR_INTERNET_SEC_INVALID_CERT;
        break;

    case WSAEINTR:
    case WSAEBADF:
    case WSAEACCES:
    case WSAEFAULT:
    case WSAEINVAL:
    case WSAEMFILE:
    case WSAEADDRINUSE:
    case WSAEADDRNOTAVAIL:
        dwErrorCode = ERROR_INTERNET_INTERNAL_ERROR;
        break;

    case WSAENOTSOCK:

        //
        // typically, if we see this error its because we tried to use a closed
        // socket handle
        //
        dwErrorCode = ERROR_INTERNET_OPERATION_CANCELLED;
        break;

    case WSAEWOULDBLOCK:
    case WSAEINPROGRESS:
    case WSAEALREADY:
    case WSAEDESTADDRREQ:
    case WSAEPROTOTYPE:
    case WSAENOPROTOOPT:
    case WSAEPROTONOSUPPORT:
    case WSAESOCKTNOSUPPORT:
    case WSAEOPNOTSUPP:
    case WSAEISCONN:
    case WSAETOOMANYREFS:
    case WSAELOOP:
    case WSAENAMETOOLONG:
    case WSAENOTEMPTY:
    case WSAEPROCLIM:
    case WSAEUSERS:
    case WSAEDQUOT:
    case WSAESTALE:
    case WSAEREMOTE:
    case WSAEDISCON:
    case WSASYSNOTREADY:
    case WSAVERNOTSUPPORTED:
    case WSANOTINITIALISED:

        //
        // currently unmapped errors
        //

        break;

    case WSAEMSGSIZE:
        dwErrorCode = ERROR_INSUFFICIENT_BUFFER;
        break;

    case WSAEPFNOSUPPORT:
    case WSAEAFNOSUPPORT:
        dwErrorCode = ERROR_INTERNET_TCPIP_NOT_INSTALLED;
        break;

    case WSAECONNABORTED:
    case WSAESHUTDOWN:
        dwErrorCode = ERROR_INTERNET_CONNECTION_ABORTED;
        break;

    case WSAECONNRESET:
    case WSAENETRESET:
        dwErrorCode = ERROR_INTERNET_CONNECTION_RESET;
        break;

    case WSAENOBUFS:
        dwErrorCode = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case WSAETIMEDOUT:
        dwErrorCode = ERROR_INTERNET_TIMEOUT;
        break;

    case WSAENETDOWN:
    case WSAECONNREFUSED:
    case WSAENETUNREACH:
    case WSAENOTCONN:
        dwErrorCode = ERROR_INTERNET_CANNOT_CONNECT;
        break;

    case WSAEHOSTDOWN:
    case WSAEHOSTUNREACH:
    case WSAHOST_NOT_FOUND:
    case WSATRY_AGAIN:
    case WSANO_RECOVERY:
    case WSANO_DATA:
        dwErrorCode = ERROR_INTERNET_NAME_NOT_RESOLVED;
        break;

    default:

        DEBUG_PRINT(UTIL,
                    WARNING,
                    ("MapInternetError(): unmapped error code %d [%#x]\n",
                    dwErrorCode,
                    dwErrorCode
                    ));

        break;
    }

    DEBUG_LEAVE(dwErrorCode);

    return dwErrorCode;
}


DWORD
CalculateHashValue(
    IN LPSTR lpszString
    )

/*++

Routine Description:

    Calculate a hash number given a string

Arguments:

    lpszString  - string to hash

Return Value:

    DWORD

--*/

{
    DWORD hashValue = 0;
    DWORD position = 1;

    while (*lpszString) {
        hashValue += *lpszString * position;
        ++lpszString;
        ++position;
    }
    return hashValue;
}



VOID GetCurrentGmtTime(
    LPFILETIME  lpFt
    )
/*++

Routine Description:
    This routine returns the current GMT time

Arguments:

    lpFt    FILETIME strucutre in which this is returned

Returns:

Comments:

--*/
{
    SYSTEMTIME sSysT;

    GetSystemTime(&sSysT);
    SystemTimeToFileTime(&sSysT, lpFt);
}

///***    DwRemoveDots    - Remove any dots from a path name
//**
//**  Synopsis
//**      DWORD DwRemoveDots (pchPath)
//**      Lifted from win95 kernel.
//**
//**  Input:
//**      pchPath         - A path string
//**
//**
//**  Output:
//**      returns the number of double dot levels removed from front
//**
//**  Errors:
//**      returns dwInvalid if invalid path
//**
//**  Description:
//**      Removes ..\ and .\ sequences from a path string. The path
//**      string should not include the root drive or net name portion.
//**      The return value of is the number of levels removed from the
//**      start of the string. Levels removed from inside the string
//**      will not be returned. For example:
//**
//**          String          Result              Return
//**
//**          ..\..\dir1      dir1                2
//**          dir1\..\dir2    dir2                0
//**          dir1\..\..\dir2 dir2                1
//**          .\dir1          dir1                0
//**          dir1\.\dir2     dir1\dir2           0
//**
//**      A backslash at the start of the string will be ignored.
//*/
//
//// File and path definitions
//
//#define     chExtSep    '.'
//#define     szExtSep    "."
//#define     chNetIni    '\\'
//#define     chDirSep    '\\'
//#define     szDirSep    "\\"
//#define     chDirSep2   '/'
//#define     chDrvSep    ':'
//#define     chRelDir    '.'
//#define     chEnvSep    ';'
//#define     chWldChr    '?'
//#define     chWldSeq    '*'
//#define     chMinDrv    'A'
//#define     chMaxDrv    'Z'
//#define     chMinDrvLow 'a'
//#define     chMaxDrvLow 'z'
//
//DWORD
//DwRemoveDots (
//    char * pchPath
///*++
//
//Routine Description:
//    Removes ./ ../ etc from a path to normalize it
//
//Arguments:
//
//    pchPath path string
//
//Returns:
//
//    Count of levels dealt with
//
//Comments:
//
//    Lifted from win95 kernel
//
//--*/
//)
//    {
//    BOOL            fInside = FALSE;
//    DWORD           cLevel = 0;
//    DWORD           cBackup;
//    register char * pchR;
//    register char * pchL;
//
//#ifdef MAYBE
//    // Check for invalid characters
//    if (!FFixPathChars(pchPath)) {
//        // No code required.
//        return dwInvalid;
//    }
//
//#endif //MAYBE
//    // Skip slashes
//    for (; *pchPath == chDirSep2; pchPath++)
//        ;
//    pchL = pchR = pchPath;
//
//    // Loop through handling each directory part
//    while (*pchR) {
//        // This part starts with dot. Is it one or more?
//        if (*pchR++ == chRelDir) {
//            for (cBackup = 0; *pchR == chRelDir; cBackup++, pchR++)
//                ;
//            if (cBackup) {
//                // More than one dot. Back up the left pointer.
//                if ((*pchR != chDirSep2) && (*pchR != '\0')) {
//                    // we got a [.]+X (X != '\') might be an LFN
//                    // process this as a name
//                    goto name_processing;
//                }
//                // Doesn't advance for ending ..
//                for (; *pchR == chDirSep2; pchR++)
//                    ;
//                if (fInside) {
//                    for (; cBackup; cBackup--) {
//                        if (pchL <= pchPath) {
//                            cLevel += cBackup;
//                            fInside = FALSE;
//                            break;
//                        }
//                        // Remove the previous part
//                        for (pchL -= 2; *pchL != chDirSep2; pchL--) {
//                            if (pchL <= pchPath) {
//                                fInside = FALSE;
//                                pchL--;
//                                break;
//                            }
//                        }
//                        pchL++;
//                    }
//                } else {
//                    cLevel += cBackup;
//                }
//                // Subtract ending backslash if not root
//                if ((*pchR == '\0') && (pchL != pchPath))
//                    pchL--;
//                strcpy(pchL, pchR);
//                pchR = pchL;
//            } else {
//                // This part starts with one dot. Throw it away.
//                if (*pchR != chDirSep2) {
//                    // Special case "\." by converting it to ""
//                    // unless it is a root, when it becomes "\".
//                    if (*pchR == '\0') {
//                        if (pchL == pchPath)
//                            *(pchR-1) = '\0';   // root
//                        else
//                            *(pchR-2) = '\0';   // not root
//                        return cLevel;
//                    }
//                    // we started with a '.' and then there was no '\'
//                    // might be an LFN name
//                    goto name_processing;
//                }
//                pchR++;
//                strcpy(pchL, pchR);
//                pchR = pchL;
//            }
//        } else {
//name_processing:
//            // This part is a name. Skip it.
//            fInside = TRUE;
//            for (; TRUE; pchR++) {
//                if (*pchR == chDirSep2) {
//                    if (*(pchR-1) == chRelDir) {
//                        // This name has one or more dots at the end.
//                        // Remove the last dot (NT3.5 does this).
//                        pchL = pchR-1;
//                        strcpy(pchL, pchR);
//                        pchR = pchL;    // point to chDirSep2 again
//                    }
//                    for (; *pchR == chDirSep2; pchR++)
//                        ;
//                    break;
//                } else if (*pchR == '\0') {
//                    // Remove trailing dots.
//                    // NB Can't fall off the beginning since the first char
//                    // of the current path element was not chRelDir.
//                    for (; *(pchR-1) == chRelDir; pchR--)
//                        ;
//                    // Overstore the first trailing dot, if there is one.
//                    *pchR = '\0';
//                    break;
//                }
//            }
//            pchL = pchR;
//        }
//    }
//    return cLevel;
//}


//#define OLD

#define EXE_EXTENSION   TEXT(".exe")
#define DLL_EXTENSION   TEXT(".dll")
#define CGI_EXTENSION   TEXT(".cgi")

LPSTR GetFileExtensionFromUrl(
    IN LPSTR lpszUrl,
    IN OUT LPDWORD lpdwLength)
/*++

Routine Description:
    This routine returns a possible file extension from a URL
    It does this by walking back from the end till the first  dot.

Arguments:

    lpszUrl         Url to derive the extension from

    lpdwLength      max length of the extension expected

Returns:

    NULL if no dot within the passed in length or a forward slash or a
    backward slash encountered before the dot. Otherwise returns a pointer
    pointing past the dot in the url string

Comments:



--*/
{
    INET_ASSERT(lpszUrl && lpdwLength);

#ifdef OLD
    if (lpszUrl != NULL) {

        LPSTR p;
        DWORD len=0 , lenLimit= *lpdwLength;

        p = lpszUrl + (strlen(lpszUrl) - 1);

        while ((*p != '.') && (p != lpszUrl)) {

            // if this contains a character that the filesystems
            // don't like, then return NULL
            if (strchr(vszInvalidFilenameChars, *p)) {
                return(NULL);
            }

            if ((*p == '/') || (*p == '\\')) {
                break;
            }
            --p;
            ++len;
        }
        if ((*p == '.')
        && (len != 0)
        && (len < lenLimit)) {
            *lpdwLength = len;
            return p + 1;
        }
    }
    return NULL;
#else
    if (!lpszUrl)
    {
        *lpdwLength = 0;
        return NULL;
    }

    LPSTR pszPeriod = NULL;
    BOOL fContinue = TRUE;

    // Scanning from left to right, note where we last saw a period.
    // If we see a character that cannot be in an extension, and we've seen a period, forget
    // about the period.
    // Repeat this until we've reached the end of the url, a question mark (query) or hash (fragment)

    // 1.6.98: _However_, if the file extension we've discovered is either .dll or .exe, 
    //         we'll continue to scan beyond the query mark for a file extension.

    // 1.20.98: And if we find no extension before the question mark, we'll look after it, then.
    
    while (fContinue)
    {
        switch (*lpszUrl)
        {
        case TEXT('.'):
            pszPeriod = lpszUrl;
            break;

        case TEXT('?'):
            if (pszPeriod)
            {
                if ((!StrCmpNI(pszPeriod, EXE_EXTENSION, ARRAY_ELEMENTS(EXE_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, DLL_EXTENSION, ARRAY_ELEMENTS(DLL_EXTENSION)-1))
                    || (!StrCmpNI(pszPeriod, CGI_EXTENSION, ARRAY_ELEMENTS(CGI_EXTENSION)-1)))
                {
                    pszPeriod = NULL;
                    break;
                }
            }
            else
            {
                break;
            }
            
        case TEXT('#'):
        case TEXT('\0'):
            fContinue = FALSE;
            break;

        default:
            if (pszPeriod && strchr(vszInvalidFilenameChars, *lpszUrl))
            {
                pszPeriod = NULL;
            }        
        }
        lpszUrl++;
    }
    // This will be off by one
    lpszUrl--;
    if (pszPeriod)
    {
        if (*lpdwLength < (DWORD)(lpszUrl-pszPeriod))
        {
            pszPeriod = NULL;
        }
        else
        {
            pszPeriod++;
            *lpdwLength = (DWORD)(lpszUrl-pszPeriod);
        }
    }
    return pszPeriod;
#endif
}


DWORD
CheckExpired(
    HINTERNET           hRequestMapped,
    BOOL*               lpfIsExpired,
    CACHE_ENTRY_INFO*   pInfo,
    LONGLONG            DefaultExpiryDelta
    )
/*++

Routine Description:
    This routine checks whether a cache entry has expired for ftp/gopher.
    It uses the globally set synchronization modes to make that decision

Arguments:

    hRequestMapped      a mapped request handle

    lpfIsExpired        returns TRUE if expired, FALSE otherwise

    lpCacheEntryInfo    cache entry info containing all the timestamps

    DefaultExpiryDelta  time delta to use for default expiry calculation

Returns:

    Windows error code

Comments:

--*/
{
    switch (GlobalUrlCacheSyncMode)
    {
        case WININET_SYNC_MODE_NEVER:
            // Never check, unless the page has expired
            *lpfIsExpired = FALSE;
            break;

        case WININET_SYNC_MODE_ALWAYS:
            *lpfIsExpired = TRUE;
            break;

        default:
            if (FT2LL (pInfo->LastSyncTime) < dwdwSessionStartTime)
                *lpfIsExpired = TRUE;
            else
            {
                FILETIME ftCurrent;
                GetCurrentGmtTime (&ftCurrent);
                *lpfIsExpired = (FT2LL(ftCurrent) - FT2LL (pInfo->LastSyncTime)
                    > DefaultExpiryDelta);
            }
            break;
    }

    return ERROR_SUCCESS;
}



LPTSTR
FTtoString(
    IN FILETIME *pftTime)

/*++

FTtoString:

    This routine converts a given FILETIME structure to a string representing
    the given date and time in the local format.

Arguments:

    pftTime supplies the FILETIME structure to convert.

Return Value:

    NULL - Memory allocation failure.
    Otherwise, the address of the string, allocated via LocalAlloc.

Author:

    Doug Barlow (dbarlow) 4/12/1996

--*/

{
    LONG cchTotal, cchNeeded;
    SYSTEMTIME stTime, stLocal;
    LPTSTR szDateTime = NULL;


    //
    // Convert the FILETIME to a SYSTEMTIME.
    //

    if (!FileTimeToSystemTime(pftTime, &stTime))
        goto ErrorExit;

    //
    // For now, leave it in GMT time, function not implimented in Win'95.
    //

    //if ( IsPlatformWinNT() )
    //{
    //    if (!SystemTimeToTzSpecificLocalTime(NULL, &stTime, &stLocal))
    //        goto ErrorExit;
    //}
    //else
    {
        stLocal = stTime;
    }


    //
    // Calculate how long the date string will be.
    //

    cchTotal =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchTotal)
        goto ErrorExit;
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            NULL,
            0);
    if (0 >= cchNeeded)
        goto ErrorExit;
    cchTotal += cchNeeded;
    cchTotal += 4 * sizeof(TCHAR);  // space, trailing NULL, and two extra.
    szDateTime = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, cchTotal);
    if (NULL == szDateTime)
        goto ErrorExit;


    //
    // Fill in the time string.
    //

    cchNeeded =
        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            DATE_SHORTDATE,
            &stLocal,
            NULL,
            szDateTime,
            cchTotal);
    if (0 >= cchNeeded)
        goto ErrorExit;
    lstrcat(szDateTime, TEXT(" "));
    cchNeeded = lstrlen(szDateTime);
    cchNeeded =
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stLocal,
            NULL,
            &szDateTime[cchNeeded],
            cchTotal - cchNeeded);
    if (0 >= cchNeeded)
        goto ErrorExit;
    return szDateTime;


ErrorExit:
    if (NULL != szDateTime)
        FREE_MEMORY(szDateTime);
    return NULL;
}


BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
)
{
    SYSTEMTIME sSysTime;

    if (dwSize < INTERNET_RFC1123_BUFSIZE) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }
    if (!FileTimeToSystemTime(((CONST FILETIME *)lpft), &sSysTime)) {
        return (FALSE);
    }
    return (InternetTimeFromSystemTime( &sSysTime,
                                        INTERNET_RFC1123_FORMAT,
                                        lpszBuff,
                                        dwSize));

}


BOOL
InternetSettingsChanged(
    VOID
    )

/*++

Routine Description:

    Determines if the global settings have been changed (inter-process)

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Bool,
                 "InternetSettingsChanged",
                 NULL
                 ));

    DWORD dwVer;
    BOOL bChanged = FALSE;

    if (GetCurrentSettingsVersion(&dwVer)) {

        DEBUG_PRINT(UTIL,
                    INFO,
                    ("current settings version = %d\n",
                    dwVer
                    ));

        if (!GlobalSettingsLoaded || (dwVer != GlobalSettingsVersion)) {
            GlobalSettingsLoaded = TRUE;
            GlobalSettingsVersion = dwVer;
            bChanged = TRUE;
        }
    }

    DEBUG_LEAVE(bChanged);

    return bChanged;
}


BOOL
RefreshSslState(
    VOID
    )
/*++

Routine Description:

    Starting with Whistler, client auth certificates are cached
    for the logon session (not per process).  Inetcpl now contains
    a button that will clear on-demand the SSL state for the session.
    If user cleared the SSL cache, then flush all cached
    client auth certificates in the global cert cache for this process.

    NOTE:  This function leverages a cache header data value.
           Clearing the state affects all processes, and
           using one of these (which was never put into practice)
           prevents the need for another shared registry value.

Arguments:

    None.

Return Value:

    BOOL   If the client auth cert cache was cleared, this function will
           return TRUE.  Otherwise, this will return FALSE.

--*/
{
    DWORD dwCount = 0;
    BOOL bCleared = FALSE;

    DEBUG_ENTER((DBG_UTIL,
                 Bool,
                 "RefreshSslState",
                 NULL
                 ));
    
    if (GlobalPlatformWhistler &&
        GetUrlCacheHeaderData(CACHE_HEADER_DATA_DOWNLOAD_PARTIAL, &dwCount) &&
        dwCount != GlobalSslStateCount)
    {
        GlobalSslStateCount = dwCount;
        PurgeKeepAlives(PKA_NOW);
        GlobalCertCache.ClearClientAuthCertChains();
        bCleared = TRUE;
    }

    DEBUG_LEAVE(bCleared);

    return bCleared;
}


BOOL
CertHashToStr(
    IN LPSTR lpMD5Hash,
    IN DWORD dwMD5HashSize,
    IN OUT LPSTR *lplpszHashStr
    )
/*++

Routine Description:

    Converts a set of bytes into a neatly formated string of ':' (colon) seperated
      hex digits that can be shown to the user.

Arguments:

    lpMD5Hash - ptr to set of hash bytes

    dwMD5HashSize - size of lpMD5Hash

    lplpszHashStr - ptr to ptr where newly allocated return string will be stored.

Return Value:

    BOOL

--*/

{

    DWORD dwStrSize = (2*dwMD5HashSize) + dwMD5HashSize;
    LPSTR lpszHashStr;

    *lplpszHashStr = new CHAR[dwStrSize];

    if ( *lplpszHashStr == NULL )
    {
        return FALSE;
    }

    lpszHashStr = *lplpszHashStr;

    for ( DWORD i = 0 ; i < dwMD5HashSize; i++ )
    {
        unsigned char uHashByte;

        if ( i != 0 )
        {
            *lpszHashStr = ':';
            lpszHashStr++;
        }

        uHashByte = (unsigned char) * ( ((unsigned char * ) lpMD5Hash) + i);

        wsprintf( lpszHashStr, "%02X", uHashByte);

        lpszHashStr += 2;

    }

    INET_ASSERT( *lpszHashStr == '\0' );

    return TRUE;
}


//
// private functions
//

DWORD
ConvertSecurityInfoIntoCertInfoStruct(
    IN  LPINTERNET_SECURITY_INFO   pSecInfo,
    OUT INTERNET_CERTIFICATE_INFO *pCertificate,
    IN OUT DWORD *pcbCertificate
    )
/*++

Routine Description:

    Converts an X509 Certificate Structure into a WININET struct
    used for storing the same info.

Arguments:

    hContext        - Context handle of the active SSPI session.

    pCertInfo       - Pointer to Structure where info is returned in.

Return Value:

    DWORD
    ERROR_SUCCESS   - if cert cannot be converted

    ERROR_NOT_ENOUGH_MEMORY

--*/

{


    DWORD   error = ERROR_SUCCESS;
    PCERT_INFO pCertInfo = NULL;
    DWORD cbCert = sizeof(INTERNET_CERTIFICATE_INFO),
          cbSubject = 0,
          cbIssuer = 0;

    BOOL fCanAlloc = FALSE;

    if(pSecInfo == NULL)
    {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    if(pCertificate == NULL || *pcbCertificate == 0)
    {
        *pcbCertificate = sizeof(INTERNET_CERTIFICATE_INFO);
        goto quit;
    }

    if(*pcbCertificate < sizeof(INTERNET_CERTIFICATE_INFO) )
    {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    ZeroMemory(pCertificate, sizeof(INTERNET_CERTIFICATE_INFO));
    fCanAlloc = TRUE;

    if(pSecInfo->pCertificate &&
       pSecInfo->pCertificate->pCertInfo )
    {
        pCertInfo = pSecInfo->pCertificate->pCertInfo;

        //
        // Now Convert Structures from SSPI format to WININET style.
        //  While in the process, we'll role them all into one
        //  big structure that we'll return to the user.
        //

        cbSubject = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);


        if ( cbSubject > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszSubjectInfo = (LPSTR) LocalAlloc(LPTR, cbSubject);

            if ( pCertificate->lpszSubjectInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Subject,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszSubjectInfo,
                                     cbSubject);

        }

        cbIssuer = CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG,
                                     NULL,
                                     0);

        if ( cbIssuer > 0 )
        {
            // freed by caller outside of wininet
            pCertificate->lpszIssuerInfo = (LPSTR) LocalAlloc(LPTR, cbIssuer);

            if ( pCertificate->lpszIssuerInfo == NULL )
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            CertNameToStr(pSecInfo->pCertificate->dwCertEncodingType,
                                     &pCertInfo->Issuer,
                                      CERT_SIMPLE_NAME_STR |
                                      CERT_NAME_STR_CRLF_FLAG |
                                      CERT_NAME_STR_NO_PLUS_FLAG ,
                                     pCertificate->lpszIssuerInfo,
                                     cbIssuer);

        }

        CopyMemory(
                (PVOID) &pCertificate->ftStart,
                (PVOID) &pCertInfo->NotBefore,
                sizeof(FILETIME)
                );

        CopyMemory(
                (PVOID) &pCertificate->ftExpiry,
                (PVOID) &pCertInfo->NotAfter,
                sizeof(FILETIME)
                );

    }

    /*if(pSecInfo->dwProtocol)
    {
        DWORD dwProtocolID;
        TCHAR lpszProtocol[100];

        ATTR_MAP ProtocolAttrMap[] =
        {
            {SP_PROT_SSL2_CLIENT, IDS_PROTOCOL_SSL2},
            {SP_PROT_SSL3_CLIENT, IDS_PROTOCOL_SSL3},
            {SP_PROT_PCT1_CLIENT, IDS_PROTOCOL_PCT1},
            {SP_PROT_TLS1_CLIENT, IDS_PROTOCOL_TLS1}
        };


        for(j=0; j < sizeof(ProtocolAttrMap)/sizeof(ProtocolAttrMap[0]); j++)
        {
            if(ProtocolAttrMap[j].dwAttr == pSecInfo->dwProtocol)
            {
                dwProtocolID = ProtocolAttrMap[j].dwStringID;
                break;
            }
        }
        if(LoadString(GlobalDllHandle,
                   dwProtocolID,
                   lpszProtocol,
                   sizeof(lpszProtocol)/sizeof(lpszProtocol[0])))
        {
            pCertificate->lpszProtocolName  = NewString(lpszProtocol);
        }
    } */

    pCertificate->dwKeySize = pSecInfo->dwCipherStrength;

quit:

    if ( error != ERROR_SUCCESS &&
         fCanAlloc
        )
    {

        if ( pCertificate->lpszSubjectInfo )
        {
            LocalFree(pCertificate->lpszSubjectInfo);
            pCertificate->lpszSubjectInfo = NULL;
        }

        if ( pCertificate->lpszIssuerInfo )
        {
            LocalFree(pCertificate->lpszIssuerInfo);
            pCertificate->lpszIssuerInfo = NULL;
        }
    }

    return error;
}

/*++

FormatCertInfo:

    This routine formats the information within a INTERNET_CERTIFICATE_INFO
    structure suitable for display with localization.

Arguments:

    pCertInfo supplies a pointer to the INTERNET_CERTIFICATE_INFO structure to
    be formatted.

Return Value:

    NULL - An error occurred.  Otherwise, a pointer to the formatted string.
        This string must be freed by the caller via LocalFree.

Author:

    Doug Barlow (dbarlow) 4/30/1996

--*/

LPTSTR
FormatCertInfo(
    IN INTERNET_CERTIFICATE_INFO *pCertInfo
    )
{
    LPVOID rgpvParams[9];   // Number of insertable elements in the
                            // plszStrings->szCertInfo resource
                            // string.
    LPTSTR szResult = NULL;
    int i = 0;
    PLOCAL_STRINGSA plszStrings;
    LPTSTR szFrom = NULL;
    LPTSTR szUntil = NULL;


    //
    // Get the Certificate Information.
    //

    plszStrings = FetchLocalStringsA();
    szFrom = FTtoString(&pCertInfo->ftStart);
    szUntil = FTtoString(&pCertInfo->ftExpiry);
    if ((NULL == szUntil) || (NULL == szFrom))
        goto ErrorExit;

    //ChangeCommaSpaceToCRLF(pCertInfo->lpszSubjectInfo);
    //ChangeCommaSpaceToCRLF(pCertInfo->lpszIssuerInfo);

    rgpvParams[i++] = (LPVOID)pCertInfo->lpszSubjectInfo;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszIssuerInfo;
    rgpvParams[i++] = (LPVOID)szFrom;
    rgpvParams[i++] = (LPVOID)szUntil;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszProtocolName;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszSignatureAlgName;
    rgpvParams[i++] = (LPVOID)pCertInfo->lpszEncryptionAlgName;
    rgpvParams[i++] = (LPVOID)(DWORD_PTR)pCertInfo->dwKeySize;
    if (96 <= pCertInfo->dwKeySize)  // Recommended Key strength
        rgpvParams[i++] = (LPVOID)plszStrings->szStrengthHigh;
    else if (64 <= pCertInfo->dwKeySize) // Passable key strength
        rgpvParams[i++] = (LPVOID)plszStrings->szStrengthMedium;
    else    // Ick!  Low key strength.
        rgpvParams[i++] = (LPVOID)plszStrings->szStrengthLow;
    INET_ASSERT(i == sizeof(rgpvParams) / sizeof(LPVOID));
    i = FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER
            | FORMAT_MESSAGE_FROM_STRING
            | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            plszStrings->szCertInfo,
            0, 0,
            (LPTSTR)&szResult,
            0,
            (va_list *)rgpvParams);

ErrorExit:
    if (NULL != szFrom)
        FREE_MEMORY(szFrom);
    if (NULL != szUntil)
        FREE_MEMORY(szUntil);
    return szResult;
}

DWORD
ConvertUnicodeToUTF8(
    IN LPCWSTR pwszIn,
    IN DWORD dwInBufLen,
    OUT LPSTR pszOut,
    OUT DWORD* pdwOutStrLen,
    IN BOOL bEncode
    )

/*++

Routine Description:

    Convert a string of UNICODE characters to UTF-8:

        0000000000000000..0000000001111111: 0xxxxxxx
        0000000010000000..0000011111111111: 110xxxxx 10xxxxxx
        0000100000000000..1111111111111111: 1110xxxx 10xxxxxx 10xxxxxx

Arguments:

    pwszIn      - pointer to input wide-character string

    dwInBufLen     - number of CHARACTERS in pwszIn INCLUDING terminating NULL

    pszOut      - pointer to output narrow-character buffer

    pdwOutStrLen    - STRLEN of pszOut (excl. terminating NULL); IN value discarded.

    bEncode     - TRUE if we are to hex encode characters >= 0x80

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - NO ERROR checking done.  Make sure large enuf buffer passed 
in.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                Dword,
                "ConvertUnicodeToUtf8",
                "%.100wq, %#x, %#x, %#x, %B",
                pwszIn, dwInBufLen, pszOut, pdwOutStrLen, bEncode
                ));
                
    INET_ASSERT(pwszIn);
    INET_ASSERT((int)dwInBufLen > 0);
    INET_ASSERT(pszOut);

    LPSTR pszStart = pszOut;
    static char hexArray[] = "0123456789ABCDEF";

    while (dwInBufLen--) {

        WORD wchar = *pwszIn++;
        BYTE bchar;

        if (wchar <= 0x007F) {
            *pszOut++ = (BYTE)(wchar);
            continue;
        }

        BYTE lead = ((wchar >= 0x0800) ? 0xE0 : 0xC0);
        int shift = ((wchar >= 0x0800) ? 12 : 6);

        bchar = lead | (BYTE)(wchar >> shift);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;

        if (wchar >= 0x0800) {
            bchar = 0x80 | (BYTE)((wchar >> 6) & 0x003F);
            if (bEncode) {
                *pszOut++ = '%';
                *pszOut++ = hexArray[bchar >> 4];
                bchar = hexArray[bchar & 0x0F];
            }
            *pszOut++ = bchar;
        }
        bchar = 0x80 | (BYTE)(wchar & 0x003F);
        if (bEncode) {
            *pszOut++ = '%';
            *pszOut++ = hexArray[bchar >> 4];
            bchar = hexArray[bchar & 0x0F];
        }
        *pszOut++ = bchar;
    }

    *pdwOutStrLen = PtrDiff32(pszOut, pszStart)-1;
    DEBUG_LEAVE(ERROR_SUCCESS);
    return ERROR_SUCCESS;
}

LPSTR
ConvertMBCSToUTF8(
    IN LPCSTR lpszMBCSHostName,
    IN DWORD dwMBCSHostNameLength,
    IN DWORD dwCodePage,
    OUT DWORD * pdwUTF8HostNameStrLen,
    IN BOOL bLowerCase
    )
{
    DEBUG_ENTER((DBG_HTTP,
                String,
                "ConvertMBCSToUTF8",
                "%.100q, %#x, %#x, %#x, %B",
                lpszMBCSHostName, dwMBCSHostNameLength, dwCodePage, (pdwUTF8HostNameStrLen ? *pdwUTF8HostNameStrLen : NULL), bLowerCase
                ));

    DEBUG_DUMP(HTTP,
               "lpszMBCSHostName: strlen+1byte\n",
               lpszMBCSHostName,
               (dwMBCSHostNameLength+1)
               );
                           
    LPSTR lpszUTF8HostName = NULL;
    LPWSTR lpwszWideHostName = NULL;

    if (!lpszMBCSHostName || !dwMBCSHostNameLength)
        goto quit;
        
    DWORD dwWideLen = MultiByteToWideChar(dwCodePage, 0, lpszMBCSHostName, dwMBCSHostNameLength, NULL, 0); 
    //IMPORTANT! NULL terminator not included in dwWideLen

    if (dwWideLen)
    {
        lpwszWideHostName = new WCHAR[dwWideLen+1];

        if (lpwszWideHostName
            && (dwWideLen = MultiByteToWideChar(dwCodePage, 0, lpszMBCSHostName, dwMBCSHostNameLength, lpwszWideHostName, dwWideLen))
            && (lpszUTF8HostName = new CHAR[dwWideLen*3+1]))
        {
            // *pdwUTF8HostNameLength = dwWideLen*3+1;
            // Fill in the terminating NULL character since dwMBCSHostNameLength doesn't include NULL.
            lpwszWideHostName[dwWideLen] = L'\0';

            DEBUG_DUMP(HTTP,
                       "Before CharLowerW - lpwszWideHostName: strlen*2+2\n",
                       lpwszWideHostName,
                       (dwWideLen*2+2)
                       );

            if (bLowerCase)
            {
                CharLowerW(lpwszWideHostName);

                DEBUG_DUMP(HTTP,
                           "After CharLowerW - lpwszWideHostName: strlen*2+2\n",
                           lpwszWideHostName,
                           (dwWideLen*2+2)
                           );
            }
            
            DWORD error = ConvertUnicodeToUTF8(lpwszWideHostName, dwWideLen+1, lpszUTF8HostName, pdwUTF8HostNameStrLen, FALSE);

            DEBUG_DUMP(HTTP,
                       "ConvertUnicodeToUTF8 - lpszUTF8HostName: strlen+1\n",
                       lpszUTF8HostName,
                       (*pdwUTF8HostNameStrLen+1)
                       );
            
            // no other error possible
            INET_ASSERT(error == ERROR_SUCCESS);
        }
    }

quit:
    if (lpwszWideHostName)
    {
        delete [] lpwszWideHostName;
    }

    DEBUG_LEAVE(lpszUTF8HostName);
    return lpszUTF8HostName;
}


char *FindNamedValue(char *pszHeader, const char *pszFieldName, unsigned long *pdwValSize) {

    const char ChDblQuote = '\"';

    char *pszBegin, *pszValue;
    BOOL fFound;
    int  cbName;

    char *pch = pszHeader;

ExpectName:
    while (*pch && isspace(*pch))
        pch++;

ParseName:
    pszBegin = pch;

    while (*pch && isalnum(*pch))
        pch++;

    cbName = (int) (pch-pszBegin);
    fFound = (cbName>0) && !strncmp(pszBegin, pszFieldName, cbName);

ExpectEqSign:
    while (*pch && isspace(*pch))
        pch++;

    if (*pch=='=')
        pch++;

ExpectValue:
    while (*pch && isspace(*pch))
        pch++;

    if (*pch=='\"') {
        pch++;
        goto ParseQuotedValue;
    }

ParseValue:
    pszValue = pch;
    while (*pch && *pch!=',')
        pch++;

    goto ExpectComma;

ParseQuotedValue:
    pszValue = pch;
    while (*pch && *pch!=ChDblQuote)
        pch++;

ExpectComma:
    if (fFound) {
        int cbValue = (int) (pch-pszValue);
        *pdwValSize = cbValue;
        return pszValue;
    }

    while (*pch && *pch!=',')
        pch++;

    if (*pch==',') {
        pch++;
        goto ExpectName;
    }

    return NULL;
}


// Helper to determine if we're currently loaded during GUI mode setup
BOOL IsInGUIModeSetup()
{
    // could be called multiple times in wininet
    static DWORD s_dwSystemSetupInProgress = 42;

    if (42 == s_dwSystemSetupInProgress)
    {
        // Rule is that this value will exist and be equal to 1 if in GUI mode setup.
        // Default to NO, and only do this for upgrades because this is potentially
        // needed for unattended clean installs.
        s_dwSystemSetupInProgress = 0;

        HKEY hKeySetup = NULL;

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                          TEXT("System\\Setup"),
                                          0,
                                          KEY_READ,
                                          &hKeySetup))
        {
            DWORD dwSize = sizeof(s_dwSystemSetupInProgress);

            if (ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                  TEXT("SystemSetupInProgress"),
                                                  NULL,
                                                  NULL,
                                                  (LPBYTE) &s_dwSystemSetupInProgress,
                                                  &dwSize))
            {
                s_dwSystemSetupInProgress = 0;
            }
            else
            {
                dwSize = sizeof(s_dwSystemSetupInProgress);
                if (s_dwSystemSetupInProgress &&
                    ERROR_SUCCESS != RegQueryValueEx (hKeySetup,
                                                      TEXT("UpgradeInProgress"),
                                                      NULL,
                                                      NULL,
                                                      (LPBYTE) &s_dwSystemSetupInProgress,
                                                      &dwSize))
                {
                    s_dwSystemSetupInProgress = 0;
                }
            }

            RegCloseKey(hKeySetup);
        }
    }
    return s_dwSystemSetupInProgress ? TRUE : FALSE;
}


#ifdef DONT_USE_IERT
/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokEx (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

/***
* double StrToDbl(const char *str, char **strStop) - convert string to double
*
* Purpose:
*           To convert a string into a double.  This function supports
*           simple double representations like '1.234', '.5678'.  It also support
*           the a killobyte computaion by appending 'k' to the end of the string
*           as in '1.5k' or '.5k'.  The results would then become 1536 and 512.5.
*
* Return:
*           The double representation of the string.
*           strStop points to the character that caused the scan to stop.
*
*******************************************************************************/

double StrToDbl(const char *str, char **strStop)
{
    double dbl = 0;
    char *psz;
    int iMult = 1;
    int iKB = 1;
    int iVal = 0;
    BOOL bHaveDot = FALSE;

    psz = (char*)str;
    while(*psz)
    {
        if((*psz >= '0') && (*psz <= '9'))
        {
            iVal = (iVal * 10) + (*psz - '0');
            if(bHaveDot)
                iMult *= 10;
        }
        else if((*psz == '.') && !bHaveDot)
        {
            bHaveDot = TRUE;
        }
        else if((*psz == 'k') || (*psz == 'K'))
        {
            iKB = 1024;
            psz++;
            break;
        }
        else
        {
            break;
        }
        psz++;
    }
    *strStop = psz;

    dbl = (double) (iVal * iKB) / iMult;
    
    return(dbl);
}
#endif  // DONT_USE_IERT


// We need a DBCS-safe version of StrTokEx. 

char* StrTokEx2(char ** pstring, const char * control)
{
    /*unsigned*/ char *str;
    const /*unsigned*/ char *ctrl = control;
    unsigned char map[32];
    int count;

    char *tokenstr;

    if(*pstring == NULL)
        return NULL;

    /* Clear control map */
    for (count = 0; count < 32; count++)
            map[count] = 0;

    /* Set bits in delimiter table */
    do
    {
        map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        ctrl++;
    } while (*ctrl);

    /* Initialize str. */
    str = *pstring;

    /* Find beginning of token (skip over leading delimiters). Note that
     * there is no token if this loop sets str to point to the terminal
     * null (*str == '\0') */
    while ((*str>0) && ((CharNext(str)-str)==1) && (map[*str >> 3] & (1 << (*str & 7))))
        str = CharNext(str);

    tokenstr = str;

    /* Find the end of the token. If it is not the end of the string,
     * put a null there. */
    for ( ; *str ; str = CharNext(str))
    {
        if (((CharNext(str)-str)==1) && (*str>0) && (map[*str >> 3] & (1 << (*str & 7))))
        {
            *str++ = '\0';
            break;
        }
    }

    /* string now points to beginning of next token */
    *pstring = str;

    /* Determine if a token has been found. */
    if ( tokenstr == str )
        return NULL;
    else
        return tokenstr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\debugmem.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    debugmem.cxx

Abstract:

    Debug memory allocator

    Contents:
        InternetDebugMemInitialize
        InternetDebugMemTerminate
        InternetDebugAllocMem
        InternetDebugFreeMem
        InternetDebugReAllocMem
        InternetDebugSizeMem
        InternetDebugCheckMemFreed
        InternetDebugMemReport
        (InternetDebugCheckMemBlock)
        (DebugFillMem)
        (InternetAlloc)
        (InternetFree)
        (InternetReAlloc)
        (InternetSize)
        (InternetHeapAlloc)
        (InternetHeapReAlloc)
        (InternetHeapFree)
        (InternetHeapSize)
        (InternetDebugMemTest)
        (ReportMemoryUsage)
        (ReportMemoryBlocks)
        (DumpDeferredFreeList)
        (DumpMemoryList)
        (FindAndDumpDeferredBlock)
        (DumpBlock)
        (DumpDebugMemoryHeader)
        (DumpDebugMemoryFooter)
        (DumpUserData)
        (MapLastAccessOperation)
        (MapMemoryFlags)
        (DbgMemGetDebugSymbol)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if defined(USE_DEBUG_MEMORY)

//
// manifests
//

#define DEFAULT_INITIAL_HEAP_SIZE   (64 K)
#define DEFAULT_MAXIMUM_HEAP_SIZE   (1 M)
#define DEFAULT_HEADER_GUARD_SIZE   32
#define DEFAULT_FOOTER_GUARD_SIZE   32
#define DEFAULT_ALLOC_ALIGNMENT     4
#define HEADER_SIGNATURE            0x414d454d  // "MEMA"
#define FOOTER_SIGNATURE            0x434f4c4c  // "LLOC"
#define DWORD_ALLOC_FILL            0xc5c5c5c5
#define BYTE_ALLOC_FILL             0xc5
#define BYTE_ALLOC_FILL_EXTRA       0x88
#define GUARD_DWORD_FILL            0x44524147  // "GARD"
#define DWORD_FREE_FILL             0xb7b7b7b7
#define BYTE_FREE_FILL              0xb7
#define DEFAULT_MAX_BLOCKS_DUMPED   1024
#define DEFAULT_MAX_DATA_DUMPED     65536
#define DEFAULT_BACKTRACE_DEPTH     2

//
// only perform stack dump for x86 (or other stack-based processors)
//

#if defined(i386)
#define DUMP_STACK  1
#else
#define DUMP_STACK  0
#endif

//
// just using one stack these days
//

#define ONE_STACK   1

//
// private types
//

typedef enum {
    MemAllocate = 0x6f6c6c41,   // "Allo"
    MemReallocate = 0x6c416552, // "ReAl"
    MemLock = 0x6b636f4c,       // "Lock"
    MemUnlock = 0x6f6c6e55,     // "Unlo"
    MemFree = 0x65657246,       // "Free"
    MemSize = 0x657a6953        // "Size"
} MEMORY_ACTION;

typedef enum {
    HEAP_COMPACT_NEVER = 0,
    HEAP_COMPACT_ON_ALLOC_FAIL,
    HEAP_COMPACT_ON_FREE
} HEAP_COMPACT_TYPE;

typedef enum {
    HEAP_VALIDATE_NEVER = 0,
    HEAP_VALIDATE_ON_ALLOC,
    HEAP_VALIDATE_ON_FREE
} HEAP_VALIDATE_TYPE;

//
// DEBUG_MEMORY_HEADER - keeps debug memory on list
//

typedef struct {
    LIST_ENTRY List;
    DWORD ThreadId;
    LPSTR CreatedFile;
    DWORD CreatedLine;
    LPSTR AccessedFile;
    DWORD AccessedLine;
    SIZE_T RequestedLength;
    SIZE_T BlockLength;
    SIZE_T ActualLength;
    DWORD Signature;
    DWORD Flags;
    DWORD TimeDeferred;
    LONG ClashTest;
    MEMORY_ACTION LastAccessOperation;
#if DUMP_STACK
#if ONE_STACK
    LPVOID Stack[8];    // should be variable
#else
    LPVOID CreateStack[4];
    LPVOID LastAccessStack[4];
#endif // ONE_STACK
#endif // DUMP_STACK
    DWORD Guard[2];

    //
    // sizeof(MEMORY_SIGNATURE) currently 24 DWORDs in Win32
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

//
// DEBUG_MEMORY_FOOTER - used to check for overwrites
//

typedef struct {
    DWORD Guard[4];
    DWORD Signature;
    SIZE_T BlockLength;  // should be the same as the header
    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs in Win32
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// private data
//

PRIVATE BOOL MemoryPackageInitialized = FALSE;

//
// InternetDebugMemFlags - bitfield of flags controlling debug memory usage.
// The default is no debug alloc (don't create header + footers) and to use
// LocalAlloc() etc.
//

//
// BUGBUG - I'm making an assumption that the compiler thinks the bits have the
//          same values as I think they have. If not, it could mess up the
//          registry/environment flags
//

PRIVATE struct {                                            // default value
    DWORD bNoDebugAlloc             : 1;    //  0x00000001          TRUE
    DWORD bUseLocalAlloc            : 1;    //  0x00000002          TRUE
    DWORD bUseSymbols               : 1;    //  0x00000004          FALSE
    DWORD bAssertOnMemoryErrors     : 1;    //  0x00000008          FALSE
    DWORD bFillMemoryOnAlloc        : 1;    //  0x00000010          FALSE
    DWORD bFillMemoryOnFree         : 1;    //  0x00000020          FALSE
    DWORD bReportMemoryUsage        : 1;    //  0x00000040          FALSE
    DWORD bReportUnfreedBlocks      : 1;    //  0x00000080          FALSE
    DWORD bReportMemoryFooters      : 1;    //  0x00000100          FALSE
    DWORD bReportUserData           : 1;    //  0x00000200          FALSE
    DWORD bStopDumpIfBadBlock       : 1;    //  0x00000400          FALSE
    DWORD bLimitUnfreedBlocks       : 1;    //  0x00000800          FALSE
    DWORD bLimitUserData            : 1;    //  0x00001000          FALSE
    DWORD bDumpAsDwords             : 1;    //  0x00002000          FALSE
    DWORD bHeapNoSerialize          : 1;    //  0x00004000          FALSE
    DWORD bHeapGenerateExceptions   : 1;    //  0x00008000          FALSE
    DWORD bHeapIsGrowable           : 1;    //  0x00010000          FALSE
    DWORD bDeferFree                : 1;    //  0x00020000          FALSE
    DWORD bDumpToFile               : 1;    //  0x00040000          FALSE
} InternetDebugMemFlags = {
    TRUE,   // no debug alloc
    TRUE,   // use LocalAlloc()
    FALSE,  // don't load debug symbols
    FALSE,  // don't assert on memory errors
    FALSE,  // don't fill memory on alloc
    FALSE,  // don't fill memory on free
    FALSE,  // don't report memory usage (stats)
    FALSE,  // don't report unfreed blocks
    FALSE,  // don't report memory footers (irrelevant)
    FALSE,  // don't report user data (irrelevant)
    FALSE,  // don't stop dump if bad block (irrelevant)
    FALSE,  // don't limit dump of unfreed blocks (irrelevant)
    FALSE,  // don't limit dump of user data (irrelevant)
    FALSE,  // don't dump user data as DWORDs (irrelevant)
    FALSE,  // serialize access to heap (irrelevant)
    FALSE,  // don't generate heap exceptions (irrelevant)
    TRUE,   // heap is growable (irrelevant)
    FALSE,  // don't defer frees
    FALSE   // don't dump to wininet log file
};

//
// defines to make using InternetDebugMemFlags easier
//

#define bNoDebugAlloc           InternetDebugMemFlags.bNoDebugAlloc
#define bUseLocalAlloc          InternetDebugMemFlags.bUseLocalAlloc
#define bUseSymbols             InternetDebugMemFlags.bUseSymbols
#define bAssertOnMemoryErrors   InternetDebugMemFlags.bAssertOnMemoryErrors
#define bFillMemoryOnAlloc      InternetDebugMemFlags.bFillMemoryOnAlloc
#define bFillMemoryOnFree       InternetDebugMemFlags.bFillMemoryOnFree
#define bReportMemoryUsage      InternetDebugMemFlags.bReportMemoryUsage
#define bReportUnfreedBlocks    InternetDebugMemFlags.bReportUnfreedBlocks
#define bReportMemoryFooters    InternetDebugMemFlags.bReportMemoryFooters
#define bReportUserData         InternetDebugMemFlags.bReportUserData
#define bStopDumpIfBadBlock     InternetDebugMemFlags.bStopDumpIfBadBlock
#define bLimitUnfreedBlocks     InternetDebugMemFlags.bLimitUnfreedBlocks
#define bLimitUserData          InternetDebugMemFlags.bLimitUserData
#define bDumpAsDwords           InternetDebugMemFlags.bDumpAsDwords
#define bHeapNoSerialize        InternetDebugMemFlags.bHeapNoSerialize
#define bHeapGenerateExceptions InternetDebugMemFlags.bHeapGenerateExceptions
#define bHeapIsGrowable         InternetDebugMemFlags.bHeapIsGrowable
#define bDeferFree              InternetDebugMemFlags.bDeferFree
#define bDumpToFile             InternetDebugMemFlags.bDumpToFile

PRIVATE DWORD MaxBlocksDumped = DEFAULT_MAX_BLOCKS_DUMPED;
PRIVATE DWORD MaxUserDataDumped = DEFAULT_MAX_DATA_DUMPED;
PRIVATE DWORD StackBacktraceDepth = DEFAULT_BACKTRACE_DEPTH;

//
// heap variables
//

PRIVATE HANDLE hDebugHeap = NULL;
PRIVATE DWORD InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
PRIVATE DWORD MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
PRIVATE HEAP_COMPACT_TYPE HeapCompactControl = HEAP_COMPACT_NEVER;
PRIVATE HEAP_VALIDATE_TYPE HeapValidateControl = HEAP_VALIDATE_NEVER;

//
// debug mem signatures etc.
//

PRIVATE DWORD AllocAlignment = DEFAULT_ALLOC_ALIGNMENT;
PRIVATE DWORD HeaderGuardSize = DEFAULT_HEADER_GUARD_SIZE;
PRIVATE DWORD FooterGuardSize = DEFAULT_FOOTER_GUARD_SIZE;
PRIVATE DWORD AllocMemoryFiller = DWORD_ALLOC_FILL;
PRIVATE DWORD FreeMemoryFiller = DWORD_FREE_FILL;

//
// usage variables - access using some sort of lock (critsec/interlocked)
//

PRIVATE CRITICAL_SECTION MemoryVarsCritSec;
PRIVATE SIZE_T TotalActualMemoryAllocated = 0;  // cumulative
PRIVATE SIZE_T TotalBlockMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalRealMemoryAllocated = 0;    //     "
PRIVATE SIZE_T TotalActualMemoryFreed = 0;      //     "
PRIVATE SIZE_T TotalBlockMemoryFreed = 0;        //     "
PRIVATE SIZE_T TotalRealMemoryFreed = 0;         //     "
PRIVATE SIZE_T ActualMemoryAllocated = 0;        // difference
PRIVATE SIZE_T BlockLengthAllocated = 0;         //     "
PRIVATE SIZE_T RealLengthAllocated = 0;          //     "
PRIVATE DWORD MemoryAllocations = 0;            // cumulative
PRIVATE DWORD GoodMemoryAllocations = 0;        //     "
PRIVATE DWORD MemoryReAllocations = 0;          //     "
PRIVATE DWORD GoodMemoryReAllocations = 0;      //     "
PRIVATE DWORD MemoryFrees = 0;                  //     "
PRIVATE DWORD GoodMemoryFrees = 0;              //     "
PRIVATE SIZE_T LargestBlockRequested = 0;
PRIVATE SIZE_T LargestBlockAllocated = 0;
PRIVATE LPSTR LargestBlockRequestedFile = NULL;
PRIVATE DWORD LargestBlockRequestedLine = 0;
PRIVATE SIZE_T SmallestBlockRequested = (SIZE_T)-1;
PRIVATE SIZE_T SmallestBlockAllocated = (SIZE_T)-1;
PRIVATE LPSTR SmallestBlockRequestedFile = NULL;
PRIVATE DWORD SmallestBlockRequestedLine = 0;
PRIVATE DWORD DeferFreeTime = 0;

//
// lists
//

PRIVATE SERIALIZED_LIST AllocatedBlockList;
PRIVATE SERIALIZED_LIST DeferredFreeList;

//
// macros
//

#define MEMORY_ASSERT(x) \
    if (bAssertOnMemoryErrors) { \
        INET_ASSERT(x); \
    } else { \
        /* NOTHING */ \
    }

//
// private prototypes
//

PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    );

PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    );

PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    );

PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    );

PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    );

PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
VOID
InternetDebugMemTest(
    VOID
    );

PRIVATE
VOID
ReportMemoryUsage(
    VOID
    );

PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    );

PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    );

PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    );

PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    );

PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    );

PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    );

PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    );

PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    );

PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    );

//
// functions
//


VOID
InternetDebugMemInitialize(
    VOID
    )

/*++

Routine Description:

    Initializes debug memory allocator

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOL init;

    init = (BOOL)InterlockedExchange((LPLONG)&MemoryPackageInitialized, TRUE);
    if (init) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

        return;
    }

    InitializeSerializedList(&AllocatedBlockList);
    InitializeSerializedList(&DeferredFreeList);
    InitializeCriticalSection(&MemoryVarsCritSec);

    //
    // sleaze: disable any debug output until we finish this. Debug log
    // routines want to allocate memory(!). InternetReadRegistryDword()
    // (called from InternetGetDebugVariable()) wants to perform DEBUG_ENTER
    // etc.
    //

    DWORD debugControlFlags = InternetDebugControlFlags;

    InternetDebugControlFlags = DBG_NO_DEBUG;

    //
    // if "WininetMem" is set then we set up to use debug memory - we use our
    // own heap, full debugging & reporting etc. (basically max memory debugging
    // as defined by me)
    //

    DWORD useDefaultDebugMemoryFlags = FALSE;

    InternetGetDebugVariable("WininetMem",
                             &useDefaultDebugMemoryFlags
                             );
    if (useDefaultDebugMemoryFlags) {
        bNoDebugAlloc = FALSE;          // use full debug allocator (header + footers, etc.)
        bUseLocalAlloc = FALSE;         // use our own heap
        bUseSymbols = FALSE;            // don't load debug symbols
        bAssertOnMemoryErrors = TRUE;   // assert to debugger/log if memory errors
        bFillMemoryOnAlloc = TRUE;      // fill user data w/ signature if not zeroinit
        bFillMemoryOnFree = TRUE;       // fill freed memory (useful on Win95/non-debug on NT)
        bReportMemoryUsage = TRUE;      // dump memory usage stats
        bReportUnfreedBlocks = TRUE;    // dump unfreed blocks (headers)
        bReportMemoryFooters = TRUE;    // dump unfreed block footers
        bReportUserData = TRUE;         // dump unfreed block user data
        bStopDumpIfBadBlock = TRUE;     // stop dumping if error occurs
        bLimitUnfreedBlocks = TRUE;     // limit block dump in case of loop in list
        bLimitUserData = TRUE;          // limit user data dump in case of bad length
        bDumpAsDwords = TRUE;           // dump data in dc format vs. db
        bHeapNoSerialize = FALSE;       // heap functions are serialized
        bHeapGenerateExceptions = FALSE;// heap functions return errors
        bHeapIsGrowable = FALSE;        // limit heap to maximum size (1 Meg)
        if (useDefaultDebugMemoryFlags == 2) {
            bDumpToFile = TRUE;
        }
    } else {

        //
        // no use-debug-mem override, see if there are any specific flags set
        //

        InternetGetDebugVariable("WininetDebugMemFlags",
                                 (LPDWORD)&InternetDebugMemFlags
                                 );
    }

    //
    // we used to load IMAGEHLP.DLL here and not use its functions until we were
    // dumping still in-use memory during DLL shutdown. Problem is that the
    // system has probably already freed IMAGEHLP.DLL by the time we come to use
    // it, resulting in GPF, so now we only load it at the time we're about to
    // use it
    //

    //if (bUseSymbols) {
    //    InitSymLib();
    //}

    if (!bUseLocalAlloc) {

        //
        // not using LocalAlloc(), using HeapAlloc(). Create heap
        //

        InitialHeapSize = DEFAULT_INITIAL_HEAP_SIZE;
        InternetGetDebugVariable("WininetDebugHeapInitialSize",
                                 &InitialHeapSize
                                 );

        MaximumHeapSize = DEFAULT_MAXIMUM_HEAP_SIZE;
        InternetGetDebugVariable("WininetDebugHeapMaximumSize",
                                 &MaximumHeapSize
                                 );

        if (bHeapIsGrowable) {
            MaximumHeapSize = 0;
        }

        hDebugHeap = HeapCreate((bHeapGenerateExceptions
                                    ? HEAP_GENERATE_EXCEPTIONS
                                    : 0)
                                | (bHeapNoSerialize
                                    ? HEAP_NO_SERIALIZE
                                    : 0),
                                InitialHeapSize,
                                MaximumHeapSize
                                );
        if (hDebugHeap == NULL) {

            DEBUG_PUT(("HeapCreate() failed - %d\n",
                        GetLastError()
                        ));

            bUseLocalAlloc = TRUE;
        } else {
            HeapCompactControl = HEAP_COMPACT_NEVER;
            InternetGetDebugVariable("WininetDebugHeapCompactControl",
                                     (LPDWORD)&HeapCompactControl
                                     );

            HeapValidateControl = HEAP_VALIDATE_NEVER;
            InternetGetDebugVariable("WininetDebugHeapValidateControl",
                                     (LPDWORD)&HeapValidateControl
                                     );

            DEBUG_PUT(("Wininet heap = %#x\n",
                        hDebugHeap
                        ));

        }
    }

    //
    // restore default debug flags
    //

    InternetDebugControlFlags = debugControlFlags;

    //InternetDebugMemTest();
}


VOID
InternetDebugMemTerminate(
    IN BOOL bReport
    )

/*++

Routine Description:

    Frees resources allocated in InternetDebugMemInitialize, after checking that
    all memory is freed

Arguments:

    bReport - TRUE if in-use blocks reported at termination

Return Value:

    None.

--*/

{
    BOOL bOpened = bReport ? InternetDebugMemReport(TRUE, FALSE) : FALSE;

    InternetDebugCheckMemFreed(FALSE);
    DeleteCriticalSection(&MemoryVarsCritSec);
    TerminateSerializedList(&AllocatedBlockList);
    TerminateSerializedList(&DeferredFreeList);

    if (hDebugHeap != NULL) {

        //
        // any future allocations(!) must use process heap
        //

        bUseLocalAlloc = TRUE;

        if (!HeapDestroy(hDebugHeap)) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapDestroy(%#x) returns %s (%d)\n",
                        hDebugHeap,
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    }
    if (bOpened) {
        InternetCloseDebugFile();
    }
    MemoryPackageInitialized = FALSE;
}


HLOCAL
InternetDebugAllocMem(
    IN UINT Flags,
    IN UINT Size,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Debug memory allocator. If this succeeds, then the real block is put on our
    list and has its head & tail (& possibly contents) initialized. The caller
    gets an pointer which is an offset to the user area in the block

Arguments:

    Flags   - controlling flags (normally passed to LocalAlloc)

    Size    - of block to allocate

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to caller's start of allocated block

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugAllocMem(%#x, %d) = ", Flags, Size);
    InterlockedIncrement((LPLONG)&MemoryAllocations);

    //
    // keep these tests separate so we don't have to look up the flags #defines
    //

    INET_ASSERT(!(Flags & LMEM_MOVEABLE));
    INET_ASSERT(!(Flags & LMEM_DISCARDABLE));

    if (Size == 0) {

        DEBUG_PRINT(MEMALLOC,
                    WARNING,
                    ("InternetDebugAllocMem(%#x, %d)\n",
                    Flags,
                    Size
                    ));

        MEMORY_ASSERT(FALSE);

    }

    SIZE_T blockLength;

    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }

    //
    // possible problem: if Size + signatures would overflow UINT. Only really
    // problematic on 16-bit platforms
    //

    if (blockLength < Size) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)Size
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    //
    // BUGBUG - allocating 0 bytes?
    //

    HLOCAL hLocal = InternetAlloc(Flags, blockLength);

    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryAllocations);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

//dprintf("NULL\n");
        return NULL;
    }

    SIZE_T actualLength = InternetSize(hLocal);
    SIZE_T requestedLength;

    if (bNoDebugAlloc) {
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        requestedLength = Size;
        if (actualLength > LargestBlockAllocated) {
            LargestBlockAllocated = actualLength;
        } else if (actualLength < SmallestBlockAllocated) {
            SmallestBlockAllocated = actualLength;
        }
    }

    EnterCriticalSection(&MemoryVarsCritSec);
    TotalActualMemoryAllocated += actualLength;
    TotalBlockMemoryAllocated += blockLength;
    TotalRealMemoryAllocated += requestedLength;
    ActualMemoryAllocated += actualLength;
    BlockLengthAllocated += blockLength;
    RealLengthAllocated += requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);

    if (bNoDebugAlloc || (hLocal == NULL)) {
        if ((hLocal != NULL) && !(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
            DebugFillMem(hLocal, Size, AllocMemoryFiller);
        }
//dprintf("%#x\n", hLocal);
        return hLocal;
    }

    LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

    //InitializeListHead(&lpHeader->List);
    lpHeader->ThreadId = GetCurrentThreadId();
    lpHeader->CreatedFile = File;
    lpHeader->CreatedLine = Line;
    lpHeader->AccessedFile = File;
    lpHeader->AccessedLine = Line;
    lpHeader->RequestedLength = Size;
    lpHeader->BlockLength = blockLength;
    lpHeader->ActualLength = actualLength;
    lpHeader->Signature = HEADER_SIGNATURE;
    lpHeader->Flags = Flags;
    lpHeader->TimeDeferred = 0;
    lpHeader->ClashTest = -1;
    lpHeader->LastAccessOperation = MemAllocate;

#if DUMP_STACK
#if ONE_STACK

    memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
    GET_CALL_STACK(lpHeader->Stack);

#else

    GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                        &lpHeader->CreateStack[1]
                        );

    memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

    GET_CALL_STACK(lpHeader->CreateStack);

    memcpy(lpHeader->LastAccessStack,
           lpHeader->CreateStack,
           sizeof(lpHeader->LastAccessStack)
           );

#endif // ONE_STACK
#endif // DUMP_STACK

    UINT i;

    for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
        lpHeader->Guard[i] = GUARD_DWORD_FILL;
    }

    //
    // BUGBUG - should be using AllocAlignment - could be > sizeof(DWORD)
    //

    if (!(Flags & LMEM_ZEROINIT) && bFillMemoryOnAlloc) {
        DebugFillMem(lpHeader + 1, Size, AllocMemoryFiller);
    }

    UINT bFillLength2 = (Size % sizeof(DWORD)) ? (sizeof(DWORD) - (Size % sizeof(DWORD))) : 0;
    LPBYTE lpbUserPointer = (LPBYTE)(lpHeader + 1) + Size;

    for (i = 0; i < bFillLength2; ++i) {
        *lpbUserPointer++ = BYTE_ALLOC_FILL_EXTRA;
    }

    LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)lpbUserPointer;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
        lpFooter->Guard[i] = GUARD_DWORD_FILL;
    }

    lpFooter->BlockLength = blockLength;
    lpFooter->Signature = FOOTER_SIGNATURE;

    for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
        lpFooter->Guard2[i] = GUARD_DWORD_FILL;
    }

    if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, FALSE)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugAllocMem(%d): %#x already on list?\n",
                    Size,
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

    }

    //
    // put at the tail of list so we can view unfreed blocks in chronological
    // order
    //

    InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List);

//dprintf("%#x\n", lpHeader + 1);
    return (HLOCAL)(lpHeader + 1);
}


HLOCAL
InternetDebugFreeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Frees a block of memory allocated by InternetDebugAllocMem(). Checks that
    the block is on our allocated block list, and that the header and footer
    areas are still intact

Arguments:

    hLocal  - handle (pointer) of block to free

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugFreeMem(%#x)\n", hLocal);
    InterlockedIncrement((LPLONG)&MemoryFrees);

    if (hLocal == NULL) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(NULL)\n"
                    ));

        MEMORY_ASSERT(FALSE);

        return InternetFree(hLocal);
    }

    HLOCAL hLocalOriginal = hLocal;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T realLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        realLength = actualLength;
    } else {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
        actualLength = InternetSize(hLocal);

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;

        if (CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE)) {
            RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List);

            if (!((lpHeader->ActualLength == actualLength)
            && (lpHeader->BlockLength <= actualLength)
            && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
            && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("InternetDebugFreeMem(%#x): block lengths mismatch\n",
                            hLocalOriginal
                            ));

                MEMORY_ASSERT(FALSE);
            }
            if (InternetDebugCheckMemBlock(lpHeader)) {
                blockLength = lpHeader->BlockLength;
                realLength = lpHeader->RequestedLength;
            } else {
                blockLength = 0;
                realLength = 0;
            }
            if (bDeferFree) {

#if DUMP_STACK
#if ONE_STACK

                memset(lpHeader->Stack, 0, sizeof(lpHeader->Stack));
                GET_CALL_STACK(lpHeader->Stack);

#else

                GET_CALLERS_ADDRESS(&lpHeader->CreateStack[0],
                                    &lpHeader->CreateStack[1]
                                    );

                memset(lpHeader->CreateStack, 0, sizeof(lpHeader->CreateStack));

                GET_CALL_STACK(lpHeader->CreateStack);

                memcpy(lpHeader->LastAccessStack,
                       lpHeader->CreateStack,
                       sizeof(lpHeader->LastAccessStack)
                       );

#endif // ONE_STACK
#endif // DUMP_STACK

                InsertAtTailOfSerializedList(&DeferredFreeList, &lpHeader->List);
                hLocal = NULL;
            }
        } else {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugFreeMem(%#x): can't find %#x\n",
                        hLocalOriginal,
                        &lpHeader->List
                        ));

            MEMORY_ASSERT(FALSE);

            FindAndDumpDeferredBlock(hLocal);
        }
    }

    if (hLocal && bFillMemoryOnFree) {
        DebugFillMem(hLocal, actualLength, FreeMemoryFiller);
    }

    hLocal = InternetFree(hLocal);

    if (hLocal == NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryFrees);
        EnterCriticalSection(&MemoryVarsCritSec);
        TotalActualMemoryFreed += actualLength;
        TotalBlockMemoryFreed += blockLength;
        TotalRealMemoryFreed += realLength;
        ActualMemoryAllocated -= actualLength;
        BlockLengthAllocated -= blockLength;
        RealLengthAllocated -= realLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugFreeMem(%#x) failed\n",
                    hLocalOriginal
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = hLocalOriginal;
    }

    return hLocal;
}


HLOCAL
InternetDebugReAllocMem(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Reallocates a debug memory block allocated by InternetDebugAllocMem()

Arguments:

    hLocal  - the handle (pointer) of the allocated block

    Size    - requested size of new block; can be larger or smaller than current
              size

    Flags   - controlling flags (normally passed to LocalReAlloc)

    File    - from where alloc called

    Line    - in File

Return Value:

    HLOCAL
        Success - pointer to new block. May be same or different than previous
                  pointer, depending on flags

        Failure - NULL

--*/

{
    if (!MemoryPackageInitialized) {
        return NULL;
    }

//dprintf("InternetDebugReAllocMem(%#x, %d, %#x)\n", hLocal, Size, Flags);
    InterlockedIncrement((LPLONG)&MemoryReAllocations);

    //
    // we can't handle the following flags
    //

    INET_ASSERT(!(Flags & LMEM_MODIFY));

    //
    // can't handle reallocating down to zero
    //

    if (Size == 0) {

        MEMORY_ASSERT(FALSE);

    }

    HLOCAL hLocalOriginal = hLocal;
    LPDEBUG_MEMORY_HEADER lpHeader;
    SIZE_T actualLength;
    SIZE_T blockLength;
    SIZE_T requestedLength;
    SIZE_T oldRequestedLength;

    if (bNoDebugAlloc) {
        actualLength = InternetSize(hLocal);
        blockLength = actualLength;
        requestedLength = actualLength;
    } else {
        if (Size > LargestBlockRequested) {
            LargestBlockRequested = Size;
            LargestBlockRequestedFile = File;
            LargestBlockRequestedLine = Line;
        } else if (Size < SmallestBlockRequested) {
            SmallestBlockRequested = Size;
            SmallestBlockRequestedFile = File;
            SmallestBlockRequestedLine = Line;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        hLocal = (HLOCAL)lpHeader;
        if (!CheckEntryOnSerializedList(&AllocatedBlockList, &lpHeader->List, TRUE)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): can't find %#x\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);

            return hLocalOriginal;
        }
        RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List);
        InternetDebugCheckMemBlock(lpHeader);
        actualLength = InternetSize((HLOCAL)lpHeader);
        blockLength = lpHeader->BlockLength;
        requestedLength = lpHeader->RequestedLength;
        oldRequestedLength = requestedLength;
        if (!((lpHeader->ActualLength == actualLength)
        && (lpHeader->BlockLength <= actualLength)
        && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
        && (lpHeader->RequestedLength < lpHeader->BlockLength))) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("InternetDebugReAllocMem(%#x): block lengths mismatch\n",
                        hLocalOriginal
                        ));

            MEMORY_ASSERT(FALSE);
        }
    }
    EnterCriticalSection(&MemoryVarsCritSec);
    ActualMemoryAllocated -= actualLength;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= requestedLength;
    LeaveCriticalSection(&MemoryVarsCritSec);
    requestedLength = Size;
    if (bNoDebugAlloc) {
        blockLength = Size;
    } else {
        blockLength = ROUND_UP_DWORD(Size)
                    + sizeof(DEBUG_MEMORY_HEADER)
                    + sizeof(DEBUG_MEMORY_FOOTER);
    }
    hLocal = InternetReAlloc(hLocal, blockLength, Flags);
    if (hLocal != NULL) {
        InterlockedIncrement((LPLONG)&GoodMemoryReAllocations);
        actualLength = InternetSize(hLocal);
        if (bNoDebugAlloc) {
            blockLength = actualLength;
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
            //InitializeListHead(&lpHeader->List);
            lpHeader->ThreadId = GetCurrentThreadId();
            lpHeader->AccessedFile = File;
            lpHeader->AccessedLine = Line;
            lpHeader->RequestedLength = requestedLength;
            lpHeader->BlockLength = blockLength;
            lpHeader->ActualLength = actualLength;
            lpHeader->Flags = Flags;
            lpHeader->TimeDeferred = 0;
            lpHeader->ClashTest = -1;
            lpHeader->LastAccessOperation = MemReallocate;

#if DUMP_STACK
#if ONE_STACK
#else

            //GET_CALLERS_ADDRESS(&lpHeader->LastAccessStack[0],
            //                    &lpHeader->LastAccessStack[1]
            //                    );

            memset(lpHeader->LastAccessStack, 0, sizeof(lpHeader->LastAccessStack));

            GET_CALL_STACK(lpHeader->LastAccessStack);

#endif // ONE_STACK
#endif // DUMP_STACK

            LPBYTE extraPointer;
            UINT dwFillLength;
            UINT i;

            if ((requestedLength > oldRequestedLength)
            && bFillMemoryOnAlloc && !(Flags & LMEM_ZEROINIT)) {

                extraPointer = (LPBYTE)(lpHeader + 1) + oldRequestedLength;

                SIZE_T difference = requestedLength - oldRequestedLength;
                DWORD dwFiller = AllocMemoryFiller;
                SIZE_T syncLength = oldRequestedLength & (sizeof(DWORD) - 1);

                if (syncLength) {
                    syncLength = sizeof(DWORD) - syncLength;
                    syncLength = min(syncLength, difference);
                    difference -= syncLength;
                    for (i = 0; i < syncLength; ++i) {
                        *extraPointer++ = ((LPBYTE)&dwFiller)[i];
                    }
                }

                //dwFillLength = difference / sizeof(DWORD);
                //difference %= sizeof(DWORD);
                //while (dwFillLength--) {
                //    *(LPDWORD)extraPointer = 0;
                //    extraPointer += sizeof(DWORD);
                //}
                //while (difference--) {
                //    *extraPointer++ = 0;
                //}

                if (difference) {
                    DebugFillMem(extraPointer, difference, dwFiller);
                    extraPointer += difference;
                }
            } else {
                extraPointer = (LPBYTE)(lpHeader + 1) + requestedLength;
            }

            SIZE_T bFillLength = (sizeof(DWORD) - (requestedLength % sizeof(DWORD))) & (sizeof(DWORD) - 1);

            while (bFillLength--) {
                *extraPointer++ = BYTE_ALLOC_FILL_EXTRA;
            }

            LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)extraPointer;

            INET_ASSERT(lpFooter == (LPDEBUG_MEMORY_FOOTER)
                ((LPBYTE)(lpHeader + 1) + ROUND_UP_DWORD(requestedLength)));

            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
                lpFooter->Guard[i] = GUARD_DWORD_FILL;
            }
            lpFooter->Signature = FOOTER_SIGNATURE;
            lpFooter->BlockLength = blockLength;
            for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
                lpFooter->Guard2[i] = GUARD_DWORD_FILL;
            }
            InsertAtTailOfSerializedList(&AllocatedBlockList, &lpHeader->List);
            hLocal = (HLOCAL)(lpHeader + 1);
        }
        EnterCriticalSection(&MemoryVarsCritSec);
        ActualMemoryAllocated += actualLength;
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += requestedLength;
        LeaveCriticalSection(&MemoryVarsCritSec);
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


SIZE_T
InternetDebugSizeMem(
    IN HLOCAL hLocal,
    IN LPSTR File,
    IN DWORD Line
    )

/*++

Routine Description:

    Returns actual allocated block size

Arguments:

    hLocal  - pointer to allocated block

    File    - from where alloc called

    Line    - in File

Return Value:

    SIZE_T
        size of allocated block

--*/

{
    if (!MemoryPackageInitialized) {
        return 0;
    }

//dprintf("InternetDebugSizeMem(%#x)\n", hLocal);
    SIZE_T size = InternetSize(hLocal);

    if (!bNoDebugAlloc) {

        LPDEBUG_MEMORY_HEADER lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        SIZE_T sizeInHeader = lpHeader->BlockLength
                          - (sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER));

        INET_ASSERT((sizeInHeader <= size)
                    && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                    && (lpHeader->ActualLength == size)
                    );

        size = sizeInHeader;
    }

    return size;
}


BOOL
InternetDebugCheckMemFreed(
    IN BOOL bReport
    )

/*++

Routine Description:

    Called when we're about to quit. Checks that all allocated memory has been
    cleaned up

Arguments:

    bReport - TRUE if in-use blocks reported

Return Value:

    BOOL
        TRUE    - all allocated memory freed

        FALSE   - we failed to clean up

--*/

{
    if (bReport) {
        if (bReportMemoryUsage) {
            ReportMemoryUsage();
        }
        if (bReportUnfreedBlocks) {
            ReportMemoryBlocks();
        }
    }
    if (ElementsOnSerializedList(&AllocatedBlockList) != 0) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetDebugCheckMemFreed(): %d memory blocks still allocated\n",
                    MemoryAllocations - MemoryFrees
                    ));

        MEMORY_ASSERT(FALSE);

        return FALSE;
    }
    return TRUE;
}


BOOL
InternetDebugMemReport(
    IN BOOL bTerminateSymbols,
    IN BOOL bCloseFile
    )

/*++

Routine Description:

    Dumps in-use blocks to debugger and/or file

Arguments:

    bTerminateSymbols   - TRUE if we are to terminate symbols here

    bCloseFile          - TRUE if we are to close debug log file here

Return Value:

    BOOL    - TRUE if we opened debug log file

--*/

{
    BOOL bOpened = FALSE;

    if (bDumpToFile) {
        bOpened = InternetOpenDebugFile();
        if (bOpened) {
            InternetDebugResetControlFlags(DBG_NO_DEBUG);
            InternetDebugSetControlFlags(DBG_TO_FILE | DBG_NO_ASSERT_BREAK);
        }
    }
    ReportMemoryUsage();
    ReportMemoryBlocks();
    if (bUseSymbols && bTerminateSymbols) {
        TermSymLib();
    }
    if (bOpened && bCloseFile) {
        InternetCloseDebugFile();
    }
    return bOpened;
}

//
// private functions
//


PRIVATE
VOID
DebugFillMem(
    IN LPVOID Pointer,
    IN SIZE_T Size,
    IN DWORD dwFiller
    )

/*++

Routine Description:

    Fills memory with repeating debug pattern. Performs DWORD fill then finishes
    off any remaining bytes with character fill (rep movsd/rep movsb (ideally)
    (x86!))

Arguments:

    Pointer     - memory to fill

    Size        - of Pointer in bytes

    dwFiller    - DWORD value to use

Return Value:

    None.

--*/

{
    INET_ASSERT(((DWORD_PTR)Pointer & (sizeof(DWORD) - 1)) == 0);

    SIZE_T dwFillLength = Size / sizeof(DWORD);
    SIZE_T bFillLength = Size % sizeof(DWORD);

    //
    // assume > 0 DWORDs to fill
    //

    LPDWORD lpdwPointer = (LPDWORD)Pointer;
    SIZE_T i;

    for (i = 0; i < dwFillLength; ++i) {
        *lpdwPointer++ = dwFiller;
    }

    if (bFillLength) {

        LPBYTE lpbPointer = (LPBYTE)lpdwPointer;

        for (i = 0; i < bFillLength; ++i) {
            *lpbPointer++ = ((LPBYTE)&dwFiller)[i];
        }
    }
}


PRIVATE
HLOCAL
InternetAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalAlloc(Flags, Size);
    } else {
        return InternetHeapAlloc(Flags, Size);
    }
}


PRIVATE
HLOCAL
InternetFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Deallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to deallocate

Return Value:

    HLOCAL
        Success - NULL

        Failure - pointer to still allocated block

--*/

{
    if (bUseLocalAlloc) {
        return LocalFree(hLocal);
    } else {
        return InternetHeapFree(hLocal);
    }
}


PRIVATE
HLOCAL
InternetReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocator - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to reallocate

    Flags   - LocalAlloc flags

    Size    - of block to allocate

Return Value:

    HLOCAL
        Success - pointer to allocated block

        Failure - NULL

--*/

{
    if (bUseLocalAlloc) {
        return LocalReAlloc(hLocal, Size, Flags);
    } else {
        return InternetHeapReAlloc(hLocal, Size, Flags);
    }
}


PRIVATE
SIZE_T
InternetSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Block sizer - uses process (local) heap or component (debug) heap based on
    global flag setting

Arguments:

    hLocal  - pointer to block to size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    if (bUseLocalAlloc) {
        return LocalSize(hLocal);
    } else {
        return InternetHeapSize(hLocal);
    }
}


PRIVATE
HLOCAL
InternetHeapAlloc(
    IN UINT Flags,
    IN SIZE_T Size
    )

/*++

Routine Description:

    Allocate memory from debug heap

Arguments:

    Flags   - passed to LocalAlloc

    Size    - of block to allocate

Return Value:

    HLOCAL

--*/

{
    HLOCAL hLocal;

    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapAlloc(hDebugHeap,
                                   (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                   | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                   | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                   Size
                                   );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        hLocal = LocalAlloc(Flags, Size);
    }
    if (hLocal == NULL) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapReAlloc(
    IN HLOCAL hLocal,
    IN SIZE_T Size,
    IN UINT Flags
    )

/*++

Routine Description:

    Reallocate memory from debug heap

Arguments:

    hLocal  - pointer to block to reallocate

    Size    - new size

    Flags   - to LocalReAlloc

Return Value:

    HLOCAL
        Success - pointer to new block

        Failure - NULL

--*/

{
    if (hDebugHeap != NULL) {
        hLocal = (HLOCAL)HeapReAlloc(hDebugHeap,
                                     (bHeapNoSerialize
                                        ? HEAP_NO_SERIALIZE
                                        : 0)
                                     | (bHeapGenerateExceptions
                                        ? HEAP_GENERATE_EXCEPTIONS
                                        : 0)
                                     | ((Flags & LMEM_MOVEABLE)
                                        ? 0
                                        : HEAP_REALLOC_IN_PLACE_ONLY)
                                     | ((Flags & LMEM_ZEROINIT)
                                        ? HEAP_ZERO_MEMORY
                                        : 0),
                                     (LPVOID)hLocal,
                                     Size
                                     );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapReAlloc(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        //
        // block still allocated
        //

        hLocal = NULL;
    }
    return hLocal;
}


PRIVATE
HLOCAL
InternetHeapFree(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Free memory to debug heap

Arguments:

    hLocal  - to free

Return Value:

    HLOCAL
        Success - NULL

        Failure - hLocal

--*/

{
    BOOL ok;

    if (hDebugHeap != NULL) {
        ok = HeapFree(hDebugHeap,
                      bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                      (LPVOID)hLocal
                      );
        if (!ok) {

            DWORD error = GetLastError();

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("HeapFree() returns %s (%d)\n",
                        InternetMapError(error),
                        error
                        ));

            MEMORY_ASSERT(FALSE);

        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapFree(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        ok = FALSE;
    }
    return ok ? NULL : hLocal;
}


PRIVATE
SIZE_T
InternetHeapSize(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines size of block allocated from debug heap

Arguments:

    hLocal  - handle (pointer) of block for which to get size

Return Value:

    SIZE_T
        Success - size of block

        Failure - 0

--*/

{
    SIZE_T size;

    if (hDebugHeap != NULL) {
        size = HeapSize(hDebugHeap,
                        bHeapNoSerialize ? HEAP_NO_SERIALIZE : 0,
                        (LPCVOID)hLocal
                        );
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("InternetHeapSize(): hDebugHeap is NULL\n"
                    ));

        MEMORY_ASSERT(FALSE);

        size = (SIZE_T)-1;
    }
    if (size == (SIZE_T)-1) {
        SetLastError(ERROR_INVALID_HANDLE);
        return 0;
    } else {
        return size;
    }
}


PRIVATE
BOOL
InternetDebugCheckMemBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )

/*++

Routine Description:

    Checks the consistency of a debug memory block

Arguments:

    lpHeader    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    BOOL result;

    __try {
        LPDEBUG_MEMORY_FOOTER lpFooter = (LPDEBUG_MEMORY_FOOTER)
            ((LPBYTE)lpHeader
                + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)));

        BOOL headerGuardOverrun = FALSE;
        UINT i;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuardOverrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        BOOL footerGuard2Overrun = FALSE;

        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        LPBYTE lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RequestedLength;
        BOOL extraMemoryOverrun = FALSE;
        SIZE_T byteLength = ROUND_UP_DWORD(lpHeader->RequestedLength) - lpHeader->RequestedLength;

        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_ALLOC_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %#x\n",
                        lpHeader
                        ));

            MEMORY_ASSERT(FALSE);

            result = FALSE;
        } else {
            result = TRUE;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %#x - exception occurred\n",
                    lpHeader
                    ));

        MEMORY_ASSERT(FALSE);

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
InternetDebugMemTest(
    VOID
    )
{
    //
    // test
    //

    LPVOID p;

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    *((LPBYTE)p + 1) = 'X';
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 1);
    p = (LPVOID)REALLOCATE_MEMORY(p, 1111, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 439, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 720, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 256, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 16, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 128, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 32, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 4, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 63, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE | LMEM_ZEROINIT);
    p = (LPVOID)REALLOCATE_MEMORY(p, 65, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)REALLOCATE_MEMORY(p, 64, LMEM_MOVEABLE);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    p = (LPVOID)ALLOCATE_MEMORY(LMEM_FIXED, 8);
    p = (LPVOID)REALLOCATE_MEMORY(p, 8, LMEM_FIXED);
    p = (LPVOID)REALLOCATE_MEMORY(p, 100000, LMEM_FIXED);
    p = (LPVOID)FREE_MEMORY((HLOCAL)p);

    INET_ASSERT(p == NULL);

    InternetDebugCheckMemFreed(TRUE);
}


PRIVATE
VOID
ReportMemoryUsage(
    VOID
    )
{
    //
    // make copies of variables in case debug print functions want to allocate
    // debug memory (!)
    //

    SIZE_T totalActualMemoryAllocated;
    SIZE_T totalBlockMemoryAllocated;
    SIZE_T totalRealMemoryAllocated;
    SIZE_T totalActualMemoryFreed;
    SIZE_T totalBlockMemoryFreed;
    SIZE_T totalRealMemoryFreed;
    SIZE_T actualMemoryAllocated;
    SIZE_T blockLengthAllocated;
    SIZE_T realLengthAllocated;
    DWORD memoryAllocations;
    DWORD goodMemoryAllocations;
    DWORD memoryReAllocations;
    DWORD goodMemoryReAllocations;
    DWORD memoryFrees;
    DWORD goodMemoryFrees;
    SIZE_T largestBlockRequested;
    SIZE_T largestBlockAllocated;
    SIZE_T smallestBlockRequested;
    SIZE_T smallestBlockAllocated;

    EnterCriticalSection(&MemoryVarsCritSec);

    totalActualMemoryAllocated = TotalActualMemoryAllocated;
    totalBlockMemoryAllocated = TotalBlockMemoryAllocated;
    totalRealMemoryAllocated = TotalRealMemoryAllocated;
    totalActualMemoryFreed = TotalActualMemoryFreed;
    totalBlockMemoryFreed = TotalBlockMemoryFreed;
    totalRealMemoryFreed = TotalRealMemoryFreed;
    actualMemoryAllocated = ActualMemoryAllocated;
    blockLengthAllocated = BlockLengthAllocated;
    realLengthAllocated = RealLengthAllocated;
    memoryAllocations = MemoryAllocations;
    goodMemoryAllocations = GoodMemoryAllocations;
    memoryReAllocations = MemoryReAllocations;
    goodMemoryReAllocations = GoodMemoryReAllocations;
    memoryFrees = MemoryFrees;
    goodMemoryFrees = GoodMemoryFrees;
    largestBlockRequested = LargestBlockRequested;
    largestBlockAllocated = LargestBlockAllocated;
    smallestBlockRequested = SmallestBlockRequested;
    smallestBlockAllocated = SmallestBlockAllocated;

    LeaveCriticalSection(&MemoryVarsCritSec);

#ifdef _WIN64
    char numBuf[64];
#else
    char numBuf[32];
#endif

    DEBUG_PUT(("********************************************************************************\n"
               "\n"
               "WinInet Debug Memory Usage:\n"
               "\n"
               "\tInternetDebugMemFlags = %#08x\n"
               "\n",
               InternetDebugMemFlags
               ));
    DEBUG_PUT(("\tTotal Memory Allocated. . . , . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Block Length Allocated. . . . . %s\n", NiceNum(numBuf, totalBlockMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal User Length Allocated . . . . . %s\n", NiceNum(numBuf, totalRealMemoryAllocated, 0)));
    DEBUG_PUT(("\tTotal Memory Freed. . . . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal Block Length Freed. . . . . . . %s\n", NiceNum(numBuf, totalBlockMemoryFreed, 0)));
    DEBUG_PUT(("\tTotal User Length Freed . . . . . . . %s\n", NiceNum(numBuf, totalRealMemoryFreed, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, actualMemoryAllocated, 0)));
    DEBUG_PUT(("\tBlock Length Still Allocated. . . . . %s\n", NiceNum(numBuf, blockLengthAllocated, 0)));
    DEBUG_PUT(("\tUser Length Still Allocated . . . . . %s\n", NiceNum(numBuf, realLengthAllocated, 0)));
    DEBUG_PUT(("\tAttempted Memory Allocations. . . . . %s\n", NiceNum(numBuf, memoryAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Allocations . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Reallocations. . . . %s\n", NiceNum(numBuf, memoryReAllocations, 0)));
    DEBUG_PUT(("\tGood Memory Reallocations . . . . . . %s\n", NiceNum(numBuf, goodMemoryReAllocations, 0)));
    DEBUG_PUT(("\tAttempted Memory Frees. . . . . . . . %s\n", NiceNum(numBuf, memoryFrees, 0)));
    DEBUG_PUT(("\tGood Memory Frees . . . . . . . . . . %s\n", NiceNum(numBuf, goodMemoryFrees, 0)));
    DEBUG_PUT(("\tLargest Block Requested . . . . . . . %s\n", NiceNum(numBuf, largestBlockRequested, 0)));
    DEBUG_PUT(("\tLargest Block Allocated . . . . . . . %s\n", NiceNum(numBuf, largestBlockAllocated, 0)));
    DEBUG_PUT(("\tLargest Block Requested From. . . . . %s!%d\n", SourceFilename(LargestBlockRequestedFile), LargestBlockRequestedLine));
    DEBUG_PUT(("\tSmallest Block Requested. . . . . . . %s\n", NiceNum(numBuf, smallestBlockRequested, 0)));
    DEBUG_PUT(("\tSmallest Block Allocated. . . . . . . %s\n", NiceNum(numBuf, smallestBlockAllocated, 0)));
    DEBUG_PUT(("\tSmallest Block Requested From . . . . %s!%d\n", SourceFilename(SmallestBlockRequestedFile), SmallestBlockRequestedLine));
    DEBUG_PUT(("\n"
               "\tBlocks Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, goodMemoryAllocations - goodMemoryFrees, 0)));
    DEBUG_PUT(("\tMemory Still Allocated. . . . . . . . %s\n", NiceNum(numBuf, totalActualMemoryAllocated - totalActualMemoryFreed, 0)));
    DEBUG_PUT(("\n"
               "********************************************************************************\n"
               "\n"));
}


PRIVATE
VOID
ReportMemoryBlocks(
    VOID
    )
{
    DEBUG_PUT(("ReportMemoryBlocks\n\n"));

    DEBUG_PUT(("AllocatedBlockList:\n\n"));

    DumpMemoryList(&AllocatedBlockList);
    if (bDeferFree) {
        DumpDeferredFreeList();
    }
}


PRIVATE
VOID
DumpDeferredFreeList(
    VOID
    )
{
    DEBUG_PUT(("DeferredFreeList:\n\n"));

    DumpMemoryList(&DeferredFreeList);
}


PRIVATE
VOID
DumpMemoryList(
    IN LPSERIALIZED_LIST lpList
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;
    int counter = 1;

    if (bUseSymbols) {

        //
        // have to load IMAGEHLP.DLL here because we're in DLL_PROCESS_DETACH
        // and if we loaded it earlier, there's a good chance the system has
        // already freed it
        //

        InitSymLib();
    }

    LockSerializedList(lpList);
    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(lpList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(lpList)) {

        DEBUG_PUT(("Block # %d\n", counter));


        if (!DumpBlock(lpHeader)) {
            break;
        }

        DEBUG_PUT(("********************************************************************************\n\n"));

        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
        ++counter;
    }
    UnlockSerializedList(lpList);
}


PRIVATE
VOID
FindAndDumpDeferredBlock(
    IN HLOCAL hLocal
    )
{
    LPDEBUG_MEMORY_HEADER lpHeader;

    LockSerializedList(&DeferredFreeList);

    lpHeader = (LPDEBUG_MEMORY_HEADER)HeadOfSerializedList(&DeferredFreeList);
    while (lpHeader != (LPDEBUG_MEMORY_HEADER)SlSelf(&DeferredFreeList)) {
        if (hLocal == (HLOCAL)lpHeader) {
            DumpBlock(lpHeader);
            break;
        }
        lpHeader = (LPDEBUG_MEMORY_HEADER)(lpHeader->List.Flink);
    }

    UnlockSerializedList(&DeferredFreeList);
}


PRIVATE
BOOL
DumpBlock(
    IN LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    BOOL ok = DumpDebugMemoryHeader(lpHeader);

    if (!ok && bStopDumpIfBadBlock) {

        DEBUG_PUT(("*** stopping block dump: header @ %#x is bad\n", lpHeader));

        return FALSE;
    }
    if (bReportUserData) {
        DumpUserData(lpHeader);
    }
    if (bReportMemoryFooters) {

        LPDEBUG_MEMORY_FOOTER lpFooter;

        lpFooter = (LPDEBUG_MEMORY_FOOTER)
                        ((LPBYTE)lpHeader
                        + sizeof(*lpHeader)
                        + ROUND_UP_DWORD(lpHeader->RequestedLength));
        ok = DumpDebugMemoryFooter(lpFooter);
        if (!ok && bStopDumpIfBadBlock) {

            DEBUG_PUT(("*** stopping block dump: footer @ %#x is bad\n", lpFooter));

            return FALSE;
        }
    }
    return TRUE;
}


PRIVATE
BOOL
DumpDebugMemoryHeader(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    char numBuf[32];
    BOOL result;
    LPSTR symbol;
    DWORD offset;
    int i;
    char flagsBuf[256];

    __try {
        DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x:\n"
                   "\n",
                   lpHeader
                   ));
        DEBUG_PUT(("\tList. . . . . . . . . F=%#x B=%#x\n",
                   lpHeader->List.Flink,
                   lpHeader->List.Blink
                   ));
        DEBUG_PUT(("\tThread. . . . . . . . %#x\n",
                   lpHeader->ThreadId
                   ));
        DEBUG_PUT(("\tAllocated From. . . . %s!%d\n",
                   SourceFilename(lpHeader->CreatedFile),
                   lpHeader->CreatedLine
                   ));
        DEBUG_PUT(("\tLast Accessed From. . %s!%d\n",
                   SourceFilename(lpHeader->AccessedFile),
                   lpHeader->AccessedLine
                   ));
        DEBUG_PUT(("\tRequested Length. . . %s\n",
                   NiceNum(numBuf, lpHeader->RequestedLength, 0)
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpHeader->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tActual Length . . . . %s\n",
                   NiceNum(numBuf, lpHeader->ActualLength, 0)
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpHeader->Signature,
                   (lpHeader->Signature == HEADER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tFlags . . . . . . . . %08x %s\n",
                   lpHeader->Flags,
                   MapMemoryFlags(lpHeader->Flags, flagsBuf)
                   ));
        DEBUG_PUT(("\tTime Deferred . . . . %08x\n",
                   lpHeader->TimeDeferred
                   ));
        DEBUG_PUT(("\tClash Test. . . . . . %d\n",
                   lpHeader->ClashTest
                   ));
        DEBUG_PUT(("\tLast Operation. . . . %s\n",
                   MapLastAccessOperation(lpHeader->LastAccessOperation)
                   ));

#if DUMP_STACK
#if ONE_STACK

        if (lpHeader->Stack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tStack . . . . . . . . %08x %s+%#x\n",
                   lpHeader->Stack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->Stack); ++i) {
            //if (!lpHeader->lpHeader->Stack[i]) {
            //    break;
            //}
            if (lpHeader->Stack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->Stack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->Stack[i],
                       symbol,
                       offset
                       ));
        }

#else

        if (lpHeader->LastAccessStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tLastAccessStack . . . %08x %s+%#x\n",
                   lpHeader->LastAccessStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->LastAccessStack); ++i) {
            //if (!lpHeader->LastAccessStack[i]) {
            //    break;
            //}
            if (lpHeader->LastAccessStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->LastAccessStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->LastAccessStack[i],
                       symbol,
                       offset
                       ));
        }
        if (lpHeader->CreateStack[0]) {
            symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[0], &offset);
        } else {
            symbol = "";
            offset = 0;
        }
        DEBUG_PUT(("\tCreateStack . . . . . %08x %s+%#x\n",
                   lpHeader->CreateStack[0],
                   symbol,
                   offset
                   ));
        for (i = 1; i < ARRAY_ELEMENTS(lpHeader->CreateStack); ++i) {
            //if (!lpHeader->lpHeader->CreateStack[i]) {
            //    break;
            //}
            if (lpHeader->CreateStack[i]) {
                symbol = DbgMemGetDebugSymbol((DWORD)lpHeader->CreateStack[i], &offset);
            } else {
                symbol = "";
                offset = 0;
            }
            DEBUG_PUT(("\t. . . . . . . . . . . %08x %s+%#x\n",
                       lpHeader->CreateStack[i],
                       symbol,
                       offset
                       ));
        }

#endif // ONE_STACK
#endif // DUMP_STACK

        DEBUG_PUT(("\tGuard . . . . . . . . %08x\n"
                   "\n",
                   lpHeader->Guard[0]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_HEADER @ %#x is BAD\n", lpHeader));

        result = FALSE;
    }
    return result;
}


PRIVATE
BOOL
DumpDebugMemoryFooter(
    LPDEBUG_MEMORY_FOOTER lpFooter
    )
{
    char numBuf[32];
    BOOL result;

    _try {
        DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x:\n"
                   "\n",
                   lpFooter
                   ));
        DEBUG_PUT(("\tGuard . . . . . . . . %08x %08x %08x %08x\n",
                   lpFooter->Guard[0],
                   lpFooter->Guard[1],
                   lpFooter->Guard[2],
                   lpFooter->Guard[3]
                   ));
        DEBUG_PUT(("\tSignature . . . . . . %x (%s)\n",
                   lpFooter->Signature,
                   (lpFooter->Signature == FOOTER_SIGNATURE) ? "Good" : "BAD!!!"
                   ));
        DEBUG_PUT(("\tBlock Length. . . . . %s\n",
                   NiceNum(numBuf, lpFooter->BlockLength, 0)
                   ));
        DEBUG_PUT(("\tGuard2. . . . . . . . %08x %08x\n"
                   "\n",
                   lpFooter->Guard2[0],
                   lpFooter->Guard2[1]
                   ));
        result = TRUE;
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //DEBUG_PUT(("DEBUG_MEMORY_FOOTER @ %#x is BAD\n", lpFooter));

        result = FALSE;
    }
    return result;
}


PRIVATE
VOID
DumpUserData(
    LPDEBUG_MEMORY_HEADER lpHeader
    )
{
    static char spaces[] = "                                              ";    // 15 * 3 + 2
    SIZE_T userSize = lpHeader->RequestedLength;
    SIZE_T Size = ROUND_UP_DWORD(userSize);
    LPBYTE Address = (LPBYTE)(lpHeader + 1);

    DEBUG_PUT(("\t%d (%#x) bytes of user data (rounded to %d (%#x)) @ %#x\n\n",
               userSize,
               userSize,
               Size,
               Size,
               Address
               ));

    if (bLimitUserData && (Size > MaxUserDataDumped)) {

        DEBUG_PUT(("*** User data length %d too large: limited to %d (probably bad block)\n",
                   Size,
                   MaxUserDataDumped
                   ));

        Size = MaxUserDataDumped;
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        char buf[128];
        int len;
        int clen;

        rsprintf(buf, "\t%08x  ", Address);

        clen = (int)min(Size, 16);
        if (bDumpAsDwords) {
            len = clen / 4;
        } else {
            len = clen;
        }

        //
        // dump the hex representation of each character - up to 16 per line
        //

        int i;

        for (i = 0; i < len; ++i) {
            if (bDumpAsDwords) {
                rsprintf(&buf[11 + i * 9], "%08x ", ((LPDWORD)Address)[i]);
            } else {
                rsprintf(&buf[11 + i * 3],
                         ((i & 15) == 7) ? "%02.2x-" : "%02.2x ",
                         Address[i] & 0xff
                         );
            }
        }

        //
        // write as many spaces as required to tab to ASCII field
        //

        int offset;

        if (bDumpAsDwords) {
            memcpy(&buf[11 + i * 9], spaces, (4 - len) * 9 + 2);
            offset = 49;
        } else {
            memcpy(&buf[11 + i * 3], spaces, (16 - len) * 3 + 2);
            offset = 60;
        }

        //
        // dump ASCII representation of each character
        //

        for (i = 0; i < clen; ++i) {

            char ch;

            ch = Address[i];
            buf[offset + i] = ((ch < 32) || (ch > 127)) ? '.' : ch;
        }

        buf[offset + i++] = '\r';
        buf[offset + i++] = '\n';
        buf[offset + i] = 0;

        //
        // InternetDebugOut() - no printf expansion (%s in data!), no prefixes
        //

        InternetDebugOut(buf, FALSE);

        Address += clen;
        Size -= clen;
    }

    InternetDebugOut("\r\n", FALSE);
}


PRIVATE
LPSTR
MapLastAccessOperation(
    MEMORY_ACTION Action
    )
{
    switch (Action) {
    case MemAllocate:
        return "Alloc";

    case MemReallocate:
        return "Realloc";

    case MemLock:
        return "Lock";

    case MemUnlock:
        return "Unlock";

    case MemFree:
        return "Free";

    case MemSize:
        return "Size";
    }
    return "?";
}


PRIVATE
LPSTR
MapMemoryFlags(
    DWORD Flags,
    LPSTR Buffer
    )
{
    LPSTR buf = Buffer;
    int i = 0;

    *buf++ = '(';
    if (Flags & LMEM_DISCARDABLE) {
        buf += wsprintf(buf, "DISCARDABLE");
        ++i;
    }
    if (Flags & LMEM_ZEROINIT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "ZEROINIT");
    }
    if (Flags & LMEM_NODISCARD) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NODISCARD");
    }
    if (Flags & LMEM_NOCOMPACT) {
        if (i) {
            buf += wsprintf(buf, ", ");
        }
        ++i;
        buf += wsprintf(buf, "NOCOMPACT");
    }
    if (i) {
        buf += wsprintf(buf, ", ");
    }
    ++i;
    buf += wsprintf(buf, (Flags & LMEM_MOVEABLE) ? "MOVEABLE" : "FIXED");
    *buf++ = ')';
    *buf++ = '\0';
    return Buffer;
}


PRIVATE
LPSTR
DbgMemGetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    ) {
    //if (!bUseSymbols) {
    //    return "?";
    //}

    //
    // RLF 04/14/98 - IMAGEHLP blowing up probably because we are doing this at
    //                process detach time. Just return offset and run convsym
    //                utility on wininet.log
    //

    //return GetDebugSymbol(Address, Offset);
    *Offset = Address;
    return "";
}

#endif // defined(USE_DEBUG_MEMORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\common\ssocket.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ssocket.cxx

Abstract:

    Contains secure sockets functions and ICSecureSocket methods

    Contents:
        SecurityPkgInitialize
        ReadCertificateIntoCertInfoStruct
        ChkCertificateCommonNameIsValid
        ChkCertificateExpired
        ICSecureSocket::ICSecureSocket
        ICSecureSocket::~ICSecureSocket
        ICSecureSocket::Connect
        CFsm_SecureConnect::RunSM
        ICSecureSocket::Connect_Fsm
        ICSecureSocket::SecureHandshakeWithServer
        CFsm_SecureHandshake::RunSM
        ICSecureSocket::SecureHandshake_Fsm
        ICSecureSocket::NegotiateSecConnection
        CFsm_SecureNegotiate::RunSM
        ICSecureSocket::SecureNegotiate_Fsm
        ICSecureSocket::SSPINegotiateLoop
        CFsm_NegotiateLoop::RunSM
        ICSecureSocket::NegotiateLoop_Fsm
        ICSecureSocket::Disconnect
        ICSecureSocket::Send
        CFsm_SecureSend::RunSM
        ICSecureSocket::Send_Fsm
        ICSecureSocket::Receive
        CFsm_SecureReceive::RunSM
        ICSecureSocket::Receive_Fsm
        ICSecureSocket::SetHostName
        (ICSecureSocket::EncryptData)
        (ICSecureSocket::DecryptData)
        (ICSecureSocket::TerminateSecConnection)
        ICSecureSocket::GetCertInfo

Author:

    Richard L Firth (rfirth) 08-Apr-1997

Environment:

    Win32 user mode

Revision History:

    08-Apr-1997 rfirth
        Created from ixport.cxx

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include <ierrui.hxx>

extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <softpub.h>

}

//
//
//  List of encryption packages:  PCT, SSL, etc
//

//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//

// BUGBUG:  Don't change the order of the packages below.  some old SSL2 sites deny the UNISP
// provider, and if we walk down the list to PCT1 or SSL3, things hang.
struct _SEC_PROVIDER SecProviders[] =
{
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT | ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_CLIENTS, NULL,
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL2_CLIENT, NULL,
//    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_PCT1_CLIENT, NULL,
//    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL3_CLIENT, NULL,
    NULL,        INVALID_CRED_VALUE , FALSE,        FALSE, 0
};



//
// dwEncFlags - Global Status of calling and initalizing the SCHANNEL and various
//   other encyrption support DLL & APIs.  Failure in the process will
//   cause this to be set to an error state, success prevents re-initalizaiton
//

DWORD dwEncFlags = 0;

//
// GlobalSecureProtocolsCopy - Copy of the current protocols the user wants to use
//   changing them allows us to restrict to specific protocols
//
DWORD GlobalSecureProtocolsCopy = DEFAULT_SECURE_PROTOCOLS;


#ifdef SECPKG_ATTR_PROTO_INFO
PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo);
#endif

//
// general security package functions
//
BOOL
SecurityPkgInitialize(
    BOOL fForce
    )
/*++

Routine Description:

    This function finds a list of security packages that are supported
    on the client's machine, check if pct or ssl is supported, and
    create a credential handle for each supported pkg.

Arguments:

    None

Return Value:

    TRUE if at least one security pkg is found; otherwise FALSE

--*/
{
    TimeStamp         tsExpiry;
    SECURITY_STATUS   scRet;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             fCapabilities;
    ULONG             i;
    ULONG             j;
    DWORD             cProviders = 0;

    SCHANNEL_CRED DefaultCredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     SP_PROT_CLIENTS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                    };

    //
    // Set new DWORD for our copy of the global protocol settings.
    //
    bool    fSame = (GlobalSecureProtocolsCopy==GlobalSecureProtocols);
    GlobalSecureProtocolsCopy = GlobalSecureProtocols;

    //
    //  check if this routine has been called.  if yes, return TRUE
    //  if we've found a supported pkg; otherwise FALSE
    //

    if ( dwEncFlags == ENC_CAPS_NOT_INSTALLED )
       return FALSE;
    else if ((dwEncFlags&ENC_CAPS_TYPE_MASK) && fSame && !fForce)
       return TRUE;

    //
    //  Initialize dwEncFlags
    //

    dwEncFlags = ENC_CAPS_NOT_INSTALLED;

    //
    //  Check if at least one security package is supported
    //


    scRet = g_EnumerateSecurityPackages( &cPackages,
                                         &pPackageInfo );

    if ( scRet != STATUS_SUCCESS )
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("EnumerateSecurityPackages failed, error %lx\n",
                    scRet
                    ));

        SetLastError( scRet );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  Use only if the package name is the PCT/SSL package
        //

        fCapabilities = pPackageInfo[i].fCapabilities;

        if ( fCapabilities & SECPKG_FLAG_STREAM )
        {
            //
            //  Check if the package supports server side authentication
            //  and all recv/sent messages are tamper proof
            //

            if ( fCapabilities & SECPKG_FLAG_CLIENT_ONLY ||
                 !(fCapabilities & SECPKG_FLAG_PRIVACY ))
            {
                continue;
            }

            //
            //  Check if the pkg matches one of our known packages
            //

            for ( j = 0; SecProviders[j].pszName != NULL; j++ )
            {
                if ( !stricmp( pPackageInfo[i].Name, SecProviders[j].pszName ) )
                {
                    CredHandle OldCred;
                    PVOID pCredData = NULL;

                    //
                    //  Create a credential handle for each supported pkg
                    //

                    INET_ASSERT((SecProviders[j].dwFlags & ENC_CAPS_SCHANNEL_CREDS));

                    pCredData = &DefaultCredData;

                    if (SecProviders[j].pCertCtxt != NULL) {
                        DefaultCredData.cCreds = 1;
                        DefaultCredData.paCred = &SecProviders[j].pCertCtxt;
                    }

                    //
                    // Enable Supported protocols in the Default Cred Data, then acquire the Credential
                    //

                    DefaultCredData.grbitEnabledProtocols = (GlobalSecureProtocols & SecProviders[j].dwProtocolFlags);

                    OldCred.dwUpper = SecProviders[j].hCreds.dwUpper;
                    OldCred.dwLower = SecProviders[j].hCreds.dwLower;

                    // Zero out previous credentials
                    SecProviders[j].hCreds.dwUpper = SecProviders[j].hCreds.dwLower = 0;

                    scRet = g_AcquireCredentialsHandle(
                                      NULL,
                                      SecProviders[j].pszName, // Package
                                      SECPKG_CRED_OUTBOUND,
                                      NULL,
                                      pCredData,
                                      NULL,
                                      NULL,
                                      &(SecProviders[j].hCreds), // Handle
                                      &tsExpiry );

                    if(!IS_CRED_INVALID(&OldCred))
                    {
                        g_FreeCredentialsHandle(&OldCred);
                    }

                    DefaultCredData.cCreds = 0;
                    DefaultCredData.paCred = NULL;

                    if ( scRet != STATUS_SUCCESS )
                    {
                        DEBUG_PRINT(API,
                                    WARNING,
                                    ("AcquireCredentialHandle failed, error %lx\n",
                                    scRet
                                    ));

                        SecProviders[j].fEnabled = FALSE;

                        SecProviders[j].hCreds.dwUpper = 0xffffffff;
                        SecProviders[j].hCreds.dwLower = 0xffffffff;


                    }
                    else
                    {
                        DEBUG_PRINT(
                             API,
                             INFO,
                             ("AcquireCredentialHandle() supports %s, acquires %x:%x\n",
                             SecProviders[j].pszName,
                             SecProviders[j].hCreds.dwUpper,
                             SecProviders[j].hCreds.dwLower
                             ));

                        SecProviders[j].fEnabled = TRUE;
                        cProviders++;
                        dwEncFlags |= SecProviders[j].dwFlags;
                    }
                }
            }
        }
    }

    if ( !cProviders )
    {
        //
        //  No security packages were found, return FALSE to caller
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("No security packages were found, error %lx\n",
                    SEC_E_SECPKG_NOT_FOUND
                    ));

        g_FreeContextBuffer( pPackageInfo );

        SetLastError( (DWORD) SEC_E_SECPKG_NOT_FOUND );

        return FALSE;
    }

    //
    //  Successfully found a security package(s)
    //

    return TRUE;
}


DWORD
QuerySecurityInfo(
                  IN CtxtHandle *hContext,
                  OUT LPINTERNET_SECURITY_INFO pInfo)
{
    SECURITY_STATUS      scRet;

    scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                     &pInfo->pCertificate );

    if (scRet != ERROR_SUCCESS)
    {

        //
        // Map the SSPI error.
        //
        return MapInternetError((DWORD) scRet);

    }

    scRet = g_QueryContextAttributes(hContext,
                                     SECPKG_ATTR_CONNECTION_INFO,
                                     &pInfo->dwProtocol );

    if (scRet != ERROR_SUCCESS)
    {

        //
        // Map the SSPI error.
        //
        return MapInternetError((DWORD) scRet);
    }

    pInfo->dwSize = sizeof(INTERNET_SECURITY_INFO);

    return ERROR_SUCCESS;
}

// Helper function to detect Fortezza connections.
BOOL IsCertificateFortezza(PCCERT_CONTEXT pCertContext)
{
    INET_ASSERT(pCertContext != NULL);
    if (pCertContext == NULL)
        return FALSE;

    LPSTR pszOid = pCertContext->pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId;

    if (pszOid)
    {
        if (strcmp(pszOid, szOID_INFOSEC_mosaicUpdatedSig) == 0 ||
             strcmp(pszOid, szOID_INFOSEC_mosaicKMandUpdSig) == 0)
        {
            return TRUE;
        }
    }
    return FALSE;
}


LONG WinVerifySecureChannel(HWND hwnd, WINTRUST_DATA *pWTD)
/*++

Routine Description:

    Wininet's wrapper for secure channel WinVerifyTrust calls.

Arguments:

    hWnd - in case WinVerifyTrust needs to do UI.
    pWTD - pointer to WINTRUST_DATA containing details about the
           secure channel. Passed to WinVerifyTrust.
Return Value:

    WIN32 error code.

--*/
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    LONG  lResult;
    BOOL  bFortezza;
    GUID  gHTTPS = HTTPSPROV_ACTION;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }
    bFortezza = IsCertificateFortezza(pWTD->pCert->psCertContext);

    if (bFortezza && g_CryptInstallDefaultContext == NULL)
    {
        // HACK: we have no way to verify a connection without
        // a crypt32 which has the new APIs exposed. Till IE5 picks up
        // the new crypto bits we will assume Fortezza connections
        // verify correctly.
        lResult = ERROR_SUCCESS;
    }
    else
    {
        HCRYPTDEFAULTCONTEXT hCryptDefaultContext = NULL;

        if (bFortezza)
        {
            if (!g_CryptInstallDefaultContext(
                        GlobalFortezzaCryptProv,
                        CRYPT_DEFAULT_CONTEXT_CERT_SIGN_OID,
                        szOID_INFOSEC_mosaicUpdatedSig,         // check with John Banes
                        0,                                      // dwFlags
                        NULL,                                   // pvReserved
                        &hCryptDefaultContext
                        ))
            {
                lResult = GetLastError();
                goto quit;
            }
        }

        lResult = g_WinVerifyTrust(hwnd, &gHTTPS, pWTD);

        DEBUG_PUT(("WinVerifyTrust returned: %x\n", lResult));

        if (hCryptDefaultContext)
        {
            // Ignore error code while freeing since we can't do anything
            // meaningful about it here.
            BOOL bResult;
            bResult = g_CryptUninstallDefaultContext(
                        hCryptDefaultContext,
                        0,
                        NULL);
            INET_ASSERT(bResult);
        }
    }

quit:

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }
    return lResult;
}


//
// ICSecureSocket methods
//


ICSecureSocket::ICSecureSocket(
    IN DWORD dwErrorFlags,
    IN INTERNET_SCHEME tScheme
    )

/*++

Routine Description:

    ICSecureSocket constructor

Arguments:

    tScheme - which protocol scheme we are creating the socket for

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::ICSecureSocket",
                 "{%#x}",
                 this
                 ));

    SIGN_SECURE_SOCKET();

    m_hContext.dwLower = m_hContext.dwUpper = 0;
    m_dwProviderIndex = 0;
    m_dwFlags |= SF_SECURE;
    m_dwErrorFlags = dwErrorFlags;
    m_lpszHostName = NULL;
    m_pdblbufBuffer = NULL;
    m_pSecurityInfo = NULL;

    DEBUG_LEAVE(0);
}


ICSecureSocket::~ICSecureSocket()

/*++

Routine Description:

    ICSecureSocket destructor. Virtual function

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "ICSecureSocket::~ICSecureSocket",
                 "{%#x [%q, sock=%#x, port=%d]}",
                 this,
                 GetHostName(),
                 GetSocket(),
                 GetSourcePort()
                 ));

    CHECK_SECURE_SOCKET();
    INET_ASSERT(IsSecure());

    if (m_pdblbufBuffer != NULL) {
        delete m_pdblbufBuffer;
    }

    // Free security context associated with this object if it's
    // still allocated.
    TerminateSecConnection();


    /* SCLE ref */
    SetSecurityEntry(NULL);
    if (m_lpszHostName != NULL) {
        m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);
        INET_ASSERT(m_lpszHostName == NULL);
    }
    //if ( _pCertChainList )
    //    delete _pCertChainList;

    DEBUG_LEAVE(0);
}


DWORD
ICSecureSocket::Connect(
    IN LONG Timeout,
    IN INT Retries,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Initiate secure connection with server

Arguments:

    Timeout - maximum amount of time (mSec) to wait for connection

    Retries - maximum number of attempts to connect

    dwFlags - flags controlling request

Return Value:

    DWORD
        Success - ERROR_SUCCESS

                  ERROR_IO_PENDING
                    Operation will complete asynchronously

        Failure - ERROR_NOT_ENOUGH_MEMORY
                    Couldn't create FSM

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect",
                 "{%#x [%#x]} %d, %d, %#x",
                 this,
                 m_Socket,
                 Timeout,
                 Retries,
                 dwFlags
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureConnect(Timeout,
                                               Retries,
                                               dwFlags,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureConnect::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureConnect::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureConnect * stateMachine = (CFsm_SecureConnect *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Connect_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Connect_Fsm(
    IN CFsm_SecureConnect * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Connect_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureConnect & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto connect_continue;

        case FSM_STATE_3:
            goto negotiate_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    m_dwProviderIndex = 0;
    //SetNonSecure();

    //
    // Hack for SSL2 Client Hello, set to FALSE,
    //  but if we fail on the first recv, fReOpenSocket
    //  is set to TRUE.
    //

    do {

        //
        // Attempt to do the connect
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Connect(fsm.m_Timeout, fsm.m_Retries, fsm.m_dwFlags);

connect_continue:

        if (error != ERROR_SUCCESS) {
            break;
        }
        if (m_dwFlags & SF_ENCRYPT) {
            fsm.SetFunctionState(FSM_STATE_3);
            error = SecureHandshakeWithServer(fsm.m_dwFlags, &fsm.m_bAttemptReconnect);
            if (error == ERROR_IO_PENDING) {
                break;
            }

negotiate_continue:

            //
            // SSL2 hack for old IIS servers.
            //  We re-open the socket, and call again.
            //

            if ((error != ERROR_SUCCESS) && fsm.m_bAttemptReconnect) {
                Disconnect(fsm.m_dwFlags);
            }
        }
    } while (fsm.m_bAttemptReconnect);

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
        if ((error != ERROR_SUCCESS) && IsOpen()) {
            Disconnect(fsm.m_dwFlags);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshakeWithServer(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    For SSL/PCT or some secure channel this function attempts to use
    an arbitrary Socket for handshaking with a server. The assumption
    is made that caller can recall this function on failure

Arguments:

    dwFlags             -

    lpbAttemptReconnect -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                Dword,
                "ICSecureSocket::SecureHandshakeWithServer",
                "%#x, %#x [%B]",
                dwFlags,
                lpbAttemptReconnect,
                *lpbAttemptReconnect
                ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureHandshake(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureHandshake::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureHandshake::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureHandshake * stateMachine = (CFsm_SecureHandshake *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureHandshake_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureHandshake_Fsm(
    IN CFsm_SecureHandshake * Fsm
    )
{


    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureHandshake_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureHandshake & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSecureFlags;
    DWORD dwCertFlags;
    BOOL fErrorInvalidCa;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //INET_ASSERT(fsm.m_dwFlags & SF_ENCRYPT);
    INET_ASSERT(m_Socket != INVALID_SOCKET);

    *fsm.m_lpbAttemptReconnect = FALSE;

    error = ERROR_SUCCESS;

    //
    // Save Off Flags in our Internal Object.
    //   Treat SF_ENCRYPT just like SF_DECRYPT
    //

    m_dwFlags |= SF_DECRYPT;
    m_dwFlags |= fsm.m_dwFlags;

    INET_ASSERT(!(m_dwFlags
                & ~(SF_NON_BLOCKING
                    | SF_SECURE
                    | SF_ENCRYPT
                    | SF_DECRYPT
                    | SF_INDICATE
                    | SF_SENDING_DATA
                    )));

    //
    // Allocate Internal Buffer for SSL/PCT data.
    //

    if (m_pdblbufBuffer == NULL) {

        BOOL fInitSuccess;

        m_pdblbufBuffer = new DBLBUFFER();
        if (m_pdblbufBuffer == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        fInitSuccess = m_pdblbufBuffer->InitBuffer(TRUE);
        if (!fInitSuccess) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
    }

    // First make sure the security dlls are loaded.
    error = LoadSecurity();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    // If the user has the Fortezza CSP but has not logged on to the card yet.
    // return back an error to indicate that we need to put up additional UI.

    // if (IsFortezzaInstalled( ) && !AttemptedFortezzaLogin( ))
    //{
    //    error = ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED;
    //    goto quit;
    //}

    //
    //  dwEncFlags is a global flag set to the
    //  supported security pkg mask
    //

    LOCK_SECURITY();

    if (dwEncFlags == ENC_CAPS_NOT_INSTALLED) {
         error = (DWORD)SEC_E_SECPKG_NOT_FOUND;
    } else if (dwEncFlags == 0) {


         //
         //  first time thru, do the load.
         //

         DEBUG_PRINT(SOCKETS,
                     INFO,
                     ("Loading security dll\n"
                     ));

        if ( !SecurityPkgInitialize() ) {
             error = GetLastError();
             UNLOCK_SECURITY();
             goto quit;
        }
    }

    UNLOCK_SECURITY();

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }


    //
    // If we succeed in loading or and initalizing the Security DLLs, we
    //      attempt to negotiate the connection
    //

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("Negotiate secure channel\n"
                ));

    //
    // Turn of Encryption/Decryption before the handshake,
    // since the NegotiateSecConnection does its own Send and Recvs
    // of specialized data.
    //

    m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
    fsm.SetFunctionState(FSM_STATE_2);
    error = NegotiateSecConnection(fsm.m_dwFlags,
                                   fsm.m_lpbAttemptReconnect
                                   );
    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_continue:

    m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    //  Find out what size Key we're using, and set the flags
    //   acordingly.
    //

    dwSecureFlags = 0;
    if ((m_pSecurityInfo && !m_pSecurityInfo->InCache()) || !IsValidCacheEntry()) {
        error = VerifyTrust();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // we've got a secure connection, set the flags.
    //

    SetSecure();

    if(m_pSecurityInfo)
    {
        INTERNET_SECURITY_INFO ciInfo;
        m_pSecurityInfo->CopyOut(ciInfo);

        if(ciInfo.dwCipherStrength < 56)
        {
            SetSecureFlags(SECURITY_FLAG_STRENGTH_WEAK);
        }
        else if (ciInfo.dwCipherStrength==80 &&
                 (ciInfo.aiCipher == CALG_SKIPJACK || ciInfo.aiCipher==CALG_TEK))
        {
            SetSecureFlags(SECURITY_FLAG_FORTEZZA);
        }
        else if(ciInfo.dwCipherStrength < 96)
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_MEDIUM);
        }
        else
        {
             SetSecureFlags(SECURITY_FLAG_STRENGTH_STRONG);
        }
        if(ciInfo.pCertificate)
        {
            CertFreeCertificateContext(ciInfo.pCertificate);
            ciInfo.pCertificate = NULL;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


BOOL ICSecureSocket:: IsValidCacheEntry()
{

    INTERNET_SECURITY_INFO ciCert;
    INTERNET_SECURITY_INFO ciInfo;
    DWORD error;
    BOOL fRet = FALSE;

    ciCert.pCertificate = NULL;
    ciInfo.pCertificate = NULL;
    
    error = QuerySecurityInfo(&m_hContext, &ciCert);

    if( (error == ERROR_SUCCESS) && ciCert.pCertificate && m_pSecurityInfo)
    {
        m_pSecurityInfo->CopyOut(ciInfo);
        if(ciInfo.pCertificate->cbCertEncoded  != ciCert.pCertificate->cbCertEncoded ||
            memcmp(ciInfo.pCertificate->pbCertEncoded , ciCert.pCertificate->pbCertEncoded , ciInfo.pCertificate->cbCertEncoded))
        {
            GlobalCertCache.Remove(GetHostName());
            SECURITY_CACHE_LIST_ENTRY* pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(GetHostName());
            (*m_ppSecurityInfo)->Release();
            *m_ppSecurityInfo = pSecurityInfo;
            pSecurityInfo->AddRef();
            SetSecurityEntry(&pSecurityInfo);
        }
        else
            fRet = TRUE;
    }

    if (ciCert.pCertificate)
    {
        CertFreeCertificateContext(ciCert.pCertificate);
    }
    
    if (ciInfo.pCertificate)
    {
        CertFreeCertificateContext(ciInfo.pCertificate);
    }
    
    return fRet;
}


DWORD
ICSecureSocket::VerifyTrust(
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/
{

    // We've done our handshake, now update the security info
    INTERNET_SECURITY_INFO ciCert;
    DWORD dwCertFlags = 0;
    WINTRUST_DATA           sWTD;
    WINTRUST_CERT_INFO      sWTCI;
    HTTPSPolicyCallbackData polHttps;
    DWORD                   cbServerName;
    DWORD error;
    HINTERNET  hInternet;
    HINTERNET  hInternetMapped;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;

    DWORD dwFlags = 0;    // HTTPS policy flags to ignore errors

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::VerifyTrust",
                 "{%#x",
                 this
                 ));

    // HACK HACK: 67640
    // WinVerifyTrust can do a nested HttpSendRequest which causes the hObject's on the 
    // thread to get messed up. This happens only when the ceritificate has a URL for 
    // a CRL in it. We save and restore these values to workaround the problem.
    // Need to work out a better solution to handle this but it is too close to ship to 
    // try anything with greater code impact. 
    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
        hInternetMapped = lpThreadInfo->hObjectMapped;
    }


    error = QuerySecurityInfo(&m_hContext, &ciCert);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if(m_pSecurityInfo)
    {
        *m_pSecurityInfo = &ciCert;
        dwCertFlags = m_pSecurityInfo->GetSecureFlags();
    }
    if (ciCert.pCertificate == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    memset(&sWTD, 0x00, sizeof(WINTRUST_DATA));
    sWTD.cbStruct               = sizeof(WINTRUST_DATA);
    sWTD.dwUIChoice             = WTD_UI_NONE;
    sWTD.pPolicyCallbackData    = (LPVOID)&polHttps;
    sWTD.dwUnionChoice          = WTD_CHOICE_CERT;
    sWTD.pCert                  = &sWTCI;
    sWTD.pwszURLReference       = NULL;
    if (GlobalEnableRevocation && !(dwCertFlags & DLG_FLAGS_SEC_CERT_REV_FAILED))
        sWTD.fdwRevocationChecks = WTD_REVOKE_WHOLECHAIN;


    memset(&sWTCI, 0x00, sizeof(WINTRUST_CERT_INFO));
    sWTCI.cbStruct              = sizeof(WINTRUST_CERT_INFO);
    sWTCI.psCertContext         = (CERT_CONTEXT *)ciCert.pCertificate;
    sWTCI.chStores              = 1;
    sWTCI.pahStores  = (HCERTSTORE *)&ciCert.pCertificate->hCertStore;


    memset(&polHttps, 0x00, sizeof(HTTPSPolicyCallbackData));
    polHttps.cbStruct =  sizeof(HTTPSPolicyCallbackData);
    polHttps.dwAuthType = AUTHTYPE_SERVER;

    // Check for everything if looping.
    // 
    // This only incurs a perf hit in cases where ignore flags are set.
    // The sacrifice is made so the UI won't lie since the pass/fail
    // status in the UI is grouped.
    polHttps.fdwChecks = (m_dwErrorFlags &
                          INTERNET_ERROR_MASK_COMBINED_SEC_CERT) ?
                                 dwFlags : dwCertFlags;
    
    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, NULL, 0);

    polHttps.pwszServerName = new WCHAR[cbServerName+1];

    if(polHttps.pwszServerName == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    sWTCI.pcwszDisplayName      = polHttps.pwszServerName;

    cbServerName = MultiByteToWideChar(CP_ACP, 0, m_lpszHostName, -1, polHttps.pwszServerName, cbServerName);

    error = LoadWinTrust();
    if(ERROR_SUCCESS == error)
    {
        error = WinVerifySecureChannel(NULL, &sWTD);
    }

    error = MapInternetError(error);


    // Handle revocation problem as special case
    if (ERROR_INTERNET_SEC_CERT_REV_FAILED == error)
        dwFlags |= DLG_FLAGS_SEC_CERT_REV_FAILED;

    // Revocation failed is separate, so it should be ignored.
    // Revoked will kill the request altogether.
    if (!(dwCertFlags & ~DLG_FLAGS_SEC_CERT_REV_FAILED))
    {
        // We're going to loop through all errors
        // (doesn't count revocation)
        m_pSecurityInfo->SetFullyValidated(TRUE);
    }

    //
    // If there was problem with the certificate and the caller requested
    // combined SSL errors cycle through all possible certificate errors.
    //

    if (ERROR_SUCCESS != error &&
        (m_dwErrorFlags & INTERNET_ERROR_MASK_COMBINED_SEC_CERT) &&
        m_pSecurityInfo)
    {
        BOOL  fCertError = FALSE;
 
        dwCertFlags = m_pSecurityInfo->GetSecureFlags();
        do
        {
            if (ERROR_INTERNET_INVALID_CA == error)
            {
                polHttps.fdwChecks |=  DLG_FLAGS_IGNORE_INVALID_CA;
                dwFlags |= DLG_FLAGS_INVALID_CA;
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_UNKNOWN_CA))
                    fCertError = TRUE;
            }
            else if (ERROR_INTERNET_SEC_CERT_CN_INVALID == error)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_CN_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_CN_INVALID;
                if (GlobalWarnOnBadCertRecving &&
                      !(dwCertFlags & SECURITY_FLAG_IGNORE_CERT_CN_INVALID))
                    fCertError = TRUE;
            }
            else if (ERROR_INTERNET_SEC_CERT_DATE_INVALID == error)
            {
                polHttps.fdwChecks |= DLG_FLAGS_IGNORE_CERT_DATE_INVALID;
                dwFlags |= DLG_FLAGS_SEC_CERT_DATE_INVALID;
                if (!(dwCertFlags & SECURITY_FLAG_IGNORE_CERT_DATE_INVALID))
                    fCertError = TRUE;
            }
            else if (ERROR_INTERNET_SEC_CERT_REVOKED == error)
            {
                // During this loop revoked comes after the untrusted
                // root error.  Clean up and break out with the revoked
                // error since it should take precedence.
                fCertError = FALSE;
                dwFlags = 0;
                break;
            }
            else if (ERROR_INTERNET_SEC_CERT_REV_FAILED == error)
            {
                // Break out and give precedence for rev failed cases, too.
                dwFlags = DLG_FLAGS_SEC_CERT_REV_FAILED;
                fCertError = FALSE;
                break;
            }
            else
            {
                //
                // Pass all other errors through.
                //

                break;
            }

            error = WinVerifySecureChannel(NULL, &sWTD);

            error = MapInternetError(error);

        } while (ERROR_SUCCESS != error);

        //
        // Change the error only if one of the known certifciate errors was
        // encountered.
        //

        if (fCertError)
        {
            error = ERROR_INTERNET_SEC_CERT_ERRORS;
            m_pSecurityInfo->SetSecureFlags(dwFlags);
        }
        else if (dwFlags & DLG_FLAGS_SEC_CERT_REV_FAILED)
        {
            INET_ASSERT(dwFlags==DLG_FLAGS_SEC_CERT_REV_FAILED);
            error = ERROR_INTERNET_SEC_CERT_REV_FAILED;
            m_pSecurityInfo->SetSecureFlags(DLG_FLAGS_SEC_CERT_REV_FAILED);
        }
    }

    delete [] polHttps.pwszServerName;

    if(ciCert.pCertificate)
    {
        CertFreeCertificateContext(ciCert.pCertificate);
    }

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    // Only cache if we weren't supposed to ignore any results.
    // For security reasons, it may be important next time.
    if(m_pSecurityInfo && (!m_pSecurityInfo->InCache()) &&
       m_pSecurityInfo->GetFullyValidated())
    {
        // Add it to the cache if it's not already there.
        /* SCLE ref */
        GlobalCertCache.Add(m_pSecurityInfo);

    }

quit:                                 
    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateSecConnection(
    IN DWORD dwFlags,
    OUT LPBOOL lpbAttemptReconnect
    )

/*++

Routine Description:

    This function establishes a secure channel with the server by
    performing the security handshake protocol.  It will walk
    the list of installed security packages until it finds a package
    that succeeds in the security handshake.  If one package fails
    it is up to the caller to re-call NegotiateSecConnection with
    a re-opened socket so another socket can attempt the connection.

Arguments:

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    lpbAttemptReconnect - on return, if this value is TRUE, the caller should call
                          this function again, and it will try another protocol.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateSecConnection",
                 "{%#x [%#x]} %#x, %#x [%B]",
                 this,
                 m_Socket,
                 dwFlags,
                 lpbAttemptReconnect,
                 *lpbAttemptReconnect
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureNegotiate(dwFlags,
                                                 lpbAttemptReconnect,
                                                 this
                                                 ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureNegotiate::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureNegotiate::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureNegotiate * stateMachine = (CFsm_SecureNegotiate *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->SecureNegotiate_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SecureNegotiate_Fsm(
    IN CFsm_SecureNegotiate * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SecureNegotiate_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureNegotiate & fsm = *Fsm;
    DWORD error = fsm.GetError();
    DWORD dwSSPIFlags = 0;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto send_continue;

        case FSM_STATE_3:
            goto negotiate_loop_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    *fsm.m_lpbAttemptReconnect = FALSE;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    if(GlobalSecureProtocols != GlobalSecureProtocolsCopy)
    {
        LOCK_SECURITY();
        //ReInit the credentials if our settings have changed.
        SecurityPkgInitialize();
        UNLOCK_SECURITY();
    }

    //
    // Pick the provider we're going to use.
    //

    while ((SecProviders[GetProviderIndex()].pszName != NULL)
           && ( !SecProviders[GetProviderIndex()].fEnabled
             || !(SecProviders[GetProviderIndex()].dwProtocolFlags & GlobalSecureProtocols) ) ) {

        //
        // Next provider
        //

        SetProviderIndex(GetProviderIndex() + 1);
    }

    if (SecProviders[GetProviderIndex()].pszName == NULL) {

        //
        // BUGBUG shouldn't we error out here?
        //

        SetProviderIndex(0);
        goto error_exit;
    }

    DWORD i;

    i = GetProviderIndex();

    DEBUG_PRINT(API,
                INFO,
                ("Starting handshake protocol with pkg %d - %s\n",
                i,
                SecProviders[i].pszName
                ));


    //
    // 1. initiate a client HELLO message and generate a token
    //

    fsm.m_OutBuffers[0].pvBuffer = NULL;
    fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;

    SECURITY_STATUS scRet;
    DWORD ContextAttr;
    TimeStamp tsExpiry;

    fsm.m_bDoingClientAuth = FALSE;

    // Resynchronize the certificate store to catch
    // recently installed certificates
    if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
        ReopenMyCertStore();
    if (g_hMyCertStore)
        CertControlStore(g_hMyCertStore, 0, CERT_STORE_CTRL_AUTO_RESYNC, NULL);

    //
    // We need a credential handle,
    //  if we're doing client do the magic to get a specialized
    //  one otherwise use the standard global one.
    //

    if ( IsCredClear(fsm.m_hCreds) )
    {
        fsm.m_hCreds = SecProviders[i].hCreds;

        if (GetCertContextArray())
        {
            if (GetCertContextArray()->GetSelectedCertContext())
            {
                error = CliAuthSelectCredential(
                            &m_hContext,
                            SecProviders[i].pszName,
                            GetCertContextArray(),
                            &fsm.m_hCreds);

                if (error != ERROR_SUCCESS) {
                    goto quit;
                }

                fsm.m_bDoingClientAuth = TRUE;
            }

            dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
        }
        else if (m_pSecurityInfo && m_pSecurityInfo->GetForceNewSession())
        {
            // Force new session to be negotiated because
            // the user flushed client auth certs for the session.
            // Clear the force flag after we enter the loop.
            dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;
        }
    }

    scRet = g_InitializeSecurityContext(&fsm.m_hCreds,
                                        NULL,
                                        (LPSTR)GetHostName(),
                                        ISC_REQ_SEQUENCE_DETECT
                                        | ISC_REQ_REPLAY_DETECT
                                        | ISC_REQ_CONFIDENTIALITY
                                        | ISC_REQ_ALLOCATE_MEMORY
                                        | dwSSPIFlags,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        NULL,       // default, don't do hack.
                                        0,
                                        &m_hContext,
                                        &fsm.m_OutBuffer, // address where output data go
                                        &ContextAttr,
                                        &tsExpiry
                                        );

    DEBUG_PRINT(API,
                INFO,
                ("1. InitializeSecurityContext returned %s [%x]. hContext = %#x:%#x\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet,
                m_hContext.dwUpper,
                m_hContext.dwLower
                ));

    if (scRet == SEC_E_INVALID_HANDLE) {
         SecProviders[i].fEnabled = FALSE;
    }
    if (scRet == SEC_E_INVALID_TOKEN) {
        error = ERROR_INTERNET_CANNOT_CONNECT;
    } else {

        //
        // Turn the error in to one we understand */
        //

        error = MapInternetError((DWORD)scRet);
    }
    if (scRet != SEC_I_CONTINUE_NEEDED) {
        goto error_exit;
    }

    DEBUG_PRINT(API,
                INFO,
                ("1. OutBuffer is <%x, %d, %x>\n",
                fsm.m_OutBuffers[0].pvBuffer,
                fsm.m_OutBuffers[0].cbBuffer,
                fsm.m_OutBuffers[0].BufferType
                ));

    if ((fsm.m_OutBuffers[0].cbBuffer != 0)
    && (fsm.m_OutBuffers[0].pvBuffer != NULL)) {

        //
        // Send response to server if there is one
        //

        fsm.SetFunctionState(FSM_STATE_2);
        error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                               fsm.m_OutBuffers[0].cbBuffer,
                               0
                               );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

send_continue:

        g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
        fsm.m_OutBuffers[0].pvBuffer = NULL;
        if (error != ERROR_SUCCESS) {

            //
            // We should deal with this better
            //

            goto error_exit;
        }
    }

    fsm.SetFunctionState(FSM_STATE_3);
    error = SSPINegotiateLoop(NULL, fsm.m_dwFlags, fsm.m_hCreds, TRUE, fsm.m_bDoingClientAuth);

    if (error == ERROR_IO_PENDING) {
        goto quit;
    }

negotiate_loop_continue:
error_exit:

    //
    // We're not actually deleting the handle, rather we're no longer keeping
    //  a reference to the Credential handle in our fsm after we hand it off
    //

    if ( fsm.m_bDoingClientAuth )
    {
        ClearCreds(fsm.m_hCreds);
        fsm.m_bDoingClientAuth = FALSE;
    }

    if (error == ERROR_INTERNET_CANNOT_CONNECT) {

        //
        // error was a CANNOT_CONNECT, so try the next protocol.
        //

        SetProviderIndex(GetProviderIndex() + 1);

        if (SecProviders[GetProviderIndex()].pszName == NULL) {
            SetProviderIndex(0);
            *fsm.m_lpbAttemptReconnect = FALSE;
        } else {
            *fsm.m_lpbAttemptReconnect = TRUE;
        }
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SSPINegotiateLoop(
    OUT DBLBUFFER * pdblbufBuffer,
    IN DWORD dwFlags,
    CredHandle hCreds,
    IN BOOL bDoInitialRead,
    IN BOOL bDoingClientAuth
    )

/*++

Routine Description:

    This function completes the handshakes needed to establish a
    security protocol.  The initial handshakes are either generated
    by NegotiateSecureConnection, when generating a new connection, or
    during a receive when a REDO request is received.

Arguments:

    pdblbufBuffer - an input buffer into which to put any Extra data left over
                    after the handshake.  This data is assumed to be application
                    data, and will be decrypted later.

    dwFlags    - Socket Flags that may need to be passed on to Socket Calls
                (needed to support Async I/O)

    bDoInitialRead - if TRUE, this function will do a read before calling
                     InitializeSecurityContext, otherwise, it passes in 0 bytes of data.

Return Value:

    ERROR_SUCCESS - we successfully completed our connection.
    ERROR_INTERNET_CANNOT_CONNECT - The connection was dropped on us, possibly because we used a bad
                                    protocol.  Try the next protocol.

    ERROR_*                       - Other internet error, disconnect.


Comments:

    BUGBUG (hack alert) [arthurbi]
    Do to a bug in IIS 1.0 Servers we cannot connect because
    we send a "Client SSL 3 Message".  This message confuses the
    server and causes it to close the socket.  The fix is to
    reopen the socket and send a "Client SSL 2 Message."  Newer
    versions of the server will be fixed.


--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SSPINegotiateLoop",
                 "{%#x [%#x]} %#x, %#x, %B",
                 this,
                 m_Socket,
                 pdblbufBuffer,
                 dwFlags,
                 bDoInitialRead
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_NegotiateLoop(pdblbufBuffer,
                                               dwFlags,
                                               bDoInitialRead,
                                               bDoingClientAuth,
                                               hCreds,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_NegotiateLoop::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_NegotiateLoop::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_NegotiateLoop * stateMachine = (CFsm_NegotiateLoop *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->NegotiateLoop_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::NegotiateLoop_Fsm(
    IN CFsm_NegotiateLoop * Fsm
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::NegotiateLoop_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_NegotiateLoop & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto receive_continue;

        case FSM_STATE_3:
            goto send_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    INET_ASSERT(IsOpen());

    fsm.m_dwProviderIndex = GetProviderIndex();

    fsm.m_dwSSPIFlags = ISC_REQ_SEQUENCE_DETECT
                      | ISC_REQ_REPLAY_DETECT
                      | ISC_REQ_CONFIDENTIALITY
                      | ISC_REQ_ALLOCATE_MEMORY
                      | ISC_RET_EXTENDED_ERROR;

    //
    // set OutBuffer for InitializeSecurityContext call
    //

    fsm.m_OutBuffer.cBuffers = 1;
    fsm.m_OutBuffer.pBuffers = fsm.m_OutBuffers;
    fsm.m_OutBuffer.ulVersion = SECBUFFER_VERSION;

    //
    // If we have a selected cert chain, then try to
    // generate a credential from that list.
    //

    if (IsCredClear(fsm.m_hCreds))
    {
        fsm.m_hCreds = SecProviders[fsm.m_dwProviderIndex].hCreds;

        if ( GetCertContextArray() &&
             GetCertContextArray()->GetSelectedCertContext() )
        {
            error = CliAuthSelectCredential(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        GetCertContextArray(),
                        &fsm.m_hCreds);

            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            fsm.m_bDoingClientAuth = TRUE;
        }
        else if (m_pSecurityInfo && m_pSecurityInfo->GetForceNewSession())
        {
            // Force new session to be negotiated because
            // the user flushed client auth certs for the session.
            fsm.m_dwSSPIFlags |= ISC_REQ_USE_SESSION_KEY;
            m_pSecurityInfo->SetForceNewSession(FALSE);
        }
    }

    if (fsm.m_bDoingClientAuth ||
        GetCertContextArray() )
    {
        fsm.m_dwSSPIFlags |= ISC_REQ_USE_SUPPLIED_CREDS;
    }

    fsm.m_scRet = SEC_I_CONTINUE_NEEDED;

    while (fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
           fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE ||
           fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

        //
        //  send to target server
        //  if we've got a SEC_E_INCOMPLETE_MESSAGE we need to do a read
        //  again because we didn't get the entire message we expected from
        //  the server.
        //


        //
        //  receive response from server and pass token into security pkg
        //    BUT only if we haven't already received extra data
        //    from SSPI which we need to process in lu of actual data
        //    data from WinSock, and if the package has not returned
        //    one of the defined warnings that indicates that we should
        //    pass the previous buffer again.
        //


        // Make sure fsm.m_lpszBuffer holds the input data to be passed
        // to initialize security context.  There are 4 cases:
        // 1) We have Extra Data, so we don't need to do a socket receive
        // 2) We were called during a re-negotiate, so if this is the first
        //    time through the loop, we have 0 bytes.
        // 3) We are recovering from a SEC_I_INCOMPLETE_CREDENTIALS, so
        //    use the same buffer again.
        // 4) We do a SocketReceive
        // We'll indicate 1 and 3 by having the fsm.m_dwBytesReceived count being the number of bytes
        // left in the buffer to be re-sent or sent to the sspi call.
        // If bytes-received is zero, then either we are doing a Redo, or we need to receive
        // data.  fsm.m_bDoRead let's us know if for some reason we should do or not do this read



        if ((0 == fsm.m_dwBytesReceived) || (fsm.m_scRet == SEC_E_INCOMPLETE_MESSAGE)) {
            if (fsm.m_bDoRead) {
                fsm.SetFunctionState(FSM_STATE_2);
                error = ICSocket::Receive((LPVOID *)&fsm.m_lpszBuffer,
                                          &fsm.m_dwBufferLength,
                                          &fsm.m_dwBufferLeft,
                                          &fsm.m_dwBytesReceived,
                                          0,
                                          SF_EXPAND,
                                          &fsm.m_bEofReceive
                                          );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

receive_continue:

                if ((error != ERROR_SUCCESS) || fsm.m_bEofReceive) {

                    DEBUG_PRINT(API,
                                ERROR,
                                ("SocketReceive failed\n"
                                ));

                    if (error == ERROR_SUCCESS) {
                        error = ERROR_INTERNET_CANNOT_CONNECT;
                    }
                    break;
                }
            } else {
                fsm.m_bDoRead = TRUE;
            }
        }

        if (fsm.m_scRet == SEC_I_INCOMPLETE_CREDENTIALS) {

            CERT_CONTEXT_ARRAY* pCertContextArray;

            //
            // If've already done Client Auth, and it fails again
            //  then we fail.
            //

            if (fsm.m_bDoingClientAuth) {
                error = ERROR_CANCELLED;
                goto quit;
            }

            //
            // If we don't already have a cert chain list,
            // then get one, and make our selection
            //

            INET_ASSERT(!GetCertContextArray());

            pCertContextArray = NULL;

            //delete pCertChainList;
            //SetCertChainList(NULL);

            error = CliAuthAcquireCertContexts(
                        &m_hContext,
                        SecProviders[fsm.m_dwProviderIndex].pszName,
                        &pCertContextArray
                        );

            SetCertContextArray(pCertContextArray);

            if (error == ERROR_SUCCESS) {
                error = ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED;
            }

            fsm.m_scRet = error;
            break;
        }

        //
        // InBuffers[1] is for getting extra data that
        //  SSPI/SCHANNEL doesn't proccess on this
        //  run around the loop.
        //

        fsm.m_InBuffers[0].pvBuffer   = fsm.m_lpszBuffer;
        fsm.m_InBuffers[0].cbBuffer   = fsm.m_dwBytesReceived;
        fsm.m_InBuffers[0].BufferType = SECBUFFER_TOKEN;

        fsm.m_InBuffers[1].pvBuffer   = NULL;
        fsm.m_InBuffers[1].cbBuffer   = 0;
        fsm.m_InBuffers[1].BufferType = SECBUFFER_EMPTY;

        //
        // Initialize these so if we fail, pvBuffer contains NULL,
        // so we don't try to free random garbage at the quit
        //

        fsm.m_OutBuffers[0].pvBuffer   = NULL;
        fsm.m_OutBuffers[0].BufferType = SECBUFFER_TOKEN;
        fsm.m_OutBuffers[0].cbBuffer   = 0;

        SecBufferDesc InBuffer;

        InBuffer.cBuffers        = 2;
        InBuffer.pBuffers        = fsm.m_InBuffers;
        InBuffer.ulVersion       = SECBUFFER_VERSION;

        DWORD ContextAttr;
        TimeStamp tsExpiry;

        fsm.m_scRet = g_InitializeSecurityContext(&fsm.m_hCreds,
                                                  &m_hContext,
                                                  NULL,
                                                  fsm.m_dwSSPIFlags,
                                                  0,
                                                  SECURITY_NATIVE_DREP,
                                                  &InBuffer,
                                                  0,
                                                  NULL,
                                                  &fsm.m_OutBuffer,
                                                  &ContextAttr,
                                                  &tsExpiry
                                                  );

        DEBUG_PRINT(API,
                    INFO,
                    ("3. InitializeSecurityContext returned %s [%x]\n",
                    InternetMapSSPIError((DWORD)fsm.m_scRet),
                    fsm.m_scRet
                    ));

        if (fsm.m_scRet == STATUS_SUCCESS ||
             fsm.m_scRet == SEC_I_CONTINUE_NEEDED ||
             (FAILED(fsm.m_scRet) && (0 != (ContextAttr & ISC_RET_EXTENDED_ERROR))))
        {
            if  (fsm.m_OutBuffers[0].cbBuffer != 0    &&
                 fsm.m_OutBuffers[0].pvBuffer != NULL )
            {

                //
                // Send response to server if there is one
                //

                fsm.SetFunctionState(FSM_STATE_3);
                error = ICSocket::Send(fsm.m_OutBuffers[0].pvBuffer,
                                       fsm.m_OutBuffers[0].cbBuffer,
                                       0
                                       );
                if (error == ERROR_IO_PENDING) {
                    goto done;
                }

send_continue:

                g_FreeContextBuffer(fsm.m_OutBuffers[0].pvBuffer);
                fsm.m_OutBuffers[0].pvBuffer = NULL;
            }
        }


        if ( fsm.m_scRet == STATUS_SUCCESS )
        {
            DEBUG_PRINT(API,
                     INFO,
                    ("NegotiateSecConnection succeeded.\n"));


            if (fsm.m_pdblbufBuffer)
            {
                if ( fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA )
                {

                    fsm.m_pdblbufBuffer->CopyIn(
                        (LPBYTE) (fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer)),
                        fsm.m_InBuffers[1].cbBuffer
                        );

                }
                else
                {
                    fsm.m_pdblbufBuffer->SetInputBufferSize(0);
                }
            }



            //
            // Bail out to quit
            //

            break;
        }
        else if (FAILED(fsm.m_scRet) && (fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE))
        {

             //
             //  free security context handle and delete the local
             //  data structures associated with the handle and
             //  try another pkg if available
             //

             DEBUG_PRINT(API,
                         INFO,
                         ("3. InitializeSecurityContext failed, %lx\n",
                         fsm.m_scRet
                         ));


             // Turn the error in to one we understand */
             error = MapInternetError((DWORD)fsm.m_scRet);

             TerminateSecConnection();
             /* Break out to try next protocol */
             break;
        }

        if ((fsm.m_scRet != SEC_E_INCOMPLETE_MESSAGE)
        && (fsm.m_scRet != SEC_I_INCOMPLETE_CREDENTIALS)) {

            DEBUG_PRINT(API,
                        INFO,
                        ("3. OutBuffer is <%x, %d, %x>\n",
                        fsm.m_OutBuffers[0].pvBuffer,
                        fsm.m_OutBuffers[0].cbBuffer,
                        fsm.m_OutBuffers[0].BufferType
                        ));

            if (fsm.m_InBuffers[1].BufferType == SECBUFFER_EXTRA) {

                //
                // skip next recv and set up buffers
                //  so InitalizeSecurityContext pulls its
                //  info from the Extra it returned previously.
                //

                DEBUG_PRINT(API,
                         INFO,
                         ("Got SECBUFFER_EXTRA, moving %d bytes to front of buffer\n",
                         fsm.m_InBuffers[1].cbBuffer
                         ));

                INET_ASSERT(fsm.m_InBuffers[1].cbBuffer > 0);

                MoveMemory(
                        fsm.m_lpszBuffer,             // dest
                        fsm.m_lpszBuffer + (fsm.m_dwBytesReceived - fsm.m_InBuffers[1].cbBuffer),
                        fsm.m_InBuffers[1].cbBuffer   // size
                        );

                fsm.m_dwBytesReceived = fsm.m_InBuffers[1].cbBuffer;
                fsm.m_dwBufferLeft   = fsm.m_dwBufferLength - fsm.m_dwBytesReceived;
            } else {

                //
                // prepare for next receive
                //

                fsm.m_dwBufferLeft = fsm.m_dwBufferLength;
                fsm.m_dwBytesReceived = 0;
            }
        }
    }

quit:

    if (fsm.m_lpszBuffer != NULL) {
         fsm.m_lpszBuffer = (LPSTR)FREE_MEMORY(fsm.m_lpszBuffer);
         INET_ASSERT(fsm.m_lpszBuffer == NULL);
    }

done:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Disconnect(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Undoes the work of ConnectSocket - i.e. closes a connected socket. We make
    callbacks to inform the app that this socket is being closed

Arguments:

    dwFlags - controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - WSA error

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Disconnect",
                 "{%#x} %#x",
                 m_Socket,
                 dwFlags
                 ));

    INET_ASSERT(IsSecure());

    DWORD error = ICSocket::Disconnect(dwFlags);

    //
    // delete security context handle for the connection
    //

    if ((m_dwFlags & (SF_ENCRYPT | SF_DECRYPT))
    && dwEncFlags != ENC_CAPS_NOT_INSTALLED) {
        TerminateSecConnection();
    }

    //
    // Zero out the pending input buffer
    //

    if (m_pdblbufBuffer != NULL) {
        m_pdblbufBuffer->SetInputBufferSize(0);
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send(
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sends data over a secure connection

Arguments:

    lpBuffer        - pointer to user data to send

    dwBufferLength  - length of user data

    dwFlags         - flags controlling operation

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send",
                 "{%#x [%#x]} %#x, %d, %#x",
                 this,
                 m_Socket,
                 lpBuffer,
                 dwBufferLength,
                 dwFlags
                 ));

    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT((int)dwBufferLength > 0);
    INET_ASSERT(IsSecure());

    DWORD error = DoFsm(new CFsm_SecureSend(lpBuffer,
                                            dwBufferLength,
                                            dwFlags,
                                            this
                                            ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureSend::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureSend::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureSend * stateMachine = (CFsm_SecureSend *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Send_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Send_Fsm(
    IN CFsm_SecureSend * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Send_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_SecureSend & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (fsm.GetState() == FSM_STATE_INIT) {

        //
        // Log The Data BEFORE we Encrypt It ( if we do )
        //

        DEBUG_DUMP_API(SOCKETS,
                       "sending data:\n",
                       fsm.m_lpBuffer,
                       fsm.m_dwBufferLength
                       );

    }

    while (((int)fsm.m_dwBufferLength > 0) && (error == ERROR_SUCCESS)) {

        LPVOID lpBuffer;
        DWORD dwLength;
        DWORD dwBytes;

        if (m_dwFlags & SF_ENCRYPT) {

            DWORD dwBytesEncrypted;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Encrypting data..\n"
                        ));

            error = EncryptData(fsm.m_lpBuffer,
                                fsm.m_dwBufferLength,
                                &fsm.m_lpCryptBuffer,
                                &fsm.m_dwCryptBufferLength,
                                &dwBytesEncrypted
                                );
            if (error != ERROR_SUCCESS) {
                break;
            }

            INET_ASSERT(fsm.m_lpCryptBuffer != NULL);
            INET_ASSERT((int)fsm.m_dwCryptBufferLength > 0);
            INET_ASSERT(dwBytesEncrypted <= fsm.m_dwBufferLength);

            lpBuffer = fsm.m_lpCryptBuffer;
            dwLength = fsm.m_dwCryptBufferLength;
            dwBytes = dwBytesEncrypted;
        } else {
            lpBuffer = fsm.m_lpBuffer;
            dwLength = fsm.m_dwBufferLength;
            dwBytes = dwLength;
        }

        fsm.m_lpBuffer = (LPVOID)((LPBYTE)fsm.m_lpBuffer + dwBytes);
        fsm.m_dwBufferLength -= dwBytes;

        error = ICSocket::Send(lpBuffer, dwLength, fsm.m_dwFlags);
        if (error != ERROR_SUCCESS) {
            break;
        }
    }

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        //
        // Free Encryption Buffer if doing SSL/PCT
        //

        if (fsm.m_lpCryptBuffer != NULL ) {
            fsm.m_lpCryptBuffer = (LPVOID)FREE_MEMORY(fsm.m_lpCryptBuffer);
            INET_ASSERT(fsm.m_lpCryptBuffer == NULL);
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive(
    IN OUT LPVOID* lplpBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwBufferRemaining,
    IN OUT LPDWORD lpdwBytesReceived,
    IN DWORD dwExtraSpace,
    IN DWORD dwFlags,
    OUT LPBOOL lpbEof
    )

/*++

Routine Description:

    Receives and decrypts data from a secure connection

Arguments:

    lplpBuffer          - see ICSocket::Receive
    lpdwBufferLength    -
    lpdwBufferRemaining -
    lpdwBytesReceived   -
    dwExtraSpace        -
    dwFlags             -
    lpbEof              -

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwBufferLength != NULL);
    INET_ASSERT((*lpdwBufferLength == 0) ? (dwFlags & SF_EXPAND) : TRUE);
    INET_ASSERT(IsSecure());

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive",
                 "%#x [%#x], %#x [%d], %#x [%d], %#x [%d], %d, %#x, %#x [%B]",
                 lplpBuffer,
                 *lplpBuffer,
                 lpdwBufferLength,
                 *lpdwBufferLength,
                 lpdwBufferRemaining,
                 *lpdwBufferRemaining,
                 lpdwBytesReceived,
                 *lpdwBytesReceived,
                 dwExtraSpace,
                 dwFlags,
                 lpbEof,
                 *lpbEof
                 ));

    DWORD error = DoFsm(new CFsm_SecureReceive(lplpBuffer,
                                               lpdwBufferLength,
                                               lpdwBufferRemaining,
                                               lpdwBytesReceived,
                                               dwExtraSpace,
                                               dwFlags,
                                               lpbEof,
                                               this
                                               ));

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_SecureReceive::RunSM(
    IN CFsm * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CFsm_SecureReceive::RunSM",
                 "%#x",
                 Fsm
                 ));

    ICSecureSocket * pSecureSocket = (ICSecureSocket *)Fsm->GetContext();
    CFsm_SecureReceive * stateMachine = (CFsm_SecureReceive *)Fsm;
    DWORD error;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = pSecureSocket->Receive_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::Receive_Fsm(
    IN CFsm_SecureReceive * Fsm
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    Fsm -

Return Value:

    DWORD

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::Receive_Fsm",
                 "%#x",
                 Fsm
                 ));

    //INET_ASSERT(m_dwFlags & SF_DECRYPT);

    CFsm_SecureReceive & fsm = *Fsm;
    DWORD error = fsm.GetError();
    LPVOID * lplpBuffer;
    LPDWORD lpdwBufferLength;
    LPDWORD lpdwBufferLeft;
    LPDWORD lpdwBytesReceived;

    if (fsm.GetState() != FSM_STATE_INIT) {
        switch (fsm.GetFunctionState()) {
        case FSM_STATE_2:
            goto negotiate_continue;

        case FSM_STATE_3:
            goto receive_continue;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;

            INET_ASSERT(FALSE);

            goto quit;
        }
    }

    //
    // if we weren't given a buffer, but the caller told us its okay to resize
    // then we allocate the initial buffer
    //

    if ((fsm.m_dwBufferLength == 0) || (fsm.m_dwBufferLeft == 0)) {

        INET_ASSERT((fsm.m_dwBufferLength == 0) ? (fsm.m_dwBufferLeft == 0) : TRUE);

        if (fsm.m_dwFlags & SF_EXPAND) {

            //
            // allocate a fixed memory buffer
            //

            //
            // BUGBUG - the initial buffer size should come from the handle
            //          object
            //

            fsm.m_dwBufferLeft = DEFAULT_RECEIVE_BUFFER_INCREMENT;
            if (fsm.m_dwBufferLength == 0) {
                fsm.m_bAllocated = TRUE;
            }
            fsm.m_dwBufferLength += fsm.m_dwBufferLeft;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("resizing %#x to %d\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);
            if (fsm.m_hBuffer == (HLOCAL)NULL) {
                error = GetLastError();

                INET_ASSERT(error != ERROR_SUCCESS);

                fsm.m_bAllocated = FALSE;
            }
        } else {

            //
            // the caller didn't say its okay to resize
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else if (fsm.m_hBuffer == (HLOCAL)NULL) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // keep the app informed (if requested to do so)
    //

    if (fsm.m_dwFlags & SF_INDICATE) {
        InternetIndicateStatus(INTERNET_STATUS_RECEIVING_RESPONSE,
                               NULL,
                               0
                               );
    }

    fsm.m_dwReadFlags = fsm.m_dwFlags;

    //
    // Loop Through our Reads, assembling enough unencrypted bytes
    //  to return back to the client.  In the non-SSL/PCT case, we should
    //  be able to quit after one iteration.
    //

    do {

        LPVOID * lplpReadBuffer;
        LPDWORD lpdwReadBufferLength;
        LPDWORD lpdwReadBufferLeft;
        LPDWORD lpdwReadBufferReceived;

        //
        // If we're attempting to read SSL/PCT data, we need examine, whether
        // we have all the bytes decrypted and read already in our scratch buffer.
        //

        if (m_dwFlags & SF_DECRYPT) {

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("Decrypting data..\n"
                        ));

            if (m_pdblbufBuffer != NULL) {

                DEBUG_DUMP_API(SOCKETS,
                               "About to decrypt this data:\n",
                               (LPBYTE)m_pdblbufBuffer->GetInputBufferPointer(),
                               m_pdblbufBuffer->GetInputBufferSize()
                               );

            }

            fsm.m_dwDecryptError = DecryptData(&fsm.m_dwInputBytesLeft,
                                               (LPBYTE)fsm.m_hBuffer,
                                               &fsm.m_dwBufferLeft,
                                               &fsm.m_dwBytesReceived,
                                               &fsm.m_dwBytesRead
                                               );

            if (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE &&
                fsm.m_bEof &&
                m_pdblbufBuffer->GetInputBufferSize() > 0) {

                error = ERROR_HTTP_INVALID_SERVER_RESPONSE;
                goto error_exit;

            }
            else if (fsm.m_dwDecryptError == SEC_I_RENEGOTIATE) {

                CredHandle hDummyCreds;

                //
                // BUGBUG - don't have to do this - Receive() called from
                //          SSPINegotiateLoop() won't come back through here
                //

                m_dwFlags &= ~(SF_ENCRYPT | SF_DECRYPT);
                ClearCreds(hDummyCreds);

                fsm.SetFunctionState(FSM_STATE_2);
                error = SSPINegotiateLoop(m_pdblbufBuffer,
                                          fsm.m_dwFlags,
                                          hDummyCreds,
                                          FALSE,
                                          FALSE);
                if (error == ERROR_IO_PENDING) {
                    goto error_exit;
                }

negotiate_continue:

                m_dwFlags |= (SF_ENCRYPT | SF_DECRYPT);

                if (error != ERROR_SUCCESS) {
                    break;
                }

                fsm.m_dwDecryptError = (ULONG)SEC_E_INCOMPLETE_MESSAGE;

                //
                // If there was extra data, and it was shoved back into
                // dblbuffer, then we should redo the decryption, since
                // it now has extra input data to process.
                //

                if (m_pdblbufBuffer->GetInputBufferSize() > 0) {
                    continue;
                }

                //
                // Okay, here we've received 0 bytes, so so we have to
                // receive more data, and process it.  Do this by zero-ing
                // out the input buffer, and setting the decrypt_error to be
                // Incomplete.
                //

            }

            //
            // If we have no buffer left to fill, or the caller ask for a single recv
            // and we've managed to read something into the buffer, then return by breaking.
            //

            if ((fsm.m_dwBufferLeft == 0)
            || (!(fsm.m_dwFlags & SF_RECEIVE_ALL) && (fsm.m_dwBytesRead > 0))) {
                break;  // we're done.
            }

            INET_ASSERT(error == ERROR_SUCCESS);

            //
            // BUGBUG [arthurbi] GetInputBufferSize needs to be called before getting
            //   the pointer, because the pointer may be moved around while generating
            //   the size.
            //

            DWORD remaining;
            DWORD inputSize;

            inputSize = m_pdblbufBuffer->GetInputBufferSize();
            remaining = m_pdblbufBuffer->GetInputBufferRemaining();
            fsm.m_dwBufferLengthDummy = inputSize + remaining;
            fsm.m_dwBufferLeftDummy = remaining;
            fsm.m_dwBufferReceivedDummy = inputSize;
            fsm.m_lpBufferDummy = m_pdblbufBuffer->GetInputBufferPointer();

            //
            // We need to be careful, and only recv one block of data at a time
            // if we're not we break keep-alive by doing too many reads.
            //
            // So unless we know ( by the non-0 return ) exactly how many bytes
            // to read, we shut off SF_RECEIVE_ALL.
            //

            fsm.m_dwReadFlags &= ~(SF_RECEIVE_ALL
                                   | SF_INDICATE
                                   | SF_EXPAND
                                   | SF_COMPRESS
                                   );

            if (fsm.m_dwInputBytesLeft != 0) {

                //
                // don't add RECEIVE_ALL if NO_WAIT already set by caller - they
                // are mutually exclusive
                //

                if (!(fsm.m_dwReadFlags & SF_NO_WAIT)) {
                    fsm.m_dwReadFlags |= SF_RECEIVE_ALL;
                }
                fsm.m_dwBufferLeftDummy = min(fsm.m_dwInputBytesLeft,
                                              fsm.m_dwBufferLeftDummy);
            }
            lplpReadBuffer = (LPVOID *)&fsm.m_lpBufferDummy;
            lpdwReadBufferLength = &fsm.m_dwBufferLengthDummy;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeftDummy;
            lpdwReadBufferReceived = &fsm.m_dwBufferReceivedDummy;
        } else {
            lplpReadBuffer = &fsm.m_hBuffer;
            lpdwReadBufferLength = &fsm.m_dwBufferLength;
            lpdwReadBufferLeft = &fsm.m_dwBufferLeft;
            lpdwReadBufferReceived = &fsm.m_dwBytesReceived;
        }

        //
        // receive some data, assuming the socket is not closed.
        //

        if (!fsm.m_bEof) {
            //fsm.m_dwBytesReceivedPre = *lpdwReadBufferReceived;
            fsm.SetFunctionState(FSM_STATE_3);
            error = ICSocket::Receive(lplpReadBuffer,
                                      lpdwReadBufferLength,
                                      lpdwReadBufferLeft,
                                      lpdwReadBufferReceived,
                                      fsm.m_dwExtraSpace,
                                      fsm.m_dwReadFlags,
                                      &fsm.m_bEof
                                      );
            if (error == ERROR_IO_PENDING) {
                goto error_exit;
            }

receive_continue:

            //fsm.m_dwBytesRead += fsm.m_dwByReceived - fsm.m_dwDCBufferRecvPre;
            if (error != ERROR_SUCCESS) {
                goto quit;
            }

            //
            // Once again, for SSL/PCT we need to update our input buffer after the read.
            //

            if (m_dwFlags & SF_DECRYPT) {
                m_pdblbufBuffer->SetInputBufferSize(fsm.m_dwBufferReceivedDummy);
            }
        }
    } while ((m_dwFlags & SF_DECRYPT)
             && (error == ERROR_SUCCESS)
             && (fsm.m_dwDecryptError == SEC_E_INCOMPLETE_MESSAGE)
             && (!fsm.m_bEof || (m_pdblbufBuffer->GetInputBufferSize() > 0)));

    if (error == ERROR_SUCCESS) {

        //
        // inform the app that we finished, and tell it how much we received
        // this time
        //

        if (fsm.m_dwFlags & SF_INDICATE) {
            InternetIndicateStatus(INTERNET_STATUS_RESPONSE_RECEIVED,
                                   &fsm.m_dwBytesRead,
                                   sizeof(fsm.m_dwBytesRead)
                                   );
        }

        //
        // if we received the entire response and the caller specified
        // SF_COMPRESS then we shrink the buffer to fit. We may end up growing
        // the buffer to contain dwExtraSpace if it is not zero and we just
        // happened to fill the current buffer
        //

        if (fsm.m_bEof && (fsm.m_dwFlags & SF_COMPRESS)) {

            fsm.m_dwBufferLeft = fsm.m_dwExtraSpace;

            //
            // include any extra that the caller required
            //

            fsm.m_dwBufferLength = fsm.m_dwBytesReceived + fsm.m_dwExtraSpace;

            DEBUG_PRINT(SOCKETS,
                        INFO,
                        ("shrinking buffer %#x to %d (%#x) bytes (includes %d extra)\n",
                        fsm.m_hBuffer,
                        fsm.m_dwBufferLength,
                        fsm.m_dwBufferLength,
                        fsm.m_dwExtraSpace
                        ));

            fsm.m_hBuffer = ResizeBuffer(fsm.m_hBuffer,
                                         fsm.m_dwBufferLength,
                                         FALSE);

            INET_ASSERT((fsm.m_hBuffer == NULL)
                        ? ((fsm.m_dwBytesReceived + fsm.m_dwExtraSpace) == 0)
                        : TRUE
                        );

        }

        DEBUG_PRINT_API(SOCKETS,
                        INFO,
                        ("read %d bytes @ %#x from socket %#x\n",
                        fsm.m_dwBytesRead,
                        (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                        m_Socket
                        ));

        DEBUG_DUMP_API(SOCKETS,
                       "received data:\n",
                       (LPBYTE)fsm.m_hBuffer + *fsm.m_lpdwBytesReceived,
                       fsm.m_dwBytesRead
                       );

    }

quit:

    //
    // if we failed but allocated a buffer then we need to free it (we were
    // leaking this buffer if the request was cancelled)
    //

    if ((error != ERROR_SUCCESS) && fsm.m_bAllocated && (fsm.m_hBuffer != NULL)) {
//dprintf("SocketReceive() freeing allocated buffer %#x\n", hBuffer);
        fsm.m_hBuffer = (HLOCAL)FREE_MEMORY(fsm.m_hBuffer);

        INET_ASSERT(fsm.m_hBuffer == NULL);

        fsm.m_dwBufferLength = 0;
        fsm.m_dwBufferLeft = 0;
        fsm.m_dwBytesReceived = 0;
        fsm.m_bEof = TRUE;
    }

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("returning: lpBuffer=%#x, bufferLength=%d, bufferLeft=%d, bytesReceived=%d\n",
                fsm.m_hBuffer,
                fsm.m_dwBufferLength,
                fsm.m_dwBufferLeft,
                fsm.m_dwBytesReceived
                ));

    //
    // update output parameters
    //

    *fsm.m_lplpBuffer = (LPVOID)fsm.m_hBuffer;
    *fsm.m_lpdwBufferLength = fsm.m_dwBufferLength;
    *fsm.m_lpdwBufferRemaining = fsm.m_dwBufferLeft;
    *fsm.m_lpdwBytesReceived = fsm.m_dwBytesReceived;

    //
    // Hack, we hide eof's from caller, since we may have buffered data sitting around
    //

    if ((m_dwFlags & SF_DECRYPT) && (fsm.m_dwBytesRead != 0)) {
        fsm.m_bEof = FALSE;
    }

    *fsm.m_lpbEof = fsm.m_bEof;

    //
    // map any sockets error to WinInet error
    //

    if (error != ERROR_SUCCESS) {
        error = MapInternetError(error);
    }

error_exit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ICSecureSocket::SetHostName(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    Set name of server we are connected to. Find or create a security cache
    entry for this name

Arguments:

    lpszHostName    - name to set

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::SetHostName",
                 "{%#x [%q %#x/%d]} %q",
                 this,
                 m_lpszHostName,
                 GetSocket(),
                 GetSourcePort(),
                 lpszHostName
                 ));

    INET_ASSERT(IsSecure());
    INET_ASSERT((lpszHostName != NULL) || (m_lpszHostName == NULL));

    DWORD error = ERROR_SUCCESS;

    if (lpszHostName != NULL) {
        if (m_lpszHostName != NULL) {
            m_lpszHostName = (LPSTR)FREE_MEMORY(m_lpszHostName);

            INET_ASSERT(m_lpszHostName == NULL);

        }
        m_lpszHostName = NewString(lpszHostName);
        if (m_lpszHostName == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
        } else if (m_pSecurityInfo == NULL) {
            /* SCLE ref */
            m_pSecurityInfo = GlobalCertCache.Find(lpszHostName);
            if (m_pSecurityInfo == NULL) {
                /* SCLE ref */
                m_pSecurityInfo = new SECURITY_CACHE_LIST_ENTRY(lpszHostName);
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

//
// private ICSecureSocket methods
//


DWORD
ICSecureSocket::EncryptData(
    IN LPVOID lpBuffer,
    IN DWORD dwInBufferLen,
    OUT LPVOID * lplpBuffer,
    OUT LPDWORD lpdwOutBufferLen,
    OUT LPDWORD lpdwInBufferBytesEncrypted
    )

/*++

Routine Description:

    This function encrypts data in the lplpbuffer.

Arguments:

    lpBuffer         - pointer to buffer containing unencrypted user data

    dwInBufferLen    - length of input buffer

    lplpBuffer       - pointer to pointer to encrypted user buffer

    lpdwOutBufferLen - pointer to length of output lplpbuffer

    lpdwInBufferBytesEncrypted - pointer to length of bytes read and encrypted in output buffer

Return Value:

    Error Code

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::EncryptData",
                 "%#x, %d, %#x, %#x, %#x",
                 lpBuffer,
                 dwInBufferLen,
                 lplpBuffer,
                 lpdwOutBufferLen,
                 lpdwInBufferBytesEncrypted
                 ));

    SECURITY_STATUS scRet = STATUS_SUCCESS;
    SecBufferDesc Buffer;
    SecBuffer Buffers[3];
    HLOCAL hBuffer;
    DWORD error;
    DWORD dwMaxDataBufferSize;
    DWORD dwExtraInputBufferLen;
    SecPkgContext_StreamSizes Sizes;

    INET_ASSERT(IsSecure());
    INET_ASSERT(lpBuffer != NULL);
    INET_ASSERT(dwInBufferLen != 0);
    INET_ASSERT(lplpBuffer != NULL);
    INET_ASSERT(lpdwOutBufferLen != NULL);
    INET_ASSERT(lpdwInBufferBytesEncrypted != NULL);

    hBuffer = (HLOCAL) *lplpBuffer;
    *lpdwOutBufferLen = 0;
    *lpdwInBufferBytesEncrypted = 0;

    //INET_ASSERT(hBuffer == NULL );

    //
    //  find the header and trailer sizes
    //

    scRet = g_QueryContextAttributes(&m_hContext,
                                     SECPKG_ATTR_STREAM_SIZES,
                                     &Sizes );
    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned, %s [%x] (%s)\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet,
                    InternetMapError(scRet)
                    ));

        error = MapInternetError((DWORD) scRet);
        goto quit;
    } else {

        DEBUG_PRINT(API,
                    INFO,
                    ("QueryContextAttributes returned header=%d, trailer=%d, maxmessage=%d\n",
                    Sizes.cbHeader,
                    Sizes.cbTrailer,
                    Sizes.cbMaximumMessage
                    ));
    }

    INET_ASSERT(Sizes.cbMaximumMessage > (Sizes.cbHeader + Sizes.cbTrailer));

    //
    // Figure out the max SSL packet we can send over the wire.
    //  If the data is too big to send, then remeber how much
    //  we did send, and how much we didn't send.
    //

    dwMaxDataBufferSize = Sizes.cbMaximumMessage - (Sizes.cbHeader + Sizes.cbTrailer);

    dwExtraInputBufferLen =
            (dwMaxDataBufferSize < dwInBufferLen ) ?
                (dwInBufferLen - dwMaxDataBufferSize) : 0;

    dwInBufferLen =
            ( dwExtraInputBufferLen > 0 ) ?
            dwMaxDataBufferSize :
            dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("resizing %#x to %d\n",
                hBuffer,
                dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer
                ));

    hBuffer = ResizeBuffer(hBuffer,
                           dwInBufferLen + Sizes.cbHeader + Sizes.cbTrailer,
                           FALSE );

    if (hBuffer == (HLOCAL)NULL) {
        error = GetLastError();

        INET_ASSERT(error != ERROR_SUCCESS);

        goto quit;
    }

    //
    // prepare data for SecBuffer
    //

    Buffers[0].pvBuffer = hBuffer;
    Buffers[0].cbBuffer = Sizes.cbHeader;
    Buffers[0].BufferType = SECBUFFER_TOKEN;

    Buffers[1].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader;
    memcpy(Buffers[1].pvBuffer,
           lpBuffer,
           dwInBufferLen);

    Buffers[1].cbBuffer = dwInBufferLen;
    Buffers[1].BufferType = SECBUFFER_DATA;

    //
    // check if security pkg supports trailer: PCT does
    //

    if ( Sizes.cbTrailer ) {
         Buffers[2].pvBuffer = (LPBYTE)hBuffer + Sizes.cbHeader + dwInBufferLen;
         Buffers[2].cbBuffer = Sizes.cbTrailer;
         Buffers[2].BufferType = SECBUFFER_TOKEN;
    } else {
         Buffers[2].pvBuffer = NULL;
         Buffers[2].cbBuffer = 0;
         Buffers[2].BufferType = SECBUFFER_EMPTY;
    }

    Buffer.cBuffers = 3;
    Buffer.pBuffers = Buffers;
    Buffer.ulVersion = SECBUFFER_VERSION;

    scRet = g_SealMessage(&m_hContext,
                          0,
                          &Buffer,
                          0);

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned, %s [%x]\n",
                InternetMapSSPIError((DWORD)scRet),
                scRet
                ));


    if (scRet != ERROR_SUCCESS) {

        //
        // Map the SSPI error.
        //

        DEBUG_PRINT(API,
                    ERROR,
                    ("SealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));

        error = MapInternetError((DWORD) scRet);

        if (hBuffer != NULL) {
            FREE_MEMORY(hBuffer);
        }
        goto quit;
    } else {
        error = ERROR_SUCCESS;
    }

    *lplpBuffer = Buffers[0].pvBuffer;
    *lpdwOutBufferLen = Sizes.cbHeader + Buffers[1].cbBuffer +
                        Buffers[2].cbBuffer;
    *lpdwInBufferBytesEncrypted = dwInBufferLen;

    DEBUG_PRINT(API,
                INFO,
                ("SealMessage returned Buffer = %x, EncryptBytes = %d, UnencryptBytes=%d\n",
                *lplpBuffer,
                *lpdwOutBufferLen,
                dwInBufferLen
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


#define SSLPCT_SMALLESTHEADERCHUNK      3


DWORD
ICSecureSocket::DecryptData(
    OUT DWORD * lpdwBytesNeeded,
    OUT LPBYTE lpOutBuffer,
    IN OUT LPDWORD lpdwOutBufferLeft,
    IN OUT LPDWORD lpdwOutBufferReceived,
    IN OUT LPDWORD lpdwOutBufferBytesRead
    )

/*++

Routine Description:

    This function decrypts data into the lpOutBuffer. It attempts to fill lpOutBuffer.
    If it fails, it may do so because more bytes are
    needed to fill lplpEncDecBuffer or lplpEndDecBuffer is not big enough to fully
    contain a complete server generated SSL/PCT message.


Return Value:

    Error Code

--*/

{
    INET_ASSERT(IsSecure());
    INET_ASSERT(lpOutBuffer);
    INET_ASSERT(lpdwOutBufferBytesRead);
    INET_ASSERT(lpdwBytesNeeded);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "ICSecureSocket::DecryptData",
                 "{%#x [%#x:%#x], %#x} %#x [%d], %#x, %#x [%d], %#x [%d], %#x [%d]",
                 &m_hContext,
                 m_hContext.dwUpper,
                 m_hContext.dwLower,
                 m_pdblbufBuffer,
                 lpdwBytesNeeded,
                 *lpdwBytesNeeded,
                 lpOutBuffer,
                 lpdwOutBufferLeft,
                 *lpdwOutBufferLeft,
                 lpdwOutBufferReceived,
                 *lpdwOutBufferReceived,
                 lpdwOutBufferBytesRead,
                 *lpdwOutBufferBytesRead
                 ));

    SecBufferDesc Buffer;
    SecBuffer Buffers[4];   // the 4 buffers are: header, data, trailer, extra
    DWORD scRet = ERROR_SUCCESS;

    *lpdwBytesNeeded = 0;

    //
    //  HOW THIS THING WORKS:
    //  We sit in a loop, attempting to fill our passed in buffer with
    //  decrypted data.  If there is no decrypted data we check to
    //  see if there is encrypted data sitting in our buffer.
    //
    //  Assuming there is enough we decrypt a chunk, and place it in the
    //  output buffer of our double buffer class. We reloop and try to
    //  copy it to our passed in byffer.
    //
    //  If there is more encrypted data, and more space to fill in
    //  the user buffer, we attempt to decrypt the next chunk of this.
    //
    //  If we do not have enough data, we return with an error, and
    //  expect a network read to be done.
    //

    do {

        //
        // Check to see if we can fill up User buffer.
        //

        m_pdblbufBuffer->CopyOut(
            lpOutBuffer,
            lpdwOutBufferLeft,
            lpdwOutBufferReceived,
            lpdwOutBufferBytesRead
        );

        //
        // If we've filled our output buffer, than exit with ERROR_SUCCESS
        //

        if ( *lpdwOutBufferLeft == 0)
        {
            break;
        }

        //
        // If we've got less than ~3 bytes return so we can read more data.
        //

        if (m_pdblbufBuffer->GetInputBufferSize() < SSLPCT_SMALLESTHEADERCHUNK) {
            scRet = (DWORD) SEC_E_INCOMPLETE_MESSAGE;
            break;
        }

        //
        // prepare data the SecBuffer for a call to SSL/PCT decryption code.
        //

        Buffers[0].pvBuffer = m_pdblbufBuffer->GetInputBufferPointer( );
        Buffers[0].cbBuffer = m_pdblbufBuffer->GetInputBufferSize(); // # of bytes to decrypt
        Buffers[0].BufferType = SECBUFFER_DATA;

        int i;

        for ( i = 1; i < 4; i++ )
        {
            //
            // clear other 3 buffers for receving result from SSPI package
            //

            Buffers[i].pvBuffer = NULL;
            Buffers[i].cbBuffer = 0;
            Buffers[i].BufferType = SECBUFFER_EMPTY;
        }

        Buffer.cBuffers = 4; // the 4 buffers are: header, data, trailer, extra
        Buffer.pBuffers = Buffers;
        Buffer.ulVersion = SECBUFFER_VERSION;

        //
        // Decrypt the DATA !!!
        //

        scRet = g_UnsealMessage(&m_hContext,
                                &Buffer,
                                0,
                                NULL );

        DEBUG_PRINT(API,
                    INFO,
                    ("UnsealMessage returned, %s [%x]\n",
                    InternetMapSSPIError((DWORD)scRet),
                    scRet
                    ));



        if ( scRet != ERROR_SUCCESS &&
             scRet != SEC_I_RENEGOTIATE)
        {
            DEBUG_PRINT(API,
                        ERROR,
                        ("UnsealMessage failed, error %lx\n",
                        scRet
                        ));

            INET_ASSERT( scRet != SEC_E_MESSAGE_ALTERED );

            if ( scRet == SEC_E_INCOMPLETE_MESSAGE )
            {
                DWORD dwAddlBufferNeeded = Buffers[1].cbBuffer;

                DEBUG_PRINT(API,
                             INFO,
                             ("UnsealMessage short of %d bytes\n",
                             dwAddlBufferNeeded
                             ));

                 //
                 // If we're missing data, return to get the missing data.
                 // But make sure we have enough room first!
                 //

                if (!m_pdblbufBuffer->ResizeBufferIfNeeded(dwAddlBufferNeeded)) {
                    scRet = ERROR_NOT_ENOUGH_MEMORY;
                }
                *lpdwBytesNeeded = dwAddlBufferNeeded;
                break;
            }
            else if ( scRet == 0x00090317 /*SEC_I_CONTEXT_EXPIRED*/)
            {
                //
                // Ignore this error and treat this like a simple terminator
                //  to end the connection.
                //

                scRet = ERROR_SUCCESS;
            }
            else
            {
                break;
            }
        }



        //
        // Success we decrypted a block
        //

        LPBYTE  lpExtraBuffer;
        DWORD   dwExtraBufferSize;
        LPBYTE  lpDecryptedBuffer;
        DWORD   dwDecryptedBufferSize;


        lpDecryptedBuffer       =   (LPBYTE) Buffers[1].pvBuffer;
        dwDecryptedBufferSize   =   Buffers[1].cbBuffer;

        //
        // BUGBUG [arthurbi] this is hack to work with the OLD SSLSSPI.DLL .
        //  They return extra on the second buffer instead of the third.
        //

        if ( Buffers[2].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[2].pvBuffer;
            dwExtraBufferSize = Buffers[2].cbBuffer;
        }
        else if ( Buffers[3].BufferType == SECBUFFER_EXTRA )
        {
            lpExtraBuffer   = (LPBYTE) Buffers[3].pvBuffer;
            dwExtraBufferSize = Buffers[3].cbBuffer;
        }
        else
        {
            lpExtraBuffer = NULL;
            dwExtraBufferSize = 0;
        }


        m_pdblbufBuffer->SetOutputInputBuffer(
            lpDecryptedBuffer,
            dwDecryptedBufferSize,
            lpExtraBuffer,
            dwExtraBufferSize,
            FALSE // don't combine.
        );

        if ( dwDecryptedBufferSize == 0 )
            break;  // No more data to process

        INET_ASSERT( *lpdwOutBufferLeft );  // don't expect to get here this way.

    } while ( *lpdwOutBufferLeft && scRet == ERROR_SUCCESS );



    DEBUG_PRINT(API,
         INFO,
         ("DecryptData returning, "
          "OutBuffer = %x, DecryptBytesRecv = %d\n",
         lpOutBuffer,
         *lpdwOutBufferBytesRead
         ));

    DEBUG_LEAVE((DWORD)scRet);

    return ( scRet );
}


VOID
ICSecureSocket::TerminateSecConnection(
    VOID
    )

/*++

Routine Description:

    This function deletes the security context handle which result
    in deleting the local data structures with which they are associated.

Arguments:

    None

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 None,
                 "ICSecureSocket::TerminateSecConnection",
                 "{%#x [%#x:%#x]}",
                 this,
                 m_hContext.dwUpper,
                 m_hContext.dwLower
                 ));

    INET_ASSERT(IsSecure());

    //INET_ASSERT(m_hContext.dwLower != 0);
    //INET_ASSERT(m_hContext.dwUpper != 0);

    if (GlobalSecFuncTable) {
        if (!((m_hContext.dwLower == 0) && (m_hContext.dwUpper == 0))) {
            // There are cases where because of circular dependencies
            // schannel could get unloaded before wininet. In that case
            // this call could fault. This usually happens when the process 
            // is shutting down.
            __try {
                g_DeleteSecurityContext(&m_hContext);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
            }
            ENDEXCEPT

            m_hContext.dwLower = m_hContext.dwUpper = 0;
        }
    } else {

        DEBUG_PRINT(API,
                    ERROR,
                    ("Attempting to Delete a security context, with a NULL SSPI func table!(missing SCHANNEL.DLL?)\n"
                    ));

    }

    DEBUG_LEAVE(0);
}

#ifdef SECPKG_ATTR_PROTO_INFO
/*++

ProtoInfoToString:

    This routine converts an SSPI SecPkgContext_ProtoInfo structure into a
    string.  The returned string must be released via LocalFree.

Arguments:

    pProtoInfo supplies the SecPkgContext_ProtoInfo structure to be converted to
    string representation.

Return Value:

    Non-NULL is the address of the returned string.  This must be freed via
        LocalFree once it is no longer needed.

    NULL implies no memory is available.

Author:

    Doug Barlow (dbarlow) 4/23/1996

--*/


PRIVATE
LPTSTR
ProtoInfoToString(
    IN const PSecPkgContext_ProtoInfo pProtoInfo)
{
    TCHAR
        szValue[32],
        szSep[8];
    LPTSTR
        szFinal
            = NULL;
    DWORD
        length;

    length = GetLocaleInfo(
                LOCALE_USER_DEFAULT,
                LOCALE_SDECIMAL,
                szSep,
                sizeof(szSep) / sizeof(TCHAR));
    if (0 >= length)
        lstrcpy(szSep, TEXT("."));

    length = wsprintf(
                szValue,
                TEXT("%d%s%d"),
                pProtoInfo->majorVersion,
                szSep,
                pProtoInfo->minorVersion);
    INET_ASSERT(sizeof(szValue) / sizeof(TCHAR) > length);

    length = lstrlen(pProtoInfo->sProtocolName);
    length += 2;                    // Space and Trailing NULL
    length += lstrlen(szValue);
    szFinal = (LPTSTR)ALLOCATE_MEMORY(LMEM_FIXED, length * sizeof(TCHAR));
    if (NULL != szFinal)
    {
        lstrcpy(szFinal, pProtoInfo->sProtocolName);
        lstrcat(szFinal, TEXT(" "));
        lstrcat(szFinal, szValue);
    }
    return szFinal;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\rprintf.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    rprintf.cxx

Abstract:

    Contains my own version of printf(), sprintf() and vprintf(). Useful since
    adding new printf escape sequences becomes easy

    Contents:
        rprintf     limited re-entrant version of printf
        rsprintf    limited re-entrant version of sprintf
        _sprintf    routine which does the work

Author:

    Richard L Firth (rfirth) 20-Jun-1995

Revision History:

    29-Aug-1989 rfirth
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

//
// defines for flags word
//

#define F_SPACES        0x00000001  // prefix field with spaces
#define F_ZEROES        0x00000002  // prefix field with zeroes
#define F_MINUS         0x00000004  // field is left justified
#define F_HASH          0x00000008  // hex field is prefixed with 0x/0X
#define F_XUPPER        0x00000010  // hex field has upper case letters
#define F_LONG          0x00000020  // long int/hex/oct prefix
#define F_PLUS          0x00000040  // prefix +'ve signed number with +
#define F_DOT           0x00000080  // separator for field and precision
#define F_NEAR          0x00000100  // far pointer has near prefix
#define F_FAR           0x00000200  // near pointer has far prefix
#define F_SREPLICATE    0x00000400  // this field replicated
#define F_EREPLICATE    0x00000800  // end of replications
#define F_UNICODE       0x00001000  // string is wide character (%ws/%wq)
#define F_QUOTING       0x00002000  // strings enclosed in double quotes
#define F_ELLIPSE       0x00004000  // a sized, quoted string ends in "..."

#define BUFFER_SIZE     1024

//
// minimum field widths for various ASCII representations of numbers
//

#define MIN_BIN_WIDTH   16          // minimum field width in btoa
#define MIN_HEX_WIDTH   8           // minimum field width in xtoa
#define MIN_INT_WIDTH   10          // minimum field width in itoa
#define MIN_LHEX_WIDTH  8           // minimum field width in long xtoa
#define MIN_LINT_WIDTH  10          // minimum field width in long itoa
#define MIN_LOCT_WIDTH  11          // minimum field width in long otoa
#define MIN_OCT_WIDTH   11          // minimum field width in otoa
#define MIN_UINT_WIDTH  10          // minimum field width in utoa

//
// character defines
//

#define EOSTR           '\0'
#define CR              '\x0d'
#define LF              '\x0a'

#if !defined(min)

#define min(a, b)   ((a)<(b)) ? (a) : (b)

#endif

PRIVATE int     _atoi(char**);
PRIVATE void    convert(char**, ULONG_PTR, int, int, unsigned, char(*)(ULONG_PTR*));
PRIVATE char    btoa(ULONG_PTR *);
PRIVATE char    otoa(ULONG_PTR *);
PRIVATE char    utoa(ULONG_PTR *);
PRIVATE char    xtoa(ULONG_PTR *);
PRIVATE char    Xasc(ULONG_PTR *);

/***    rprintf - a re-entrant cut-down version of printf. Understands usual
 *                  printf format characters introduced by '%' plus one or
 *                  two additions
 *
 *      ENTRY   format  - pointer to buffer containing format string defining
 *                        the output. As per usual printf the arguments to
 *                        fill in the blanks in the format string are on the
 *                        the stack after the format string
 *
 *              <args>  - arguments on stack, size and type determined from
 *                        the format string
 *
 *      EXIT    format string used to convert arguments (if any) and print
 *              the results to stdout.
 *              The number of character copied is the value returned
 */

#ifdef UNUSED
int cdecl rprintf(char* format, ...) {

    int charsPrinted = 0;
    char buffer[BUFFER_SIZE];
    DWORD nwritten;
    va_list args;

    /* print the output into  buffer then print the formatted buffer to the
     * screen
     */

    va_start(args, format);
    charsPrinted = _sprintf(buffer, format, args);
    va_end(args);

    WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                              buffer,
                              charsPrinted,
                              &nwritten,
                              0
                              );
    return nwritten;
}
#endif

/***    rsprintf - a re-entrant cut-down version of sprintf. See rprintf for
 *                  details
 *
 *      ENTRY   buffer  - pointer to the buffer which will receive the
 *                        formatted output
 *
 *              format  - pointer to buffer which defines the formatted
 *                        output. Consists of normal printing characters
 *                        and printf-style format characters (see rprintf)
 *
 *      EXIT    characters from format string and arguments converted to
 *              character format based on format string are copied into the
 *              buffer
 *              The number of character copied is the value returned
 */

int cdecl rsprintf(char* buffer, char* format, ...) {

    va_list args;
    int n;

    va_start(args, format);
    n = _sprintf(buffer, format, args);
    va_end(args);
    return n;
}

/***    _sprintf - performs the sprintf function. Receives an extra parameter
 *                  on the stack which is the pointer to the variable argument
 *                  list of rprintf and rsprintf
 *
 *      ENTRY   buffer  - pointer to buffer which will receive the output
 *
 *              format  - pointer to the format string
 *
 *              args    - variable argument list which will be used to fill in
 *                        the escape sequences in the format string
 *
 *      EXIT    The characters in the format string are used to convert the
 *              arguments and copy them to the buffer.
 *              The number of character copied is the value returned
 */

int cdecl _sprintf(char* buffer, char* format, va_list args) {

    char*       original = buffer;
    int         FieldWidth;
    int         FieldPrecision;
    int         FieldLen;
    BOOL        SubDone;
    int         StrLen;
    int         i;
    DWORD       flags;
    int         replications;

    while (*format) {
        switch ((unsigned)*format) {
        case '\n':

            //
            // convert line-feed to carriage-return, line-feed. But only if the
            // format string doesn't already contain a carriage-return directly
            // before the line-feed! This way we can make multiple calls into
            // this function, with the same buffer, and only once expand the
            // line-feed
            //

            if (*(buffer - 1) != CR) {
                *buffer++ = CR;
            }
            *buffer++ = LF;
            break;

        case '%':
            SubDone = FALSE;
            flags = 0;
            FieldWidth = 0;
            FieldPrecision = 0;
            replications = 1;   /* default replication is 1 */
            while (!SubDone) {
                switch ((unsigned)*++format) {
                case '%':
                    *buffer++ = '%';
                    SubDone = TRUE;
                    break;

                case ' ':
                    flags |= F_SPACES;
                    break;

                case '#':
                    flags |= F_HASH;
                    break;

                case '-':
                    flags |= F_MINUS;
                    break;

                case '+':
                    flags |= F_PLUS;
                    break;

                case '.':
                    flags |= F_DOT;
                    break;

                case '*':
                    if (flags & F_DOT) {
                        FieldPrecision = va_arg(args, int);
                    } else {
                        FieldWidth = va_arg(args, int);
                    }
                    break;

                case '@':
                    replications = _atoi(&format);
                    break;

                case '[':
                    flags |= F_SREPLICATE;
                    break;

                case ']':
                    flags |= F_EREPLICATE;
                    break;

                case '0':
                    /* if this is leading zero then caller wants
                     * zero prefixed number of given width (%04x)
                     */
                    if (!(flags & F_ZEROES)) {
                        flags |= F_ZEROES;
                        break;
                    }

                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    if (flags & F_DOT) {
                        FieldPrecision = _atoi(&format);
                    } else {
                        FieldWidth = _atoi(&format);
                    }
                    break;

                case 'b':

                    //
                    // Binary representation
                    //

                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned int),
                                (FieldWidth) ? FieldWidth : MIN_BIN_WIDTH,
                                MIN_BIN_WIDTH,
                                flags,
                                btoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'B':

                    //
                    // Boolean representation
                    //

                    if (va_arg(args, BOOL)) {
                        *buffer++ = 'T';
                        *buffer++ = 'R';
                        *buffer++ = 'U';
                        *buffer++ = 'E';
                    } else {
                        *buffer++ = 'F';
                        *buffer++ = 'A';
                        *buffer++ = 'L';
                        *buffer++ = 'S';
                        *buffer++ = 'E';
                    }
                    SubDone = TRUE;
                    break;

                case 'c':

                    //
                    // assume that a character is the size of the
                    // width of the stack which in turn has the same
                    // width as an integer
                    //

                    --FieldWidth;
                    while (replications--) {
                        for (i = 0; i < FieldWidth; i++) {
                            *buffer++ = ' ';
                        }
                        *buffer++ = (char) va_arg(args, int);
                    }
                    SubDone = TRUE;
                    break;

                case 'd':
                case 'i':
                    while (replications--) {

                        long l;

                        l = (flags & F_LONG) ? va_arg(args, long) : (long)va_arg(args, int);
                        if (l < 0) {
                            *buffer++ = '-';
                            if (flags & F_LONG) {
                                l = -(long)l;
                            } else {
                                l = -(int)l;
                            }
                        } else if (flags & F_PLUS) {
                            *buffer++ = '+';
                        }
                        convert(&buffer,
                                l,
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LINT_WIDTH : MIN_INT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'e':
                    /* not currently handled */
                    break;

                case 'f':
                    /* not currently handled */
                    break;

                case 'F':
                    flags |= F_FAR;
                    break;

                case 'g':
                case 'G':
                    /* not currently handled */
                    break;

                case 'h':
                    /* not currently handled */
                    break;

                case 'l':
                    flags |= F_LONG;
                    break;

                case 'L':
                    /* not currently handled */
                    break;

                case 'n':
                    *(va_arg(args, int*))  = (int)(buffer - original);
                    SubDone = TRUE;
                    break;

                case 'N':
                    flags |= F_NEAR;
                    break;

                case 'o':
                    while (replications--) {
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : (unsigned long)va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LOCT_WIDTH : MIN_OCT_WIDTH,
                                flags,
                                otoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'p':
                    while (replications--) {

                        void* p;

                        if (!(flags & F_NEAR)) {
                            convert(&buffer,
                                    (ULONG_PTR) va_arg(args, char near *),
                                    MIN_HEX_WIDTH,
                                    MIN_HEX_WIDTH,
                                    flags | F_XUPPER,
                                    Xasc
                                    );
                            *buffer++ = ':';
                        }
                        convert(&buffer,
                                (ULONG_PTR)va_arg(args, unsigned),
                                MIN_HEX_WIDTH,
                                MIN_HEX_WIDTH,
                                flags | F_XUPPER,
                                Xasc
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'Q':       // quoted unicode string
                    flags |= F_UNICODE;
                    // *** FALL THROUGH ***

                case 'q':
                    *buffer++ = '"';
                    flags |= F_QUOTING;

                    //
                    // *** FALL THROUGH ***
                    //

                case 's':
                    while (replications--) {

                        char* s;

                        s = va_arg(args, char*);
                        if (s != NULL) {

                            // darrenmi 2/24/00 Note that if the string has a field precision,
                            // it's not always null terminated!! Don't depend on it being psz
                            // and stop when we hit our max length.
                            StrLen = 0;

                            if (flags & F_UNICODE) {
                                WCHAR   *pWork = (LPWSTR)s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            } else {
                                CHAR    *pWork = s;
                                while((!FieldPrecision || StrLen < FieldPrecision) && *pWork)
                                {
                                    pWork++;
                                    StrLen++;
                                }
                            }

                            FieldLen = (FieldPrecision)
                                        ? min(StrLen, FieldPrecision)
                                        : StrLen
                                        ;
                            if ((flags & F_QUOTING) && (FieldPrecision > 3) && (FieldLen == FieldPrecision)) {
                                FieldLen -= 3;
                                flags |= F_ELLIPSE;
                            }

                            for (i = 0; i < (FieldWidth - FieldLen); i++) {
                                *buffer++ = ' ';
                            }

                            if (flags & F_UNICODE) {

                                char wbuf[4096];
                                int wi;

                                WideCharToMultiByte(CP_ACP, 0,
                                        (LPWSTR)s, -1,
                                        wbuf, 4096,
                                        NULL, NULL);

                                for (wi = 0; wbuf[wi] && FieldLen; ++wi) {
                                    *buffer = wbuf[wi];

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            } else {
                                while (*s && FieldLen) {
                                    *buffer = *s++;

                                    //
                                    // if this is a quoted string, and it contains
                                    // \r and/or \n, then we reverse-convert these
                                    // characters, since we don't want then to
                                    // break the string. Do the same for \t
                                    //

                                    if (flags & F_QUOTING) {

                                        char ch;

                                        ch = *buffer;
                                        if ((ch == '\r') || (ch == '\n') || (ch == '\t')) {
                                            *buffer++ = '\\';
                                            *buffer = (ch == '\r')
                                                        ? 'r'
                                                        : (ch == '\n')
                                                            ? 'n'
                                                            : 't'
                                                            ;
                                        }
                                    }
                                    ++buffer;
                                    --FieldLen;
                                }
                            }
                            if (flags & F_ELLIPSE) {
                                *buffer++ = '.';
                                *buffer++ = '.';
                                *buffer++ = '.';
                            }
                        } else if (!(flags & F_QUOTING)) {
                            *buffer++ = '(';
                            *buffer++ = 'n';
                            *buffer++ = 'u';
                            *buffer++ = 'l';
                            *buffer++ = 'l';
                            *buffer++ = ')';
                        }
                    }
                    if (flags & F_QUOTING) {
                        *buffer++ = '"';
                    }
                    SubDone = TRUE;
                    break;

                case 'S':
                    break;

                case 'u':
                    while (replications--) {
                        convert(&buffer,
                                va_arg(args, unsigned),
                                FieldWidth,
                                MIN_UINT_WIDTH,
                                flags,
                                utoa
                                );
                    }
                    SubDone = TRUE;
                    break;

                case 'w':
                    flags |= F_UNICODE;
                    break;

                case 'X':
                    flags |= F_XUPPER;

                    //
                    // *** FALL THROUGH ***
                    //

                case 'x':
                    while (replications--) {
                        if (flags & F_HASH) {
                            *buffer++ = '0';
                            *buffer++ = (flags & F_XUPPER) ? (char)'X' : (char)'x';
                        }
                        convert(&buffer,
                                (flags & F_LONG) ? va_arg(args, unsigned long) : va_arg(args, unsigned),
                                FieldWidth,
                                (flags & F_LONG) ? MIN_LHEX_WIDTH : MIN_HEX_WIDTH,
                                flags,
                                (flags & F_XUPPER) ? Xasc : xtoa
                                );
                    }
                    SubDone = TRUE;
                    break;
                } /* switch <%-specifier> */
            }
            break;

        default:
            *buffer++ = *format;
        } /* switch <character> */
        ++format;
    } /* while */
    *buffer = EOSTR;
    return (int)(buffer - original);
}

/***    _atoi - ascii to integer conversion used to get the field width out
 *              of the format string
 *
 *      ENTRY   p - pointer to pointer to format string
 *
 *      EXIT    returns the number found in the prefix string as a (16-bit)
 *              int format string pointer is updated past the field width
 */

PRIVATE
int _atoi(char** p) {

    int n = 0;
    int i = 5;

    while ((**p >= '0' && **p <= '9') && i--) {
        n = n*10+((int)(*(*p)++)-(int)'0');
    }

    /* put the format pointer back one since the major loop tests *++format */

    --*p;
    return n;
}

/***    convert - convert number to representation defined by procedure
 *
 *      ENTRY   buffer  - pointer to buffer to receive conversion
 *              n       - number to convert
 *              width   - user defined field width
 *              mwidth  - minimum width for representation
 *              flags   - flags controlling conversion
 *              proc    - pointer to conversion routine
 *
 *      EXIT    buffer is updated to point past the number representation
 *              just put into it
 */

PRIVATE
void
convert(
    char** buffer,
    ULONG_PTR n,
    int width,
    int mwidth,
    unsigned flags,
    char (*proc)(ULONG_PTR*)
    )
{
    char    numarray[33];
    int     MinWidth;
    int     i;

    MinWidth = (width < mwidth) ? mwidth : width;
    i = MinWidth;
    do {
        numarray[--i] = (*proc)(&n);
    } while (n);
    while (width > MinWidth-i) {
        numarray[--i] = (char)((flags & F_SPACES) ? ' ' : '0');
    }
    while (i < MinWidth) {
        *(*buffer)++ = numarray[i++];
    }
}

/***    btoa - return next (least significant) char in a binary to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char btoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)(*pn&1)+'0';
    *pn >>= 1;
    return rch;
}

/***    otoa - return next (least significant) char in an octal to ASCII
 *              conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char otoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn&7);
    *pn >>= 3;
    return rch;
}

/***    utoa - return next (least significant) char in an unsigned int to
 *              ASCII conversion
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char utoa(ULONG_PTR *pn) {

    char    rch;

    rch = (char)'0'+(char)(*pn%10);
    *pn /= 10;
    return rch;
}

/***    xtoa - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns lower case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char xtoa(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('a'-'9'-1);

    *pn >>= 4;
    return rch;
}

/***    Xasc - return next (least significant) char in a hexadecimal to
 *              ASCII conversion. Returns upper case hex characters
 *
 *      ENTRY   pn  - pointer to number to convert
 *
 *      EXIT    returns next (LS) character, updates original number
 */

PRIVATE
char Xasc(ULONG_PTR *pn) {

    ULONG_PTR   n = *pn & 0x000f;
    char        rch = (n <= 9)
                        ? (char)n+'0'
                        : (char)n+'0'+('A'-'9'-1);

    *pn >>= 4;
    return rch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\memalloc.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    memalloc.cxx

Abstract:

    Debug-only memory allocation routines

    Contents:
        InetInitializeDebugMemoryPackage
        InetTerminateDebugMemoryPackage
        InetAllocateMemory
        InetReallocateMemory
        (InetIsBlockMoveable)
        InetFreeMemory
        (InetCheckBlockConsistency)
        InetLockMemory
        InetUnlockMemory
        InetMemorySize
        InetCheckDebugMemoryFreed
        (x86SleazeCallersAddress)

Author:

     Richard L Firth (rfirth) 02-Feb-1995

Environment:

    Win32 user mode

Revision History:

    02-Feb-1995
        Created

--*/

#include <wininetp.h>
#include "rprintf.h"

#if INET_DEBUG

//
// manifests
//

#define HEADER_SIGNATURE    0x414d454d  // 'MEMA'
#define FOOTER_SIGNATURE    0x434f4c4c  // 'LLOC'
#define DWORD_FILL          0xa9a9a9a9
#define BYTE_FILL           0xa9
#define BYTE_FILL_EXTRA     0xcb
#define GUARD_DWORD_FILL    0xcccd21f4
#define DWORD_FREE_FILL     0xb7b7b7b7
#define BYTE_FREE_FILL      0xb7

//
// private types
//

typedef struct {

    //
    // hMoveable - local handle of moveable memory that this tag links
    //

    HLOCAL hMoveable;

} DEBUG_MOVEABLE_TAG, *LPDEBUG_MOVEABLE_TAG;

typedef struct {

    //
    // List - maintains a list of allocated blocks
    //

    LIST_ENTRY List;

    //
    // BlockLength - the size of this block, *including* all headers, footers
    // and padding
    //

    UINT BlockLength;

    //
    // RealLength - the original caller request
    //

    UINT RealLength;

    //
    // Signature - just used as a sanity check to ensure that what we are
    // dealing with is actually a block we allocated
    //

    DWORD Signature;

    //
    // LockCount - if this is moveable memory, keeps the number of times this
    // block has been locked
    //

    LONG LockCount;

    //
    // Flags - what type of memory this is, etc.
    //

    DWORD Flags;

    //
    // LastAccessOperation - the operation caller at LastAccessReturnAddress
    // performed
    //

    MEMALLOC_ACTION LastAccessOperation;

    //
    // LastAccessReturnAddress - caller of last function to perform memory
    // function operation (alloc, lock, realloc, unlock, etc) on this block
    //

    LPVOID LastAccessReturnAddress[2];

    //
    // CreatorReturnAddress - return EIP (x86-only) of caller of allocator
    // and caller of caller
    //

    LPVOID CreatorReturnAddress[2];

    //
    // Tag - if this is moveable memory, we can't add this block to the allocated
    // block list, we have to allocate a DEBUG_MOVEABLE_TAG, link that and point
    // to it from here
    //

    LPDEBUG_MOVEABLE_TAG Tag;

    //
    // Guard - just a sentinel to find out if the caller is writing before the
    // start of this block
    //

    DWORD Guard[4];

    //
    // sizeof(MEMORY_SIGNATURE) currently 17 DWORDs
    //

} DEBUG_MEMORY_HEADER, *LPDEBUG_MEMORY_HEADER;

typedef struct {

    //
    // Guard - allows us to determine if the end of allocated memory was
    // overwritten
    //

    DWORD Guard[4];

    //
    // Signature - should be the footer signature
    //

    DWORD Signature;

    //
    // BlockLength - should be the same as the header
    //

    DWORD BlockLength;

    //
    // Guard2 - to make sure the end of the block is coherent
    //

    DWORD Guard2[2];

    //
    // sizeof(DEBUG_MEMORY_FOOTER) currently 8 DWORDs
    //

} DEBUG_MEMORY_FOOTER, *LPDEBUG_MEMORY_FOOTER;

//
// data
//

LONG ActualMemoryAllocated = 0;
LONG BlockLengthAllocated = 0;
LONG RealLengthAllocated = 0;
DWORD MemoryAllocations = 0;
DWORD MemoryFrees = 0;
SERIALIZED_LIST AllocatedBlockList;

//
// macros
//

#if defined(i386)

#define GET_CALLERS_ADDRESS(p, pp)  x86SleazeCallersAddress(p, pp)

#else

#define GET_CALLERS_ADDRESS(p, pp)

#endif // defined(i386)

//
// private prototypes
//

PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    );

PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    );

PRIVATE
VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    );

//
// functions
//


VOID
InetInitializeDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Just initializes data items in this module

Arguments:

    None.

Return Value:

    None.

--*/

{
    static BOOL MemoryPackageInitialized = FALSE;

    if (!MemoryPackageInitialized) {
        InitializeSerializedList(&AllocatedBlockList);
        MemoryPackageInitialized = TRUE;
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("Memory package already initialized\n"
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


VOID
InetTerminateDebugMemoryPackage(
    VOID
    )

/*++

Routine Description:

    Undoes any resource allocation in InetInitializeDebugMemoryPackage, after
    checking that all memory is freed

Arguments:

    None.

Return Value:

    None.

--*/

{
    InetCheckDebugMemoryFreed();
    TerminateSerializedList(&AllocatedBlockList);
}


HLOCAL
InetAllocateMemory(
    IN UINT LocalAllocFlags,
    IN UINT NumberOfBytes
    )

/*++

Routine Description:

    Debug memory allocator: allocates memory with head & tail. Fills memory
    with signature unless otherwise requested. If this is moveable memory
    then the caller must lock the memory with InetLockMemory(), else a pointer
    will be returned to the head of the heap's real start-of-block, and the
    caller will probably nuke the signature contents (but we should discover
    this when the block is freed)

Arguments:

    LocalAllocFlags - flags to be passed on to LocalAlloc
    NumberOfBytes   - to allocate for caller

Return Value:

    LPVOID
        Success - pointer to memory after DEBUG_MEMORY_HEADER
        Failure - NULL

--*/

{
    HLOCAL hLocal;
    UINT blockLength;
    BOOL isMoveable;

    isMoveable = (LocalAllocFlags & LMEM_MOVEABLE) ? TRUE : FALSE;
    blockLength = ROUND_UP_DWORD(NumberOfBytes)
                + sizeof(DEBUG_MEMORY_HEADER)
                + sizeof(DEBUG_MEMORY_FOOTER)
                ;

    //
    // possible problem: if NumberOfBytes + signatures would overflow UINT.
    // Only really problematic on 16-bit platforms
    //

    if (blockLength < NumberOfBytes) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("can't allocate %lu bytes: would overflow\n",
                    (DWORD)NumberOfBytes
                    ));

        DEBUG_BREAK(MEMALLOC);

        return (HLOCAL)NULL;
    }

    hLocal = LocalAlloc(LocalAllocFlags, blockLength);
    if (hLocal != NULL) {

        LPVOID lpMem;
        LPDEBUG_MEMORY_HEADER lpHeader;
        DWORD dwFiller;
        BYTE bFiller;
        UINT dwFillLength;
        UINT bFillLength1;
        UINT bFillLength2;
        UINT i;
        LPVOID userPointer;

        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += blockLength;
        RealLengthAllocated += NumberOfBytes;
        ++MemoryAllocations;

        if (isMoveable) {
            lpMem = (LPVOID)LocalLock(hLocal);
            if (lpMem == NULL) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalLock(%x) failed: %d\n",
                            hLocal,
                            GetLastError()
                            ));

                DEBUG_BREAK(MEMALLOC);

            }
        } else {
            lpMem = (LPVOID)hLocal;
        }

        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMem;
        InitializeListHead(&lpHeader->List);
        lpHeader->BlockLength = blockLength;
        lpHeader->RealLength = NumberOfBytes;
        lpHeader->Signature = HEADER_SIGNATURE;
        lpHeader->LockCount = 0;
        lpHeader->Flags = LocalAllocFlags;

        GET_CALLERS_ADDRESS(&lpHeader->CreatorReturnAddress[0],
                            &lpHeader->CreatorReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemAllocate;

        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            lpHeader->Guard[i] = GUARD_DWORD_FILL;
        }

        if (LocalAllocFlags & LMEM_ZEROINIT) {
            dwFiller = 0;
            bFiller = 0;
        } else {
            dwFiller = DWORD_FILL;
            bFiller = BYTE_FILL;
        }
        dwFillLength = NumberOfBytes / sizeof(DWORD);
        bFillLength1 = NumberOfBytes % sizeof(DWORD);
        bFillLength2 = bFillLength1 ? (sizeof(DWORD) - bFillLength1) : 0;
        userPointer = (LPVOID)(lpHeader + 1);

        LPDWORD lpdwUserPointer = (LPDWORD)userPointer;

        for (i = 0; i < dwFillLength; ++i) {
            *lpdwUserPointer++ = dwFiller;
        }

        LPBYTE lpbUserPointer = (LPBYTE)lpdwUserPointer;

        for (i = 0; i < bFillLength1; ++i) {
            *lpbUserPointer++ = bFiller;
        }
        for (i = 0; i < bFillLength2; ++i) {
            *lpbUserPointer++ = BYTE_FILL_EXTRA;
        }

        userPointer = (LPVOID)lpbUserPointer;

        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard[i] = GUARD_DWORD_FILL;
        }
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->BlockLength = blockLength;
        ((LPDEBUG_MEMORY_FOOTER)userPointer)->Signature = FOOTER_SIGNATURE;
        for (i = 0; i < ARRAY_ELEMENTS(((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2); ++i) {
            ((LPDEBUG_MEMORY_FOOTER)userPointer)->Guard2[i] = GUARD_DWORD_FILL;
        }

        //
        // if this is moveable memory, then we can't link it into the allocated
        // block list because if it moves, the list gets nuked. So we have to
        // allocate a DEBUG_MOVEABLE_TAG, link that and point to it from here
        //

        if (isMoveable) {

            LPDEBUG_MOVEABLE_TAG lpTag;

            lpTag = (LPDEBUG_MOVEABLE_TAG)InetAllocateMemory(LMEM_FIXED, sizeof(DEBUG_MOVEABLE_TAG));

            INET_ASSERT(lpTag != NULL);

            lpTag->hMoveable = hLocal;
            lpHeader->Tag = lpTag;
        } else {
            InsertAtHeadOfSerializedList(&AllocatedBlockList, &lpHeader->List);
        }

        if (isMoveable) {
            if (LocalUnlock(hLocal)) {

                DEBUG_PRINT(MEMALLOC,
                            ERROR,
                            ("LocalUnlock(%x): memory still locked\n",
                            hLocal
                            ));

                DEBUG_BREAK(MEMALLOC);

            } else {

                DWORD err;

                err = GetLastError();
                if (err != NO_ERROR) {

                    DEBUG_PRINT(MEMALLOC,
                                ERROR,
                                ("LocalUnlock(%x) returns %d\n",
                                hLocal,
                                err
                                ));

                    DEBUG_BREAK(MEMALLOC);

                }
            }
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to allocate %u bytes memory\n",
                    blockLength
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


HLOCAL
InetReallocateMemory(
    IN HLOCAL hLocal,
    IN UINT Size,
    IN UINT Flags,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Reallocates previously allocated block

    BUGBUG - this doesn't handle the more exotic LocalReAlloc stuff, like
             DISCARDABLE memory, allocating/freeing through realloc etc

Arguments:

    hLocal      - block to reallocate
    Size        - new size
    Flags       - new flags
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to find out from hLocal whether this
                  memory is moveable or fixed

Return Value:

    HLOCAL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    UINT realLength;
    UINT heapLength;

    //
    // can't handle reallocating down to zero
    //

    INET_ASSERT(Size != 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        heapLength = LocalSize(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
        heapLength = LocalSize((HLOCAL)lpHeader);
    }

    InetCheckBlockConsistency((LPVOID)lpHeader);

    if (IsMoveable) {
        LocalUnlock(hLocal);
    }

    realLength = Size;

    Size = ROUND_UP_DWORD(Size)
         + sizeof(DEBUG_MEMORY_HEADER)
         + sizeof(DEBUG_MEMORY_FOOTER)
         ;

    ActualMemoryAllocated -= heapLength;
    BlockLengthAllocated -= lpHeader->BlockLength;
    RealLengthAllocated -= lpHeader->RealLength;

    hLocal = LocalReAlloc(hLocal, Size, Flags);
    if (hLocal != NULL) {

        LPBYTE extraPointer;
        UINT extraLength;
        UINT i;
        LPDEBUG_MEMORY_FOOTER lpFooter;

        if (IsMoveable) {
            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
        } else {
            lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
        }

        lpHeader->BlockLength = Size;
        lpHeader->RealLength = realLength;
        lpHeader->Flags = Flags;

        GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                            &lpHeader->LastAccessReturnAddress[1]
                            );

        lpHeader->LastAccessOperation = MemReallocate;

        extraPointer = (LPBYTE)(lpHeader + 1) + realLength;
        extraLength = (sizeof(DWORD) - (realLength % sizeof(DWORD)))
                    & (sizeof(DWORD) - 1)
                    ;
        for (i = 0; i < extraLength; ++i) {
            *extraPointer++ = BYTE_FILL_EXTRA;
        }
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)(lpHeader + 1)
                 + ROUND_UP_DWORD(realLength)
                 );
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            lpFooter->Guard[i] = GUARD_DWORD_FILL;
        }
        lpFooter->Signature = FOOTER_SIGNATURE;
        lpFooter->BlockLength = Size;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            lpFooter->Guard2[i] = GUARD_DWORD_FILL;
        }
        ActualMemoryAllocated += LocalSize(hLocal);
        BlockLengthAllocated += Size;
        RealLengthAllocated += lpHeader->RealLength;
        if (IsMoveable) {
            LocalUnlock(hLocal);
        } else {
            hLocal = (HLOCAL)(lpHeader + 1);
        }
    } else {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("failed to reallocate %u bytes memory. Last error = %d\n",
                    Size,
                    GetLastError()
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
    return hLocal;
}


PRIVATE
BOOL
InetIsBlockMoveable(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Determines if hLocal is moveable or fixed memory

Arguments:

    hLocal  -

Return Value:

    BOOL

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;

    //
    // BUGBUG - this method won't work for Win32s unless it supports SEH. But
    //          there is another method...
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;
    __try {
        if (lpHeader->Signature == HEADER_SIGNATURE) {
            isMoveable = FALSE;
        } else {

            lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

            INET_ASSERT(lpHeader != NULL);

            isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
            LocalUnlock(hLocal);
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // yeowww! hLocal must be a handle to moveable memory. Either that, or
        // it is completely bogus
        //

        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        isMoveable = (BOOL)(lpHeader->Signature == HEADER_SIGNATURE);
        LocalUnlock(hLocal);
    }
    return isMoveable;
}


HLOCAL
InetFreeMemory(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Debug memory deallocator: checks memory is already allocated and that the
    head and tail structures are still ok. Fills freed memory with signature

Arguments:

    hLocal  - address/handle of memory to free
    IsMoveable  - TRUE if this is moveable memory. We need this help because
                  there is no good way to determine if the memory is moveable
                  or fixed

Return Value:

    HLOCAL
        Success - NULL
        Failure - hLocal

--*/

{
    UINT memFlags;
    LPDEBUG_MEMORY_HEADER lpHeader;
    BOOL isMoveable;
    UINT memSize;
    UINT blockLength;
    UINT realLength;

    if (!IsMoveable) {
        hLocal = (HLOCAL)((LPDEBUG_MEMORY_HEADER)hLocal - 1);
    }

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) == 0);

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal;
    }

    memSize = LocalSize(hLocal);

    INET_ASSERT((lpHeader->BlockLength <= memSize)
                && !(lpHeader->BlockLength & (sizeof(DWORD) - 1))
                && (lpHeader->RealLength < lpHeader->BlockLength)
                );

    InetCheckBlockConsistency((LPVOID)lpHeader);

    //
    // if this is moveable memory then we didn't link it to the allocated
    // block list, but allocated a DEBUG_MOVEABLE_TAG to do the job. We
    // must remove it
    //

    if (IsMoveable) {

        LPDEBUG_MOVEABLE_TAG lpTag;

        lpTag = lpHeader->Tag;

        INET_ASSERT(lpTag->hMoveable == hLocal);

        InetFreeMemory(lpTag, FALSE);
    } else {
        RemoveFromSerializedList(&AllocatedBlockList, &lpHeader->List);
    }

    if (IsMoveable) {

        BOOL stillLocked;

        stillLocked = LocalUnlock(hLocal);

        INET_ASSERT(!stillLocked);
        INET_ASSERT(GetLastError() == NO_ERROR);

    }

    blockLength = lpHeader->BlockLength;
    realLength = lpHeader->RealLength;
    hLocal = LocalFree(hLocal);

    INET_ASSERT(hLocal == NULL);

    ActualMemoryAllocated -= memSize;
    BlockLengthAllocated -= blockLength;
    RealLengthAllocated -= realLength;
    ++MemoryFrees;

    return hLocal;
}


PRIVATE
VOID
InetCheckBlockConsistency(
    IN LPVOID lpMemory
    )

/*++

Routine Description:

    Checks that what we think is a valid allocated block (allocated by
    InetAllocateMemory), really is

Arguments:

    lpMemory    - pointer to what we think is DEBUG_MEMORY_HEADER

Return Value:

    None.

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader;
    LPDEBUG_MEMORY_FOOTER lpFooter;
    UINT i;
    BOOL headerGuardOverrun;
    BOOL footerGuardOverrun;
    BOOL footerGuard2Overrun;
    BOOL extraMemoryOverrun;
    LPBYTE lpExtraMemory;
    UINT byteLength;

    __try {
        lpHeader = (LPDEBUG_MEMORY_HEADER)lpMemory;
        lpFooter = (LPDEBUG_MEMORY_FOOTER)((LPBYTE)lpMemory
                 + (lpHeader->BlockLength - sizeof(DEBUG_MEMORY_FOOTER)))
                 ;

        headerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpHeader->Guard); ++i) {
            if (lpHeader->Guard[i] != GUARD_DWORD_FILL) {
                headerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuardOverrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard); ++i) {
            if (lpFooter->Guard[i] != GUARD_DWORD_FILL) {
                footerGuardOverrun = TRUE;
                break;
            }
        }

        footerGuard2Overrun = FALSE;
        for (i = 0; i < ARRAY_ELEMENTS(lpFooter->Guard2); ++i) {
            if (lpFooter->Guard2[i] != GUARD_DWORD_FILL) {
                footerGuard2Overrun = TRUE;
                break;
            }
        }

        lpExtraMemory = (LPBYTE)(lpHeader + 1) + lpHeader->RealLength;
        extraMemoryOverrun = FALSE;
        byteLength = ROUND_UP_DWORD(lpHeader->RealLength) - lpHeader->RealLength;
        for (i = 0; i < byteLength; ++i) {
            if (lpExtraMemory[i] != BYTE_FILL_EXTRA) {
                extraMemoryOverrun = TRUE;
                break;
            }
        }

        if (headerGuardOverrun
        || footerGuardOverrun
        || footerGuard2Overrun
        || extraMemoryOverrun
        || (lpHeader->Signature != HEADER_SIGNATURE)
        || (lpFooter->Signature != FOOTER_SIGNATURE)
        || (lpFooter->BlockLength != lpHeader->BlockLength)) {

            DEBUG_PRINT(MEMALLOC,
                        ERROR,
                        ("Bad block: %x\n",
                        lpMemory
                        ));

            DEBUG_BREAK(MEMALLOC);

        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {

        DEBUG_PRINT(MEMALLOC,
                    FATAL,
                    ("Invalid block %x - exception occurred\n",
                    lpMemory
                    ));

        DEBUG_BREAK(MEMALLOC);

    }
}


LPVOID
InetLockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Locks a moveable memory block and increments the lock count. Checks block
    consistency

Arguments:

    hLocal  - handle of moveable memory to lock

Return Value:

    LPVOID
        pointer to locked memory

--*/

{
    LPDEBUG_MEMORY_HEADER lpHeader = NULL;
    UINT memFlags;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

    INET_ASSERT(lpHeader != NULL);

    InetCheckBlockConsistency((LPVOID)lpHeader);
    ++lpHeader->LockCount;

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemLock;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT((memFlags != LMEM_INVALID_HANDLE)
                && (lpHeader->LockCount == (LONG)(memFlags & LMEM_LOCKCOUNT))
                );

    return ++lpHeader;
}


BOOL
InetUnlockMemory(
    IN HLOCAL hLocal
    )

/*++

Routine Description:

    Unlocks a (locked!) moveable memory block

Arguments:

    hLocal  - handle (pointer) of block to unlock

Return Value:

    None.

--*/

{
    UINT memFlags;
    BOOL stillLocked;
    LPDEBUG_MEMORY_HEADER lpHeader;
    DWORD lockCount;

    memFlags = LocalFlags(hLocal);

    INET_ASSERT(memFlags != LMEM_INVALID_HANDLE);
    INET_ASSERT((memFlags & LMEM_LOCKCOUNT) >= 1);

    //
    // memory must be locked or LocalFlags would have returned error.
    // Lock memory again to get pointer to block, then unlock it.
    // There should still be at least one lock on the block
    //

    lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);
    LocalUnlock(hLocal);

    InetCheckBlockConsistency((LPVOID)lpHeader);

    GET_CALLERS_ADDRESS(&lpHeader->LastAccessReturnAddress[0],
                        &lpHeader->LastAccessReturnAddress[1]
                        );

    lpHeader->LastAccessOperation = MemUnlock;

    lockCount = --lpHeader->LockCount;
    stillLocked = LocalUnlock(hLocal);

    INET_ASSERT(stillLocked ? (lockCount > 0) : GetLastError() == NO_ERROR);

    return stillLocked;
}


UINT
InetMemorySize(
    IN HLOCAL hLocal,
    IN BOOL IsMoveable
    )

/*++

Routine Description:

    Returns allocated block size

Arguments:

    hLocal      - memory handle
    IsMoveable  - TRUE if hLocal is a handle to moveable memory >>> THAT IS NOT
                  LOCKED <<<

Return Value:

    UINT

--*/

{
    UINT size;
    UINT sizeInHeader;
    LPDEBUG_MEMORY_HEADER lpHeader;

    if (IsMoveable) {
        lpHeader = (LPDEBUG_MEMORY_HEADER)LocalLock(hLocal);

        INET_ASSERT(lpHeader != NULL);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize(hLocal);
        LocalUnlock(hLocal);
    } else {
        lpHeader = (LPDEBUG_MEMORY_HEADER)hLocal - 1;

        INET_ASSERT(lpHeader->Signature == HEADER_SIGNATURE);

        sizeInHeader = lpHeader->RealLength;
        size = LocalSize((HLOCAL)lpHeader);
    }

    INET_ASSERT((sizeInHeader <= size)
                && (size >= sizeof(DEBUG_MEMORY_HEADER) + sizeof(DEBUG_MEMORY_FOOTER))
                );

    return sizeInHeader;
}


BOOL
InetCheckDebugMemoryFreed(
    VOID
    )

/*++

Routine Description:

    Check that we don't have any memory allocated

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    if (ActualMemoryAllocated || (MemoryFrees != MemoryAllocations)) {

        DEBUG_PRINT(MEMALLOC,
                    ERROR,
                    ("MemoryAllocated = %ld, MemoryAllocations = %lu, MemoryFrees = %lu\n",
                    ActualMemoryAllocated,
                    MemoryAllocations,
                    MemoryFrees
                    ));

        DEBUG_BREAK(MEMALLOC);

        return FALSE;
    }
    return TRUE;
}

#if defined(i386)


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\perfdiag.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    perfdiag.cxx

Abstract:

    Performance diagnostics

    Contents:
        WininetPerfLog
        PerfSleep
        PerfSelect
        PerfWaitForSingleObject
        (CPerfDiag::get_next_record)
        CPerfDiag::CPerfDiag
        CPerfDiag::~CPerfDiag
        CPerfDiag::Log(DWORD, DWORD)
        CPerfDiag::Log(DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Log(DWORD, DWORD, DWORD, DWORD, HINTERNET)
        CPerfDiag::Dump
        (map_perf_event)
        (map_callback_status)
        (map_async_request)
        (map_thread_pri)
        (map_length)

Author:

    Richard L Firth (rfirth) 24-Jan-1997

Revision History:

    24-Jan-1997 rfirth
        Created

--*/

#include <wininetp.h>

#if defined(USE_PERF_DIAG)

#include <perfdiag.hxx>

//
// global data
//

GLOBAL CPerfDiag * GlobalPerfDiag = NULL;
GLOBAL BOOL GlobalDumpPerfToFile = TRUE;

//
// private prototypes
//

PRIVATE LPSTR map_perf_event(DWORD dwEvent);
PRIVATE LPSTR map_callback_status(DWORD dwStatus);
PRIVATE LPSTR map_async_request(DWORD dwRequest);
PRIVATE LPSTR map_thread_pri(DWORD dwPriority);
PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf);

//
// APIs
//

INTERNETAPI_(void) WininetPerfLog(
    IN DWORD dwEvent,
    IN DWORD dwInfo1,
    IN DWORD dwInfo2,
    IN HINTERNET hInternet
    ) {
    if (!GlobalPerfDiag) {
        GlobalPerfDiag = new CPerfDiag;
    }
    if (GlobalPerfDiag) {
        GlobalPerfDiag->Log(dwEvent, dwInfo1, dwInfo2, GetCurrentThreadId(), hInternet);
    }
}

//
// functions
//

VOID PerfSleep(DWORD dwMilliseconds) {
    PERF_LOG(PE_YIELD_SLEEP_START);
    Sleep(dwMilliseconds);
    PERF_LOG(PE_YIELD_SLEEP_END);
}

int PerfSelect(int nfds,	
    fd_set FAR * readfds,	
    fd_set FAR * writefds,	
    fd_set FAR * exceptfds,	
    const struct timeval FAR * timeout 	
    ) {
    PERF_LOG(PE_YIELD_SELECT_START);

    int n = _I_select(nfds, readfds, writefds, exceptfds, timeout);

    PERF_LOG(PE_YIELD_SELECT_END);
    return n;
}

DWORD PerfWaitForSingleObject(
    HANDLE hObject,
    DWORD dwTimeout
    ) {
    PERF_LOG(PE_YIELD_OBJECT_WAIT_START);

    DWORD result = WaitForSingleObject(hObject, dwTimeout);

    PERF_LOG(PE_YIELD_OBJECT_WAIT_END);

    return result;
}

//
// private methods
//

LPPERF_INFO CPerfDiag::get_next_record(VOID) {

    if (!m_lpbPerfBuffer || m_bFull) {
        return NULL;
    }

    LPBYTE lpbCurrent;
    LPBYTE lpbNext;
    LPBYTE result;

    do {
        lpbCurrent = m_lpbNext;
        lpbNext = lpbCurrent + sizeof(PERF_INFO);
        result = (LPBYTE)InterlockedExchangePointer((PVOID*)&m_lpbNext, lpbNext);
    } while ((result != (LPBYTE)lpbCurrent) && (lpbCurrent < m_lpbEnd));
    if (lpbCurrent >= m_lpbEnd) {
        m_bFull = TRUE;
        OutputDebugString("*** Wininet performance log is full!\n");
        lpbCurrent = NULL;
    }
    return (LPPERF_INFO)lpbCurrent;
}

//
// public methods
//

CPerfDiag::CPerfDiag() {
    m_lpbPerfBuffer = NULL;
    m_dwPerfBufferLen = 0;
    m_lpbEnd = NULL;
    m_lpbNext = NULL;
    m_bFull = FALSE;
    m_bStarted = FALSE;
    m_bStartFinished = FALSE;
    m_liStartTime.QuadPart = 0i64;
    perf_start();
}

CPerfDiag::~CPerfDiag() {
    free_perf_buffer();
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo) {

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo) {
        Log(dwEvent, dwInfo, 0, lpThreadInfo->ThreadId, lpThreadInfo->hObject);
    }
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwThreadId, HINTERNET hInternet) {
    Log(dwEvent, dwInfo, 0, dwThreadId, hInternet);
}

VOID CPerfDiag::Log(DWORD dwEvent, DWORD dwInfo, DWORD dwInfo2, DWORD dwThreadId, HINTERNET hInternet) {

    //if (!m_bStarted) {
    //    perf_start();
    //}

    LPPERF_INFO lpInfo = get_next_record();

    if (!lpInfo) {
        return;
    }

    lpInfo->hInternet = hInternet;
    lpInfo->dwThreadId = dwThreadId;
    lpInfo->dwThreadPriority = GetThreadPriority(GetCurrentThread());
    lpInfo->dwEvent = dwEvent;
    lpInfo->dwInfo = dwInfo;
    lpInfo->dwInfo2 = dwInfo2;
    get_time(lpInfo);
}

VOID CPerfDiag::Dump(VOID) {

    HANDLE hFile = INVALID_HANDLE_VALUE;
    static const char PerfFileName[] = "WININET.PRF";

    if (GlobalDumpPerfToFile) {
        hFile = CreateFile((LPCSTR)PerfFileName,
                           GENERIC_WRITE,
                           FILE_SHARE_READ,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           INVALID_HANDLE_VALUE
                           );
        if (hFile == INVALID_HANDLE_VALUE) {
            OutputDebugString("failed to create perf file ");
            OutputDebugString((LPCSTR)PerfFileName);
            OutputDebugString("\n");
            GlobalDumpPerfToFile = FALSE;
        }
    }

    LARGE_INTEGER liFrequency;
    LONGLONG div1;
    LONGLONG div2;

    QueryPerformanceFrequency(&liFrequency);
    div1 = liFrequency.QuadPart;
    div2 = div1 / 1000000;

    LPPERF_INFO lpInfo;
    int record = 1;

    for (lpInfo = (LPPERF_INFO)m_lpbPerfBuffer; lpInfo != (LPPERF_INFO)m_lpbNext; ++lpInfo) {

        char buf[1024];
        LONGLONG ticks;
        DWORD microseconds;
        DWORD seconds;
        DWORD minutes;

        ticks = lpInfo->liTime.QuadPart - m_liStartTime.QuadPart;
        seconds = (DWORD)(ticks / div1);
        microseconds = (DWORD)((ticks % div1) / div2);

        //
        // don't understand why I have to do this? Win95 only (you could have guessed)
        // rounding error?
        //

        while (microseconds >= 1000000) {
            microseconds -= 1000000;
            ++seconds;
        }
        minutes = seconds / 60;
        seconds = seconds % 60;

        char lenbuf[32];
        char lenbuf2[32];

        int nChars = wsprintf(buf,
                              "%5d: Delta=%.2d:%.2d.%.6d TID=%08x Pri=%-8s hReq=%06x Info=%08x %-24s %-22s %s\r\n",
                              record,
                              minutes,
                              seconds,
                              microseconds,
                              lpInfo->dwThreadId,
                              map_thread_pri(lpInfo->dwThreadPriority),
                              lpInfo->hInternet,
                              lpInfo->dwInfo,
                              map_perf_event(lpInfo->dwEvent),
                              ((lpInfo->dwEvent == PE_APP_CALLBACK_START)
                              || (lpInfo->dwEvent == PE_APP_CALLBACK_END))
                                 ? map_callback_status(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_WORKER_REQUEST_START)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_START)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_CLIENT_REQUEST_QUEUED))
                                 ? map_async_request(lpInfo->dwInfo)
                              : (((lpInfo->dwEvent == PE_SEND_END)
                              || (lpInfo->dwEvent == PE_RECEIVE_END))
                                 ? map_length(lpInfo->dwInfo2, lenbuf)
                              : (((lpInfo->dwEvent == PE_ENTER_PATH)
                              || (lpInfo->dwEvent == PE_LEAVE_PATH)
                              || (lpInfo->dwEvent == PE_TRACE_PATH))
                                 ? (LPSTR)lpInfo->dwInfo2
                                 : ""))),
                              (((lpInfo->dwEvent == PE_CLIENT_REQUEST_END)
                              || (lpInfo->dwEvent == PE_WORKER_REQUEST_END))
                              && ((lpInfo->dwInfo == AR_INTERNET_READ_FILE)
                              || (lpInfo->dwInfo == AR_INTERNET_QUERY_DATA_AVAILABLE)))
                                 ? map_length(lpInfo->dwInfo2, lenbuf2)
                                 : ""
                             );
        if (GlobalDumpPerfToFile) {

            DWORD nWritten;

            WriteFile(hFile, buf, nChars, &nWritten, NULL);
        } else {
            OutputDebugString(buf);
        }
        ++record;
    }
    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile);
    }
}


PRIVATE LPSTR map_perf_event(DWORD dwEvent) {
    switch (dwEvent) {
    case PE_START:                      return "START";
    case PE_END:                        return "END";
    case PE_CLIENT_REQUEST_START:       return "CLIENT_REQUEST_START";
    case PE_CLIENT_REQUEST_END:         return "CLIENT_REQUEST_END";
    case PE_CLIENT_REQUEST_QUEUED:      return "CLIENT_REQUEST_QUEUED";
    case PE_WORKER_REQUEST_START:       return "WORKER_REQUEST_START";
    case PE_WORKER_REQUEST_END:         return "WORKER_REQUEST_END";
    case PE_APP_CALLBACK_START:         return "APP_CALLBACK_START";
    case PE_APP_CALLBACK_END:           return "APP_CALLBACK_END";
    case PE_NAMERES_START:              return "NAMERES_START";
    case PE_NAMERES_END:                return "NAMERES_END";
    case PE_CONNECT_START:              return "CONNECT_START";
    case PE_CONNECT_END:                return "CONNECT_END";
    case PE_SEND_START:                 return "SEND_START";
    case PE_SEND_END:                   return "SEND_END";
    case PE_RECEIVE_START:              return "RECEIVE_START";
    case PE_RECEIVE_END:                return "RECEIVE_END";
    case PE_PEEK_RECEIVE_START:         return "PEEK_RECEIVE_START";
    case PE_PEEK_RECEIVE_END:           return "PEEK_RECEIVE_END";
    case PE_SOCKET_CLOSE_START:         return "SOCKET_CLOSE_START";
    case PE_SOCKET_CLOSE_END:           return "SOCKET_CLOSE_END";
    case PE_ACQUIRE_KEEP_ALIVE:         return "ACQUIRE_KEEP_ALIVE";
    case PE_RELEASE_KEEP_ALIVE:         return "RELEASE_KEEP_ALIVE";
    case PE_SOCKET_ERROR:               return "SOCKET_ERROR";
    case PE_CACHE_READ_CHECK_START:     return "CACHE_READ_CHECK_START";
    case PE_CACHE_READ_CHECK_END:       return "CACHE_READ_CHECK_END";
    case PE_CACHE_WRITE_CHECK_START:    return "CACHE_WRITE_CHECK_START";
    case PE_CACHE_WRITE_CHECK_END:      return "CACHE_WRITE_CHECK_END";
    case PE_CACHE_RETRIEVE_START:       return "CACHE_RETRIEVE_START";
    case PE_CACHE_RETRIEVE_END:         return "CACHE_RETRIEVE_END";
    case PE_CACHE_READ_START:           return "CACHE_READ_START";
    case PE_CACHE_READ_END:             return "CACHE_READ_END";
    case PE_CACHE_WRITE_START:          return "CACHE_WRITE_START";
    case PE_CACHE_WRITE_END:            return "CACHE_WRITE_END";
    case PE_CACHE_CREATE_FILE_START:    return "CACHE_CREATE_FILE_START";
    case PE_CACHE_CREATE_FILE_END:      return "CACHE_CREATE_FILE_END";
    case PE_CACHE_CLOSE_FILE_START:     return "CACHE_CLOSE_FILE_START";
    case PE_CACHE_CLOSE_FILE_END:       return "CACHE_CLOSE_FILE_END";
    case PE_CACHE_EXPIRY_CHECK_START:   return "CACHE_EXPIRY_CHECK_START";
    case PE_CACHE_EXPIRY_CHECK_END:     return "CACHE_EXPIRY_CHECK_END";
    case PE_YIELD_SELECT_START:         return "YIELD_SELECT_START";
    case PE_YIELD_SELECT_END:           return "YIELD_SELECT_END";
    case PE_YIELD_OBJECT_WAIT_START:    return "YIELD_OBJECT_WAIT_START";
    case PE_YIELD_OBJECT_WAIT_END:      return "YIELD_OBJECT_WAIT_END";
    case PE_YIELD_SLEEP_START:          return "YIELD_SLEEP_START";
    case PE_YIELD_SLEEP_END:            return "YIELD_SLEEP_END";
    case PE_TRACE:                      return "TRACE";
    case PE_ENTER_PATH:                 return "ENTER_PATH";
    case PE_LEAVE_PATH:                 return "LEAVE_PATH";
    case PE_TRACE_PATH:                 return "TRACE_PATH";
    }
    return "?";
}

PRIVATE LPSTR map_callback_status(DWORD dwStatus) {
    switch (dwStatus) {
    case INTERNET_STATUS_RESOLVING_NAME:        return "RESOLVING_NAME";
    case INTERNET_STATUS_NAME_RESOLVED:         return "NAME_RESOLVED";
    case INTERNET_STATUS_CONNECTING_TO_SERVER:  return "CONNECTING_TO_SERVER";
    case INTERNET_STATUS_CONNECTED_TO_SERVER:   return "CONNECTED_TO_SERVER";
    case INTERNET_STATUS_SENDING_REQUEST:       return "SENDING_REQUEST";
    case INTERNET_STATUS_REQUEST_SENT:          return "REQUEST_SENT";
    case INTERNET_STATUS_RECEIVING_RESPONSE:    return "RECEIVING_RESPONSE";
    case INTERNET_STATUS_RESPONSE_RECEIVED:     return "RESPONSE_RECEIVED";
    case INTERNET_STATUS_CTL_RESPONSE_RECEIVED: return "CTL_RESPONSE_RECEIVED";
    case INTERNET_STATUS_PREFETCH:              return "PREFETCH";
    case INTERNET_STATUS_CLOSING_CONNECTION:    return "CLOSING_CONNECTION";
    case INTERNET_STATUS_CONNECTION_CLOSED:     return "CONNECTION_CLOSED";
    case INTERNET_STATUS_HANDLE_CREATED:        return "HANDLE_CREATED";
    case INTERNET_STATUS_HANDLE_CLOSING:        return "HANDLE_CLOSING";
    case INTERNET_STATUS_REQUEST_COMPLETE:      return "REQUEST_COMPLETE";
    case INTERNET_STATUS_REDIRECT:              return "REDIRECT";
    case INTERNET_STATUS_STATE_CHANGE:          return "STATE_CHANGE";
    }
    return "?";
}

PRIVATE LPSTR map_async_request(DWORD dwRequest) {
    switch (dwRequest) {
    case AR_INTERNET_CONNECT:               return "InternetConnect";
    case AR_INTERNET_OPEN_URL:              return "InternetOpenUrl";
    case AR_INTERNET_READ_FILE:             return "InternetReadFile";
    case AR_INTERNET_WRITE_FILE:            return "InternetWriteFile";
    case AR_INTERNET_QUERY_DATA_AVAILABLE:  return "InternetQueryDataAvailable";
    case AR_INTERNET_FIND_NEXT_FILE:        return "InternetFindNextFile";
    case AR_FTP_FIND_FIRST_FILE:            return "FtpFindFirstFile";
    case AR_FTP_GET_FILE:                   return "FtpGetFile";
    case AR_FTP_PUT_FILE:                   return "FtpPutFile";
    case AR_FTP_DELETE_FILE:                return "FtpDeleteFile";
    case AR_FTP_RENAME_FILE:                return "FtpRenameFile";
    case AR_FTP_OPEN_FILE:                  return "FtpOpenFile";
    case AR_FTP_CREATE_DIRECTORY:           return "FtpCreateDirectory";
    case AR_FTP_REMOVE_DIRECTORY:           return "FtpRemoveDirectory";
    case AR_FTP_SET_CURRENT_DIRECTORY:      return "FtpSetCurrentDirectory";
    case AR_FTP_GET_CURRENT_DIRECTORY:      return "FtpGetCurrentDirectory";
    case AR_GOPHER_FIND_FIRST_FILE:         return "GopherFindFirstFile";
    case AR_GOPHER_OPEN_FILE:               return "GopherOpenFile";
    case AR_GOPHER_GET_ATTRIBUTE:           return "GopherGetAttribute";
    case AR_HTTP_SEND_REQUEST:              return "HttpSendRequest";
    case AR_READ_PREFETCH:                  return "READ_PREFETCH";
    case AR_SYNC_EVENT:                     return "SYNC_EVENT";
    case AR_TIMER_EVENT:                    return "TIMER_EVENT";
    }
    return "?";
}

PRIVATE LPSTR map_thread_pri(DWORD dwPriority) {
    switch (dwPriority) {
    case THREAD_PRIORITY_ABOVE_NORMAL:
        return "ABOVE";

    case THREAD_PRIORITY_BELOW_NORMAL:
        return "BELOW";

    case THREAD_PRIORITY_HIGHEST:
        return "HIGHEST";

    case THREAD_PRIORITY_IDLE:
        return "IDLE";

    case THREAD_PRIORITY_LOWEST:
        return "LOWEST";

    case THREAD_PRIORITY_NORMAL:
        return "NORMAL";

    case THREAD_PRIORITY_TIME_CRITICAL:
        return "TIMECRIT";
    }
    return "?";
}

PRIVATE LPSTR map_length(DWORD dwLength, LPSTR lpBuf) {
    wsprintf(lpBuf, "%d", dwLength);
    return lpBuf;
}

#endif // defined(USE_PERF_DIAG)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\inetdbg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    inetdbg.cxx

Abstract:

    Debugging functions for internet DLL

    Contents:
        InternetDebugInitialize
        InternetDebugTerminate
        InternetGetDebugInfo
        InternetSetDebugInfo
        InternetOpenDebugFile
        InternetReopenDebugFile
        InternetCloseDebugFile
        InternetFlushDebugFile
        InternetDebugSetControlFlags
        InternetDebugResetControlFlags
        InternetDebugEnter
        InternetDebugLeave
        InternetDebugError
        InternetDebugPrint
        (InternetDebugPrintString)
        InternetDebugPrintf
        InternetDebugOut
        InternetDebugDump
        InternetDebugDumpFormat
        InternetAssert
        InternetGetDebugVariable
        (InternetGetDebugVariableString)
        InternetMapError
        InternetMapStatus
        InternetMapOption
        InternetMapHttpOption
        InternetMapHttpState
        InternetMapHttpStateFlag
        InternetMapAsyncRequest
        InternetMapHandleType
        InternetMapScheme
        InternetMapOpenType
        InternetMapService
        (ExtractFileName)
        (SetDebugPrefix)
        SourceFilename
        InitSymLib
        TermSymLib
        GetDebugSymbol
        x86SleazeCallStack
        x86SleazeCallersAddress

Author:

    Richard L Firth (rfirth) 13-Feb-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    13-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <ieverp.h>
#include "rprintf.h"
#include <imagehlp.h>
#include "autodial.h"

#ifdef ENABLE_DEBUG

//
// private manifests
//

#define SWITCH_VARIABLE_NAME        "WininetDebugging"
#define CONTROL_VARIABLE_NAME       "WininetControl"
#define CATEGORY_VARIABLE_NAME      "WininetCategory"
#define ERROR_VARIABLE_NAME         "WininetError"
#define BREAK_VARIABLE_NAME         "WininetBreak"
#define DEFAULT_LOG_VARIABLE_NAME   "WininetLog"
#define CHECK_LIST_VARIABLE_NAME    "WininetCheckSerializedList"
#define LOG_FILE_VARIABLE_NAME      "WininetLogFile"
#define INDENT_VARIABLE_NAME        "WininetLogIndent"
#define NO_PID_IN_LOG_FILENAME     "WininetNoPidInLogFilename"

#define DEFAULT_LOG_FILE_NAME       "WININET.LOG"

#define ENVIRONMENT_VARIABLE_BUFFER_LENGTH  80

#define PRINTF_STACK_BUFFER_LENGTH  (4 K)

//
// private macros
//

#define CASE_OF(constant)   case constant: return # constant

//
// private prototypes
//

PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    );

PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    );

PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    );
//
//
// these variables are employed in macros, so must be public
//

PUBLIC DWORD InternetDebugErrorLevel = DBG_ERROR;
PUBLIC DWORD InternetDebugControlFlags = DBG_NO_DEBUG;
PUBLIC DWORD InternetDebugCategoryFlags = 0;
PUBLIC DWORD InternetDebugBreakFlags = 0;

//
// these variables are only accessed in this module, so can be private
//

PRIVATE int InternetDebugIndentIncrement = 2;
PRIVATE HANDLE InternetDebugFileHandle = INVALID_HANDLE_VALUE;
PRIVATE char InternetDebugFilename[MAX_PATH + 1] = DEFAULT_LOG_FILE_NAME;
PRIVATE BOOL InternetDebugEnabled = TRUE;
PRIVATE DWORD InternetDebugStartTime = 0;

extern "C" {
BOOL UrlcacheDebugEnabled = FALSE;
#if defined(UNIX) && defined(ux10)
/* Temporary fix for Apogee Compiler bug on HP only */
extern BOOL fCheckEntryOnList;
#else
BOOL fCheckEntryOnList;
#endif /* UNIX */
}

//
// high frequency performance counter globals
//


PRIVATE LONGLONG ftInit;  // initial local time
PRIVATE LONGLONG pcInit;  // initial perf counter
PRIVATE LONGLONG pcFreq;  // perf counter frequency

//
// functions
//


VOID
InternetDebugInitialize(
    VOID
    )

/*++

Routine Description:

    reads environment INETDBG flags and opens debug log file if required

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // ensure registry key open (normally done in GlobalDataInitialize() later)
    //

    EnsureInternetSettingsKeyCached();

    //
    // record the starting tick count for cumulative deltas
    //

    InternetDebugStartTime = GetTickCountWrap();

    if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq) {

        QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
        SYSTEMTIME st;
        GetLocalTime (&st);
        SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
    }

    //
    // check see if there are any debug variable overrides in the environment
    // or the registry. If "WininetLog=<!0>" is set then we use the flags that
    // are most commonly used to generate WININET.LOG, with no console or
    // debugger output. We allow the other variables to be overridden
    //

    BOOL defaultDebugVariables = FALSE;

    InternetGetDebugVariable(DEFAULT_LOG_VARIABLE_NAME, (LPDWORD)&defaultDebugVariables);
    if (defaultDebugVariables) {
        InternetDebugEnabled = TRUE;
        InternetDebugControlFlags = INTERNET_DEBUG_CONTROL_DEFAULT;
        InternetDebugCategoryFlags = INTERNET_DEBUG_CATEGORY_DEFAULT;
        InternetDebugErrorLevel = INTERNET_DEBUG_ERROR_LEVEL_DEFAULT;
        InternetDebugBreakFlags = 0;
    }
    InternetGetDebugVariable(SWITCH_VARIABLE_NAME, (LPDWORD)&InternetDebugEnabled);
    InternetGetDebugVariable(CONTROL_VARIABLE_NAME, &InternetDebugControlFlags);
    InternetGetDebugVariable(CATEGORY_VARIABLE_NAME, &InternetDebugCategoryFlags);
    InternetGetDebugVariable(ERROR_VARIABLE_NAME, &InternetDebugErrorLevel);
    InternetGetDebugVariable(BREAK_VARIABLE_NAME, &InternetDebugBreakFlags);
    InternetGetDebugVariable(CHECK_LIST_VARIABLE_NAME, (LPDWORD)&fCheckEntryOnList);
    InternetGetDebugVariable(INDENT_VARIABLE_NAME, (LPDWORD)&InternetDebugIndentIncrement);
    InternetGetDebugVariableString(LOG_FILE_VARIABLE_NAME,
                                   InternetDebugFilename,
                                   sizeof(InternetDebugFilename)
                                   );
    DWORD InternetNoPidInLogFilename=0;
    InternetGetDebugVariable(NO_PID_IN_LOG_FILENAME, &InternetNoPidInLogFilename);

    if (!InternetNoPidInLogFilename)
    {
        char szFullPathName[MAX_PATH + 1];
        LPSTR szExecutableName;

        if (GetModuleFileName(NULL, szFullPathName, sizeof(szFullPathName))) 
        {
            szExecutableName = StrRChr(szFullPathName, NULL, '\\');
            if (szExecutableName != NULL)
                ++szExecutableName;
            else
                szExecutableName = szFullPathName;
        } 
        else
            szExecutableName = "";

        DWORD cbFilenameLen = strlen(InternetDebugFilename);
        //                          ".xxxxx.yyy.#########.LOG" 
        DWORD cbProcessInfoLenMax = 1 + strlen(szExecutableName) + 1 + 9 + 1 + 3;

        if (cbProcessInfoLenMax < sizeof(InternetDebugFilename))
            wsprintf(InternetDebugFilename+cbFilenameLen, ".%s.%u.LOG", 
                szExecutableName,
                GetCurrentProcessId());
    };
    
    UrlcacheDebugEnabled = InternetDebugEnabled &&
        (InternetDebugCategoryFlags & DBG_CACHE);

    if ((InternetDebugIndentIncrement < 0) || (InternetDebugIndentIncrement > 32)) {
        InternetDebugIndentIncrement = 2;
    }

    //
    // quit now if debugging is disabled
    //

    if (!InternetDebugEnabled) {
        InternetDebugControlFlags |= (DBG_NO_DEBUG | DBG_NO_DATA_DUMP);
        return;
    }

    //
    // if we want to write debug output to file, open WININET.LOG in the current
    // directory. Open it in text mode, for write-only (by this process)
    //

    if (InternetDebugControlFlags & DBG_TO_FILE) {
        if (!InternetReopenDebugFile(InternetDebugFilename)) {
            InternetDebugControlFlags &= ~DBG_TO_FILE;
        }
    }
}


VOID
InternetDebugTerminate(
    VOID
    )

/*++

Routine Description:

    Performs any required debug termination

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_TO_FILE) {
        InternetCloseDebugFile();
    }
    InternetDebugControlFlags = DBG_NO_DEBUG;
}

DWORD
InternetGetDebugInfo(
    OUT LPINTERNET_DEBUG_INFO lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns the internal debug variables

Arguments:

    lpBuffer            - pointer to structure that receives the variables

    lpdwBufferLength    - IN: Length of buffer
                          OUT: length of returned data if successful, else
                          required length of buffer

Return Value:

    DWORD
        Success - ERROR_SUCCESS;

        Failure - ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD requiredLength;
    DWORD error;
    int filenameLength;

    filenameLength = ((InternetDebugFileHandle != INVALID_HANDLE_VALUE)
                        ? strlen(InternetDebugFilename) : 0) + 1;

    requiredLength = sizeof(*lpBuffer) + filenameLength;
    if ((lpBuffer != NULL) && (*lpdwBufferLength >= requiredLength)) {
        lpBuffer->ErrorLevel = InternetDebugErrorLevel;
        lpBuffer->ControlFlags = InternetDebugControlFlags;
        lpBuffer->CategoryFlags = InternetDebugCategoryFlags;
        lpBuffer->BreakFlags = InternetDebugBreakFlags;
        lpBuffer->IndentIncrement = InternetDebugIndentIncrement;
        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
            memcpy(lpBuffer->Filename, InternetDebugFilename, filenameLength);
        } else {
            lpBuffer->Filename[0] = '\0';
        }
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    *lpdwBufferLength = requiredLength;
    return error;
}


DWORD
InternetSetDebugInfo(
    IN LPINTERNET_DEBUG_INFO lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets the internal debugging variables to the values in the buffer. To make
    incrmental changes, the caller must first read the variables, change the
    bits they're interested in, then change the whole lot at one go

Arguments:

    lpBuffer        - pointer to structure that contains the variables

    dwBufferLength  - size of lpBuffer. Ignored

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    InternetDebugErrorLevel = lpBuffer->ErrorLevel;
    InternetDebugCategoryFlags = lpBuffer->CategoryFlags;
    InternetDebugControlFlags = lpBuffer->ControlFlags;
    InternetDebugBreakFlags = lpBuffer->BreakFlags;
    InternetDebugIndentIncrement = lpBuffer->IndentIncrement;

    //
    // handle the debug file. If we get an empty string, then (if we are logging
    // to a file), close the file.
    //
    // If the filename is exactly the same as we're already using, then the
    // caller doesn't want to change the log file
    //
    // If the filename is different, then we are being asked to create a new log
    // file: close the old and open the new. If we cannot open the new file then
    // set the filename to the NUL string in the debug buffer
    //

    if (lpBuffer->Filename[0]) {
        if (strcmp(InternetDebugFilename, lpBuffer->Filename) != 0) {
            InternetCloseDebugFile();
            InternetReopenDebugFile(lpBuffer->Filename);
            if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
                strcpy(InternetDebugFilename, lpBuffer->Filename);
            } else {
                lpBuffer->Filename[0] = '\0';
            }
        }
    } else {
        InternetCloseDebugFile();
    }
    return ERROR_SUCCESS;
}


BOOL
InternetOpenDebugFile(
    VOID
    )

/*++

Routine Description:

    Opens debug filename if not already open. Use InternetDebugFilename

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - file was opened

        FALSE   - file not opened (already open or error)

--*/

{
    if (InternetDebugFileHandle == INVALID_HANDLE_VALUE) {
        InternetDebugFileHandle = CreateFile(
            InternetDebugFilename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );
        return InternetDebugFileHandle != INVALID_HANDLE_VALUE;
    }
    return FALSE;
}


BOOL
InternetReopenDebugFile(
    IN LPSTR Filename
    )

/*++

Routine Description:

    (Re)opens a debug log file. Closes the current one if it is open

Arguments:

    Filename    - new file to open

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        InternetCloseDebugFile();
    }
    if (Filename && *Filename) {
        InternetDebugFileHandle = CreateFile(
            Filename,
            GENERIC_WRITE,
            FILE_SHARE_READ,
            NULL,  // lpSecurityAttributes
            (InternetDebugControlFlags & DBG_APPEND_FILE)
                ? OPEN_ALWAYS
                : CREATE_ALWAYS,
            FILE_ATTRIBUTE_NORMAL
            | FILE_FLAG_SEQUENTIAL_SCAN
            | ((InternetDebugControlFlags & DBG_FLUSH_OUTPUT)
                ? FILE_FLAG_WRITE_THROUGH
                : 0),
            NULL
            );

        //
        // put our start info in the log file. Mainly useful when we're
        // appending to the file
        //

        if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {

            SYSTEMTIME currentTime;
            char filespec[MAX_PATH + 1];
            LPSTR filename;

            if (GetModuleFileName(NULL, filespec, sizeof(filespec))) {
                filename = strrchr(filespec, '\\');
                if (filename != NULL) {
                    ++filename;
                } else {
                    filename = filespec;
                }
            } else {
                filename = "";
            }

            InternetDebugGetLocalTime(&currentTime, NULL);

            InternetDebugPrintf("\n"
                                ">>>> WinInet Version %d.%d Build %s.%d " __DATE__ " " __TIME__ "\n"
                                ">>>> Process %s [%d (%#x)] started at %02d:%02d:%02d.%03d %02d/%02d/%d\n",
                                InternetVersionInfo.dwMajorVersion,
                                InternetVersionInfo.dwMinorVersion,
                                VER_PRODUCTVERSION_STRING,
                                InternetBuildNumber,
                                filename,
                                GetCurrentProcessId(),
                                GetCurrentProcessId(),
                                currentTime.wHour,
                                currentTime.wMinute,
                                currentTime.wSecond,
                                currentTime.wMilliseconds,
                                currentTime.wMonth,
                                currentTime.wDay,
                                currentTime.wYear
                                );

            InternetDebugPrintf(">>>> Command line = %q\n", GetCommandLine());

            InternetDebugPrintf("\n"
                                "     InternetDebugErrorLevel      = %s [%d]\n"
                                "     InternetDebugControlFlags    = %#08x\n"
                                "     InternetDebugCategoryFlags   = %#08x\n"
                                "     InternetDebugBreakFlags      = %#08x\n"
                                "     InternetDebugIndentIncrement = %d\n"
                                "\n",
                                (InternetDebugErrorLevel == DBG_INFO)       ? "Info"
                                : (InternetDebugErrorLevel == DBG_WARNING)  ? "Warning"
                                : (InternetDebugErrorLevel == DBG_ERROR)    ? "Error"
                                : (InternetDebugErrorLevel == DBG_FATAL)    ? "Fatal"
                                : (InternetDebugErrorLevel == DBG_ALWAYS)   ? "Always"
                                : "?",
                                InternetDebugErrorLevel,
                                InternetDebugControlFlags,
                                InternetDebugCategoryFlags,
                                InternetDebugBreakFlags,
                                InternetDebugIndentIncrement
                                );
            return TRUE;
        }
    }
    return FALSE;
}


VOID
InternetCloseDebugFile(
    VOID
    )

/*++

Routine Description:

    Closes the current debug log file

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
        CloseHandle(InternetDebugFileHandle);
        InternetDebugFileHandle = INVALID_HANDLE_VALUE;
    }
}


VOID
InternetFlushDebugFile(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (InternetDebugFileHandle != INVALID_HANDLE_VALUE) {
        FlushFileBuffers(InternetDebugFileHandle);
    }
}


VOID
InternetDebugSetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets debug control flags

Arguments:

    dwFlags - flags to set

Return Value:

    None.

--*/

{
    InternetDebugControlFlags |= dwFlags;
}


VOID
InternetDebugResetControlFlags(
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Resets debug control flags

Arguments:

    dwFlags - flags to reset

Return Value:

    None.

--*/

{
    InternetDebugControlFlags &= ~dwFlags;
}


VOID
InternetDebugEnter(
    IN DWORD Category,
    IN DEBUG_FUNCTION_RETURN_TYPE ReturnType,
    IN LPCSTR Function,
    IN LPCSTR ParameterList OPTIONAL,
    IN ...
    )

/*++

Routine Description:

    Creates an INTERNET_DEBUG_RECORD for the current function and adds it to
    the per-thread (debug) call-tree

Arguments:

    Category        - category flags, e.g. DBG_FTP

    ReturnType      - type of data it returns

    Function        - name of the function. Must be global, static string

    ParameterList   - string describing parameters to function, or NULL if none

    ...             - parameters to function

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = NEW(INTERNET_DEBUG_RECORD);

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    pRecord->Stack = pThreadInfo->Stack;
    pRecord->Category = Category;
    pRecord->ReturnType = ReturnType;
    pRecord->Function = Function;
    pRecord->LastTime = GetTickCountWrap();
    pThreadInfo->Stack = pRecord;
    ++pThreadInfo->CallDepth;

    //
    // if the function's category (FTP, GOPHER, HTTP) is selected in the
    // category flags, then we dump the function entry information
    //

    if (InternetDebugCategoryFlags & Category) {

        char buf[4096];
        LPSTR bufptr;

        bufptr = buf;
        bufptr += rsprintf(bufptr, "%s(", Function);
        if (ARGUMENT_PRESENT(ParameterList)) {

            va_list parms;

            va_start(parms, ParameterList);
            bufptr += _sprintf(bufptr, (char*)ParameterList, parms);
            va_end(parms);
        }
        rsprintf(bufptr, ")\n");
        InternetDebugPrintString(buf);

        //
        // only increase the indentation if we will display debug information
        // for this category
        //

        pThreadInfo->IndentIncrement += InternetDebugIndentIncrement;
    }
}


VOID
InternetDebugLeave(
    IN DWORD_PTR Variable,
    IN LPCSTR Filename,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    Destroys the INTERNET_DEBUG_RECORD for the current function and dumps info
    about what the function is returning, if requested to do so

Arguments:

    Variable    - variable containing value being returned by function

    Filename    - name of file where DEBUG_LEAVE() invoked

    LineNumber  - and line number in Filename

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR format;
    LPSTR errstr;
    BOOL noVar;
    char formatBuf[128];
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);

    if (!pThreadInfo) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (!pRecord) {
        return;
    }

    //
    // we are about to output a diagnostic message to the debug log, debugger,
    // or console. First check that we are required to display messages at
    // this level. The level for function ENTER and LEAVE is INFO
    //

    // if (InternetDebugErrorLevel >= DBG_INFO) 
        {

        //
        // only display the string and reduce the indent if we are requested
        // for information about this category
        //

        errstr = NULL;
        noVar = FALSE;
        if (InternetDebugCategoryFlags & pRecord->Category) {
            switch (pRecord->ReturnType) {
            case None:
                format = "%s() returning VOID";
                noVar = TRUE;
                break;

            case Bool:
                Variable = (DWORD_PTR)(Variable ? "TRUE" : "FALSE");

                //
                // *** FALL THROUGH ***
                //

            case String:
                format = "%s() returning %s";
                break;

            case Int:
                format = "%s() returning %d";
                break;

            case Dword:
                format = "%s() returning %u";
                errstr = InternetMapError((DWORD)Variable);
                if (errstr != NULL) {
                    if (*errstr == '?') {
                        rsprintf(hexnumBuf, "%#x", Variable);
                        errstr = hexnumBuf;
                        format = "%s() returning %u [?] (%s)";
                    } else {
                        format = "%s() returning %u [%s]";
                    }
                }
                break;

            case Handle:
            case Pointer:
                if (Variable == 0) {
                    format = "%s() returning NULL";
                    noVar = TRUE;
                } else {
                    if (pRecord->ReturnType == Handle) {
                        format = "%s() returning handle %#x";
                    } else {
                        format = "%s() returning %#x";
                    }
                }
                break;

            default:

                INET_ASSERT(FALSE);

                break;
            }

            pThreadInfo->IndentIncrement -= InternetDebugIndentIncrement;
            if (pThreadInfo->IndentIncrement < 0) {
                pThreadInfo->IndentIncrement = 0;
            }

            //
            // add line number info, if requested
            //

            strcpy(formatBuf, format);
            if (!(InternetDebugControlFlags & DBG_NO_LINE_NUMBER)) {
                strcat(formatBuf, " (line %d)");
            }
            strcat(formatBuf, "\n");

            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {
                strcat(formatBuf, "\n");
            }

            //
            // dump the line, depending on requirements and number of arguments
            //

            if (noVar) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   LineNumber
                                   );
            } else if (errstr != NULL) {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   errstr,
                                   LineNumber
                                   );
            } else {
                InternetDebugPrint(formatBuf,
                                   pRecord->Function,
                                   Variable,
                                   LineNumber
                                   );
            }
/*
            //
            // output an empty line if we are required to separate API calls in
            // the log. Only do this if this is an API level function, and it
            // is the top-level function
            //

            if ((InternetDebugControlFlags & DBG_SEPARATE_APIS)
            && (pRecord->Stack == NULL)) {

                //
                // don't call InternetDebugPrint - we don't need timing, thread,
                // level etc. information just for the separator
                //

                InternetDebugOut("\n", FALSE);
            }
*/
        }
    }

    //
    // regardless of whether we are outputting debug info for this category,
    // remove the debug record and reduce the call-depth
    //

    --pThreadInfo->CallDepth;
    pThreadInfo->Stack = pRecord->Stack;

    DEL(pRecord);

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugError(
    IN DWORD Error
    )

/*++

Routine Description:

    Used to display that a function is returning an error. We try to display a
    symbolic name for the error too (as when we are returning a DWORD from a
    function, using DEBUG_LEAVE)

    Displays a string of the form:

        Foo() returning error 87 [ERROR_INVALID_PARAMETER]

Arguments:

    Error   - the error code

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO pThreadInfo;
    LPINTERNET_DEBUG_RECORD pRecord;
    LPSTR errstr;
    DWORD lastError;
    char hexnumBuf[15];

    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    //
    // seems that something in this path can nuke the last error, so we must
    // refresh it
    //

    lastError = GetLastError();

    pThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(pThreadInfo != NULL);
    INET_ASSERT(GetLastError() == lastError);

    if (pThreadInfo == NULL) {
        return;
    }

    pRecord = pThreadInfo->Stack;

    //INET_ASSERT(pRecord != NULL);

    if (pRecord == NULL) {
        return;
    }

    errstr = InternetMapError(Error);
    if ((errstr == NULL) || (*errstr == '?')) {
        rsprintf(hexnumBuf, "%#x", Error);
        errstr = hexnumBuf;
    }
    InternetDebugPrint("%s() returning %d [%s]\n",
                       pRecord->Function,
                       Error,
                       errstr
                       );

    //
    // refresh the last error, in case it was nuked
    //

    SetLastError(lastError);
}


VOID
InternetDebugPrint(
    IN LPSTR Format,
    ...
    )

/*++

Routine Description:

    Internet equivalent of printf()

Arguments:

    Format  - printf format string

    ...     - any extra args

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    va_list list;

    va_start(list, Format);
    _sprintf(bufptr, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    )

/*++

Routine Description:

    Internet equivalent of printf(), but takes valist as the args

Arguments:

    Format  - printf format string

    list    - stack frame of variable arguments

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    _sprintf(bufptr, Format, list);

    InternetDebugOut(buf, FALSE);
}


PRIVATE
VOID
InternetDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), except we perform no expansion on the string

Arguments:

    String  - already formatted string (may contain %s)

Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    char buf[PRINTF_STACK_BUFFER_LENGTH];
    LPSTR bufptr;

    bufptr = SetDebugPrefix(buf);
    if (bufptr == NULL) {
        return;
    }

    //
    // now append the string that the DEBUG_PRINT originally gave us
    //

    strcpy(bufptr, String);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugPrintf(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Same as InternetDebugPrint(), but we don't access the per-thread info
    (because we may not have any)

Arguments:

    Format  - printf format string

    ...     - any extra args


Return Value:

    None.

--*/

{
    if (InternetDebugControlFlags & DBG_NO_DEBUG) {
        return;
    }

    va_list list;
    char buf[PRINTF_STACK_BUFFER_LENGTH];

    va_start(list, Format);
    _sprintf(buf, Format, list);
    va_end(list);

    InternetDebugOut(buf, FALSE);
}


VOID
InternetDebugOut(
    IN LPSTR Buffer,
    IN BOOL Assert
    )

/*++

Routine Description:

    Writes a string somewhere - to the debug log file, to the console, or via
    the debugger, or any combination

Arguments:

    Buffer  - pointer to formatted buffer to write

    Assert  - TRUE if this function is being called from InternetAssert(), in
              which case we *always* write to the debugger. Of course, there
              may be no debugger attached, in which case no action is taken

Return Value:

    None.

--*/

{
    int buflen;
    DWORD written;

    buflen = strlen(Buffer);
    if ((InternetDebugControlFlags & DBG_TO_FILE)
    && (InternetDebugFileHandle != INVALID_HANDLE_VALUE)) {
        WriteFile(InternetDebugFileHandle, Buffer, buflen, &written, NULL);
        if (InternetDebugControlFlags & DBG_FLUSH_OUTPUT) {
            InternetFlushDebugFile();
        }
    }

    if (InternetDebugControlFlags & DBG_TO_CONSOLE) {
        WriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),
                     Buffer,
                     buflen,
                     &written,
                     0
                     );
    }

    if (Assert || (InternetDebugControlFlags & DBG_TO_DEBUGGER)) {
        OutputDebugString(Buffer);
    }
}


VOID
InternetDebugDump(
    IN LPSTR Text,
    IN LPBYTE Address,
    IN DWORD Size
    )

/*++

Routine Description:

    Dumps Size bytes at Address, in the time-honoured debug tradition

Arguments:

    Text    - to display before dumping data

    Address - start of buffer

    Size    - number of bytes

Return Value:

    None.

--*/

{
    //
    // if flags say no data dumps then quit
    //

    if (InternetDebugControlFlags & (DBG_NO_DEBUG | DBG_NO_DATA_DUMP)) {
        return;
    }

    //
    // display the introduction text, if any
    //

    if (Text) {
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrint(Text);
        } else {
            InternetDebugOut(Text, FALSE);
        }
    }

    char buf[128];

    //
    // display a line telling us how much data there is, if requested to
    //

    if (InternetDebugControlFlags & DBG_DUMP_LENGTH) {
        rsprintf(buf, "%d (%#x) bytes @ %#x\n", Size, Size, Address);
        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }
    }

    //
    // dump out the data, debug style
    //

    while (Size) {

        int len = InternetDebugDumpFormat(Address, Size, sizeof(BYTE), buf);

        //
        // if we are to indent the data to the current level, then display the
        // buffer via InternetDebugPrint() which will apply all the thread id,
        // indentation, and other options selected, else just display the data
        // via InternetDebugOut(), which will simply send it to the output media
        //

        if (InternetDebugControlFlags & DBG_INDENT_DUMP) {
            InternetDebugPrintString(buf);
        } else {
            InternetDebugOut(buf, FALSE);
        }

        Address += len;
        Size -= len;
    }
}


DWORD
InternetDebugDumpFormat(
    IN LPBYTE Address,
    IN DWORD Size,
    IN DWORD ElementSize,
    OUT LPSTR Buffer
    )

/*++

Routine Description:

    Formats Size bytes at Address, in the time-honoured debug tradition, for
    data dump purposes

Arguments:

    Address     - start of buffer

    Size        - number of bytes

    ElementSize - size of each word element in bytes

    Buffer      - pointer to output buffer, assumed to be large enough

Return Value:

    DWORD   - number of bytes formatted

--*/

{
    //
    // we (currently) only understand DWORD, WORD and BYTE dumps
    //

    if ((ElementSize != sizeof(DWORD)) && (ElementSize != sizeof(WORD))) {
        ElementSize = sizeof(BYTE);
    }

    static char spaces[] = "                                               ";    // 15 * 3 + 2
    int i, len;

    len = min(Size, 16);
    rsprintf(Buffer, "%08x  ", Address);

    //
    // dump the hex representation of each character or word - up to 16 per line
    //

    DWORD offset = 10;

    for (i = 0; i < len; i += ElementSize) {

        DWORD value;
        LPSTR formatString;

        switch (ElementSize) {
        case 4:
            formatString = "%08x ";
            value = *(LPDWORD)&Address[i];
            break;

        case 2:
            formatString = "%04x ";
            value = *(LPWORD)&Address[i] & 0xffff;
            break;

        default:
            formatString = ((i & 15) == 7) ? "%02.2x-" : "%02.2x ";
            value = Address[i] & 0xff;
            break;
        }
        rsprintf(&Buffer[offset], formatString, value);
        offset += ElementSize * 2 + 1;
    }

    //
    // write as many spaces as required to tab to ASCII field
    //

    memcpy(&Buffer[offset], spaces, (16 - len) * 3 + 2);
    offset += (16 - len) * 3 + 2;

    //
    // dump ASCII representation of each character
    //

    for (i = 0; i < len; ++i) {

        char ch;

        ch = Address[i];
        Buffer[offset + i] =  ((ch < 32) || (ch > 127)) ? '.' : ch;
    }

    Buffer[offset + i++] = '\r';
    Buffer[offset + i++] = '\n';
    Buffer[offset + i] = '\0';

    return len;
}


VOID
InternetAssert(
    IN LPSTR Assertion,
    IN LPSTR FileName,
    IN DWORD LineNumber
    )

/*++

Routine Description:

    displays assertion message at debugger and raised breakpoint exception

Arguments:

    Assertion   - string describing assertion which failed

    FileName    - module where assertion failure occurred

    LineNumber  - at this line number

Return Value:

    None.

--*/

{
    char buffer[512];

    rsprintf(buffer,
             "\n"
             "*** Wininet Assertion failed: %s\n"
             "*** Source file: %s\n"
             "*** Source line: %d\n"
             "*** Thread %08x\n"
             "\n",
             Assertion,
             FileName,
             LineNumber,
             GetCurrentThreadId()
             );
    InternetDebugOut(buffer, TRUE);

    //
    // break to the debugger, unless it is requested that we don't
    //

    if (!(InternetDebugControlFlags & DBG_NO_ASSERT_BREAK)) {
        DebugBreak();
    }
}


VOID
InternetGetDebugVariable(
    IN LPSTR lpszVariableName,
    OUT LPDWORD lpdwVariable
    )

/*++

Routine Description:

    Get debug variable. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpdwVariable        - returned variable

Return Value:

    None.

--*/

{
    DWORD len;
    char varbuf[ENVIRONMENT_VARIABLE_BUFFER_LENGTH];

    //
    // get the debug variables first from the environment, then - if not there -
    // from the registry
    //

    len = GetEnvironmentVariable(lpszVariableName, varbuf, sizeof(varbuf));
    if (len && len < sizeof(varbuf)) {
        *lpdwVariable = (DWORD)strtoul(varbuf, NULL, 0);
    } else {
        InternetReadRegistryDword(lpszVariableName, lpdwVariable);
    }
}


PRIVATE
VOID
InternetGetDebugVariableString(
    IN LPSTR lpszVariableName,
    OUT LPSTR lpszVariable,
    IN DWORD dwVariableLen
    )

/*++

Routine Description:

    Get debug variable string. First examine environment, then registry

Arguments:

    lpszVariableName    - variable name

    lpszVariable        - returned string variable

    dwVariableLen       - size of buffer

Return Value:

    None.

--*/

{
    if (GetEnvironmentVariable(lpszVariableName, lpszVariable, dwVariableLen) == 0) {

        char buf[MAX_PATH + 1];
        DWORD len = min(sizeof(buf), dwVariableLen);

        if (InternetReadRegistryString(lpszVariableName, buf, &len) == ERROR_SUCCESS) {
            memcpy(lpszVariable, buf, len + 1);
        }
    }
}

LPSTR
InternetMapChunkToken(
    IN CHUNK_TOKEN ctToken
    )
{
    switch(ctToken)
    {
        CASE_OF(CHUNK_TOKEN_DIGIT);
        CASE_OF(CHUNK_TOKEN_DATA);
        CASE_OF(CHUNK_TOKEN_COLON);
        CASE_OF(CHUNK_TOKEN_CR);
        CASE_OF(CHUNK_TOKEN_LF);
        CASE_OF(CHUNK_TOKEN_INVALID);

        default:
            return "?";

    }
}

LPSTR
InternetMapChunkState(
    IN CHUNK_STATE csState
    )
{
    switch(csState)
    {
        CASE_OF(CHUNK_STATE_START);
        CASE_OF(CHUNK_STATE_SIZE_PARSE);
        CASE_OF(CHUNK_STATE_SIZE_CRLF);
        CASE_OF(CHUNK_STATE_DATA_PARSE);
        CASE_OF(CHUNK_STATE_DATA_CRLF);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_NAME);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_VALUE);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_CRLF);
        CASE_OF(CHUNK_STATE_ZERO_FOOTER_FINAL_CRLF);
        CASE_OF(CHUNK_STATE_FINISHED);

        default:
            return "?";

    }
}


LPSTR
InternetMapError(
    IN DWORD Error
    )

/*++

Routine Description:

    Map error code to string. Try to get all errors that might ever be returned
    by an Internet function

Arguments:

    Error   - code to map

Return Value:

    LPSTR - pointer to symbolic error name

--*/

{
    switch (Error) {

    //
    // WINERROR errors
    //

    CASE_OF(ERROR_SUCCESS);
    CASE_OF(ERROR_INVALID_FUNCTION);
    CASE_OF(ERROR_FILE_NOT_FOUND);
    CASE_OF(ERROR_PATH_NOT_FOUND);
    CASE_OF(ERROR_TOO_MANY_OPEN_FILES);
    CASE_OF(ERROR_ACCESS_DENIED);
    CASE_OF(ERROR_INVALID_HANDLE);
    CASE_OF(ERROR_ARENA_TRASHED);
    CASE_OF(ERROR_NOT_ENOUGH_MEMORY);
    CASE_OF(ERROR_INVALID_BLOCK);
    CASE_OF(ERROR_BAD_ENVIRONMENT);
    CASE_OF(ERROR_BAD_FORMAT);
    CASE_OF(ERROR_INVALID_ACCESS);
    CASE_OF(ERROR_INVALID_DATA);
    CASE_OF(ERROR_OUTOFMEMORY);
    CASE_OF(ERROR_INVALID_DRIVE);
    CASE_OF(ERROR_CURRENT_DIRECTORY);
    CASE_OF(ERROR_NOT_SAME_DEVICE);
    CASE_OF(ERROR_NO_MORE_FILES);
    CASE_OF(ERROR_WRITE_PROTECT);
    CASE_OF(ERROR_BAD_UNIT);
    CASE_OF(ERROR_NOT_READY);
    CASE_OF(ERROR_BAD_COMMAND);
    CASE_OF(ERROR_CRC);
    CASE_OF(ERROR_BAD_LENGTH);
    CASE_OF(ERROR_SEEK);
    CASE_OF(ERROR_NOT_DOS_DISK);
    CASE_OF(ERROR_SECTOR_NOT_FOUND);
    CASE_OF(ERROR_OUT_OF_PAPER);
    CASE_OF(ERROR_WRITE_FAULT);
    CASE_OF(ERROR_READ_FAULT);
    CASE_OF(ERROR_GEN_FAILURE);
    CASE_OF(ERROR_SHARING_VIOLATION);
    CASE_OF(ERROR_LOCK_VIOLATION);
    CASE_OF(ERROR_WRONG_DISK);
    CASE_OF(ERROR_SHARING_BUFFER_EXCEEDED);
    CASE_OF(ERROR_HANDLE_EOF);
    CASE_OF(ERROR_HANDLE_DISK_FULL);
    CASE_OF(ERROR_NOT_SUPPORTED);
    CASE_OF(ERROR_REM_NOT_LIST);
    CASE_OF(ERROR_DUP_NAME);
    CASE_OF(ERROR_BAD_NETPATH);
    CASE_OF(ERROR_NETWORK_BUSY);
    CASE_OF(ERROR_DEV_NOT_EXIST);
    CASE_OF(ERROR_TOO_MANY_CMDS);
    CASE_OF(ERROR_ADAP_HDW_ERR);
    CASE_OF(ERROR_BAD_NET_RESP);
    CASE_OF(ERROR_UNEXP_NET_ERR);
    CASE_OF(ERROR_BAD_REM_ADAP);
    CASE_OF(ERROR_PRINTQ_FULL);
    CASE_OF(ERROR_NO_SPOOL_SPACE);
    CASE_OF(ERROR_PRINT_CANCELLED);
    CASE_OF(ERROR_NETNAME_DELETED);
    CASE_OF(ERROR_NETWORK_ACCESS_DENIED);
    CASE_OF(ERROR_BAD_DEV_TYPE);
    CASE_OF(ERROR_BAD_NET_NAME);
    CASE_OF(ERROR_TOO_MANY_NAMES);
    CASE_OF(ERROR_TOO_MANY_SESS);
    CASE_OF(ERROR_SHARING_PAUSED);
    CASE_OF(ERROR_REQ_NOT_ACCEP);
    CASE_OF(ERROR_REDIR_PAUSED);
    CASE_OF(ERROR_FILE_EXISTS);
    CASE_OF(ERROR_CANNOT_MAKE);
    CASE_OF(ERROR_FAIL_I24);
    CASE_OF(ERROR_OUT_OF_STRUCTURES);
    CASE_OF(ERROR_ALREADY_ASSIGNED);
    CASE_OF(ERROR_INVALID_PASSWORD);
    CASE_OF(ERROR_INVALID_PARAMETER);
    CASE_OF(ERROR_NET_WRITE_FAULT);
    CASE_OF(ERROR_NO_PROC_SLOTS);
    CASE_OF(ERROR_TOO_MANY_SEMAPHORES);
    CASE_OF(ERROR_EXCL_SEM_ALREADY_OWNED);
    CASE_OF(ERROR_SEM_IS_SET);
    CASE_OF(ERROR_TOO_MANY_SEM_REQUESTS);
    CASE_OF(ERROR_INVALID_AT_INTERRUPT_TIME);
    CASE_OF(ERROR_SEM_OWNER_DIED);
    CASE_OF(ERROR_SEM_USER_LIMIT);
    CASE_OF(ERROR_DISK_CHANGE);
    CASE_OF(ERROR_DRIVE_LOCKED);
    CASE_OF(ERROR_BROKEN_PIPE);
    CASE_OF(ERROR_OPEN_FAILED);
    CASE_OF(ERROR_BUFFER_OVERFLOW);
    CASE_OF(ERROR_DISK_FULL);
    CASE_OF(ERROR_NO_MORE_SEARCH_HANDLES);
    CASE_OF(ERROR_INVALID_TARGET_HANDLE);
    CASE_OF(ERROR_INVALID_CATEGORY);
    CASE_OF(ERROR_INVALID_VERIFY_SWITCH);
    CASE_OF(ERROR_BAD_DRIVER_LEVEL);
    CASE_OF(ERROR_CALL_NOT_IMPLEMENTED);
    CASE_OF(ERROR_SEM_TIMEOUT);
    CASE_OF(ERROR_INSUFFICIENT_BUFFER);
    CASE_OF(ERROR_INVALID_NAME);
    CASE_OF(ERROR_INVALID_LEVEL);
    CASE_OF(ERROR_NO_VOLUME_LABEL);
    CASE_OF(ERROR_MOD_NOT_FOUND);
    CASE_OF(ERROR_PROC_NOT_FOUND);
    CASE_OF(ERROR_WAIT_NO_CHILDREN);
    CASE_OF(ERROR_CHILD_NOT_COMPLETE);
    CASE_OF(ERROR_DIRECT_ACCESS_HANDLE);
    CASE_OF(ERROR_NEGATIVE_SEEK);
    CASE_OF(ERROR_SEEK_ON_DEVICE);
    CASE_OF(ERROR_DIR_NOT_ROOT);
    CASE_OF(ERROR_DIR_NOT_EMPTY);
    CASE_OF(ERROR_PATH_BUSY);
    CASE_OF(ERROR_SYSTEM_TRACE);
    CASE_OF(ERROR_INVALID_EVENT_COUNT);
    CASE_OF(ERROR_TOO_MANY_MUXWAITERS);
    CASE_OF(ERROR_INVALID_LIST_FORMAT);
    CASE_OF(ERROR_BAD_ARGUMENTS);
    CASE_OF(ERROR_BAD_PATHNAME);
    CASE_OF(ERROR_BUSY);
    CASE_OF(ERROR_CANCEL_VIOLATION);
    CASE_OF(ERROR_ALREADY_EXISTS);
    CASE_OF(ERROR_FILENAME_EXCED_RANGE);
    CASE_OF(ERROR_LOCKED);
    CASE_OF(ERROR_NESTING_NOT_ALLOWED);
    CASE_OF(ERROR_BAD_PIPE);
    CASE_OF(ERROR_PIPE_BUSY);
    CASE_OF(ERROR_NO_DATA);
    CASE_OF(ERROR_PIPE_NOT_CONNECTED);
    CASE_OF(ERROR_MORE_DATA);
    CASE_OF(ERROR_NO_MORE_ITEMS);
    CASE_OF(ERROR_NOT_OWNER);
    CASE_OF(ERROR_PARTIAL_COPY);
    CASE_OF(ERROR_MR_MID_NOT_FOUND);
    CASE_OF(ERROR_INVALID_ADDRESS);
    CASE_OF(ERROR_PIPE_CONNECTED);
    CASE_OF(ERROR_PIPE_LISTENING);
    CASE_OF(ERROR_OPERATION_ABORTED);
    CASE_OF(ERROR_IO_INCOMPLETE);
    CASE_OF(ERROR_IO_PENDING);
    CASE_OF(ERROR_NOACCESS);
    CASE_OF(ERROR_STACK_OVERFLOW);
    CASE_OF(ERROR_INVALID_FLAGS);
    CASE_OF(ERROR_NO_TOKEN);
    CASE_OF(ERROR_BADDB);
    CASE_OF(ERROR_BADKEY);
    CASE_OF(ERROR_CANTOPEN);
    CASE_OF(ERROR_CANTREAD);
    CASE_OF(ERROR_CANTWRITE);
    CASE_OF(ERROR_REGISTRY_RECOVERED);
    CASE_OF(ERROR_REGISTRY_CORRUPT);
    CASE_OF(ERROR_REGISTRY_IO_FAILED);
    CASE_OF(ERROR_NOT_REGISTRY_FILE);
    CASE_OF(ERROR_KEY_DELETED);
    CASE_OF(ERROR_CIRCULAR_DEPENDENCY);
    CASE_OF(ERROR_SERVICE_NOT_ACTIVE);
    CASE_OF(ERROR_DLL_INIT_FAILED);
    CASE_OF(ERROR_CANCELLED);
    CASE_OF(ERROR_BAD_USERNAME);
    CASE_OF(ERROR_LOGON_FAILURE);

    CASE_OF(WAIT_FAILED);
    //CASE_OF(WAIT_ABANDONED_0);
    CASE_OF(WAIT_TIMEOUT);
    CASE_OF(WAIT_IO_COMPLETION);
    //CASE_OF(STILL_ACTIVE);

    CASE_OF(RPC_S_INVALID_STRING_BINDING);
    CASE_OF(RPC_S_WRONG_KIND_OF_BINDING);
    CASE_OF(RPC_S_INVALID_BINDING);
    CASE_OF(RPC_S_PROTSEQ_NOT_SUPPORTED);
    CASE_OF(RPC_S_INVALID_RPC_PROTSEQ);
    CASE_OF(RPC_S_INVALID_STRING_UUID);
    CASE_OF(RPC_S_INVALID_ENDPOINT_FORMAT);
    CASE_OF(RPC_S_INVALID_NET_ADDR);
    CASE_OF(RPC_S_NO_ENDPOINT_FOUND);
    CASE_OF(RPC_S_INVALID_TIMEOUT);
    CASE_OF(RPC_S_OBJECT_NOT_FOUND);
    CASE_OF(RPC_S_ALREADY_REGISTERED);
    CASE_OF(RPC_S_TYPE_ALREADY_REGISTERED);
    CASE_OF(RPC_S_ALREADY_LISTENING);
    CASE_OF(RPC_S_NO_PROTSEQS_REGISTERED);
    CASE_OF(RPC_S_NOT_LISTENING);
    CASE_OF(RPC_S_UNKNOWN_MGR_TYPE);
    CASE_OF(RPC_S_UNKNOWN_IF);
    CASE_OF(RPC_S_NO_BINDINGS);
    CASE_OF(RPC_S_NO_PROTSEQS);
    CASE_OF(RPC_S_CANT_CREATE_ENDPOINT);
    CASE_OF(RPC_S_OUT_OF_RESOURCES);
    CASE_OF(RPC_S_SERVER_UNAVAILABLE);
    CASE_OF(RPC_S_SERVER_TOO_BUSY);
    CASE_OF(RPC_S_INVALID_NETWORK_OPTIONS);
    CASE_OF(RPC_S_NO_CALL_ACTIVE);
    CASE_OF(RPC_S_CALL_FAILED);
    CASE_OF(RPC_S_CALL_FAILED_DNE);
    CASE_OF(RPC_S_PROTOCOL_ERROR);
    CASE_OF(RPC_S_UNSUPPORTED_TRANS_SYN);
    CASE_OF(RPC_S_UNSUPPORTED_TYPE);
    CASE_OF(RPC_S_INVALID_TAG);
    CASE_OF(RPC_S_INVALID_BOUND);
    CASE_OF(RPC_S_NO_ENTRY_NAME);
    CASE_OF(RPC_S_INVALID_NAME_SYNTAX);
    CASE_OF(RPC_S_UNSUPPORTED_NAME_SYNTAX);
    CASE_OF(RPC_S_UUID_NO_ADDRESS);
    CASE_OF(RPC_S_DUPLICATE_ENDPOINT);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_TYPE);
    CASE_OF(RPC_S_MAX_CALLS_TOO_SMALL);
    CASE_OF(RPC_S_STRING_TOO_LONG);
    CASE_OF(RPC_S_PROTSEQ_NOT_FOUND);
    CASE_OF(RPC_S_PROCNUM_OUT_OF_RANGE);
    CASE_OF(RPC_S_BINDING_HAS_NO_AUTH);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_SERVICE);
    CASE_OF(RPC_S_UNKNOWN_AUTHN_LEVEL);
    CASE_OF(RPC_S_INVALID_AUTH_IDENTITY);
    CASE_OF(RPC_S_UNKNOWN_AUTHZ_SERVICE);
    CASE_OF(EPT_S_INVALID_ENTRY);
    CASE_OF(EPT_S_CANT_PERFORM_OP);
    CASE_OF(EPT_S_NOT_REGISTERED);
    CASE_OF(RPC_S_NOTHING_TO_EXPORT);
    CASE_OF(RPC_S_INCOMPLETE_NAME);
    CASE_OF(RPC_S_INVALID_VERS_OPTION);
    CASE_OF(RPC_S_NO_MORE_MEMBERS);
    CASE_OF(RPC_S_NOT_ALL_OBJS_UNEXPORTED);
    CASE_OF(RPC_S_INTERFACE_NOT_FOUND);
    CASE_OF(RPC_S_ENTRY_ALREADY_EXISTS);
    CASE_OF(RPC_S_ENTRY_NOT_FOUND);
    CASE_OF(RPC_S_NAME_SERVICE_UNAVAILABLE);
    CASE_OF(RPC_S_INVALID_NAF_ID);
    CASE_OF(RPC_S_CANNOT_SUPPORT);
    CASE_OF(RPC_S_NO_CONTEXT_AVAILABLE);
    CASE_OF(RPC_S_INTERNAL_ERROR);
    CASE_OF(RPC_S_ZERO_DIVIDE);
    CASE_OF(RPC_S_ADDRESS_ERROR);
    CASE_OF(RPC_S_FP_DIV_ZERO);
    CASE_OF(RPC_S_FP_UNDERFLOW);
    CASE_OF(RPC_S_FP_OVERFLOW);
    CASE_OF(RPC_X_NO_MORE_ENTRIES);
    CASE_OF(RPC_X_SS_CHAR_TRANS_OPEN_FAIL);
    CASE_OF(RPC_X_SS_CHAR_TRANS_SHORT_FILE);
    CASE_OF(RPC_X_SS_IN_NULL_CONTEXT);
    CASE_OF(RPC_X_SS_CONTEXT_DAMAGED);
    CASE_OF(RPC_X_SS_HANDLES_MISMATCH);
    CASE_OF(RPC_X_SS_CANNOT_GET_CALL_HANDLE);
    CASE_OF(RPC_X_NULL_REF_POINTER);
    CASE_OF(RPC_X_ENUM_VALUE_OUT_OF_RANGE);
    CASE_OF(RPC_X_BYTE_COUNT_TOO_SMALL);
    CASE_OF(RPC_X_BAD_STUB_DATA);


    //
    // WININET errors
    //

    CASE_OF(ERROR_INTERNET_OUT_OF_HANDLES);
    CASE_OF(ERROR_INTERNET_TIMEOUT);
    CASE_OF(ERROR_INTERNET_EXTENDED_ERROR);
    CASE_OF(ERROR_INTERNET_INTERNAL_ERROR);
    CASE_OF(ERROR_INTERNET_INVALID_URL);
    CASE_OF(ERROR_INTERNET_UNRECOGNIZED_SCHEME);
    CASE_OF(ERROR_INTERNET_NAME_NOT_RESOLVED);
    CASE_OF(ERROR_INTERNET_PROTOCOL_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_INVALID_OPTION);
    CASE_OF(ERROR_INTERNET_BAD_OPTION_LENGTH);
    CASE_OF(ERROR_INTERNET_OPTION_NOT_SETTABLE);
    CASE_OF(ERROR_INTERNET_SHUTDOWN);
    CASE_OF(ERROR_INTERNET_INCORRECT_USER_NAME);
    CASE_OF(ERROR_INTERNET_INCORRECT_PASSWORD);
    CASE_OF(ERROR_INTERNET_LOGIN_FAILURE);
    CASE_OF(ERROR_INTERNET_INVALID_OPERATION);
    CASE_OF(ERROR_INTERNET_OPERATION_CANCELLED);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_TYPE);
    CASE_OF(ERROR_INTERNET_INCORRECT_HANDLE_STATE);
    CASE_OF(ERROR_INTERNET_NOT_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_REGISTRY_VALUE_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_BAD_REGISTRY_PARAMETER);
    CASE_OF(ERROR_INTERNET_NO_DIRECT_ACCESS);
    CASE_OF(ERROR_INTERNET_NO_CONTEXT);
    CASE_OF(ERROR_INTERNET_NO_CALLBACK);
    CASE_OF(ERROR_INTERNET_REQUEST_PENDING);
    CASE_OF(ERROR_INTERNET_INCORRECT_FORMAT);
    CASE_OF(ERROR_INTERNET_ITEM_NOT_FOUND);
    CASE_OF(ERROR_INTERNET_CANNOT_CONNECT);
    CASE_OF(ERROR_INTERNET_CONNECTION_ABORTED);
    CASE_OF(ERROR_INTERNET_CONNECTION_RESET);
    CASE_OF(ERROR_INTERNET_FORCE_RETRY);
    CASE_OF(ERROR_INTERNET_INVALID_PROXY_REQUEST);
    CASE_OF(ERROR_INTERNET_NEED_UI);
    CASE_OF(ERROR_INTERNET_HANDLE_EXISTS);
    CASE_OF(ERROR_INTERNET_SEC_CERT_DATE_INVALID);
    CASE_OF(ERROR_INTERNET_SEC_CERT_CN_INVALID);
    CASE_OF(ERROR_INTERNET_HTTP_TO_HTTPS_ON_REDIR);
    CASE_OF(ERROR_INTERNET_HTTPS_TO_HTTP_ON_REDIR);
    CASE_OF(ERROR_INTERNET_MIXED_SECURITY);
    CASE_OF(ERROR_INTERNET_CHG_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_POST_IS_NON_SECURE);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED);
    CASE_OF(ERROR_INTERNET_INVALID_CA);
    CASE_OF(ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP);
    CASE_OF(ERROR_INTERNET_ASYNC_THREAD_FAILED);
    CASE_OF(ERROR_INTERNET_REDIRECT_SCHEME_CHANGE);
    CASE_OF(ERROR_INTERNET_DIALOG_PENDING);
    CASE_OF(ERROR_INTERNET_RETRY_DIALOG);
    CASE_OF(ERROR_INTERNET_NO_NEW_CONTAINERS);
    CASE_OF(ERROR_INTERNET_HTTPS_HTTP_SUBMIT_REDIR);
    CASE_OF(ERROR_INTERNET_INSERT_CDROM);
    CASE_OF(ERROR_INTERNET_FORTEZZA_LOGIN_NEEDED);
    CASE_OF(ERROR_INTERNET_SEC_CERT_ERRORS);
    CASE_OF(ERROR_INTERNET_SECURITY_CHANNEL_ERROR);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_CACHE_FILE);
    CASE_OF(ERROR_INTERNET_TCPIP_NOT_INSTALLED);
    CASE_OF(ERROR_INTERNET_OFFLINE);
    CASE_OF(ERROR_INTERNET_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_PROXY_SERVER_UNREACHABLE);
    CASE_OF(ERROR_INTERNET_BAD_AUTO_PROXY_SCRIPT);
    CASE_OF(ERROR_INTERNET_UNABLE_TO_DOWNLOAD_SCRIPT);
    CASE_OF(ERROR_INTERNET_SEC_INVALID_CERT);
    CASE_OF(ERROR_INTERNET_SEC_CERT_REVOKED);
    CASE_OF(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK);
    CASE_OF(ERROR_INTERNET_NOT_INITIALIZED);

    CASE_OF(ERROR_FTP_TRANSFER_IN_PROGRESS);
    CASE_OF(ERROR_FTP_DROPPED);
    CASE_OF(ERROR_FTP_NO_PASSIVE_MODE);

    CASE_OF(ERROR_GOPHER_PROTOCOL_ERROR);
    CASE_OF(ERROR_GOPHER_NOT_FILE);
    CASE_OF(ERROR_GOPHER_DATA_ERROR);
    CASE_OF(ERROR_GOPHER_END_OF_DATA);
    CASE_OF(ERROR_GOPHER_INVALID_LOCATOR);
    CASE_OF(ERROR_GOPHER_INCORRECT_LOCATOR_TYPE);
    CASE_OF(ERROR_GOPHER_NOT_GOPHER_PLUS);
    CASE_OF(ERROR_GOPHER_ATTRIBUTE_NOT_FOUND);
    CASE_OF(ERROR_GOPHER_UNKNOWN_LOCATOR);

    CASE_OF(ERROR_HTTP_HEADER_NOT_FOUND);
    CASE_OF(ERROR_HTTP_DOWNLEVEL_SERVER);
    CASE_OF(ERROR_HTTP_INVALID_SERVER_RESPONSE);
    CASE_OF(ERROR_HTTP_INVALID_HEADER);
    CASE_OF(ERROR_HTTP_INVALID_QUERY_REQUEST);
    CASE_OF(ERROR_HTTP_HEADER_ALREADY_EXISTS);
    CASE_OF(ERROR_HTTP_REDIRECT_FAILED);
    CASE_OF(ERROR_HTTP_NOT_REDIRECTED);
    CASE_OF(ERROR_HTTP_COOKIE_NEEDS_CONFIRMATION);
    CASE_OF(ERROR_HTTP_COOKIE_DECLINED);
    CASE_OF(ERROR_HTTP_REDIRECT_NEEDS_CONFIRMATION);

    //
    // internal WININET errors
    //

    CASE_OF(ERROR_INTERNET_INTERNAL_SOCKET_ERROR);
    CASE_OF(ERROR_INTERNET_CONNECTION_AVAILABLE);
    CASE_OF(ERROR_INTERNET_NO_KNOWN_SERVERS);
    CASE_OF(ERROR_INTERNET_PING_FAILED);
    CASE_OF(ERROR_INTERNET_NO_PING_SUPPORT);
    CASE_OF(ERROR_INTERNET_CACHE_SUCCESS);


    //
    // SSPI errors
    //

    CASE_OF(SEC_E_INSUFFICIENT_MEMORY);
    CASE_OF(SEC_E_INVALID_HANDLE);
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION);
    CASE_OF(SEC_E_TARGET_UNKNOWN);
    CASE_OF(SEC_E_INTERNAL_ERROR);
    CASE_OF(SEC_E_SECPKG_NOT_FOUND);
    CASE_OF(SEC_E_NOT_OWNER);
    CASE_OF(SEC_E_CANNOT_INSTALL);
    CASE_OF(SEC_E_INVALID_TOKEN);
    CASE_OF(SEC_E_CANNOT_PACK);
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED);
    CASE_OF(SEC_E_NO_IMPERSONATION);
    CASE_OF(SEC_E_LOGON_DENIED);
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS);
    CASE_OF(SEC_E_NO_CREDENTIALS);
    CASE_OF(SEC_E_MESSAGE_ALTERED);
    CASE_OF(SEC_E_OUT_OF_SEQUENCE);
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_NEEDED);
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE);
    CASE_OF(SEC_I_LOCAL_LOGON);
    CASE_OF(SEC_E_BAD_PKGID);
    CASE_OF(SEC_E_CONTEXT_EXPIRED);
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE);
    CASE_OF(SEC_E_WRONG_PRINCIPAL);


    //
    // WINSOCK errors
    //

    CASE_OF(WSAEINTR);
    CASE_OF(WSAEBADF);
    CASE_OF(WSAEACCES);
    CASE_OF(WSAEFAULT);
    CASE_OF(WSAEINVAL);
    CASE_OF(WSAEMFILE);
    CASE_OF(WSAEWOULDBLOCK);
    CASE_OF(WSAEINPROGRESS);
    CASE_OF(WSAEALREADY);
    CASE_OF(WSAENOTSOCK);
    CASE_OF(WSAEDESTADDRREQ);
    CASE_OF(WSAEMSGSIZE);
    CASE_OF(WSAEPROTOTYPE);
    CASE_OF(WSAENOPROTOOPT);
    CASE_OF(WSAEPROTONOSUPPORT);
    CASE_OF(WSAESOCKTNOSUPPORT);
    CASE_OF(WSAEOPNOTSUPP);
    CASE_OF(WSAEPFNOSUPPORT);
    CASE_OF(WSAEAFNOSUPPORT);
    CASE_OF(WSAEADDRINUSE);
    CASE_OF(WSAEADDRNOTAVAIL);
    CASE_OF(WSAENETDOWN);
    CASE_OF(WSAENETUNREACH);
    CASE_OF(WSAENETRESET);
    CASE_OF(WSAECONNABORTED);
    CASE_OF(WSAECONNRESET);
    CASE_OF(WSAENOBUFS);
    CASE_OF(WSAEISCONN);
    CASE_OF(WSAENOTCONN);
    CASE_OF(WSAESHUTDOWN);
    CASE_OF(WSAETOOMANYREFS);
    CASE_OF(WSAETIMEDOUT);
    CASE_OF(WSAECONNREFUSED);
    CASE_OF(WSAELOOP);
    CASE_OF(WSAENAMETOOLONG);
    CASE_OF(WSAEHOSTDOWN);
    CASE_OF(WSAEHOSTUNREACH);
    CASE_OF(WSAENOTEMPTY);
    CASE_OF(WSAEPROCLIM);
    CASE_OF(WSAEUSERS);
    CASE_OF(WSAEDQUOT);
    CASE_OF(WSAESTALE);
    CASE_OF(WSAEREMOTE);
    CASE_OF(WSAEDISCON);
    CASE_OF(WSASYSNOTREADY);
    CASE_OF(WSAVERNOTSUPPORTED);
    CASE_OF(WSANOTINITIALISED);
    CASE_OF(WSAHOST_NOT_FOUND);
    CASE_OF(WSATRY_AGAIN);
    CASE_OF(WSANO_RECOVERY);
    CASE_OF(WSANO_DATA);

#if 0
    //
    // RAS errors
    //

    CASE_OF(PENDING);
    CASE_OF(ERROR_INVALID_PORT_HANDLE);
    CASE_OF(ERROR_PORT_ALREADY_OPEN);
    CASE_OF(ERROR_BUFFER_TOO_SMALL);
    CASE_OF(ERROR_WRONG_INFO_SPECIFIED);
    CASE_OF(ERROR_CANNOT_SET_PORT_INFO);
    CASE_OF(ERROR_PORT_NOT_CONNECTED);
    CASE_OF(ERROR_EVENT_INVALID);
    CASE_OF(ERROR_DEVICE_DOES_NOT_EXIST);
    CASE_OF(ERROR_BUFFER_INVALID);
    CASE_OF(ERROR_ROUTE_NOT_AVAILABLE);
    CASE_OF(ERROR_ROUTE_NOT_ALLOCATED);
    CASE_OF(ERROR_INVALID_COMPRESSION_SPECIFIED);
    CASE_OF(ERROR_OUT_OF_BUFFERS);
    CASE_OF(ERROR_PORT_NOT_FOUND);
    CASE_OF(ERROR_ASYNC_REQUEST_PENDING);
    CASE_OF(ERROR_ALREADY_DISCONNECTING);
    CASE_OF(ERROR_PORT_NOT_OPEN);
    CASE_OF(ERROR_PORT_DISCONNECTED);
    CASE_OF(ERROR_NO_ENDPOINTS);
    CASE_OF(ERROR_CANNOT_OPEN_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_FIND_PHONEBOOK_ENTRY);
    CASE_OF(ERROR_CANNOT_WRITE_PHONEBOOK);
    CASE_OF(ERROR_CORRUPT_PHONEBOOK);
    CASE_OF(ERROR_CANNOT_LOAD_STRING);
    CASE_OF(ERROR_KEY_NOT_FOUND);
    CASE_OF(ERROR_DISCONNECTION);
    CASE_OF(ERROR_REMOTE_DISCONNECTION);
    CASE_OF(ERROR_HARDWARE_FAILURE);
    CASE_OF(ERROR_USER_DISCONNECTION);
    CASE_OF(ERROR_INVALID_SIZE);
    CASE_OF(ERROR_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_CANNOT_PROJECT_CLIENT);
    CASE_OF(ERROR_UNKNOWN);
    CASE_OF(ERROR_WRONG_DEVICE_ATTACHED);
    CASE_OF(ERROR_BAD_STRING);
    CASE_OF(ERROR_REQUEST_TIMEOUT);
    CASE_OF(ERROR_CANNOT_GET_LANA);
    CASE_OF(ERROR_NETBIOS_ERROR);
    CASE_OF(ERROR_SERVER_OUT_OF_RESOURCES);
    CASE_OF(ERROR_NAME_EXISTS_ON_NET);
    CASE_OF(ERROR_SERVER_GENERAL_NET_FAILURE);
    CASE_OF(WARNING_MSG_ALIAS_NOT_ADDED);
    CASE_OF(ERROR_AUTH_INTERNAL);
    CASE_OF(ERROR_RESTRICTED_LOGON_HOURS);
    CASE_OF(ERROR_ACCT_DISABLED);
    CASE_OF(ERROR_PASSWD_EXPIRED);
    CASE_OF(ERROR_NO_DIALIN_PERMISSION);
    CASE_OF(ERROR_SERVER_NOT_RESPONDING);
    CASE_OF(ERROR_FROM_DEVICE);
    CASE_OF(ERROR_UNRECOGNIZED_RESPONSE);
    CASE_OF(ERROR_MACRO_NOT_FOUND);
    CASE_OF(ERROR_MACRO_NOT_DEFINED);
    CASE_OF(ERROR_MESSAGE_MACRO_NOT_FOUND);
    CASE_OF(ERROR_DEFAULTOFF_MACRO_NOT_FOUND);
    CASE_OF(ERROR_FILE_COULD_NOT_BE_OPENED);
    CASE_OF(ERROR_DEVICENAME_TOO_LONG);
    CASE_OF(ERROR_DEVICENAME_NOT_FOUND);
    CASE_OF(ERROR_NO_RESPONSES);
    CASE_OF(ERROR_NO_COMMAND_FOUND);
    CASE_OF(ERROR_WRONG_KEY_SPECIFIED);
    CASE_OF(ERROR_UNKNOWN_DEVICE_TYPE);
    CASE_OF(ERROR_ALLOCATING_MEMORY);
    CASE_OF(ERROR_PORT_NOT_CONFIGURED);
    CASE_OF(ERROR_DEVICE_NOT_READY);
    CASE_OF(ERROR_READING_INI_FILE);
    CASE_OF(ERROR_NO_CONNECTION);
    CASE_OF(ERROR_BAD_USAGE_IN_INI_FILE);
    CASE_OF(ERROR_READING_SECTIONNAME);
    CASE_OF(ERROR_READING_DEVICETYPE);
    CASE_OF(ERROR_READING_DEVICENAME);
    CASE_OF(ERROR_READING_USAGE);
    CASE_OF(ERROR_READING_MAXCONNECTBPS);
    CASE_OF(ERROR_READING_MAXCARRIERBPS);
    CASE_OF(ERROR_LINE_BUSY);
    CASE_OF(ERROR_VOICE_ANSWER);
    CASE_OF(ERROR_NO_ANSWER);
    CASE_OF(ERROR_NO_CARRIER);
    CASE_OF(ERROR_NO_DIALTONE);
    CASE_OF(ERROR_IN_COMMAND);
    CASE_OF(ERROR_WRITING_SECTIONNAME);
    CASE_OF(ERROR_WRITING_DEVICETYPE);
    CASE_OF(ERROR_WRITING_DEVICENAME);
    CASE_OF(ERROR_WRITING_MAXCONNECTBPS);
    CASE_OF(ERROR_WRITING_MAXCARRIERBPS);
    CASE_OF(ERROR_WRITING_USAGE);
    CASE_OF(ERROR_WRITING_DEFAULTOFF);
    CASE_OF(ERROR_READING_DEFAULTOFF);
    CASE_OF(ERROR_EMPTY_INI_FILE);
    CASE_OF(ERROR_AUTHENTICATION_FAILURE);
    CASE_OF(ERROR_PORT_OR_DEVICE);
    CASE_OF(ERROR_NOT_BINARY_MACRO);
    CASE_OF(ERROR_DCB_NOT_FOUND);
    CASE_OF(ERROR_STATE_MACHINES_NOT_STARTED);
    CASE_OF(ERROR_STATE_MACHINES_ALREADY_STARTED);
    CASE_OF(ERROR_PARTIAL_RESPONSE_LOOPING);
    CASE_OF(ERROR_UNKNOWN_RESPONSE_KEY);
    CASE_OF(ERROR_RECV_BUF_FULL);
    CASE_OF(ERROR_CMD_TOO_LONG);
    CASE_OF(ERROR_UNSUPPORTED_BPS);
    CASE_OF(ERROR_UNEXPECTED_RESPONSE);
    CASE_OF(ERROR_INTERACTIVE_MODE);
    CASE_OF(ERROR_BAD_CALLBACK_NUMBER);
    CASE_OF(ERROR_INVALID_AUTH_STATE);
    CASE_OF(ERROR_WRITING_INITBPS);
    CASE_OF(ERROR_X25_DIAGNOSTIC);
    CASE_OF(ERROR_ACCT_EXPIRED);
    CASE_OF(ERROR_CHANGING_PASSWORD);
    CASE_OF(ERROR_OVERRUN);
    CASE_OF(ERROR_RASMAN_CANNOT_INITIALIZE);
    CASE_OF(ERROR_BIPLEX_PORT_NOT_AVAILABLE);
    CASE_OF(ERROR_NO_ACTIVE_ISDN_LINES);
    CASE_OF(ERROR_NO_ISDN_CHANNELS_AVAILABLE);
    CASE_OF(ERROR_TOO_MANY_LINE_ERRORS);
    CASE_OF(ERROR_IP_CONFIGURATION);
    CASE_OF(ERROR_NO_IP_ADDRESSES);
    CASE_OF(ERROR_PPP_TIMEOUT);
    CASE_OF(ERROR_PPP_REMOTE_TERMINATED);
    CASE_OF(ERROR_PPP_NO_PROTOCOLS_CONFIGURED);
    CASE_OF(ERROR_PPP_NO_RESPONSE);
    CASE_OF(ERROR_PPP_INVALID_PACKET);
    CASE_OF(ERROR_PHONE_NUMBER_TOO_LONG);
    CASE_OF(ERROR_IPXCP_NO_DIALOUT_CONFIGURED);
    CASE_OF(ERROR_IPXCP_NO_DIALIN_CONFIGURED);
    CASE_OF(ERROR_IPXCP_DIALOUT_ALREADY_ACTIVE);
    CASE_OF(ERROR_ACCESSING_TCPCFGDLL);
    CASE_OF(ERROR_NO_IP_RAS_ADAPTER);
    CASE_OF(ERROR_SLIP_REQUIRES_IP);
    CASE_OF(ERROR_PROJECTION_NOT_COMPLETE);
    CASE_OF(ERROR_PROTOCOL_NOT_CONFIGURED);
    CASE_OF(ERROR_PPP_NOT_CONVERGING);
    CASE_OF(ERROR_PPP_CP_REJECTED);
    CASE_OF(ERROR_PPP_LCP_TERMINATED);
    CASE_OF(ERROR_PPP_REQUIRED_ADDRESS_REJECTED);
    CASE_OF(ERROR_PPP_NCP_TERMINATED);
    CASE_OF(ERROR_PPP_LOOPBACK_DETECTED);
    CASE_OF(ERROR_PPP_NO_ADDRESS_ASSIGNED);
    CASE_OF(ERROR_CANNOT_USE_LOGON_CREDENTIALS);
    CASE_OF(ERROR_TAPI_CONFIGURATION);
    CASE_OF(ERROR_NO_LOCAL_ENCRYPTION);
    CASE_OF(ERROR_NO_REMOTE_ENCRYPTION);
    CASE_OF(ERROR_REMOTE_REQUIRES_ENCRYPTION);
    CASE_OF(ERROR_IPXCP_NET_NUMBER_CONFLICT);
    CASE_OF(ERROR_INVALID_SMM);
    CASE_OF(ERROR_SMM_UNINITIALIZED);
    CASE_OF(ERROR_NO_MAC_FOR_PORT);
    CASE_OF(ERROR_SMM_TIMEOUT);
    CASE_OF(ERROR_BAD_PHONE_NUMBER);
    CASE_OF(ERROR_WRONG_MODULE);
    CASE_OF(ERROR_INVALID_CALLBACK_NUMBER);
    CASE_OF(ERROR_SCRIPT_SYNTAX);
#endif // 0
    default:
        return "?";
    }
}


LPSTR
InternetMapStatus(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert INTERNET_STATUS_ value to symbolic name

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {
    CASE_OF(INTERNET_STATUS_RESOLVING_NAME);
    CASE_OF(INTERNET_STATUS_NAME_RESOLVED);
    CASE_OF(INTERNET_STATUS_CONNECTING_TO_SERVER);
    CASE_OF(INTERNET_STATUS_CONNECTED_TO_SERVER);
    CASE_OF(INTERNET_STATUS_SENDING_REQUEST);
    CASE_OF(INTERNET_STATUS_REQUEST_SENT);
    CASE_OF(INTERNET_STATUS_RECEIVING_RESPONSE);
    CASE_OF(INTERNET_STATUS_RESPONSE_RECEIVED);
    CASE_OF(INTERNET_STATUS_CTL_RESPONSE_RECEIVED);
    CASE_OF(INTERNET_STATUS_PREFETCH);
    CASE_OF(INTERNET_STATUS_CLOSING_CONNECTION);
    CASE_OF(INTERNET_STATUS_CONNECTION_CLOSED);
    CASE_OF(INTERNET_STATUS_HANDLE_CREATED);
    CASE_OF(INTERNET_STATUS_HANDLE_CLOSING);
    CASE_OF(INTERNET_STATUS_REQUEST_COMPLETE);
    CASE_OF(INTERNET_STATUS_REDIRECT);
    CASE_OF(INTERNET_STATUS_INTERMEDIATE_RESPONSE);
    CASE_OF(INTERNET_STATUS_STATE_CHANGE);
    CASE_OF(INTERNET_STATUS_USER_INPUT_REQUIRED);
    }
    return "?";
}


LPSTR
InternetMapSSPIError(
    IN DWORD Status
    )

/*++

Routine Description:

    Convert a SSL/PCT SSPI Error Code to a string.

Arguments:

    Status  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Status) {

    CASE_OF(STATUS_SUCCESS);
    CASE_OF(SEC_E_INSUFFICIENT_MEMORY        );
    CASE_OF(SEC_E_INVALID_HANDLE             );
    CASE_OF(SEC_E_UNSUPPORTED_FUNCTION       );
    CASE_OF(SEC_E_TARGET_UNKNOWN             );
    CASE_OF(SEC_E_INTERNAL_ERROR             );
    CASE_OF(SEC_E_SECPKG_NOT_FOUND           );
    CASE_OF(SEC_E_NOT_OWNER                  );
    CASE_OF(SEC_E_CANNOT_INSTALL             );
    CASE_OF(SEC_E_INVALID_TOKEN              );
    CASE_OF(SEC_E_CANNOT_PACK                );
    CASE_OF(SEC_E_QOP_NOT_SUPPORTED          );
    CASE_OF(SEC_E_NO_IMPERSONATION           );
    CASE_OF(SEC_E_LOGON_DENIED               );
    CASE_OF(SEC_E_UNKNOWN_CREDENTIALS        );
    CASE_OF(SEC_E_NO_CREDENTIALS             );
    CASE_OF(SEC_E_MESSAGE_ALTERED            );
    CASE_OF(SEC_E_OUT_OF_SEQUENCE            );
    CASE_OF(SEC_E_NO_AUTHENTICATING_AUTHORITY);
    CASE_OF(SEC_I_CONTINUE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_NEEDED            );
    CASE_OF(SEC_I_COMPLETE_AND_CONTINUE      );
    CASE_OF(SEC_I_LOCAL_LOGON                );
    CASE_OF(SEC_E_BAD_PKGID                  );
    CASE_OF(SEC_E_CONTEXT_EXPIRED            );
    CASE_OF(SEC_E_INCOMPLETE_MESSAGE         );
//    CASE_OF(SEC_E_NO_SPM                     );
//    CASE_OF(SEC_E_NOT_SUPPORTED              );

    }
    return "?";
}




LPSTR
InternetMapOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert INTERNET_OPTION_ value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(INTERNET_OPTION_CALLBACK);
    CASE_OF(INTERNET_OPTION_CONNECT_TIMEOUT);
    CASE_OF(INTERNET_OPTION_CONNECT_RETRIES);
    CASE_OF(INTERNET_OPTION_CONNECT_BACKOFF);
    CASE_OF(INTERNET_OPTION_SEND_TIMEOUT);
    CASE_OF(INTERNET_OPTION_RECEIVE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_DATA_SEND_TIMEOUT);
    CASE_OF(INTERNET_OPTION_DATA_RECEIVE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_HANDLE_TYPE);
    CASE_OF(INTERNET_OPTION_CONTEXT_VALUE_OLD);
    CASE_OF(INTERNET_OPTION_NAME_RES_THREAD);
    CASE_OF(INTERNET_OPTION_READ_BUFFER_SIZE);
    CASE_OF(INTERNET_OPTION_WRITE_BUFFER_SIZE);
    CASE_OF(INTERNET_OPTION_GATEWAY_NAME);
    CASE_OF(INTERNET_OPTION_ASYNC_ID);
    CASE_OF(INTERNET_OPTION_ASYNC_PRIORITY);
    CASE_OF(INTERNET_OPTION_ASYNC_REQUEST_COUNT);
    CASE_OF(INTERNET_OPTION_MAXIMUM_WORKER_THREADS);
    CASE_OF(INTERNET_OPTION_ASYNC_QUEUE_DEPTH);
    CASE_OF(INTERNET_OPTION_WORKER_THREAD_TIMEOUT);
    CASE_OF(INTERNET_OPTION_PARENT_HANDLE);
    CASE_OF(INTERNET_OPTION_KEEP_CONNECTION);
    CASE_OF(INTERNET_OPTION_REQUEST_FLAGS);
    CASE_OF(INTERNET_OPTION_EXTENDED_ERROR);
    CASE_OF(INTERNET_OPTION_RECEIVE_ALL_MODE);
    CASE_OF(INTERNET_OPTION_OFFLINE_MODE);
    CASE_OF(INTERNET_OPTION_CACHE_STREAM_HANDLE);
    CASE_OF(INTERNET_OPTION_USERNAME);
    CASE_OF(INTERNET_OPTION_PASSWORD);
    CASE_OF(INTERNET_OPTION_ASYNC);
    CASE_OF(INTERNET_OPTION_SECURITY_FLAGS);
    CASE_OF(INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT);
    CASE_OF(INTERNET_OPTION_DATAFILE_NAME);
    CASE_OF(INTERNET_OPTION_URL);
    CASE_OF(INTERNET_OPTION_SECURITY_CERTIFICATE);
    CASE_OF(INTERNET_OPTION_SECURITY_KEY_BITNESS);
    CASE_OF(INTERNET_OPTION_REFRESH);
    CASE_OF(INTERNET_OPTION_PROXY);
    CASE_OF(INTERNET_OPTION_SETTINGS_CHANGED);
    CASE_OF(INTERNET_OPTION_VERSION);
    CASE_OF(INTERNET_OPTION_USER_AGENT);
    CASE_OF(INTERNET_OPTION_END_BROWSER_SESSION);
    CASE_OF(INTERNET_OPTION_PROXY_USERNAME);
    CASE_OF(INTERNET_OPTION_PROXY_PASSWORD);
    CASE_OF(INTERNET_OPTION_CONTEXT_VALUE);
    CASE_OF(INTERNET_OPTION_CONNECT_LIMIT);
    CASE_OF(INTERNET_OPTION_SECURITY_SELECT_CLIENT_CERT);
    CASE_OF(INTERNET_OPTION_POLICY);
    CASE_OF(INTERNET_OPTION_OFFLINE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_LINE_STATE);
    CASE_OF(INTERNET_OPTION_IDLE_STATE);
    CASE_OF(INTERNET_OPTION_OFFLINE_SEMANTICS);
    CASE_OF(INTERNET_OPTION_SECONDARY_CACHE_KEY);
    CASE_OF(INTERNET_OPTION_CALLBACK_FILTER);
    CASE_OF(INTERNET_OPTION_CONNECT_TIME);
    CASE_OF(INTERNET_OPTION_SEND_THROUGHPUT);
    CASE_OF(INTERNET_OPTION_REQUEST_PRIORITY);
    CASE_OF(INTERNET_OPTION_HTTP_VERSION);
    CASE_OF(INTERNET_OPTION_RESET_URLCACHE_SESSION);
    CASE_OF(INTERNET_OPTION_NET_SPEED);
    CASE_OF(INTERNET_OPTION_ERROR_MASK);
    CASE_OF(INTERNET_OPTION_FROM_CACHE_TIMEOUT);
    CASE_OF(INTERNET_OPTION_BYPASS_EDITED_ENTRY);
    CASE_OF(INTERNET_OPTION_SECURITY_CONNECTION_INFO);
    CASE_OF(INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO);
    CASE_OF(INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY);
    }
    return "?";
}


LPSTR
InternetMapHttpOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert HTTP_QUERY_ option value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(HTTP_QUERY_MIME_VERSION);               // 0
    CASE_OF(HTTP_QUERY_CONTENT_TYPE);               // 1
    CASE_OF(HTTP_QUERY_CONTENT_TRANSFER_ENCODING);  // 2
    CASE_OF(HTTP_QUERY_CONTENT_ID);                 // 3
    CASE_OF(HTTP_QUERY_CONTENT_DESCRIPTION);        // 4
    CASE_OF(HTTP_QUERY_CONTENT_LENGTH);             // 5
    CASE_OF(HTTP_QUERY_CONTENT_LANGUAGE);           // 6
    CASE_OF(HTTP_QUERY_ALLOW);                      // 7
    CASE_OF(HTTP_QUERY_PUBLIC);                     // 8
    CASE_OF(HTTP_QUERY_DATE);                       // 9
    CASE_OF(HTTP_QUERY_EXPIRES);                    // 10
    CASE_OF(HTTP_QUERY_LAST_MODIFIED);              // 11
    CASE_OF(HTTP_QUERY_MESSAGE_ID);                 // 12
    CASE_OF(HTTP_QUERY_URI);                        // 13
    CASE_OF(HTTP_QUERY_DERIVED_FROM);               // 14
    CASE_OF(HTTP_QUERY_COST);                       // 15
    CASE_OF(HTTP_QUERY_LINK);                       // 16
    CASE_OF(HTTP_QUERY_PRAGMA);                     // 17
    CASE_OF(HTTP_QUERY_VERSION);                    // 18
    CASE_OF(HTTP_QUERY_STATUS_CODE);                // 19
    CASE_OF(HTTP_QUERY_STATUS_TEXT);                // 20
    CASE_OF(HTTP_QUERY_RAW_HEADERS);                // 21
    CASE_OF(HTTP_QUERY_RAW_HEADERS_CRLF);           // 22
    CASE_OF(HTTP_QUERY_CONNECTION);                 // 23
    CASE_OF(HTTP_QUERY_ACCEPT);                     // 24
    CASE_OF(HTTP_QUERY_ACCEPT_CHARSET);             // 25
    CASE_OF(HTTP_QUERY_ACCEPT_ENCODING);            // 26
    CASE_OF(HTTP_QUERY_ACCEPT_LANGUAGE);            // 27
    CASE_OF(HTTP_QUERY_AUTHORIZATION);              // 28
    CASE_OF(HTTP_QUERY_CONTENT_ENCODING);           // 29
    CASE_OF(HTTP_QUERY_FORWARDED);                  // 30
    CASE_OF(HTTP_QUERY_FROM);                       // 31
    CASE_OF(HTTP_QUERY_IF_MODIFIED_SINCE);          // 32
    CASE_OF(HTTP_QUERY_LOCATION);                   // 33
    CASE_OF(HTTP_QUERY_ORIG_URI);                   // 34
    CASE_OF(HTTP_QUERY_REFERER);                    // 35
    CASE_OF(HTTP_QUERY_RETRY_AFTER);                // 36
    CASE_OF(HTTP_QUERY_SERVER);                     // 37
    CASE_OF(HTTP_QUERY_TITLE);                      // 38
    CASE_OF(HTTP_QUERY_USER_AGENT);                 // 39
    CASE_OF(HTTP_QUERY_WWW_AUTHENTICATE);           // 40
    CASE_OF(HTTP_QUERY_PROXY_AUTHENTICATE);         // 41
    CASE_OF(HTTP_QUERY_ACCEPT_RANGES);              // 42
    CASE_OF(HTTP_QUERY_SET_COOKIE);                 // 43
    CASE_OF(HTTP_QUERY_COOKIE);                     // 44
    CASE_OF(HTTP_QUERY_REQUEST_METHOD);             // 45
    CASE_OF(HTTP_QUERY_REFRESH);                    // 46
    CASE_OF(HTTP_QUERY_CONTENT_DISPOSITION);        // 47
    CASE_OF(HTTP_QUERY_AGE);                        // 48
    CASE_OF(HTTP_QUERY_CACHE_CONTROL);              // 49
    CASE_OF(HTTP_QUERY_CONTENT_BASE);               // 50
    CASE_OF(HTTP_QUERY_CONTENT_LOCATION);           // 51
    CASE_OF(HTTP_QUERY_CONTENT_MD5);                // 52
    CASE_OF(HTTP_QUERY_CONTENT_RANGE);              // 53
    CASE_OF(HTTP_QUERY_ETAG);                       // 54
    CASE_OF(HTTP_QUERY_HOST);                       // 55
    CASE_OF(HTTP_QUERY_IF_MATCH);                   // 56
    CASE_OF(HTTP_QUERY_IF_NONE_MATCH);              // 57
    CASE_OF(HTTP_QUERY_IF_RANGE);                   // 58
    CASE_OF(HTTP_QUERY_IF_UNMODIFIED_SINCE);        // 59
    CASE_OF(HTTP_QUERY_MAX_FORWARDS);               // 60
    CASE_OF(HTTP_QUERY_PROXY_AUTHORIZATION);        // 61
    CASE_OF(HTTP_QUERY_RANGE);                      // 62
    CASE_OF(HTTP_QUERY_TRANSFER_ENCODING);          // 63
    CASE_OF(HTTP_QUERY_UPGRADE);                    // 64
    CASE_OF(HTTP_QUERY_VARY);                       // 65
    CASE_OF(HTTP_QUERY_VIA);                        // 66
    CASE_OF(HTTP_QUERY_WARNING);                    // 67
    CASE_OF(HTTP_QUERY_EXPECT);                     // 68
    CASE_OF(HTTP_QUERY_PROXY_CONNECTION);           // 69
    CASE_OF(HTTP_QUERY_UNLESS_MODIFIED_SINCE);      // 70
    CASE_OF(HTTP_QUERY_ECHO_REQUEST);               // 71
    CASE_OF(HTTP_QUERY_ECHO_REPLY);                 // 72
    CASE_OF(HTTP_QUERY_ECHO_HEADERS);               // 73
    CASE_OF(HTTP_QUERY_ECHO_HEADERS_CRLF);          // 74
    CASE_OF(HTTP_QUERY_CUSTOM);                     // 65535
    }
    return "?";
}


LPSTR
InternetMapHttpState(
    IN DWORD State
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ to symbolic name

Arguments:

    State   - to map

Return Value:

    LPSTR

--*/

{
    switch (State) {
    CASE_OF(HttpRequestStateCreating);
    CASE_OF(HttpRequestStateOpen);
    CASE_OF(HttpRequestStateRequest);
    CASE_OF(HttpRequestStateResponse);
    CASE_OF(HttpRequestStateObjectData);
    CASE_OF(HttpRequestStateError);
    CASE_OF(HttpRequestStateClosing);
    CASE_OF(HttpRequestStateReopen);
    }
    return "?";
}

LPSTR
InternetMapHttpStateFlag(
    IN DWORD Flag
    )

/*++

Routine Description:

    Convert HTTPREQ_STATE_ flag to symbolic name

Arguments:

    Flag    - to map

Return Value:

    LPSTR

--*/

{
    switch (Flag) {
    case HTTPREQ_STATE_ANYTHING_OK:
        return "ANYTHING";

    case HTTPREQ_STATE_CLOSE_OK:
        return "CLOSE";

    case HTTPREQ_STATE_ADD_OK:
        return "ADD";

    case HTTPREQ_STATE_SEND_OK:
        return "SEND";

    case HTTPREQ_STATE_READ_OK:
        return "READ";

    case HTTPREQ_STATE_QUERY_REQUEST_OK:
        return "QUERY_REQUEST";

    case HTTPREQ_STATE_QUERY_RESPONSE_OK:
        return "QUERY_RESPONSE";

    case HTTPREQ_STATE_REUSE_OK:
        return "REUSE";
    }
    return "?";
}


LPSTR
InternetMapAuthScheme(
    IN DWORD Scheme
    )

/*++

Routine Description:

    Convert AUTHCTX::SCHEME_ to symbolic name

Arguments:

    Scheme   - to map

Return Value:

    LPSTR

--*/

{
    switch (Scheme) {

        CASE_OF(AUTHCTX::SCHEME_BASIC);
        CASE_OF(AUTHCTX::SCHEME_DIGEST);
        CASE_OF(AUTHCTX::SCHEME_NTLM);
        CASE_OF(AUTHCTX::SCHEME_MSN);
        CASE_OF(AUTHCTX::SCHEME_DPA);
        CASE_OF(AUTHCTX::SCHEME_KERBEROS);
        CASE_OF(AUTHCTX::SCHEME_NEGOTIATE);
        CASE_OF(AUTHCTX::SCHEME_UNKNOWN);
    }
    return "?";
}

LPSTR
InternetMapAuthState(
    IN DWORD State
    )

/*++

Routine Description:

    Convert AUTHSTATE_ to symbolic name

Arguments:

    State   - to map

Return Value:

    LPSTR

--*/

{
    switch (State) {
    CASE_OF(AUTHSTATE_NONE);
    CASE_OF(AUTHSTATE_NEGOTIATE);
    CASE_OF(AUTHSTATE_CHALLENGE);
    CASE_OF(AUTHSTATE_NEEDTUNNEL);
    }
    return "?";
}


LPSTR
InternetMapAsyncRequest(
    IN AR_TYPE Type
    )

/*++

Routine Description:

    Convert AR_TYPE to symbolic name

Arguments:

    Type    - Async request type

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Type) {
    CASE_OF(AR_INTERNET_CONNECT);
    CASE_OF(AR_INTERNET_OPEN_URL);
    CASE_OF(AR_INTERNET_READ_FILE);
    CASE_OF(AR_INTERNET_WRITE_FILE);
    CASE_OF(AR_INTERNET_QUERY_DATA_AVAILABLE);
    CASE_OF(AR_INTERNET_FIND_NEXT_FILE);
    CASE_OF(AR_FTP_FIND_FIRST_FILE);
    CASE_OF(AR_FTP_GET_FILE);
    CASE_OF(AR_FTP_PUT_FILE);
    CASE_OF(AR_FTP_DELETE_FILE);
    CASE_OF(AR_FTP_RENAME_FILE);
    CASE_OF(AR_FTP_OPEN_FILE);
    CASE_OF(AR_FTP_CREATE_DIRECTORY);
    CASE_OF(AR_FTP_REMOVE_DIRECTORY);
    CASE_OF(AR_FTP_SET_CURRENT_DIRECTORY);
    CASE_OF(AR_FTP_GET_CURRENT_DIRECTORY);
    CASE_OF(AR_GOPHER_FIND_FIRST_FILE);
    CASE_OF(AR_GOPHER_OPEN_FILE);
    CASE_OF(AR_GOPHER_GET_ATTRIBUTE);
    CASE_OF(AR_HTTP_SEND_REQUEST);
    CASE_OF(AR_HTTP_BEGIN_SEND_REQUEST);
    CASE_OF(AR_HTTP_END_SEND_REQUEST);
    CASE_OF(AR_READ_PREFETCH);
    CASE_OF(AR_SYNC_EVENT);
    CASE_OF(AR_TIMER_EVENT);
    CASE_OF(AR_HTTP_REQUEST1);
    CASE_OF(AR_FILE_IO);
    CASE_OF(AR_INTERNET_READ_FILE_EX);
    }
    return "?";
}


LPSTR
InternetMapHandleType(
    IN DWORD HandleType
    )

/*++

Routine Description:

    Map handle type to symbolic name

Arguments:

    HandleType  - from handle object

Return Value:

    LPSTR

--*/

{
    switch (HandleType) {
    CASE_OF(TypeGenericHandle);
    CASE_OF(TypeInternetHandle);
    CASE_OF(TypeFtpConnectHandle);
    CASE_OF(TypeFtpFindHandle);
    CASE_OF(TypeFtpFindHandleHtml);
    CASE_OF(TypeFtpFileHandle);
    CASE_OF(TypeFtpFileHandleHtml);
    CASE_OF(TypeGopherConnectHandle);
    CASE_OF(TypeGopherFindHandle);
    CASE_OF(TypeGopherFindHandleHtml);
    CASE_OF(TypeGopherFileHandle);
    CASE_OF(TypeGopherFileHandleHtml);
    CASE_OF(TypeHttpConnectHandle);
    CASE_OF(TypeHttpRequestHandle);
    CASE_OF(TypeFileRequestHandle);
    CASE_OF(TypeWildHandle);
    }
    return "?";
}


LPSTR
InternetMapScheme(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps INTERNET_SCHEME_ to symbolic name

Arguments:

    Scheme  - to map

Return Value:

    LPSTR

--*/

{
    switch (Scheme) {
    CASE_OF(INTERNET_SCHEME_UNKNOWN);
    CASE_OF(INTERNET_SCHEME_DEFAULT);
    CASE_OF(INTERNET_SCHEME_FTP);
    CASE_OF(INTERNET_SCHEME_GOPHER);
    CASE_OF(INTERNET_SCHEME_HTTP);
    CASE_OF(INTERNET_SCHEME_HTTPS);
    }
    return "?";
}


LPSTR
InternetMapOpenType(
    IN DWORD OpenType
    )

/*++

Routine Description:

    Maps INTERNET_OPEN_TYPE_ to symbolic name

Arguments:

    OpenType    - to map

Return Value:

    LPSTR

--*/

{
    switch (OpenType) {
    CASE_OF(INTERNET_OPEN_TYPE_DIRECT);
    CASE_OF(INTERNET_OPEN_TYPE_PROXY);
    CASE_OF(INTERNET_OPEN_TYPE_PRECONFIG);
    }
    return "?";
}


LPSTR
InternetMapService(
    IN DWORD Service
    )

/*++

Routine Description:

    Maps INTERNET_SERVICE_ to symbolic name

Arguments:

    Service - to map

Return Value:

    LPSTR

--*/

{
    switch (Service) {
#if 0
    CASE_OF(INTERNET_SERVICE_URL);
#endif
    CASE_OF(INTERNET_SERVICE_FTP);
    CASE_OF(INTERNET_SERVICE_GOPHER);
    CASE_OF(INTERNET_SERVICE_HTTP);
    }
    return "?";
}


LPSTR
InternetMapWinsockCallbackType(
    IN DWORD CallbackType
    )

/*++

Routine Description:

    Maps WINSOCK_CALLBACK_ to symbolic name

Arguments:

    Service - to map

Return Value:

    LPSTR

--*/

{
    switch (CallbackType) {
    CASE_OF(WINSOCK_CALLBACK_CONNECT);
    CASE_OF(WINSOCK_CALLBACK_GETHOSTBYADDR);
    CASE_OF(WINSOCK_CALLBACK_GETHOSTBYNAME);
    CASE_OF(WINSOCK_CALLBACK_LISTEN);
    CASE_OF(WINSOCK_CALLBACK_RECVFROM);
    CASE_OF(WINSOCK_CALLBACK_SENDTO);
    }
    return "?";
}

//
// private functions
//


PRIVATE
LPSTR
ExtractFileName(
    IN LPSTR Module,
    OUT LPSTR Buf
    )
{
    LPSTR filename;
    LPSTR extension;
    int   len;

    filename = strrchr(Module, '\\');
    extension = strrchr(Module, '.');
    if (filename) {
        ++filename;
    } else {
        filename = Module;
    }
    if (!extension) {
        extension = filename + strlen(filename);
    }
    len = (int) (extension - filename);
    memcpy(Buf, filename, len);
    Buf[len] = '\0';
    return Buf;
}


PRIVATE
LPSTR
SetDebugPrefix(
    IN LPSTR Buffer
    )
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    //INET_ASSERT(lpThreadInfo != NULL);

    if (!lpThreadInfo) {
        return NULL;
    }

    LPINTERNET_DEBUG_RECORD lpRecord;

    lpRecord = lpThreadInfo->Stack;

    if (InternetDebugControlFlags & DBG_ENTRY_TIME) {
        if ((InternetDebugControlFlags & (DBG_DELTA_TIME | DBG_CUMULATIVE_TIME))
        && lpRecord) {

            DWORD ticks;
            DWORD ticksNow;

            ticksNow = GetTickCountWrap();
            ticks = ticksNow -  ((InternetDebugControlFlags & DBG_CUMULATIVE_TIME)
                                    ? InternetDebugStartTime
                                    : lpRecord->LastTime);

            Buffer += rsprintf(Buffer,
                               "% 5d.%3d ",
                               ticks / 1000,
                               ticks % 1000
                               );
            if (InternetDebugControlFlags & DBG_DELTA_TIME) {
                lpRecord->LastTime = ticksNow;
            }
        } else {

            SYSTEMTIME timeNow;

            InternetDebugGetLocalTime(&timeNow, NULL);

            Buffer += rsprintf(Buffer,
                               "%02d:%02d:%02d.%03d ",
                               timeNow.wHour,
                               timeNow.wMinute,
                               timeNow.wSecond,
                               timeNow.wMilliseconds
                               );
        }
    }

/*
    if (InternetDebugControlFlags & DBG_LEVEL_INDICATOR) {
        Buffer += rsprintf(Buffer, );
    }
*/

    if (InternetDebugControlFlags & DBG_THREAD_INFO) {

        //
        // thread id
        //

        Buffer += rsprintf(Buffer, "%08x", lpThreadInfo->ThreadId);

        //
        // INTERNET_THREAD_INFO address
        //

        if (InternetDebugControlFlags & DBG_THREAD_INFO_ADR) {
            Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo);
        }

        //
        // ARB address
        //

        //if (InternetDebugControlFlags & DBG_ARB_ADDR) {
        //    Buffer += rsprintf(Buffer, ":%08x", lpThreadInfo->lpArb);
        //}

        //
        // FIBER address
        //

        //if (InternetDebugControlFlags & DBG_FIBER_INFO) {
        //
        //    LPVOID p;
        //
        //    p = (lpThreadInfo->lpArb != NULL)
        //      ? lpThreadInfo->lpArb->Header.lpFiber
        //      : NULL
        //      ;
        //    Buffer += rsprintf(Buffer, ":%08x", p);
        //}

        //
        // async ID
        //

        if (InternetDebugControlFlags & DBG_ASYNC_ID) {
            if (lpThreadInfo->IsAsyncWorkerThread) {
                Buffer += rsprintf(Buffer, ":<--->");
            } else if (lpThreadInfo->InCallback) {

                //
                // async worker thread calling back into the app; any WinInet
                // API requests during this time treated as though from the
                // app context
                //

                Buffer += rsprintf(Buffer, ":<c-b>");
            }
            else if (lpThreadInfo->IsAutoProxyProxyThread)
            {

                //
                // this is a specialized Auto-Proxy thread
                //

                Buffer += rsprintf(Buffer, ":<a-p>");
            }
            else
            {

                //
                // this is an app thread
                //

                Buffer += rsprintf(Buffer, ":<app>");
            }
        }

        //
        // request handle
        //

        if (InternetDebugControlFlags & DBG_REQUEST_HANDLE) {
            Buffer += rsprintf(Buffer, ":%6X", lpThreadInfo->hObject);
        }

        *Buffer++ = ' ';
    }

    if (InternetDebugControlFlags & DBG_CALL_DEPTH) {
        Buffer += rsprintf(Buffer, "%03d ", lpThreadInfo->CallDepth);
    }

    for (int i = 0; i < lpThreadInfo->IndentIncrement; ++i) {
        *Buffer++ = ' ';
    }

    //
    // if we are not debugging the category - i.e we got here via a requirement
    // to display an error, or we are in a function that does not have a
    // DEBUG_ENTER - then prefix the string with the current function name
    // (obviously misleading if the function doesn't have a DEBUG_ENTER)
    //

    if (lpRecord != NULL) {
        if (!(lpRecord->Category & InternetDebugCategoryFlags)) {
            Buffer += rsprintf(Buffer, "%s(): ", lpRecord->Function);
        }
    }

    return Buffer;
}

int dprintf(char * format, ...) {

    va_list args;
    char buf[PRINTF_STACK_BUFFER_LENGTH];
    int n;

    va_start(args, format);
    n = _sprintf(buf, format, args);
    va_end(args);
    OutputDebugString(buf);

    return n;
}


LPSTR
SourceFilename(
    LPSTR Filespec
    )
{
    if (!Filespec) {
        return "?";
    }

    LPSTR p;

    if (p = strrchr(Filespec, '\\')) {

        //
        // we want e.g. common\debugmem.cxx, but get
        // common\..\win32\debugmem.cxx. Bah!
        //

        //LPSTR q;
        //
        //if (q = strrchr(p - 1, '\\')) {
        //    p = q;
        //}
    }
    return p ? p + 1 : Filespec;
}

typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

PRIVATE HMODULE hSymLib = NULL;
PRIVATE SYMINITIALIZE pSymInitialize = NULL;
PRIVATE SYMLOADMODULE pSymLoadModule = NULL;
PRIVATE SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
PRIVATE SYMCLEANUP pSymCleanup = NULL;


VOID
InitSymLib(
    VOID
    )
{
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "WININET.DLL", "WININET", 0, 0);
    }
}


VOID
TermSymLib(
    VOID
    )
{
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}


LPSTR
GetDebugSymbol(
    DWORD Address,
    LPDWORD Offset
    )
{
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    //
    // BUGBUG - only one caller at a time please
    //

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}

#if defined(i386)


VOID
x86SleazeCallStack(
    OUT LPVOID * lplpvStack,
    IN DWORD dwStackCount,
    IN LPVOID * Ebp
    )

/*++

Routine Description:

    Similar to x86SleazeCallersAddress but gathers a variable number of return
    addresses. We assume all functions have stack frame

Arguments:

    lplpvStack      - pointer to returned array of caller's addresses

    dwStackCount    - number of elements in lplpvStack

    Ebp             - starting Ebp if not 0, else use current stack

Return Value:

    None.

--*/

{
    DWORD my_esp;

    _asm mov my_esp, esp;

    __try {
        if (Ebp == 0) {
            Ebp = (LPVOID *)(&lplpvStack - 2);
        }
        while (dwStackCount--) {
            if (((DWORD)Ebp > my_esp + 0x10000) || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
            *lplpvStack++ = *(Ebp + 1);
            Ebp = (LPVOID *)*Ebp;
            if (((DWORD)Ebp <= 0x10000)
            || ((DWORD)Ebp >= 0x80000000)
            || ((DWORD)Ebp & 3)
            || ((DWORD)Ebp > my_esp + 0x10000)
            || ((DWORD)Ebp < my_esp - 0x10000)) {
                break;
            }
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
    }
}


VOID
x86SleazeCallersAddress(
    LPVOID* pCaller,
    LPVOID* pCallersCaller
    )

/*++

Routine Description:

    This is a sleazy function that reads return addresses out of the stack/
    frame pointer (ebp). We pluck out the return address of the function
    that called THE FUNCTION THAT CALLED THIS FUNCTION, and the caller of
    that function. Returning the return address of the function that called
    this function is not interesting to that caller (almost worthy of Sir
    Humphrey Appleby isn't it?)

    Assumes:

        my ebp  =>  | caller's ebp |
                    | caller's eip |
                    | arg #1       | (pCaller)
                    | arg #2       | (pCallersCaller

Arguments:

    pCaller         - place where we return addres of function that called
                      the function that called this function
    pCallersCaller  - place where we return caller of above

Return Value:

    None.

--*/

{

    //
    // this only works on x86 and only if not fpo functions!
    //

    LPVOID* ebp;

    ebp = (PVOID*)&pCaller - 2; // told you it was sleazy
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCaller = *(ebp + 1);
    ebp = (PVOID*)*(PVOID*)ebp;
    *pCallersCaller = *(ebp + 1);
}

#endif // defined(i386)

#endif // ENABLE_DEBUG

INTERNETAPI_(BOOL) InternetDebugGetLocalTime(
    OUT SYSTEMTIME * pstLocalTime,
    OUT DWORD      * pdwMicroSec
)
{
#ifndef ENABLE_DEBUG
    // QUICK HACK TO KEEP THINGS CLEAN AND STILL MEASURE WITH HIGH PERFORMANCE
    // COUNTER

    static BOOL pcTested = FALSE;
    static LONGLONG ftInit;  // initial local time
    static LONGLONG pcInit;  // initial perf counter
    static LONGLONG pcFreq;  // perf counter frequency

    if (!pcTested)
    {
        pcTested = TRUE;
        if (QueryPerformanceFrequency ((LARGE_INTEGER *) &pcFreq) && pcFreq)
        {
            QueryPerformanceCounter ((LARGE_INTEGER *) &pcInit);
            SYSTEMTIME st;
            GetLocalTime (&st);
            SystemTimeToFileTime (&st, (FILETIME *) &ftInit);
        }
    }

    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#else
    if (!pcFreq)
        GetLocalTime (pstLocalTime);
    else
    {
        LONGLONG pcCurrent, ftCurrent;
        QueryPerformanceCounter ((LARGE_INTEGER *) &pcCurrent);
        ftCurrent = ftInit + ((10000000 * (pcCurrent - pcInit)) / pcFreq);
        FileTimeToSystemTime ((FILETIME *) &ftCurrent, pstLocalTime);
    }

    return TRUE;
#endif // ENABLE_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\blocklst.cxx ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    blocklst.cxx

Abstract:

    Contains WinInet async support to allow blocking of unknown threads, on auto-proxy events.

    Contents:
        BlockThreadOnEvent
        SignalThreadOnEvent
        AcquireBlockedRequestQueue
        ReleaseBlockedRequestQueue
        (DestroyBlockedThreadEvent)


Author:

    Arthur L Bierer (arthurbi) 15-Feb-1998

Environment:

    Win32 user-mode DLL

Revision History:

    15-Feb-1998 arthurbi
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private data
//

//
// BlockedRequestQueue - when threads need to block on an event they get
// placed in here until their event is signaled. This is needed so threads
// can block on internally kept events without having to be tied
// to keeping track of event handles.
//
// Blocked threads must not be also waiting for a socket to become unblocked
//

GLOBAL SERIALIZED_LIST BlockedRequestQueue = {0};

//
// ARB - information common to all asynchronous blocked events
//

typedef struct {

    //
    // List - requests are queued on doubly-linked list. N.B. Code that deals
    // in ARBs implicitly assumes that List is at offset zero in the ARB. Move
    // this and pick up the pieces...
    //

    LIST_ENTRY List;

    //
    // hEvent - handle to Event that we are blocked on.
    //

    HANDLE      hEvent;

    //
    // dwBlockedOnEvent - contains the event this ARB may be blocked
    // on.  This allows a FIBER to block itself on an Internally kept
    // event. When the event is signalled, it will wakeup, and moved
    // to the Active Pool of fibers.
    //
    // A ZERO value means there is NO event that is being blocked on.
    //

    DWORD_PTR   dwBlockedOnEvent;

    //
    // dwBlockedOnEventReturnCode - contains error code returned from
    //  fiber or main thread that is doing the unblocking.
    //

    DWORD       dwBlockedOnEventReturnCode;

#if INET_DEBUG

    //
    // dwSignature - in the debug version, we maintain a signature in the ARB
    // for sanity checking
    //

    DWORD dwSignature;

#endif // INET_DEBUG

} ARB, * LPARB;

//
// functions...
//

PRIVATE
VOID
DestroyBlockedThreadEvent(
    IN LPARB lpArb
    )

/*++

Routine Description:

    Removes lpArb from the blocked request queue if its still there, and
    destroys it

Arguments:

    lpArb   - pointer to AR_SYNC_EVENT ARB

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 None,
                 "DestroyBlockedThreadEvent",
                 "%#x",
                 lpArb
                 ));

    AcquireBlockedRequestQueue();

    if (lpArb->hEvent != NULL) {
        CloseHandle(lpArb->hEvent);
    }

    if (IsOnSerializedList(&BlockedRequestQueue, &lpArb->List)) {
        RemoveFromSerializedList(&BlockedRequestQueue, &lpArb->List);
    }

    ReleaseBlockedRequestQueue();

    DEBUG_LEAVE(0);
}


DWORD
BlockThreadOnEvent(
    IN DWORD_PTR dwEventId,
    IN DWORD dwTimeout,
    IN BOOL bReleaseLock
    )

/*++

Routine Description:

    Waits for an async event if called in the context of a fiber, else waits for
    an event if called in the context of a sync request

Arguments:

    dwEventId       - event id to wait on

    dwTimeout       - amount of time to wait

    bReleaseLock    - TRUE if we need to release the blocked request queue

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                    The request/wait completed successfully

        Failure - ERROR_INTERNET_TIMEOUT
                    The request timed out

                  ERROR_INTERNET_INTERNAL_ERROR
                    We couldn't get the INTERNET_THREAD_INFO

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Dword,
                 "BlockThreadOnEvent",
                 "%#x, %d, %B",
                 dwEventId,
                 dwTimeout,
                 bReleaseLock
                 ));

    DWORD error;
    ARB Arb;

    ZeroMemory(&Arb, sizeof(Arb));

    //
    // set up the remaining fields in the ARB - initialize the list pointer,
    // set the priority (to default), and the event id
    //

    Arb.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (Arb.hEvent == NULL) {
        error = GetLastError();

        // IE6 BUG #25117
        // if we acquired the blocked request queue before calling this function
        // then we need to release it
        //

        if (bReleaseLock) {
            ReleaseBlockedRequestQueue();
        }

        goto quit;
    }
    Arb.dwBlockedOnEvent = dwEventId;

    //
    // add the request to the blocked request queue
    //

    InsertAtTailOfSerializedList(&BlockedRequestQueue, &Arb.List);

    //
    // if we acquired the blocked request queue before calling this function
    // then we need to release it
    //

    if (bReleaseLock) {
        ReleaseBlockedRequestQueue();
    }

    //
    // now wait here for the event to become signalled
    //

    error = PERF_WaitForSingleObject(Arb.hEvent,
                                     dwTimeout
                                     );

    //
    // if we timed out then we will remove and destroy the ARB, else the thread
    // which signalled the request will have done so
    //

    if (error == WAIT_TIMEOUT) {
        error = ERROR_INTERNET_TIMEOUT;
    } else {
        error = Arb.dwBlockedOnEventReturnCode;
    }

quit:

    //
    // remove the request from the blocked request queue and destroy it
    //

    DestroyBlockedThreadEvent(&Arb);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
SignalThreadOnEvent(
    IN DWORD_PTR dwEventId,
    IN DWORD dwNumberOfWaiters,
    IN DWORD dwReturnCode
    )

/*++

Routine Description:

    Unblocks a number of fibers that may be waiting for an event to be signalled.
    When the fibers unblock they will be rescheduled to the Active Request Queue.
    The 'event' is reset automatically back to unsignalled state.

    If called outside of the worker thread, this function also handles
    interupting the blocked worked thread so it can resume requests.

Arguments:

    dwEventId           - Event ID to wake up on.

    dwNumberOfWaiters   - number of waiters to unblock. Choose a large number
                          to mean 'all'

    dwReturnCode        - Upon waking up fibers, their blocked called will return
                          with this error code.

Return Value:

    DWORD
        Number of waiters unblocked

--*/

{
    DEBUG_ENTER((DBG_ASYNC,
                 Int,
                 "SignalThreadOnEvent",
                 "%#x, %d, %d (%s)",
                 dwEventId,
                 dwNumberOfWaiters,
                 dwReturnCode,
                 InternetMapError(dwReturnCode)
                 ));

    INET_ASSERT(dwNumberOfWaiters > 0);

    DWORD dwUnblocked = 0;

    AcquireBlockedRequestQueue();

    LPARB lpArb = (LPARB)HeadOfSerializedList(&BlockedRequestQueue);
    LPARB lpArbPrevious = (LPARB)SlSelf(&BlockedRequestQueue);

    while (lpArb != (LPARB)SlSelf(&BlockedRequestQueue)) {
        if (lpArb->dwBlockedOnEvent == dwEventId) {

            lpArb->dwBlockedOnEventReturnCode = dwReturnCode;

            //
            // if the ARB is really an async request then add it to the end of
            // the async request queue else if it is a sync request then just
            // signal the event. The waiter will free the ARB
            //

            SetEvent(lpArb->hEvent);

            DEBUG_PRINT(ASYNC,
                        INFO,
                        ("signalled sync request %#x, on %#x\n",
                        lpArb,
                        lpArb->dwBlockedOnEvent
                        ));


            //
            // if we've hit the number of waiters we were to unblock then
            // quit
            //

            ++dwUnblocked;
            if (dwUnblocked == dwNumberOfWaiters) {
                break;
            }

            //
            // we moved the ARB
            //

            lpArb = lpArbPrevious;
        }
        lpArbPrevious = lpArb;
        lpArb = (LPARB)lpArb->List.Flink;
    }

    ReleaseBlockedRequestQueue();

    DEBUG_LEAVE(dwUnblocked);

    return dwUnblocked;
}



VOID
AcquireBlockedRequestQueue(
    VOID
    )

/*++

Routine Description:

    Synchronizes access to the blocked request queue

Arguments:

    None.

Return Value:

    None.

--*/

{
    LockSerializedList(&BlockedRequestQueue);
}


VOID
ReleaseBlockedRequestQueue(
    VOID
    )

/*++

Routine Description:

    Releases the lock acquired with AcquireBlockedRequestQueue

Arguments:

    None.

Return Value:

    None.

--*/

{
    UnlockSerializedList(&BlockedRequestQueue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\autodial.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    autodial.cxx

Abstract:

    Contains the implementation of autodial

    Contents:

Author:

    Darren Mitchell (darrenmi) 22-Apr-1997

Environment:

    Win32(s) user-mode DLL

Revision History:

    22-Apr-1997 darrenmi
        Created


--*/

#include "wininetp.h"
#include "autodial.h"
#include "rashelp.h"
#include <sensapi.h>
#include <winsvc.h>
#include <commctrl.h>
#include "millenras.h"
#include <iphlpapi.h>

// Globals.
// In IE4 - there are several situations when these globals are
// accessed simultaneously by different threads and so we need to protect them
// with a mutex

//
// fDontProcessHook - set to TRUE in the following circumstances:
//
// - autodial is not enabled
// - loading the ras dll failed
// - no modem is installed
//
// this flag is only relevant on Win95.
//
BOOL fDontProcessHook = FALSE;

DWORD   g_dwLastTickCount = 0;

// g_hwndWebCheck is currently not protected with a mutex
HWND g_hwndWebCheck = NULL;               // instead of findwindow every time

// have we already checked out the current connection for proxy change?
BOOL g_fConnChecked = FALSE;

// serialize GetConnectedState
HANDLE g_hConnectionMutex = INVALID_HANDLE_VALUE;

// serialize access to RAS
HANDLE g_hRasMutex = INVALID_HANDLE_VALUE;

// serialize access to proxy reg settings
HANDLE g_hProxyRegMutex = INVALID_HANDLE_VALUE;


// Have we upgraded settings?
BOOL g_fCheckedUpgrade = FALSE;

// should we ask user to go offline if no connect?
BOOL g_fAskOffline = TRUE;

// Don't do any callbacks in rnaapp.exe process
BOOL g_fRNAAppProcess = FALSE;

// We use native font control from comctl so we need to call initcommoncontrols
HMODULE hCommctrl = NULL;
typedef BOOL (WINAPI *PFNINITCOMMONCONTROLS)(LPINITCOMMONCONTROLSEX);

// base key for settings, lives in proxreg.cxx
extern CRefdKey* g_prkBase;

//
// Enable sens network checking
//
#ifndef UNIX
/* On Unix we assume we are on a LAN all the time */
#define CHECK_SENS 1
#endif /* UNIX */

#ifdef CHECK_SENS

// prototype for IsNetworkAlive()
typedef BOOL (WINAPI *ISNETWORKALIVE)(LPDWORD);

// handle to sens dll and entry point
BOOL g_fSensInstalled = TRUE;
HINSTANCE g_hSens = NULL;
ISNETWORKALIVE g_pfnIsNetworkAlive = NULL;

// how often to call sens to check state?  Every 15 seconds seems reasonable
#define MIN_SENS_CHECK_INTERVAL 15000
DWORD g_dwLastSensCheck = 0;

// message we send to dialmon to find out if sens is loaded
#define WM_IS_SENSLCE_LOADED    (WM_USER+201)
#endif

// registry strings
const CHAR szRegPathRemoteAccess[] = REGSTR_PATH_REMOTEACCESS;
const CHAR szRegPathInternetSettings[] = REGSTR_PATH_INTERNET_SETTINGS;
const CHAR szRegValEnableAutodial[] = REGSTR_VAL_ENABLEAUTODIAL;
const CHAR szRegValInternetEntry[] = REGSTR_VAL_INTERNETPROFILE;
const CHAR szRegValUnattended[] = REGSTR_VAL_ENABLEUNATTENDED;
static const CHAR szRegPathRNAProfile[] = REGSTR_PATH_REMOTEACCESS "\\Profile";
static const CHAR szRegValAutodialDllName[] = REGSTR_VAL_AUTODIALDLLNAME;
static const CHAR szRegValAutodialFcnName[] = REGSTR_VAL_AUTODIALFCNNAME;
static const CHAR szRegValAutodialFlags[] = "HandlerFlags";
static const CHAR szRegPathRNAService[] = REGSTR_PATH_SERVICES "\\RemoteAccess";
static const CHAR szRegAddresses[] = "RemoteAccess\\Addresses";
static const CHAR szRegPathTCP[] = REGSTR_PATH_VXD "\\MSTCP";
static const CHAR szRegValRemoteConnection[] = "Remote Connection";
static const CHAR szRegValHostName[] = "HostName";
static const CHAR szInetPerformSecurityCheck[] = "InetPerformSecurityCheck";
static const CHAR szRegValEnableSecurityCheck[] = REGSTR_VAL_ENABLESECURITYCHECK;
static const CHAR szAutodialMonitorClass[] = REGSTR_VAL_AUTODIAL_MONITORCLASSNAME;
static const CHAR szWebCheckMonitorClass[] = "MS_WebCheckMonitor";
static const CHAR szRegPathComputerName[] = REGSTR_PATH_COMPUTRNAME;
static const CHAR szRegValComputerName[] = REGSTR_VAL_COMPUTRNAME;
static const CHAR szMigrateProxy[] = "MigrateProxy";
static const CHAR szProxySuspect[] = "ProxySuspect";
static const CHAR szCMDllName[] = "cmdial32.dll";

// wide version of various registry strings
#define TSZMICROSOFTPATHW                   L"Software\\Microsoft"
#define TSZIEPATHW        TSZMICROSOFTPATHW L"\\Internet Explorer"
#define TSZWINCURVERPATHW TSZMICROSOFTPATHW L"\\windows\\CurrentVersion"
#define TSZWININETPATHW   TSZWINCURVERPATHW L"\\Internet Settings"

#define REGSTR_PATH_INTERNETSETTINGSW       TSZWININETPATHW
#define REGSTR_PATH_INTERNET_LAN_SETTINGSW  REGSTR_PATH_INTERNETSETTINGSW L"\\LAN"
#define REGSTR_DIAL_AUTOCONNECTW            L"AutoConnect"
#define REGSTR_VAL_COVEREXCLUDEW            L"CoverExclude"
#define REGSTR_VAL_REDIALATTEMPTSW          L"RedialAttempts"
#define REGSTR_VAL_REDIALINTERVALW          L"RedialWait"
#define REGSTR_VAL_INTERNETENTRYW           L"InternetProfile"
#define REGSTR_VAL_INTERNETPROFILEW         REGSTR_VAL_INTERNETENTRYW
#define REGSTR_PATH_REMOTEACCESSW           L"RemoteAccess"
#define REGSTR_VAL_AUTODIALDLLNAMEW         L"AutodialDllName"
#define REGSTR_VAL_AUTODIALFCNNAMEW         L"AutodialFcnName"

const WCHAR szRegValInternetEntryW[] = REGSTR_VAL_INTERNETPROFILEW;
const WCHAR szRegPathRemoteAccessW[] = REGSTR_PATH_REMOTEACCESSW;
const WCHAR szRegPathRNAProfileW[] = REGSTR_PATH_REMOTEACCESSW L"\\Profile";
const WCHAR szRegValAutodialDllNameW[] = REGSTR_VAL_AUTODIALDLLNAMEW;
const WCHAR szRegValAutodialFcnNameW[] = REGSTR_VAL_AUTODIALFCNNAMEW;
const WCHAR szRegValAutodialFlagsW[] = L"HandlerFlags";
const WCHAR szCMDllNameW[] = L"cmdial32.dll";

// NT reg keys for finding ras phonebook file
static const CHAR szNTRasPhonebookKey[] = "Software\\Microsoft\\RAS Phonebook";
static const CHAR szPhonebookMode[] = "PhonebookMode";

// don't check RNA state more than once every 3 seconds
#define MIN_RNA_BUSY_CHECK_INTERVAL 3000

// Name or reg value we save legacy settings for comparison later
#define LEGACY_MIGRATE_FLAGS        (PROXY_TYPE_PROXY | PROXY_TYPE_AUTO_PROXY_URL)

//
// Current ras connections - used so we don't poll ras every time we're
// interested - only poll every 3 seconds (const. above)
//
RasEnumConnHelp g_RasCon;
DWORD       g_dwConnections = 0;
BOOL        g_fRasInstalled = FALSE;
DWORD       g_dwLastDialupTicks = 0;

//
// API setting for autodial.  Allow individual processes to disable autodial
// using InternetSetOption.
//
// This can override an enabled setting but not a disabled setting.
//
BOOL        g_fAutodialEnableAPISetting = TRUE;

//
// Control of autodial initialization
//
BOOL        g_fAutodialInitialized = FALSE;

//
// Do we know for sure that winsock is loaded?
//
BOOL        g_fWinsockLoaded = FALSE;


HANDLE      g_hDialEvent = NULL;
//
// Structure used to mess about with proxy settings
//
typedef struct _proxy {
    DWORD   dwEnable;
    TCHAR   szServer[INTERNET_MAX_URL_LENGTH];
    TCHAR   szOverride[INTERNET_MAX_URL_LENGTH];
    DWORD   dwSuspect;
} PROXY, *PPROXY;

//
// Need GetBestRoute from iphlpapi -- dynaload it, free on ExitAutodialModule
//
typedef DWORD (WINAPI *GETBESTROUTE)(DWORD, DWORD, PMIB_IPFORWARDROW);

static HINSTANCE g_hIphlpapi = NULL;
static GETBESTROUTE g_pfnGetBestRoute = NULL;

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                         RAS dynaload code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static HINSTANCE g_hRasLib = NULL;
static long g_lRasRefCnt = 0;

static _RASHANGUP               pfnRasHangUp = NULL;

static _RASDIALA                 pfnRasDialA = NULL;
static _RASENUMENTRIESA          pfnRasEnumEntriesA = NULL;
static _RASGETENTRYDIALPARAMSA   pfnRasGetEntryDialParamsA = NULL;
static _RASSETENTRYDIALPARAMSA   pfnRasSetEntryDialParamsA = NULL;
static _RASEDITPHONEBOOKENTRYA   pfnRasEditPhonebookEntryA = NULL;
static _RASCREATEPHONEBOOKENTRYA pfnRasCreatePhonebookEntryA = NULL;
static _RASGETERRORSTRINGA       pfnRasGetErrorStringA = NULL;
static _RASGETCONNECTSTATUSA     pfnRasGetConnectStatusA = NULL;
static _RASENUMCONNECTIONSA      pfnRasEnumConnectionsA = NULL;
static _RASGETENTRYPROPERTIESA   pfnRasGetEntryPropertiesA = NULL;

static _RASDIALW                 pfnRasDialW = NULL;
static _RASENUMENTRIESW          pfnRasEnumEntriesW = NULL;
static _RASGETENTRYDIALPARAMSW   pfnRasGetEntryDialParamsW = NULL;
static _RASSETENTRYDIALPARAMSW   pfnRasSetEntryDialParamsW = NULL;
static _RASEDITPHONEBOOKENTRYW   pfnRasEditPhonebookEntryW = NULL;
static _RASCREATEPHONEBOOKENTRYW pfnRasCreatePhonebookEntryW = NULL;
static _RASGETERRORSTRINGW       pfnRasGetErrorStringW = NULL;
static _RASGETCONNECTSTATUSW     pfnRasGetConnectStatusW = NULL;
static _RASENUMCONNECTIONSW      pfnRasEnumConnectionsW = NULL;
static _RASGETENTRYPROPERTIESW   pfnRasGetEntryPropertiesW = NULL;

// Millennium (DUN 1.4?) RAS exports
static _RASINTERNETDIAL          pfnRasInternetDialA = NULL;
static _RASINTERNETHANGUP        pfnRasInternetHangUpA = NULL;
static _RASINTERNETAUTODIAL      pfnRasInternetAutodialA = NULL;
static _RASINTERNETAUTODIALHANG  pfnRasInternetAutodialHangUpA = NULL;
static _RASINTERNETCONNSTATE     pfnRasInternetGetConnectedStateExA = NULL;
static _RNAGETDEFAULTAUTODIAL    pfnRnaGetDefaultAutodialConnection = NULL;
static _RNASETDEFAULTAUTODIAL    pfnRnaSetDefaultAutodialConnection = NULL;

// RAS entry points to sync up autodial connectoid... used on whistler only
static _RASGETAUTODIALADDRESSA   pfnRasGetAutodialAddressA = NULL;
static _RASSETAUTODIALADDRESSA   pfnRasSetAutodialAddressA = NULL;

static _RASGETCREDENTIALSW       pfnRasGetCredentialsW = NULL;
static _RASSETCREDENTIALSW       pfnRasSetCredentialsW = NULL;

typedef struct _tagAPIMAPENTRY {
    FARPROC* pfn;
    LPSTR pszProc;
} APIMAPENTRY;

APIMAPENTRY rgRasApiMapA[] = {
    { (FARPROC*) &pfnRasDialA,                   "RasDialA" },
    { (FARPROC*) &pfnRasHangUp,                  "RasHangUpA" },
    { (FARPROC*) &pfnRasEnumEntriesA,            "RasEnumEntriesA" },
    { (FARPROC*) &pfnRasGetEntryDialParamsA,     "RasGetEntryDialParamsA" },
    { (FARPROC*) &pfnRasSetEntryDialParamsA,     "RasSetEntryDialParamsA" },
    { (FARPROC*) &pfnRasEditPhonebookEntryA,     "RasEditPhonebookEntryA" },
    { (FARPROC*) &pfnRasCreatePhonebookEntryA,   "RasCreatePhonebookEntryA" },
    { (FARPROC*) &pfnRasGetErrorStringA,         "RasGetErrorStringA" },
    { (FARPROC*) &pfnRasGetConnectStatusA,       "RasGetConnectStatusA" },
    { (FARPROC*) &pfnRasEnumConnectionsA,        "RasEnumConnectionsA" },
    { (FARPROC*) &pfnRasGetEntryPropertiesA,     "RasGetEntryPropertiesA"},
    { (FARPROC*) &pfnRasInternetDialA,           "RasInternetDialA"},
    { (FARPROC*) &pfnRasInternetHangUpA,         "RasInternetHangUpA"},
    { (FARPROC*) &pfnRasInternetAutodialA,       "RasInternetAutodialA"},
    { (FARPROC*) &pfnRasInternetAutodialHangUpA, "RasInternetAutodialHangUpA"},
    { (FARPROC*) &pfnRasInternetGetConnectedStateExA, "RasInternetGetConnectedStateExA"},
    { (FARPROC*) &pfnRnaGetDefaultAutodialConnection, "RnaGetDefaultAutodialConnection"},
    { (FARPROC*) &pfnRnaSetDefaultAutodialConnection, "RnaSetDefaultAutodialConnection"},
    { NULL, NULL },
};

APIMAPENTRY rgRasApiMapW[] = {
    { (FARPROC*) &pfnRasDialW,                   "RasDialW" },
    { (FARPROC*) &pfnRasHangUp,                  "RasHangUpW" },
    { (FARPROC*) &pfnRasEnumEntriesW,            "RasEnumEntriesW" },
    { (FARPROC*) &pfnRasGetEntryDialParamsW,     "RasGetEntryDialParamsW" },
    { (FARPROC*) &pfnRasSetEntryDialParamsW,     "RasSetEntryDialParamsW" },
    { (FARPROC*) &pfnRasEditPhonebookEntryW,     "RasEditPhonebookEntryW" },
    { (FARPROC*) &pfnRasCreatePhonebookEntryW,   "RasCreatePhonebookEntryW" },
    { (FARPROC*) &pfnRasGetErrorStringW,         "RasGetErrorStringW" },
    { (FARPROC*) &pfnRasGetConnectStatusW,       "RasGetConnectStatusW" },
    { (FARPROC*) &pfnRasEnumConnectionsW,        "RasEnumConnectionsW" },
    { (FARPROC*) &pfnRasGetEntryPropertiesW,     "RasGetEntryPropertiesW"},
    { (FARPROC*) &pfnRasGetCredentialsW,         "RasGetCredentialsW"},
    { (FARPROC*) &pfnRasSetCredentialsW,         "RasSetCredentialsW"},

    // following are A in W map on purpose.. used on whistler only, but wininet code has
    // the connectoid in multibyte.. may as well let RAS convert it.
    { (FARPROC*) &pfnRasGetAutodialAddressA,     "RasGetAutodialAddressA"},
    { (FARPROC*) &pfnRasSetAutodialAddressA,     "RasSetAutodialAddressA"},
    { NULL, NULL },
};

#define RASFCN(_fn, _part, _par, _dbge, _dbgl)     \
DWORD _##_fn _part                          \
{                                           \
    DEBUG_ENTER(_dbge);                     \
                                            \
    DWORD dwRet;                            \
    if(NULL == pfn##_fn)                    \
    {                                       \
        _dbgl(ERROR_INVALID_FUNCTION);      \
        return ERROR_INVALID_FUNCTION;      \
    }                                       \
                                            \
    dwRet = (* pfn##_fn) _par;              \
                                            \
    _dbgl(dwRet);                           \
    return dwRet;                           \
}

RASFCN(RasDialA,
    (LPRASDIALEXTENSIONS lpRasDialExtensions, LPSTR lpszPhonebook, LPRASDIALPARAMS lpRasDialParams, DWORD dwNotifierType, LPVOID lpvNotifier, LPHRASCONN lphRasConn),
    (lpRasDialExtensions, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    (DBG_DIALUP, Dword, "RasDialA", "%#x, %#x (%q), %#x, %d, %#x, %#x", lpRasDialExtensions, lpszPhonebook, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    DEBUG_LEAVE
    );

RASFCN(RasHangUp,
    (HRASCONN hRasConn),
    (hRasConn),
    (DBG_DIALUP, Dword, "RasHangUp", "%#x", hRasConn),
    DEBUG_LEAVE
    );

RASFCN(RasEnumEntriesA,
    (LPSTR lpszReserved, LPSTR lpszPhonebook, LPRASENTRYNAMEA lprasentryname, LPDWORD lpcb, LPDWORD lpcEntries),
    (lpszReserved, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    (DBG_DIALUP, Dword, "RasEnumEntriesA", "%#x (%q), %#x (%q), %#x, %#x, %#x", lpszReserved, lpszReserved, lpszPhonebook, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryDialParamsA,
    (LPCSTR lpszPhonebook, LPRASDIALPARAMS lprasdialparams, LPBOOL lpfPassword),
    (lpszPhonebook, lprasdialparams, lpfPassword),
    (DBG_DIALUP, Dword, "RasGetEntryDialParamsA", "%#x (%q), %#x, %#x", lpszPhonebook, lpszPhonebook, lprasdialparams, lpfPassword),
    DEBUG_LEAVE
    );

RASFCN(RasSetEntryDialParamsA,
    (LPCSTR lpszPhonebook,LPRASDIALPARAMS lprasdialparams, BOOL fRemovePassword),
    (lpszPhonebook,lprasdialparams, fRemovePassword),
    (DBG_DIALUP, Dword, "RasSetEntryDialParamsA", "%#x (%q), %#x, %d", lpszPhonebook, lpszPhonebook, lprasdialparams, fRemovePassword),
    DEBUG_LEAVE
    );

RASFCN(RasGetErrorStringA,
    (UINT uError, LPSTR pszBuf, DWORD cBufSize),
    (uError, pszBuf, cBufSize),
    (DBG_DIALUP, Dword, "RasGetErrorStringA", "%d, %#x (%q), %d", uError, pszBuf, cBufSize),
    DEBUG_LEAVE
    );

RASFCN(RasEditPhonebookEntryA,
    (HWND hwnd, LPSTR lpszBook, LPSTR lpszEntry),
    (hwnd, lpszBook, lpszEntry),
    (DBG_DIALUP, Dword, "RasEditPhonebookEntryA", "%#x, %#x (%q), %#x (%q)", hwnd, lpszBook, lpszBook, lpszEntry, lpszEntry),
    DEBUG_LEAVE
    );

RASFCN(RasCreatePhonebookEntryA,
    (HWND hwnd, LPSTR pszBook),
    (hwnd, pszBook),
    (DBG_DIALUP, Dword, "RasCreatePhonebookEntryA", "%#x, %#x (%q)", hwnd, pszBook, pszBook),
    DEBUG_LEAVE
    );

RASFCN(RasGetConnectStatusA,
    (HRASCONN hrasconn, LPRASCONNSTATUS lprasconnstatus),
    (hrasconn, lprasconnstatus),
    (DBG_DIALUP, Dword, "RasGetConnectStatusA", "%#x, %#x", hrasconn, lprasconnstatus),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryPropertiesA,
    (LPSTR lpszPhonebook, LPSTR lpszEntry, LPRASENTRY lpRasEntry, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhonebook, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    (DBG_DIALUP, Dword, "RasGetEntryPropertiesA", "%#x (%q), %#x (%q), %#x, %#x, %#x %#x", lpszPhonebook, lpszPhonebook, lpszEntry, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    DEBUG_LEAVE
    );

RASFCN(RasEnumConnectionsA,
    (LPRASCONN lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn),
    (lpRasConn, lpdwSize, lpdwConn),
    (DBG_DIALUP, Dword, "RasEnumConnectionsA", "%#x, %#x, %#x", lpRasConn, lpdwSize, lpdwConn),
    DEBUG_LEAVE
    );

RASFCN(RasInternetDialA,
    (HWND hwndParent, LPSTR pszEntryName, DWORD dwFlags, DWORD_PTR *lpdwConnection, DWORD dwReserved),
    (hwndParent, pszEntryName, dwFlags, lpdwConnection, dwReserved),
    (DBG_DIALUP, Dword, "RasInternetDialA", "#x, #x (%q), %x, %x, %x", hwndParent, pszEntryName, pszEntryName, dwFlags, lpdwConnection, dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RasInternetHangUpA,
    (DWORD_PTR dwConnection, DWORD dwReserved),
    (dwConnection, dwReserved),
    (DBG_DIALUP, Dword, "RasInternetHangUpA", "#x, #x", dwConnection, dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RasInternetAutodialA,
    (DWORD dwFlags, HWND hwndParent),
    (dwFlags, hwndParent),
    (DBG_DIALUP, Dword, "RasInterenetAutodialA", "#x, #x", dwFlags, hwndParent),
    DEBUG_LEAVE
    );

RASFCN(RasInternetAutodialHangUpA,
    (DWORD dwReserved),
    (dwReserved),
    (DBG_DIALUP, Dword, "RasInternetAutodialHangUpA", "#x", dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RasInternetGetConnectedStateExA,
    (LPDWORD lpdwFlags, LPSTR lpszConnectionName, DWORD dwBufLen, DWORD dwReserved),
    (lpdwFlags, lpszConnectionName, dwBufLen, dwReserved),
    (DBG_DIALUP, Bool, "RasInternetGetConnectedStateExA", "%x, %x, %x, %x", lpdwFlags, lpszConnectionName, dwBufLen, dwReserved),
    DEBUG_LEAVE
    );

RASFCN(RnaGetDefaultAutodialConnection,
    (LPSTR pszEntry, DWORD dwLen, LPDWORD lpdwFlags),
    (pszEntry, dwLen, lpdwFlags),
    (DBG_DIALUP, Dword, "RnaGetDefaultAutodialConnection", "%#x, %#x, %#x", pszEntry, dwLen, lpdwFlags),
    DEBUG_LEAVE
    );

RASFCN(RnaSetDefaultAutodialConnection,
    (LPSTR pszEntry, DWORD dwFlags),
    (pszEntry, dwFlags),
    (DBG_DIALUP, Dword, "RnaSetDefaultAutodialConnection", "%#x (%q), %#x", pszEntry, pszEntry, dwFlags),
    DEBUG_LEAVE
    );

////////////////////////////////////////////////////
// Wide versions
RASFCN(RasDialW,
    (LPRASDIALEXTENSIONS lpRasDialExtensions, LPWSTR lpszPhonebook,
    LPRASDIALPARAMSW lpRasDialParams, DWORD dwNotifierType, LPVOID lpvNotifier, LPHRASCONN lphRasConn),
    (lpRasDialExtensions, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    (DBG_DIALUP, Dword, "RasDialW", "%#x, %#x (%Q), %#x, %d, %#x, %#x", lpRasDialExtensions, lpszPhonebook, lpszPhonebook, lpRasDialParams, dwNotifierType, lpvNotifier, lphRasConn),
    DEBUG_LEAVE
    );

RASFCN(RasEnumEntriesW,
    (LPWSTR lpszReserved, LPWSTR lpszPhonebook, LPRASENTRYNAMEW lprasentryname,
    LPDWORD lpcb, LPDWORD lpcEntries),
    (lpszReserved, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    (DBG_DIALUP, Dword, "RasEnumEntriesW", "%#x (%Q), %#x (%Q), %#x, %#x %#x", lpszReserved, lpszReserved, lpszPhonebook, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryDialParamsW,
    (LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, LPBOOL lpfPassword),
    (lpszPhonebook, lprasdialparams, lpfPassword),
    (DBG_DIALUP, Dword, "RasGetEntryDialParamsW", "%#x (%Q), %#x, %#x", lpszPhonebook, lpszPhonebook, lprasdialparams, lpfPassword),
    DEBUG_LEAVE
    );

RASFCN(RasSetEntryDialParamsW,
    (LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, BOOL fRemovePassword),
    (lpszPhonebook,lprasdialparams, fRemovePassword),
    (DBG_DIALUP, Dword, "RasSetEntryDialParamsW", "%#x (%Q), %#x, %d", lpszPhonebook, lpszPhonebook, lprasdialparams, fRemovePassword),
    DEBUG_LEAVE
    );

RASFCN(RasGetErrorStringW,
    (UINT uError, LPWSTR pszBuf, DWORD cBufSize),
    (uError, pszBuf, cBufSize),
    (DBG_DIALUP, Dword, "RasGetErrorStringW", "%d, %#x (%Q), %d", uError, pszBuf, cBufSize),
    DEBUG_LEAVE
    );

RASFCN(RasEditPhonebookEntryW,
    (HWND hwnd, LPWSTR lpszBook, LPWSTR lpszEntry),
    (hwnd, lpszBook, lpszEntry),
    (DBG_DIALUP, Dword, "RasEditPhonebookEntryW", "%#x, %#x (%Q), %#x (%Q)", hwnd, lpszBook, lpszBook, lpszEntry, lpszEntry),
    DEBUG_LEAVE
    );

RASFCN(RasCreatePhonebookEntryW,
    (HWND hwnd, LPWSTR pszBook),
    (hwnd, pszBook),
    (DBG_DIALUP, Dword, "RasCreatePhonebookEntryW", "%#x, %#x (%Q)", hwnd, pszBook, pszBook),
    DEBUG_LEAVE
    );

RASFCN(RasGetConnectStatusW,
    (HRASCONN hrasconn, LPRASCONNSTATUSW lprasconnstatus),
    (hrasconn, lprasconnstatus),
    (DBG_DIALUP, Dword, "RasGetConnectStatusW", "%#x, %#x", hrasconn, lprasconnstatus),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryPropertiesW,
    (LPWSTR lpszPhonebook, LPWSTR lpszEntry, LPRASENTRYW lpRasEntry, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhonebook, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    (DBG_DIALUP, Dword, "RasGetEntryPropertiesW", "%#x (%Q), %#x (%Q), %#x, %#x, %#x %#x", lpszPhonebook, lpszPhonebook, lpszEntry, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    DEBUG_LEAVE
    );

RASFCN(RasEnumConnectionsW,
    (LPRASCONNW lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn),
    (lpRasConn, lpdwSize, lpdwConn),
    (DBG_DIALUP, Dword, "RasEnumConnectionsW", "%#x, %#x, %#x", lpRasConn, lpdwSize, lpdwConn),
    DEBUG_LEAVE
    );

RASFCN(RasGetAutodialAddressA,
    (LPCSTR lpszAddress, LPDWORD lpdwReserved, LPRASAUTODIALENTRYA lpEntries, LPDWORD lpdwBytes, LPDWORD lpdwEntries),
    (lpszAddress, lpdwReserved, lpEntries, lpdwBytes, lpdwEntries),
    (DBG_DIALUP, Dword, "RasGetAutodialAddressA", "%#x (%Q), %#x, %#x, %#x, %#x", lpszAddress, lpszAddress, lpdwReserved, lpEntries, lpdwBytes, lpdwEntries),
    DEBUG_LEAVE
    );

RASFCN(RasSetAutodialAddressA,
    (LPCSTR lpszAddress, DWORD dwReserved, LPRASAUTODIALENTRYA lpEntries, DWORD dwBytes, DWORD dwEntries),
    (lpszAddress, dwReserved, lpEntries, dwBytes, dwEntries),
    (DBG_DIALUP, Dword, "RasSetAutodialAddressA", "%#x (%q), %#x, %#x, %#x, %#x", lpszAddress, lpszAddress, dwReserved, lpEntries, dwBytes, dwEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetCredentialsW,
    (LPCWSTR pszPhonebook, LPCWSTR pszEntry, LPRASCREDENTIALSW pCreds),
    (pszPhonebook, pszEntry, pCreds),
    (DBG_DIALUP, Dword, "RasGetCredentialsW", "%#x (%Q), %#x (%Q), %#x", pszPhonebook, pszPhonebook, pszEntry, pszEntry, pCreds),
    DEBUG_LEAVE
    );

RASFCN(RasSetCredentialsW,
    (LPCWSTR pszPhonebook, LPCWSTR pszEntry, LPRASCREDENTIALSW pCreds, BOOL fNuke),
    (pszPhonebook, pszEntry, pCreds, fNuke),
    (DBG_DIALUP, Dword, "RasSetCredentialsW", "%#x (%Q), %#x (%Q), %#x, %#x", pszPhonebook, pszPhonebook, pszEntry, pszEntry, pCreds, fNuke),
    DEBUG_LEAVE
    );

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
EnsureRasLoaded(
    VOID
    )

/*++

Routine Description:

    Dynaload ras apis

Arguments:

    pfInstalled - return installed state of ras

Return Value:

    BOOL
        TRUE    - Ras loaded
        FALSE   - Ras not loaded

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "EnsureRasLoaded",
                 NULL
                 ));

    //
    // Looks like RAS is installed - try and load it up!
    //
    if(NULL == g_hRasLib) {
        g_hRasLib = LoadLibrary("RASAPI32.DLL");

        if(NULL == g_hRasLib)
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        APIMAPENTRY *prgRasApiMap;
        if(PLATFORM_TYPE_WIN95 == GlobalPlatformType)
            prgRasApiMap = rgRasApiMapA;
        else
            prgRasApiMap = rgRasApiMapW;

        int nIndex = 0;
        while ((prgRasApiMap+nIndex)->pszProc != NULL) {
            // Some functions are only present on some platforms.  Don't
            // assume this succeeds for all functions.
            *(prgRasApiMap+nIndex)->pfn =
                    GetProcAddress(g_hRasLib, (prgRasApiMap+nIndex)->pszProc);
            nIndex++;
        }
    }

    if(g_hRasLib) {
        g_lRasRefCnt++;
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
IsServiceRunning(
    LPSTR   pszServiceName,
    DWORD   dwRequiredState
    )

/*++

Routine Description:

    Determines whether a specified service is running on NT

Arguments:

    pszServiceName  - service to find
    dwRequiredState - state the service has to be in to consider it found

Return Value:

    BOOL
        TRUE        - Service is in required state

        FALSE       - not

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsServiceRunning",
                 "%#x (%q), %#x",
                 pszServiceName,
                 pszServiceName,
                 dwRequiredState
                 ));

    SC_HANDLE   hscm;
    BOOL        fFoundService = FALSE;

    //
    // Sanity check - can only do this on NT
    //
    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // Ask service manager to enumerate all running services
    //
    hscm = OpenSCManager(NULL, NULL, GENERIC_READ);
    if(hscm)
    {
        SC_HANDLE hras;
        ENUM_SERVICE_STATUS essServices[16];
        DWORD dwError, dwResume = 0, i;
        DWORD cbNeeded = 1, csReturned;

        while(FALSE == fFoundService && cbNeeded > 0)
        {
            // Get the next chunk of services
            dwError = 0;
            if(FALSE == EnumServicesStatus(hscm, SERVICE_WIN32, dwRequiredState,
                    essServices, sizeof(essServices), &cbNeeded, &csReturned,
                    &dwResume))
            {
                dwError = GetLastError();
            }

            if(dwError && dwError != ERROR_MORE_DATA)
            {
                // unknown error - bail
                break;
            }

            for(i=0; i<csReturned; i++)
            {
                if(0 == lstrcmpi(essServices[i].lpServiceName, pszServiceName))
                {
                    // found it!
                    fFoundService = TRUE;
                    break;
                }
            }
        }

        CloseServiceHandle(hscm);
    }

    DEBUG_LEAVE(fFoundService);
    return fFoundService;
}


BOOL
IsRasInstalled(
    VOID
    )

/*++

Routine Description:

    Determines whether ras is installed on this machine

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Ras is installed

        FALSE   - Ras is not installed

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "IsRasInstalled",
                 NULL
                 ));

    static fChecked = FALSE;

    //
    // If RAS is already loaded, don't bother doing any work.
    //
    if(g_hRasLib)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if we've already done the check, don't do it again
    //
    if(fChecked)
    {
        DEBUG_LEAVE_API(g_fRasInstalled);
        return g_fRasInstalled;
    }

    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType) {
        //
        // Check Win9x key
        //
        char    szSmall[3]; // there should be a "1" or a "0" only
        DWORD   cb;
        HKEY    hkey;
        long    lRes;

        lRes = REGOPENKEYEX(HKEY_LOCAL_MACHINE, REGSTR_PATH_RNACOMPONENT,
                             NULL, KEY_READ, &hkey);
        if(ERROR_SUCCESS == lRes) {
            cb = sizeof(szSmall);
            //  REGSTR_VAL_RNAINSTALLED is defined with TEXT() macro so
            //  if wininet is ever compiled unicode this will be a compile
            //  error.
            lRes = RegQueryValueExA(hkey, REGSTR_VAL_RNAINSTALLED, NULL,
                    NULL, (LPBYTE)szSmall, &cb);
            if(ERROR_SUCCESS == lRes) {
                if((szSmall[0] == '1') && (szSmall[1] == 0)) {
                    // 1 means ras installed
                    g_fRasInstalled = TRUE;
                }
            }
            REGCLOSEKEY(hkey);
        }
    } else {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osvi);

        if (osvi.dwMajorVersion < 5)
        {
            // on NT4, make sure ras man service is installed
            g_fRasInstalled = IsServiceRunning("RasMan", SERVICE_STATE_ALL);

            if(g_fRasInstalled)
            {
                if(EnsureRasLoaded() && FALSE == GlobalDisableNT4RasCheck)
                {
                    RasEnumHelp *pRasEnum = NULL;
                    __try
                    {
                        // call rasenumentries - if it faults, we're in that
                        // NT4 busted case so return not installed.
                        pRasEnum = new RasEnumHelp;
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        // if it faults, don't use ras any more
                        g_fRasInstalled = FALSE;
                    }
                    ENDEXCEPT

                    if (pRasEnum)
                        delete pRasEnum;
                }
            }
        }
        else
        {
            // NT5 and presumably beyond, ras is always installed
            g_fRasInstalled = TRUE;
        }
    }

    fChecked = TRUE;

    DEBUG_LEAVE_API(g_fRasInstalled);
    return g_fRasInstalled;
}


BOOL
DoConnectoidsExist(
    VOID
    )

/*++

Routine Description:

    Determines whether any ras connectoids exist

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Connectoids exist

        FALSE   - No connectoids exist

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "DoConnectoidsExist",
                 NULL
                 ));

    static BOOL fExist = FALSE;

    //
    // If we found connectoids before, don't bother looking again
    //
    if(fExist)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // If RAS is already loaded, ask it
    //
    if(g_hRasLib && FALSE == GlobalDisableNT4RasCheck) {
        DWORD dwRet, dwEntries;

        RasEnumHelp *pRasEnum = new RasEnumHelp;

        if (pRasEnum)
        {
            dwRet = pRasEnum->GetError();
            dwEntries = pRasEnum->GetEntryCount();
            delete pRasEnum;
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }

        // If ras tells us there are none, return none
        if(ERROR_SUCCESS == dwRet && 0 == dwEntries)
        {
            DEBUG_LEAVE_API(FALSE);
            return FALSE;
        }
        // couldn't determine that there aren't any so assume there are.
        fExist = TRUE;
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if ras isn't installed, say no connectoids
    //
    if(FALSE == IsRasInstalled())
    {
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType) {
        // On win95, check for any value in RemoteAccess\Addresses reg key
        HKEY    hkey;
        TCHAR   szName[RAS_MaxEntryName+1];
        DWORD   cbName = RAS_MaxEntryName+1;
        long    lRes;

        if(ERROR_SUCCESS == REGOPENKEYEX(HKEY_CURRENT_USER, szRegAddresses,
                0, KEY_READ, &hkey)) {

            lRes = RegEnumValue(hkey, 0, szName, &cbName, NULL, NULL, NULL, NULL);
            if(ERROR_SUCCESS == lRes) {
                // we managed to get info on a connectoid.
                fExist = TRUE;
            }

            REGCLOSEKEY(hkey);
        }
    } else {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx(&osvi);

        // assume connectoids exist
        fExist = TRUE;

        if (osvi.dwMajorVersion < 5) {
            // On NT4, check for rasphone.pbk size > 0
            TCHAR   szPhonebook[MAX_PATH + 128];
            ULONG   uLen, ulMode, cb;
            HANDLE  hFile = INVALID_HANDLE_VALUE;
            DWORD   dwSize, dwBigSize;
            HKEY    hkey;

            // Ensure system phonebook is the one in use.  If user has switched
            // to another phonebook, don't bother doing anything else and assume
            // connectoids exist.  It's not our job to grope the world trying to
            // find custom phonebooks.
            if(ERROR_SUCCESS == REGOPENKEYEX(HKEY_CURRENT_USER, szNTRasPhonebookKey,
                0, KEY_READ, &hkey))
            {
                *szPhonebook = 0;
                cb = sizeof(ULONG);
                if(ERROR_SUCCESS == RegQueryValueEx(hkey, szPhonebookMode, NULL,
                        NULL, (LPBYTE)&ulMode, &cb) && 0 == ulMode)
                {
                    // system phonebook - rasphone.pbk in ras directory
                    uLen = GetSystemDirectory(szPhonebook, MAX_PATH);
                    if(uLen)
                    {
                        // append \ras\rasphone.pbk
                        LoadString(GlobalDllHandle, IDS_RASPHONEBOOK, szPhonebook + uLen, 128);
                        hFile = CreateFile(szPhonebook, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    NULL, OPEN_EXISTING, 0, NULL);
                        if(INVALID_HANDLE_VALUE == hFile) {
                            // file doesn't exist - no connectoids
                            fExist = FALSE;
                        } else {
                            dwSize = GetFileSize(hFile, &dwBigSize);
                            if(0 == dwSize && 0 == dwBigSize)
                                // zero size system phonebook - no connectoids
                                fExist = FALSE;
                            CloseHandle(hFile);
                        }
                    }
                }
                REGCLOSEKEY(hkey);
            }
        }
    }

    DEBUG_LEAVE_API(fExist);
    return fExist;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                          Helper Functions
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
InitCommCtrl(
    VOID
    )

/*++

Routine Description:

    Initializes common controls for native font control

    Called from InternetDialA which is serialized.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - successly called InitCommonControlsEx
        FALSE   - failed

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "InitCommCtrl",
                 NULL
                 ));

    BOOL fSuccess = FALSE;

    hCommctrl = LoadLibrary("comctl32.dll");
    if(hCommctrl)
    {
        PFNINITCOMMONCONTROLS pfnInit;

        pfnInit = (PFNINITCOMMONCONTROLS)GetProcAddress(hCommctrl, "InitCommonControlsEx");
        if(pfnInit)
        {
            INITCOMMONCONTROLSEX ex;

            ex.dwSize = sizeof(ex);
            ex.dwICC = ICC_NATIVEFNTCTL_CLASS;
            pfnInit(&ex);
            fSuccess = TRUE;
        }
    }

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}


VOID
ExitCommCtrl(
    VOID
    )

/*++

Routine Description:

    Unloads commctrl library

    Called from InternetDialA which is serialized.

Arguments:

    None

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ExitCommCtrl",
                 NULL
                 ));

    if(hCommctrl)
    {
        FreeLibrary(hCommctrl);
        hCommctrl = NULL;
    }

    DEBUG_LEAVE(0);
}


BOOL
IsGlobalOffline(
    VOID
    )

/*++

Routine Description:

    Determines whether wininet is in global offline mode

Arguments:

    None

Return Value:

    BOOL
        TRUE    - offline
        FALSE   - online

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsGlobalOffline",
                 NULL
                 ));

    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}


VOID
SetOffline(
    IN BOOL fOffline
    )

/*++

Routine Description:

    Sets wininet's offline mode

Arguments:

    fOffline    - online or offline

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "SetOffline",
                 "%B",
                 fOffline
                 ));

    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));

    DEBUG_LEAVE(0);
}


VOID
GetConnKeyW(
    IN LPWSTR pszConn,
    IN LPWSTR pszKey,
    IN int iLen
    )

/*++

Routine Description:

    Get registry key for a specific connection

Arguments:

    pszConn     - connection for which key is required
    pszKey      - buffer to put key
    iLen        - buffer size

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "GetConnKeyW",
                 "%#x (%Q), %#x, %d",
                 pszConn,
                 pszConn,
                 pszKey,
                 iLen
                 ));

    if(NULL == pszConn || 0 == *pszConn)
    {
        // lan setting
        StrCpyNW(pszKey, REGSTR_PATH_INTERNET_LAN_SETTINGSW, iLen);
    }
    else
    {
        // connectoid settings
        wnsprintfW(pszKey, iLen, L"%ws\\%ws", szRegPathRNAProfileW, pszConn);
    }

    DEBUG_LEAVE(0);
}

VOID
GetConnKeyA(
    IN LPSTR pszConn,
    IN LPSTR pszKey,
    IN int iLen
    )

/*++

Routine Description:

    Get registry key for a specific connection

Arguments:

    pszConn     - connection for which key is required
    pszKey      - buffer to put key
    iLen        - buffer size

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "GetConnKeyA",
                 "%#x (%q), %#x, %d",
                 pszConn,
                 pszConn,
                 pszKey,
                 iLen
                 ));

    if(NULL == pszConn || 0 == *pszConn)
    {
        // lan setting
        lstrcpynA(pszKey, REGSTR_PATH_INTERNET_LAN_SETTINGS, iLen);
    }
    else
    {
        // connectoid settings
        wnsprintfA(pszKey, iLen, "%s\\%s", szRegPathRNAProfile, pszConn);
    }

    DEBUG_LEAVE(0);
}


VOID
SetAutodialEnable(
    IN BOOL     fEnable
    )

/*++

Routine Description:

    Sets the API setting for controlling autodial.  Called from
    InternetSetOption.

Arguments:

    fEnable     - FALSE means don't autodial for this process
                  TRUE means autodial if configured by the user

Return Value:

    none.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "SetAutodialEnable",
                 "%B",
                 fEnable
                 ));

    g_fAutodialEnableAPISetting = fEnable;

    DEBUG_LEAVE(0);
}


DWORD
GetAutodialMode(
    )

{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "GetAutodialMode",
                NULL
                ));

    DWORD dwMode = AUTODIAL_MODE_NO_NETWORK_PRESENT, dwError, dwData;

    // make sure RAS and Wininet flags match up
    INET_ASSERT(RAS_AUTODIAL_OPT_NEVER  == AUTODIAL_MODE_NEVER);
    INET_ASSERT(RAS_AUTODIAL_OPT_ALWAYS == AUTODIAL_MODE_ALWAYS);
    INET_ASSERT(RAS_AUTODIAL_OPT_DEMAND == AUTODIAL_MODE_NO_NETWORK_PRESENT);

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaGetDefaultAutodialConnection)
    {
        dwError = _RnaGetDefaultAutodialConnection(NULL, 0, &dwMode);

        if(dwError)
        {
            DEBUG_ERROR(DIALUP, dwError);
            dwMode = AUTODIAL_MODE_NEVER;
        }

        dwMode &= (RAS_AUTODIAL_OPT_NEVER | RAS_AUTODIAL_OPT_ALWAYS | RAS_AUTODIAL_OPT_DEMAND);

        DEBUG_LEAVE(dwMode);
        return dwMode;
    }

    if(InternetReadRegistryDword(REGSTR_VAL_ENABLEAUTODIAL, &dwData) ||
        0 == dwData)
    {
        dwMode = AUTODIAL_MODE_NEVER;
    }

    if(AUTODIAL_MODE_NO_NETWORK_PRESENT == dwMode)
    {
        if(InternetReadRegistryDword(REGSTR_VAL_NONETAUTODIAL, &dwData) ||
            0 == dwData)
        {
            dwMode = AUTODIAL_MODE_ALWAYS;
        }
    }

    DEBUG_LEAVE(dwMode);
    return dwMode;
}

DWORD
SetAutodialMode(
    IN DWORD dwMode
    )

{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "SetAutodialMode",
                "%#x",
                dwMode
                ));

    DWORD dwEnable = 0, dwNonet = 0, dwError = 0;

    // make sure RAS and Wininet flags match up
    INET_ASSERT(RAS_AUTODIAL_OPT_NEVER  == AUTODIAL_MODE_NEVER);
    INET_ASSERT(RAS_AUTODIAL_OPT_ALWAYS == AUTODIAL_MODE_ALWAYS);
    INET_ASSERT(RAS_AUTODIAL_OPT_DEMAND == AUTODIAL_MODE_NO_NETWORK_PRESENT);

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaSetDefaultAutodialConnection && pfnRnaGetDefaultAutodialConnection)
    {
        CHAR szOldName[RAS_MaxEntryName+1];
        DWORD dwOldMode;

        // Have to set both name and mode at the same time, so read existing values and change
        // what we need.
        dwError = _RnaGetDefaultAutodialConnection(szOldName, ARRAYSIZE(szOldName), &dwOldMode);
        if(0 == dwError)
        {
            dwError = _RnaSetDefaultAutodialConnection(szOldName, dwMode);
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    switch(dwMode)
    {
    case AUTODIAL_MODE_NEVER:
        break;
    case AUTODIAL_MODE_NO_NETWORK_PRESENT:
        dwNonet = 1;
        // fall through to always
    case AUTODIAL_MODE_ALWAYS:
        dwEnable = 1;
        break;
    default:
        dwError = ERROR_INVALID_PARAMETER;
    }

    if(ERROR_SUCCESS == dwError)
    {
        InternetWriteRegistryDword(REGSTR_VAL_ENABLEAUTODIAL, dwEnable);
        InternetWriteRegistryDword(REGSTR_VAL_NONETAUTODIAL, dwNonet);
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


DWORD
GetAutodialConnection(
    CHAR    *pszBuffer,
    DWORD   dwBufferLength
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "GetAutodialConnection",
                "%#x, %#x",
                pszBuffer,
                dwBufferLength
                ));

    DWORD   dwType, dwHasEntry = FALSE, dwMode, dwError = ERROR_INVALID_NAME;

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaGetDefaultAutodialConnection)
    {
        dwError = _RnaGetDefaultAutodialConnection(pszBuffer, dwBufferLength, &dwMode);

        if(0 == dwError)
        {
            DEBUG_PRINT(DIALUP, INFO, ("Entry=%s, Mode=%x", pszBuffer, dwMode));
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    if(GlobalPlatformWhistler && EnsureRasLoaded() && pfnRasGetAutodialAddressA)
    {
        RASAUTODIALENTRYA adEntry;
        DWORD dwBytes, dwEntries;
 
        ZeroMemory(&adEntry, sizeof(adEntry));
        adEntry.dwSize = sizeof(adEntry);
        dwBytes = sizeof(adEntry);
        dwEntries = 1;
 
        dwError = _RasGetAutodialAddressA(
                    NULL,
                    NULL,
                    &adEntry,
                    &dwBytes,
                    &dwEntries);

        if(NO_ERROR == dwError && dwEntries)
        {
            lstrcpyn(pszBuffer, adEntry.szEntry, dwBufferLength);
        }
        else
        {
            *pszBuffer = 0;
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    if(ERROR_SUCCESS == SHGetValueA(HKEY_CURRENT_USER, szRegPathRemoteAccess,
            szRegValInternetEntry, &dwType, pszBuffer, &dwBufferLength) &&
            lstrlen(pszBuffer))
    {
        dwError = 0;    // success
    }

    DEBUG_LEAVE(dwError);
    return dwError;
}


DWORD
SetAutodialConnection(
    CHAR   *pszConnection
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                Dword,
                "SetAutodialConnection",
                "%#x (%q)",
                pszConnection,
                pszConnection
                ));

    DWORD   dwError;

    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRnaSetDefaultAutodialConnection && pfnRnaGetDefaultAutodialConnection)
    {
        CHAR szOldName[RAS_MaxEntryName+1];
        DWORD dwOldMode;

        // Have to set both name and mode at the same time, so read existing values and change
        // what we need.
        dwError = _RnaGetDefaultAutodialConnection(szOldName, ARRAYSIZE(szOldName), &dwOldMode);
        if(0 == dwError)
        {
            dwError = _RnaSetDefaultAutodialConnection(pszConnection, dwOldMode);
        }

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    if(GlobalPlatformWhistler && EnsureRasLoaded() && pfnRasSetAutodialAddressA)
    {
        RASAUTODIALENTRYA adEntry;
 
        ZeroMemory(&adEntry, sizeof(adEntry));
        adEntry.dwSize = sizeof(adEntry);
        lstrcpyn(adEntry.szEntry, pszConnection, sizeof(adEntry.szEntry) / sizeof(TCHAR));
 
        dwError = _RasSetAutodialAddressA(
                    NULL,
                    NULL,
                    &adEntry,
                    sizeof(adEntry),
                    1);

        DEBUG_LEAVE(dwError);
        return dwError;
    }

    SHSetValue(HKEY_CURRENT_USER, szRegPathRemoteAccess, szRegValInternetEntry,
                REG_SZ, pszConnection, lstrlen(pszConnection));

    DEBUG_LEAVE(0);
    return 0;
}


BOOL
IsAutodialEnabled(
    OUT BOOL    *pfForceDial,
    IN AUTODIAL *pConfig
    )

/*++

Routine Description:

    Read flags used to control autodial.  Also honors SetOption setting
    to override and not autodial.

    Note: if autodial isn't enabled, the rest of the structure isn't read.

Arguments:

    pConfig     - AUTODIAL struct to store info.  NULL is valid if info
                  isn't required.

Return Value:

    BOOL
        TRUE    - Autodial is enabled
        FALSE   - Autodial is not enabled

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsAutodialEnabled",
                 "%#x, %#x",
                 pfForceDial,
                 pConfig
                 ));

    HKEY    hKey;
    DWORD   dwRes, dwData = 0, dwSize, dwType;
    BOOL    fConfigured, fEnabled;

    //
    // Init out parameter
    //
    if(pfForceDial)
    {
        *pfForceDial = FALSE;
    }

    if(pConfig)
    {
        memset(pConfig, 0, sizeof(AUTODIAL));
    }

    //
    // Get autodial enabled
    //
    fConfigured = fEnabled = TRUE;

    // check registry setting
    if(InternetReadRegistryDword(REGSTR_VAL_ENABLEAUTODIAL, &dwData) ||
        0 == dwData)
    {
        fEnabled = fConfigured = FALSE;
    }

    if(fEnabled)
    {
        if(InternetReadRegistryDword(REGSTR_VAL_NONETAUTODIAL, &dwData) ||
            0 == dwData)
        {
            // don't use sens -- imitate IE4 and before behavior
            if(pConfig)
            {
                pConfig->fForceDial = TRUE;
            }
            if(pfForceDial)
            {
                *pfForceDial = TRUE;
            }
        }

        // update fEnabled based on api setting
        fEnabled = g_fAutodialEnableAPISetting;
    }


    if(NULL == pConfig)
    {
        DEBUG_LEAVE(fEnabled);
        return fEnabled;
    }

    //
    // save enabled to pconfig struct
    //
    pConfig->fEnabled = fEnabled;

    pConfig->fConfigured = fConfigured;


    //
    // read security check
    //
    dwSize = sizeof(dwData);
    if( GlobalPlatformType == PLATFORM_TYPE_WIN95 &&
        InternetReadRegistryDword(szRegValEnableSecurityCheck, &dwData) == ERROR_SUCCESS &&
        dwData)
    {
        pConfig->fSecurity = TRUE;
    }

    if(FALSE == fEnabled)
    {
        // if autodial isn't enabled, no point in reading the rest of the
        // info because it isn't used
        DEBUG_LEAVE(fEnabled);
        return fEnabled;
    }

    //
    // read connectoid name
    //
    CHAR szConnectoidName[RAS_MaxEntryName + 1];
    if(ERROR_SUCCESS == GetAutodialConnection(szConnectoidName, RAS_MaxEntryName))
    {
        MultiByteToWideChar(CP_ACP, 0, szConnectoidName, -1, pConfig->pszEntryName, RAS_MaxEntryName);
    }
    else
    {
        pConfig->pszEntryName[0] = 0;
    }

    if(lstrlenW(pConfig->pszEntryName))
    {
        pConfig->fHasEntry = TRUE;

        // if possible, verify that autodial entry actually exists
        RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

        if (pRasProp)
        {
            if(pRasProp->GetError() == 0)
            {
                DWORD dwRet = pRasProp->GetW(pConfig->pszEntryName);
                if((ERROR_SUCCESS != dwRet) && (ERROR_INVALID_FUNCTION != dwRet))
                {
                    // ras doesn't know about this - blow it away
                    pConfig->fHasEntry = FALSE;
                    *pConfig->pszEntryName = 0;
                }
            }
            delete pRasProp;
        }
    }

    if(FALSE == pConfig->fHasEntry && (FALSE == DoConnectoidsExist()))
    {
        // We expect an entry at this point.  If we don't and none exist at
        // this point, autodial isn't, in fact, enabled.
        pConfig->fEnabled = FALSE;
        pConfig->fForceDial = FALSE;

        if(pfForceDial)
        {
            *pfForceDial = FALSE;
        }
    }

    //
    // read autoconnect for the specified entry
    //
    if(pConfig->fHasEntry)
    {
        WCHAR   szKey[MAX_PATH];

        GetConnKeyW(pConfig->pszEntryName, szKey, ARRAYSIZE(szKey));
        dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey,
                REGSTR_DIAL_AUTOCONNECTW, &dwType, &dwData, &dwSize) &&
                dwData)
        {
            pConfig->fUnattended = TRUE;
        }
    }

    DEBUG_LEAVE(pConfig->fEnabled);
    return pConfig->fEnabled;
}


UINT_PTR
SendDialmonMessage(
    UINT    uMessage,
    BOOL    fPost
    )

/*++

Routine Description:

    Send a message to dialmon

Arguments:

    uMessage    - message to send
    fPost       - post or send

Return Value:

    Return of send or 0 if post

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "SendDialmonMessage",
                 "%x, %B",
                 uMessage,
                 fPost
                 ));

    UINT_PTR    uRet = 0;

    // Send a message to dialmon's monitor window to start monitoring this
    // connectoid
    if(NULL == g_hwndWebCheck) {
        g_hwndWebCheck = FindWindow(szWebCheckMonitorClass,NULL);
    }
    if(g_hwndWebCheck) {
        if(fPost)
        {
            PostMessage(g_hwndWebCheck, uMessage, 0, 0);
        }
        else
        {
            uRet = SendMessage(g_hwndWebCheck, uMessage, 0, 0);
        }
    }

    DEBUG_LEAVE(uRet);
    return uRet;
}


BOOL
GetRedialParameters(
    IN LPWSTR pszConn,
    OUT LPDWORD pdwDialAttempts,
    OUT LPDWORD pdwDialInterval
    )

/*++

Routine Description:

    Get redial information for a specific connectoid

Arguments:

    pszConn         - connection name
    pdwDialAttempts - location to store dial attempts
    pdwDialInterval - location to store dial interval

Return Value:

    BOOL
        TRUE        - success
        FALSE       - failure

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "GetRedialParameters",
                 "%#x (%Q), %x, %x",
                 pszConn,
                 pszConn,
                 pdwDialAttempts,
                 pdwDialInterval
                 ));

    WCHAR   szKey[MAX_PATH];
    DWORD   dwValue, dwSize;
    HKEY    hkey;

    //
    // validate and clear out variables
    //
    if(NULL == pdwDialAttempts || NULL == pdwDialInterval)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // set to defaults
    //
    *pdwDialAttempts = DEFAULT_DIAL_ATTEMPTS;
    *pdwDialInterval = DEFAULT_DIAL_INTERVAL;

    //
    // read values from registry
    //
    GetConnKeyW(pszConn, szKey, ARRAYSIZE(szKey));
    dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALATTEMPTSW, NULL, &dwValue, &dwSize) && dwValue)
    {
        *pdwDialAttempts = dwValue;
    }

    dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALINTERVALW, NULL, &dwValue, &dwSize) && dwValue)
    {
        *pdwDialInterval = dwValue;
    }

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                        Win9x security check
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

// stolen from ICW's wizglob.h -- BUGBUG - add to our tree
#define INSTANCE_PPPDRIVER       0x0002
typedef DWORD (WINAPI * ICFGISFILESHARINGTURNEDON  )  (DWORD dwfDriverType, LPBOOL lpfSharingOn);


BOOL
IsSharingEnabled(
    VOID
    )

/*++

Routine Description:

    Silently determine whether sharing is turned on on PPP devices on Win9x

Arguments:

    none

Return Value:

    BOOL
        TRUE    - sharing on
        FALSE   - sharing off (or NT)

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsSharingEnabled",
                 NULL
                 ));

    ICFGISFILESHARINGTURNEDON   lpIcfgIsFileSharingTurnedOn=NULL;
    HINSTANCE hICFGInst = NULL;
    BOOL fSharingIsOn = FALSE;

    //
    // Bail out on NT
    //
    if(PLATFORM_TYPE_WINNT == GlobalPlatformType)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    else
    {
        hICFGInst = LoadLibraryA("icfg95.dll");
    }

    //
    // Try and get entry point in icfg95.dll to check
    //
    if(hICFGInst)
    {
        DWORD dwRet;
        lpIcfgIsFileSharingTurnedOn = (ICFGISFILESHARINGTURNEDON)GetProcAddress( hICFGInst, "IcfgIsFileSharingTurnedOn");
        if(lpIcfgIsFileSharingTurnedOn)
            dwRet = lpIcfgIsFileSharingTurnedOn(INSTANCE_PPPDRIVER, &fSharingIsOn);

        FreeLibrary(hICFGInst);
    }

    DEBUG_LEAVE(fSharingIsOn);
    return fSharingIsOn;
}


DWORD
PerformSecurityCheck(
    IN HWND     hwndParent,
    IN DWORD    dwFlags
    )

/*++

Routine Description:

    Prompt user to fix sharing on PPP device on Win9x.  Reboot if necessary.

Arguments:

    hwndParent  - parent window for any UI
    dwFlags     - flags possibly containing INTERNET_AUTODIAL_FAILIFSECURITYCHECK

Return Value:

    BOOL
        TRUE    - failed test, may be rebooting
        FALSE   - passed test

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "PerformSecurityCheck",
                 "%#x, %#x",
                 hwndParent,
                 dwFlags
                 ));

    static BOOL fDoneCheckOnce = FALSE;
    BOOL fNeedRestart = FALSE;
    HINSTANCE hinstInetWiz;
    INETPERFORMSECURITYCHECK lpInetPerformSecurityCheck;
    CHAR szFilename[SMALLBUFLEN+1]="";

    // only do this once per session, never on NT
    if(PLATFORM_TYPE_WINNT == GlobalPlatformType || fDoneCheckOnce)
    {
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    fDoneCheckOnce = TRUE;

    if(dwFlags & (INTERNET_AUTODIAL_FAILIFSECURITYCHECK | INTERNET_DIAL_UNATTENDED | INTERNET_AUTODIAL_FORCE_UNATTENDED))
    {
        if(IsSharingEnabled())
        {
            // silent check failed
            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
    }

    // get filename out of resource
    LoadString(GlobalDllHandle,IDS_INETCFG_FILENAME,szFilename,
        sizeof(szFilename));

    // load the inetcfg dll
    hinstInetWiz = LoadLibrary(szFilename);
    INET_ASSERT(hinstInetWiz);
    if (hinstInetWiz) {

        // get the proc address
        lpInetPerformSecurityCheck = (INETPERFORMSECURITYCHECK)
            GetProcAddress(hinstInetWiz,szInetPerformSecurityCheck);
        INET_ASSERT(lpInetPerformSecurityCheck);
        if (lpInetPerformSecurityCheck)
        {
            // call the function to do system security check
            (lpInetPerformSecurityCheck) (hwndParent, &fNeedRestart);
        }

        FreeLibrary(hinstInetWiz);

        if(fNeedRestart)
        {
            // call RestartDialog in shell32
            HINSTANCE hShell = LoadLibrary("shell32.dll");
            _RESTARTDIALOG pfnRestart = NULL;

            if(hShell)
            {
                pfnRestart = (_RESTARTDIALOG)GetProcAddress(hShell, (LPTSTR)59);
                if(pfnRestart)
                    (*pfnRestart)(NULL, NULL, EWX_REBOOT);
                FreeLibrary(hShell);
            }
        }
    }

    DEBUG_LEAVE(fNeedRestart);
    return fNeedRestart;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                      Custom Dial Handler code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


BOOL
IsCDH(
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh
    )

/*++

Routine Description:

    Determine whether a connection uses a custom dial handler

Arguments:

    pszEntryName    - connection name
    pcdh            - pointer to structure to hold cdh info

Return Value:

    BOOL
        TRUE    - connection uses custom dial handler
        FALSE   - doesn't

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsCDH",
                 "%#x (%Q), %#x",
                 pszEntryName,
                 pszEntryName,
                 pcdh
                 ));

    //
    // clear out cdhinfo
    //
    memset(pcdh, 0, sizeof(CDHINFO));

    if(PLATFORM_TYPE_WIN95 == GlobalPlatformType)
    {
        //
        // Check registry settings on Win9x
        //

        WCHAR szKey[MAX_PATH];
        DWORD dwType;
        DWORD cbDllName = sizeof(pcdh->pszDllName);
        DWORD cbFcnName = sizeof(pcdh->pszFcnName);
        wnsprintfW(szKey, MAX_PATH, L"%ws\\%ws", szRegPathRNAProfileW, pszEntryName);

        if((ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, szRegValAutodialDllNameW, &dwType, (LPBYTE) pcdh->pszDllName, &cbDllName)) &&
           (ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey, szRegValAutodialFcnNameW, &dwType, (LPBYTE) pcdh->pszFcnName, &cbFcnName)))
        {
            // try to read flags - not critical if can't find it
            DWORD cbFlags   = sizeof(DWORD);
            SHGetValueW(HKEY_CURRENT_USER, szKey, szRegValAutodialFlagsW, &dwType, (LPBYTE) &(pcdh->dwHandlerFlags), &cbFlags);
            if(0 == cbFlags)
                pcdh->dwHandlerFlags = 0;

            // if we got dll / fcn, we have a handler
            pcdh->fHasHandler = TRUE;

            // ICW's isign32.dll registers itself as a CDH but does no useful work.  Ignore it.
            // Note this could distinguish isign32.dll a little better -- right now it will
            // incorectly find "aolisign32.dll" if such a thing were to exist.
            if( StrStrIW(pcdh->pszDllName, L"isign32.dll") &&
                StrStrIW(pcdh->pszFcnName, L"AutodialLogon"))
            {
                // nuke it
                memset(pcdh, 0, sizeof(CDHINFO));
            }
        }
    }
    else
    {
        //
        // No such this as a "CDH" on Win2k as defined by this mechanism.
        // On Win2K, there's a new field in the rasentry struct specifically
        // for this.  See the function DialIfWin2KCDH.
        //
        // Always return FALSE for CDH on Win2K.
        //
        if(FALSE == GlobalPlatformVersion5)
        {
            //
            // NT4 - this is broken -- we look in the RASENTRY struct for autodial
            // function and dll but these fields are intended for use by NT's
            // autodial code, NOT IE's.  Prototypes are different and we only
            // get by by luck - if NT finds these entries, it tries to find an
            // A or W version of the exported function.  CM is the only guy that
            // does this and they don't export decorated A or W versions.  Since
            // NT can't find the function, it ignores the entries.
            //
            // This problem disappears on NT5 -- CM has thier own connectoid
            // type. (Custom dial handlers in general won't be supported)
            //
            RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

            if (pRasProp)
            {
                if((0 == pRasProp->GetError()) && (0 == pRasProp->GetW(pszEntryName)))
                {
                    // got entry, if there is custom dial fields, copy them to our
                    // struct
                    if(pRasProp->GetAutodiallDllW() && pRasProp->GetAutodialFuncW())
                    {
                        StrCpyNW(pcdh->pszDllName, pRasProp->GetAutodiallDllW(), sizeof(pcdh->pszDllName));
                        StrCpyNW(pcdh->pszFcnName, pRasProp->GetAutodialFuncW(), sizeof(pcdh->pszFcnName));
                        pcdh->fHasHandler = TRUE;
                    }
                }
                delete pRasProp;
            }
        }
    }

    DEBUG_LEAVE(pcdh->fHasHandler);
    return pcdh->fHasHandler;
}

BOOL
CallCDH(
    IN HWND hwndParent,
    IN LPWSTR pszEntryName,
    IN CDHINFO *pcdh,
    IN DWORD dwOperation,
    OUT LPDWORD lpdwResult
    )

/*++

Routine Description:

    Call a custom dial handler to perform an operation

Arguments:

    hwndParent      - parent window for any ui
    pszEntryName    - connection name
    pcdh            - pointer to structure to hold cdh info
    dwOperation     - a CDH operation to perform, one of the
                        INTERNET_CUSTOMDIAL_* operations.
    lpdwResult      - result of CDH operation

        ERROR_SUCCESS - operation completed
        ERROR_ALREADY_EXISTS - connection already exists (CM only)
        ERROR_USER_DISCONNECTION - user cancelled operation
        ERROR_INVALID_PARAMETER - CDH failed to load or service request

Returns Value:

    BOOL
        TRUE        - CDH handled operation
        FALSE       - didn't

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "CallCDH",
                 "%#x, %#x (%Q), %#x, %#x, %#x",
                 hwndParent,
                 pszEntryName,
                 pszEntryName,
                 pcdh,
                 dwOperation,
                 lpdwResult
                 ));

    BOOL    fRet = FALSE;

    if(pcdh->fHasHandler)
    {
        // FIXME - verify handler supports requested operation by checking
        // it's flags.  Connection Manager has been known to assert if it's
        // called to do something it doesn't understand.

        HINSTANCE hinstDialerDll = LoadLibraryWrapW(pcdh->pszDllName);
        if (hinstDialerDll)
        {
            PFN_DIAL_HANDLER lpInetDialHandler;
            CHAR szFcnName[MAX_PATH + 1];

            WideCharToMultiByte(CP_ACP, 0, pcdh->pszFcnName, -1, szFcnName, MAX_PATH, NULL, NULL);
            lpInetDialHandler = (PFN_DIAL_HANDLER)GetProcAddress(hinstDialerDll, szFcnName);
            if (lpInetDialHandler)
            {
#ifdef _X86_
                // IBM Global Network is busted in that it expects to be called
                // as cdecl when all other CDHs are stdcall.  To get around
                // this bustitude somewhat, restore esp after the call to get
                // our stack frame back to a point where we won't fault.
                DWORD dwSavedEsp;
                _asm { mov [dwSavedEsp], esp }
#endif

                // Thunk entry name to ansi
                CHAR szEntryName[RAS_MaxEntryName + 1];
                WideCharToMultiByte(CP_ACP, 0, pszEntryName, -1, szEntryName, RAS_MaxEntryName, NULL, NULL);
                fRet = (lpInetDialHandler)(hwndParent, szEntryName, dwOperation, lpdwResult);

#ifdef _X86_
                _asm { mov esp, [dwSavedEsp] }
#endif
            }

            FreeLibrary(hinstDialerDll);
        }
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                           Initialization
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

VOID
InitAutodialModule(
    BOOL    fGlobalDataNeeded
    )

/*++

Routine Description:

    Initialize autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "InitAutodialModule",
                 "%B",
                 fGlobalDataNeeded
                 ));

    // check for global data first - will only ever happen once
    if(fGlobalDataNeeded && !GlobalDataInitialized)
    {
        GlobalDataInitialize();
    }

    // only do this once...
    if(g_fAutodialInitialized)
    {
        DEBUG_LEAVE(0);
        return;
    }

    // make sure internet settings key is open
    EnsureInternetSettingsKeyCached();

    // There is really no reason to acquire a crosprocess mutex
    // We are going to creat a perprocess mutex when services are running. SPP
    // wininet folks will explore whether this has to be expanded to include all processes
    // (Shishir Pardikar)
    
    if (FALSE == GlobalIsProcessNtService)
    {
        // create connection mutex
        g_hConnectionMutex = OpenMutex(SYNCHRONIZE, FALSE, CONNECTION_MUTEX);
        if (g_hConnectionMutex == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
        {
            g_hConnectionMutex = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
                                             FALSE,
                                             CONNECTION_MUTEX);
        }

    }
    else
    {
        g_hConnectionMutex = CreateMutex(NULL, FALSE, NULL);
    }
    INET_ASSERT(g_hConnectionMutex != INVALID_HANDLE_VALUE);
    
    

    // create dial mutex to serialize access to RAS (per process)
    g_hRasMutex = CreateMutex(NULL, FALSE, NULL);
    INET_ASSERT(g_hRasMutex != INVALID_HANDLE_VALUE);

    // create proxy registry mutex to serialize access to registry settings across processes
    g_hProxyRegMutex = OpenMutex(SYNCHRONIZE, FALSE, PROXY_REG_MUTEX);
    if (g_hProxyRegMutex == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        g_hProxyRegMutex = CreateMutex(CreateAllAccessSecurityAttributes(NULL, NULL, NULL),
                                       FALSE,
                                       PROXY_REG_MUTEX);
    }

    INET_ASSERT(g_hProxyRegMutex != INVALID_HANDLE_VALUE);




    if(FALSE == IsAutodialEnabled(NULL, NULL)) {
        // if autodial not enabled, then set the fDontProcessHook flag so we
        // exit our hook proc very quickly and don't interfere with Winsock
        fDontProcessHook = TRUE;
    }

    if(GetModuleHandle("rnaapp.exe"))
    {
        // We're in rnaapp!  Bail all winsock callbacks
        g_fRNAAppProcess = TRUE;
    }
    DEBUG_PRINT(DIALUP, INFO, ("g_fRNAAppProcess = %B\n", g_fRNAAppProcess));

    g_fAutodialInitialized = TRUE;

    DEBUG_LEAVE(0);
}


VOID
ExitAutodialModule(
    VOID
    )

/*++

Routine Description:

    Clean up autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ExitAutodialModule",
                 NULL
                 ));

    // don't do anything if not initialized
    if(FALSE == g_fAutodialInitialized)
    {
        DEBUG_LEAVE(0);
        return;
    }

#ifdef CHECK_SENS
    if(g_hSens) {
        FreeLibrary(g_hSens);
        g_hSens = NULL;
        g_pfnIsNetworkAlive = NULL;
    }
#endif

    // close connection mutex
    if(INVALID_HANDLE_VALUE != g_hConnectionMutex)
    {
        CloseHandle(g_hConnectionMutex);
        g_hConnectionMutex = INVALID_HANDLE_VALUE;
    }

    // close RAS mutex
    if(INVALID_HANDLE_VALUE != g_hRasMutex)
    {
        CloseHandle(g_hRasMutex);
        g_hRasMutex = INVALID_HANDLE_VALUE;
    }

    // close proxy registry mutex
    if(INVALID_HANDLE_VALUE != g_hProxyRegMutex)
    {
        CloseHandle(g_hProxyRegMutex);
        g_hProxyRegMutex = INVALID_HANDLE_VALUE;
    }

    // close user's reg key
    CRefdKey* prk = (CRefdKey*)InterlockedExchangePointer((PVOID*)&g_prkBase, NULL);
    CloseBaseProxyKey(prk);

    if (g_hRasLib)
    {
        FreeLibrary(g_hRasLib);
        g_hRasLib = NULL;
    }

    if(g_hIphlpapi)
    {
        FreeLibrary(g_hIphlpapi);
        g_hIphlpapi = NULL;
        g_pfnGetBestRoute = NULL;
    }

    g_fAutodialInitialized = FALSE;

    DEBUG_LEAVE(0);
}


VOID
ResetAutodialModule(
    VOID
    )

/*++

Routine Description:

    Reset certain state when a global reset is called.  Causes settings
    to be reread and some one-time operations to be redone.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ResetAutodialModule",
                 NULL
                 ));

    // global settings have changed - reset hook to look again
    fDontProcessHook = FALSE;

    // refresh proxy info and next connection
    g_fConnChecked = FALSE;

#ifdef CHECK_SENS
    // refresh our sens state
    g_fSensInstalled = TRUE;
#endif

    // beta 1 hack
    g_fCheckedUpgrade = FALSE;

    // check security context again for HKCU settings
    CRefdKey* prk = (CRefdKey*)InterlockedExchangePointer((PVOID*)&g_prkBase, NULL);
    CloseBaseProxyKey(prk);

    DEBUG_LEAVE(0);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                     Connection management code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


#ifdef CHECK_SENS


BOOL
GetSensLanState(
    OUT LPDWORD pdwFlags
    )

/*++

Routine Description:

    Load and query sens to see if any packets have moved on the lan.
    Beware of service not started and/or api dll not present.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - Lan is active
        FALSE   - Lan is not active

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "GetSensLanState",
                 "%#x",
                 pdwFlags
                 ));

    BOOL    fConnected = TRUE;

    // initialize out flags parameter to default - lan connectivity
    *pdwFlags = NETWORK_ALIVE_LAN;

    // If sens isn't around to ask, we have to assume the lan is connected
    
    if(FALSE == g_fSensInstalled)
    {
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    //
    // Try to load SENS and get our entry point
    //
    if(NULL == g_hSens) {

        INT_PTR fSensRunning;

        if(PLATFORM_TYPE_WINNT == GlobalPlatformType)
        {
            // check for running service on NT
            fSensRunning = IsServiceRunning("Sens", SERVICE_ACTIVE);
        }
        else
        {
            // check for dialmon loaded bits on Win9x

            //
            // Webcheck creates this named event to track the lifetime of Sens.
            // It's created with CreateEventA so we need to open with with
            // OpenEventA.
            //
            HANDLE hEvent;

            fSensRunning = FALSE;

            hEvent = OpenEventA(SYNCHRONIZE, FALSE, "MS_WebcheckExternalsTerminateEvent");
            if(hEvent)
            {
                fSensRunning = TRUE;
                CloseHandle(hEvent);
            }
        }

        // On win9x check with dialmon to see if sens is running before
        // calling it.  If we call it and it isn't loaded, it'll load itself
        // and defeat the purpose of not loading it.
        if(fSensRunning)
        {
            g_hSens = LoadLibrary("sensapi.dll");
            if(g_hSens) {
                g_pfnIsNetworkAlive = (ISNETWORKALIVE)GetProcAddress(g_hSens, "IsNetworkAlive");
            }
        }
    }

    //
    // Call sens to get its state
    //
    if(g_pfnIsNetworkAlive) {
        fConnected = g_pfnIsNetworkAlive(pdwFlags);
        g_fSensInstalled = TRUE;
        if(fConnected) {
            if(ERROR_SUCCESS != GetLastError()) {
                // sens service not running - must assume lan is available
                g_fSensInstalled = FALSE;
            }
            if(0 == (*pdwFlags & (NETWORK_ALIVE_LAN | NETWORK_ALIVE_AOL)))
            {
                // no AOL or LAN flag, so return no lan connectivity
                fConnected = FALSE;
            }
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("g_fSensInstalled = %B\n", g_fSensInstalled));

    //
    // If sens isn't alive but we managed to load the dll, unload it
    // now as it's useless.  Otherwise, hang on to the dll.  No need to
    // load and unload it all the time.
    //
    if(FALSE == g_fSensInstalled && g_hSens) {
        FreeLibrary(g_hSens);
        g_hSens = NULL;
        g_pfnIsNetworkAlive = NULL;
    }

    DEBUG_LEAVE(fConnected);
    return fConnected;
}



#endif // CHECK_SENS


BOOL
IsDialUpConnection(
    IN BOOL fForceRefresh,
    OUT LPDWORD     lpdwConnectionNum
    )

/*++

Routine Description:

    Determines whether there's a dial-up connection.  Refreshes information
    periodically.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - A dial-up connection exists
        FALSE   - No dial-up connection

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsDialUpConnection",
                 "%B, %x",
                 fForceRefresh,
                 lpdwConnectionNum
                 ));

    static BOOL     fRasLoaded = FALSE;
    DWORD           dwNewTickCount, dwElapsed, dwBytes, dwRes, dwConNum = 0;
    BOOL            fProcessedRecently = FALSE, fRet;

    //
    // Initialize out parameter
    //
    if(lpdwConnectionNum)
    {
        *lpdwConnectionNum = 0;
    }

    //
    // serialize
    //
    WaitForSingleObject(g_hRasMutex, INFINITE);

    //
    // Check out how recently we polled ras
    //
    dwNewTickCount = GetTickCountWrap();
    dwElapsed = dwNewTickCount - g_dwLastDialupTicks;

    //
    // Only refresh if more than MIN... ticks has passed
    //
    if((dwElapsed >= MIN_RNA_BUSY_CHECK_INTERVAL) || fForceRefresh) {
        g_dwLastDialupTicks = dwNewTickCount;
        if(DoConnectoidsExist())
        {
            if(FALSE == fRasLoaded)
                fRasLoaded = EnsureRasLoaded();

            if(fRasLoaded)
            {
                g_RasCon.Enum();
                if(g_RasCon.GetError() == 0)
                    g_dwConnections = g_RasCon.GetConnectionsCount();
                else
                    g_dwConnections = 0;
            }
        }
        else
        {
            g_dwConnections = 0;
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("Found %d connections\n", g_dwConnections));

    if(g_dwConnections > 1 && lpdwConnectionNum)
    {
        //
        // We have more than one connection and caller wants to know which one
        // is the interesting one.  Try to find a VPN connectoid.
        //
        // Note: RasGetEntryPropertiesA doesn't exist on Win95 Gold.  However,
        // you need RAS 1.2 (which has it) for the VPN device so we're ok
        // using it.  If we can't dynaload it for some inexplicable reason,
        // we'll just end up not finding a VPN entry and setting proxy
        // settings to the first connection.
        //
        // Note we use an array of 2 rasentry structures because NT wants to
        // a phone number list after the actual struct and we need space for it.
        // An extra RASENTRY struct is 1700+ bytes so it should be sufficient.
        //
        RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

        if (pRasProp)
        {
            for(dwConNum = 0; dwConNum < g_dwConnections; dwConNum++)
            {
                if(0 == pRasProp->GetW(g_RasCon.GetEntryW(dwConNum)))
                {
                    if(0 == lstrcmpiA(pRasProp->GetDeviceTypeA(), RASDT_Vpn))
                    {
                        DEBUG_PRINT(DIALUP, INFO, ("Found VPN entry: %ws\n",
                            g_RasCon.GetEntryW(dwConNum)));
                        *lpdwConnectionNum = dwConNum;
                        break;
                    }
                }
            }
            delete pRasProp;
        }
    }

    fRet = (BOOL)(g_dwConnections != 0);

    //
    // verify status of connection we're interested in is RASCS_Connected.
    //
    if(fRet)
    {
        RasGetConnectStatusHelp RasGetConnectStatus(g_RasCon.GetHandle(dwConNum));
        dwRes = RasGetConnectStatus.GetError();
        if(dwRes || (RasGetConnectStatus.ConnState() != RASCS_Connected))
        {
            fRet = FALSE;
        }

        DEBUG_PRINT(DIALUP, INFO, ("Connect Status: dwRet=%x, connstate=%x\n", dwRes, RasGetConnectStatus.ConnState()));
    }

    ReleaseMutex(g_hRasMutex);

    DEBUG_LEAVE(fRet);
    return fRet;
}


BOOL
IsLanConnection(
    OUT LPDWORD pdwFlags
    )

/*++

Routine Description:

    Determines whether there's a lan connection.  Refreshes information
    periodically.

    When Sens is present, AOL functionality is retuned as TRUE with
    *pdwFlags = NETWORK_ALIVE_AOL.

Arguments:

    None

Return Value:

    BOOL
        TRUE    - A lan connection exists
        FALSE   - No lan connection

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "IsLanConnection",
                 "%#x",
                 pdwFlags
                 ));

    static DWORD    dwLastSensTicks = 0;
    static BOOL     fSensState = TRUE;
    static DWORD    dwSensFlags = 0;
    DWORD           dwNewTickCount, dwElapsed;
    BOOL            fRet = TRUE;

    // init out parameter
    INET_ASSERT(pdwFlags);
    *pdwFlags = 0;

#ifdef CHECK_SENS
    //
    // Check connectivity apis to see if lan is really present
    //
    if(fRet)
    {
        dwNewTickCount = GetTickCountWrap();
        dwElapsed = dwNewTickCount - dwLastSensTicks;
        if(dwElapsed >= MIN_SENS_CHECK_INTERVAL)
        {
            fSensState = GetSensLanState(&dwSensFlags);
            dwLastSensTicks = dwNewTickCount;
        }
        fRet = fSensState;
        *pdwFlags = dwSensFlags;
    }
#endif

    DEBUG_LEAVE(fRet);
    return fRet;
}


VOID
CheckForUpgrade(
    VOID
    )

/*++

Routine Description:

    Performs processing that needs to happen when we upgrade to IE5.

    - Migrate proxy and dial settings on upgrade
    - Migrate legacy proxy settings when they change

Arguments:

    None

Return Value:

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CheckForUpgrade",
                 NULL
                 ));

    DWORD   dwMigrateState = 1, dwRet, dwEntries = 0;
    char    szUserName[10];
    DWORD   cbUserNameSize = ARRAYSIZE(szUserName);
    CRefdKey* prkBase = FindBaseProxyKey();

    //
    // Bail out right away if we've already done this 
    // Or if we are running in an NT service such as the usermode portion of webdav redir
    // in order to avoid deadlocks

    // Also check to make sure we're not running as .default or SYSTEM
    
    if(prkBase &&
       (FALSE == g_fCheckedUpgrade) &&
       (FALSE == GlobalIsProcessNtService) &&
       !IsInGUIModeSetup() &&
       !(GlobalPlatformWhistler &&
       GlobalUserName.Get(szUserName,&cbUserNameSize) &&
               (0 == lstrcmpi(szUserName, ".Default") ||
                0 == lstrcmpi(szUserName, "SYSTEM"))))
    {
        LONG lResult;
        DWORD dwType, dwExclude, dwSize = sizeof(DWORD), dwDisp;
        RasEnumHelp *pRasEnum = NULL;
        //
        // Check to see if proxy settings have been migrated
        //
        if(ERROR_SUCCESS != SHGetValue(prkBase->GetKey(),
            REGSTR_PATH_INTERNET_SETTINGS, szMigrateProxy, &dwType, &dwMigrateState, &dwSize))
        {
            dwMigrateState = 0;
        }

        DEBUG_PRINT(DIALUP, INFO, ("dwMigrateState=%d\n", dwMigrateState));

        //
        // set up list of connectoids
        //
        if(DoConnectoidsExist() && EnsureRasLoaded() && FALSE == GlobalDisableNT4RasCheck)
        {
            pRasEnum = new RasEnumHelp;
            if(pRasEnum != NULL)
            {
                dwRet = pRasEnum->GetError();
                dwEntries = pRasEnum->GetEntryCount();
            }
        }

        //
        // Migrate legacy proxy settings to all connections
        //
        if(0 == dwMigrateState)
        {
            INTERNET_PROXY_INFO_EX info;

            // start off with clean proxy struct
            memset(&info, 0, sizeof(info));
            info.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);

            // need to migrate settings
            if(ReadLegacyProxyInfo(szRegPathInternetSettings, &info))
            {
#ifndef UNIX
                // make sure autodiscovery is on
                info.dwFlags |= PROXY_TYPE_AUTO_DETECT;
#endif /* !UNIX */

                // Save proxy settings to for lan
                info.lpszConnectionName = NULL;
                WriteProxySettings(&info, TRUE);

                // Save legacy settings to special location so we can check
                // for change later
                info.lpszConnectionName = LEGACY_SAVE_NAME;
                WriteProxySettings(&info, TRUE);

                //
                // If we're not turning on autodiscovery for dialup connections
                // by default, get rid of it at this point
                //
                if(FALSE == EnableAutodiscoverForDialup())
                {
                    info.dwFlags &= ~PROXY_TYPE_AUTO_DETECT;
                }

                // Save settings for each connectoid
                DWORD i;
                for(i=0; i<dwEntries; i++)
                {
                    info.lpszConnectionName = pRasEnum->GetEntryA(i);
                    WriteProxySettings(&info, TRUE);
                }

                // clean memory possibly allocated by ReadLegacyProxyInfo
                info.lpszConnectionName = NULL; // not allocated, don't free
                CleanProxyStruct(&info);
            }
        }

        //
        // Check to see if other dial-up settings have been migrated
        //

        if(0 == dwMigrateState && dwEntries)
        {
            CHAR    szKey[MAX_PATH];
            DWORD   dwMinutes, dwAttempts, dwInterval, dwWait, i;
            DWORD   dwEnable;

            // read dial attempts and wait
            if(InternetReadRegistryDword(REGSTR_VAL_REDIALATTEMPTS, &dwAttempts))
                dwAttempts = DEFAULT_DIAL_ATTEMPTS;
            if(InternetReadRegistryDword(REGSTR_VAL_REDIALINTERVAL, &dwInterval))
                dwInterval = DEFAULT_DIAL_INTERVAL;

            // Get idle enable
            if(InternetReadRegistryDword(REGSTR_VAL_ENABLEAUTODISCONNECT, &dwEnable) ||
                0 == dwEnable)
            {
                dwEnable = 0;
                dwMinutes = 20;
            }

            // if enabled, get minutes
            if(dwEnable &&
               InternetReadRegistryDword(REGSTR_VAL_DISCONNECTIDLETIME, &dwMinutes))
            {
                dwEnable = 0;
                dwMinutes = 20;
            }

            // enumerate ras entries
            for(i=0; i<dwEntries; i++)
            {
                DWORD dwDisposition;
                HKEY hkey;
                long lRes;

                // migrate settings for this connectoid
                GetConnKeyA(pRasEnum->GetEntryA(i), szKey, ARRAYSIZE(szKey));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_ENABLEAUTODISCONNECT, REG_DWORD, (BYTE *)&dwEnable, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_DISCONNECTIDLETIME, REG_DWORD, (BYTE *)&dwMinutes, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_ENABLEEXITDISCONNECT, REG_DWORD, (BYTE *)&dwEnable, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALATTEMPTS, REG_DWORD, (BYTE *)&dwAttempts, sizeof(DWORD));
                SHSetValueA(HKEY_CURRENT_USER, szKey, REGSTR_VAL_REDIALINTERVAL, REG_DWORD, (BYTE *)&dwInterval, sizeof(DWORD));
            }
        }

        if(pRasEnum)
            delete pRasEnum;

        //
        // mark setings as migrated so we don't do this again next time
        //
        dwDisp = 1;
        SHSetValueA(prkBase->GetKey(), REGSTR_PATH_INTERNET_SETTINGS,
            szMigrateProxy, REG_DWORD, &dwDisp, sizeof(DWORD));

        if(dwMigrateState)
        {
            // We have already migrated settings.  If legacy settings have
            // changed, update current connection.
            INTERNET_PROXY_INFO_EX saved, current, destination;

            memset(&saved, 0, sizeof(saved));
            saved.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);
            saved.lpszConnectionName = LEGACY_SAVE_NAME;

            memset(&current, 0, sizeof(current));
            current.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);

            memset(&destination, 0, sizeof(destination));
            destination.dwStructSize = sizeof(INTERNET_PROXY_INFO_EX);

            if( ReadLegacyProxyInfo(szRegPathInternetSettings, &current) &&
                ERROR_SUCCESS == ReadProxySettings(&saved))
            {
                BOOL fChanged = FALSE;

                //
                // see if they've changed
                //
                if((saved.dwFlags & LEGACY_MIGRATE_FLAGS) != (current.dwFlags & LEGACY_MIGRATE_FLAGS))
                {
                    fChanged = TRUE;
                }
                else
                {
                    // Only check for autoconfig url match if setting is the same and on because
                    // legacy saved for no autoconfig url is to delete the url.
                    if((saved.dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
                       (FALSE == IsConnectionMatch(saved.lpszAutoconfigUrl, current.lpszAutoconfigUrl)))
                    {
                        fChanged = TRUE;
                    }
                }
                if(FALSE == IsConnectionMatch(saved.lpszProxy, current.lpszProxy))
                {
                    fChanged = TRUE;
                }
                if(FALSE == IsConnectionMatch(saved.lpszProxyBypass, current.lpszProxyBypass))
                {
                    fChanged = TRUE;
                }

                // if they have, save to current connection
                if(fChanged)
                {
                    DWORD dwIndex;
                    LPCSTR lpszTemp;

                    // save new legacy settings to check again later
                    current.lpszConnectionName = LEGACY_SAVE_NAME;
                    WriteProxySettings(&current, TRUE);

                    // read existing lan settings
                    destination.lpszConnectionName = NULL;
                    ReadProxySettings(&destination);

                    // fix flags
                    destination.dwFlags = (destination.dwFlags & ~LEGACY_MIGRATE_FLAGS) | (current.dwFlags & LEGACY_MIGRATE_FLAGS);

                    // fix proxy server / override
                    lpszTemp = destination.lpszProxy;
                    destination.lpszProxy = current.lpszProxy;
                    current.lpszProxy = lpszTemp;

                    lpszTemp = destination.lpszProxyBypass;
                    destination.lpszProxyBypass = current.lpszProxyBypass;
                    current.lpszProxyBypass = lpszTemp;

                    // fix autoconfig url
                    lpszTemp = destination.lpszAutoconfigUrl;
                    destination.lpszAutoconfigUrl = current.lpszAutoconfigUrl;
                    current.lpszAutoconfigUrl = lpszTemp;

                    // save it
                    WriteProxySettings(&destination, TRUE);
                }
            }

            saved.lpszConnectionName = NULL;
            current.lpszConnectionName = NULL;
            destination.lpszConnectionName = NULL;
            CleanProxyStruct(&saved);
            CleanProxyStruct(&current);
            CleanProxyStruct(&destination);
        }

        // don't run this code again
        g_fCheckedUpgrade = TRUE;
    }

    CloseBaseProxyKey(prkBase);

    DEBUG_LEAVE(0);
}


DWORD
FixProxySettings(
    IN LPWSTR   pszConnW,
    IN BOOL     fForceUpdate,
    IN DWORD    dwLanFlags
    )

/*++

Routine Description:

    Copy lan or dial-up proxy settings to generic key and tell proxy code
    new proxy information

Arguments:

    pszConn         - connection name to switch to
    fForceUpdate    - set regardless of having set before
    dwLanFlags      - distinguish between LAN and AOL connection

Return Value:

    DWORD
        0           - no proxy for this connection
        1           - proxy exists for this connection

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Int,
                 "FixProxySettings",
                 "%#x (%Q), %B, %#x",
                 pszConnW,
                 pszConnW,
                 fForceUpdate,
                 dwLanFlags
                 ));

    static  TCHAR pszLastConn[RAS_MaxEntryName+1];
    static  DWORD dwEnable = 0;
    CHAR szConn[RAS_MaxEntryName + 1];
    LPSTR pszConn = NULL;

    if(pszConnW != NULL)
    {
        *szConn = '\0';
        pszConn = szConn;
        WideCharToMultiByte(CP_ACP, 0, pszConnW, -1, pszConn, RAS_MaxEntryName, NULL, NULL);
    }

    //
    // Make sure we've listened to any global settings changed that happened
    // in other processes
    //
    if (InternetSettingsChanged()) {
        ChangeGlobalSettings();
    }

    //
    // Ensure upgrade stuff is done
    //
    CheckForUpgrade();

    //
    // Is this connection already fixed?
    //
    if(g_fConnChecked && (FALSE == fForceUpdate)) {
        if((NULL == pszConn && 0 == *pszLastConn) ||
            0 == lstrcmp(pszConn, pszLastConn)) {
            // already fixed this connection

            DEBUG_LEAVE(dwEnable);
            return dwEnable;
        }
    }

    //
    // Get proxy struct for proxy object
    //
    INTERNET_PROXY_INFO_EX info;
    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = pszConn;

    //
    // Read proxy settings for this connection unless it's LAN/AOL
    // in which case we want no proxy
    //
    if(pszConn || 0 == (dwLanFlags & NETWORK_ALIVE_AOL))
    {
        if (ReadProxySettings(&info) != ERROR_SUCCESS)
        {
            DEBUG_LEAVE(dwEnable);
            return dwEnable;
        }
    }

    //
    // Save connection we fixed
    //
    if(NULL == pszConn) {
        // lan
        *pszLastConn = 0;
    } else {
        // connectoid
        lstrcpyn(pszLastConn, pszConn, RAS_MaxEntryName + 1);
    }

    // tell caller if proxy is enabled
    if(info.dwFlags & PROXY_TYPE_PROXY)
    {
        dwEnable = 1;
    }
    else
    {
        dwEnable = 0;
    }

    GlobalProxyInfo.SetProxySettings(&info, FALSE);

    //GlobalProxyInfo.RefreshProxySettings(FALSE);

    //
    // Copy current settings to the legacy reg locations so legacy
    // apps can find them.
    //
    info.lpszConnectionName = LEGACY_SAVE_NAME;
    WriteLegacyProxyInfo(szRegPathInternetSettings, &info, TRUE);
    WriteProxySettings(&info, TRUE);

    // free up memory allocated by ReadProxySettings
    info.lpszConnectionName = NULL; // not allocated, don't free
    CleanProxyStruct(&info);

    //
    // Flag we've checked this at least once so in future we can bail out early
    //
    g_fConnChecked = TRUE;

    DEBUG_LEAVE(dwEnable);
    return dwEnable;
}


BOOL
FixProxySettingsForCurrentConnection(
    IN BOOL fForceUpdate
    )

/*++

Routine Description:

    Figure out the current connection and fix proxy settings for it.
    Basically a cheap, return-no-info version of GetConnectedStateEx used
    by the winsock callback.

Arguments:

    none

Return Value:

    BOOL
        TRUE        - connected
        FALSE       - not connected

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "FixProxySettingsForCurrentConnection",
                 "%B",
                 fForceUpdate
                 ));


    BOOL    fRet, fForceDial;
    DWORD   dwFixEntry;

    //
    // Make sure everything's initialized
    //
    InitAutodialModule(TRUE);

    // serialize connection type stuff
    WaitForSingleObject(g_hConnectionMutex, INFINITE);

    //
    // Check to see if we have a dialup connection
    //
    fRet = IsDialUpConnection(FALSE, &dwFixEntry);
    if(fRet)
    {
        FixProxySettings(g_RasCon.GetEntryW(dwFixEntry), fForceUpdate, 0);
    }

    //
    // If dial always isn't set, check lan setting
    //
    IsAutodialEnabled(&fForceDial, NULL);

    if(FALSE == fRet && FALSE == fForceDial)
    {
        //
        // no ras connections - ensure LAN proxy settings are correct
        //
        DWORD dwFlags;
        fRet = IsLanConnection(&dwFlags);

        //
        // Whether we have a lan connection or not, prop lan proxy settings.
        // This allows unknown connections to use lan settings.
        //
        FixProxySettings(NULL, fForceUpdate, dwFlags);
    }

    ReleaseMutex(g_hConnectionMutex);

    DEBUG_LEAVE(fRet);
    return fRet;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                       Win2K Helper Functions
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
BOOL
DialIfWin2KCDH(
    IN LPWSTR           pszEntry,
    IN HWND             hwndParent,
    IN BOOL             fHideParent,
    OUT DWORD           *lpdwResult,
    OUT DWORD_PTR       *lpdwConnection
    )

/*++

Routine Description:

    Check a connectoid to see if it has a Win2K custom dial handler and if
    so, do the voodoo magic to dial it

Arguments:

    lpParams    - dial params
    hwndParent  - parent window
    fHideParent - if true, hide this window if dialing this connectoid
    lpdwResult  - result of dial (set if return is TRUE)

Return Value:

    BOOL
        TRUE    - Attempted to dial Win2K CDH
        FALSE   - didn't

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "DialIfWin2KCDH",
                 "%x (%Q), %x, %B, %x, %x",
                 pszEntry,
                 pszEntry,
                 hwndParent,
                 fHideParent,
                 lpdwResult,
                 lpdwConnection
                 ));

    DWORD dwRet;
    RasEntryPropHelp *pRasProp = new RasEntryPropHelp;
    BOOL fResult = FALSE;

    if (pRasProp == NULL)
    {
        goto Cleanup;
    }

    if(FALSE == GlobalPlatformVersion5)
    {
        // not on win2k, bag
        goto Cleanup;
    }

    // get props for this connectoid and see if it has a custom dial dll

    if(ERROR_SUCCESS != (dwRet = pRasProp->GetW(pszEntry)))
    {
        // error getting rasentry struct
        goto Cleanup;
    }

    if(NULL == pRasProp->GetCustomDialDllW())
    {
        // no custom dial dll
        goto Cleanup;
    }

    // hide parent window if necessary
    if(fHideParent)
    {
        ShowWindow(hwndParent, SW_HIDE);
    }

    // call rasdialdlg to dial the custom dude
    HMODULE hLib;
    RASDIALDLG rdd;
    _RASDIALDLGW pfnRdd;

    hLib = LoadLibrary("rasdlg.dll");
    if(hLib)
    {
        pfnRdd = (_RASDIALDLGW)GetProcAddress(hLib, "RasDialDlgW");
        if(pfnRdd)
        {
            memset(&rdd, 0, sizeof(rdd));
            rdd.dwSize = sizeof(RASDIALDLG);
            rdd.hwndOwner = hwndParent;
            dwRet = (*pfnRdd)(NULL, pszEntry, NULL, &rdd);
        }
        FreeLibrary(hLib);
    }
    else
    {
        // really bad...
        goto Cleanup;
    }

    // figure out how we did
    if(dwRet)
    {
        DWORD dwEntry;

        // success
        *lpdwResult = ERROR_SUCCESS;

        // find hconn for the thing we just dialed
        if(lpdwConnection)
        {
            if(IsDialUpConnection(TRUE, &dwEntry))
            {
                *lpdwConnection = (DWORD_PTR) g_RasCon.GetHandle(dwEntry);
            }
        }
    }
    else
    {
        // error or cancel
        *lpdwResult = ERROR_USER_DISCONNECTION;

        if(rdd.dwError)
        {
            *lpdwResult = rdd.dwError;
        }
    }

    fResult = TRUE;

Cleanup:
    if (pRasProp)
    {
        delete pRasProp;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                      Winsock callback handler
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

DWORD
CheckForNoNetOverride(
    LPSTR pszHostName
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                Bool,
                "CheckForNoNetOverride",
                "%#x (%q)",
                pszHostName,
                pszHostName
                ));

    DWORD   dwAutodialFlags = 0;
    DWORD   dwFlags;

    if(IsOS(OS_WHISTLERORGREATER) && IsLanConnection(&dwFlags) && ERROR_SUCCESS == LoadWinsock())
    {
        DWORD dwIpAddress;
        DWORD dwError;

        // assume no route and we want to override
        dwAutodialFlags = INTERNET_AUTODIAL_OVERRIDE_NET_PRESENT;

        // First check to see if we have an ip address.
        ADDRINFO Hints;
        LPADDRINFO lpAddrInfo;

        memset(&Hints, 0, sizeof(struct addrinfo));
        Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
        Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
        Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
        Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

        dwError = _I_getaddrinfo(pszHostName, NULL, &Hints, &lpAddrInfo);

        if(ERROR_SUCCESS != dwError)
        {
            // not an ip address, try to resolve name
            Hints.ai_flags = AI_CANONNAME;
            dwError = _I_getaddrinfo(pszHostName, NULL, &Hints, &lpAddrInfo);
        }

        //
        // If we got an IP4 address, check to see if we have a route for it
        //
        if(ERROR_SUCCESS == dwError && (AF_INET == lpAddrInfo->ai_family))
        {
            MIB_IPFORWARDROW bestRoute;
            DWORD dwError = 0;

            if(NULL == g_hIphlpapi)
            {
                g_hIphlpapi = LoadLibrary("iphlpapi.dll");
                if(g_hIphlpapi)
                {
                    g_pfnGetBestRoute = (GETBESTROUTE)GetProcAddress(g_hIphlpapi, "GetBestRoute");
                }
            }

            // snag ip address from lpaddr
            SOCKADDR_IN *paddr = (SOCKADDR_IN *)(lpAddrInfo->ai_addr);
            dwIpAddress = *((unsigned long *)(&paddr->sin_addr));

            if(g_pfnGetBestRoute && (ERROR_SUCCESS == g_pfnGetBestRoute(dwIpAddress, 0, &bestRoute)))
            {
                // got a route, no need to override dial semantics
                DEBUG_PRINT(DIALUP, INFO, ("Found a route to %s, no need to override dial\n", pszHostName));
                dwAutodialFlags = 0;
            }
        }

        UnloadWinsock();
    }

    DEBUG_LEAVE(dwAutodialFlags);
    return dwAutodialFlags;
}


BOOL
InternetAutodialIfNotLocalHost(
    IN LPSTR OPTIONAL pszURL,
    IN LPSTR OPTIONAL pszHostName
    )

/*++

Routine Description:

    Dial so long as we're configured for it and the name passed isn't a
    local host alias.

    Finds:
        'localhost'
        '127.0.0.1' and its aliases
        local machine name from registry or winsock

    If a URL is specified, it's cracked to get the host name.

Arguments:

    pszURL          - url to check for
    pszHostName     - hostname to check for

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                Bool,
                "InternetAutodialIfNotLocalHost",
                "%#x (%q), %#x (%q)",
                pszURL,
                pszURL,
                pszHostName,
                pszHostName
                ));

    CHAR    *pszURLCopy = NULL, *pszLocalHostname;
    BOOL    fLocalHost = FALSE;
    BOOL    fAllocatedBuffer = FALSE;
    BOOL    fRet = TRUE;
    BOOL    fNeedToFix = TRUE;
    DWORD   dwAutodialFlags = 0;

    //
    // Make sure we're all initialized
    //
    InitAutodialModule(TRUE);


    // we bypass this activity in an NT service has disabled autodialing. This special cases
    // this behaviour for the webdav redir. 
    // In future wininet folks will look to see whether this shouldn't be done for all
    // apps disabling autodialing. For now we just avoid the testing hit for the
    // browser folks (Shishir Pardikar)

    if((FALSE == fDontProcessHook) && !(GlobalIsProcessNtService && !IsAutodialEnabled(NULL, NULL)))

    {
        //
        // If we were passed a URL, crack it to get host name
        //
        if(NULL == pszHostName && pszURL)
        {
            DWORD   dwHostNameLength;
            long    error;

            // make a copy of url to crack
            pszURLCopy = new (CHAR[INTERNET_MAX_URL_LENGTH+1]);
            if(NULL == pszURLCopy)
            {
                goto quit;
            }
            fAllocatedBuffer = TRUE;
            lstrcpyn(pszURLCopy, pszURL, INTERNET_MAX_URL_LENGTH);

            // crack it
            error = CrackUrl(pszURLCopy,
                             0,
                             FALSE, // don't escape URL-path
                             NULL,  // don't care about scheme
                             NULL,  // don't care about Scheme Name
                             NULL,
                             &pszHostName,
                             &dwHostNameLength,
                             NULL,  // don't care about port
                             NULL,  // don't care about user name
                             NULL,
                             NULL,  // or password
                             NULL,
                             NULL,  // or object
                             NULL,
                             NULL,  // no extra
                             NULL,
                             NULL
                             );

            if ((error != ERROR_SUCCESS) || (pszHostName == NULL))
            {
                goto quit;
            }

            // null-terminate host name (stomps pszURLCopy buffer)
            pszHostName[dwHostNameLength] = 0;
        }

        //
        // We'd better have a host name by now...
        //
        INET_ASSERT(pszHostName);
        if(NULL == pszHostName)
        {
            goto quit;
        }

        //
        // Check for 'localhost'
        //
        if( 0 == lstrcmpi(pszHostName, "localhost"))
        {
            DEBUG_PRINT(DIALUP, INFO, ("Found localhost\n"));
            fLocalHost = TRUE;
            goto quit;
        }

        //
        // check for 127.0.0.1 or its variants -- use inet_addr if winsock loaded
        //
        if(g_fWinsockLoaded || _I_inet_addr)
        {
            if(ERROR_SUCCESS == LoadWinsock())
            {
                if(0x0100007f == _I_inet_addr(pszHostName))
                {
                    fLocalHost = TRUE;
                }
                UnloadWinsock();
            }
        }
        else
        {
            // winsock not loaded, do the best we can
            if(0 == lstrcmpi(pszHostName, "127.0.0.1"))
            {
                fLocalHost = TRUE;
            }
        }

        if(fLocalHost)
        {
            DEBUG_PRINT(DIALUP, INFO, ("Found 127.0.0.1 alias\n"));
            goto quit;
        }

        //
        // check local machine name
        //
        pszLocalHostname = new (CHAR[INTERNET_MAX_HOST_NAME_LENGTH+1]);
        INET_ASSERT(pszLocalHostname);
        if(pszLocalHostname)
        {
            DWORD dwSize = INTERNET_MAX_HOST_NAME_LENGTH;
            DWORD dwValType;

            // check fully qualified name (only if we know winsock is loaded)
            if(g_fWinsockLoaded || _I_gethostname)
            {
                if(ERROR_SUCCESS == LoadWinsock())
                {
                    if(0 == _I_gethostname(pszLocalHostname, INTERNET_MAX_HOST_NAME_LENGTH))
                    {
                        if(0 == lstrcmpi(pszLocalHostname, pszHostName))
                            fLocalHost = TRUE;
                    }
                    UnloadWinsock();
                }
            }

            if (!fLocalHost &&
                SHGetValue(HKEY_LOCAL_MACHINE,szRegPathTCP,
                szRegValHostName,&dwValType,pszLocalHostname,&dwSize) ==
                ERROR_SUCCESS)
            {
                if(0 == lstrcmpi(pszLocalHostname, pszHostName))
                    fLocalHost = TRUE;
            }

            // also against check computer name in registry, RPC
            // will use this if there's no DNS hostname set
            dwSize = INTERNET_MAX_HOST_NAME_LENGTH;
            if (!fLocalHost &&
                SHGetValue(HKEY_LOCAL_MACHINE, szRegPathComputerName,
                szRegValComputerName,&dwValType,pszLocalHostname,&dwSize) ==
                ERROR_SUCCESS)
            {
                if(0 == lstrcmpi(pszLocalHostname, pszHostName))
                    fLocalHost = TRUE;
            }

            delete pszLocalHostname;
        }

        if(fLocalHost)
        {
            DEBUG_PRINT(DIALUP, INFO, ("Found local machine name\n"));
            goto quit;
        }

        // Check for override of "dial if no net" (ICS host is prime example)
        dwAutodialFlags = CheckForNoNetOverride(pszHostName);

        // not localhost, so need to autodial
        fRet = InternetAutodial(dwAutodialFlags, 0);
        fNeedToFix = FALSE;
    }

quit:
    if(fNeedToFix)
    {
        // Since we're not dialing, ensure correct settings
        FixProxySettingsForCurrentConnection(FALSE);
    }

    if(fAllocatedBuffer)
    {
        delete pszURLCopy;
    }

    DEBUG_LEAVE(fRet);
    return fRet;
}


extern "C"
VOID
InternetAutodialCallback(
    IN DWORD dwOpCode,
    IN LPCVOID lpParam
    )

/*++

Routine Description:

    Possibly establish a connection prior to a winsock operation.  Called
    by winsock before each operation.

Arguments:

    dwOpCode        - Winsock operation about to be done
    lpParam         - Information about operation

Return Value:

    None.

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 None,
                 "InternetAutodialCallback",
                 "%s (%#x), %#x",
                 InternetMapWinsockCallbackType(dwOpCode),
                 dwOpCode,
                 lpParam
                 ));

    //
    // Make sure we're initialized and have done the process check!
    //
    InitAutodialModule(FALSE);

    //
    // If we're in rnaapp.exe process, bail out now!
    //
    if(g_fRNAAppProcess)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Process is rnaapp.exe! Bailing out!\n"));
        DEBUG_LEAVE_API(0);
        return;
    }

    // return as soon as possible if we know there's nothing for us to do here...

    // keep track of the last time we sent winsock activity messages or
    // checked for RNA activity.  We won't do these things more than once
    // every MIN_RNA_BUSY_CHECK_INTERVAL seconds.  Getting the tick count
    // is extremely cheap so this is a worthwhile optimization.


    BOOL fProcessedRecently = FALSE;
    DWORD dwNewTickCount = GetTickCountWrap();
    DWORD dwElapsed = dwNewTickCount - g_dwLastTickCount;
    if (dwElapsed < MIN_RNA_BUSY_CHECK_INTERVAL) {
        fProcessedRecently = TRUE;
    } else {
        g_dwLastTickCount = dwNewTickCount;
    }

    // we're in the winsock callback so it's safe (ie. cheap) to call winsock
    g_fWinsockLoaded = TRUE;

    if (!fProcessedRecently) {
        // if hidden autodisconnect monitor window is around, send it a message to
        // notify it of winsock activity so it knows we're not idle.
        HWND hwndMonitorApp = FindWindow(szAutodialMonitorClass,NULL);
        if (hwndMonitorApp) {
            PostMessage(hwndMonitorApp,WM_WINSOCK_ACTIVITY,0,0);
        }
        if(NULL == g_hwndWebCheck) {
            g_hwndWebCheck = FindWindow(szWebCheckMonitorClass,NULL);
        }
        if(g_hwndWebCheck) {
            PostMessage(g_hwndWebCheck,WM_WINSOCK_ACTIVITY,0,0);
        }
    }

    //
    // Only continue if we have a callback type that we actually do something
    // with
    //
    switch(dwOpCode)
    {
        case WINSOCK_CALLBACK_CONNECT:
        case WINSOCK_CALLBACK_RECVFROM:
            // we do stuff with these so continue...
            break;
        case WINSOCK_CALLBACK_GETHOSTBYNAME:
            // bail out now for gethostbyname(NULL) else do normal
            // gethostbyname processing.
            if(NULL == lpParam)
            {
                DEBUG_PRINT(DIALUP, INFO, ("Not dialing for gethostbyname(NULL)\n"));
                DEBUG_LEAVE_API(0);
                return;
            }
            break;
        default:
            DEBUG_LEAVE_API(0);
            return;
    }

    //
    // if we're EXPLORER or IEXPLORE and in global offline mode, don't dial
    //
    if (GlobalIsProcessExplorer && IsGlobalOffline())
    {
        DEBUG_LEAVE_API(0);
        return;
    }

    //
    // verify proxy settings are correct for current connection and if
    // we're already connected, bail out!
    //
    if(FixProxySettingsForCurrentConnection(FALSE) || fDontProcessHook)
    {
        DEBUG_LEAVE_API(0);
        return;
    }

    //
    // Look at the specific winsock operation we're doing and bail out if
    // we don't want to dial
    //
    switch (dwOpCode)
    {
        case WINSOCK_CALLBACK_CONNECT:
        case WINSOCK_CALLBACK_RECVFROM:
            // these APIs all have a sockaddr struct as the API-specific
            // parameter, look in struct to find address family.  Don't
            // respond if it's non-TCP.
            INET_ASSERT(lpParam);

            if (lpParam) {
                struct sockaddr_in * psa = (struct sockaddr_in *) lpParam;

                if (AF_INET != psa->sin_family) {
                    // not TCP, don't respond
                    DEBUG_PRINT(DIALUP, INFO, ("Not dialing for non TCP connect\n"));
                    DEBUG_LEAVE_API(0);
                    return;
                }

#if defined(UNIX) && defined(ux10)
                DEBUG_PRINT(DIALUP, INFO, ("IP address: %d.%d.%d.%d\n",
                    ((LPBYTE)&(psa->sin_addr))[0],
                    ((LPBYTE)&(psa->sin_addr))[1],
                    ((LPBYTE)&(psa->sin_addr))[2],
                    ((LPBYTE)&(psa->sin_addr))[3]));
#else
                DEBUG_PRINT(DIALUP, INFO, ("IP address: %d.%d.%d.%d\n",
                    psa->sin_addr.S_un.S_un_b.s_b1,
                    psa->sin_addr.S_un.S_un_b.s_b2,
                    psa->sin_addr.S_un.S_un_b.s_b3,
                    psa->sin_addr.S_un.S_un_b.s_b4));
#endif

                if (0x0100007f == psa->sin_addr.s_addr) {
                    // loop back address, don't respond
                    DEBUG_PRINT(DIALUP, INFO, ("Not dialing for 127.0.0.1\n"));
                    DEBUG_LEAVE_API(0);
                    return;
                }

                //
                // Check to make sure this isn't our local address if possible
                //
                // This is a very rare code path and won't be hit in normal
                // browsing.  Also, winsock is already loaded in this process
                // so LoadWinsock is reasonably cheap.
                //
                // This code is here to fix FrontPage and WinCE.  Those are
                // pretty much the only guys that will ever hit it.
                //
                // [darrenmi] don't attempt to do this if we're on the
                // netware client because gethostbyname(NULL) will fault.
                //

                // how many IPs can the local host have?  16 seems like an
                // excessive amount.
                #define MAX_IP_COUNT    16

                if (FALSE == GlobalRunningNovellClient32 &&
                    FALSE == g_fGetHostByNameNULLFails &&
                    ERROR_SUCCESS == LoadWinsock())
                {
                    // get real ip addresses for this host
                    HOSTENT *ph;

                    __try
                    {
                        ph = _I_gethostbyname(NULL);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        g_fGetHostByNameNULLFails = TRUE;
                        ph = NULL;
                    }
                    ENDEXCEPT

                    if(ph)
                    {
                        int iCount = 0;
                        DWORD dwAddress[MAX_IP_COUNT];

                        while((LPDWORD)(ph->h_addr_list[iCount]) && iCount < MAX_IP_COUNT)
                        {
                            dwAddress[iCount] = *((LPDWORD)(ph->h_addr_list[iCount]));

                            //
                            // don't dial if connecting to this host's ip address
                            //
                            // FrontPage does this.
                            //
                            if(dwAddress[iCount] == psa->sin_addr.s_addr) {
                                DEBUG_PRINT(DIALUP, INFO, ("Not dialing for local host IP address\n"));
                                DEBUG_LEAVE_API(0);
                                return;
                            }

                            iCount++;
                        }

                        //
                        // RFC1918 lists 192.168.x.x as 256 class C networks
                        // for use as non-global addresses.  If this address
                        // is one of these guys and we already have an ip on the
                        // same subnet, don't dial
                        //
                        // WinCE device does this.
                        //
                        if((psa->sin_addr.s_addr & 0x0000FFFF) == 0x0000A8C0)
                        {
                            int i;

                            for(i=0; i<iCount; i++)
                            {
                                if((psa->sin_addr.s_addr & 0x00FFFFFF) == (dwAddress[i] & 0x00FFFFFF))
                                {
                                    // connect to a local subnet we're alreay on.  Don't dial.
                                    DEBUG_PRINT(DIALUP, INFO, ("Not dialing for local 192.168.x.x subnet\n"));
                                    DEBUG_LEAVE_API(0);
                                    return;
                                }
                            }
                        }
                    }
                    UnloadWinsock();
                }
            }
            break;

        case WINSOCK_CALLBACK_GETHOSTBYNAME:
            // a lot of apps do a GetHostByName(<local host name>) first
            // thing to get their hands on a hostent struct, this doesn't
            // constitute wanting to hit the net.  If we get a GetHostByName,
            // compare the host name to the local host name in the registry,
            // and if they match then don't respond to this.
            if (lpParam)
            {
                InternetAutodialIfNotLocalHost(NULL, (LPSTR)lpParam);
                DEBUG_LEAVE_API(0);
                return;
            }
    }

    //
    // Dial...
    //
    InternetAutodial(0, 0);

    DEBUG_LEAVE_API(0);
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                            Public APIs
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

VOID
AUTO_PROXY_DLLS::SaveDetectedProxySettings(
    IN LPINTERNET_PROXY_INFO_EX lpProxySettings,
    IN BOOL fNeedHostIPChk
    )
{
    BOOL fRet;
    BOOL fDialupRet;
    BOOL fConnectionMatch = FALSE;

    //
    // Ensure we're initialized
    //

    InitAutodialModule(TRUE);

    WaitForSingleObject(g_hConnectionMutex, INFINITE);

    // remove settting from last time...
    lpProxySettings->dwAutoDiscoveryFlags &= ~(AUTO_PROXY_FLAG_DETECTION_SUSPECT);

    //
    // Check to see if we have a dialup connection
    //

    DWORD dwFixEntry;
    fRet = IsDialUpConnection(TRUE, &dwFixEntry);

    if(fRet)
    {
        // check for match
        if(lpProxySettings->lpszConnectionName &&
            lstrcmpiA(lpProxySettings->lpszConnectionName, g_RasCon.GetEntryA(dwFixEntry)) == 0)
        {
            fConnectionMatch = TRUE;
        }
    }

    fDialupRet = fRet;

    DWORD dwFlags;

    //
    // no ras connections - ensure LAN proxy settings are correct
    //

    fRet = IsLanConnection(&dwFlags);

    if(fRet)
    {
        if (lpProxySettings->lpszConnectionName == NULL)
        {
            fConnectionMatch = TRUE;
        }
        else if (fDialupRet &&
                 (dwFlags & NETWORK_ALIVE_LAN) &&
                 (lpProxySettings->dwDetectedInterfaceIpCount == 1) &&
                 g_fSensInstalled )
        {
            //
            // At this point our detection results are suspect,
            //  because we are claiming to have a DialUp Adapter,
            //  Net Adapter, and only One IP address for the whole
            //  system.
            //

            lpProxySettings->dwAutoDiscoveryFlags |= AUTO_PROXY_FLAG_DETECTION_SUSPECT;
        }
    }

    if ( fConnectionMatch && !(IsGlobalOffline()))
    {
        LockAutoProxy();

        fRet = TRUE;

        //
        // Do Host IP check to confirm we're still ok, ie on the same connection,
        //  that we began on.
        //

        if ( fNeedHostIPChk )
        {
            DWORD error;
            DWORD * pdwDetectedInterfaceIp = NULL;
            DWORD dwDetectedInterfaceIpCount;

            fRet = FALSE;

            error = GetHostAddresses(&pdwDetectedInterfaceIp,
                                     &dwDetectedInterfaceIpCount);  // will this cause problems with auto-dial?

            if ( error == ERROR_SUCCESS &&
                 dwDetectedInterfaceIpCount == lpProxySettings->dwDetectedInterfaceIpCount)
            {
                fRet = TRUE;
                for (DWORD i = 0; i < dwDetectedInterfaceIpCount; i++)
                {
                    if (pdwDetectedInterfaceIp[i] != lpProxySettings->pdwDetectedInterfaceIp[i] ) {
                        fRet = FALSE;
                        break;
                    }
                }
            }

            if ( pdwDetectedInterfaceIp != NULL) {
                FREE_MEMORY(pdwDetectedInterfaceIp);
            }
        }

        //
        // Now save out all our settings, if we can.
        //

        if (fRet)
        {
            SetProxySettings(lpProxySettings,
                             IsModifiedInProcess(),
                             FALSE /*no overwrite*/);

            if ( ! IsModifiedInProcess() )
            {
                // Need to save results to registry, if we succeed,
                //  then make sure to transfer new version stamp
                if ( WriteProxySettings(lpProxySettings, FALSE) == ERROR_SUCCESS )
                {
                    _ProxySettings.dwCurrentSettingsVersion =
                        lpProxySettings->dwCurrentSettingsVersion;
                }
            }

            // stamp version, so we know we've been updated.
            _dwUpdatedProxySettingsVersion = lpProxySettings->dwCurrentSettingsVersion;
        }

        UnlockAutoProxy();
    }

    ReleaseMutex(g_hConnectionMutex);
    return;
}



INTERNETAPI_(BOOL)
InternetGetConnectedStateExW(
    OUT LPDWORD lpdwFlags,
    OUT LPWSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Determine whether any useful connections exist

    On FALSE, will return information about autodial connection if any

Arguments:

    lpdwFlags       - Location to store flags about current connection
        INTERNET_CONNECTION_MODEM   Modem connection
        INTERNET_CONNECTION_LAN     Network connection
        INTERNET_CONNECTION_PROXY   Proxy in use
        INTERNET_RAS_INSTALLED      Ras is installed on machine
    lpszConnectionName
                    - name of current connection
    dwBufLen        - length of name buffer
    dwReserved      - Must be 0

Return Value:

    BOOL
        TRUE        - connection exists
        FALSE       - no connection exists

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetGetConnectedStateExW",
                 "%#x, %#x, %#x, %#x",
                 lpdwFlags,
                 lpszConnectionName,
                 dwBufLen,
                 dwReserved
                 ));

    BOOL        fRet = FALSE, fProcessedRecently = FALSE, fConfigured = FALSE;
    DWORD       dwFlags = 0;
    DWORD       dwRes = 0, dwBytes, dwEnable = 0;
    AUTODIAL    ad;
    BOOL        fAutodialEnabled;
    static BOOL fSensState = TRUE;

    //
    // Ensure we're initialized
    //
    InitAutodialModule(TRUE);

    //
    // Verify parameters
    //
    if((lpdwFlags && ERROR_SUCCESS != ProbeWriteBuffer(lpdwFlags, sizeof(DWORD))) ||
       (lpszConnectionName && ERROR_SUCCESS != ProbeWriteBuffer(lpszConnectionName, dwBufLen)) ||
       dwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    //
    // If on Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetGetConnectedStateExA)
    {
        CHAR szAnsiName[RAS_MaxEntryName + 1];
        DWORD   dwConnFlags = 0;

        //
        // call RAS one first...
        //
        fRet = _RasInternetGetConnectedStateExA(&dwConnFlags, szAnsiName, RAS_MaxEntryName, dwReserved);

        if(lpszConnectionName)
        {
            MultiByteToWideChar(CP_ACP, 0, szAnsiName, -1, lpszConnectionName, dwBufLen);
        }

        //
        // RAS one fills in everything except PROXY and OFFLINE flags.
        //
        if(dwConnFlags & INTERNET_CONNECTION_MODEM)
        {
            dwEnable = FixProxySettings(lpszConnectionName, FALSE, 0);
        }
        else if(dwConnFlags & INTERNET_CONNECTION_LAN)
        {
            dwEnable = FixProxySettings(NULL, FALSE, 0);
        }

        if(dwEnable)
        {
            dwConnFlags |= INTERNET_CONNECTION_PROXY | INTERNET_CONNECTION_CONFIGURED;
        }

        if(IsGlobalOffline())
        {
            dwConnFlags |= INTERNET_CONNECTION_OFFLINE;
        }

        if(fRet)
        {
            // we now have a connection - if we get into a state where we don't,
            // ask user to go offline
            g_fAskOffline = TRUE;
        }

        // set out flags if caller requested it
        if(lpdwFlags)
        {
            *lpdwFlags = dwConnFlags;
        }

        DEBUG_LEAVE_API(fRet);
        return fRet;
    }

    //
    // Initialize out variables
    //
    if(lpdwFlags)
        *lpdwFlags = 0;

    if(lpszConnectionName)
        *lpszConnectionName = 0;


    WaitForSingleObject(g_hConnectionMutex, INFINITE);


    //
    // Check to see if we have a dialup connection
    //
    DWORD dwFixEntry;
    fRet = IsDialUpConnection(FALSE, &dwFixEntry);

    //
    // Tell caller if RAS is installed
    //
    if(g_fRasInstalled)
    {
        dwFlags |= INTERNET_RAS_INSTALLED;
    }

    if(fRet)
    {
        // this connectoid is connected
        dwFlags |= INTERNET_CONNECTION_MODEM;
        fConfigured = TRUE;

        dwEnable = FixProxySettings(g_RasCon.GetEntryW(dwFixEntry), FALSE, 0);

        // copy name for caller
        if(lpszConnectionName && dwBufLen) {
            StrCpyNW(lpszConnectionName, g_RasCon.GetEntryW(dwFixEntry), dwBufLen);
        }
    }

    //
    // autodial configuration is relevant for finding out if lan is present.
    // if autodial.force is set, consider lan NOT present since we're going
    // to dial anyway.
    //
    fAutodialEnabled = IsAutodialEnabled(NULL, &ad);

    if((FALSE == fRet) && (FALSE == ad.fForceDial))
    {
        //
        // no ras connections - ensure LAN proxy settings are correct
        //
        DWORD dwLanFlags;
        fRet = IsLanConnection(&dwLanFlags);

        if(fRet)
        {
            // lan connection is configured and present
            dwFlags |= INTERNET_CONNECTION_LAN;
            dwEnable = FixProxySettings(NULL, FALSE, dwLanFlags);
            // if call wants name, fill in "lan connection"
            if(lpszConnectionName && dwBufLen)
                LoadStringWrapW(GlobalDllHandle, IDS_LAN_CONNECTION, lpszConnectionName, dwBufLen);
        }
    }


    //
    // turn on proxy flag if necessary
    //
    if(dwEnable)
    {
        dwFlags |= INTERNET_CONNECTION_PROXY;

        // we have some kind of configured connection
        fConfigured = TRUE;
    }


    //
    // If no connection found, tell caller about autodial entry
    //
    if(FALSE == fConfigured ||
       0 == (dwFlags & (INTERNET_CONNECTION_LAN | INTERNET_CONNECTION_MODEM)))
    {
        if(ad.fConfigured)
        {
            // we have an autodial connection
            fConfigured = TRUE;

            if(0 == (dwFlags & (INTERNET_CONNECTION_LAN | INTERNET_CONNECTION_MODEM)))
            {
                // autodial is enabled

                // If the caller cares about entry name, find them one
                if(ad.fHasEntry)
                {
                    // use specified one
                    dwFlags |= INTERNET_CONNECTION_MODEM;
                    if(lpszConnectionName && dwBufLen)
                    {
                        StrCpyNW(lpszConnectionName, ad.pszEntryName, dwBufLen);
                    }
                }
                else
                {
                    // None set as default, pick one and set it
                    RasEnumHelp * pre = new RasEnumHelp;

                    if(pre)
                    {
                        if (pre->GetEntryCount())
                        {
                            LPWSTR pwzName = pre->GetEntryW(0);

                            // set this entry to the default
                            SHSetValueW(HKEY_CURRENT_USER, szRegPathRemoteAccessW, szRegValInternetEntryW,
                                    REG_SZ, (BYTE *)pwzName, lstrlenW(pwzName));

                            // return to caller
                            dwFlags |= INTERNET_CONNECTION_MODEM;
                            if(lpszConnectionName && dwBufLen)
                            {
                                StrCpyNW(lpszConnectionName, pwzName, dwBufLen);
                            }
                        }
                        delete pre;
                    }
                }
            }
        }
    }


    //
    // Tell caller if we have a connection configured
    //
    if(fConfigured)
    {
        dwFlags |= INTERNET_CONNECTION_CONFIGURED;
    }


    //
    // Tell caller if we're offline
    //
    if(IsGlobalOffline())
    {
        dwFlags |= INTERNET_CONNECTION_OFFLINE;
    }

    if(lpdwFlags)
        *lpdwFlags = dwFlags;

#if defined(SITARA)

    //
    // IF we're configured to use a modem,
    //  then go ahead an turn on Sitara
    //

    if (fRet && (dwFlags & INTERNET_CONNECTION_MODEM))
    {
        GlobalHasSitaraModemConn = TRUE;
    }
    else
    {
        GlobalHasSitaraModemConn = FALSE;
    }

#endif // SITARA

    if(fRet)
        // we now have a connection - if we get into a state where we don't,
        // ask user to go offline
        g_fAskOffline = TRUE;

    ReleaseMutex(g_hConnectionMutex);

    DEBUG_LEAVE_API(fRet);
    SetLastError(ERROR_SUCCESS);
    return fRet;
}


INTERNETAPI_(BOOL)
InternetGetConnectedStateExA(
    OUT LPDWORD lpdwFlags,
    OUT LPSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Ansi version of InternetGetConnectedStateExW

Arguments:

    Same as InternetGetConnectedStateExW

Return Value:

    Same as InternetGetConnectedStateExW

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetGetConnectedStateExA",
                 "%#x, %#x, %#x, %#x",
                 lpdwFlags,
                 lpszConnectionName,
                 dwBufLen,
                 dwReserved
                 ));

    WCHAR   szWideName[RAS_MaxEntryName + 1];
    BOOL    fRet;

    //
    // call wide version
    //
    *szWideName = 0;
    fRet = InternetGetConnectedStateExW(lpdwFlags, szWideName, RAS_MaxEntryName, dwReserved);

    //
    // convert wide name to ansi
    //
    if(lpszConnectionName)
    {
        if(ERROR_SUCCESS == ProbeWriteBuffer(lpszConnectionName, dwBufLen))
        {
            int i;
            i = WideCharToMultiByte(CP_ACP, 0, szWideName, -1, lpszConnectionName, dwBufLen, NULL, NULL);
            if(0 == i) {
                // truncated - null terminate
                lpszConnectionName[dwBufLen - 1] = 0;
            }
        }
        else
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);
            fRet = FALSE;
        }
    }

    DEBUG_LEAVE_API(fRet);
    return fRet;
}



INTERNETAPI_(BOOL)
InternetGetConnectedState(
    OUT LPDWORD lpdwFlags,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Get simple information about connected state

Arguments:

    lpdwFlags       - Location to store connection flags

                        xxx

    dwReserved      - must be 0

Return Value:

    BOOL
        Connected   - TRUE

        Not         - FALSE

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetGetConnectedState",
                 "%#x, %#x",
                 lpdwFlags,
                 dwReserved
                 ));

    BOOL fRet = InternetGetConnectedStateExW(lpdwFlags, NULL, 0, dwReserved);

    DEBUG_LEAVE_API(fRet);
    return fRet;
}


BOOL
HandleFlagsForRas(
    IN HWND     hwndParent,
    IN BOOL     fAutodialing,
    IN DWORD    dwFlags,
    OUT DWORD   *pdwRasFlags
    )

/*++

Routine Description:

    Convert InternetDial flags to RasInternetDial flags.  Also directly handle
    any flags that Ras doesn't know about.

    Only ever called on Millennium

Arguments:

    hwndParent      Parent window for any UI
    fAutodialing    We're called from InternetAutodial vs. InternetDial
    dwFlags         InternetDial flags
    dwRasFlags      RasInternetDial flags

Return values:

    TRUE            Success

    FALSE           Abort operation

--*/
  
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "HandleFlagsForRas",
                 "%#x, %B, %#x, %#x",
                 hwndParent,
                 fAutodialing,
                 dwFlags,
                 pdwRasFlags
                 ));

    DWORD   dwResult = ERROR_SUCCESS;

    *pdwRasFlags = 0;

    //
    // Convert flags for directly supported options
    //
    if((dwFlags & INTERNET_DIAL_SHOW_OFFLINE) ||
       (GlobalIsProcessExplorer))                       *pdwRasFlags |= RAS_INTERNET_AUTODIAL_ALLOW_OFFLINE;
    if((dwFlags & INTERNET_DIAL_UNATTENDED) ||
       (dwFlags & INTERNET_AUTODIAL_FORCE_UNATTENDED))  *pdwRasFlags |= RAS_INTERNET_AUTODIAL_UNATTENDED;

//  if(dwFlags & INTERNET_DIAL_FORCE_PROMPT)    not supported

    //
    // Handle offline mode
    //
    if(dwFlags & INTERNET_AUTODIAL_FORCE_ONLINE)
    {
        SetOffline(FALSE);
    }

    //
    // Handle security check -- only if not connected and autodial and check is enabled.
    //
    AUTODIAL    ad;
    DWORD       dwState;

    if(!IsDialUpConnection(FALSE, NULL))
    {
        //
        // Perform check if:
        //
        // - Autodial is enabled OR we're not autodialing
        // - and Security check is enabled
        //
        IsAutodialEnabled(NULL, &ad);

        if((ad.fEnabled || !fAutodialing) && ad.fSecurity)
        {
            if(PerformSecurityCheck(hwndParent, dwFlags))
            {
                // non-silent check failed
                dwResult = ERROR_INTERNET_FAILED_DUETOSECURITYCHECK;
            }
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("Ras Flags=0x%x\n", *pdwRasFlags));

    DEBUG_LEAVE(dwResult);
    return dwResult;
}

VOID
HandleUserCancel(
    IN DWORD dwResult,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Check to see if user cancelled dial and fix appropriate states

Arguments:

    dwResult        - Result of dialing operation -- only care about 
                      USER_DISCONNECTION
    dwFlags         - Dialing flags, only care about SHOW_OFFLINE



Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "HandleUserCancel",
                 "%#x, %#x",
                 dwResult,
                 dwFlags
                 ));

    if(ERROR_USER_DISCONNECTION == dwResult)
    {
        if(GlobalIsProcessExplorer || (dwFlags & INTERNET_DIAL_SHOW_OFFLINE))
        {
            // offline semantics - set offline mode
            SetOffline(TRUE);
        }
        else
        {
            // Normal cancel.  Prevent more dialing attempts.
            fDontProcessHook = TRUE;
        }
    }

    DEBUG_LEAVE(0);
}



DWORD
InternetDialW(
    IN HWND hwndParent,
    IN LPWSTR pszEntryName,
    IN DWORD dwFlags,
    OUT DWORD_PTR *lpdwConnection,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Connect to a specified connectoid

Arguments:

    hwndParent      - parent window for dialing ui

    pszEntryName    - string => connectoid to connect to
                    - empty string ("") => let user choose
                    - NULL => connect to autodial connectoid

    dwFlags         - flags controlling operation:

                        xxx

    lpdwConnection  - location to store connection handle

    dwReserved      - must be 0

Return Value:

    DWORD
        Success - 0

        Failure - Ras or windows error code

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Dword,
                 "InternetDialW",
                 "%#x, %#x (%Q), %#x, %#x, %#x",
                 hwndParent,
                 pszEntryName,
                 pszEntryName,
                 dwFlags,
                 lpdwConnection,
                 dwReserved
                 ));

    DIALSTATE   data;
    BOOL        fConn = FALSE;
    DWORD       dwRet = ERROR_SUCCESS, dwTemp;
    WCHAR       szKey[MAX_PATH];
    AUTODIAL    ad;

    //
    // Ensure we're initialized
    //
    InitAutodialModule(TRUE);

    //
    // ensure reserved field is 0
    //
    if(dwReserved)
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // ensure we have a lpdwConnection pointer and initialize it
    //
    if(NULL == lpdwConnection ||
       ERROR_SUCCESS != ProbeWriteBuffer(lpdwConnection, sizeof(DWORD)))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto quit;
    }
    *lpdwConnection = 0;

    //
    // ensure we have a valid pszEntryName (NULL is valid - see below)
    //
    if(pszEntryName && ERROR_SUCCESS != ProbeStringW(pszEntryName, &dwTemp))
    {
        dwRet = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // On Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetDialA)
    {
        DWORD dwRasFlags;

        dwRet = HandleFlagsForRas(hwndParent, FALSE, dwFlags, &dwRasFlags);
        if(dwRet)
        {
            // error, need to bail out
            DEBUG_LEAVE_API(dwRet);
            return dwRet;
        }

        CHAR szAnsiName[RAS_MaxEntryName+1];
        CHAR *pszNameToUse = NULL;

        if(pszEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, pszEntryName, -1, szAnsiName, RAS_MaxEntryName, NULL, NULL);
            pszNameToUse = szAnsiName;
        }

        dwRet = _RasInternetDialA(hwndParent, pszNameToUse, dwRasFlags, lpdwConnection, dwReserved);

        //
        // Switch to offline mode if necessary
        //
        HandleUserCancel(dwRet, dwFlags);

        //
        // If connected, send message to dialmon
        //
        CDHINFO cdh;
        DWORD   dwEntry = 0;
  
        if(IsDialUpConnection(TRUE, &dwEntry) && !IsCDH(g_RasCon.GetEntryW(dwEntry), &cdh))
        {
            SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);
        }

        //
        // fix proxy information for new connection
        //
        FixProxySettingsForCurrentConnection(FALSE);

        DEBUG_LEAVE_API(dwRet);
        return dwRet;
    }

    //
    // Check config state
    //
    IsAutodialEnabled(NULL, &ad);

    if(ad.fSecurity)
    {
        if(PerformSecurityCheck(hwndParent, dwFlags))
        {
            DEBUG_LEAVE_API(ERROR_INTERNET_FAILED_DUETOSECURITYCHECK);
            return ERROR_INTERNET_FAILED_DUETOSECURITYCHECK;
        }
    }

    //
    // Save connectoid name
    //
    memset(&data, 0, sizeof(DIALSTATE));
    data.params.dwSize = sizeof(RASDIALPARAMSW);
    if(pszEntryName && *pszEntryName)
    {
        // use passed connection name as one to dial
        StrCpyNW(data.params.szEntryName, pszEntryName, RAS_MaxEntryName + 1);
    }
    else
    {
        // NULL name passed, use autodial entry if any.  If not, use first
        // one in list (data.params.szEntryName == "")

        if(ad.fEnabled && ad.fHasEntry)
        {
            StrCpyNW(data.params.szEntryName, ad.pszEntryName, RAS_MaxEntryName + 1);
        }
    }

    //
    // Check to see if already have a ras connection
    //
    fConn = IsDialUpConnection(FALSE, NULL);

    //
    // Check to see if there's a custom dial handler
    //
    if(FALSE == fConn)
    {
        CDHINFO cdh;

        memset(&cdh, 0, sizeof(CDHINFO));
        if(IsCDH(data.params.szEntryName, &cdh))
        {
            DWORD dwTmpRetVal;

            if(CallCDH(hwndParent, data.params.szEntryName, &cdh, INTERNET_CUSTOMDIAL_CONNECT, &dwTmpRetVal))
            {
                dwRet = dwTmpRetVal;
                if(ERROR_SUCCESS == dwRet || ERROR_ALREADY_EXISTS == dwRet)
                {
                    // successfully connected
                    dwRet = ERROR_SUCCESS;

                    if(lpdwConnection)
                        *lpdwConnection = (DWORD)CDH_HCONN;

                    // reset last ras poll time to force a check next time
                    g_dwLastDialupTicks = 0;

                    // fix proxy information for new connection
                    WaitForSingleObject(g_hConnectionMutex, INFINITE);
                    FixProxySettings(data.params.szEntryName, FALSE, 0);
                    ReleaseMutex(g_hConnectionMutex);
                }
                else
                {
                    // check to see if user cancelled and go to offline if necessary
                    HandleUserCancel(dwRet, dwFlags);
                }
                dwRet = ERROR_SUCCESS;
                goto quit;
            }

            // else CDH didn't actually do anything - fall through
        }
    }

    if(GlobalPlatformVersion5 && *data.params.szEntryName)
    {
        // check to see if it's a win2k CDH
        if(DialIfWin2KCDH(data.params.szEntryName, hwndParent, FALSE, &dwRet, lpdwConnection))
        {
            // check for cancel and offline mode
            HandleUserCancel(dwRet, dwFlags);

            goto quit;
        }
    }


    //
    // If we still don't have a connection, show our UI to make one
    //
    if(FALSE == fConn)
    {
        DWORD   dwType, dwTemp, dwSize;
        BOOL    fDialedCDH = FALSE;

        //
        // serialize access to our UI
        //

        // If we already are displaying the UI, bring it to the foreground

        // get mutex and check connection again - may have to wait for it and
        // connection status could change
        INET_ASSERT(g_hAutodialMutex);
        WaitForSingleObject(g_hAutodialMutex, INFINITE);

        if(IsDialUpConnection(FALSE, NULL))
        {
            // got a connection in the mean time - bail out
            ReleaseMutex(g_hAutodialMutex);
            DEBUG_LEAVE_API(ERROR_SUCCESS);
            return ERROR_SUCCESS;
        }

        if(IsGlobalOffline())
        {
            // we went offline, then bail out without UI
            ReleaseMutex(g_hAutodialMutex);
            DEBUG_LEAVE_API(ERROR_SUCCESS);
            return ERROR_SUCCESS;
        }


        //
        // Make sure ras is happy
        //
        if(FALSE == EnsureRasLoaded())
        {
            ReleaseMutex(g_hAutodialMutex);
            DEBUG_LEAVE_API(ERROR_NO_CONNECTION);
            return ERROR_NO_CONNECTION;
        }

        //
        // Fire up commctrl
        //
        InitCommCtrl();
        
        if(!g_hDialEvent)
        {
            g_hDialEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        }

        if(!g_hDialEvent)
        {
            return E_FAIL;
        }
        //
        // Dial it
        //
        CDialUI *pdui = new CDialUI(hwndParent);

        if(pdui)
        {
            // make sure we have a reference
            pdui->AddRef();
            dwRet = pdui->StartDial(&data, dwFlags);
            fDialedCDH = pdui->DialedCDH();
            pdui->Release();
        }

        //
        // Shut down commtrl
        //
        ExitCommCtrl();

        //
        // Switch to offline mode if necessary
        //
        HandleUserCancel(data.dwResult, dwFlags);

        //
        // reset last ras poll time to force a check next time and release
        // mutex
        //
        g_dwLastDialupTicks = 0;
        ReleaseMutex(g_hAutodialMutex);

        if(!fDialedCDH)
        {
            //
            // Save connect automatically if it wasn't overridden
            //
            if(0 == (dwFlags & INTERNET_DIAL_FORCE_PROMPT))
            {
                GetConnKeyW(data.params.szEntryName, szKey, ARRAYSIZE(szKey));
                dwTemp = (data.dwFlags & CI_AUTO_CONNECT) ? 1 : 0;
                SHSetValueW(HKEY_CURRENT_USER, szKey, REGSTR_DIAL_AUTOCONNECTW,
                    REG_DWORD, &dwTemp, sizeof(DWORD));
            }
            
            //
            // check to see if we're really connected or not
            //
            if(data.dwResult || NULL == data.hConn)
            {
                if(data.hConn)
                    _RasHangUp(data.hConn);
                dwRet = data.dwResult;
                goto quit;
            }
            
            RasGetConnectStatusHelp RasGetConnectStatus(data.hConn);
            dwRet = RasGetConnectStatus.GetError();
            if(dwRet)
            {
                _RasHangUp(data.hConn);
                goto quit;
            }
            
            if(RasGetConnectStatus.ConnState() != RASCS_Connected)
            {
                _RasHangUp(data.hConn);
                dwRet = ERROR_NO_CONNECTION;
                goto quit;
            }
        }
    }

    //
    // fix proxy information for new connection
    //
    WaitForSingleObject(g_hConnectionMutex, INFINITE);
    FixProxySettings(data.params.szEntryName, FALSE, 0);
    ReleaseMutex(g_hConnectionMutex);

    //
    // reset last ras poll time to force a check next time
    //
    g_dwLastDialupTicks = 0;

    //
    // start disconnect monitoring
    //
    SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);


    //
    // return handle to caller if required
    //
    if(lpdwConnection)
        *lpdwConnection = (DWORD_PTR) data.hConn;

quit:
    SetEvent(g_hDialEvent);
    DEBUG_LEAVE_API(dwRet);
    return dwRet;
}


DWORD
InternetDialA(
    IN HWND hwndParent,
    IN LPSTR pszEntryName,
    IN DWORD dwFlags,
    OUT DWORD_PTR *lpdwConnection,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Wide version of InternetDialA

Arguments:

    Same as InternetDialA

Return Value:

    Same as InternetDialA

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "InternetDialA",
                "%#x, %#x (%q), %#x, %#x, %#x",
                hwndParent,
                pszEntryName,
                pszEntryName,
                dwFlags,
                lpdwConnection,
                dwReserved
                ));

    DWORD dwErr = ERROR_SUCCESS;
    WCHAR szWideEntryName[RAS_MaxEntryName + 1];
    WCHAR *pwzNameToUse = NULL;

    if (pszEntryName)
    {
        if (IsBadStringPtr(pszEntryName, RAS_MaxEntryName + 1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        else
        {
            int i;
            i = MultiByteToWideChar(CP_ACP, 0, pszEntryName, -1, szWideEntryName, RAS_MaxEntryName);
            if(0 == i) 
            {
                // truncated - null terminate
                szWideEntryName[RAS_MaxEntryName] = 0;
            }
            pwzNameToUse = szWideEntryName;
        }
    }
    dwErr = InternetDialW(hwndParent, pwzNameToUse, dwFlags, lpdwConnection, dwReserved);

cleanup:
    DEBUG_LEAVE_API(dwErr);
    return dwErr;
}


DWORD
InternetHangUp(
    IN DWORD_PTR dwConnection,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Hangs up a connection established by InternetDial

Arguments:

    dwConnection    - connection obtained from InternetDial

    dwReserved      - must be 0

Return Value:

    DWORD
        Success - 0

        Failure - Ras or windows error code

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Dword,
                "InternetHangUp",
                "%#x, %#x",
                dwConnection,
                dwReserved
                ));

    DWORD dwRet;

    //
    // If on Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetHangUpA)
    {
        dwRet = _RasInternetHangUpA(dwConnection, dwReserved);

        DEBUG_LEAVE_API(dwRet);
        return dwRet;
    }

    // ensure reserved is 0
    if(dwReserved)
    {
        DEBUG_LEAVE_API(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Ensure we're initialized
    //
    if(FALSE == g_fAutodialInitialized)
    {
        InitAutodialModule(FALSE);
    }

    //
    // Best we can do for CDH's is post message to the disconnect monitor.
    // Hopefully it'll do the right thing and disconnect.  Works for MSN
    // at least.
    //
    if(CDH_HCONN == dwConnection)
    {
        //
        // Try to find a CM connection to hang up
        //
        if(IsDialUpConnection(FALSE, NULL))
        {
            CDHINFO cdh;
            DWORD i, dwError;

            for(i=0; i < g_dwConnections; i++)
            {
                if(IsCDH(g_RasCon.GetEntryW(i), &cdh))
                {
                    if(StrStrIW(cdh.pszDllName, szCMDllNameW))
                    {
                        DEBUG_PRINT(DIALUP, INFO, ("Found CM connection to hang up\n"));
                        dwError = _RasHangUp(g_RasCon.GetHandle(i));
                        DEBUG_LEAVE_API(dwError);
                        return dwError;
                    }
                }
            }
        }

        HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
        if (hwndMonitorWnd) {
            PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
        }

        DEBUG_LEAVE_API(0);
        return 0;
    }

    //
    // Load ras
    //
    if(FALSE == EnsureRasLoaded())
    {
        DEBUG_LEAVE_API(ERROR_UNKNOWN);
        return ERROR_UNKNOWN;
    }

    //
    // hang up the connection
    //
    dwRet = _RasHangUp((HRASCONN)dwConnection);

    DEBUG_LEAVE_API(dwRet);
    return dwRet;
}


BOOLAPI InternetSetDialStateA(
    IN LPCSTR lpszEntryName,
    IN DWORD dwState,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Sets current state for a custom dial handler.

    This was broken in IE4 and didn't actually do anything.  Rather than
    leave it in this state, the notion of custom dial state has been
    removed. [darrenmi]

Arguments:

    lpszEntryName   - connectiod to set state for

    dwState         - new connection state

    dwReserved      - must be 0

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more information

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetSetDialStateA",
                "%#x (%q), %#x, %#x",
                lpszEntryName,
                lpszEntryName,
                dwState,
                dwReserved
                ));

// NOTE: When this starts using lpszEntryName, remember to define USES_STRING to activate
// unicode conversions for InternetSetDialStateW.

    if(dwReserved)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);

        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    // [darrenmi] I do not expect any client to ever call this api - I don't
    // think any were ever written.  Only possible exception may be CM.
    // If it does call it, I want to know.
#ifdef DEBUG
    OutputDebugString("Wininet.DLL: Unexpected use of dead api, contact darrenmi [x34231]\n");
    OutputDebugString("Wininet.DLL: It is safe to continue past this DebugBreak()\n");
    DebugBreak();
#endif

    DEBUG_LEAVE_API(TRUE);
    return TRUE;
}


BOOLAPI InternetSetDialStateW(
    IN LPCWSTR lpszEntryName,
    IN DWORD dwState,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Wide version of InternetSetDialStateA

Arguments:

    Same as InternetSetDialStateA

Return Value:

    Same as InternetSetDialStateA

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetSetDialStateW",
                "%#x (%Q), %#x, %#x",
                lpszEntryName,
                lpszEntryName,
                dwState,
                dwReserved
                ));

    BOOL fRet;

    //
    // Convert and call multibyte version
    //
#ifdef INTERNETSETDIALSTATE_USES_CONNECTOID
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpConnectoid;

    if (lpszEntryName)
    {
        ALLOC_MB(lpszEntryName, 0, mpConnectoid);
        if (!mpConnectoid.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszEntryName, mpConnectoid);
    }
    fRet = InternetSetDialStateA(mpConnectoid.psStr, dwState, dwReserved);

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(DIALUP, dwErr);
    }
#else
    fRet = InternetSetDialStateA(NULL, dwState, dwReserved);
#endif

    DEBUG_LEAVE_API(fRet);
    return fRet;
}


BOOLAPI InternetGoOnlineW(
    IN LPWSTR lpszURL,
    IN HWND hwndParent,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Show UI to ask user whether they wish to go back online.  This is
    triggered by clicking a link that isn't available offline.

Arguments:

    lpszURL         - url that triggered switch (currently not used)

    hwndParent      - parent window for dialog

    dwFlags         - operation control flags (currently not used)
                        INTERENT_GOONLINE_REFRESH
                            This was caused by a refresh rather than a click
                            on an unavailable link

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more information

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetGoOnlineW",
                "%#x (%Q), %#x, %#x",
                lpszURL,
                lpszURL,
                hwndParent,
                dwFlags
                ));

    INT_PTR fRet = TRUE;

    //
    // validate flags
    //
    if(dwFlags & ~INTERENT_GOONLINE_REFRESH)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);

        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    //
    // if already online, we're done
    //
    if(IsGlobalOffline())
    {
        ULONG_PTR uCookie = 0;
        SHActivateContext(&uCookie);
        //
        // Show ui to ask user to go online
        //
        fRet = DialogBoxParamWrapW(GlobalDllHandle, MAKEINTRESOURCEW(IDD_GOONLINE),
            hwndParent, OnlineDlgProc, 0);

        if (uCookie)
        {
            SHDeactivateContext(uCookie);
        }
    }

    if(fRet)
    {
        //
        // Make sure we're connected.
        //
        SetOffline(FALSE);

        MEMORYPACKET mpUrl;
        if (lpszURL)
        {
            ALLOC_MB(lpszURL, 0, mpUrl);
            if (mpUrl.psStr)
            {
                UNICODE_TO_ANSI(lpszURL, mpUrl);
                fRet = InternetAutodialIfNotLocalHost(mpUrl.psStr, NULL);
            }
            else
            {
                fRet = FALSE;
            }
        }
    }

    DEBUG_LEAVE_API(fRet != 0);
    return (fRet != 0);
}


BOOLAPI InternetGoOnlineA(
    IN LPSTR lpszURL,
    IN HWND hwndParent,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Wide version of InternetGoOnlineA

Arguments:

    Same as InternetGoOnlineA

Return Value:

    Same as InternetGoOnlineA

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                Bool,
                "InternetGoOnlineA",
                "%#x (%q), %#x, %#x",
                lpszURL,
                lpszURL,
                hwndParent,
                dwFlags
                ));

    BOOL fRet = FALSE;

    //
    // Convert and call multibyte version
    //
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    LPWSTR lpszWideURL = NULL;

    if (lpszURL)
    {
        int i;
        DWORD dwLen = lstrlenA(lpszURL);
        if((lpszWideURL = (LPWSTR)LocalAlloc(LPTR, (dwLen+1) * sizeof(WCHAR))) != NULL)
        {
            i = MultiByteToWideChar(CP_ACP, 0, lpszURL, -1, lpszWideURL, dwLen);
            if(0 == i)
                lpszWideURL[dwLen] = 0; // truncated - null terminate
        }
    }

    fRet = InternetGoOnlineW(lpszWideURL, hwndParent, dwFlags);

    if(lpszWideURL)
    {
        LocalFree(lpszWideURL);
    }

    DEBUG_LEAVE_API(fRet);
    return fRet;
}


BOOL
InternetAutodial(
    IN DWORD dwFlags,
    IN HWND hwndParent
    )

/*++

Routine Description:

    Dials the internet connectoid

Arguments:

    dwFlags         - flags to control operation

                        xxx

    hwndParent      - parent window for any ui that's displayed

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more info

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetAutodial",
                 "%#x, %#x",
                 dwFlags,
                 hwndParent
                 ));

    AUTODIAL    config;
    DWORD       dwErrorCode = ERROR_INTERNET_INTERNAL_ERROR;
    DWORD       dwRet = ERROR_SUCCESS, dwLanFlags;
    HWND        hwnd = GetDesktopWindow();


    //
    // On Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetAutodialA)
    {
        DWORD   dwRasFlags;

        dwRet = HandleFlagsForRas(hwndParent, TRUE, dwFlags, &dwRasFlags);
        if(dwRet)
        {
            // error, need to bail out
            DEBUG_LEAVE_API(dwRet);
            return dwRet;
        }

        dwRet = _RasInternetAutodialA(dwRasFlags, hwndParent);

        //
        // Switch to offline mode if necessary
        //
        HandleUserCancel(dwRet, dwFlags);

        //
        // If connected, send message to dialmon
        //
        CDHINFO cdh;
        DWORD   dwEntry = 0;
  
        if(IsDialUpConnection(TRUE, &dwEntry) && !IsCDH(g_RasCon.GetEntryW(dwEntry), &cdh))
        {
            SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);
        }

        //
        // fix proxy information for new connection
        //
        FixProxySettingsForCurrentConnection(FALSE);

        //
        // Prop return code
        //
        if(dwRet)
        {
            DEBUG_ERROR(DIALUP, dwRet);
            SetLastError(dwRet);
        }

        DEBUG_LEAVE_API(0 == dwRet);
        return (0 == dwRet);
    }

    // dwFlags - only valid flag is INTERNET_AUTODIAL_FORCE_UNATTENDED
    // Keep ISVs honest about this
    if(dwFlags & ~(INTERNET_AUTODIAL_FLAGS_MASK))
    {
        dwErrorCode = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if(FALSE == g_fAutodialInitialized)
    {
        InitAutodialModule(TRUE);
    }

    // if no parent window was passed, use desktop window
    if(NULL == hwndParent)
    {
        hwndParent = GetDesktopWindow();
    }

    //
    // need connection mutex for FixProxySettings and IsLanConnection
    //
    WaitForSingleObject(g_hConnectionMutex, INFINITE);

    //
    // check to see if we're already connected
    //
    if(IsDialUpConnection(FALSE, &dwRet))
    {
        // make sure proxy settings are correct
        FixProxySettings(g_RasCon.GetEntryW(dwRet), FALSE, 0);
        ReleaseMutex(g_hConnectionMutex);

        // If we're connected by modem, ensure online if necessary
        if(dwFlags & INTERNET_AUTODIAL_FORCE_ONLINE)
        {
            SetOffline(FALSE);
        }

        dwErrorCode = ERROR_SUCCESS;
        goto quit;
    }

    // Check config and make sure we have connectoids if we're supposed to
    // dial one
    if(IsAutodialEnabled(NULL, &config))
    {
        if(FALSE == EnsureRasLoaded())
        {
            config.fEnabled = config.fForceDial = FALSE;
        }
        else
        {
            RasEnumHelp *pRasEnum = new RasEnumHelp;

            if (pRasEnum)
            {
                if (pRasEnum->GetEntryCount() == 0)
                {
                    config.fEnabled = config.fForceDial = FALSE;
                }
                delete pRasEnum;
            }
        }
    }

    if(IsLanConnection(&dwLanFlags) && (FALSE == config.fForceDial))
    {
        if(!config.fEnabled || !(dwFlags & INTERNET_AUTODIAL_OVERRIDE_NET_PRESENT))
        {
            // make sure proxy settings are correct
            FixProxySettings(NULL, FALSE, dwLanFlags);
            ReleaseMutex(g_hConnectionMutex);

            // autodial not necessary
            dwErrorCode = ERROR_SUCCESS;
            goto quit;
        }
    }

    //
    // check if offline and can't go online...
    //
    if( GlobalIsProcessExplorer && IsGlobalOffline() &&
        0 == (dwFlags & INTERNET_AUTODIAL_FORCE_ONLINE)) {

        ReleaseMutex(g_hConnectionMutex);
        dwErrorCode = ERROR_INTERNET_OFFLINE;
        goto quit;
    }

    // make sure we're online
    SetOffline(FALSE);

    // make sure we're supposed to dial
    if(FALSE == config.fEnabled) {
        fDontProcessHook = TRUE;
        dwErrorCode = ERROR_SUCCESS;

        DEBUG_PRINT(DIALUP, INFO, ("Unable to find a connection\n"));

        // no connections and can't dial.  Prompt to go offline.
        if(g_fAskOffline)
        {
            // IE5 Beta 1 Hack - Throw up this dialog for explorer or IE
            // Only for now. However, we should introduce an API that
            // allows any app to say that it wants to participate in
            // IE's Offline Mode stuff and all such apps would then
            // get this dialog

            if(GlobalIsProcessExplorer)
            {
                ULONG_PTR uCookie = 0;
                SHActivateContext(&uCookie);
                // Throw up this dialog for explorer.exe or iexplore.exe only
                if(DialogBoxParamWrapW(GlobalDllHandle, MAKEINTRESOURCEW(IDD_GOOFFLINE),
                    hwndParent, GoOfflinePromptDlgProc,(LPARAM) 0))
                {
                    SetOffline(TRUE);
                }
                else
                {
                    g_fAskOffline = FALSE;
                }
                if (uCookie)
                {
                    SHDeactivateContext(uCookie);
                }
            }
        }

        //
        // If we try to hit the net at this point, we want to use the lan
        // settings whatever they are.
        //
        // This is the only place settings get propagated when no connection
        // can be found.
        //
        FixProxySettings(NULL, FALSE, 0);
        ReleaseMutex(g_hConnectionMutex);

        goto quit;
    }

    // if no entry, fill in a bogus one - dialing UI will pick the first
    // one
    if(FALSE == config.fHasEntry) {
        config.pszEntryName[0] = 0;
        config.fHasEntry = TRUE;
    }

    ReleaseMutex(g_hConnectionMutex);

    // Load Ras
    if(FALSE == EnsureRasLoaded()) {
        // Load of ras failed - probably not installed
        fDontProcessHook = TRUE;
        dwErrorCode = ERROR_SERVICE_DOES_NOT_EXIST;
        goto quit;
    }

    //
    // Fix dial flags
    //
    if((dwFlags & INTERNET_AUTODIAL_FORCE_UNATTENDED) && (config.fUnattended))
        dwFlags |= INTERNET_DIAL_UNATTENDED;

    //
    // Dial it
    //
    DWORD_PTR dwHandle;
    dwErrorCode = InternetDialW(hwndParent, config.pszEntryName, dwFlags, &dwHandle, 0);

quit:
    if(dwErrorCode != ERROR_SUCCESS)
    {
        SetLastError(dwErrorCode);
        DEBUG_ERROR(DIALUP, dwErrorCode);
    }
    DEBUG_LEAVE_API(dwErrorCode == ERROR_SUCCESS);

    return((dwErrorCode == ERROR_SUCCESS));
}


BOOLAPI InternetAutodialHangup(
    IN DWORD dwReserved
    )

/*++

Routine Description:

    Finds and hangs up the autodial connection

    If the autodial connection is a CDH, call the CDH to hang it up.  This
    may or may not work depending on whether the CDH supports hanging up.

Arguments:

    dwReserved      - must be 0

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE, GetLastError for more information

--*/

{
    AUTODIAL    config;
    CDHINFO     cdh;

    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "InternetAutodialHangup",
                 "%#x",
                 dwReserved
                 ));

    DWORD       dwErr = ERROR_SUCCESS;
    int         j = 0;

    // ensure reserved is 0
    if(dwReserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DEBUG_ERROR(DIALUP, ERROR_INVALID_PARAMETER);
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    //
    // On Millennium, forward calls to RAS
    //
    if(GlobalPlatformMillennium && EnsureRasLoaded() && pfnRasInternetAutodialHangUpA)
    {
        dwErr = _RasInternetAutodialHangUpA(dwReserved);

        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    if(FALSE == g_fAutodialInitialized)
    {
        InitAutodialModule(FALSE);
    }

    // read connectoid - if none or autodial not enabled, bail
    if(FALSE == IsAutodialEnabled(NULL, &config) || FALSE == config.fHasEntry)
        goto quit;

    if(IsCDH(config.pszEntryName, &cdh))
    {
        //
        // If this CDH is CM, bail out here so the RasHangup below happens
        //
        if(NULL == StrStrIW(cdh.pszDllName, szCMDllNameW))
        {
            // ask it to hang up - may or may not do it depending on what it
            // supports
            //
            // This isn't going to work.  CM doesn't like getting commands it
            // doesn't understand.  For now, CDHs don't hang up.  Tough.
            //
            // CallCDH(NULL, config.pszEntryName, &cdh, INTERNET_CUSTOMDIAL_DISCONNECT);
            //
            // Actually, post message to CDH's disconnect monitor.  Works for
            // MSN at least.
            HWND hwndMonitorWnd = FindWindow(TEXT("MS_AutodialMonitor"),NULL);
            if (hwndMonitorWnd) {
                PostMessage(hwndMonitorWnd,WM_IEXPLORER_EXITING,0,0);
            }

            goto quit;
        }
    }

    //
    // See if a ras connection matches the autodial connectoid
    //
    if(IsDialUpConnection(FALSE, NULL))
    {
        //
        // See if any current connections match autodial connection
        //
        DWORD i;

        for(i = 0; i < g_dwConnections; i++)
        {
            if(0 == StrCmpIW(g_RasCon.GetEntryW(i), config.pszEntryName))
            {
                _RasHangUp(g_RasCon.GetHandle(i));
                break;
            }
        }
    }

quit:
    DEBUG_LEAVE_API(TRUE);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\debug\convsym\convsym.cxx ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <imagehlp.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

typedef BOOL (* SYMINITIALIZE)(HANDLE, LPSTR, BOOL);
typedef BOOL (* SYMLOADMODULE)(HANDLE, HANDLE, PSTR, PSTR, DWORD, DWORD);
typedef BOOL (* SYMGETSYMFROMADDR)(HANDLE, DWORD, PDWORD, PIMAGEHLP_SYMBOL);
typedef BOOL (* SYMCLEANUP)(HANDLE);

void _CRTAPI1 main(int, char**);
void usage(void);
VOID InitSymLib(VOID);
VOID TermSymLib(VOID);
LPSTR GetDebugSymbol(DWORD Address, LPDWORD Offset);

void _CRTAPI1 main(int argc, char** argv) {

    char * fni = NULL;
    char * fno = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (fno) {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        } else if (fni) {
            fno = *argv;
        } else {
            fni = *argv;
        }
    }

    if (!fni || !fno) {
        usage();
    }

    FILE * fpi = fopen(fni, "rt");

    if (!fpi) {
        printf("error: cannot open file \"%s\" for read\n", fni);
        exit(1);
    }

    FILE * fpo = fopen(fno, "wt");

    if (!fpo) {
        printf("error: cannot open file \"%s\" for write\n", fno);
        exit(1);
    }

    InitSymLib();

    while (!feof(fpi)) {

        char buf[1024];

        if (!fgets(buf, sizeof(buf), fpi)) {
            break;
        }

        char * p = strstr(buf, "+0x");

        if (p) {

            DWORD val = (DWORD)strtoul(p, NULL, 0);
            DWORD offset;
            char * str = GetDebugSymbol(val, &offset);

            if (str) {
                sprintf(p, "%s+%#x\n", str, offset);
            }
        }
        fwrite(buf, strlen(buf), 1, fpo);
    }
    fclose(fpi);
    fclose(fpo);
    TermSymLib();
}

void usage() {
    printf("usage: convsym <input_file> <output_file>\n"
           );
    exit(1);
}

HMODULE hSymLib = NULL;
SYMINITIALIZE pSymInitialize = NULL;
SYMLOADMODULE pSymLoadModule = NULL;
SYMGETSYMFROMADDR pSymGetSymFromAddr = NULL;
SYMCLEANUP pSymCleanup = NULL;

VOID InitSymLib(VOID) {
    if (hSymLib == NULL) {
        hSymLib = LoadLibrary("IMAGEHLP.DLL");
        if (hSymLib != NULL) {
            pSymInitialize = (SYMINITIALIZE)GetProcAddress(hSymLib,
                                                           "SymInitialize"
                                                           );
            pSymLoadModule = (SYMLOADMODULE)GetProcAddress(hSymLib,
                                                           "SymLoadModule"
                                                           );
            pSymGetSymFromAddr = (SYMGETSYMFROMADDR)GetProcAddress(hSymLib,
                                                                   "SymGetSymFromAddr"
                                                                   );
            pSymCleanup = (SYMCLEANUP)GetProcAddress(hSymLib,
                                                     "SymCleanup"
                                                     );
            if (!pSymInitialize
            || !pSymLoadModule
            || !pSymGetSymFromAddr
            || !pSymCleanup) {
                FreeLibrary(hSymLib);
                hSymLib = NULL;
                pSymInitialize = NULL;
                pSymLoadModule = NULL;
                pSymGetSymFromAddr = NULL;
                pSymCleanup = NULL;
                return;
            }
        }
        pSymInitialize(GetCurrentProcess(), NULL, FALSE);
        //SymInitialize(GetCurrentProcess(), NULL, TRUE);
        pSymLoadModule(GetCurrentProcess(), NULL, "WININET.DLL", "WININET", 0, 0);
    }
}

VOID TermSymLib(VOID) {
    if (pSymCleanup) {
        pSymCleanup(GetCurrentProcess());
        FreeLibrary(hSymLib);
    }
}

LPSTR GetDebugSymbol(DWORD Address, LPDWORD Offset) {
    *Offset = Address;
    if (!pSymGetSymFromAddr) {
        return "";
    }

    static char symBuf[512];

    //((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
    ((PIMAGEHLP_SYMBOL)symBuf)->SizeOfStruct = sizeof(symBuf);
    ((PIMAGEHLP_SYMBOL)symBuf)->MaxNameLength = sizeof(symBuf) - sizeof(IMAGEHLP_SYMBOL);
    if (!pSymGetSymFromAddr(GetCurrentProcess(),
                            Address,
                            Offset,
                            (PIMAGEHLP_SYMBOL)symBuf)) {
        ((PIMAGEHLP_SYMBOL)symBuf)->Name[0] = '\0';
    }
    return ((PIMAGEHLP_SYMBOL)symBuf)->Name;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\certcach.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certcach.cxx

Abstract:

    Contains class implementation for certificate cache object.
    This object will hold various Certificate entries.

    Contents:
        SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::AddRef
        SECURITY_CACHE_LIST_ENTRY::Release
        SECURITY_CACHE_LIST_ENTRY::Clear
        SECURITY_CACHE_LIST::Find
        SECURITY_CACHE_LIST::Add
        SECURITY_CACHE_LIST::ClearList
        SECURITY_CACHE_LIST::ClearClientAuthCertChains

    TODO:  Add Cert validation.  What if Cert is given but different?

Author:

    Arthur L Bierer (arthurbi) 20-Apr-1996

Revision History:

    20-Apr-1996 arthurbi
        Created

--*/
#include <wininetp.h>

//
// private manifests
//

#define MAX_CERT_CACHE_CERTS    16

//
// private types
//

//
// SECURITY_CACHE_LIST_ENTRY member functions
//


SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY(
    IN LPSTR lpszHostName
    )

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY constructor. Create object; don't add it to list

Arguments:

    lpszHostName    - name of host for which this cache entry created

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY",
                 "%q",
                 lpszHostName
                 ));

#if INET_DEBUG
    _List.Flink = _List.Blink = NULL;
#endif
    _cRef = 1;
    _fInCache = FALSE;
    _ServerName = lpszHostName;
    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _dwSecurityFlags = 0;
    _pCertContextArray = NULL;
    _fForceNewSession = FALSE;
    _fValidateAll = FALSE;

#if INET_DEBUG
    m_Signature = 0x454c4353;   // 'SCLE'
#endif

    DEBUG_LEAVE(0);
}


SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY()

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "~SECURITY_CACHE_LIST_ENTRY",
                 "{%#x [%q]}",
                 this,
                 _ServerName.StringAddress()
                 ));

    INET_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    Clear();

    DEBUG_LEAVE(0);
}


LONG
SECURITY_CACHE_LIST_ENTRY::AddRef(
    VOID
    )

/*++

Routine Description:

    Increment reference count of SECURITY_CACHE_LIST_ENTRY

Arguments:

    None.

Return Value:

    LONG    - reference count after increment

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::AddRef",
                 "{%#x [%q, %d]}",
                 this,
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    InterlockedIncrement(&_cRef);

    DEBUG_LEAVE(_cRef);

    return _cRef;
}


LONG
SECURITY_CACHE_LIST_ENTRY::Release(
    VOID
    )

/*++

Routine Description:

    Decrement reference count and destroy object if (<=) zero

Arguments:

    None.

Return Value:

    LONG    - reference count after decrement

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::Release",
                 "{%q [%d]}",
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    LONG cRet;

    if (0 >= (cRet = InterlockedDecrement(&_cRef))) {
        delete this;
    }

    DEBUG_LEAVE(cRet);

    return cRet;
}


VOID
SECURITY_CACHE_LIST_ENTRY::Clear()

/*++

Routine Description:

    Clear out SECURITY_CACHE_LIST_ENTRY

Arguments:

    Clear   -

Return Value:

    None.

--*/

{
    if (_CertInfo.pCertificate != NULL) {
        __try {
            CertFreeCertificateContext(_CertInfo.pCertificate);
        } __except(EXCEPTION_EXECUTE_HANDLER) {
        }
        ENDEXCEPT
        _CertInfo.pCertificate = NULL;
    }

    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _CertInfo.dwSize = sizeof(_CertInfo);

    _dwSecurityFlags = 0;
    _ServerName = NULL;
    _pCertContextArray = NULL;
    if( _pCertContextArray )
    {
        delete _pCertContextArray;
        _pCertContextArray = NULL;
    }
}

//
// SECURITY_CACHE_LIST member functions
//


VOID
SECURITY_CACHE_LIST::ClearList(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::ClearList",
                 NULL
                 ));

    LockSerializedList(&_List);

    while (!IsSerializedListEmpty(&_List)) {

        SECURITY_CACHE_LIST_ENTRY * CacheEntry;

        //
        // remove the PROXY_SERVER_LIST_ENTRY at the head of the serialized
        // list
        //

        LPVOID entry = SlDequeueHead(&_List);

        //
        // entry should not be NULL - IsSerializedListEmpty() told us we
        // could expect something
        //

        INET_ASSERT(entry != NULL);

        //
        // get the address of the object (should be the same as entry) and
        // delete it
        //

        CacheEntry = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("releasing %q (%d)\n",
                    CacheEntry->_ServerName.StringAddress(),
                    CacheEntry->_cRef
                    ));

        CacheEntry->Release();
    }

    UnlockSerializedList(&_List);

    DEBUG_LEAVE(0);
}


DWORD
SECURITY_CACHE_LIST::Add(
    IN SECURITY_CACHE_LIST_ENTRY * entry
    )

/*++

Routine Description:

    Adds a CertInfo Structure to the list front of the list.

Arguments:

    lpszHost    - Hostname to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "SECURITY_CACHE_LIST::Add",
                 "%#x [%q, %d]",
                 entry,
                 entry ? entry->_ServerName.StringAddress() : "",
                 entry ? entry->_cRef : 0
                 ));

    DWORD error = ERROR_SUCCESS;

    INET_ASSERT(entry != NULL);

    if (entry != NULL) {
        LockSerializedList(&_List);

        //
        // If we've grown too much, nuke the oldest one.
        //

        if (ElementsOnSerializedList(&_List) >= MAX_CERT_CACHE_CERTS) {

            SECURITY_CACHE_LIST_ENTRY *pOld;
            LPVOID old_entry = SlDequeueTail(&_List);

            INET_ASSERT(old_entry != NULL);

            pOld = CONTAINING_RECORD(old_entry, SECURITY_CACHE_LIST_ENTRY, _List);

            //
            // entry should not be NULL - IsSerializedListEmpty() told us we
            // could expect something
            //

            pOld->_fInCache = FALSE;

            //
            // Clean Our old object, and reinstatiate with a new name.
            //

            pOld->Release();
        }
        InsertAtHeadOfSerializedList(&_List, &entry->_List);
        entry->AddRef();
        entry->_fInCache = TRUE;
        UnlockSerializedList(&_List);
    }

    DEBUG_LEAVE(error);

    return error;
}


SECURITY_CACHE_LIST_ENTRY *
SECURITY_CACHE_LIST::Find(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and returns
    the found entry, or NULL if not found.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    CERT_CACHE_LIST_ENTRY *
        Success - Pointer to found entry.

        Failure - NULL, not found.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Find",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;

    //
    // BUGBUG need to validate against Server Certifcate on every
    //  connection, this Find only validates by Hostname.
    //  What about DNS spoofing?  Won't we be hosed?
    //

    //
    // TODO if found, need to push to front of list.
    //

    LockSerializedList(&_List);
    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        //
        // check to see if they match.
        //

        if (info->_ServerName.Stricmp(lpszHost) == 0) {
            info->AddRef();
            break; // match.
        }
        info = NULL;
    }
    UnlockSerializedList(&_List);

    DEBUG_LEAVE(info);

    return info;
}


VOID
SECURITY_CACHE_LIST::Remove(
    IN LPSTR lpszHost
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and removes
    the entry.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    None

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Remove",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;


    LockSerializedList(&_List);
    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        //
        // check to see if they match.
        //

        if (info->_ServerName.Stricmp(lpszHost) == 0) {
            RemoveFromSerializedList(&_List, entry);
            break; // match.
        }
        info = NULL;
    }
    UnlockSerializedList(&_List);

    DEBUG_LEAVE(0);

}


VOID
SECURITY_CACHE_LIST::ClearClientAuthCertChains(
    VOID
    )
/*++

Routine Description:

    This function walks the cache and releases any client
    auth chains associated with each entry.  This method
    is called in response to the "Clear SSL State" button
    being pressed in inetcpl.  Starting with Whistler,
    client certificates are cached for the logon session,
    rather than the process.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DEBUG_ENTER((DBG_HTTP,
                 None,
                 "SECURITY_CACHE_LIST::ClearClientAuthCertChains",
                 NULL
                 ));

    SECURITY_CACHE_LIST_ENTRY * pInfo = NULL;

    LockSerializedList(&_List);
    for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
        entry != (PLIST_ENTRY)SlSelf(&_List);
        entry = entry->Flink)
    {
        pInfo = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        // This will delete and NULL the array
        pInfo->SetCertContextArray(NULL);

        // Ensure new session is negotiated for next SSL connection to server
        pInfo->SetForceNewSession(TRUE);
    }
    UnlockSerializedList(&_List);

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\cookexp.cxx ===
#include <wininetp.h>


#define SZ_COOKIE_EXPORT_HEADER "#  Internet Explorer cookie file, exported for Netscape browsers."
#define IE_LOCAL_PREFIX             "~~local~~"
#define IE_COOKIE_PREFIX            "Cookie:"


void FileTimeToDosTime( FILETIME ft, DWORD* pTime_t);


struct CACHE_ENTRY_INFO_BUFFER : public INTERNET_CACHE_ENTRY_INFO
{
    BYTE _ab[MAX_CACHE_ENTRY_INFO_SIZE];
};


//****************************************************
//
//  FileOutputStream - utility
//

class FileOutputStream
{
public:
    FileOutputStream()
    : m_hFile(INVALID_HANDLE_VALUE), m_fError(FALSE), m_dwLastError(0)
    {
    }

    ~FileOutputStream()
    {
        if( m_hFile != INVALID_HANDLE_VALUE)
            CloseHandle( m_hFile);
    }

    BOOL Load( LPCTSTR szFilename, BOOL fAppend)
    {
        m_hFile = CreateFile( szFilename, GENERIC_WRITE | GENERIC_READ, 0, NULL, 
                              fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL, NULL);

        if( m_hFile == INVALID_HANDLE_VALUE)
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }

        if( fAppend
            && SetFilePointer( m_hFile, 0, NULL, FILE_END) == 0xFFFFFFFF)
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }

        return TRUE;
    }

    BOOL DumpStr( LPCSTR szString, DWORD cbSize)
    {
        DWORD dwTemp;

        if( m_fError == TRUE)
            return FALSE;
        
        if( WriteFile( m_hFile, szString, cbSize, &dwTemp, NULL) == TRUE)
        {
            return TRUE;
        }
        else
        {
            m_fError = TRUE;
            m_dwLastError = GetLastError();
            return FALSE;
        }
    }

    BOOL WriteBool( BOOL fBool)
    {
        if( fBool == TRUE)
            return DumpStr( "TRUE", sizeof("TRUE") - 1);
        else
            return DumpStr( "FALSE", sizeof("FALSE") - 1);
    }

    BOOL WriteTab()
    {
        return DumpStr( "\t", sizeof('\t'));
    }

    BOOL WriteNSNewline()
    {
        return DumpStr( "\r\n\r\n", sizeof("\r\n\r\n") - 1);
    }

    BOOL IsError()
    {
        return m_fError;
    }

private:
    HANDLE m_hFile;
    BOOL m_fError;
    DWORD m_dwLastError;
};


//****************************************************
//
//  ExportCookieFile
//

// per-line format of Netscape cookie file
//DOMAIN \t is_given_domain(TRUE|FALSE) \t PATH \t secure(TRUE|FALSE) \t time_t(EXPIRES) \t NAME \t VALUE

BOOLAPI ExportCookieFileW( IN LPCWSTR szFilename, IN BOOL fAppend)
{
    MEMORYPACKET mpFilename;
    ALLOC_MB(szFilename,0,mpFilename);
    if (!mpFilename.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(szFilename,mpFilename);

    return ExportCookieFileA( mpFilename.psStr, fAppend);
};



BOOLAPI ExportCookieFileA( IN LPCSTR szFilename, IN BOOL fAppend)
{
    BOOL retVal = FALSE;

    CHAR* cursor;
    DWORD dwTemp;

    FileOutputStream outFile;

    CACHE_ENTRY_INFO_BUFFER *pcei = new CACHE_ENTRY_INFO_BUFFER;

    if (pcei == NULL)
        goto doneExportCookieFile;

    DWORD cbCeiSize = sizeof(*pcei);
    HANDLE hEnumeration = FindFirstUrlCacheEntry( IE_COOKIE_PREFIX, pcei, &cbCeiSize);
    if( hEnumeration == NULL)
        goto doneExportCookieFile;

    if( outFile.Load( szFilename, fAppend) != TRUE)
        goto doneExportCookieFile;

    if( !fAppend)
    {
        outFile.DumpStr( SZ_COOKIE_EXPORT_HEADER, sizeof(SZ_COOKIE_EXPORT_HEADER) - 1);
        outFile.WriteNSNewline();
    }
    
    if( outFile.IsError() == TRUE)
        goto doneExportCookieFile;

    //  enumerate over the cookie cache entries.
    //Each cache entry will have a file which contains multiple cookies,
    //so inside this loop we will be enumerating over individual cookies.
    do
    {
        CHAR* pFileBuf = NULL;
        DWORD cbFileBufSize;
        CHAR* pDomain;

        //Generate the DOMAIN for all the cookies in this entry
        // example Urls in pEntry:
        //  "Cookie:t-franks@amazon.com/"
        //  "Cookie:t-franks@~~local~~/c:\local\path\"
        // The correspondingDomain entry in NS cookie.txt:
        //   "amazon.com"
        //   ""  ->  local paths are empty strings to NS
        cursor = pcei->lpszSourceUrlName; 

        while( *cursor != '@' && *cursor != '\0')
            cursor++;
            
        if( *cursor != '@')
            goto doneWithEntryOnExportCookie;

        pDomain = ++cursor;

        if( StrCmpN( pDomain, IE_LOCAL_PREFIX, sizeof(IE_LOCAL_PREFIX) - 1) != 0) 
        {
            //  if we have a non-local domain, clip off the path.
            while( *cursor != '/' && *cursor != '\0')
                cursor++;

            if( *cursor != '/')
                goto doneWithEntryOnExportCookie;

            *cursor = '\0';
        }
        else
        {
            //  Else local cookies have a blank domain in the Netscape cookie files.
            pDomain[0] = '\0';
        }

        // load the attached file and enumerate through the contained cookies.
        if( (pcei->lpszLocalFileName == NULL)
            || (ReadFileToBuffer( pcei->lpszLocalFileName, (BYTE**)&pFileBuf, &cbFileBufSize) 
                != TRUE))
        {
            goto doneWithEntryOnExportCookie;           
        }
        
        CHAR* pFileCursor;
        pFileCursor = pFileBuf;
        while( pFileCursor < pFileBuf + cbFileBufSize)
        {
            CHAR *pszName, *pszValue, *pszHash, *pszFlags,
                 *pszExpireTimeLow, *pszExpireTimeHigh,
                 *pszLastTimeHigh,  *pszLastTimeLow,
                 *pszDelimiter;
            FILETIME ftExpire;
            DWORD dwFlags;
       
            // Get the first token (cookie name).
            pszName           = StrTokEx(&pFileCursor, "\n");
            if (!pszName)                               // Cookie name.
            {
                // Normal termination of the parse.
                goto doneWithEntryOnExportCookie;
            }

            // Parse the rest of the cookie
            if( *pFileCursor == '\n')
            {
                pszValue = pFileCursor;
                *pszValue = '\0';
                pFileCursor++;
            }
            else
                pszValue          = StrTokEx(&pFileCursor, "\n");      // Cookie value.

            pszHash           = StrTokEx(&pFileCursor, "\n");      // Combo of domain and path.
            pszFlags          = StrTokEx(&pFileCursor, "\n");      // Cookie flags.
            pszExpireTimeLow  = StrTokEx(&pFileCursor, "\n");      // Expire time.
            pszExpireTimeHigh = StrTokEx(&pFileCursor, "\n");             
            pszLastTimeLow    = StrTokEx(&pFileCursor, "\n");      // Last Modified time.
            pszLastTimeHigh   = StrTokEx(&pFileCursor, "\n");
            pszDelimiter      = StrTokEx(&pFileCursor, "\n");      // Delimiter should be "*"

            // Abnormal termination of parse.
            if (!pszDelimiter || pszDelimiter[0] != '*')
            {
                INET_ASSERT(FALSE);
                goto doneWithEntryOnExportCookie;
            }

            // Get the expire time.
            ftExpire.dwLowDateTime  = atoi(pszExpireTimeLow);
            ftExpire.dwHighDateTime = atoi(pszExpireTimeHigh);

            // Get the flags
            dwFlags = atoi(pszFlags);

            //  If this is a session cookie, its non-persistent
            //and shouldn't be saved to file.
            //  (session cookies shouldn't be in the index file, anyhow)
            INET_ASSERT( (dwFlags & COOKIE_SESSION) == 0 ? TRUE : FALSE);
            if( (dwFlags & COOKIE_SESSION) != 0)
                continue;
                
            //  process parsed contents.
            CHAR* pszNSPath;
            DWORD timetExpire;

            // Example IE cookie file:
            // pszHash = "amazon.com/main/"
            // pszHash = "~~local~~/c:\local\path\"
            // corresponding Netscape path format:
            // pszNSPath = "/main/"
            // pszNSPath = "/c|/local/path/"
            cursor = pszHash;

            // move to the first '/'
            while( *cursor != '/' && *cursor != '\0')
                cursor++;
            if( *cursor != '/')
                continue;

            pszNSPath = cursor;
                
            //  If this is a path on the Hard Disk, turn the '\\'s to '/'s
            //and ':'s to '|'s.  (to conform with funky NS format)
            if( StrCmpN( pszHash, IE_LOCAL_PREFIX, sizeof(IE_LOCAL_PREFIX) - 1) == 0)
            {
                while( *cursor != '\0')
                {
                    if( *cursor == '\\')
                        *cursor = '/';

                    if( *cursor == ':')
                        *cursor = '|';

                    cursor++;
                }
            }

            //  convert to Netscape time format
            FileTimeToDosTime( ftExpire, &timetExpire);

            outFile.DumpStr( pDomain, lstrlen( pDomain));
            outFile.WriteTab();
            outFile.WriteBool( TRUE);
            outFile.WriteTab();
            outFile.DumpStr( pszNSPath, lstrlen( pszNSPath));
            outFile.WriteTab();
            outFile.WriteBool( (dwFlags & COOKIE_SECURE) != 0 ? TRUE : FALSE);
            outFile.WriteTab();

            CHAR expireBuffer[16];
            wsprintf( expireBuffer, "%lu", timetExpire);
            outFile.DumpStr( expireBuffer, lstrlen( expireBuffer));
            outFile.WriteTab();

            outFile.DumpStr( pszName, lstrlen( pszName));
            outFile.WriteTab();
            outFile.DumpStr( pszValue, lstrlen( pszValue));
            outFile.WriteNSNewline();
        }
        
    doneWithEntryOnExportCookie:
        if( pFileBuf != NULL)
            delete [] pFileBuf;

        if( outFile.IsError() == TRUE)
            goto doneExportCookieFile;
    }
    while( FindNextUrlCacheEntry( hEnumeration, pcei, &(cbCeiSize = sizeof(*pcei))));

    retVal = TRUE;
    
doneExportCookieFile:

    if (pcei)
        delete pcei;

    if( hEnumeration != NULL)
        FindCloseUrlCache( hEnumeration);

    return retVal;
}

// reverse of part of transformation in InternetTimeFromTime_t
//  A filetime is the numbers of 100 ns since Jan 1, 1601, while
//a dostime is the number of seconds since Jan 1, 1970.
void FileTimeToDosTime( FILETIME ft, DWORD* pTime_t)
{
    //dwl1970Offset is the number of ns from 1601 to 1970
    const DWORDLONG dwl1970Offset = 0x019dae9064bafa80;

    DWORDLONG lVal;
    
    lVal = ft.dwLowDateTime;
    lVal |= Int64ShllMod32( Int64ShllMod32( ft.dwHighDateTime, 16), 16 );

    *pTime_t = (DWORD)((lVal - dwl1970Offset) / 10000000);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\dllentry.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dllentry.cxx

Abstract:

    Entry point for WinInet Internet client DLL

    Contents:
        WinInetDllEntryPoint

Author:

    Richard L Firth (rfirth) 10-Nov-1994

Environment:

    Win32 (user-mode) DLL

Revision History:

    10-Nov-1994 rfirth
        Created

--*/

#include <wininetp.h>
#include <process.h>
#include <perfdiag.hxx>
#include <shlwapi.h>
#include <advpub.h>
#include "autodial.h"

#define FLAGS_SZ "Flags"
#define FLAGS_DW PLUGIN_AUTH_FLAGS_CAN_HANDLE_UI | PLUGIN_AUTH_FLAGS_KEEP_ALIVE_NOT_REQUIRED
#define IE_SECURITY_DIGEST_REG_KEY "Software\\Microsoft\\Internet Explorer\\Security\\Digest"


#if defined(__cplusplus)
extern "C" {
#endif

BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    );


#if defined(__cplusplus)
}
#endif

//
// global data
//

GLOBAL CRITICAL_SECTION GeneralInitCritSec = {0};

//
// functions
//


BOOL
WINAPI
DllMain(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )

/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/

{
    if (Reason != DLL_PROCESS_ATTACH) {

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

    }

    DWORD error;

    //
    // perform global dll initialization, if any.
    //
    switch (Reason) {
    case DLL_PROCESS_ATTACH:
        GlobalDllHandle = DllHandle;
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        // Call SHFusionInitialize only on themed platforms:
        if (GlobalPlatformWhistler)
            SHFusionInitializeFromModule((HMODULE)DllHandle);
        
        InitializeCriticalSection(&GeneralInitCritSec);

        INITIALIZE_DEBUG_REGKEY();
        INITIALIZE_DEBUG_MEMORY();
        INET_DEBUG_START();

        GlobalDllInitialize();
        if (!InternetCreateThreadInfo(TRUE)) {
            return FALSE;
        }

        DEBUG_ENTER((DBG_DLL,
                     Bool,
                     "DllMain",
                     "%#x, %s, %#x",
                     DllHandle,
                     (Reason == DLL_PROCESS_ATTACH) ? "DLL_PROCESS_ATTACH"
                     : (Reason == DLL_PROCESS_DETACH) ? "DLL_PROCESS_DETACH"
                     : (Reason == DLL_THREAD_ATTACH) ? "DLL_THREAD_ATTACH"
                     : (Reason == DLL_THREAD_DETACH) ? "DLL_THREAD_DETACH"
                     : "?",
                     Reserved
                     ));

        DEBUG_LEAVE(TRUE);

        break;

    case DLL_PROCESS_DETACH:

        //
        // signal to all APIs (and any other function that might have an
        // interest) that the DLL is being shutdown
        //

        GlobalDynaUnload = (Reserved == NULL) ? TRUE : FALSE;
        InDllCleanup = TRUE;
        GlobalPleaseQuitWhatYouAreDoing = TRUE;

        DEBUG_PRINT(DLL,
                    INFO,
                    ("DLL Terminated\n"
                    ));

        DEBUG_LEAVE(TRUE);

        if (GlobalDynaUnload) {
            if (GlobalDataInitialized) {
                GlobalDataTerminate();
            }
            GlobalDllTerminate();
            ExitAutodialModule();
            InternetTerminateThreadInfo();
        }

        CloseInternetSettingsKey();

        PERF_DUMP();

        PERF_END();

        //TERMINATE_DEBUG_MEMORY(FALSE);
        TERMINATE_DEBUG_MEMORY(TRUE);
        INET_DEBUG_FINISH();
        TERMINATE_DEBUG_REGKEY();

        //InternetDestroyThreadInfo();

        GlobalUserName.~CUserName();
        DeleteCriticalSection(&GeneralInitCritSec);

        // Call SHFusionUninitialize only on themed platforms:
        if (GlobalPlatformWhistler)
            SHFusionUninitialize();
        
        break;

    case DLL_THREAD_DETACH:

        //
        // kill the INTERNET_THREAD_INFO
        //

        DEBUG_LEAVE(TRUE);

        InternetDestroyThreadInfo();
        break;

    case DLL_THREAD_ATTACH:

        //
        // we do nothing for thread attach - if we need an INTERNET_THREAD_INFO
        // then it gets created by the function which realises we need one
        //

        AllowCAP();

        DEBUG_LEAVE(TRUE);

        break;
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(GlobalDllHandle, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

extern VOID MakeCacheLocationsConsistent();

STDAPI
DllInstall
(
    IN BOOL      bInstall,   // Install or Uninstall
    IN LPCWSTR    pwStr
)
{
    HRESULT hr = S_OK;


// Add entries to selfreg.inx and include the code below to support self-registration.
#ifdef WININET_SELFREG

    BOOL bUseHKCU = FALSE;
    if (pwStr && (0 == StrCmpIW(pwStr, L"HKCU")))
    {
        bUseHKCU = TRUE;
    }

    if ( bInstall )
    {
        hr = CallRegInstall(bUseHKCU ? "Reg.HKCU" : "Reg.HKLM");
    }
    else
    {
        hr = CallRegInstall(bUseHKCU ? "Unreg.HKCU" : "UnReg.HKLM");
    }
#endif

    if( bInstall && (!pwStr || !*pwStr || (StrCmpIW( pwStr, L"HKLM") == 0)))
    {
        // Write out to HKLM\Software\Microsoft\Internet Explorer\Security\Digest
        HKEY hKey;
        DWORD dwError, dwRegDisp, dwFlags;
        dwFlags = FLAGS_DW;

        dwError =  REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
            IE_SECURITY_DIGEST_REG_KEY, 0, NULL,
                0, KEY_READ | KEY_WRITE, NULL, &hKey, &dwRegDisp);

        if (dwError == ERROR_SUCCESS)
        {
            dwError = RegSetValueEx(hKey, FLAGS_SZ, 0,
                REG_BINARY, (LPBYTE) &dwFlags, sizeof(DWORD));
            REGCLOSEKEY(hKey);
        }


        // also need to fix up the HKLM\SV\MS\IE\AdavancedOptions\Negotiate so that "Restore Defaults" will work
        // HKEY hKey;
        // DWORD dwError, dwRegDisp, dwFlags;
        
        GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        if (GlobalPlatformWhistler)
        {
            dwFlags = 0x00000001;

            dwError =  REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
                "SOFTWARE\\Microsoft\\Internet Explorer\\AdvancedOptions\\CRYPTO\\NEGOTIATE", 0, NULL,
                    0, KEY_WRITE, NULL, &hKey, &dwRegDisp);

            if (dwError == ERROR_SUCCESS)
            {
                dwError = RegSetValueEx(hKey, "DefaultValue", 0,
                    REG_DWORD, (LPBYTE) &dwFlags, sizeof(DWORD));
                REGCLOSEKEY(hKey);
            }
        }

#ifndef UNIX
        DWORD dwNSVersion;
        if( GetActiveNetscapeVersion( &dwNSVersion) == FALSE)
            dwNSVersion = 0;
        SetNetscapeImportVersion( dwNSVersion);
#endif // UNIX

        WritePrivateProfileString("compatibility", "NOTIFIER", "0x400000", "win.ini");
        WritePrivateProfileString(NULL, NULL, NULL, "win.ini");
    }
    else if(bInstall && StrCmpIW( pwStr, L"HKCU") == 0)
    {

        MakeCacheLocationsConsistent();

#ifndef UNIX
        TCHAR szNSFilename[MAX_PATH];
        DWORD cNSFilenameSize = MAX_PATH;
        DWORD dwNSVersion;

        if( GetNetscapeImportVersion( &dwNSVersion) == TRUE
            && dwNSVersion != 0
            && FindNetscapeCookieFile( dwNSVersion, szNSFilename, &cNSFilenameSize) == TRUE)
        {
            ImportCookieFile( szNSFilename );
        }
#endif // UNIX

        ie401::Import401History();

        ie401::Import401Content();
    }
    else if (!bInstall && (!pwStr || !*pwStr || (StrCmpIW(pwStr, L"HKLM") == 0)))
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE, IE_SECURITY_DIGEST_REG_KEY);
    }

    //
    // set up privacy defaults
    //
    if(bInstall && StrCmpIW( pwStr, L"HKCU") == 0 && !IsInGUIModeSetup())
    {
        CheckPrivacyDefaults();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\cliauth.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cliauth.cxx

Abstract:

    Contains Schannel/SSPI specific code for handling Client Authenication
    multiplexed between several asynchronous requests using fibers

    Contents:
        CliAuthRefreshCredential
        CliAuthSelectCredential

Author:

    Arthur L Bierer (arthurbi) 13-Jun-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Jun-1996 arthurbi
        Created, based on orginal code from a-petesk.

--*/

#include <wininetp.h>


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

}


CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY()
{
    _error           = ERROR_SUCCESS;
    _iSelected  = -1;
    _ppCertContexts    = (PCCERT_CONTEXT *)
                        ALLOCATE_MEMORY(LMEM_FIXED,
                            sizeof(PCERT_CONTEXT)* CERT_CONTEXT_ARRAY_ALLOC_UNIT);

    if ( _ppCertContexts == NULL ) {
        _error = GetLastError();
    }

    _cAlloced  = CERT_CONTEXT_ARRAY_ALLOC_UNIT;
    _cCertContexts     = 0;

    ClearCreds(_hCreds);
    InitializeCriticalSection(&_cs);
}

void CERT_CONTEXT_ARRAY::Reset(void)
{
    if ( _ppCertContexts )
    {
        for ( DWORD i = 0; i < _cCertContexts; i++ )
        {
            INET_ASSERT(_ppCertContexts[i]);
            CertFreeCertificateContext(_ppCertContexts[i]);
        }
    }
    _cCertContexts = 0;
    
    // It is important that this Free is guarded by a try except.
    // These objects get freed up at dll unload time and there is a circular
    // dependency between winient and schannel which can cause schannel to 
    // get unloaded. If that is the case we could fault here.
    if (!IsCredClear(_hCreds))
    {
        __try 
        {
            g_FreeCredentialsHandle(&_hCreds);
        }
        __except ( EXCEPTION_EXECUTE_HANDLER )
        {
            // do nothing.
        }
    }
}


CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY()
{
    Reset();

    FREE_MEMORY(_ppCertContexts);
    DeleteCriticalSection(&_cs);
}

DWORD
CliAuthSelectCredential(
    IN PCtxtHandle        phContext,
    IN LPTSTR             pszPackageName,
    IN CERT_CONTEXT_ARRAY*  pCertContextArray,
    OUT PCredHandle       phCredential)

/*++

Routine Description:

    Uses a selected Certificate Chain to produce a Credential handle.

    The credential handle will be used by SCHANNEL to produce a valid Client
    Auth session with a server.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    pSelectedCert   - Cert that User wishes us to use for Client Auth with this server.
                       (BUGBUG who should free this? )

    phCredential    - Outgoing SSPI Credential handle that we may generate
                    IMPORTANT: Do not free the credential handle returned by this function.
                    These have to be cached for the lifetime of the process so the user 
                    doesn't get prompted forthe password over and over. Unfortunately there is
                    no ref-counting mechanism on CredHandle's so callers of this function need to 
                    make sure they don't free the handle.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_INTERNET_SECURITY_CHANNEL_ERROR -
                        Call Down to SSPI or WinTrust failed.

                  ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP -
                        Client Auth is not setup on this machine.

--*/

{

     SCHANNEL_CRED CredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     DEFAULT_SECURE_PROTOCOLS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                     };
    SECURITY_STATUS scRet;


    DWORD           i;
    PCERT_BLOB      pBlob;
    DWORD           index;
    DWORD           error;
    PCCERT_CONTEXT  pCert;
    CredHandle      hCreds;

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthSelectCredential",
                 "%#x, %s, %x, %x",
                 phContext,
                 pszPackageName,
                 pCertContextArray,
                 phCredential
                 ));


    INET_ASSERT(phContext);
    INET_ASSERT(pCertContextArray);
    INET_ASSERT(pszPackageName);


    pCertContextArray->LockCredHandle( );

    if ( pCertContextArray->GetArraySize() == 0 )
    {
        error = ERROR_SUCCESS;
        goto quit;
    }

    // First check and see if the Cert context already has a CredHandle associated with it.
    hCreds = pCertContextArray->GetCredHandle( );

    if (!IsCredClear(hCreds))
    {
        *phCredential = hCreds;
        error = ERROR_SUCCESS;
        goto quit;
    }

    pCert =         pCertContextArray->GetSelectedCertContext();


    //
    // Setup strucutres for AcquireCredentialsHandle call.
    //

    if ( pCert )
    {

        CredData.cCreds = 1;
        CredData.paCred = &pCert;
    }
    InternetReadRegistryDword("SecureProtocols",
                          (LPDWORD)&CredData.grbitEnabledProtocols
                          );

    scRet = g_AcquireCredentialsHandle(
        NULL,
        pszPackageName,
        SECPKG_CRED_OUTBOUND,
        NULL,
        &CredData,
        NULL,
        NULL,
        phCredential,
        NULL);

    error = MapInternetError((DWORD)scRet);
    if (error == ERROR_SUCCESS)
    {
        pCertContextArray->SetCredHandle(*phCredential);
    }

quit:
    pCertContextArray->UnlockCredHandle();
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CliAuthAcquireCertContexts(
    IN  PCtxtHandle        phContext,
    IN  LPTSTR             pszPackageName,
    OUT CERT_CONTEXT_ARRAY** ppCertContextArray
    )

/*++

Routine Description:

    Acquires a List of valid Certificate Chains for use in Client Authentication.

    Gathers an issuer list from the current context, and uses CAPI stored Certificates
    to build a list which will be selected from by the user at a later point.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    phCredential    - Outgoing SSPI Credential handle that we may generate

    ppCertContextArray  - Outgoing List of Certifcate Contexts that can be selected
                        among to generate a Context.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_INTERNET_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_INTERNET_SECURITY_CHANNEL_ERROR -
                        Call Down to SSPI or WinTrust failed.

                  ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP -
                        Client Auth is not setup on this machine.

--*/

{
    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthAcquireCertContexts",
                 "%#x, %s, %x",
                 phContext,
                 pszPackageName,
                 ppCertContextArray
                 ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    BOOL async;
    SECURITY_STATUS scRet;
    DWORD           cCerts;
    CERT_CHAIN_FIND_BY_ISSUER_PARA FindByIssuerPara;
    SecPkgContext_IssuerListInfoEx IssuerListInfo;
    PCCERT_CHAIN_CONTEXT pChainContext;
    PCCERT_CONTEXT pCertContext;
    DWORD error;

    if (lpThreadInfo != NULL) {
        async = _InternetGetAsync(lpThreadInfo);
        _InternetSetAsync(lpThreadInfo, FALSE);
    }

    INET_ASSERT(ppCertContextArray);


    INET_ASSERT(*ppCertContextArray == NULL );
    *ppCertContextArray = NULL;

    IssuerListInfo.cIssuers = 0;
    IssuerListInfo.aIssuers = NULL;

    if ( phContext == NULL )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // Attempt to find out whether we have any issuers
    //  from this connection that the Server might have
    //  told us about.
    //
    
    scRet = g_QueryContextAttributes(phContext,
                                   SECPKG_ATTR_ISSUER_LIST_EX,
                                   &IssuerListInfo);

    if(FAILED(scRet))
    {
        error = MapInternetError((DWORD) scRet);
        goto quit;
    }

    cCerts = 0;

    //
    // Create our CertChain Array for keeping CertChains around
    //

    *ppCertContextArray = new CERT_CONTEXT_ARRAY();

    if ( *ppCertContextArray == NULL )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    error = (*ppCertContextArray)->GetError();

    if ( error != ERROR_SUCCESS)
    {
        goto quit;
    }

    if (g_CertFindChainInStore == NULL || g_CertFreeCertificateChain == NULL)
    {
        // We don't support client-auth unless we have the new crypto dlls
        error = ERROR_CALL_NOT_IMPLEMENTED;
        goto quit;
    }

    ZeroMemory(&FindByIssuerPara, sizeof(FindByIssuerPara));

    FindByIssuerPara.cbSize = sizeof(FindByIssuerPara);
    FindByIssuerPara.pszUsageIdentifier = szOID_PKIX_KP_CLIENT_AUTH;
    FindByIssuerPara.dwKeySpec = 0;
    FindByIssuerPara.cIssuer   = IssuerListInfo.cIssuers;
    FindByIssuerPara.rgIssuer  = IssuerListInfo.aIssuers;

    pChainContext = NULL;

    while (TRUE)
    {
        // Find a certificate chain.
        if(g_bOpenMyCertStore && g_hMyCertStore == NULL)
           ReopenMyCertStore();
        pChainContext = g_CertFindChainInStore(g_hMyCertStore,
                                             X509_ASN_ENCODING,
                                             0,
                                             CERT_CHAIN_FIND_BY_ISSUER,
                                             &FindByIssuerPara,
                                             pChainContext);

        if (pChainContext == NULL)
            break;

        // Get pointer to leaf certificate context.
        pCertContext = pChainContext->rgpChain[0]->rgpElement[0]->pCertContext;

        // This could only happen if there is a bug in the crypto code. But we will deal with
        // that and continue looking in any case.
        if (pCertContext == NULL)
        {
            INET_ASSERT(FALSE);
            continue;
        }

        BOOL AcceptCert=FALSE;

        // retrieve key usage field
        BYTE KeyUsage;
        BOOL BKeyUsage = CertGetIntendedKeyUsage(pCertContext->dwCertEncodingType, pCertContext->pCertInfo, &KeyUsage, sizeof(KeyUsage));

        // if there is no key usage field (BKeyUsage is FALSE) or key usage is set to CERT_DIGITAL_SIGNATURE_KEY_USAGE, then accept certificate 
        // as client certificate for SSL auth
        if ( !BKeyUsage || (KeyUsage & CERT_DIGITAL_SIGNATURE_KEY_USAGE))
            AcceptCert = TRUE;         

        if (AcceptCert)
            error = (*ppCertContextArray)->AddCertContext(pCertContext);

        if (error != ERROR_SUCCESS)
        {
            g_CertFreeCertificateChain(pChainContext);
            goto quit;
        }
    }

quit:

    if ( error != ERROR_SUCCESS &&
         *ppCertContextArray != NULL )
    {
        delete *ppCertContextArray;
        *ppCertContextArray = NULL;
    }

    if (IssuerListInfo.aIssuers != NULL)
    {
        g_FreeContextBuffer(IssuerListInfo.aIssuers);
    }

    if (lpThreadInfo != NULL) {
        _InternetSetAsync(lpThreadInfo, async);
    }

    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\cookimp.cxx ===
#include <wininetp.h>
#include <wininet.h>

//#include "..\inc\cookimp.h"

#define NS_COOKIE_IMPORT_KEY        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\NSCookieUpgrade")
#define NS_COOKIE_IMPORT_VERSION    TEXT("Version")
#define NS_COOKIE_IMPORT_FLAG       TEXT("DisableUpgrade")

#define HTML_FILE_EXTENSION         TEXT(".htm")
#define NS_EXE_FILENAME             TEXT("Netscape.exe")
#define NS_COOKIE_FILENAME          TEXT("cookies.txt")

#define OPEN_COMMAND_OF_APP         TEXT("\\shell\\open\\command")
#define NS_APP_PATHS_REG            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\Netscape.exe")

#define NS3_COOKIE_REG_PATH         TEXT("Software\\Netscape\\Netscape Navigator\\Cookies")
#define NS3_COOKIE_REG_KEY          TEXT("Cookie File")
#define NS4_USERS_REG_PATH          TEXT("Software\\Netscape\\Netscape Navigator\\Users")
#define NS4_USERPATH_REG_KEY        TEXT("DirRoot")

//  note:  LENGTHOFSTR()'s result includes terminating character
#define LENGTHOFTSTR( x ) (sizeof(x) / sizeof(TCHAR))

bool EndOfLine( CHAR chr );
BOOL InternetTimeFromTime_tA( IN DWORD dwTime, OUT LPSTR lpszTime, /* in-out */ DWORD cbBufferSize );


//--------------------------------------------------------------------
//
//  ImportCookieFile
//

//  parses a Netscape 'cookies.txt' file and adds each cookie using InternetSetCookie
BOOLAPI ImportCookieFileW( IN LPCWSTR szFilename)
{
    MEMORYPACKET mpFilename;
    ALLOC_MB(szFilename,0,mpFilename);
    if (!mpFilename.psStr)
    {
        return FALSE;
    }
    UNICODE_TO_ANSI(szFilename,mpFilename);

    return ImportCookieFileA( mpFilename.psStr);
};


BOOLAPI ImportCookieFileA( IN LPCSTR szFilename )
{
    BOOL retVal = FALSE;

    HANDLE hFile = (HKEY) INVALID_HANDLE_VALUE;
    LPSTR szFile = NULL;
    DWORD cbFileSize;

    if( ReadFileToBuffer( szFilename, (BYTE**)&szFile, &cbFileSize) != TRUE)
        goto doneImportFile;

    // parse file line by line
    DWORD iPosition;
    iPosition = 0;
    while( iPosition < cbFileSize )
    {
        LPSTR szValue = NULL;
        LPSTR szURL = NULL;

        //   blank lines are ignored
        if( EndOfLine( szFile[iPosition]))
        {
            iPosition++;
            continue;
        }

        //   lines beginning with # are comments
        if( szFile[iPosition] == '#')
        {
            while ( iPosition < cbFileSize && !EndOfLine( szFile[iPosition]))
                iPosition++;

            iPosition++;
            continue;
        }

        //   see CookieFormat text file for the spec of a Netscape 'cookies.txt'
        const DWORD iArgCount = 7;
        enum eArgTypes { DOMAIN=0,UNUSED=1,PATH=2,SECURE=3,EXPIRES=4,NAME=5,VALUE=6 };

        //  parse cookie into 7 fields (szArg[0..6]) with lengths stored in cbArgLength[0..6]
        LPSTR szArg[iArgCount];
        DWORD cbArgLength[iArgCount];

        // Continue parsing fields only if end of line/file hasn't been hit.
        // 'for' is re-entered when the end of each cookie is found:
        //      On re-entry, null terminate the cookie found.
        for( DWORD iArgIndex = 0;
                iPosition < cbFileSize && !EndOfLine( szFile[iPosition]);
                iArgIndex++, szFile[iPosition++] = '\0')
        {
            //  sanity check: are there really only 7 fields?
            if( iArgIndex >= iArgCount )
            {
                INET_ASSERT(FALSE);

                // if there are more than 7 fields, move to where a new cookie should start
                while ( iPosition < cbFileSize && !EndOfLine( szFile[iPosition]))
                    iPosition++;

                // end of invalid cookie found, now increment to next cookie.
                iPosition++;

                goto doneImportCookie;
            }

            //  Mark the beginning of the field.
            szArg[iArgIndex] = &szFile[iPosition];

            //  Find the end of the field.
            while( iPosition < cbFileSize && szFile[iPosition] != '\t' && !EndOfLine( szFile[iPosition]) )
                iPosition++;

            // Calculate the length of the cookie.
            cbArgLength[iArgIndex] = (unsigned long) (&szFile[iPosition] - szArg[iArgIndex]);
        }

        if( iArgIndex < iArgCount )
        {
            //sanity check: Are there enough fields?
            INET_ASSERT(FALSE);
            goto doneImportCookie;
        }

        // build HTTP cookie string in szValue
        DWORD cbValueSize;
        cbValueSize =  cbArgLength[NAME]
                    + cbArgLength[VALUE]
                    + cbArgLength[DOMAIN]
                    + sizeof("=;secure;expires=;domain=")
                    + INTERNET_RFC1123_BUFSIZE
                    + 1;
        szValue = new CHAR[ cbValueSize];

        if( szValue == NULL )
            goto doneImportCookie;

        LPSTR pValueIterator;
        pValueIterator = szValue;

        // add 'name=value' pair
        memcpy( pValueIterator, szArg[NAME], cbArgLength[NAME] );
        pValueIterator += cbArgLength[NAME];
        pValueIterator[0] = '=';
        pValueIterator++;
        memcpy( pValueIterator, szArg[VALUE], cbArgLength[VALUE] );
        pValueIterator += cbArgLength[VALUE];

        //  set security information
        if( szArg[SECURE][0] == 'T' || szArg[SECURE][0] == 't' )
        {
            memcpy( pValueIterator, ";secure", sizeof(";secure") - 1);
            pValueIterator += sizeof(";secure") - 1;
        }

        //  In a path that is on the HD, Netscape's path is like "/c|/directory/filename.ext"
        //  I need the path to read as "/c:\directory\filename.ext".
        if( cbArgLength[DOMAIN] == 0 )
            for( LPSTR pchr = szArg[PATH]; *pchr != '\0'; pchr++ )
            {
                if( *pchr == '|' )
                    *pchr = ':';
                if( *pchr == '/' && pchr != szArg[PATH] )
                    *pchr = '\\';
            }

        //  InternetSetCookie accepts files with a local domain if it isn't
        // explicitly declared.. which related to a bug in InternetSetCookie.
        if( cbArgLength[DOMAIN] != 0 )
        {
            //  add the domain=DOMAIN pair
            memcpy( pValueIterator, ";domain=", sizeof(";domain=") - 1);
            pValueIterator += sizeof(";domain=") - 1;
            memcpy( pValueIterator, szArg[DOMAIN], cbArgLength[DOMAIN]);
            pValueIterator += cbArgLength[DOMAIN];
        }

        //  InternetSetCookie doesn't work right if the path ends in a filename.
        //so I'll stick the path in the szURL parameter (which accepts filenames)
        ////  add the path=PATH pair
        //memcpy( pValueIterator, ";path=", sizeof(";path=") - 1);
        //pValueIterator += sizeof(";path=") - 1;
        //memcpy( pValueIterator, szArg[PATH], cbArgLength[PATH]);
        //pValueIterator += cbArgLength[PATH];

        //  set expiration info
        memcpy( pValueIterator,";expires=", sizeof(";expires=") - 1);
        pValueIterator += sizeof(";expires=") - 1;

        if( InternetTimeFromTime_tA( StrToLong( szArg[EXPIRES]), pValueIterator, INTERNET_RFC1123_BUFSIZE ) != TRUE )
            goto doneImportCookie;

        //  InternetSetCookie requires an URL.. There isn't a complete url in the netscape cookie, but it can
        //be fudged.  The path in the URL will become the path stored for the cookie, the rest is checked for
        //legality then ignored.
        DWORD cbURLSize;
        cbURLSize = sizeof("nnnn://")
            + cbArgLength[DOMAIN]
            + cbArgLength[PATH]
            + 1;
        szURL = new CHAR[ cbURLSize];

        if( szURL == NULL )
            goto doneImportCookie;

        LPSTR pURLIterator;
        pURLIterator = szURL;

        if( szArg[DOMAIN][0] == '\0')
        {
            memcpy( pURLIterator, "file:/", sizeof("file:/") - 1);
            pURLIterator += sizeof("file:/") - 1;
            memcpy( pURLIterator, szArg[PATH], cbArgLength[PATH]);
            pURLIterator += cbArgLength[PATH];
        }
        else
        {
            memcpy( pURLIterator, "http://", sizeof("http://") - 1);
            pURLIterator += sizeof("http://") - 1;
            memcpy( pURLIterator, szArg[DOMAIN], cbArgLength[DOMAIN]);
            pURLIterator += cbArgLength[DOMAIN];
            memcpy( pURLIterator, szArg[PATH], cbArgLength[PATH]);
            pURLIterator += cbArgLength[PATH];
        }
        pURLIterator[0] = '\0';

        //  don't overwrite exisiting cookies.
        DWORD dwTemp;
        CHAR szNullTerminatedName[ MAX_PATH];
        memcpy( szNullTerminatedName, szArg[NAME], cbArgLength[NAME]);
        szNullTerminatedName[ cbArgLength[NAME]] = '\0';
        if( InternetGetCookieEx( szURL, szNullTerminatedName,
            NULL, &dwTemp, 0, NULL) == TRUE)
        {
            // this cookie exists!  don't import.
            goto doneImportCookie;
        }

        DEBUG_PUT(( "\n\nCalled InternetSetCookie with\nUrl:%s\nValue:%s", szURL,  szValue));

#ifdef UNICODE
#error "ImportCookieFile(): InternetSetCookieA needs to be called directly from here."
#endif
        if( InternalInternetSetCookie( szURL, NULL, szValue, COOKIE_NOUI, NULL ) == FALSE )
        {
            DWORD temp = GetLastError();
            DEBUG_PUT(("\n Cookie Rejected!  Error code: %x", temp));
        }

    // If we got this far, we're done.
    retVal = TRUE;

    doneImportCookie:
        if( szValue != NULL)
            delete [] szValue;
        if( szURL != NULL)
            delete [] szURL;
    }



doneImportFile:
    if( hFile != (HKEY) INVALID_HANDLE_VALUE)
        CloseHandle( hFile);

    if( szFile != NULL)
        delete [] szFile;


    return retVal;
}


//--------------------------------------------------------------------
//
//  FindNetscapeCookieFile
//

//  Gets the cookie file and stores it in buffer szFilename.
//lpnBufSize contains the buffer's size on the way in, and the amount used on the way out (in characters)
//If FindNetscapeCookieFile succeeds, it returns TRUE, else it returns FALSE.
//If it fails, information may be written to the buffer with error information,
//  look at RegQueryValueEx for details.
BOOL FindNetscapeCookieFile( IN DWORD dwNSVer, OUT LPTSTR szFilename, /* in-out */ LPDWORD lpnBufSize)
{
    BOOL retVal = FALSE;

    //  for Version<MS_NAVI4
    HKEY hCookieKey, hUserRootKey, hProfileKey;

    //  for MS_NAVI4 >= Version < MS_NAVI5
    hCookieKey = (HKEY) INVALID_HANDLE_VALUE;
    hUserRootKey = (HKEY) INVALID_HANDLE_VALUE;
    hProfileKey = (HKEY) INVALID_HANDLE_VALUE;

    INET_ASSERT( dwNSVer != 0x0000);

    if( dwNSVer < NS_NAVI4)
    {
        if( REGOPENKEYEX( HKEY_CURRENT_USER, NS3_COOKIE_REG_PATH, 0, KEY_READ, &hCookieKey) != ERROR_SUCCESS)
        {
            hCookieKey = (HKEY) INVALID_HANDLE_VALUE;
            goto doneFindNetscapeCookieFile;
        }

        DWORD dwType;  //  should be REG_SZ when returned from QueryValue
        DWORD cbBufSize;
        cbBufSize = *lpnBufSize * sizeof(TCHAR);
        if( RegQueryValueEx( hCookieKey, NS3_COOKIE_REG_KEY, NULL,  &dwType, (LPBYTE)szFilename, &cbBufSize) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            *lpnBufSize = cbBufSize / sizeof(TCHAR);
            goto doneFindNetscapeCookieFile;
        }
        *lpnBufSize = cbBufSize / sizeof(TCHAR);

        retVal = TRUE;
    }
    else if ( dwNSVer < NS_NAVI5)
    {
        if( REGOPENKEYEX( HKEY_LOCAL_MACHINE, NS4_USERS_REG_PATH, 0, KEY_READ, &hUserRootKey) != ERROR_SUCCESS)
        {
            hUserRootKey = (HKEY) INVALID_HANDLE_VALUE;
            goto doneFindNetscapeCookieFile;
        }

        DWORD dwNumberOfProfiles;
        if( RegQueryInfoKey( hUserRootKey, NULL, NULL, NULL, &dwNumberOfProfiles,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL) != ERROR_SUCCESS
            || dwNumberOfProfiles != 1)
        {
            goto doneFindNetscapeCookieFile;
        }

        TCHAR szProfileName[MAX_PATH];
        DWORD nProfileNameBufferSize;
        nProfileNameBufferSize = sizeof(szProfileName);
        if( RegEnumKeyEx( hUserRootKey, 0, szProfileName, &nProfileNameBufferSize, NULL, NULL, NULL, NULL) != ERROR_SUCCESS)
        {
            goto doneFindNetscapeCookieFile;
        }

        if( REGOPENKEYEX( hUserRootKey, szProfileName, 0, KEY_READ, &hProfileKey) != ERROR_SUCCESS)
        {
            hProfileKey = (HKEY) INVALID_HANDLE_VALUE;
            goto doneFindNetscapeCookieFile;
        }

        DWORD dwType;  //  should be REG_SZ when returned from QueryValue
        DWORD cbBufSize;
        cbBufSize = *lpnBufSize * sizeof(TCHAR);
        if( RegQueryValueEx( hProfileKey, NS4_USERPATH_REG_KEY, NULL, &dwType, (LPBYTE)szFilename, &cbBufSize) != ERROR_SUCCESS
            || dwType != REG_SZ)
        {
            *lpnBufSize = (cbBufSize / sizeof(TCHAR) - 1) + LENGTHOFTSTR( NS_COOKIE_FILENAME);
            goto doneFindNetscapeCookieFile;
        }

        if( (*lpnBufSize - (cbBufSize / sizeof(TCHAR) - 1)) < LENGTHOFTSTR( NS_COOKIE_FILENAME))
        {
            *lpnBufSize = (cbBufSize / sizeof(TCHAR) - 1) + LENGTHOFTSTR( NS_COOKIE_FILENAME);
            goto doneFindNetscapeCookieFile;
        }

        *lpnBufSize = cbBufSize / sizeof(TCHAR) - 1;
        szFilename[(*lpnBufSize)++] = TCHAR('\\');
        memcpy( szFilename + *lpnBufSize, NS_COOKIE_FILENAME, sizeof(NS_COOKIE_FILENAME));
        *lpnBufSize += LENGTHOFTSTR( NS_COOKIE_FILENAME);

        retVal = TRUE;
    }

doneFindNetscapeCookieFile:

    if( hCookieKey != (HKEY) INVALID_HANDLE_VALUE )
        REGCLOSEKEY( hCookieKey);

    if( hUserRootKey != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hUserRootKey);

    if( hProfileKey != (HKEY) INVALID_HANDLE_VALUE)
        REGCLOSEKEY( hProfileKey);

    return retVal;
}


//--------------------------------------------------------------------
//
//  GetActiveNetscapeVersion
//

BOOL GetActiveNetscapeVersion( LPDWORD lpVersion)
{
    BOOL retVal = FALSE;

    TCHAR szFilename[MAX_PATH];
    DWORD cFilenameSize = MAX_PATH;
    BYTE* pVerBuffer = NULL;

    //  If the application currently associated with .htm files is NS,
    //thats the active version.  If it isn't, we grab the last installed
    //version of NS and say thats the active version.

    LPTSTR pFilenameSubstring;
    if( GetExecuteableFromExtension( HTML_FILE_EXTENSION, szFilename, &cFilenameSize, &pFilenameSubstring) == FALSE
        || StrCmpI( pFilenameSubstring, NS_EXE_FILENAME) != 0 )
    {
        goto doneGetActiveNetscapeVersion;
    }

    DWORD cbFileVersionBufSize;
    DWORD dwTemp;
    if( (cbFileVersionBufSize = GetFileVersionInfoSize( szFilename, &dwTemp)) == 0 )
        goto doneGetActiveNetscapeVersion;

    pVerBuffer = new BYTE[cbFileVersionBufSize];
    if( pVerBuffer == NULL)
        goto doneGetActiveNetscapeVersion;

    if( GetFileVersionInfo( szFilename, 0, cbFileVersionBufSize, pVerBuffer) == 0 )
        goto doneGetActiveNetscapeVersion;

    VS_FIXEDFILEINFO *lpVSFixedFileInfo;

    unsigned uiLength;
    if( VerQueryValue( pVerBuffer, TEXT("\\"),(LPVOID*)&lpVSFixedFileInfo, &uiLength) == 0
        || uiLength == 0)
        goto doneGetActiveNetscapeVersion;

    *lpVersion = lpVSFixedFileInfo->dwFileVersionMS;
    retVal = TRUE;

doneGetActiveNetscapeVersion:
    if( pVerBuffer != NULL)
        delete [] pVerBuffer;

    return retVal;
}


//--------------------------------------------------------------------
//
//  ImportCookieFile
//

//  Retrieves the executable file associated with the open command for
//a particular file extension.
//
//  Parsing the open command for the path\file can be ambiguous.
//If there is a '\' in a prefixed file argument of the open command
//the returned string will contain everying up to and including
//that argument
//
//example:
//""c:\program files\argy.exe \load file" -postfix"
//will give you
//"c:\program files\ argv.exe \load"
//
//typical case:
//""c:\program files\exec.exe -prearg" -postarg"
//will give you
//"c:\program files\exec.exe"
//
//pcFilenameSubstring will point one char past the last '\' to allow
//immediate checking of that last word.
//
BOOL GetExecuteableFromExtension(
    IN LPCTSTR szExtension,
    OUT LPTSTR szFilepath,
    /* in-out */ LPDWORD pcFilenameSize,
    OUT LPTSTR* ppFilenameSubstring)
{
    DWORD dwType;   // rewritten often, temporary values
    TCHAR szBuffer[MAX_PATH];   // reused as szCommandKeyPath and szOpenCommand
    DWORD cBufSize;

    BOOL retVal = FALSE;

    HKEY hHtmlEntry = (HKEY) INVALID_HANDLE_VALUE;
    HKEY hOpenCmd = (HKEY) INVALID_HANDLE_VALUE;

    if( REGOPENKEYEX( HKEY_CLASSES_ROOT, szExtension, 0, KEY_READ, &hHtmlEntry) != ERROR_SUCCESS)
    {
        hHtmlEntry = (HKEY) INVALID_HANDLE_VALUE;
        goto doneGetExecuteableFromExtension;
    }

    // to build a registry key in szCommandKeyPath, we first retrieve
    // the filetype (e.g. htmlfile) and then attach the registry path
    // for the 'open' command in HKEY_CLASSES_ROOT

    LPTSTR szCommandKeyPath;
    szCommandKeyPath = szBuffer;

    //  retrieve filetype
    cBufSize = MAX_PATH * sizeof(TCHAR);
    if( RegQueryValueEx( hHtmlEntry, NULL, NULL, &dwType, (BYTE*)szCommandKeyPath, &cBufSize) != ERROR_SUCCESS
        || dwType != REG_SZ )
    {
        goto doneGetExecuteableFromExtension;
    }

    //  append path ('htmlfile' -> 'htmlfile\\shell\\open\\command')
    StrCatBuff(szCommandKeyPath, OPEN_COMMAND_OF_APP, MAX_PATH);

    //  get the open command from the registry
    if( REGOPENKEYEX( HKEY_CLASSES_ROOT, szCommandKeyPath, 0, KEY_READ, &hOpenCmd) != ERROR_SUCCESS)
    {
        hOpenCmd = (HKEY) INVALID_HANDLE_VALUE;
        goto doneGetExecuteableFromExtension;
    }

    LPTSTR szOpenCommand;
    szOpenCommand = szBuffer;
    cBufSize = MAX_PATH * sizeof(TCHAR);
    if( RegQueryValueEx( hOpenCmd, "", NULL, &dwType, (BYTE*)szOpenCommand, &cBufSize) != ERROR_SUCCESS
        || dwType != REG_SZ)
    {
        goto doneGetExecuteableFromExtension;
    }

    // we now have a command line entry with the netscape filename.
    // typical format:  ""path\filename -prefixed args" -postfixed arguments"

    LPTSTR pSubstring;
    LPTSTR pRightmostWhack;
    // Now, too build a return value, point to the path\filename within the
    // command line entry and null-terminate it.
    pSubstring = szOpenCommand;
    while( *pSubstring == TCHAR('\"') || *pSubstring == TCHAR(' '))
    {
        // move beginning past any prefixed quotes or spaces
        pSubstring++;
    }

    pRightmostWhack = StrRChr(pSubstring, NULL, TCHAR('\\'));

    if (!pRightmostWhack)
    {
        // couldn't find a "\" so just set it equal to the substring
        pRightmostWhack = pSubstring;
    }
    else
    {
        // move to the the beginning of the last token (a filename, we assume)
        pRightmostWhack++;
    }

    // save the location of the filename
    *ppFilenameSubstring = pRightmostWhack;

    // move right end past the last token
    while(*pRightmostWhack != TCHAR('\"')    &&
          *pRightmostWhack != TCHAR(' ')     &&
          *pRightmostWhack != TCHAR('\0'))
    {
        pRightmostWhack++;
    }

    // null terminate the substring
    *pRightmostWhack = TCHAR('\0');

    // strictly > since lstrlen dosen't count space for NULL terminator
    if(*pcFilenameSize > (DWORD)lstrlen(pSubstring))
    {
        lstrcpyn(szFilepath, pSubstring, *pcFilenameSize);
        retVal = TRUE;
    }

    *pcFilenameSize = lstrlen(pSubstring);

doneGetExecuteableFromExtension:
    if( hHtmlEntry != (HKEY) INVALID_HANDLE_VALUE)
    {
        REGCLOSEKEY( hHtmlEntry);
    }

    if( hOpenCmd != (HKEY) INVALID_HANDLE_VALUE)
    {
        REGCLOSEKEY( hOpenCmd);
    }

    return retVal;
}






//***********************************************************************************
//    registry functions to store which version of Netscape is to be imported from


//--------------------------------------------------------------------
//
//  SetNetscapeImportVersion
//

//  Store version of Netscape to import cookies from in the registry
BOOL SetNetscapeImportVersion( IN DWORD dwNSVersion)
{
    BOOL retVal = FALSE;

    HKEY hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;

    DWORD dwDisposition;  // ignored output parameter
    if( REGCREATEKEYEX( HKEY_LOCAL_MACHINE, NS_COOKIE_IMPORT_KEY, 0, TEXT("REG_SZ"),
                        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hNSVersionKey, &dwDisposition) != ERROR_SUCCESS)
    {
        hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;
        goto doneSetNetscapeImportVersion;
    }

    if( RegSetValueEx( hNSVersionKey, NS_COOKIE_IMPORT_VERSION, 0, REG_DWORD, (BYTE*)&dwNSVersion, sizeof(DWORD)) != ERROR_SUCCESS )
        goto doneSetNetscapeImportVersion;

    retVal = TRUE;

doneSetNetscapeImportVersion:
    if( hNSVersionKey != (HKEY) INVALID_HANDLE_VALUE )
        REGCLOSEKEY( hNSVersionKey);

    return retVal;
}


//--------------------------------------------------------------------
//
//  GetNetscapeImportVersion
//

//  Retrieves version of Netscape to import coookies from in the registry
BOOL GetNetscapeImportVersion( OUT DWORD* pNSVersion)
{
    BOOL retVal = FALSE;

    HKEY hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;

    TCHAR szNSFilename[MAX_PATH];
    DWORD cNSFilenameSize = MAX_PATH;

    if( REGOPENKEYEX( HKEY_LOCAL_MACHINE, NS_COOKIE_IMPORT_KEY, 0, KEY_READ, &hNSVersionKey) != ERROR_SUCCESS)
    {
        hNSVersionKey = (HKEY) INVALID_HANDLE_VALUE;
        goto doneGetNetscapeImportVersion;
    }

    DWORD dwType;
    DWORD dwBufSize;
    dwBufSize = sizeof(DWORD);
    if( RegQueryValueEx( hNSVersionKey, NS_COOKIE_IMPORT_VERSION, 0, &dwType, (BYTE*)pNSVersion, &dwBufSize) != ERROR_SUCCESS
        || dwType != REG_DWORD)
    {
        goto doneGetNetscapeImportVersion;
    }

    //  if the "DisableImport" key has been set to a non-FALSE value,
    //fail to find a version to import from.
    DWORD fDontImport;
    if( (RegQueryValueEx( hNSVersionKey, NS_COOKIE_IMPORT_FLAG, 0, &dwType,
                        (BYTE*)&fDontImport, &(dwBufSize = sizeof(fDontImport)))
           == ERROR_SUCCESS)
        && dwType == REG_DWORD
        && fDontImport != FALSE)
    {
        goto doneGetNetscapeImportVersion;
    }

    retVal = TRUE;

doneGetNetscapeImportVersion:
    if( hNSVersionKey != (HKEY) INVALID_HANDLE_VALUE )
        REGCLOSEKEY( hNSVersionKey);

    return retVal;

}


//***************************************************************************
//  utility functions internal to cookimp.cxx


//  indicates if a character is an endofline character in a Netscape cookie file.
bool EndOfLine( CHAR chr )
{
    return chr == '\n' || chr == '\r';
}


//--------------------------------------------------------------------
//
//  InternetTimeFromTime_tA
//

//  InternetTimeFromTime_T takes a time value formatted to the run-time library's time_t
//and gives a formatted time string formatted to the RFC format in HTTP spec 1.0
//
//  dwTime is the number of seconds since Jan 1, 1970 00:00:00.
BOOL InternetTimeFromTime_tA( IN DWORD dwTime, OUT LPSTR lpszTime, DWORD cbBufferSize )
{
    if( cbBufferSize < INTERNET_RFC1123_BUFSIZE )
        return false;

//    FILETIME ft2;
//    DosTime2FileTime( dwTime, &ft2);

    //  First create a FILETIME value, to convert to SYSTEMTIME.

    //  i19700Offset is the FILETIME offset of Jan 1, 1970 at 00:00:00...
    const DWORDLONG dwl1970Offset = 0x019dae9064bafa80;

    DWORDLONG dwlTime = dwl1970Offset + (DWORDLONG)dwTime * (DWORDLONG)10000000;
    FILETIME ft;
    ft.dwLowDateTime  = (DWORD)( dwlTime & 0x00000000FFFFFFFF);
    ft.dwHighDateTime = (DWORD)Int64ShrlMod32( Int64ShrlMod32( dwlTime & 0xFFFFFFFF00000000, 16), 16 );

    //  Second I convert the FILETIME to a SYSTEMTIME   
    SYSTEMTIME st;

    if( FileTimeToSystemTime( &ft, &st ) == 0)
        return FALSE;

#ifdef UNICODE
#error "InternetTimeFromTime_tA(): InternetTimeFromSystemTimeA needs to be called directly from here."
#endif
    //  Finally I use SYSTEMTIME to produce the formatted string.
    return InternetTimeFromSystemTime( &st, INTERNET_RFC1123_FORMAT, lpszTime, cbBufferSize );
}


//--------------------------------------------------------------------
//
//  ReadFileToBuffer
//

//  opens a file and spits it out to memory.
//  if *ppBuf originally points to NULL, memory is allocated for the file
//      and cbBufSize contains the number of bytes allocated.
//      (use delete [] *ppBuf when done)
//  if *ppBuf is not NULL, it is assumed to point to a target buffer of
//      size *lpcbBufSize, and size used is then recorded in *lpcbBufSize.
//  returns TRUE if successful.
//  on FALSE return, *lpcbBufSize contains the size needed to be allocated
//      or 0xFFFFFFFF on total failure
BOOL ReadFileToBuffer( IN LPCTSTR szFilename, LPBYTE* ppBuf, LPDWORD lpcbBufSize)
{
    BOOL retVal = FALSE;

    HANDLE hFile = INVALID_HANDLE_VALUE;

    hFile = CreateFile( szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);

    if( hFile == INVALID_HANDLE_VALUE )
    {
        //  notify failure and exit
        *lpcbBufSize = 0xFFFFFFFF;
        goto doneReadFileToBuffer;
    }

    DWORD dwHighOrderedBitsOfFileSize;
    DWORD cbFileSize;
    cbFileSize = GetFileSize( hFile, &dwHighOrderedBitsOfFileSize );
    if(  cbFileSize == 0xFFFFFFFF || dwHighOrderedBitsOfFileSize != 0 )
    {
        //  notify file was too big and exit
        *lpcbBufSize = 0xFFFFFFFF;
        goto doneReadFileToBuffer;
    }

    if( *ppBuf != NULL )
    {
        //  verify passed buffer is large enough
        if( *lpcbBufSize < cbFileSize)
        {
            //  set needed filesize and exit
            *lpcbBufSize = cbFileSize;
            goto doneReadFileToBuffer;
        }
    }
    else
    {
        *ppBuf = new BYTE[cbFileSize];

        if( *ppBuf == NULL)
        {
            //  notify failure and exit
            *lpcbBufSize = 0xFFFFFFFF;
            goto doneReadFileToBuffer;
        }
    }

    //  set output result
    *lpcbBufSize = cbFileSize;

    DWORD cbRead;
    if( ReadFile( hFile, *ppBuf, cbFileSize, &cbRead, NULL) != TRUE
        || cbRead != cbFileSize)
    {
        //  notify failure and exit
        *lpcbBufSize = 0xFFFFFFFF;
        goto doneReadFileToBuffer;
    }

    CloseHandle( hFile );
    hFile = INVALID_HANDLE_VALUE;

    retVal = TRUE;

doneReadFileToBuffer:

    if( hFile != INVALID_HANDLE_VALUE)
        CloseHandle( hFile);

    return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\globals.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains global data items for WININET.DLL and initialization function

    Contents:
        GlobalDllInitialize
        GlobalDllTerminate
        GlobalDataInitialize
        GlobalTruncateFileName;
        GlobalDataTerminate
        IsHttp1_1
        IsOffline
        SetOfflineUserState
        FetchLocalStrings
        GetWininetUserName
        ChangeGlobalSettings
        RefreshOfflineFromRegistry
        PerformStartupProcessing

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

    07-Oct-1998 joshco
        updated minor version number 1->2

--*/

#include <wininetp.h>
#include <ntverp.h>
#include <autodial.h>       // InitAutodialModule, ExitAutodialModule
#include <schnlsp.h>
#include <persist.h>

//
// WinInet major & minor versions - allow to be defined externally
//

// JOSHCO

#if !defined(WININET_MAJOR_VERSION)
#define WININET_MAJOR_VERSION   1
#endif
#if !defined(WININET_MINOR_VERSION)
#define WININET_MINOR_VERSION   2
#endif

//
// external functions
//

void RefreshP3PSettings();

STDAPI_(void) UrlZonesDetach (void);

#if INET_DEBUG

VOID
InitDebugSock(
    VOID
    );

#endif

//
// private prototypes
//

#if defined(SITARA)

PRIVATE
VOID
OpenIeMainKey(
    VOID
    );

PRIVATE
VOID
CloseIeMainKey(
    VOID
    );

PRIVATE
BOOL
CheckABS(
    VOID
    );

PRIVATE
BOOL
ReadIeMainDwordValue(
    IN LPSTR pszValueName,
    OUT LPDWORD pdwValue
    );

#endif // SITARA

//
// global DLL state data
//

GLOBAL HINSTANCE GlobalDllHandle = NULL;
GLOBAL DWORD GlobalPlatformType;
GLOBAL DWORD GlobalPlatformVersion5;
GLOBAL DWORD GlobalPlatformMillennium = FALSE;
GLOBAL DWORD GlobalPlatformWhistler = FALSE;
GLOBAL DWORD GlobalDllState = INTERNET_STATE_ONLINE | INTERNET_STATE_IDLE;
GLOBAL BOOL GlobalDataInitialized = FALSE;
GLOBAL BOOL  GlobalTruncateFileName = FALSE;

//
// WinInet DLL version information (mainly for diagnostics)
//

#if INET_DEBUG

GLOBAL DWORD InternetMajorVersion = 1;
GLOBAL DWORD InternetMinorVersion = 0;

#endif // INET_DEBUG

#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

GLOBAL DWORD InternetBuildNumber = VER_PRODUCTBUILD;

//
// transport-based time-outs, etc.
//

//GLOBAL DWORD GlobalConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
#ifndef unix
GLOBAL DWORD GlobalConnectTimeout = 5 * 60 * 1000;
#else
GLOBAL DWORD GlobalConnectTimeout = 1 * 60 * 1000;
#endif /* unix */
GLOBAL DWORD GlobalConnectRetries = DEFAULT_CONNECT_RETRIES;
GLOBAL DWORD GlobalSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL DWORD GlobalReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL DWORD GlobalDataSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL DWORD GlobalDataReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL DWORD GlobalFromCacheTimeout = (DWORD)-1;
GLOBAL DWORD GlobalFtpAcceptTimeout = DEFAULT_FTP_ACCEPT_TIMEOUT;
GLOBAL DWORD GlobalTransportPacketLength = DEFAULT_TRANSPORT_PACKET_LENGTH;
GLOBAL DWORD GlobalKeepAliveSocketTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;
GLOBAL DWORD GlobalSocketSendBufferLength = DEFAULT_SOCKET_SEND_BUFFER_LENGTH;
GLOBAL DWORD GlobalSocketReceiveBufferLength = DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH;
GLOBAL DWORD GlobalMaxHttpRedirects = DEFAULT_MAX_HTTP_REDIRECTS;
GLOBAL DWORD GlobalMaxConnectionsPerServer = DEFAULT_MAX_CONNECTIONS_PER_SERVER;
GLOBAL DWORD GlobalMaxConnectionsPer1_0Server = DEFAULT_MAX_CONS_PER_1_0_SERVER;
GLOBAL DWORD GlobalConnectionInactiveTimeout = DEFAULT_CONNECTION_INACTIVE_TIMEOUT;
GLOBAL DWORD GlobalServerInfoTimeout = DEFAULT_SERVER_INFO_TIMEOUT;
GLOBAL const DWORD GlobalMaxSizeStatusLineResultText = 1024;
GLOBAL BOOL  GlobalHaveInternetOpened = FALSE;
GLOBAL BOOL  GlobalBypassEditedEntry = FALSE;

GLOBAL DWORD GlobalCacheMode = 0;

//GLOBAL DWORD GlobalServerInfoAllocCount = 0;
//GLOBAL DWORD GlobalServerInfoDeAllocCount = 0;

//
// async worker thread variables
//

//GLOBAL DWORD GlobalMinimumWorkerThreads = DEFAULT_MINIMUM_THREADS;
//GLOBAL DWORD GlobalMaximumWorkerThreads = DEFAULT_MAXIMUM_THREADS;
//GLOBAL DWORD GlobalInitialWorkerThreads = DEFAULT_INITIAL_THREADS;
//GLOBAL DWORD GlobalWorkerThreadIdleTimeout = DEFAULT_THREAD_IDLE_TIMEOUT;
//GLOBAL DWORD GlobalWorkQueueLimit = DEFAULT_WORK_QUEUE_LIMIT;
GLOBAL DWORD GlobalWorkerThreadTimeout = DEFAULT_WORKER_THREAD_TIMEOUT;

GLOBAL BOOL g_bHibernating = FALSE;
GLOBAL BOOL g_bDisableHibernation = FALSE;
//
// switches
//

GLOBAL BOOL InDllCleanup = FALSE;
GLOBAL BOOL GlobalPleaseQuitWhatYouAreDoing = FALSE;
GLOBAL BOOL GlobalDynaUnload = FALSE;
GLOBAL BOOL GlobalDisableKeepAlive = FALSE;
GLOBAL BOOL GlobalDisablePassport = FALSE;
GLOBAL BOOL GlobalEnableHttp1_1 = FALSE;
GLOBAL BOOL GlobalEnableProxyHttp1_1 = FALSE;
GLOBAL BOOL GlobalDisableReadRange = FALSE;
GLOBAL BOOL GlobalEnableGopher = FALSE;

//GLOBAL BOOL GlobalAutoProxyInDeInit = FALSE;
GLOBAL BOOL GlobalIsProcessExplorer = FALSE;
#ifndef UNIX
GLOBAL BOOL GlobalEnableFortezza = TRUE;
#else /* for UNIX */
GLOBAL BOOL GlobalEnableFortezza = FALSE;
#endif /* UNIX */

#if defined(SITARA)

GLOBAL BOOL GlobalEnableSitara = FALSE;
GLOBAL BOOL GlobalHasSitaraModemConn = FALSE;

#endif // SITARA

GLOBAL BOOL GlobalEnableUtf8Encoding = FALSE;
GLOBAL BOOL GlobalEnableRevocation = FALSE;

// SSL Switches  (petesk 7/24/97)
GLOBAL DWORD GlobalSecureProtocols  = DEFAULT_SECURE_PROTOCOLS;

GLOBAL DWORD GlobalSslStateCount = 0;

//
// AutoDetect Proxy Globals
//

GLOBAL LONG GlobalInternetOpenHandleCount = -1;
GLOBAL DWORD GlobalProxyVersionCount = 0;
GLOBAL BOOL GlobalAutoProxyNeedsInit = FALSE;
GLOBAL BOOL GlobalAutoProxyInInit = FALSE;
GLOBAL BOOL GlobalAutoProxyCacheEnable = TRUE;
GLOBAL BOOL GlobalDisplayScriptDownloadFailureUI = FALSE;

GLOBAL BOOL GlobalSendUTF8ServerToProxy = TRUE;
GLOBAL BOOL GlobalMBCSAPIforCrack = TRUE;
GLOBAL BOOL GlobalUseUTF8ServerForNameRes = FALSE;

//
//  Workaround for Novell's Client32
//

GLOBAL BOOL fDontUseDNSLoadBalancing = FALSE;

//
// Workaround for slow RAS enumeration
//
GLOBAL BOOL GlobalDisableNT4RasCheck = FALSE;
GLOBAL BOOL GlobalUseLanSettings = FALSE;

GLOBAL BOOL GlobalSendExtraCRLF = TRUE;

//Ftp time checking
GLOBAL BOOL  GlobalBypassFtpTimeCheck = FALSE;

//
// lists
//

GLOBAL SERIALIZED_LIST GlobalObjectList = {0};
GLOBAL SERIALIZED_LIST GlobalServerInfoList = {0};

//
// cache timeouts
//

GLOBAL LONGLONG dwdwHttpDefaultExpiryDelta = 12 * 60 * 60 * (LONGLONG)10000000;  // 12 hours in 100ns units
GLOBAL LONGLONG dwdwFtpDefaultExpiryDelta = 24 * 60 * 60 * (LONGLONG)10000000;  // 24 hours in 100ns units
GLOBAL LONGLONG dwdwGopherDefaultExpiryDelta = 24 * 60 * 60 * (LONGLONG)10000000;  // 24 hours in 100ns units
GLOBAL LONGLONG dwdwSessionStartTime;
GLOBAL LONGLONG dwdwSessionStartTimeDefaultDelta = 0;

GLOBAL DWORD GlobalUrlCacheSyncMode = WININET_SYNC_MODE_DEFAULT;
GLOBAL DWORD GlobalDiskUsageLowerBound = (4*1024*1024);
GLOBAL DWORD GlobalScavengeFileLifeTime = (10*60);

GLOBAL LPSTR vszMimeExclusionList=NULL, vszHeaderExclusionList=NULL;

GLOBAL LPSTR *lpvrgszMimeExclusionTable=NULL, *lpvrgszHeaderExclusionTable=NULL;

GLOBAL DWORD *lpvrgdwMimeExclusionTableOfSizes=NULL;

GLOBAL DWORD vdwMimeExclusionTableCount=0, vdwHeaderExclusionTableCount=0;

//
// SSL globals, for UI.  We need to know
//  whether its ok for us to pop up UI.
//
//

GLOBAL BOOL GlobalWarnOnPost = FALSE;
GLOBAL BOOL GlobalWarnAlways = FALSE;
GLOBAL BOOL GlobalWarnOnZoneCrossing = TRUE;
GLOBAL BOOL GlobalWarnOnBadCertSending = FALSE;
GLOBAL BOOL GlobalWarnOnBadCertRecving = TRUE;
GLOBAL BOOL GlobalDisableSslCaching = FALSE;
GLOBAL BOOL GlobalWarnOnPostRedirect = TRUE;
GLOBAL BOOL GlobalAlwaysDrainOnRedirect = FALSE;

GLOBAL SECURITY_CACHE_LIST GlobalCertCache;

GLOBAL DWORD GlobalSettingsVersion=0; // crossprocess settings versionstamp
GLOBAL BOOL GlobalSettingsLoaded = FALSE;

GLOBAL const char vszSyncMode[] = "SyncMode5";

GLOBAL const char vszDisableSslCaching[] = "DisableCachingOfSSLPages";
GLOBAL BOOL GlobalDisableNTLMPreAuth = FALSE;

GLOBAL char vszCurrentUser[MAX_PATH];
GLOBAL DWORD vdwCurrentUserLen = 0;

//
// critical sections
//

GLOBAL CRITICAL_SECTION AutoProxyDllCritSec = {0};
GLOBAL CRITICAL_SECTION LockRequestFileCritSec = {0};
GLOBAL CRITICAL_SECTION ZoneMgrCritSec = {0};
GLOBAL CRITICAL_SECTION MlangCritSec  = {0};


// cookies info

GLOBAL BOOL vfPerUserCookies = TRUE;
const char  vszAnyUserName[]="anyuser";
const char  vszPerUserCookies[] = "PerUserCookies";
const char  vszInvalidFilenameChars[] = "<>\\\"/:|?*";

GLOBAL BOOL GlobalLeashLegacyCookies = TRUE;
const char vszLeashLegacyCookies[] = REGSTR_LEASH_LEGACY_COOKIES;

// Hard-coded user agent string
// Update for each different version of IE 
#if defined(UNIX)
const char gszDefaultUserAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; X11)";
#elif defined(_WIN64)
const char gszDefaultUserAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; Win64)";
#else
const char gszDefaultUserAgent[] = "Mozilla/4.0 (compatible; MSIE 6.0; Win32)";
#endif




// Mlang related data and functions.
PRIVATE HINSTANCE hInstMlang;
PRIVATE PFNINETMULTIBYTETOUNICODE pfnInetMultiByteToUnicode;
PRIVATE BOOL bFailedMlangLoad;  // So we don't try repeatedly if we fail once.
BOOL LoadMlang( );
BOOL UnloadMlang( );
#define MLANGDLLNAME    "mlang.dll"


// shfolder.dll hmod handle
HMODULE g_HMODSHFolder = NULL;
// Shell32.dll hmod handle
HMODULE g_HMODShell32 = NULL;

GLOBAL CUserName GlobalUserName;

//
// novell client32 (hack) "support"
//

GLOBAL BOOL GlobalRunningNovellClient32 = FALSE;
GLOBAL BOOL GlobalNonBlockingClient32 = FALSE;

//
// private data
//

HANDLE g_hAutodialMutex = NULL;

//
// proxy info
//

GLOBAL PROXY_INFO_GLOBAL GlobalProxyInfo;

//
// DLL version info
//

GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WININET_MAJOR_VERSION,
    WININET_MINOR_VERSION
};

//
// HTTP version info - default 1.0
//

GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 0};


GLOBAL BOOL fCdromDialogActive = FALSE;
GLOBAL DWORD g_dwCredPersistAvail = CRED_PERSIST_UNKNOWN;

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

GLOBAL char gszAt[]   = "@";
GLOBAL char gszBang[] = "!";
GLOBAL char gszCRLF[] = "\r\n";


extern GLOBAL SERIALIZED_LIST BlockedRequestQueue;


// Identity-related globals
GLOBAL DWORD GlobalIdentity = 0;
GLOBAL GUID  GlobalIdentityGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
GLOBAL BOOL GlobalSuppressCookiesPolicy = FALSE;
#ifdef WININET6
GLOBAL HKEY GlobalCacheHKey = HKEY_CURRENT_USER;
#endif

GLOBAL PTSTR GlobalSpecialDomains = NULL;
GLOBAL PTSTR *GlobalSDOffsets = NULL;

// auth globals

DWORD GlobalEnableNegotiate = FALSE;


// Nt service loading wininet. This triggers special semantics for webdav redir to avoid deadlocks
// due to crossprocessmutexes being taken (ConnectionMutex is a good example of that)
// (Shishir Pardikar)

GLOBAL BOOL GlobalIsProcessNtService = FALSE;

// Global Cred hack for Mars V2

XSTRING g_xsUser;
XSTRING g_xsPass;

// Begin (a-thkesa)
// The following global added to read expire time value from registry:Default is 30 Min
// See Windows Bug:557284/WinSE:23879 
// Declared in proxysup.hxx
GLOBAL DWORD GlobalBadProxyExpiresTime = 30*60; // this will be multiplied 
// End(a-thkesa)  

BOOL       g_fHasCredsTimestamp;
SYSTEMTIME g_TimeCredsEntered;

void SetUserOrPass (LPSTR lpszIn, BOOL fUser) {
    XSTRING *xs = fUser? &g_xsUser: &g_xsPass;
    xs->SetData(lpszIn);
}

void TimeStampCreds(void) 
{
    ::GetSystemTime(&g_TimeCredsEntered); // time-stamp the creds
    g_fHasCredsTimestamp = TRUE;
}

PSYSTEMTIME GetCredTimeStamp (void) 
{
    if (g_fHasCredsTimestamp)
    {
        return &g_TimeCredsEntered;
    } 
    else 
    {
        return NULL;
    }
}

BOOL GetUserAndPass (LPSTR *pszUser, LPSTR *pszPass)
{
    if (g_xsUser.GetPtr()
        && g_xsPass.GetPtr())
    {
        *pszUser = g_xsUser.GetPtr();
        *pszPass = g_xsPass.GetPtr();
        return TRUE;
    }

    *pszUser = *pszPass = NULL;
    return FALSE;
}

//
// functions
//


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllInitialize(
    VOID
    )

/*++

Routine Description:

    The set of initializations - critical sections, etc. - that must be done at
    DLL_PROCESS_ATTACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllInitialize",
                 NULL
                 ));

    CLEAR_DEBUG_CRIT(szDebugBlankBuffer);

    GetCurrentGmtTime((LPFILETIME)&dwdwSessionStartTime);

    InitializeCriticalSection(&AutoProxyDllCritSec);
    InitializeCriticalSection(&LockRequestFileCritSec);
    InitializeCriticalSection(&ZoneMgrCritSec);
    InitializeCriticalSection(&MlangCritSec);


    InitializeSerializedList(&GlobalObjectList);
    InitializeSerializedList(&GlobalServerInfoList);
    InitializeSerializedList(&BlockedRequestQueue);

    AuthOpen();

    IwinsockInitialize();
    SecurityInitialize();
    FtpInitialize();
    GopherInitialize();

    //
    // initialize cache critical sections etc.
    //

    DLLUrlCacheEntry(DLL_PROCESS_ATTACH);

    EnsureInternetSettingsKeyCached();

    DEBUG_LEAVE(0);
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes the initializations of GlobalDllInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllTerminate",
                 NULL
                 ));

    //
    // only perform resource clean-up if this DLL is being unloaded due to a
    // FreeLibrary() call. Otherwise, we take the lazy way out and let the
    // system clean up after us
    //

    if (GlobalDynaUnload) {
        TerminateAsyncSupport();
        GopherTerminate();
        FtpTerminate();
        IwinsockTerminate();
        HandleTerminate();
    }

    CHECK_SOCKETS();

    AuthClose();

    TerminateSerializedList(&BlockedRequestQueue);
    TerminateSerializedList(&GlobalServerInfoList);

    //
    //BUGBUG: we can't Terminate the list here because
    //        of a race condition from IE3
    //        (someone still holds the handle)
    //        but we don't want to leak the CritSec
    //        TerminateSerlizedList == DeleteCritSec + some Asserts
    //
    //TerminateSerializedList(&GlobalObjectList);
    DeleteCriticalSection(&(GlobalObjectList.Lock));


    DeleteCriticalSection(&MlangCritSec);
    DeleteCriticalSection(&ZoneMgrCritSec);
    DeleteCriticalSection(&LockRequestFileCritSec);
    DeleteCriticalSection(&AutoProxyDllCritSec);

    DLLUrlCacheEntry(DLL_PROCESS_DETACH);

    SecurityTerminate();

    if (g_HMODSHFolder)
    {
        FreeLibrary(g_HMODSHFolder);
        g_HMODSHFolder = NULL;
    }
    if (g_HMODShell32)
    {
        FreeLibrary(g_HMODShell32);
        g_HMODShell32 = NULL;
    }
    
    CloseInternetSettingsKey();

    DEBUG_LEAVE(0);
}


DWORD
GlobalDataInitialize(
    VOID
    )

/*++

Routine Description:

    Loads any global data items from the registry

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "GlobalDataInitialize",
                 NULL
                 ));

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    static DWORD error = ERROR_SUCCESS;
    
    //
    // only one thread initializes
    //

    if (InterlockedExchange((LPLONG)&Initializing, TRUE)) {
        while (!Initialized) {
            SleepEx(0, TRUE);
        }
        goto done;
    }

    //
    // we ignore any failure return codes from reading the registry. All the
    // global variables are initialized to default values
    //

    //
    // UseSchannelDirectly - TRUE if we are to bypass SSPI "Secur32/Security"
    //      and directly call into SCHANNEL.  This should give us a perf
    //      improvement since we don't have to load an extra DLL.
    //

    g_fHasCredsTimestamp = FALSE;

//
// BUGBUG - all these need to be per-process. They are intended for IE
//
    memset(&GlobalIdentityGuid, 0, sizeof(GlobalIdentityGuid));

    InternetReadRegistryDword("FromCacheTimeout",
                              (LPDWORD)&GlobalFromCacheTimeout
                              );

    //InternetReadRegistryDword("UseSchannelDirectly",
    //                          (LPDWORD)&GlobalUseSchannelDirectly
    //                          );

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("SecureProtocols",
                              (LPDWORD)&GlobalSecureProtocols
                              );

    // also in ChangeGlobalSettings()
    if (!GlobalPlatformWhistler)
    {
        // Fortezza support has been removed from XP
        InternetReadRegistryDword("Fortezza",
                                  (LPDWORD)&GlobalEnableFortezza
                                  );
    }
    else
    {
        GlobalEnableFortezza = FALSE;
    }

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("CertificateRevocation",
                              (LPDWORD)&GlobalEnableRevocation
                              );

    InternetReadRegistryDword("DisableKeepAlive",
                              (LPDWORD)&GlobalDisableKeepAlive
                              );

    InternetReadRegistryDword("DisablePassport",
                          (LPDWORD)&GlobalDisablePassport
                          );

    InternetReadRegistryDword("CacheMode", (LPDWORD) &GlobalCacheMode);

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("EnableHttp1_1",
                              (LPDWORD)&GlobalEnableHttp1_1
                              );

    // also in ChangeGlobalSettings()
    InternetReadRegistryDword("ProxyHttp1.1",
                              (LPDWORD)&GlobalEnableProxyHttp1_1
                              );

    DWORD dwEnableNegotiate = -1;
    InternetReadRegistryDword("EnableNegotiate",
                      (LPDWORD)&dwEnableNegotiate
                      );
    if (dwEnableNegotiate != -1)
    {
        // the value is present in the registy, so we honor it.
        GlobalEnableNegotiate = dwEnableNegotiate;
    }
    else
    {
        if (GlobalPlatformWhistler && !IsInGUIModeSetup())
        {
            // the value is abscent in Whistler, we'll need to turn set the value to 1
            InternetWriteRegistryDword("EnableNegotiate", 1);
            GlobalEnableNegotiate = TRUE;
        }
    }


    GetUrlCacheHeaderData(CACHE_HEADER_DATA_DOWNLOAD_PARTIAL, &GlobalSslStateCount);


    DWORD dwType, dwSize;

    dwSize = sizeof(DWORD);

    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "EnableAutoProxyResultCache", &dwType, &GlobalAutoProxyCacheEnable, &dwSize);

    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "DisplayScriptDownloadFailureUI", &dwType, &GlobalDisplayScriptDownloadFailureUI, &dwSize);

    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "MBCSServername", &dwType, &GlobalSendUTF8ServerToProxy, &dwSize);
    
    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "MBCSAPIforCrack", &dwType, &GlobalMBCSAPIforCrack, &dwSize);

    dwSize = sizeof(DWORD);
    SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
        "UTF8ServerNameRes", &dwType, &GlobalUseUTF8ServerForNameRes, &dwSize);

    //Read DisableWorkerThreadHibernation from HKLM first and allow HKCU override.
    InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                 "DisableWorkerThreadHibernation",
                                 (LPDWORD)&g_bDisableHibernation
                                 );
    InternetReadRegistryDword("DisableWorkerThreadHibernation",
                              (LPDWORD)&g_bDisableHibernation
                              );
                              
    GlobalUseUTF8ServerForNameRes = GlobalUseUTF8ServerForNameRes 
                            && GlobalSendUTF8ServerToProxy;
                              
    InternetReadRegistryDword("DisableReadRange",
                              (LPDWORD)&GlobalDisableReadRange
                              );

    InternetReadRegistryDword("SocketSendBufferLength",
                              &GlobalSocketSendBufferLength
                              );

    InternetReadRegistryDword("SocketReceiveBufferLength",
                              &GlobalSocketReceiveBufferLength
                              );

    InternetReadRegistryDword("KeepAliveTimeout",
                              &GlobalKeepAliveSocketTimeout
                              );

    InternetReadRegistryDword("MaxHttpRedirects",
                              &GlobalMaxHttpRedirects
                              );

    InternetReadRegistryDword("MaxConnectionsPerServer",
                              &GlobalMaxConnectionsPerServer
                              );

    InternetReadRegistryDword("MaxConnectionsPer1_0Server",
                              &GlobalMaxConnectionsPer1_0Server
                              );

    InternetReadRegistryDword("ServerInfoTimeout",
                              &GlobalServerInfoTimeout
                              );

    InternetReadRegistryDword("ReceiveTimeOut",
                              (LPDWORD)&GlobalReceiveTimeout
                              );

    InternetReadRegistryDword("DisableNTLMPreAuth",
                              (LPDWORD)&GlobalDisableNTLMPreAuth
                              );

    InternetReadRegistryDword("ScavengeCacheLowerBound",
                              (LPDWORD)&GlobalDiskUsageLowerBound
                              );

    InternetCacheReadRegistryDword("ScavengeCacheFileLifeTime",
                              (LPDWORD)&GlobalScavengeFileLifeTime
                              );

    DWORD dwDefTime;

    if (InternetReadRegistryDword("HttpDefaultExpiryTimeSecs", &dwDefTime) ==
            ERROR_SUCCESS) {
        dwdwHttpDefaultExpiryDelta = dwDefTime * (LONGLONG)10000000;
    }

    if (InternetReadRegistryDword("FtpDefaultExpiryTimeSecs", &dwDefTime) ==
            ERROR_SUCCESS) {
        dwdwFtpDefaultExpiryDelta = dwDefTime * (LONGLONG)10000000;
    }

    if (InternetReadRegistryDword("GopherDefaultExpiryTimeSecs", &dwDefTime) ==
            ERROR_SUCCESS) {
        dwdwGopherDefaultExpiryDelta = dwDefTime * (LONGLONG)10000000;
    }

    InternetReadRegistryDword(vszDisableSslCaching, (LPDWORD)&GlobalDisableSslCaching);

    InternetReadRegistryDword(vszPerUserCookies, (LPDWORD)&vfPerUserCookies);

    InternetReadRegistryDword(vszLeashLegacyCookies, (LPDWORD)&GlobalLeashLegacyCookies);

    InternetReadRegistryDword("DisableNT4RasCheck", (LPDWORD)&GlobalDisableNT4RasCheck);
    InternetReadRegistryDword("DialupUseLanSettings", (LPDWORD)&GlobalUseLanSettings);

    InternetReadRegistryDword("SendExtraCRLF", (LPDWORD)&GlobalSendExtraCRLF);
    InternetReadRegistryDword("BypassFtpTimeCheck", (LPDWORD)&GlobalBypassFtpTimeCheck);

    InternetReadRegistryDword("EnableGopher", (LPDWORD)&GlobalEnableGopher);

    //
    //  fix for Novell's Client32 - zekel 23-jul-96
    //  first check HKLM then HKCU, HKCU takes precdence
    //

    InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                 "DontUseDNSLoadBalancing",
                                 (LPDWORD)&fDontUseDNSLoadBalancing
                                 );
    InternetReadRegistryDword("DontUseDNSLoadBalancing",
                              (LPDWORD) &fDontUseDNSLoadBalancing
                              );

    InternetReadRegistryDword("NonBlockingClient32",
                              (LPDWORD)&GlobalNonBlockingClient32
                              );

    //
    // Get the list of MIME types for which caching needs to be disabled
    //

    CreateMimeExclusionTableForCache();

    //
    // Get the list of headers that should be excluded from the cache
    //

    CreateHeaderExclusionTableForCache();


    DEBUG_PRINT(HTTP,
                INFO,
                ("Current wininet user is %s length %d\n",
                vszCurrentUser,
                vdwCurrentUserLen
                ));


    //
    // initialize databases
    //

    InitializeResolverCache();
    GlobalDataReadWarningUIFlags();

    PerformStartupProcessing();

    //
    // create the global keep-alive, cert-cache and proxy lists
    //

    GlobalCertCache.Initialize();
    GlobalProxyInfo.InitializeProxySettings();
    

    //LoadServerInfoDatabase();


    //
    // initialize offline mode from registry
    //

    RefreshOfflineFromRegistry();

    //
    // read the global (cache) settings version to avoid an unnecessary reload
    // N.B. we rely on the side effect of calling urlcache InitGlobals
    //
    InternetSettingsChanged();

    char buf[MAX_PATH + 1];

    if (GetModuleFileName(NULL, buf, sizeof(buf))) {
        LPSTR p = strrchr(buf, DIR_SEPARATOR_CHAR);
        p = p ? ++p : buf;

        DEBUG_PRINT(INET, INFO, ("process is %q\n", p));

        if (lstrcmpi(p, "EXPLORER.EXE") && lstrcmpi(p, "IEXPLORE.EXE")) {

            //
            // yet another app-hack: AOL's current browser can't understand
            // HTTP 1.1. When they do, they have to call InternetSetOption()
            // with INTERNET_OPTION_HTTP_VERSION
            //

            if (!lstrcmpi(p, "WAOL.EXE")) {
                GlobalEnableHttp1_1 = FALSE;
            }


            if (!lstrcmpi(p, "SVCHOST.EXE")     ||
                !lstrcmpi(p, "SERVICES.EXE")) {
                GlobalIsProcessNtService = TRUE;
            }
            
            //
            // non-IE app must supply this through option
            //

            GlobalFromCacheTimeout = (DWORD)-1;
        } else {
            GlobalIsProcessExplorer = TRUE;
        }
    } else {

        DEBUG_PRINT(INET,
                    INFO,
                    ("GetModuleFileName() returns %d\n",
                    GetLastError()
                    ));

    }

    

    //
    // initialize the autodial code
    //

    // NB!!! this has been moved AFTER the above app hack because it uses the GlobalIsProcessNtService
    // variable to decide whether to create a perprocess connection mutex or cross-process
    // (Shishir Pardikar)

    InitAutodialModule(FALSE);




#if defined(SITARA)

    //
    // check if Sitara is loaded (IE5B1). Existence of key means Sitara
    // installed
    //

    HKEY key;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     "Software\\Microsoft\\InternetExpressLane",
                     0,
                     KEY_QUERY_VALUE,
                     &key) == ERROR_SUCCESS) {
        REGCLOSEKEY(key);
        OpenIeMainKey();
        GlobalEnableSitara = CheckABS();
    }

#endif // SITARA

    DWORD urlEncoding;

    urlEncoding = 0;
    InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                 "UrlEncoding",
                                 &urlEncoding
                                 );
    if (urlEncoding == 0) {
        GlobalEnableUtf8Encoding = TRUE;
    }

    // File name truncate ?
    DWORD dwTruncateFileName;

    dwTruncateFileName = 0;
    InternetReadRegistryDword("TruncateFileName", &dwTruncateFileName);

    if (dwTruncateFileName != 0) 
        GlobalTruncateFileName = TRUE;

    //
    // perform module/package-specific initialization
    //

    error = HandleInitialize();
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // initalize the cookie system
    //

    if (!OpenTheCookieJar()) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // initialize the background task manager
    //
    if( !LoadBackgroundTaskMgr() ) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        //goto quit;
    }

	// Begin (a-thkesa) 
	// Read GlobalBadProxyExpiresTime value from the registry.
	  InternetReadRegistryDword("BadProxyExpiresTime", (LPDWORD)&GlobalBadProxyExpiresTime);
	// End (a-thkesa)


quit:

    //
    // finally, if EnableHttp1_1 was set to non-zero in the registry, enable
    // HTTP 1.1
    //

    if (GlobalEnableHttp1_1) {
        HttpVersionInfo.dwMajorVersion = 1;
        HttpVersionInfo.dwMinorVersion = 1;
    }

    if (error == ERROR_SUCCESS) {
        GlobalDataInitialized = TRUE;
    }

    //
    // irrespective of success or failure, we have attempted global data
    // initialization. If we failed then we assume its something fundamental
    // and fatal: we don't try again
    //

    Initialized = TRUE;

done:

    DEBUG_LEAVE(error);

    return error;
}


VOID
GlobalDataReadWarningUIFlags(
    VOID
    )

/*++

Routine Description:

    Reads Registry values into global data.
    Used to read read the registry on connects.

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataReadWarningUIFlags",
                 NULL
                 ));

#ifndef WININET6
    //
    // Load SSL Values from the Registry on whether to pop up UI on error.
    //

    InternetReadRegistryDword("WarnOnPost", (LPDWORD)&GlobalWarnOnPost);

    GlobalWarnAlways = FALSE;
    InternetReadRegistryDword("WarnAlwaysOnPost", (LPDWORD)&GlobalWarnAlways);

    //
    // If Global Warn On Post is set to "2" we reset the "WarnAlways" to TRUE,
    //  since this is the new way INETCPL reads/writes the registry.
    //

    if ( GlobalWarnOnPost == 2 )
    {
        GlobalWarnAlways = TRUE;
    }

    InternetReadRegistryDword("WarnOnZoneCrossing", (LPDWORD)&GlobalWarnOnZoneCrossing);

    InternetReadRegistryDword("WarnOnBadCertSending", (LPDWORD)&GlobalWarnOnBadCertSending);

    InternetReadRegistryDword("WarnOnBadCertRecving", (LPDWORD)&GlobalWarnOnBadCertRecving);

    InternetReadRegistryDword("WarnOnPostRedirect", (LPDWORD)&GlobalWarnOnPostRedirect);

    InternetReadRegistryDword("AlwaysDrainOnRedirect", (LPDWORD)&GlobalAlwaysDrainOnRedirect);
#else
    //
    // Load SSL Values from the Registry on whether to pop up UI on error.
    //

    InternetIDEReadRegistryDword("WarnOnPost", (LPDWORD)&GlobalWarnOnPost);

    GlobalWarnAlways = FALSE;
    InternetIDEReadRegistryDword("WarnAlwaysOnPost", (LPDWORD)&GlobalWarnAlways);

    //
    // If Global Warn On Post is set to "2" we reset the "WarnAlways" to TRUE,
    //  since this is the new way INETCPL reads/writes the registry.
    //

    if ( GlobalWarnOnPost == 2 )
    {
        GlobalWarnAlways = TRUE;
    }

    InternetIDEReadRegistryDword("WarnOnZoneCrossing", (LPDWORD)&GlobalWarnOnZoneCrossing);

    InternetIDEReadRegistryDword("WarnOnBadCertSending", (LPDWORD)&GlobalWarnOnBadCertSending);



    InternetIDEReadRegistryDword("WarnOnBadCertRecving", (LPDWORD)&GlobalWarnOnBadCertRecving);

    InternetIDEReadRegistryDword("WarnOnPostRedirect", (LPDWORD)&GlobalWarnOnPostRedirect);
#endif


    DEBUG_LEAVE(0);
}


VOID
GlobalDataTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes work of GlobalDataInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataTerminate",
                 NULL
                 ));

    //
    // Release background task manager
    //
    UnloadBackgroundTaskMgr();

    AuthUnload();
    UrlZonesDetach();

    TerminateResolverCache();
    CloseTheCookieJar();

    if (GlobalSpecialDomains)
    {
        delete [] GlobalSpecialDomains;
        delete [] GlobalSDOffsets;
    }
    
    //
    // destroy lists created from registry
    //

    DestroyMimeExclusionTableForCache();
    DestroyHeaderExclusionTableForCache();

    //
    // terminate the global cert-cache and proxy lists
    //

    GlobalCertCache.Terminate();
    GlobalProxyInfo.TerminateProxySettings();


    //SaveServerInfoDatabase();
    PurgeServerInfoList(TRUE);

    //TerminateAsyncSupport();

    //
    // free up the handle to the startup mutex
    //
    if (g_hAutodialMutex) {
        CloseHandle(g_hAutodialMutex);
    }

#if defined(SITARA)

    CloseIeMainKey();

#endif // SITARA

    UnloadMlang();
    UnloadSecurity();

    GlobalDataInitialized = FALSE;

    DEBUG_LEAVE(0);
}


BOOL
IsHttp1_1(
    VOID
    )

/*++

Routine Description:

    Determine if we are using HTTP 1.1 or greater

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    return (HttpVersionInfo.dwMajorVersion > 1)
            ? TRUE
            : (((HttpVersionInfo.dwMajorVersion == 1)
                && (HttpVersionInfo.dwMajorVersion >= 1))
                ? TRUE
                : FALSE);
}


BOOL
IsOffline(
    VOID
    )

/*++

Routine Description:

    Returns whether we are in (global) offline mode or not. We are offline if
    we went offline because of network failure, or we were put into offline
    mode by the user

Arguments:

    None.

Return Value:

    BOOL
        TRUE    - we are currently offline

        FALSE   - not offline

--*/

{
    DEBUG_ENTER((DBG_SESSION,
                 Bool,
                 "IsOffline",
                 NULL
                 ));

    INET_ASSERT(((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_ONLINE)
                || ((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE));
    INET_ASSERT((GlobalDllState & INTERNET_STATE_OFFLINE_USER)
                ? ((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE)
                : TRUE);

    BOOL offline = (GlobalDllState & (INTERNET_STATE_OFFLINE | INTERNET_STATE_OFFLINE_USER))
                    ? TRUE
                    : FALSE;

    DEBUG_LEAVE(offline);

    return offline;
}


DWORD
SetOfflineUserState(
    IN DWORD dwState,
    IN BOOL bForce
    )

/*++

Routine Description:

    If we are in online state, puts Wininet into user-induced offline mode. Stop
    all outstanding requests, if required and set the global scope. If we are in
    offline mode, then change state to online

Arguments:

    dwState - INTERNET_STATE_ONLINE or INTERNET_STATE_OFFLINE

    bForce  - TRUE if we are to forcibly complete all outstanding requests
              (including synchronous requests)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "SetOfflineUserState",
                 "%s (%d), %B",
                 (dwState == INTERNET_STATE_ONLINE) ? "INTERNET_STATE_ONLINE"
                 : (dwState == INTERNET_STATE_OFFLINE) ? "INTERNET_STATE_OFFLINE"
                 : "???",
                 dwState,
                 bForce
                 ));

    INET_ASSERT((dwState == INTERNET_STATE_ONLINE)
                || (dwState == INTERNET_STATE_OFFLINE));
    INET_ASSERT(((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_ONLINE)
                || ((GlobalDllState & INTERNET_LINE_STATE_MASK) == INTERNET_STATE_OFFLINE));

    DWORD error = ERROR_SUCCESS;

    if (dwState == INTERNET_STATE_OFFLINE) {
        GlobalDllState = (GlobalDllState & ~INTERNET_LINE_STATE_MASK)
                       | (INTERNET_STATE_OFFLINE | INTERNET_STATE_OFFLINE_USER);
        if (bForce) {
            //CancelActiveAsyncRequests(ERROR_INTERNET_OFFLINE);
            CancelActiveSyncRequests(ERROR_INTERNET_OFFLINE);
            GlobalProxyInfo.AbortAutoProxy();
        }
    } else {
        GlobalDllState = GlobalDllState
                       & ~(INTERNET_LINE_STATE_MASK | INTERNET_STATE_OFFLINE_USER)
                       | INTERNET_STATE_ONLINE;
    }

    DEBUG_PRINT(GLOBAL,
                INFO,
                ("GlobalDllState = %#x\n",
                GlobalDllState
                ));

    DEBUG_LEAVE(error);

    return error;
}


/*++

FetchLocalStrings:

    This routine fetches the strings necessary to display information in the
    language of the local user.

Arguments:

    None

Return Value:

    The address of a LOCAL_STRINGS structure containing the addresses of the
    localized strings to display.

Author:

    Doug Barlow (dbarlow) 4/25/1996

--*/
//
// WARNING!  The order of elements in the following array must match the
// order of elements in the LOCAL_STRINGS structure.
//

static const UINT
    uStringId[]
        = { IDS_LW95_ENTERAUTHINFO,
            IDS_SECERT_CERTINFO,
            IDS_SECERT_STRENGTH_HIGH,
            IDS_SECERT_STRENGTH_MEDIUM,
            IDS_SECERT_STRENGTH_LOW,
            IDS_CERT_SUBJECT,
            IDS_CERT_ISSUER,
            IDS_CERT_EFFECTIVE_DATE,
            IDS_CERT_EXPIRATION_DATE,
            IDS_CERT_PROTOCOL,
            IDS_CERT_USAGE,
            IDS_CERT_ENCRYPT_ALG,
            IDS_CERT_HASH_ALG,
            IDS_CERT_EXCH_ALG,
            IDS_CERT_COMMENT,
            IDS_COMMENT_EXPIRES,
            IDS_COMMENT_NOT_VALID,
            IDS_COMMENT_BAD_CN,
            IDS_COMMENT_BAD_CA,
            IDS_COMMENT_BAD_SIGNATURE,
            IDS_COMMENT_REVOKED,
            IDS_STRING_CIPHMSG,
            IDS_STRING_HASHMSG,
            IDS_STRING_EXCHMSG,
            IDS_CERT_FINGERPRINT,
            IDS_DOMAIN,
            IDS_REALM,
            IDS_SITE,
            IDS_FIREWALL
};

PLOCAL_STRINGS
FetchLocalStrings(
    void)
{

    static LOCAL_STRINGS
        lszStrings;
    static BOOL fInitialized = FALSE;

    INET_ASSERT(sizeof(uStringId) == offsetof(LOCAL_STRINGS, rgchBuffer));
    EnterCriticalSection(&GeneralInitCritSec);
    __try
    {
        if (!fInitialized)
        {
            LPWSTR szBufEntry;
            LPWSTR *pszName;
            DWORD dwOffset;
            DWORD index, len;


            //
            // It needs to be initialized.
            //

            pszName = (LPWSTR *)&lszStrings;
            dwOffset = 0;
            for (index = 0;
                 index < sizeof(uStringId) / sizeof(UINT);
                 index += 1)
            {
                szBufEntry = &lszStrings.rgchBuffer[dwOffset];
                len = LoadStringWrapW(
                            GlobalDllHandle,
                            uStringId[index],
                            szBufEntry,
                            LOCAL_STRINGS_MAX_BUFFER - dwOffset);
                INET_ASSERT(0 != len);  // Resource missing!
                dwOffset += len;
                lszStrings.rgchBuffer[dwOffset++] = 0;
                *pszName++ = szBufEntry;
            }

            INET_ASSERT(LOCAL_STRINGS_MAX_BUFFER > dwOffset);


            //
            // Make it available to this and future callers.
            //

            fInitialized = TRUE;
        }
    }
    __finally
    {
        LeaveCriticalSection(&GeneralInitCritSec);
    }
    ENDFINALLY
    return &lszStrings;
}

PLOCAL_STRINGSA
FetchLocalStringsA(
    void)
{
    static LOCAL_STRINGSA
        lszStrings;
    static BOOL fInitialized = FALSE;

    INET_ASSERT(sizeof(uStringId) == offsetof(LOCAL_STRINGSA, rgchBuffer));
    EnterCriticalSection(&GeneralInitCritSec);
    __try
    {
        if (!fInitialized)
        {
            LPSTR szBufEntry;
            LPSTR *pszName;
            DWORD dwOffset;
            DWORD index, len;


            //
            // It needs to be initialized.
            //

            pszName = (LPSTR *)&lszStrings;
            dwOffset = 0;
            for (index = 0;
                 index < sizeof(uStringId) / sizeof(UINT);
                 index += 1)
            {
                szBufEntry = &lszStrings.rgchBuffer[dwOffset];
                len = LoadStringA(
                            GlobalDllHandle,
                            uStringId[index],
                            szBufEntry,
                            LOCAL_STRINGS_MAX_BUFFER - dwOffset);
                INET_ASSERT(0 != len);  // Resource missing!
                dwOffset += len;
                lszStrings.rgchBuffer[dwOffset++] = 0;
                *pszName++ = szBufEntry;
            }

            INET_ASSERT(LOCAL_STRINGS_MAX_BUFFER > dwOffset);

            //
            // Make it available to this and future callers.
            //

            fInitialized = TRUE;
        }
    }
    __finally
    {
        LeaveCriticalSection(&GeneralInitCritSec);
    }
    ENDFINALLY
    return &lszStrings;
}

BOOL
GetWininetUserName(
    VOID
)
{
    BOOL fRet = FALSE;
    DWORD dwT;
    CHAR *ptr;

    // Note this critsect could be blocked for a while if RPC gets involved...
    EnterCriticalSection(&GeneralInitCritSec);

    if (vdwCurrentUserLen) {
        fRet = TRUE;
        goto Done;
    }

    dwT = sizeof(vszCurrentUser);

    if (vfPerUserCookies) {

        fRet = GetUserName(vszCurrentUser, &dwT);

        if (!fRet) {

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("GetUsername returns %d\n",
                        GetLastError()
                        ));
        }

    }

    if (fRet == FALSE){

        strcpy(vszCurrentUser, vszAnyUserName);

        fRet = TRUE;
    }

    // Downcase the username.
    ptr = vszCurrentUser;
    while (*ptr)
    {
        /* BUGBUG: This logic mangles the user name when 
                   there are multi-byte characters.
           Unfortunately fixing it would lose legacy cookies so the 
           fix had to be backed out.
           The correct code is commented out below. */

        *ptr = tolower(*ptr);
        ptr++;

        // if (!IsDBCSLeadByte(*ptr))
        //    *ptr = tolower(*ptr);
        // ptr = CharNextExA(CP_ACP, ptr, 0);
    }

    INET_ASSERT(fRet == TRUE);

    vdwCurrentUserLen = (DWORD) (ptr - vszCurrentUser);


Done:
    LeaveCriticalSection(&GeneralInitCritSec);
    return (fRet);
}


VOID
ChangeGlobalSettings(
    VOID
    )

/*++

Routine Description:

    Changes global settings

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "ChangeGlobalSettings",
                 NULL
                 ));

    InternetReadRegistryDword(vszSyncMode,
                              &GlobalUrlCacheSyncMode
                              );

    InternetReadRegistryDword(vszDisableSslCaching,
                              (LPDWORD)&GlobalDisableSslCaching
                              );

    InternetReadRegistryDword("EnableHttp1_1",
                              (LPDWORD)&GlobalEnableHttp1_1
                              );

    InternetReadRegistryDword("ProxyHttp1.1",
                              (LPDWORD)&GlobalEnableProxyHttp1_1
                              );

    InternetReadRegistryDword(vszPerUserCookies,
                              (LPDWORD)&vfPerUserCookies
                              );

    InternetReadRegistryDword(vszLeashLegacyCookies, (LPDWORD)&GlobalLeashLegacyCookies);

    if (!GlobalProxyInfo.IsModifiedInProcess())
    {
        FixProxySettingsForCurrentConnection(
            FALSE
            );
    }

    //
    // update security protocol changes.
    //

    InternetReadRegistryDword("SecureProtocols",
                          (LPDWORD)&GlobalSecureProtocols
                          );

    if (!GlobalPlatformWhistler)
    {
        // Fortezza support has been removed from XP
        InternetReadRegistryDword("Fortezza",
                                  (LPDWORD)&GlobalEnableFortezza
                                  );
    }
    else
    {
        GlobalEnableFortezza = FALSE;
    }

    InternetReadRegistryDword("CertificateRevocation",
                              (LPDWORD)&GlobalEnableRevocation
                              );

    //
    // Check autodial settings and hang up if autodial was turned off
    //

    // have autodial module reset itself
    ResetAutodialModule();

    RefreshOfflineFromRegistry();

    // force reload of cookie-settings from registry by flushing memory cache
    RefreshP3PSettings();

    DEBUG_LEAVE(0);
}


VOID
RefreshOfflineFromRegistry(
    VOID
    )

/*++

Routine Description:

    Reads offline setting in the registry and sets wininet's offline mode
    accordingly.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "RefreshOfflineFromRegistry",
                 NULL
                 ));

    DWORD dwTemp = 0;

    // note: this won't alter dwTemp if not found and so will default to
    // online
    InternetReadRegistryDword("GlobalUserOffline", &dwTemp);

    // convert to appropriate flags
    if(0 == dwTemp) {
        // online
        dwTemp = INTERNET_STATE_ONLINE;
    } else {
        // offline
        dwTemp = INTERNET_STATE_OFFLINE;
    }
    SetOfflineUserState(dwTemp, FALSE);

    DEBUG_LEAVE(0);
}


VOID
PerformStartupProcessing(
    VOID
    )

/*++

Routine Description:

    Performs actions exactly once on system startup.  Resets offline mode.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "PerformStartupProcessing",
                 NULL
                 ));

    INET_ASSERT(NULL == g_hAutodialMutex);

    g_hAutodialMutex = OpenMutex(SYNCHRONIZE, FALSE, WININET_STARTUP_MUTEX);
    if (g_hAutodialMutex == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        g_hAutodialMutex = CreateMutex(CreateAllAccessSecurityAttributes(NULL,NULL,NULL), FALSE, WININET_STARTUP_MUTEX);
    }

    if(g_hAutodialMutex) {
        DWORD dwLastError = GetLastError();

        if(ERROR_SUCCESS == dwLastError) {
            // GetLastError returns ERROR_ALREADY_EXISTS if the mutex existed
            // before we created it.  If we don't get this error, we're the
            // first so proceed with out startup processing

            if(!GlobalPlatformVersion5)
            {
                // Reset global offline mode on non-Win2K platforms
                InternetWriteRegistryDword("GlobalUserOffline", 0);
            }
        }
    }

    DEBUG_LEAVE(0);
}

#if defined(SITARA)

PRIVATE HKEY IeMainKey = NULL;


PRIVATE
VOID
OpenIeMainKey(
    VOID
    )
{
    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     "Software\\Microsoft\\Internet Explorer\\Main",
                     0,
                     KEY_QUERY_VALUE,
                     &IeMainKey
                     ) != ERROR_SUCCESS) {
        IeMainKey = NULL;
    }
}


PRIVATE
VOID
CloseIeMainKey(
    VOID
    )
{
    if (IeMainKey != NULL) {
        REGCLOSEKEY(IeMainKey);
        IeMainKey = NULL;
    }
}


DWORD
GetSitaraProtocol(
    VOID
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Int,
                 "GetSitaraProtocol",
                 NULL
                 ));

    DWORD dwProtocol = IPPROTO_TCP;
    DWORD dwEnabled = 0;

    if (ReadIeMainDwordValue("Use_Express_Lane", &dwEnabled) && (dwEnabled != 0)) {
        dwProtocol = 901;
    }

    DEBUG_LEAVE(dwProtocol);

    return dwProtocol;
}


PRIVATE
BOOL
CheckABS(
    VOID
    )
{
    DEBUG_ENTER((DBG_SOCKETS,
                 Bool,
                 "CheckABS",
                 NULL
                 ));

    BOOL on = 0;

    ReadIeMainDwordValue("ABS", (LPDWORD)&on);

    DEBUG_LEAVE(!on);

    return !on;
}


PRIVATE
BOOL
ReadIeMainDwordValue(
    IN LPSTR pszValueName,
    OUT LPDWORD pdwValue
    )
{
    if (IeMainKey != NULL) {

        DWORD value;
        DWORD valueType;
        DWORD valueLength = sizeof(value);
        DWORD err = RegQueryValueEx(IeMainKey,
                                    pszValueName,
                                    NULL,
                                    &valueType,
                                    (LPBYTE)&value,
                                    &valueLength
                                    );

        if ((err == ERROR_SUCCESS)
            && ((valueType == REG_DWORD) || (valueType == REG_BINARY))
            && (valueLength == sizeof(DWORD))) {
            *pdwValue = value;
            return TRUE;
        }
    }
    return FALSE;
}

#endif // SITARA


// Loads Mlang.dll and get the entry point we are interested in.

BOOL LoadMlang( )
{
    EnterCriticalSection(&MlangCritSec);

    if (hInstMlang == NULL && !bFailedMlangLoad)
    {
        INET_ASSERT(pfnInetMultiByteToUnicode == NULL);
        hInstMlang = LoadLibrary(MLANGDLLNAME);

        if (hInstMlang != NULL)
        {
            pfnInetMultiByteToUnicode = (PFNINETMULTIBYTETOUNICODE)GetProcAddress
                                            (hInstMlang,"ConvertINetMultiByteToUnicode");
            if (pfnInetMultiByteToUnicode == NULL)
            {
                INET_ASSERT(FALSE);
                FreeLibrary(hInstMlang);
                hInstMlang = NULL;
            }
        }
        else
        {
            INET_ASSERT(FALSE); // bad news if we can't load mlang.dll
        }

        if (pfnInetMultiByteToUnicode == NULL)
            bFailedMlangLoad = TRUE;
    }

    LeaveCriticalSection(&MlangCritSec);

    return (pfnInetMultiByteToUnicode != NULL);
}

BOOL UnloadMlang( )
{
    EnterCriticalSection(&MlangCritSec);

    if (hInstMlang)
        FreeLibrary(hInstMlang);

    hInstMlang = NULL;
    pfnInetMultiByteToUnicode = NULL;
    bFailedMlangLoad = FALSE;

    LeaveCriticalSection(&MlangCritSec);

    return TRUE;
}

PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( )
{
    // We are checking for pfnInetMultiByteToUnicode without getting a crit section.
    // This works only because UnloadMlang is called at the Dll unload time.

    if (pfnInetMultiByteToUnicode == NULL)
    {
        LoadMlang( );
    }

    return pfnInetMultiByteToUnicode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\event.cxx ===
//
// event.cxx - simple eventing mechanism for ras/offline/logon events
//
#include "wininetp.h"
#include <docobj.h>

//
// Globals
//
static const TCHAR szEventKey[] = REGSTR_PATH_INETEVENTS;

CLSID clsidEventGroup = { /* ab8ed004-b86a-11d1-b1f8-00c04fa357fa */
    0xab8ed004,
    0xb86a,
    0x11d1,
    {0xb1, 0xf8, 0x00, 0xc0, 0x4f, 0xa3, 0x57, 0xfa}
  };

//
// remember events so we don't repeat them
//
static DWORD g_dwOffline = 0;

//
// SendEvent - deliver an event to a single client
//
BOOL SendEvent(DWORD dwEvent, VARIANTARG *pva, LPTSTR pszValue)
{
    CLSID               clsid;
    IOleCommandTarget   *poct;
    HRESULT             hr = E_FAIL;

#ifdef UNICODE
    if(FAILED(CLSIDFromString(pszValue, &clsid)))
        return FALSE;
#else
    WCHAR wszCLSID[80];
    MultiByteToWideChar(CP_ACP, 0, pszValue, -1, wszCLSID, sizeof(wszCLSID) / sizeof(WCHAR));
    if(FAILED(CLSIDFromString(wszCLSID, &clsid)))
        return FALSE;
#endif


    hr = (CoCreateInstance(clsid, NULL, CLSCTX_ALL,
                            IID_IOleCommandTarget, (void **)&poct));
    if(SUCCEEDED(hr))
    {
        // ensure client likes our group
        hr = poct->Exec(&clsidEventGroup, dwEvent, 0, pva, NULL);
        poct->Release();
    }

    return SUCCEEDED(hr);
}


//
// EnumClients - send all events to clients in a reg key
//
DWORD EnumClients(HKEY hkey, DWORD dwEvent, LPWSTR pwsEventDesc, DWORD dwEventData)
{
    DWORD cbData, cbValue, dwType, i, dwMask;
    TCHAR szValueName[80];
    VARIANTARG  va;

    va.vt = VT_EMPTY;

    //
    // Enumerate everyone
    //
    for (i = 0; ; i++)
    {
        LONG lEnum;

        cbValue = sizeof(szValueName) / sizeof(TCHAR);
        cbData = sizeof(DWORD);

        // BUGBUG (Unicode, Davepl) I'm assuming that the data is UNICODE,
        // but I'm not sure who put it there yet... double check.

        if( ( lEnum = RegEnumValue( hkey, i, szValueName, &cbValue, NULL,
                                    &dwType, (LPBYTE)&dwMask, &cbData ) ) == ERROR_MORE_DATA )
        {
            // ERROR_MORE_DATA means the value name or data was too large
            // skip to the next item
            continue;
        }
        else if( lEnum != ERROR_SUCCESS )
        {
            // could be ERROR_NO_MORE_ENTRIES, or some kind of failure
            // we can't recover from any other registry problem, anyway
            break;
        }

        if(0 != (dwMask & dwEvent)) {
            // this guy wants this event
            SendEvent(dwEvent, &va, szValueName);
        }
    }

    return 0;
}



//
// DispatchEvent - enumerate all clients and deliver the event to them
//

DWORD InternetDispatchEvent(DWORD dwEvent, LPWSTR pwsEventDesc, DWORD dwEventData)
{
    HKEY hkey;

    // get rid of repeated events here
    switch(dwEvent) {
    case INETEVT_OFFLINE:
        if(g_dwOffline == dwEvent)
            return 0;
        g_dwOffline = dwEvent;
        break;
    case INETEVT_ONLINE:
        if(g_dwOffline == dwEvent)
            return 0;
        g_dwOffline = dwEvent;
        break;
    default:
        return ERROR_INVALID_PARAMETER;
    }

    // fire up com
    if(SUCCEEDED(CoInitialize(NULL))) {

        if (REGOPENKEY(HKEY_CURRENT_USER, szEventKey, &hkey) == ERROR_SUCCESS) {
            EnumClients(hkey, dwEvent, pwsEventDesc, dwEventData);
            REGCLOSEKEY(hkey);
        }

        if (REGOPENKEY(HKEY_LOCAL_MACHINE, szEventKey, &hkey) == ERROR_SUCCESS) {
            EnumClients(hkey, dwEvent, pwsEventDesc, dwEventData);
            REGCLOSEKEY(hkey);
        }

        CoUninitialize();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\iedial.cxx ===
#include "wininetp.h"
#include "autodial.h"
#include "rashelp.h"

#define TAPI_CURRENT_VERSION 0x00010004
#include <tapi.h>

void PostString(HWND hDlg, LPWSTR pszString);
void GetDialErrorString(DWORD dwError, LPWSTR pszBuffer, DWORD dwLength);
void SetDialError(HWND hDlg, DWORD dwError);

UINT_PTR
SendDialmonMessage(
    UINT    uMessage,
    BOOL    fPost
    );

// function prototype in inetcpl to launch connections tab
typedef BOOL (WINAPI *LAUNCHCPL)(HWND);

//
// Globals
//
BOOL    g_fRegisterWndProc = FALSE;

#define REGSTR_DIAL_AUTOCONNECTW            L"AutoConnect"

typedef struct _tagRASCONNSTATEMAP {
    RASCONNSTATE    rascs;
    UINT            uResourceID;
} RASCONNSTATEMAP;

RASCONNSTATEMAP rgRasStates[] = {
    { RASCS_OpenPort,                 IDS_DIALING       },
    { RASCS_AllDevicesConnected,      IDS_CONNECTED     },
    { RASCS_Authenticate,             IDS_AUTHENTICATE  },
    { RASCS_Disconnected,             IDS_DISCONNECTED  },
    { (RASCONNSTATE)0, 0 }
};

PROPMAP g_PropertyMap[] = {
    {DIALPROP_USERNAME,         PropUserName       },
    {DIALPROP_PASSWORD,         PropPassword       },
    {DIALPROP_DOMAIN,           PropDomain         },
    {DIALPROP_SAVEPASSWORD,     PropSavePassword   },
    {DIALPROP_PHONENUMBER,      PropPhoneNumber    },
    {DIALPROP_REDIALCOUNT,      PropRedialCount    },
    {DIALPROP_REDIALINTERVAL,   PropRedialInterval },
    {DIALPROP_LASTERROR,        PropLastError      },
    {DIALPROP_RESOLVEDPHONE,    PropResolvedPhone  }
};
#define NUM_DIALPROPS (sizeof(g_PropertyMap) / sizeof(PROPMAP))

//////////////////////////////////////////////////////////////////////////////
//
// CDialEngine implementation
//
//////////////////////////////////////////////////////////////////////////////


CDialEngine::CDialEngine()
{
    m_cRef = 0;
    m_pdes = NULL;
    m_rcs = RASCS_Disconnected;
    m_fCurrentlyDialing = FALSE;
    memset(&m_rdp, 0, sizeof(m_rdp));
    memset(&m_rcred, 0, sizeof(m_rcred));
    m_fPassword = FALSE;
    m_fSavePassword = FALSE;
    m_dwError = 0;

    // must be initialized to zero -- RasDial will fail (!) if this is anything
    // other than 0 when passed in to receive conn handle!!
    m_hConn = NULL;

    m_rdp.dwSize = sizeof(m_rdp);

    EnsureRasLoaded();

    if(FALSE == g_fRegisterWndProc)
    {
        // register window class for dialing engine
        WNDCLASS wc;
        memset(&wc, 0, sizeof(wc));
        wc.lpfnWndProc = CDialEngine::EngineWndProc;
        wc.hInstance = GlobalDllHandle;
        wc.lpszClassName = "DialEngine";
        RegisterClass(&wc);

        g_fRegisterWndProc = TRUE;
    }
}

CDialEngine::~CDialEngine()
{
    SAFE_RELEASE(m_pdes);

    if(m_hwnd)
    {
        DestroyWindow(m_hwnd);
    }
}

//
// IUnknown members
//
STDMETHODIMP_(ULONG) CDialEngine::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDialEngine::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CDialEngine::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv = NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_IDialEngine == riid))
    {
        *ppv = (IDialEngine *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}


//
// IDialEngine members
//
STDMETHODIMP
CDialEngine::Initialize(
    LPCWSTR pwzConnectoid,
    IDialEventSink *pIDES
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::Initialize",
                 "%#x (%Q), %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 pIDES
                 ));

    // save off stuff
    m_pdes = pIDES;
    m_pdes->AddRef();
    StrCpyW(m_rdp.szEntryName, pwzConnectoid);
    m_rdp.dwSize = sizeof(m_rdp);

    // get stats from RAS
    RasEntryDialParamsHelp re;
    if(re.GetW(NULL, &m_rdp, &m_fPassword))
    {
        DEBUG_LEAVE(E_INVALIDARG);
        return E_INVALIDARG;
    }

    if(IsOS(OS_WHISTLERORGREATER))
    {
        // on whistler, use RasGetCredentials instead to preserve settings
        m_rcred.dwSize = sizeof(m_rcred);
        m_rcred.dwMask = RASCM_UserName | RASCM_Password;
        if(_RasGetCredentialsW(NULL, pwzConnectoid, &m_rcred))
        {
            DEBUG_LEAVE(E_INVALIDARG);
            return E_INVALIDARG;
        }
        DEBUG_PRINT(DIALUP, INFO, ("Name=<%ws>, PW=<%ws>, dwMask=%x\n", m_rcred.szUserName, m_rcred.szPassword, m_rcred.dwMask));

        m_fPassword = (m_rcred.dwMask & RASCM_Password) ? TRUE : FALSE;
    }

    // read redial properties
    GetRedialParameters((LPWSTR)pwzConnectoid, &m_dwTryTotal, &m_dwWaitTotal);
    m_dwTryCurrent = 0;
    m_dwWaitCurrent = 0;

    // register the ras message
    m_uRasMsg = RegisterWindowMessageA(RASDIALEVENT);
    if(0 == m_uRasMsg)
        m_uRasMsg = WM_RASDIALEVENT;

    // create the window to get ras callbacks.
    m_hwnd = CreateWindowA(
                "DialEngine",
                "DialEngine",
                WS_OVERLAPPED,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                CW_USEDEFAULT,
                NULL,
                NULL,
                GlobalDllHandle,
                NULL
                );

    if(NULL == m_hwnd)
    {
        DEBUG_LEAVE(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }

    // tell window our this pointer
    SendMessage(m_hwnd, WM_USER, 0, (LPARAM)this);

    // get current connected state from RAS
    UpdateRasState();

    DEBUG_LEAVE(S_OK);
    return S_OK;
}


STDMETHODIMP
CDialEngine::GetProperty(
    LPCWSTR pwzProperty,
    LPWSTR  pwzValue,
    DWORD   dwBufSize
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::GetProperty",
                 "%#x (%Q), %#x, %#x",
                 pwzProperty,
                 pwzProperty,
                 pwzValue,
                 dwBufSize
                 ));

    HRESULT hr = E_INVALIDARG;
    WCHAR * pwzSrc = NULL;
    RasEntryPropHelp *pre = new RasEntryPropHelp;

    switch(PropertyToOrdinal(pwzProperty))
    {
    case PropUserName:
        pwzSrc = m_rdp.szUserName;
        break;
    case PropPassword:
        if(m_fPassword)
        {
            pwzSrc = m_rdp.szPassword;
        }
        else
        {
            hr = S_FALSE;
        }
        break;
    case PropDomain:
        pwzSrc = m_rdp.szDomain;
        break;
    case PropSavePassword:
        if(m_fSavePassword)
        {
            pwzSrc = L"TRUE";
        }
        else
        {
            pwzSrc = L"FALSE";
        }
        break;
    case PropResolvedPhone:
        if(ResolvePhoneNumber(pwzValue, dwBufSize))
        {
            hr = S_OK;
            break;
        }

        //
        // failed to get nicely formatted phone number, fall through to basic one
        //

    case PropPhoneNumber:
        if (pre == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pre->GetW(m_rdp.szEntryName);
            pwzSrc = pre->GetPhoneNumberW();
        }
        break;
    case PropRedialCount:
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %d\n", m_dwTryTotal));
        wnsprintfW(pwzValue, dwBufSize, L"%d", m_dwTryTotal);
        hr = S_OK;
        break;
    case PropRedialInterval:
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %d\n", m_dwWaitTotal));
        wnsprintfW(pwzValue, dwBufSize, L"%d", m_dwWaitTotal);
        hr = S_OK;
        break;
    case PropLastError:
        GetDialErrorString(m_dwError, pwzValue, dwBufSize);
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %ws\n", pwzValue));
        hr = S_OK;
        break;
    }

    if(pwzSrc)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Prop value = %ws\n", pwzSrc));
        StrCpyNW(pwzValue, pwzSrc, dwBufSize);
        hr = S_OK;
    }

    if (pre)
        delete pre;

    DEBUG_LEAVE(hr);
    return hr;
}


STDMETHODIMP
CDialEngine::SetProperty(
    LPCWSTR pwzProperty,
    LPCWSTR  pwzValue
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::SetProperty",
                 "%#x (%Q), %#x (%Q)",
                 pwzProperty,
                 pwzProperty,
                 pwzValue,
                 pwzValue
                 ));

    HRESULT hr = E_INVALIDARG;
    WCHAR * pwzDest = NULL;
    DWORD   dwMaxLength = 0;
    WCHAR   wcNull = 0;

    // treat NULL values as emtpy values
    if(NULL == pwzValue)
    {
        pwzValue = &wcNull;
    }

    switch(PropertyToOrdinal(pwzProperty))
    {
    case PropUserName:
        pwzDest = m_rdp.szUserName;
        dwMaxLength = UNLEN;
        if(IsOS(OS_WHISTLERORGREATER))
        {
            StrCpyNW(m_rcred.szUserName, pwzValue, dwMaxLength);
        }
        break;
    case PropPassword:
        pwzDest = m_rdp.szPassword;
        dwMaxLength = PWLEN;
        m_fPassword = TRUE;
        if(IsOS(OS_WHISTLERORGREATER))
        {
            StrCpyNW(m_rcred.szPassword, pwzValue, dwMaxLength);
        }
        break;
    case PropDomain:
        pwzDest = m_rdp.szDomain;
        dwMaxLength = DNLEN;
        break;
    case PropSavePassword:
        if(!StrCmpIW(pwzValue, L"TRUE"))
        {
            m_fSavePassword = TRUE;
        }
        else
        {
            m_fSavePassword = FALSE;
        }
        if(FALSE == m_fSavePassword)
        {
            m_fPassword = FALSE;
        }
        hr = S_OK;
        break;
    case PropPhoneNumber:
        pwzDest = m_rdp.szPhoneNumber;
        dwMaxLength = RAS_MaxPhoneNumber;
        break;
    case PropRedialCount:
        m_dwTryTotal = StrToIntW(pwzValue);
        if(0 == m_dwTryTotal)
        {
            m_dwTryTotal = DEFAULT_DIAL_ATTEMPTS;
        }
        hr = S_OK;
        break;
    case PropRedialInterval:
        m_dwWaitTotal = StrToIntW(pwzValue);
        if(0 == m_dwWaitTotal)
        {
            m_dwWaitTotal = DEFAULT_DIAL_INTERVAL;
        }
        hr = S_OK;
        break;
    default:
        hr = E_UNEXPECTED;
        break;
    }

    if(pwzDest)
    {
        StrCpyNW(pwzDest, pwzValue, dwMaxLength);
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}


STDMETHODIMP
CDialEngine::StartConnection()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::StartConnection",
                 NULL
                 ));

    m_dwTryCurrent++;
    m_pdes->OnEvent(DIALENG_RedialAttempt, m_dwTryCurrent);

    RasDialHelp RasDial(NULL, NULL, &m_rdp, 0xFFFFFFFF, m_hwnd, &m_hConn);

    if(0 != RasDial.GetError()) {

        // Clean up since RAS may return a connection anyway...
        CleanConnection();
        m_dwError = ERROR_NO_CONNECTION;
        EndOfOperation();

        DEBUG_PRINT(DIALUP, INFO, ("Bailing - RasDial error\n"));
        DEBUG_LEAVE(E_FAIL);
        return E_FAIL;
    }

    DEBUG_LEAVE(S_OK);
    return S_OK;
}

STDMETHODIMP
CDialEngine::Dial()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::Dial",
                 NULL
                 ));

    HRESULT hr;

    if(m_fCurrentlyDialing)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Bailing - m_fCurentlyDialing\n"));
        DEBUG_LEAVE(S_FALSE);
        return S_FALSE;
    }

    // find out if our connection state has changed in the mean time
    UpdateRasState();

    // we have begun...
    m_fCurrentlyDialing = TRUE;

    if(m_rcs == RASCS_Connected)
    {
        DEBUG_PRINT(DIALUP, INFO, ("Bailing - already connected\n"));
        m_dwError = ERROR_SUCCESS;
        EndOfOperation();

        DEBUG_LEAVE(S_FALSE);
        return S_FALSE;
    }

    m_dwError = 0;
    m_dwTryCurrent = 0;

    hr = StartConnection();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CDialEngine::CleanConnection()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::CleanConnection",
                 NULL
                 ));

    HRESULT hr = S_FALSE;

    // make sure we see if we've connected in the mean time
    UpdateRasState();

    DEBUG_PRINT(DIALUP, INFO, ("m_hConn=%x\n", m_hConn));

    // hang up connection if we got one
    if(m_hConn)
    {
        HRASCONN hConn = m_hConn;
        m_hConn = NULL;
        _RasHangUp(hConn);
        hr = S_OK;
    }

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CDialEngine::HangUp()
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::HangUp",
                 NULL
                 ));

    HRESULT hr;

    // hang up or abort any pending dials
    hr = CleanConnection();

    // make sure no pending timers
    if(m_uTimerId)
    {
        KillTimer(m_hwnd, m_uTimerId);
        m_uTimerId = 0;
    }

    // calling hangup causes ras events to end
    if(0 == m_dwError)
    {
        m_dwError = ERROR_USER_DISCONNECTION;
    }
    EndOfOperation();

    DEBUG_LEAVE(hr);
    return hr;
}

STDMETHODIMP
CDialEngine::GetConnectedState(
    DWORD  *pdwState)
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::GetConnectedState",
                 NULL
                 ));

    *pdwState = MapRCS(m_rcs);

    DEBUG_LEAVE(S_OK);
    return S_OK;
}


STDMETHODIMP
CDialEngine::GetConnectHandle(
    DWORD_PTR *pdwHandle
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::GetConnectHandle",
                 NULL
                 ));

    if(RASCS_Connected == m_rcs)
    {
        *pdwHandle = (DWORD_PTR)m_hConn;
        DEBUG_LEAVE(S_OK);
        return S_OK;
    }
    else
    {
        *pdwHandle = 0;
        DEBUG_LEAVE(S_FALSE);
        return S_FALSE;
    }
}

//
// private members
//
LONG_PTR CALLBACK
CDialEngine::EngineWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::EngineWndProc",
                 "%#x, %#x, %#x, %#x",
                 hwnd,
                 uMsg,
                 wParam,
                 lParam
                 ));

    CDialEngine * peng = (CDialEngine *)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if(uMsg == WM_USER)
    {
        peng = (CDialEngine *)lParam;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (DWORD_PTR)peng);
    }
    else if(peng && uMsg == peng->m_uRasMsg)
    {
        peng->OnRasEvent((RASCONNSTATE)wParam, (DWORD)lParam);
    }
    else if(peng && uMsg == WM_TIMER)
    {
        peng->OnTimer();
    }

    DEBUG_LEAVE(0);
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

VOID
CDialEngine::OnTimer()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::OnTimer",
                 NULL
                 ));

    if(0 == m_dwError)
    {
        m_dwWaitCurrent--;
        if(0 == m_dwWaitCurrent)
        {
            // kick off dial
            KillTimer(m_hwnd, m_uTimerId);
            m_uTimerId = 0;
            StartConnection();
        }
        else
        {
            // update sink
            // m_pdes->OnEvent(DIALENG_RedialWait, m_dwWaitCurrent);
        }
    }

    DEBUG_LEAVE(0);
}

VOID
CDialEngine::OnRasEvent(
    RASCONNSTATE rcs,
    DWORD dwError
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::OnRasEvent",
                 "%#x, %#x",
                 (DWORD)rcs,
                 dwError
                 ));

    // save rasconnstate
    m_rcs = rcs;

    // forward event to UI object
    m_pdes->OnEvent(MapRCS(rcs), dwError);

    // handle the dial state
    if(dwError != SUCCESS) {

        // win95 returns this error if authentication failed.
        if(ERROR_UNKNOWN == dwError)
            dwError = ERROR_AUTHENTICATION_FAILURE;

        // save error if we don't already have one
        if(0 == m_dwError && dwError)
        {
            m_dwError = dwError;
        }

        // clean up connection
        CleanConnection();

        switch(dwError) {
        case ERROR_AUTHENTICATION_FAILURE:
            memset(m_rdp.szPassword, 0, ARRAYSIZE(m_rdp.szPassword));
            EndOfOperation();
            break;
        case ERROR_USER_DISCONNECTION:
            // we hit cancel and called RasHangUp.  Nothing to do here -
            // cancel code has cleaned up as necessary.
            EndOfOperation();
            break;
        case ERROR_LINE_BUSY:
        case ERROR_NO_ANSWER:
        case ERROR_NO_CARRIER:
            if(m_dwTryCurrent < m_dwTryTotal)
            {
                m_dwError = 0;
                m_dwWaitCurrent = m_dwWaitTotal;
                m_uTimerId = SetTimer(m_hwnd, 1, 1000, NULL);
                m_pdes->OnEvent(DIALENG_RedialWait, m_dwWaitCurrent);
                break;
            }

            // fall through
        default:
            EndOfOperation();
        }
    } else {
        // we're getting status
        if(rcs == RASCS_Connected)
        {
            // we're done
            m_dwError = ERROR_SUCCESS;
            EndOfOperation();

            DEBUG_PRINT(DIALUP, INFO, ("Connected: m_fPassword=%B, m_fSavePassword=%B\n", m_fPassword, m_fSavePassword));
            if(IsOS(OS_WHISTLERORGREATER))
            {
                // delete/write/leave alone semantics
                //
                // m_fPassword     m_fSavePassword      result
                //      T               T               Write password
                //      F               F               Delete password
                //      T               F               Leave password alone
                //      F               T               Never happens

                if(!m_fPassword && !m_fSavePassword)
                {
                    // delete case, only want password mask
                    m_rcred.dwMask = 0;
                }

                if(m_fPassword == m_fSavePassword)
                {
                    // write or delete case

                    // always need password flag
                    m_rcred.dwMask |= RASCM_Password;

                    // write or delete, depend on m_fSavePassword
                    DEBUG_PRINT(DIALUP, INFO, ("Name=<%ws>, PW=<%ws>, dwMask=%x\n", m_rcred.szUserName, m_rcred.szPassword, m_rcred.dwMask));
                    _RasSetCredentialsW(NULL, m_rdp.szEntryName, &m_rcred, !m_fSavePassword);
                }
            }
            else
            {
                if(m_fPassword == m_fSavePassword)
                {
                    // save or delete password
                    RasEntryDialParamsHelp re;
                    re.SetW(NULL, &m_rdp, !m_fSavePassword);
                }
            }

            // inform dialmon that we've dialed
            SendDialmonMessage(WM_SET_CONNECTOID_NAME, TRUE);
        }
    }

    DEBUG_LEAVE(0);
}

DWORD
CDialEngine::MapRCS(RASCONNSTATE rcs)
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialEngine::MapRCS",
                 "%#x",
                 (DWORD)rcs
                 ));


    DEBUG_LEAVE((DWORD)rcs);
    return (DWORD)rcs;
}


DIALPROP
CDialEngine::PropertyToOrdinal(LPCWSTR pwzProperty)
{
    long i;

    for(i=0; i<NUM_DIALPROPS; i++)
    {
        if(!StrCmpIW(g_PropertyMap[i].pwzProperty, pwzProperty))
        {
            return g_PropertyMap[i].Prop;
        }
    }

    return PropInvalid;
}

VOID
CDialEngine::UpdateRasState()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::UpdateRasState",
                 NULL
                 ));

    DEBUG_PRINT(DIALUP, INFO, ("m_fCurrentlyDialing = %B\n", m_fCurrentlyDialing));

    //
    // only do this if not dialing.  If we are, OnRasEvent will update
    // state appropriately.
    //
    if(FALSE == m_fCurrentlyDialing)
    {
        RasEnumConnHelp re;

        re.Enum();

        DEBUG_PRINT(DIALUP, INFO, ("Checking for connections\n"));

        // set state to disconnected and try to find a connection
        m_rcs = RASCS_Disconnected;

        if(0 == re.GetError())
        {
            DWORD dwCount;

            for(dwCount = 0; dwCount < re.GetConnectionsCount(); dwCount++)
            {
                if(0 == StrCmpW(re.GetEntryW(dwCount), m_rdp.szEntryName))
                {
                    DEBUG_PRINT(DIALUP, INFO, ("Found connection\n"));
                    m_hConn = re.GetHandle(dwCount);
                    m_rcs = RASCS_Connected;
                }
            }
        }
    }

    DEBUG_LEAVE(0);
}

VOID
CDialEngine::EndOfOperation()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialEngine::EndOfOperation",
                 NULL
                 ));

    if(m_fCurrentlyDialing)
    {
        // called when a dialing operation is done
        m_fCurrentlyDialing = FALSE;
        m_dwTryCurrent = 0;

        // notify sink that no more events are forthcoming
        m_pdes->OnEvent(DIALENG_OperationComplete, m_dwError);
    }

    DEBUG_LEAVE(0);
}

VOID FAR CALLBACK TapiCallback(
    DWORD       hDevice,
    DWORD       dwMsg,
    DWORD_PTR   dwCallbackInstance,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    )
{
}

BOOL
CDialEngine::ResolvePhoneNumber(LPWSTR pwzBuffer, DWORD dwLen)
{
    char   *pszTemp = NULL;
    WCHAR   szCanonical[128];
    CHAR    szAnsiCanonical[128];
    CHAR   *pszResolved;
    long    lErr, i;
    BOOL    fResult = FALSE;
    RasEntryPropHelp *pre = new RasEntryPropHelp;

    if (pre == NULL)
    {
        goto Cleanup;
    }

    pszTemp = (char *) ALLOCATE_FIXED_MEMORY(4096);
    if (pszTemp == NULL)
    {
        goto Cleanup;
    }

    // look up RAS entry
    pre->GetW(m_rdp.szEntryName);
    if(pre->GetError())
    {
        goto Cleanup;
    }

    if(pre->GetOptions() & RASEO_UseCountryAndAreaCodes)
    {
        PWSTR       pszAreaCode = pre->GetAreaCodeW();
        HLINEAPP    hApp;
        DWORD       dwNumDevs;

        // make TAPI canonical phone number
        wnsprintfW(szCanonical, 128, L"+%d (%ws) %ws", pre->GetCountryCode(), pszAreaCode ? pszAreaCode : L"", pre->GetPhoneNumberW());

        // ask TAPI to translate it
        LPLINETRANSLATEOUTPUT lpOut = (LPLINETRANSLATEOUTPUT)pszTemp;
        lpOut->dwTotalSize = 4096;
        lErr = lineInitialize(&hApp, GlobalDllHandle, TapiCallback, "Wininet", &dwNumDevs);
        if(lErr)
        {
            goto Cleanup;
        }
        WideCharToMultiByte(CP_ACP, 0, szCanonical, -1, szAnsiCanonical, 128, NULL, NULL);
        lErr = lineTranslateAddress(hApp, 0, TAPI_CURRENT_VERSION, szAnsiCanonical, 0, 0, lpOut);
        if(lErr)
        {
            goto Cleanup;
        }   
        pszResolved = (CHAR *)((char *)lpOut + lpOut->dwDisplayableStringOffset);
        i = MultiByteToWideChar(CP_ACP, 0, pszResolved, -1, pwzBuffer, dwLen);
        if(0 == i)
        {
            pwzBuffer[dwLen] = 0; // truncated - null terminate
        }
    }
    else
    {
        // TAPI resolution not turned on, just return straight phone number
        StrCpyNW(pwzBuffer, pre->GetPhoneNumberW(), dwLen);
    }

    fResult = TRUE;

Cleanup:
    if (pre)
        delete pre;

    if (pszTemp)
        FREE_MEMORY(pszTemp);

    return fResult;
}


//////////////////////////////////////////////////////////////////////////////
//
// CDialUI implementation
//
//////////////////////////////////////////////////////////////////////////////

CDialUI::CDialUI(HWND hwndParent)
{
    m_cRef = 0;
    m_pEng = NULL;
    m_pdb = NULL;
    m_State = UISTATE_Interactive;
    m_fOfflineSemantics = FALSE;
    m_fSavePassword = FALSE;
    m_fPasswordChanged = FALSE;
    m_fAutoConnect = FALSE;
    m_fCDH = FALSE;
    m_fDialedCDH = FALSE;
    memset(&m_cdh, 0, sizeof(m_cdh));

    if(hwndParent)
    {
        m_hwndParent = hwndParent;
    }
    else
    {
        m_hwndParent = GetDesktopWindow();
    }
}

CDialUI::~CDialUI()
{
    SAFE_RELEASE(m_pEng);
    SAFE_RELEASE(m_pdb);
}

//
// IUnknown members
//
STDMETHODIMP_(ULONG) CDialUI::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CDialUI::Release(void)
{
    if( 0L != --m_cRef )
        return m_cRef;

    delete this;
    return 0L;
}

STDMETHODIMP CDialUI::QueryInterface(REFIID riid, void ** ppv)
{
    *ppv=NULL;

    // Validate requested interface
    if ((IID_IUnknown == riid) ||
        (IID_IDialEventSink == riid))
    {
        *ppv = (IDialEventSink *)this;
    }
    else
    {
        return E_NOINTERFACE;
    }

    // Addref through the interface
    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}


//
// IDialUI members
//
DWORD
CDialUI::StartDial(
    IN DIALSTATE *pDial,
    IN DWORD dwFlags
    )
//
//
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialUI::StartDial",
                 "%#x, %#x",
                 pDial,
                 dwFlags
                 ));

    DWORD dwSize, dwTemp, dwType;
    WCHAR szKey[MAX_PATH];

    // save passed info
    m_dwFlags = dwFlags;
    m_pDial = pDial;
    m_pDial->dwResult = 0;

    // check for connect automatically
    dwSize = sizeof(DWORD);
    dwTemp = 0;
    GetConnKeyW(pDial->params.szEntryName, szKey, ARRAYSIZE(szKey));
    if(0 == (dwFlags & INTERNET_DIAL_FORCE_PROMPT) &&
            ERROR_SUCCESS == SHGetValueW(HKEY_CURRENT_USER, szKey,
            REGSTR_DIAL_AUTOCONNECTW, &dwType, &dwTemp, &dwSize) && dwTemp)
    {
        m_fAutoConnect = TRUE;
    }

    //
    // Get some UI going
    //
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
    if(-1 == DialogBoxParamWrapW(GlobalDllHandle, MAKEINTRESOURCEW(IDD_CONNECT_TO),
        m_hwndParent, CDialUI::DialogProc, (LPARAM)this))
    {
        // couldn't create dialog for some reason - no mem?
        m_pDial->dwResult = ERROR_OUTOFMEMORY;
    }
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    // prop odds and ends back to data so caller is happy
    if(!m_fCDH)
    {
        m_pDial->dwFlags = 0;
        if(m_fAutoConnect)
        {
            m_pDial->dwFlags |= CI_AUTO_CONNECT;
        }

        if(m_pEng)
        {
            m_pEng->GetConnectHandle((DWORD_PTR *)&m_pDial->hConn);
        }
    }
    else
    {
        m_pDial->hConn = (HRASCONN)CDH_HCONN;
    }

    //
    // Clean up
    //
    SAFE_RELEASE(m_pEng);

    DEBUG_LEAVE(m_pDial->dwResult);
    return m_pDial->dwResult;
}


STDMETHODIMP
CDialUI::OnEvent(
    DWORD dwEvent,
    DWORD dwStatus
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "CDialUI::OnEvent",
                 "%#x, %#x",
                 dwEvent,
                 dwStatus
                 ));

    WCHAR   pszText[128], pszTemplate[128];
    INT     idRes;

    // find string for this state (if any)
    for (int nIndex = 0; rgRasStates[nIndex].uResourceID != 0; nIndex++)
    {
        if ((RASCONNSTATE)dwEvent == rgRasStates[nIndex].rascs) {
            LoadStringWrapW(GlobalDllHandle, rgRasStates[nIndex].uResourceID,
                pszText, 128);
            PostString(m_hwnd, pszText);
        }
    }

    switch(dwEvent)
    {
        case DIALENG_RedialAttempt:
        case DIALENG_RedialWait:
            idRes = IDS_REDIAL_ATTEMPT;
            if(dwEvent == DIALENG_RedialWait)
            {
                idRes = IDS_REDIAL_WAIT;
            }
            LoadStringWrapW(GlobalDllHandle, idRes, pszTemplate, 128);
            wnsprintfW(pszText, ARRAYSIZE(pszText), pszTemplate, dwStatus);
            PostString(m_hwnd, pszText);
            break;
        case DIALENG_OperationComplete:
            m_pDial->dwResult = dwStatus;
            if(0 == dwStatus || m_State == UISTATE_Unattended)
            {
                EndDialog(m_hwnd, 0);
            }
            else
            {
                if(dwStatus)
                {
                    // get an error - display it
                    SetDialError(m_hwnd, dwStatus);
                }
                m_State = UISTATE_Interactive;
                FixUIComponents();
            }
            break;
    }

    DEBUG_LEAVE(0);
    return NOERROR;
}

VOID
CDialUI::FixUIComponents(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::FixUIComponents",
                 NULL
                 ));
    WCHAR   pszTemp[64];
    int     i;
    BOOL    fActive = TRUE, fCanSave, fCDHActive = TRUE;
    TCHAR   szUser[UNLEN+1];
    DWORD   dwLen = UNLEN;
    UINT uIDs[] =      {IDC_CONN_TXT, IDC_CONN_LIST, ID_CONNECT, IDC_SETTINGS};
    UINT uCDHIDs[] =   {IDC_NAME_TXT, IDC_USER_NAME, IDC_PASSWORD_TXT, IDC_PASSWORD};

#define NUM_IDS      (sizeof(uIDs) / sizeof(UINT))
#define NUM_CDH_IDS  (sizeof(uCDHIDs) / sizeof(UINT))

    //
    // fix cancel button
    //
    if(UISTATE_Dialing == m_State || UISTATE_Unattended == m_State || FALSE == m_fOfflineSemantics)
    {
        i = IDS_CANCEL;
    }
    else
    {
        i = IDS_WORK_OFFLINE;
    }
    LoadStringWrapW(GlobalDllHandle, i, pszTemp, MAX_PATH);
    SetWindowTextWrapW(GetDlgItem(m_hwnd, IDCANCEL), pszTemp);

    //
    // Fix focus
    //
    if(UISTATE_Dialing == m_State || UISTATE_Unattended == m_State)
    {
        SetFocus(GetDlgItem(m_hwnd, IDCANCEL));
        fActive = FALSE;
    }

    //
    // Grey out appropriate stuff
    //
    for(i=0; i<NUM_IDS; i++)
    {
        EnableWindow(GetDlgItem(m_hwnd, uIDs[i]), fActive);
    }

    for(i=0; i<NUM_CDH_IDS; i++)
    {
        EnableWindow(GetDlgItem(m_hwnd, uCDHIDs[i]), fActive && !m_fCDH);
    }

    //
    // fix password and auto check boxes
    //
    fCanSave = (0 != GetUserName(szUser, &dwLen));
    EnableWindow(GetDlgItem(m_hwnd, IDC_SAVE_PASSWORD), fActive && fCanSave);

    //
    // special case - Autoconnect is disabled if save password not checked
    // or password cannot be saved
    //
    EnableWindow(
        GetDlgItem(m_hwnd, IDC_AUTOCONNECT),
        fCanSave && fActive && IsDlgButtonChecked(m_hwnd, IDC_SAVE_PASSWORD));

    DEBUG_LEAVE(0);
}


//
// Other members
//
VOID
CDialUI::OnInitDialog(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnInitDialog",
                 NULL
                 ));

    TCHAR szUser[UNLEN+1];
    DWORD dwLen = UNLEN;
    BOOL fCanSave;

    // Fill in the connectoid list
    EnumerateConnectoids();

    // Get the engine for this connectoid and get relevant properties
    GetProps();

    // check flags for unattended, etc.
    if(GlobalIsProcessExplorer || (m_dwFlags & INTERNET_DIAL_SHOW_OFFLINE))
    {
        m_fOfflineSemantics = TRUE;
    }

    if(m_dwFlags & (INTERNET_DIAL_UNATTENDED|INTERNET_AUTODIAL_FORCE_UNATTENDED))
    {
        // want unattended dial.. do it if we can, else bail out
        m_State = UISTATE_Unattended;
        if(m_pEng)
        {
            m_pEng->Dial();
        }
        else
        {
            OnCancel();
        }
    }

    // make sure cancel button is correct
    FixUIComponents();

    // Handle autoconnect
    if(m_fAutoConnect)
    {
        CheckDlgButton(m_hwnd, IDC_AUTOCONNECT, BST_CHECKED);
        OnConnect();
    }

    DEBUG_LEAVE(0);
}

VOID
CDialUI::OnSelChange()
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnSelChange",
                 NULL
                 ));
    int iSel;
    HWND hwndList = GetDlgItem(m_hwnd, IDC_CONN_LIST);

    // yank out new name
    iSel = ComboBox_GetCurSel(hwndList);
    if(CB_ERR == iSel)
        iSel = 0;

    SendMessageWrapW(hwndList, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)m_pDial->params.szEntryName);

    // Fill in props for new connection (will get new engine)
    GetProps();

    DEBUG_LEAVE(0);
}


VOID
CDialUI::OnConnect(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnConnect",
                 NULL
                 ));

    // If we have a CDH, call it
    if(m_fCDH)
    {
        if(!CallCDH(m_hwnd, m_pDial->params.szEntryName, &m_cdh, 0, &(m_pDial->dwResult)))
        {
            // custom dial handler failed to handle dial request, bail out
            m_pDial->dwResult = ERROR_USER_DISCONNECTION;
        }

        m_fDialedCDH = TRUE;
        EndDialog(m_hwnd, 0);
        DEBUG_LEAVE(0);
        return;
    }
    else
    {
        // If we don't have an engine, repop conn list (may have been deleted)
        // and bail out of dial operation
        if(!m_pEng)
        {
            EnumerateConnectoids();
            DEBUG_LEAVE(0);
            return;
        }

        // Save off properties
        SaveProps();
    }

    // TODO grey stuff
    m_State = UISTATE_Dialing;
    FixUIComponents();

    // Stick phone number in progress box
    WCHAR szString[256], szPhone[128];

    LoadStringWrapW(GlobalDllHandle, IDS_DIALING, szString, 128);
    if(SUCCEEDED(m_pEng->GetProperty(DIALPROP_RESOLVEDPHONE, szPhone, 128)))
    {
        StrNCatW(szString, szPhone, 128);
        PostString(m_hwnd, szString);
    }

    // Start the dialing operation
    m_pEng->Dial();

    DEBUG_LEAVE(0);
}


VOID
CDialUI::OnCancel(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::OnCancel",
                 NULL
                 ));

    switch(m_State)
    {
    case UISTATE_Interactive:
        //
        // exit the dialog box
        //
        m_pDial->dwResult = ERROR_USER_DISCONNECTION;
        EndDialog(m_hwnd, 0);
        break;
    case UISTATE_Unattended:
    case UISTATE_Dialing:
        //
        // cancel current dialing operation
        //
        if(m_pEng)
        {
            m_pEng->HangUp();
        }
        m_pDial->dwResult = ERROR_USER_DISCONNECTION;

        //
        // If we were previous "unattended" we aren't any more
        //
        CheckDlgButton(m_hwnd, IDC_AUTOCONNECT, BST_UNCHECKED);
        m_fAutoConnect = FALSE;

        //
        // fix grey stuff
        //
        FixUIComponents();
        break;
    }

    DEBUG_LEAVE(0);
}


INT_PTR CALLBACK
CDialUI::DialogProc(
    HWND hwndDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CDialUI * pui = (CDialUI *)GetWindowLongPtr(hwndDlg, DWLP_USER);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwndDlg, DWLP_USER, lParam);
        pui = (CDialUI *)lParam;
        pui->m_hwnd = hwndDlg;
        pui->OnInitDialog();
        return TRUE;

    case WM_COMMAND:
        // handle combo box messages
        if(HIWORD(wParam) == CBN_SELCHANGE) {
            pui->OnSelChange();
            break;
        }

        switch (LOWORD(wParam))
        {
        case ID_CONNECT:
            pui->OnConnect();
            break;
        case IDCANCEL:
            pui->OnCancel();
            break;
        case IDC_SETTINGS:
            {
            HMODULE hInetcpl = LoadLibrary("inetcpl.cpl");
            if(hInetcpl)
            {
                LAUNCHCPL cpl = (LAUNCHCPL)GetProcAddress(hInetcpl, "LaunchConnectionDialog");
                if(cpl)
                {
                    cpl(hwndDlg);

                    // refresh to new default if any
                    AUTODIAL config;
                    memset(&config, 0, sizeof(config));
                    IsAutodialEnabled(NULL, &config);

                    if(config.fEnabled)
                    {
                        if(config.fHasEntry)
                        {
                            StrCpyW(pui->m_pDial->params.szEntryName, config.pszEntryName);
                        }

                        // refresh settings
                        pui->EnumerateConnectoids();
                        pui->GetProps();
                    }
                    else
                    {
                        // nothing to dial... bail out right away.
                        pui->OnCancel();
                    }   
                }
                FreeLibrary(hInetcpl);
            }
            }
            break;
        case IDC_SAVE_PASSWORD:
            EnableWindow(
                GetDlgItem(hwndDlg, IDC_AUTOCONNECT),
                IsDlgButtonChecked(hwndDlg, IDC_SAVE_PASSWORD));
            break;
        case IDC_PASSWORD:
            if(HIWORD(wParam) == EN_CHANGE)
            {
                pui->m_fPasswordChanged = TRUE;
            }
            break;
        }
        break;
    }
    return FALSE;
}

VOID
CDialUI::EnumerateConnectoids(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::EnumerateConnectoids",
                 NULL
                 ));

    HWND hwndCombo = GetDlgItem(m_hwnd, IDC_CONN_LIST);
    INET_ASSERT(hwndCombo);

    ComboBox_ResetContent(hwndCombo);
    EnsureRasLoaded();

    DWORD dwEntries, dwRet;
    RasEnumHelp RasEnum;
    dwRet = RasEnum.GetError();
    dwEntries = RasEnum.GetEntryCount();
    if(ERROR_SUCCESS == dwRet)
    {
        // insert connectoid names from buffer into combo box
        DWORD i;
        for(i=0; i<dwEntries; i++)
        {
            SendMessageWrapW(hwndCombo, CB_ADDSTRING, 0, (LPARAM)RasEnum.GetEntryW(i));
        }

        // try to find connectoid from pinfo
        int iSel = (int)SendMessageWrapW(hwndCombo, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)m_pDial->params.szEntryName);
        if(CB_ERR == iSel)
        {
            iSel = 0;
            SendMessageWrapW(hwndCombo, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)m_pDial->params.szEntryName);
        }
        ComboBox_SetCurSel(hwndCombo, iSel);
    }

    DEBUG_LEAVE(0);
}


VOID
CDialUI::GetProps(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::GetProps",
                 NULL
                 ));

    WCHAR wzBuffer[256];
    HRESULT hr;
    CDHINFO cdh;

    SAFE_RELEASE(m_pEng);

    //
    // Find out if new selection is a CDH
    //
    m_fCDH = IsCDH(m_pDial->params.szEntryName, &m_cdh);

    //
    // Query for properties for non-CDH connections
    //
    if(!m_fCDH && SUCCEEDED(InternetGetDialEngineW(m_pDial->params.szEntryName, (IDialEventSink *)this, &m_pEng)))
    {
        if(FAILED(m_pEng->GetProperty(DIALPROP_USERNAME, wzBuffer, 256)))
        {
            *wzBuffer = 0;
        }
        SetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_USER_NAME), wzBuffer);

        m_fSavePassword = FALSE;
        hr = m_pEng->GetProperty(DIALPROP_PASSWORD, wzBuffer, 256);
        if(S_OK == hr)
        {
            m_fSavePassword = TRUE;
        }
        else // S_FALSE - no saved password, or error
        {
            *wzBuffer = 0;
        }
        SetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_PASSWORD), wzBuffer);
        CheckDlgButton(m_hwnd, IDC_SAVE_PASSWORD, m_fSavePassword ? BST_CHECKED : BST_UNCHECKED);

        if(FAILED(m_pEng->GetProperty(DIALPROP_DOMAIN, wzBuffer, 256)))
        {
            *wzBuffer = 0;
        }
        SetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_DOMAIN), wzBuffer);
    }

    //
    // fix UI based on connectoid type
    //
    FixUIComponents();

    // reset password changed as setting it above will cause the window message
    m_fPasswordChanged = FALSE;

    DEBUG_LEAVE(0);
}


VOID
CDialUI::SaveProps(
    )
{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "CDialUI::SaveProps",
                 NULL
                 ));

    WCHAR wzBuffer[256];

    GetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_USER_NAME), wzBuffer, 256);
    m_pEng->SetProperty(DIALPROP_USERNAME, wzBuffer);

    GetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_DOMAIN), wzBuffer, 256);
    m_pEng->SetProperty(DIALPROP_DOMAIN, wzBuffer);

    m_fSavePassword = FALSE;
    if(BST_CHECKED == IsDlgButtonChecked(m_hwnd, IDC_SAVE_PASSWORD))
        m_fSavePassword = TRUE;

    if(m_fPasswordChanged || FALSE == m_fSavePassword)
    {
        GetWindowTextWrapW(GetDlgItem(m_hwnd, IDC_PASSWORD), wzBuffer, 256);
        m_pEng->SetProperty(DIALPROP_PASSWORD, wzBuffer);
        m_pEng->SetProperty(DIALPROP_SAVEPASSWORD, m_fSavePassword ? L"TRUE" : L"FALSE");
        m_fPasswordChanged = FALSE;
    }

    m_fAutoConnect = FALSE;
    if(BST_CHECKED == IsDlgButtonChecked(m_hwnd, IDC_AUTOCONNECT))
        m_fAutoConnect = TRUE;

    DEBUG_LEAVE(0);
}


//////////////////////////////////////////////////////////////////////////////
//
// Helper functions
//
//////////////////////////////////////////////////////////////////////////////

//
// Add a string to the details edit box
//
void PostString(HWND hDlg, LPWSTR pszString)
{
    HWND hwndEdit = GetDlgItem(hDlg, IDC_DETAILS_LIST);
    WCHAR szCR[] = L"\r\n";

    // move caret to end
    SendMessageWrapW(hwndEdit, EM_SETSEL, 0,  -1);
    SendMessageWrapW(hwndEdit, EM_SETSEL, -1, -1);

    // replace selection (nothing) with new string
    SendMessageWrapW(hwndEdit, EM_REPLACESEL, 0, (LPARAM)pszString);

    // move caret to end
    SendMessageWrapW(hwndEdit, EM_SETSEL, 0,  -1);
    SendMessageWrapW(hwndEdit, EM_SETSEL, -1, -1);

    // replace selection (nothing) with CR
    SendMessageWrapW(hwndEdit, EM_REPLACESEL, 0, (LPARAM)szCR);

    // scroll to end
    SendMessageWrapW(hwndEdit, EM_SCROLLCARET, 0, 0);
}


#define RAS_BOGUS_AUTHFAILCODE_1    84
#define RAS_BOGUS_AUTHFAILCODE_2    74389484

DWORD RasErrorToIDS(DWORD dwErr)
{
    if(dwErr==RAS_BOGUS_AUTHFAILCODE_1 || dwErr==RAS_BOGUS_AUTHFAILCODE_2)
    {
        return IDS_PPPRANDOMFAILURE;
    }

    if((dwErr>=653 && dwErr<=663) || (dwErr==667) || (dwErr>=669 && dwErr<=675))
    {
        return IDS_MEDIAINIERROR;
    }

    switch(dwErr)
    {
    default:
        return IDS_PPPRANDOMFAILURE;

    case ERROR_LINE_BUSY:
        return IDS_PHONEBUSY;

    case ERROR_NO_ANSWER:
        return IDS_NOANSWER;

    case ERROR_NO_DIALTONE:
        return IDS_NODIALTONE;

    case ERROR_HARDWARE_FAILURE:    // modem turned off
    case ERROR_PORT_ALREADY_OPEN:   // procomm/hypertrm/RAS has COM port
    case ERROR_PORT_OR_DEVICE:      // got this when hypertrm had the device open -- jmazner
        return IDS_NODEVICE;

    case ERROR_BUFFER_INVALID:              // bad/empty rasdilap struct
    case ERROR_BUFFER_TOO_SMALL:            // ditto?
    case ERROR_CANNOT_FIND_PHONEBOOK_ENTRY: // if connectoid name in registry is wrong
    case ERROR_INTERACTIVE_MODE:
        return IDS_TCPINSTALLERROR;

    case ERROR_AUTHENTICATION_FAILURE:      // get this on actual CHAP reject
        return IDS_AUTHFAILURE;

    case ERROR_VOICE_ANSWER:
    case ERROR_NO_CARRIER:
    case ERROR_PPP_TIMEOUT:                 // get this on CHAP timeout
    case ERROR_REMOTE_DISCONNECTION:        // Ascend drops connection on auth-fail
    case ERROR_AUTH_INTERNAL:               // got this on random POP failure
    case ERROR_PROTOCOL_NOT_CONFIGURED:     // get this if LCP fails
    case ERROR_PPP_NO_PROTOCOLS_CONFIGURED: // get this if IPCP addr download gives garbage
        return IDS_PPPRANDOMFAILURE;
    }
    return 0;
}

void GetDialErrorString(DWORD dwError, LPWSTR pszBuffer, DWORD dwLength)
{
    DWORD dwRes;

    dwRes = RasErrorToIDS(dwError);

    if(dwRes) {

        // we have a resource - use it
        LoadStringWrapW(GlobalDllHandle, dwRes, pszBuffer, dwLength);

    } else {

        // couldn't get ras error, try system error
        if(0 == FormatMessageWrapW(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, pszBuffer, dwLength, NULL)) {

            // couldn't get system error, get system error E_FAIL == Unknown error
            FormatMessageWrapW(FORMAT_MESSAGE_FROM_SYSTEM, NULL, E_FAIL, 0, pszBuffer, dwLength, NULL);
        }
    }
}

void SetDialError(HWND hDlg, DWORD dwError)
{
    WCHAR szBuf[200];

    GetDialErrorString(dwError, szBuf, 200);
    PostString(hDlg, szBuf);
}

BOOL
FindDialProvider(
    IN  LPWSTR      pwzConnectoid,
    IN  LPWSTR      pwzProviderType,
    OUT CLSID *     pclsid
    )
//
// FindDialProvider - find an engine, UI, or branding provider for a
// specific connectoid
//
{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "FindDialProvider",
                 "%#x (%Q), %#x (%Q), %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 pwzProviderType,
                 pwzProviderType,
                 pclsid
                 ));

    WCHAR szKey[MAX_PATH];
    WCHAR szClsid[64];
    DWORD dwSize;

    // get the key for the connectoid
    GetConnKeyW(pwzConnectoid, szKey, ARRAYSIZE(szKey));

    // read the CLSID string
    dwSize = sizeof(szClsid);
    if(ERROR_SUCCESS != SHGetValueW(
            HKEY_CURRENT_USER,
            szKey,
            pwzProviderType,
            NULL,
            szClsid,
            &dwSize))
    {
        // no provider specified
        DEBUG_PRINT(DIALUP, INFO, ("No provider found.\n"));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    // covert string to clsid
    if(FAILED(CLSIDFromString(szClsid, pclsid)))
    {
        DEBUG_PRINT(DIALUP, INFO, ("Unable to convert clsid.\n"));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    DEBUG_LEAVE(TRUE);
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
// Public APIs
//
//////////////////////////////////////////////////////////////////////////////


INTERNETAPI InternetGetDialEngineW(
    IN LPWSTR               pwzConnectoid,
    IN IDialEventSink *     pdes,
    OUT IDialEngine **      ppde
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Dword,
                 "InternetGetDialEngineW",
                 "%#x (%Q), %#x, %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 pdes,
                 ppde
                 ));

    HRESULT hr;
    CLSID   clsid;

    *ppde = NULL;

    //
    // find engine we're going to use
    //
    if(FindDialProvider(pwzConnectoid, L"DialEngine", &clsid))
    {
        // engine specified, try to create it
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                IID_IDialEngine, (void **)ppde);
    }

    if(NULL == *ppde)
    {
        // use default engine
        CDialEngine * pEngine = new CDialEngine();
        if(pEngine)
        {
            hr = pEngine->QueryInterface(IID_IDialEngine, (void **)ppde);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if(SUCCEEDED(hr))
    {
        hr = (*ppde)->Initialize(pwzConnectoid, pdes);

        if(FAILED(hr))
        {
            (*ppde)->Release();
            *ppde = NULL;
        }
    }

    DEBUG_LEAVE_API(hr);
    return hr;
}

#if 0
//
// [darrenmi 4/14/00] cleaning up exports of incomplete feature
//

INTERNETAPI InternetGetDialBrandingW(
    IN LPWSTR               pwzConnectoid,
    OUT IDialBranding **    ppdb
    )
{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Dword,
                 "InternetGetDialBrandingW",
                 "%#x (%Q), %#x",
                 pwzConnectoid,
                 pwzConnectoid,
                 ppdb
                 ));

    HRESULT hr = S_FALSE;
    CLSID   clsid;

    *ppdb = NULL;

    //
    // find engine we're going to use
    //
    if(FindDialProvider(pwzConnectoid, L"DialBranding", &clsid))
    {
        // engine specified, try to create it
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                IID_IDialBranding, (void **)ppdb);
    }

    if(SUCCEEDED(hr))
    {
        hr = (*ppdb)->Initialize(pwzConnectoid);
        if(FAILED(hr))
        {
            (*ppdb)->Release();
            *ppdb = NULL;
        }
    }

    DEBUG_LEAVE_API(hr);
    return hr;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\inetapiu.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.cxx

Abstract:

    Contains WinInet API utility & sub-API functions

    Contents:
        wInternetQueryDataAvailable

Author:

    Richard L Firth (rfirth) 16-Feb-1996

Environment:

    Win32 user-level

Revision History:

    16-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>
#include "inetapiu.h"

DWORD
InbLocalEndCacheWrite(
    IN HINTERNET hFtpFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

DWORD
InbGopherLocalEndCacheWrite(
    IN HINTERNET hGopherFile,
    IN LPSTR    lpszFileExtension,
    IN BOOL fNormal
    );

//
// functions
//


BOOL
wInternetQueryDataAvailable(
    IN LPVOID hFileMapped,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Part 2 of InternetQueryDataAvailabe. This function is called by the async
    worker thread in order to resume InternetQueryDataAvailable(), and by the
    app as the worker part of the API, post validation

    We can query available data for handle types that return data, either from
    a socket, or from a cache file:

        - HTTP request
        - FTP file
        - FTP find
        - FTP find HTML
        - gopher file
        - gopher find
        - gopher find HTML

Arguments:

    hFileMapped                 - the mapped HINTERNET

    lpdwNumberOfBytesAvailable  - where the number of bytes is returned

    dwFlags                     - flags controlling operation

    dwContext                   - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_INET,
                Bool,
                "wInternetQueryDataAvailable",
                "%#x, %#x, %#x, %#x",
                hFileMapped,
                lpdwNumberOfBytesAvailable,
                dwFlags,
                dwContext
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    HINTERNET_HANDLE_TYPE handleType;

    INET_ASSERT(hFileMapped);

    //
    // as usual, grab the per-thread info block
    //

    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this is the async worker thread then set the context, handle, and
    // last-error info in the per-thread data block before we go any further
    // (we already did this on the sync path)
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        _InternetSetContext(lpThreadInfo,
                            ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetContext()
                            );
        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle(),
                                 hFileMapped
                                 );
        _InternetClearLastError(lpThreadInfo);

        //
        // we should only be here in async mode if there was no data immediately
        // available
        //

        INET_ASSERT(!((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable());

    }

    //
    // get the local handle for FTP & gopher
    //

    HINTERNET hLocal;

    error = RGetLocalHandle(hFileMapped, &hLocal);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we copy the number of bytes available to a local variable first, and
    // only update the caller's variable if we succeed
    //

    DWORD bytesAvailable;

    //
    // get the current data available, based on the handle type
    //

    switch (handleType = ((HANDLE_OBJECT *)hFileMapped)->GetHandleType()) {
    case TypeHttpRequestHandle:
        error = ((HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped)
                    ->QueryDataAvailable(&bytesAvailable);
        break;

    case TypeFtpFileHandle:
    case TypeFtpFindHandle:
        error = wFtpQueryDataAvailable(hLocal, &bytesAvailable);
        break;

    case TypeGopherFileHandle:
    case TypeGopherFindHandle:
        error = wGopherQueryDataAvailable(hLocal, &bytesAvailable);
        break;

    case TypeFtpFindHandleHtml:
    case TypeGopherFindHandleHtml:
        error = QueryHtmlDataAvailable(hFileMapped, &bytesAvailable);
        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                    IsCacheWriteInProgress()) {
            DWORD errorCache = error;

            if ((errorCache == ERROR_SUCCESS) && (bytesAvailable == 0)) {
                errorCache = ERROR_NO_MORE_FILES;
            }
            if (errorCache != ERROR_SUCCESS) {
                if (handleType == TypeFtpFindHandleHtml) {
                    InbLocalEndCacheWrite(  hFileMapped,
                                            "htm",
                                            (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
                else {
                    InbGopherLocalEndCacheWrite(  hFileMapped,
                                                "htm",
                                                (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
            }
        }
        break;

#ifdef EXTENDED_ERROR_HTML

    case TypeFtpFileHandleHtml:
        error = QueryHtmlDataAvailable(hFileMapped, &bytesAvailable);
        break;

#endif

    default:
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        break;
    }

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->SetAvailableDataLength(bytesAvailable);
        *lpdwNumberOfBytesAvailable = bytesAvailable;
        success = TRUE;

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    bytesAvailable
                    ));

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                        lpdwNumberOfBytesAvailable,
                        bytesAvailable
                        ));

    } else {
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    SetLastError(error);

    DEBUG_LEAVE(success);

    return success;
}


STDAPI_(BOOL) ForceNexusLookupExW(
    IN BOOL             fForce,
    IN PWSTR            pwszRegUrl,    // user supplied buffer ...
    IN OUT PDWORD       pdwRegUrlLen,  // ... and length (will be updated to actual length 
                                    // on successful return)
    IN PWSTR            pwszDARealm,    // user supplied buffer ...
    IN OUT PDWORD       pdwDARealmLen  // ... and length (will be updated to actual length 
                                    // on successful return)
    )
{
    PP_CONTEXT hPP = 0; 

    hPP = ::PP_InitContext(L"WinInet.Dll", NULL); 
    
    BOOL RetVal = ::PP_ForceNexusLookup (hPP, 
                                         fForce,
                                         pwszRegUrl, 
                                         pdwRegUrlLen, 
                                         pwszDARealm, 
                                         pdwDARealmLen );

    ::PP_FreeContext ( hPP );

    return RetVal;
    
}

STDAPI_(VOID) ForceNexusLookup(void)
{
    PP_CONTEXT hPP = 0; 

    hPP = ::PP_InitContext(L"WinInet.Dll", NULL); 
    
    ::PP_ForceNexusLookup (hPP,
                           FALSE, // don't force connection establishment if nexus not reachable
                           NULL, 
                           0, 
                           NULL, 
                           0 );

    ::PP_FreeContext ( hPP );
}


BOOL 
GetMD5Result(PSTR pszChallengeInfo, PSTR pszPassword, PBYTE pbHexHash);


///////////////
// This routine gets the default passport password and does an MD5 hash of it with
// the supplied ChallengeInfo and returns the result in hex string format.  
//
// pwszRealm = realm to get the password for.  If NULL, uses default.  Ignored if pwszTarget is not null.
//
// pwszTarget = target to get the password for.  If NULL, uses realm
//
// pbHexHash = output buffer to receive the MD5 result in hex string format, 
//             MUST BE AT LEAST MD5DIGESTLEN * 2 + 1 IN SIZE
//
// Returns TRUE if success, FALSE if failure.
//
// 

STDAPI_(BOOL) CreateMD5SSOHash ( 
	IN PWSTR    pszChallengeInfo,
	IN PWSTR    pwszRealm,
	IN PWSTR    pwszTarget,
	OUT PBYTE   pbHexHash
)
{
    PP_CONTEXT hPP = 0; 
	BOOL bRetVal = FALSE;

    hPP = ::PP_InitContext(L"WinInet.Dll", NULL); 

	if ( hPP )
	{
		WCHAR pszPassword[INTERNET_MAX_PASSWORD_LENGTH];

		// Check for cached creds in the session 
		if (::PP_GetCachedCredential ( hPP, pwszRealm, pwszTarget, NULL, pszPassword) )
		{
			DWORD dwChallengeInfoLen = wcslen(pszChallengeInfo) + 1;
			PSTR pszChallengeInfoA = (PSTR) LocalAlloc (LPTR, dwChallengeInfoLen );

			DWORD dwPasswordLen = wcslen(pszPassword) + 1;
			PSTR pszPasswordA = (PSTR) LocalAlloc (LPTR, dwPasswordLen );

			if ( pszChallengeInfoA != NULL && pszPasswordA != NULL )
			{
				// convert to asci
				::WideCharToMultiByte(CP_ACP, 0, pszChallengeInfo, -1, pszChallengeInfoA, dwChallengeInfoLen, NULL, NULL);
				::WideCharToMultiByte(CP_ACP, 0, pszPassword, -1, pszPasswordA, dwPasswordLen, NULL, NULL);

				bRetVal = GetMD5Result ( pszChallengeInfoA, pszPasswordA, pbHexHash );

				ZeroMemory ( pszPassword, INTERNET_MAX_PASSWORD_LENGTH * sizeof(WCHAR) );
				ZeroMemory ( pszPasswordA, dwPasswordLen );

			}
	
		    if ( pszChallengeInfoA )
				LocalFree ( pszChallengeInfoA );
			if ( pszPasswordA )
				LocalFree ( pszPasswordA );
		}

		::PP_FreeContext ( hPP );
	}

	return bRetVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\inetapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapiw.cxx

Abstract:

    Contains the wide-character Internet APIs

    Contents:
        InternetCrackUrlW
        InternetCreateUrlW
        InternetCanonicalizeUrlW
        InternetCombineUrlW
        InternetOpenW
        InternetConnectW
        InternetOpenUrlW
        InternetReadFileExW
        InternetWriteFileExW
        InternetFindNextFileW
        InternetQueryOptionW
        InternetSetOptionW
        InternetGetLastResponseInfoW
        InternetSetStatusCallbackW

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

//  because wininet doesnt know about IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

extern BOOL TransformFtpFindDataToW(LPWIN32_FIND_DATAA pfdA, LPWIN32_FIND_DATAW pfdW);
extern BOOL TransformGopherFindDataToW(LPGOPHER_FIND_DATAA pgfdA, LPGOPHER_FIND_DATAW pgfdW);

// -- FixStrings ------

//  Used in InternetCrackUrlW only.
//  Either
//  (a) If we have an ansi string, AND a unicode buffer, convert from ansi to unicode
//  (b) If we have an ansi string, but NO unicode buffer, determine where the ansi string
//         occurs in the unicode URL, and point the component there.

VOID
FixStrings(    
    LPSTR& pszA, 
    DWORD cbA, 
    LPWSTR& pszW, 
    DWORD& ccW, 
    LPSTR pszUrlA, 
    LPCWSTR pszUrlW)
{
    if (!pszA)
        return;

    if (pszW) 
    {
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA+1, pszW, ccW) - 1; 
    } 
    else 
    { 
        pszW = (LPWSTR)(pszUrlW + MultiByteToWideChar(CP_ACP, 0, 
                pszUrlA, (int) (pszA-pszUrlA), NULL, 0)); 
        ccW = MultiByteToWideChar(CP_ACP, 0, pszA, cbA, NULL, 0); 
    } 
}

//
// functions
//


INTERNETAPI_(BOOL) InternetCrackUrlW(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW pUCW
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    pszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if pszUrl is ASCIIZ string, else length of pszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCrackUrlW",
                     "%wq, %#x, %#x, %#x",
                     pszUrlW,
                     dwUrlLengthW,
                     dwFlags,
                     pUCW
                     ));

    INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    BOOL fContinue;
    DWORD c;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!(pszUrlW && pUCW))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    UCA.dwStructSize = sizeof(URL_COMPONENTSA); 
    ALLOC_MB(pszUrlW, dwUrlLengthW, mpUrlA);
    if (!mpUrlA.psStr) {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI(pszUrlW, mpUrlA);

    for (c=0; c<=5; c++) {
        LPWSTR pszWorker;
        DWORD ccLen;
        MEMORYPACKET* pmpWorker;
        
        switch(c)
        {
        case 0:
            pszWorker = pUCW->lpszScheme;
            ccLen = pUCW->dwSchemeLength;
            pmpWorker = &mpScheme;
            break;

        case 1:
            pszWorker = pUCW->lpszHostName;
            ccLen = pUCW->dwHostNameLength;
            pmpWorker = &mpHostName;
            break;

        case 2:
            pszWorker = pUCW->lpszUserName;
            ccLen = pUCW->dwUserNameLength;
            pmpWorker = &mpUserName;
            break;

        case 3:
            pszWorker = pUCW->lpszPassword;
            ccLen = pUCW->dwPasswordLength;
            pmpWorker = &mpPassword;
            break;

        case 4:
            pszWorker = pUCW->lpszUrlPath;
            ccLen = pUCW->dwUrlPathLength;
            pmpWorker = &mpUrlPath;
            break;

        case 5:
            pszWorker = pUCW->lpszExtraInfo;
            ccLen = pUCW->dwExtraInfoLength;
            pmpWorker = &mpExtraInfo;
            break;
        }

        if (pszWorker) { 
            ALLOC_MB(pszWorker,ccLen,(*pmpWorker)); 
            if (!pmpWorker->psStr) {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        } else { 
            pmpWorker->dwAlloc = ccLen; 
        }
    };

    REASSIGN_ALLOC(mpScheme,UCA.lpszScheme,UCA.dwSchemeLength);
    REASSIGN_ALLOC(mpHostName, UCA.lpszHostName,UCA.dwHostNameLength);
    REASSIGN_ALLOC(mpUserName, UCA.lpszUserName,UCA.dwUserNameLength);
    REASSIGN_ALLOC(mpPassword,UCA.lpszPassword,UCA.dwPasswordLength);
    REASSIGN_ALLOC(mpUrlPath,UCA.lpszUrlPath,UCA.dwUrlPathLength);
    REASSIGN_ALLOC(mpExtraInfo,UCA.lpszExtraInfo,UCA.dwExtraInfoLength);
                
    fResult = InternetCrackUrlA(mpUrlA.psStr, mpUrlA.dwSize, dwFlags, &UCA);
    if (fResult) {
        FixStrings(UCA.lpszScheme, UCA.dwSchemeLength, pUCW->lpszScheme, 
                    pUCW->dwSchemeLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszHostName, UCA.dwHostNameLength, pUCW->lpszHostName, 
                    pUCW->dwHostNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUserName, UCA.dwUserNameLength, pUCW->lpszUserName, 
                    pUCW->dwUserNameLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszPassword, UCA.dwPasswordLength, pUCW->lpszPassword, 
                    pUCW->dwPasswordLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszUrlPath, UCA.dwUrlPathLength, pUCW->lpszUrlPath, 
                    pUCW->dwUrlPathLength, mpUrlA.psStr, pszUrlW);
        FixStrings(UCA.lpszExtraInfo, UCA.dwExtraInfoLength, pUCW->lpszExtraInfo, 
                    pUCW->dwExtraInfoLength, mpUrlA.psStr, pszUrlW);
        pUCW->nScheme = UCA.nScheme;
        pUCW->nPort = UCA.nPort;
        pUCW->dwStructSize = sizeof(URL_COMPONENTSW);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetCreateUrlW(
    IN LPURL_COMPONENTSW pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

Return Value:

    BOOL
        Success - URL written to pszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCreateUrlW",
                     "%#x, %#x, %#x, %#x",
                     pUCW,
                     dwFlags,
                     pszUrlW,
                     pdwUrlLengthW
                     ));

    // INET_ASSERT(pszUrlW);
    INET_ASSERT(pUCW);

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pdwUrlLengthW 
        || (pUCW==NULL)
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW))
        || (pszUrlW && IsBadWritePtr(pszUrlW, *pdwUrlLengthW*sizeof(WCHAR))))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW, *pdwUrlLengthW, mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    mpUrlA.dwSize = mpUrlA.dwAlloc;
    UCA.dwStructSize = sizeof(URL_COMPONENTSA);

    UCA.nScheme = pUCW->nScheme;
    UCA.nPort = pUCW->nPort;
    if (pUCW->lpszScheme)
    {
        ALLOC_MB(pUCW->lpszScheme, pUCW->dwSchemeLength, mpScheme);
        if (!mpScheme.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszScheme, mpScheme);
    }
    REASSIGN_SIZE(mpScheme, UCA.lpszScheme, UCA.dwSchemeLength);
    if (pUCW->lpszHostName)
    {
        ALLOC_MB(pUCW->lpszHostName, pUCW->dwHostNameLength, mpHostName);
        if (!mpHostName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszHostName, mpHostName);
    }
    REASSIGN_SIZE(mpHostName, UCA.lpszHostName, UCA.dwHostNameLength);
    if (pUCW->lpszUserName)
    {
        ALLOC_MB(pUCW->lpszUserName, pUCW->dwUserNameLength, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUserName, mpUserName);
    }
    REASSIGN_SIZE(mpUserName, UCA.lpszUserName, UCA.dwUserNameLength);
    if (pUCW->lpszPassword)
    {
        ALLOC_MB(pUCW->lpszPassword, pUCW->dwPasswordLength, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszPassword, mpPassword);
    }
    REASSIGN_SIZE(mpPassword, UCA.lpszPassword, UCA.dwPasswordLength);
    if (pUCW->lpszUrlPath)
    {
        ALLOC_MB(pUCW->lpszUrlPath, pUCW->dwUrlPathLength, mpUrlPath); 
        if (!mpUrlPath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUrlPath, mpUrlPath);
    }
    REASSIGN_SIZE(mpUrlPath, UCA.lpszUrlPath, UCA.dwUrlPathLength);
    if (pUCW->lpszExtraInfo)
    {
        ALLOC_MB(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength, mpExtraInfo);
        if (!mpExtraInfo.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszExtraInfo, mpExtraInfo);
    }
    REASSIGN_SIZE(mpExtraInfo, UCA.lpszExtraInfo, UCA.dwExtraInfoLength);
    fResult = InternetCreateUrlA(&UCA, dwFlags, mpUrlA.psStr, &mpUrlA.dwSize);
    if (fResult)
    {
        MAYBE_COPY_ANSI(mpUrlA, pszUrlW, *pdwUrlLengthW);
    }
    else
    {
        *pdwUrlLengthW = mpUrlA.dwSize*sizeof(WCHAR);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// implemented in inetapia.cxx
DWORD ICUHrToWin32Error(HRESULT);


INTERNETAPI_(BOOL) InternetCanonicalizeUrlW(
    IN LPCWSTR pszUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    pszUrl             - pointer to URL to be canonicalize

    pszBuffer          - pointer to buffer where new URL is written

    lpdwBufferLength    - size of buffer on entry, length of new URL on exit

    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlW",
                     "%wq, %#x, %#x [%d], %#x",
                     pszUrl,
                     pszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

//    We don't need no stinkin asserts
//    INET_ASSERT(pszUrl);
//    INET_ASSERT(pszBuffer);
//    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!pszUrl || !pszBuffer || !lpdwBufferLength 
        || IsBadWritePtr(lpdwBufferLength, sizeof(lpdwBufferLength))
        || *lpdwBufferLength == 0
        || IsBadWritePtr(pszBuffer, *lpdwBufferLength*sizeof(WCHAR))
        || IsBadStringPtrW(pszUrl, INTERNET_MAX_URL_LENGTH))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeW(pszUrl, pszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(INET, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    DEBUG_LEAVE_API(bRet);
    return bRet;
}


INTERNETAPI_(BOOL) InternetCombineUrlW(
    IN LPCWSTR pszBaseUrl,
    IN LPCWSTR pszRelativeUrl,
    OUT LPWSTR pszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    pszBaseUrl         - pointer to base URL

    pszRelativeUrl     - pointer to relative URL

    pszBuffer          - pointer to buffer where new URL is written

    lpdwBufferLength    - size of buffer on entry, length of new URL on exit

    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCombineUrlW",
                     "%wq, %wq, %#x, %#x [%d], %#x",
                     pszBaseUrl,
                     pszRelativeUrl,
                     pszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

//    We don't need no stinkin' asserts
//    INET_ASSERT(pszBaseUrl);
//    INET_ASSERT(pszRelativeUrl);
//    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!pszBaseUrl || !pszRelativeUrl || !lpdwBufferLength 
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (pszBuffer && IsBadWritePtr(pszBuffer, *lpdwBufferLength*sizeof(WCHAR)))
        || IsBadStringPtrW(pszBaseUrl, INTERNET_MAX_URL_LENGTH)
        || IsBadStringPtrW(pszRelativeUrl, INTERNET_MAX_URL_LENGTH))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineW(pszBaseUrl, pszRelativeUrl, pszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(INET, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    DEBUG_LEAVE_API(bRet);
    return bRet;
}


INTERNETAPI_(HINTERNET) InternetOpenW(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pszAgent       -

    dwAccessType    -

    pszProxy       -

    pszProxyBypass -

    dwFlags         -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenW",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpAgentA, mpProxyA, mpProxyBypassA;

    ALLOC_MB(pszAgentW,0,mpAgentA);
    if (!mpAgentA.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI(pszAgentW,mpAgentA);
    if (pszProxyW)
    {
        ALLOC_MB(pszProxyW,0,mpProxyA);
        if (!mpProxyA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszProxyW,mpProxyA);
    }
    if (pszProxyBypassW)
    {
        ALLOC_MB(pszProxyBypassW,0,mpProxyBypassA);
        if (!mpProxyBypassA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszProxyBypassW,mpProxyBypassA);
    }

    hInternet = InternetOpenA(mpAgentA.psStr, dwAccessType, mpProxyA.psStr, 
                                        mpProxyBypassA.psStr, dwFlags);

                                        
cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(HINTERNET) InternetConnectW(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR pszUserNameW,
    IN LPCWSTR pszPasswordW,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszServerName      -
    nServerPort         -
    pszUserName        -
    pszPassword        -
    dwService           -
    dwFlags             -
    dwContext           -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetConnectW",
                     "%#x, %wq, %d, %wq, %wq, %s (%d), %#08x, %#x",
                     hInternetSession,
                     pszServerNameW,
                     nServerPort,
                     pszUserNameW,
                     pszPasswordW,
                     InternetMapService(dwService),
                     dwService,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpServerNameA, mpUserNameA, mpPasswordA;
    HINTERNET hInternet = NULL;

    if (!pszServerNameW)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pszServerNameW, 0, mpServerNameA);
    if (!mpServerNameA.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pszServerNameW, mpServerNameA);
    if (pszUserNameW)
    {
        ALLOC_MB(pszUserNameW, 0, mpUserNameA);
        if (!mpUserNameA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszUserNameW, mpUserNameA);
    }
    if (pszPasswordW)
    {
        ALLOC_MB(pszPasswordW, 0, mpPasswordA);
        if (!mpPasswordA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszPasswordW, mpPasswordA);
    }
    hInternet = InternetConnectA(hInternetSession, mpServerNameA.psStr, nServerPort,
                                mpUserNameA.psStr, mpPasswordA.psStr, dwService, dwFlags, dwContext);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(HINTERNET) InternetOpenUrlW(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszUrlW,
    IN LPCWSTR pszHeadersW,
    IN DWORD dwHeadersLengthW,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszUrl             -
    pszHeaders         -
    dwHeadersLength     -
    dwFlags             -
    dwContext           -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenUrlW",
                     "%#x, %wq, %.80wq, %d, %#08x, %#x",
                     hInternetSession,
                     pszUrlW,
                     pszHeadersW,
                     dwHeadersLengthW,
                     dwFlags,
                     dwContext
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpHeadersA, mpUrlA;
    HINTERNET hInternet = NULL;
    
    if (!pszUrlW || (*pszUrlW==L'\0'))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(pszUrlW, 0, mpUrlA);
    if (!mpUrlA.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI(pszUrlW, mpUrlA);
    if (pszHeadersW)
    {
        ALLOC_MB(pszHeadersW, (dwHeadersLengthW==-1L? 0 : dwHeadersLengthW), mpHeadersA);
        if (!mpHeadersA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszHeadersW, mpHeadersA);
    }
    hInternet = InternetOpenUrlA(hInternetSession, mpUrlA.psStr, mpHeadersA.psStr, 
                                    mpHeadersA.dwSize, dwFlags, dwContext);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI_(BOOL) InternetReadFileExW(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSW lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(BOOL) InternetWriteFileExW(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSW lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(BOOL) InternetFindNextFileW(
    IN HINTERNET hFind,
    OUT LPVOID lpvFindData
    )

/*++

Routine Description:

    This function retrieves the next block of data from the server.
    Currently it supports the following protocol data :

    FtpFindNextFile
    GopherFindNext

Arguments:

    hFind       - handle that was obtained by a FindFirst call

    lpvFindData - pointer to buffer where the next block of data is copied

Return Value:

    TRUE if the function successfully returns next block of data.
    FALSE otherwise. GetLastError() will return the error code.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetFindNextFileW",
                     "%#x, %#x",
                     hFind,
                     lpvFindData
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hFindMapped;
    HINTERNET_HANDLE_TYPE handleType;
    BOOL fResult = FALSE;
    
    dwErr = MapHandleToAddress(hFind, (LPVOID *)&hFindMapped, FALSE);
    if (dwErr!=ERROR_SUCCESS)
    {
        goto cleanup;
    }
    dwErr = RGetHandleType(hFindMapped, &handleType);
    DereferenceObject(hFindMapped);
    if (dwErr!=ERROR_SUCCESS)
    {
        goto cleanup;
    }
    if ((handleType != TypeFtpFindHandle) && (handleType != TypeGopherFindHandle))
    {
        dwErr = ERROR_INTERNET_INVALID_OPERATION;
        goto cleanup;
    }

    if (handleType == TypeFtpFindHandle)
    {
        WIN32_FIND_DATAA fdA;
        dwErr = ProbeWriteBuffer(lpvFindData, sizeof(WIN32_FIND_DATAW));
        if (dwErr!=ERROR_SUCCESS) 
        {
            goto cleanup;
        }
        if (InternetFindNextFileA(hFind,(LPVOID)&fdA))
            fResult = TransformFtpFindDataToW(&fdA,(LPWIN32_FIND_DATAW)lpvFindData);
    }
    else
    {
        GOPHER_FIND_DATAA gfdA;
        dwErr = ProbeWriteBuffer(lpvFindData, sizeof(GOPHER_FIND_DATAW));
        if (dwErr!=ERROR_SUCCESS) 
        {
            goto cleanup;
        }
        if (InternetFindNextFileA(hFind,(LPVOID)&gfdA))
            fResult = TransformGopherFindDataToW(&gfdA,(LPGOPHER_FIND_DATAW)lpvFindData);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetGetLastResponseInfoW(
    OUT LPDWORD lpdwErrorCategory,
    IN LPWSTR pszBufferW,
    IN OUT LPDWORD lpdwBufferLengthW
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    lpdwErrorCategory   -
    pszBuffer          -
    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoW",
                     "%#x, %ws, %#x [%d]",
                     lpdwErrorCategory,
                     pszBufferW,
                     lpdwBufferLengthW,
                     lpdwBufferLengthW ? *lpdwBufferLengthW : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBufferA;

    if (pszBufferW)
    {
        ALLOC_MB(pszBufferW,*lpdwBufferLengthW,mpBufferA);
        if (!mpBufferA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
        
    mpBufferA.dwSize = mpBufferA.dwAlloc;
    fResult = InternetGetLastResponseInfoA(lpdwErrorCategory, mpBufferA.psStr,
                                            &mpBufferA.dwSize);
    if (fResult) {
        MAYBE_COPY_ANSI(mpBufferA, pszBufferW, *lpdwBufferLengthW);
    } else {
        *lpdwBufferLengthW = mpBufferA.dwSize*sizeof(WCHAR);
    }

cleanup:    
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetCheckConnectionW(
    IN      LPCWSTR   pszUrlW,
    IN      DWORD   dwFlags,
    IN      DWORD   dwReserved
)

/*++

Routine Description:

    This routine tells the caller whether he can establish a connection to the
    network.


Arguments:

    pszUrl     this parameter is an indication to the API to attempt
                a specific host. The use of this parameter is based on the
                flags set in the dwFlags parameter

    dwFlags     a bitwise OR of the following flags

                    INTERNET_FLAG_ICC_FORCE_CONNECTION - force a connection if
                    cannot find one already established

                    INTERNET_FLAG_ICC_CONNECT_SPECIFIC_HOST - try the connection
                    to the specific host. If this flag is not set then the
                    host name is used if a quicker method is not avilable.

    dwReserved  reserved

Return Value:

    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCheckConnectionW",
                     "%ws %x",
                     pszUrlW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlA;
    BOOL fResult = FALSE;
    
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW,0,mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszUrlW,mpUrlA);
    }
    fResult = InternetCheckConnectionA(mpUrlA.psStr, dwFlags, dwReserved);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackCore(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback,
    IN BOOL fType
    );

INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackW(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Pointer,
                 "InternetSetStatusCallbackW",
                 "%#x, %#x",
                 hInternet,
                 lpfnInternetCallback
                 ));

    INTERNET_STATUS_CALLBACK pfn = InternetSetStatusCallbackCore(hInternet,lpfnInternetCallback,TRUE);

    DEBUG_LEAVE(pfn);
    return pfn;
}

#ifdef IGCURLW
INTERNETAPI_(BOOL) InternetGetCertByURLW(
    IN LPWSTR     lpszURL,
    IN OUT LPWSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
    return InternetGetCertByURLA(lpszURL,lpszCertText,dwcbCertText);
}

#endif

INTERNETAPI_(BOOL) InternetShowSecurityInfoByURLW(
    IN LPWSTR    pszUrlW,
    IN HWND      hwndRootWindow
    )
/*++

Routine Description:

    Does a high-level lookup against the Certificate Cache.
    Searches by URL (broken down into hostname) for the Certificate,
    and returns it in a formatted (&localized) string.

Arguments:

    lpszUrl         - pointer to URL to crack

    lpszCertText    - Output of formatted certifcate

    dwcbCertText    - Size of lpszCertText

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_INET,
                 Bool,
                 "InternetShowSecurityInfoW",
                 "%wq, %#x",
                 pszUrlW,
                 hwndRootWindow
                 ));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlA;
    
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW,0,mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pszUrlW,mpUrlA);
    }
    fResult = InternetShowSecurityInfoByURLA(mpUrlA.psStr, hwndRootWindow);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

INTERNETAPI_(BOOL) InternetAlgIdToStringW(
    IN ALG_ID       ai,
    IN LPWSTR       lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a algid to a user-displayable string.

Arguments:
    
    ai - Algorithm identifiers ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)
    
    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetAlgIdToStringW",
                     "%#x, %wq, %#x, %#x",
                     ai,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    if (dwReserved!=0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (lpstr)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwstrLength;
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));

        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (InternetAlgIdToStringA(ai, (LPSTR)mpBuffer.psStr, &mpBuffer.dwSize, dwReserved))
    {
        *lpdwstrLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                      NULL, 0);
        if (*lpdwstrLength*sizeof(WCHAR) <= mpBuffer.dwAlloc && lpstr)
        {
            MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                    lpstr, *lpdwstrLength);
            (*lpdwstrLength)--;
            fResult = TRUE;
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else 
    {
        dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            *lpdwstrLength = mpBuffer.dwSize * sizeof(WCHAR);
        }
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSecurityProtocolToStringW(
    IN DWORD        dwProtocol,
    IN LPWSTR       lpstr,
    IN OUT LPDWORD  lpdwstrLength,
    IN DWORD        dwReserved /* Must be 0 */
    )
/*++

Routine Description:

    Converts a security protocol to a user-displayable string.

Arguments:
    
    dwProtocol - Security protocol identifier ( defined in wincrypt.h)

    lpstr - Buffer to copy string into.

    lpdwstrLength - pass in num of characters, return no of characters copied if successful,
                       else no of chars required (including null terminator)
    
    dwReserved = Must be 0

Return Value:
    DWORD
        Win32 or WININET error code.
--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSecurityProtocolToStringW",
                     "%d, %wq, %#x, %#x",
                     dwProtocol,
                     lpstr,
                     lpdwstrLength,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    if (dwReserved!=0)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (lpstr)
    {
        mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwstrLength;
        mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    if (InternetSecurityProtocolToStringA(dwProtocol, (LPSTR)mpBuffer.psStr, &mpBuffer.dwSize, dwReserved))
    {
        *lpdwstrLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                      NULL, 0);
        if (*lpdwstrLength*sizeof(WCHAR) <= mpBuffer.dwAlloc && lpstr)
        {
            MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                    lpstr, *lpdwstrLength);
            (*lpdwstrLength)--;
            fResult = TRUE;
        }
        else
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else 
    {
        dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER)
        {
            *lpdwstrLength = mpBuffer.dwSize * sizeof(WCHAR);
        }
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\inetapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapia.cxx

Abstract:

    Contains the ANSI and character-mode-independent Internet APIs

    Contents:
        InternetCrackUrlA
        InternetCreateUrlA
        InternetCanonicalizeUrlA
        InternetCombineUrlA
        InternetOpenA
        InternetCloseHandle
        _InternetCloseHandle
        _InternetCloseHandleNoContext
        InternetConnectA
        InternetOpenUrlA
        InternetReadFile
        ReadFile_End
        InternetReadFileExA
        InternetWriteFile
        InternetWriteFileExA
        InternetSetFilePointer
        InternetQueryDataAvailable
        InternetFindNextFileA
        InternetQueryOptionA
        InternetSetOptionA
        InternetSetOptionExA
        InternetGetLastResponseInfoA
        InternetSetStatusCallbackA
        //InternetCancelAsyncRequest
        (wInternetCloseConnectA)
        (GetEmailNameAndPassword)
        InternetAttemptConnect
        (CreateDeleteSocket)
        InternetLockRequestFile
        InternetUnlockRequestFile
        InternetCheckConnectionA

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana


--*/


#include <wininetp.h>
#include <perfdiag.hxx>
#include "inetapiu.h"

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>

#include "autodial.h"

//
// public ..?
//

extern "C" {

INTERNETAPI_(BOOL) InternetGetCertByURLA(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    );

}


//
// private manifests
//

//
// private prototypes
//

PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    );

PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    );

PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    );

PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    );


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET lpConnectHandle,
    IN DWORD ServiceType
    );

PRIVATE
DWORD
GetEmailNameAndPassword(
    IN OUT LPSTR* lplpszUserName,
    IN OUT LPSTR* lplpszPassword,
    OUT LPSTR lpszEmailName,
    IN DWORD dwEmailNameLength
    );

PRIVATE
BOOL
InternetParseCommon(
    IN LPCTSTR lpszBaseUrl,
    IN LPCTSTR lpszRelativeUrl,
    OUT LPTSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );

//PRIVATE
//DWORD
//CreateDeleteSocket(
//    VOID
//    );

BOOL
GetWininetUserName(
    VOID
);



//
// functions
//


INTERNETAPI_(BOOL) InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCrackUrlA",
                     "%q, %#x, %#x, %#x",
                     lpszUrl,
                     dwUrlLength,
                     dwFlags,
                     lpUrlComponents
                     ));

    DWORD error;

    //
    // validate parameters
    //

    if (ARGUMENT_PRESENT(lpszUrl)) {
        if (dwUrlLength == 0) {
            error = ProbeString((LPSTR)lpszUrl, &dwUrlLength);
        } else {
            error = ProbeReadBuffer((LPVOID)lpszUrl, dwUrlLength);
        }
    } else {
        error = ERROR_INVALID_PARAMETER;
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    if ((lpUrlComponents == NULL)
    || (lpUrlComponents->dwStructSize != sizeof(*lpUrlComponents))) {
        error = ERROR_INVALID_PARAMETER;
    } else {
        error = ProbeWriteBuffer((LPVOID)lpUrlComponents,
                                 sizeof(*lpUrlComponents)
                                 );
    }
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only allow two flags for this API
    //

    if (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }
    
    if (!GlobalDataInitialized) 
    {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) 
        {
            goto quit;
        }
    }

    //
    // get the individual components to return. If they reference a buffer then
    // check it for writeability
    //

    LPSTR lpUrl;
    LPSTR urlCopy;
    INTERNET_SCHEME schemeType;
    LPSTR schemeName;
    DWORD schemeNameLength;
    LPSTR hostName;
    DWORD hostNameLength;
    INTERNET_PORT nPort;
    LPSTR userName;
    DWORD userNameLength;
    LPSTR password;
    DWORD passwordLength;
    LPSTR urlPath;
    DWORD urlPathLength;
    LPSTR extraInfo;
    DWORD extraInfoLength;
    BOOL copyComponent;
    BOOL havePort;

    copyComponent = FALSE;

    schemeName = lpUrlComponents->lpszScheme;
    schemeNameLength = lpUrlComponents->dwSchemeLength;
    if ((schemeName != NULL) && (schemeNameLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)schemeName, schemeNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *schemeName = '\0';
        copyComponent = TRUE;
    }

    hostName = lpUrlComponents->lpszHostName;
    hostNameLength = lpUrlComponents->dwHostNameLength;
    if ((hostName != NULL) && (hostNameLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)hostName, hostNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *hostName = '\0';
        copyComponent = TRUE;
    }

    userName = lpUrlComponents->lpszUserName;
    userNameLength = lpUrlComponents->dwUserNameLength;
    if ((userName != NULL) && (userNameLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)userName, userNameLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *userName = '\0';
        copyComponent = TRUE;
    }

    password = lpUrlComponents->lpszPassword;
    passwordLength = lpUrlComponents->dwPasswordLength;
    if ((password != NULL) && (passwordLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)password, passwordLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *password = '\0';
        copyComponent = TRUE;
    }

    urlPath = lpUrlComponents->lpszUrlPath;
    urlPathLength = lpUrlComponents->dwUrlPathLength;
    if ((urlPath != NULL) && (urlPathLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)urlPath, urlPathLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *urlPath = '\0';
        copyComponent = TRUE;
    }

    extraInfo = lpUrlComponents->lpszExtraInfo;
    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
    if ((extraInfo != NULL) && (extraInfoLength != 0)) {
        error = ProbeWriteBuffer((LPVOID)extraInfo, extraInfoLength);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        *extraInfo = '\0';
        copyComponent = TRUE;
    }

    //
    // we can only escape or decode the URL if the caller has provided us with
    // buffers to write the escaped strings into
    //

    if (dwFlags & (ICU_ESCAPE | ICU_DECODE)) {
        if (!copyComponent) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }

        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        urlCopy = NewString((LPSTR)lpszUrl, dwUrlLength);
        if (urlCopy == NULL) {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        lpUrl = urlCopy;
    } else {
        lpUrl = (LPSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     (dwFlags & ICU_ESCAPE) ? TRUE : FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     extraInfoLength ? &extraInfo : NULL,
                     extraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto crack_error;
    }

    BOOL copyFailure;

    copyFailure = FALSE;

    //
    // update the URL_COMPONENTS structure based on the results, and what was
    // asked for
    //

    if (lpUrlComponents->lpszScheme != NULL) {
        if (lpUrlComponents->dwSchemeLength > schemeNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszScheme,
                   (LPVOID)schemeName,
                   schemeNameLength
                   );
            lpUrlComponents->lpszScheme[schemeNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszScheme, 0);
            }
        } else {
            ++schemeNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    } else if (lpUrlComponents->dwSchemeLength != 0) {
        lpUrlComponents->lpszScheme = schemeName;
        lpUrlComponents->dwSchemeLength = schemeNameLength;
    }

    if (lpUrlComponents->lpszHostName != NULL) {
        if (lpUrlComponents->dwHostNameLength > hostNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszHostName,
                   (LPVOID)hostName,
                   hostNameLength
                   );
            lpUrlComponents->lpszHostName[hostNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszHostName, 0);
            }
        } else {
            ++hostNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwHostNameLength = hostNameLength;
    } else if (lpUrlComponents->dwHostNameLength != 0) {
        lpUrlComponents->lpszHostName = hostName;
        lpUrlComponents->dwHostNameLength = hostNameLength;
    }

    if (lpUrlComponents->lpszUserName != NULL) {
        if (lpUrlComponents->dwUserNameLength > userNameLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUserName,
                   (LPVOID)userName,
                   userNameLength
                   );
            lpUrlComponents->lpszUserName[userNameLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUserName, 0);
            }
        } else {
            ++userNameLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwUserNameLength = userNameLength;
    } else if (lpUrlComponents->dwUserNameLength != 0) {
        lpUrlComponents->lpszUserName = userName;
        lpUrlComponents->dwUserNameLength = userNameLength;
    }

    if (lpUrlComponents->lpszPassword != NULL) {
        if (lpUrlComponents->dwPasswordLength > passwordLength) {
            memcpy((LPVOID)lpUrlComponents->lpszPassword,
                   (LPVOID)password,
                   passwordLength
                   );
            lpUrlComponents->lpszPassword[passwordLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszPassword, 0);
            }
        } else {
            ++passwordLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwPasswordLength = passwordLength;
    } else if (lpUrlComponents->dwPasswordLength != 0) {
        lpUrlComponents->lpszPassword = password;
        lpUrlComponents->dwPasswordLength = passwordLength;
    }

    if (lpUrlComponents->lpszUrlPath != NULL) {
        if(schemeType == INTERNET_SCHEME_FILE)
        {
            //
            //  for file: urls we return the path component
            //  as a valid dos path.
            //

            copyFailure = FAILED(PathCreateFromUrl(lpUrl, lpUrlComponents->lpszUrlPath, &(lpUrlComponents->dwUrlPathLength), 0));
        }
        else if (lpUrlComponents->dwUrlPathLength > urlPathLength) {
            memcpy((LPVOID)lpUrlComponents->lpszUrlPath,
                   (LPVOID)urlPath,
                   urlPathLength
                   );
            lpUrlComponents->lpszUrlPath[urlPathLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszUrlPath, 0);
            }
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        } else {
            ++urlPathLength;
            copyFailure = TRUE;
            lpUrlComponents->dwUrlPathLength = urlPathLength;
        }
    } else if (lpUrlComponents->dwUrlPathLength != 0) {
        lpUrlComponents->lpszUrlPath = urlPath;
        lpUrlComponents->dwUrlPathLength = urlPathLength;
    }

    if (lpUrlComponents->lpszExtraInfo != NULL) {
        if (lpUrlComponents->dwExtraInfoLength > extraInfoLength) {
            memcpy((LPVOID)lpUrlComponents->lpszExtraInfo,
                   (LPVOID)extraInfo,
                   extraInfoLength
                   );
            lpUrlComponents->lpszExtraInfo[extraInfoLength] = '\0';
            if (dwFlags & ICU_DECODE) {
                UrlUnescapeInPlace(lpUrlComponents->lpszExtraInfo, 0);
            }
        } else {
            ++extraInfoLength;
            copyFailure = TRUE;
        }
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    } else if (lpUrlComponents->dwExtraInfoLength != 0) {
        lpUrlComponents->lpszExtraInfo = extraInfo;
        lpUrlComponents->dwExtraInfoLength = extraInfoLength;
    }

    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //
    // N.B. Don't change error below here. If need be, move this test lower
    //

    if (copyFailure) {
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case INTERNET_SCHEME_FTP:
            nPort = INTERNET_DEFAULT_FTP_PORT;
            break;

        case INTERNET_SCHEME_GOPHER:
            nPort = INTERNET_DEFAULT_GOPHER_PORT;
            break;

        case INTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case INTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

crack_error:

    if (urlCopy != NULL) {
        DEL_STRING(urlCopy);
    }

quit:
    BOOL success = (error==ERROR_SUCCESS);

    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI_(BOOL) InternetCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl OPTIONAL,
    IN OUT LPDWORD lpdwUrlLength
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

    lpUrlComponents - pointer to URL_COMPONENTS structure containing pointers
                      and lengths of components of interest

    dwFlags         - flags controlling function:

                        ICU_ESCAPE  - the components contain characters that
                                      must be escaped in the output URL

    lpszUrl         - pointer to buffer where output URL will be written

    lpdwUrlLength   - IN: number of bytes in lpszUrl buffer
                      OUT: if success, number of characters in lpszUrl, else
                           number of bytes required for buffer

Return Value:

    BOOL
        Success - URL written to lpszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCreateUrlA",
                     "%#x, %#x, %#x, %#x",
                     lpUrlComponents,
                     dwFlags,
                     lpszUrl,
                     lpdwUrlLength
                     ));

#if INET_DEBUG

    LPSTR lpszUrlOriginal = lpszUrl;

#endif

    DWORD error = ERROR_SUCCESS;
    LPSTR encodedUrlPath = NULL;
    LPSTR encodedExtraInfo = NULL;

    //
    // validate parameters
    //

    if ((lpUrlComponents == NULL)
    || (lpUrlComponents->dwStructSize != sizeof(*lpUrlComponents))
    || (dwFlags & ~(ICU_ESCAPE | ICU_USERNAME))
    || (lpdwUrlLength == NULL)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!ARGUMENT_PRESENT(lpszUrl)) {
        *lpdwUrlLength = 0;
    }

    //
    // allocate large buffers from heap
    //

    encodedUrlPath = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    encodedExtraInfo = (LPSTR)ALLOCATE_MEMORY(LMEM_FIXED, INTERNET_MAX_URL_LENGTH + 1);
    if ((encodedUrlPath == NULL) || (encodedExtraInfo == NULL)) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we get an exception, we return ERROR_INVALID_PARAMETER
    //

    __try {

        //
        // get the individual components to copy
        //

        LPSTR schemeName;
        DWORD schemeNameLength;
        DWORD schemeFlags;
        LPSTR hostName;
        DWORD hostNameLength;
        INTERNET_PORT nPort;
        DWORD portLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;
        LPSTR urlPath;
        DWORD urlPathLength;
        DWORD extraLength;
        DWORD encodedUrlPathLength;
        LPSTR extraInfo;
        DWORD extraInfoLength;
        DWORD encodedExtraInfoLength;
        LPSTR schemeSep;
        DWORD schemeSepLength;
        INTERNET_SCHEME schemeType;
        INTERNET_PORT defaultPort;

        //
        // if the scheme name is absent then we use the default
        //

        schemeName = lpUrlComponents->lpszScheme;
        schemeType = lpUrlComponents->nScheme;

        if (schemeName == NULL) {
            if (schemeType == INTERNET_SCHEME_DEFAULT){
                schemeName = DEFAULT_URL_SCHEME_NAME;
                schemeNameLength = sizeof(DEFAULT_URL_SCHEME_NAME) - 1;
            }
            else {
                schemeName = MapUrlScheme(schemeType, &schemeNameLength);
            }
        } else {
            schemeNameLength = lpUrlComponents->dwSchemeLength;
            if (schemeNameLength == 0) {
                schemeNameLength = lstrlen(schemeName);
            }
        }

        //
        // doesn't have to be a host name
        //

        hostName = lpUrlComponents->lpszHostName;
        portLength = 0;
        if (hostName != NULL) {
            hostNameLength = lpUrlComponents->dwHostNameLength;
            if (hostNameLength == 0) {
                hostNameLength = lstrlen(hostName);
            }

        //
        // if the port is default then we don't add it to the URL, else we need to
        // copy it as a string
        //
        // there won't be a port unless there's host.

            schemeType = MapUrlSchemeName(schemeName, schemeNameLength ? schemeNameLength : -1);
            switch (schemeType) {
            case INTERNET_SCHEME_FTP:
                defaultPort = INTERNET_DEFAULT_FTP_PORT;
                break;

            case INTERNET_SCHEME_GOPHER:
                defaultPort = INTERNET_DEFAULT_GOPHER_PORT;
                break;

            case INTERNET_SCHEME_HTTP:
                defaultPort = INTERNET_DEFAULT_HTTP_PORT;
                break;

            case INTERNET_SCHEME_HTTPS:
                defaultPort = INTERNET_DEFAULT_HTTPS_PORT;
                break;

            default:
                defaultPort = INTERNET_INVALID_PORT_NUMBER;
                break;
            }

            if (lpUrlComponents->nPort != defaultPort) {

                INTERNET_PORT divisor;

                nPort = lpUrlComponents->nPort;
                if (nPort) {
                    divisor = 10000;
                    portLength = 6; // max is 5 characters, plus 1 for ':'
                    while ((nPort / divisor) == 0) {
                        --portLength;
                        divisor /= 10;
                    }
                } else {
                    portLength = 2;         // port is ":0"
                }
            }
        } else {
            hostNameLength = 0;
        }


        //
        // doesn't have to be a user name
        //

        userName = lpUrlComponents->lpszUserName;
        if (userName != NULL) {
            userNameLength = lpUrlComponents->dwUserNameLength;
            if (userNameLength == 0) {
                userNameLength = lstrlen(userName);
            }
        } else {

            //
            // BUGBUG - if ICU_USERNAME then we get the value from the registry
            //

            userNameLength = 0;
        }

        //
        // doesn't have to be a password
        //

        password = lpUrlComponents->lpszPassword;
        if (password != NULL) {
            passwordLength = lpUrlComponents->dwPasswordLength;
            if (passwordLength == 0) {
                passwordLength = lstrlen(password);
            }
        } else {

            //
            // BUGBUG - if ICU_USERNAME then we get the value from the registry
            //

            passwordLength = 0;
        }

        //
        // but if there's a password without a user name, then its an error
        //

        if (password && !userName) {
            error = ERROR_INVALID_PARAMETER;
        } else {

            //
            // determine the scheme type for possible uses below
            //

            schemeFlags = 0;
            if (strnicmp(schemeName, "http", schemeNameLength) == 0) {
                schemeFlags = SCHEME_HTTP;
            } else if (strnicmp(schemeName, "ftp", schemeNameLength) == 0) {
                schemeFlags = SCHEME_FTP;
            } else if (strnicmp(schemeName, "gopher", schemeNameLength) == 0) {
                schemeFlags = SCHEME_GOPHER;
            }

            //
            // doesn't have to be an URL-path. Empty string is default
            //

            urlPath = lpUrlComponents->lpszUrlPath;
            if (urlPath != NULL) {
                urlPathLength = lpUrlComponents->dwUrlPathLength;
                if (urlPathLength == 0) {
                    urlPathLength = lstrlen(urlPath);
                }
                if ((*urlPath != '/') && (*urlPath != '\\')) {
                    extraLength = 1;
                } else {
                    extraLength = 0;
                }

                //
                // if requested, we will encode the URL-path
                //

                if (dwFlags & ICU_ESCAPE) {

                    //
                    // only encode the URL-path if it's a recognized scheme
                    //

                    if (schemeFlags != 0) {
                        encodedUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
                        error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                                              schemeFlags,
                                              urlPath,
                                              urlPathLength,
                                              encodedUrlPath,
                                              &encodedUrlPathLength
                                              );
                        if (error == ERROR_SUCCESS) {
                            urlPath = encodedUrlPath;
                            urlPathLength = encodedUrlPathLength;
                        }
                    }
                }
            } else {
                urlPathLength = 0;
                extraLength = 0;
            }

            //
            // handle extra info if present
            //

            if (error == ERROR_SUCCESS) {
                extraInfo = lpUrlComponents->lpszExtraInfo;
                if (extraInfo != NULL) {
                    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
                    if (extraInfoLength == 0) {
                        extraInfoLength = lstrlen(extraInfo);
                    }

                    //
                    // if requested, we will encode the extra info
                    //

                    if (dwFlags & ICU_ESCAPE) {

                        //
                        // only encode the extra info if it's a recognized scheme
                        //

                        if (schemeFlags != 0) {
                            encodedExtraInfoLength = INTERNET_MAX_URL_LENGTH + 1;
                            error = EncodeUrlPath(0,
                                                  schemeFlags,
                                                  extraInfo,
                                                  extraInfoLength,
                                                  encodedExtraInfo,
                                                  &encodedExtraInfoLength
                                                  );
                            if (error == ERROR_SUCCESS) {
                                extraInfo = encodedExtraInfo;
                                extraInfoLength = encodedExtraInfoLength;
                            }
                        }
                    }
                } else {
                    extraInfoLength = 0;
                }
            }

            DWORD requiredSize;

            if (error == ERROR_SUCCESS) {

                //
                // Determine if we have a protocol scheme that requires slashes
                //

                if (DoesSchemeRequireSlashes(schemeName, schemeNameLength, (hostName != NULL))
                || ((schemeType == INTERNET_SCHEME_NEWS)
                && urlPath
                && (strchr(urlPath, '/') || strchr(urlPath, '\\')))) {
                    schemeSep = "://";
                    schemeSepLength = sizeof("://") - 1;
                } else {
                    schemeSep = ":";
                    schemeSepLength = sizeof(":") - 1;
                }

                //
                // ensure we have enough buffer space
                //

                requiredSize = schemeNameLength
                             + schemeSepLength
                             + hostNameLength
                             + portLength
                             + (userName ? userNameLength + 1 : 0) // +1 for '@'
                             + (password ? passwordLength + 1 : 0) // +1 for ':'
                             + urlPathLength
                             + extraLength
                             + extraInfoLength
                             + 1                                // +1 for '\0'
                             ;

                //
                // if there is enough buffer, copy the URL
                //

                if (*lpdwUrlLength >= requiredSize) {
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeName, schemeNameLength);
                    lpszUrl += schemeNameLength;
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeSep, schemeSepLength);
                    lpszUrl += schemeSepLength;
                    if (userName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)userName, userNameLength);
                        lpszUrl += userNameLength;
                        if (password) {
                            *lpszUrl++ = ':';
                            memcpy((LPVOID)lpszUrl, (LPVOID)password, passwordLength);
                            lpszUrl += passwordLength;
                        }
                        *lpszUrl++ = '@';
                    }
                    if (hostName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)hostName, hostNameLength);
                        lpszUrl += hostNameLength;

                        // We won't attach a port unless there's a host to go with it.
                        if (portLength) {
                            lpszUrl += wsprintf(lpszUrl, ":%d", nPort & 0xffff);
                        }

                    }
                    if (urlPath) {

                        //
                        // Only do extraLength if we've actually copied something
                        // after the scheme.  Also, don't copy slash if it's
                        // mailto:
                        //

                        if (extraLength != 0 && (userName || hostName || portLength) &&
                            schemeType != INTERNET_SCHEME_MAILTO) {
                            *lpszUrl++ = '/';
                        } else if (extraLength != 0) {
                            --requiredSize;
                        }
                        memcpy((LPVOID)lpszUrl, (LPVOID)urlPath, urlPathLength);
                        lpszUrl += urlPathLength;
                    } else if (extraLength != 0) {
                        --requiredSize;
                    }
                    if (extraInfo) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)extraInfo, extraInfoLength);
                        lpszUrl += extraInfoLength;
                    }

                    //
                    // terminate string
                    //

                    *lpszUrl = '\0';

                    //
                    // -1 for terminating '\0'
                    //

                    --requiredSize;
                } else {

                    //
                    // not enough buffer space - just return the required buffer length
                    //

                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            //
            // update returned parameters
            //

            *lpdwUrlLength = requiredSize;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
quit:

    //
    // clear up the buffers we allocated
    //


    if (encodedUrlPath != NULL) {
        FREE_MEMORY(encodedUrlPath);
    }
    if (encodedExtraInfo != NULL) {
        FREE_MEMORY(encodedExtraInfo);
    }

    BOOL success = (error==ERROR_SUCCESS);

    if (success) {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("URL = %q\n",
                        lpszUrlOriginal
                        ));
    } else {

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}

//
//  ICUHrToWin32Error() is specifically for converting the return codes for
//  Url* APIs in shlwapi into win32 errors.
//  WARNING:  it should not be used for any other purpose.
//
DWORD
ICUHrToWin32Error(HRESULT hr)
{
    DWORD err = ERROR_INVALID_PARAMETER;
    switch(hr)
    {
    case E_OUTOFMEMORY:
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case E_POINTER:
        err = ERROR_INSUFFICIENT_BUFFER;
        break;

    case S_OK:
        err = ERROR_SUCCESS;
        break;

    default:
        break;
    }
    return err;
}



INTERNETAPI_(BOOL) InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszUrl             - pointer to URL to be canonicalize
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlA",
                     "%q, %#x, %#x [%d], %#x",
                     lpszUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet = TRUE;;

    INET_ASSERT(lpszUrl);
    INET_ASSERT(lpszBuffer);
    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszUrl || !lpszBuffer || !lpdwBufferLength || *lpdwBufferLength == 0 || IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeA(lpszUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}


INTERNETAPI_(BOOL) InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszBaseUrl         - pointer to base URL
    lpszRelativeUrl     - pointer to relative URL
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCombineUrlA",
                     "%q, %q, %#x, %#x [%d], %#x",
                     lpszBaseUrl,
                     lpszRelativeUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

    INET_ASSERT(lpszBaseUrl);
    INET_ASSERT(lpszRelativeUrl);
    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszBaseUrl || !lpszRelativeUrl || !lpdwBufferLength || (lpszBuffer && IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA(lpszBaseUrl, lpszRelativeUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    IF_DEBUG_CODE() {
        if (bRet) {
            DEBUG_PRINT_API(API,
                            INFO,
                            ("URL = %q\n",
                            lpszBuffer
                            ));
        }
    }

    DEBUG_LEAVE_API(bRet);

    return bRet;
}



INTERNETAPI_(HINTERNET) InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Opens a root Internet handle from which all HINTERNET objects are derived

Arguments:

    lpszAgent       - name of the application making the request (arbitrary
                      identifying string). Used in "User-Agent" header when
                      communicating with HTTP servers, if the application does
                      not add a User-Agent header of its own

    dwAccessType    - type of access required. Can be

                        INTERNET_OPEN_TYPE_PRECONFIG
                            - Gets the configuration from the registry

                        INTERNET_OPEN_TYPE_DIRECT
                            - Requests are made directly to the nominated server

                        INTERNET_OPEN_TYPE_PROXY
                            - Requests are made via the nominated proxy

                        INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY
                            - Like Pre-Config, but prevents JavaScript, INS
                                and other auto-proxy types from being used.

    lpszProxy       - if INTERNET_OPEN_TYPE_PROXY, a list of proxy servers to
                      use

    lpszProxyBypass - if INTERNET_OPEN_TYPE_PROXY, a list of servers which we
                      will communicate with directly

    dwFlags         - flags to control the operation of this API or potentially
                      all APIs called on the handle generated by this API.
                      Currently supported are:

                        INTERNET_FLAG_ASYNC
                            - if specified then all subsequent API calls made
                              against the handle returned from this API, or
                              handles descended from the handle returned by
                              this API, have the opportunity to complete
                              asynchronously, depending on other factors
                              relevant at the time the API is called

Return Value:

    HINTERNET
        Success - handle of Internet object

        Failure - NULL. For more information, call GetLastError()

--*/

{
    PERF_INIT();

    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenA",
                     "%q, %s (%d), %q, %q, %#x",
                     lpszAgent,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     lpszProxy,
                     lpszProxyBypass,
                     dwFlags
                     ));

    DWORD error;
    HINTERNET hInternet = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // we are doing GetUserName here instead of in DLL_PROCESS_ATTACH
    // As every caller of wininet has to do this first, we ensure
    // that the username is initialized when they get to actually doing
    // any real operation
    //

    GetWininetUserName();

    //
    // validate parameters
    //

    if (!
         (
              (dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
           || (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG)
           || (dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG_WITH_NO_AUTOPROXY)
           || (
                (dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                &&
                    (
                       !ARGUMENT_PRESENT(lpszProxy)
                    || (*lpszProxy == '\0')

                    )
              )
           || (dwFlags & ~INTERNET_FLAGS_MASK)
         )
       )
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    GlobalHaveInternetOpened = TRUE;

    //
    // Initalize an auto proxy dll if needed,
    //  as long as the caller is allowing us free rein to do this
    //  by calling us with INTERNET_OPEN_TYPE_PRECONFIG.
    //

    //if ( dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG )
    //{
    //    if ( ! InitalizeAutoConfigDllIfNeeded() )
    //  {
    //      error = GetLastError();
    //
    //      INET_ASSERT(error != ERROR_SUCCESS);
    //
    //      goto quit;
    //  }
    //
    //


    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = new INTERNET_HANDLE_OBJECT(lpszAgent,
                                            dwAccessType,
                                            (LPSTR)lpszProxy,
                                            (LPSTR)lpszProxyBypass,
                                            dwFlags
                                            );
    if (lpInternet == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    error = lpInternet->GetStatus();
    if (error == ERROR_SUCCESS) {
        hInternet = (HINTERNET)lpInternet;

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();

        //
        // start async support now if required. If we can't start it, we'll get
        // another chance the next time we create an async request
        //

        if (dwFlags & INTERNET_FLAG_ASYNC) {
            InitializeAsyncSupport();
        }
    } else {

        //
        // hack fix to stop InternetIndicateStatus (called from the handle
        // object destructor) blowing up if there is no handle object in the
        // thread info block. We can't call back anyway
        //

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        if (lpThreadInfo) {

            //
            // BUGBUG - incorrect handle value
            //

            _InternetSetObjectHandle(lpThreadInfo, lpInternet, lpInternet);
        }

        //
        // we failed during initialization. Kill the handle using Dereference()
        // (in order to stop the debug version complaining about the reference
        // count not being 0. Invalidate for same reason)
        //

        lpInternet->Invalidate();
        lpInternet->Dereference();

        INET_ASSERT(hInternet == NULL);

    }

quit:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE_API(hInternet);

    return hInternet;
}


INTERNETAPI_(BOOL) InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes any open internet handle object

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCloseHandle",
                     "%#x",
                     hInternet
                     ));

    PERF_ENTER(InternetCloseHandle);

    DWORD error;
    BOOL success = FALSE;
    HINTERNET hInternetMapped = NULL;
    static DWORD ticks = GetTickCountWrap();

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // map the handle. Don't invalidate it (_InternetCloseHandle() does this)
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped == NULL) {

            //
            // the handle never existed or has been completely destroyed
            //

            DEBUG_PRINT(API,
                        ERROR,
                        ("Handle %#x is invalid\n",
                        hInternet
                        ));

            //
            // catch invalid handles - may help caller
            //

            DEBUG_BREAK(INVALID_HANDLES);

        } else {

            //
            // this handle is already being closed (it's invalidated). We only
            // need one InternetCloseHandle() operation to invalidate the handle.
            // All other threads will simply dereference the handle, and
            // eventually it will be destroyed
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }
        goto quit;
    }

    //
    // the handle is not invalidated
    //

    HANDLE_OBJECT * pHandle;

    pHandle = (HANDLE_OBJECT *)hInternetMapped;

    if ( ! ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->IsAsyncHandle() )
    {
        if ((GetTickCountWrap() - ticks) >= 5000)
        {
            PurgeServerInfoList(FALSE);

            InterlockedExchange((LPLONG) &ticks, (LONG) GetTickCountWrap());
        }
    }

    DEBUG_PRINT(INET,
                INFO,
                ("handle %#x == %#x == %s\n",
                hInternet,
                hInternetMapped,
                InternetMapHandleType(pHandle->GetHandleType())
                ));

    //
    // if this is an http request handle, notify all filters.
    //

    if (pHandle->GetHandleType() == TypeHttpRequestHandle) {
        HttpFiltOnTransactionComplete (hInternet);
    }

    //
    // if this is a delete-parent-with-child subtree then find the root node
    //

    while (pHandle->GetDeleteWithChild()) {

        HINTERNET handleObject;

        handleObject = pHandle->GetParent();

        INET_ASSERT(handleObject != NULL);

        //
        // remove the delete-parent-with-child indication, or we'll get stuck
        // in a loop
        //

        pHandle->SetParent(handleObject, FALSE);

        //
        // if the parent handle is an EXISTING_CONNECT connect handle then we
        // just mark it unused & close the current handle
        //

        HINTERNET_HANDLE_TYPE handleType;

        handleType = ((HANDLE_OBJECT *)handleObject)->GetHandleType();
        if ((handleType == TypeFtpConnectHandle)
        || (handleType == TypeGopherConnectHandle)
        || (handleType == TypeHttpConnectHandle)) {

            INTERNET_CONNECT_HANDLE_OBJECT * pConnect;

            pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)handleObject;

            //
            // SetUnused() will only operate on a connect handle object that
            // has been created with INTERNET_FLAG_EXISTING_CONNECT
            //

            if (pConnect->SetUnused()) {

                //
                // only handle type should be FTP connect handle for now
                //

                INET_ASSERT(handleType == TypeFtpConnectHandle);

                DEBUG_PRINT(INET,
                            INFO,
                            ("caching unused %s connect handle object %#x. RefCount = %d\n",
                            (handleType == TypeFtpConnectHandle)
                                ? "FTP"
                                : (handleType == TypeGopherConnectHandle)
                                    ? "Gopher"
                                    : "HTTP",
                            ((HANDLE_OBJECT *)handleObject)->GetPseudoHandle(),
                            ((HANDLE_OBJECT *)handleObject)->ReferenceCount()
                            ));
                break;
            }
        }
        pHandle = (HANDLE_OBJECT *)handleObject;
        hInternet = pHandle->GetPseudoHandle();
    }

    //
    // close all child handles first
    //

    while (pHandle->HaveChildren()) {

        //
        // we'll fall out at the first error we get. It *should* mean that this
        // handle (and its descendents) is already being closed
        //

        if (!InternetCloseHandle(pHandle->NextChild())) {
            break;
        }
    }

    //
    // clear the handle object last error variables
    //

    InternetClearLastError();


    //
    // remove the reference added by MapHandleToAddress(), or the handle won't
    // be destroyed by _InternetCloseHandle()
    //

    DereferenceObject((LPVOID)hInternetMapped);

    //
    // use _InternetCloseHandle() to do the work
    //

    success = _InternetCloseHandle(hInternet);

quit:

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(InternetCloseHandle);

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as InternetCloseHandle() except does not clear out the last error text.
    Mainly for FTP

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    BOOL success;
    HINTERNET hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        if (InDllCleanup) {
            error = ERROR_INTERNET_SHUTDOWN;
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // we need the parent handle - we will set this as the handle object being
    // processed by this thread. This is required for async worker threads (see
    // below)
    //

    HINTERNET hParent;
    HINTERNET hParentMapped;
    DWORD_PTR dwParentContext;

    hParentMapped = ((HANDLE_OBJECT *)hInternetMapped)->GetParent();
    if (hParentMapped != NULL) {
        hParent = ((HANDLE_OBJECT *)hParentMapped)->GetPseudoHandle();
        dwParentContext = ((HANDLE_OBJECT *)hParentMapped)->GetContext();
    }

    //
    // set the object handle and context in the per-thread data structure
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->GetContext()
                        );

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

    //
    // now set the object to be the parent. This is necessary for e.g.
    // FtpGetFile() and async requests (where the async worker thread will make
    // an extra callback to deliver the results of the async request)
    //

    if (hParentMapped != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hParent, hParentMapped);
        if (dwParentContext != 0) {
            _InternetSetContext(lpThreadInfo, dwParentContext);
        }
    }

    if (g_bHibernating)
    {
        InterruptSelect();
    }
    //
    // if the handle was still alive after dereferencing it then we will inform
    // the app that the close is pending
    //

quit:

    //
    // if the handle is still alive then we return success - it is invalidated
    // and will be deleted as soon as possible
    //

    if (error == ERROR_INTERNET_HANDLE_EXISTS) {
        error = ERROR_SUCCESS;
    }
    success = (error==ERROR_SUCCESS);
    if (!success) {
        SetLastError(error);
        DEBUG_ERROR(INET, error);
    }
    DEBUG_LEAVE(success);
    return success;
}


DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as _InternetCloseHandle() except does not change the per-thread info
    structure handle/context values

    BUGBUG - This should be handled via a parameter to _InternetCloseHandle(),
             but its close to shipping...

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandleNoContext",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    HINTERNET hInternetMapped = NULL;

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_OBJECT *)hInternetMapped)->AbortSocket();

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

quit:

    //
    // if the handle is still alive then we return success - it is invalidated
    // and will be deleted as soon as possible
    //

    if (error == ERROR_INTERNET_HANDLE_EXISTS) {
        error = ERROR_SUCCESS;
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetGetCertByURLA(
    IN LPSTR     lpszURL,
    IN OUT LPSTR lpszCertText,
    OUT DWORD    dwcbCertText
    )
/*++

Routine Description:

    Does a high-level lookup against the Certificate Cache.
    Searches by URL (broken down into hostname) for the Certificate,
    and returns it in a formatted (&localized) string.

Arguments:

    lpszUrl         - pointer to URL to crack

    lpszCertText    - Output of formatted certifcate

    dwcbCertText    - Size of lpszCertText

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{

    BOOL fSuccess = FALSE;

/*    LPSTR lpszHostName;
    DWORD dwcbHostName;
    INTERNET_CERTIFICATE_INFO cInfo;
    CHAR chBackup;
    DWORD error = ERROR_SUCCESS;

    ZeroMemory(&cInfo, sizeof(INTERNET_CERTIFICATE_INFO));

    error = CrackUrl(lpszURL,
             lstrlen(lpszURL),
             FALSE,
             NULL,          //  Scheme Type
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             &lpszHostName, //  Host Name
             &dwcbHostName, //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra Info
             NULL,          //  Extra Info Length
             NULL
             );


    if ( error != ERROR_SUCCESS)
        goto quit;

    chBackup = lpszHostName[dwcbHostName];
    lpszHostName[dwcbHostName] = '\0';

    fSuccess = GlobalCertCache.GetCert(
                    lpszHostName,
                    &cInfo
                    );


    lpszHostName[dwcbHostName] = chBackup;

    if ( ! fSuccess )
    {
        error = ERROR_INTERNET_INVALID_OPERATION;
        goto quit;
    }

    LPSTR szResult;

    szResult = FormatCertInfo(&cInfo);

    if ( ! szResult )
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    DWORD dwcbResult;

    dwcbResult = lstrlen(szResult);

    if ( dwcbCertText < (dwcbResult+1) )
    {
        error = ERROR_INSUFFICIENT_BUFFER;
        goto quit;
    }

    memcpy(
        lpszCertText,
        szResult,
        (dwcbResult + 1) * sizeof(TCHAR));


quit:

    if (NULL != szResult) {
        FREE_MEMORY(szResult);
    }
    if (NULL != cInfo.lpszSubjectInfo) {
        FREE_MEMORY(cInfo.lpszSubjectInfo);
    }
    if (NULL != cInfo.lpszIssuerInfo) {
        FREE_MEMORY(cInfo.lpszIssuerInfo);
    }
    if (NULL != cInfo.lpszSignatureAlgName) {
        FREE_MEMORY(cInfo.lpszSignatureAlgName);
    }
    if (NULL != cInfo.lpszEncryptionAlgName) {
        FREE_MEMORY(cInfo.lpszEncryptionAlgName);
    }
    if (NULL != cInfo.lpszProtocolName) {
        FREE_MEMORY(cInfo.lpszProtocolName);
    }

    fSuccess = TRUE;

    if ( error != ERROR_SUCCESS )
    {
        fSuccess = FALSE;
        SetLastError(error);
    }*/

    return fSuccess;

}


INTERNETAPI_(BOOL) InternetShowSecurityInfoByURLA(
    IN LPSTR     lpszURL,
    IN HWND      hwndRootWindow
    )
/*++

Routine Description:

    Does a high-level lookup against the Certificate Cache.
    Searches by URL (broken down into hostname) for the Certificate,
    and returns it in a formatted (&localized) string.

Arguments:

    lpszUrl         - pointer to URL to crack

    lpszCertText    - Output of formatted certifcate

    dwcbCertText    - Size of lpszCertText

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_INET,
                 Bool,
                 "InternetShowSecurityInfoA",
                 "%q %#x",
                 lpszURL,
                 hwndRootWindow
                 ));

    LPSTR lpszHostName;
    DWORD dwcbHostName;
    INTERNET_SECURITY_INFO cInfo;
    CHAR chBackup;
    DWORD dwFlags;
    DWORD error = ERROR_SUCCESS;
    WCHAR   szTitle[MAX_PATH];
    WCHAR   szMessage[MAX_PATH];
    INTERNET_SCHEME ustSchemeType;
    BOOL fResult = FALSE;

    if (!GlobalDataInitialized) {
        if (GlobalDataInitialize() != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }

    ZeroMemory(&cInfo, sizeof(INTERNET_SECURITY_INFO));

    error = CrackUrl(lpszURL,
             lstrlen(lpszURL),
             FALSE,
             &ustSchemeType,
             NULL,          //  Scheme Name
             NULL,          //  Scheme Length
             &lpszHostName, //  Host Name
             &dwcbHostName, //  Host Length
             NULL,          //  Internet Port
             NULL,          //  UserName
             NULL,          //  UserName Length
             NULL,          //  Password
             NULL,          //  Password Lenth
             NULL,          //  Path
             NULL,          //  Path Length
             NULL,          //  Extra Info
             NULL,          //  Extra Info Length
             NULL
             );


    if ( error != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    if ( ustSchemeType != INTERNET_SCHEME_HTTPS )
    {
        goto Cleanup;
    }

    if ( lpszHostName == NULL || dwcbHostName == 0 )
    {
        fResult = TRUE;
        goto done;
    }


    chBackup = lpszHostName[dwcbHostName];
    lpszHostName[dwcbHostName] = '\0';
    SECURITY_CACHE_LIST_ENTRY *pEntry;
    pEntry = GlobalCertCache.Find(lpszHostName);

    lpszHostName[dwcbHostName] = chBackup;

    if(pEntry)
    {
        pEntry->CopyOut(cInfo);
        pEntry->Release();
        ShowSecurityInfo(hwndRootWindow,
                         &cInfo);
        CertFreeCertificateContext(cInfo.pCertificate);
        fResult = TRUE;
        goto done;
    }

Cleanup:
    // No certificate info, display messagebox.
    LoadStringWrapW(
            GlobalDllHandle,
            IDS_NOCERT_TITLE,
            szTitle,
            sizeof(szTitle) / sizeof(szTitle[0]));

    LoadStringWrapW(
            GlobalDllHandle,
            IDS_NOCERT,
            szMessage,
            sizeof(szMessage) / sizeof(szMessage[0]));

     MessageBoxWrapW(hwndRootWindow,
         szMessage,
         szTitle,
         MB_ICONINFORMATION | MB_OK);

done:
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(HINTERNET) InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a connection with a server, logging-on the user in the process.

Arguments:

    hInternet       - Internet handle, returned by InternetOpen()

    lpszServerName  - name of server with which to connect

    nServerPort     - port at which server listens

    lpszUserName    - name of current user

    lpszPassword    - password of current user

    dwService       - service required. Controls type of handle generated.
                      May be one of:
                        - INTERNET_SERVICE_FTP
                        - INTERNET_SERVICE_GOPHER
                        - INTERNET_SERVICE_HTTP

    dwFlags         - protocol-specific flags. The following are defined:
                        - INTERNET_FLAG_PASSIVE (FTP)
                        - INTERNET_FLAG_KEEP_CONNECTION (HTTP)
                        - INTERNET_FLAG_SECURE (HTTP)

    dwContext       - application-supplied value used to identify this
                      request in callbacks

Return Value:

    HINTERNET
        Success - address of a new handle object

        Failure - NULL. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetConnectA",
                     "%#x, %q, %d, %q, %q, %s (%d), %#08x, %#x",
                     hInternet,
                     lpszServerName,
                     nServerPort,
                     lpszUserName,
                     lpszPassword,
                     InternetMapService(dwService),
                     dwService,
                     dwFlags,
                     dwContext
                     ));

    char emailName[INTERNET_MAX_HOST_NAME_LENGTH + 1];
    char proxyBuf[INTERNET_MAX_HOST_NAME_LENGTH + 1];

    HINTERNET connectHandle = NULL;
    HINTERNET hInternetMapped = NULL;
    HINTERNET hObject;
    HINTERNET hObjectMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;

    BOOL fUseProxy = FALSE;

    LPSTR serverName = NULL;
    LPSTR userName = (LPSTR)lpszUserName;
    LPSTR password = (LPSTR)lpszPassword;
    LPSTR realServerName = (LPSTR)lpszServerName;
    LPSTR realUserName = (LPSTR)lpszUserName;

    BOOL existingConnection = FALSE;
    BOOL viaProxy = FALSE;

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect = NULL;
    //CServerInfo * lpServerInfo;

    BOOL bProtocolLevel = !(dwFlags & INTERNET_FLAG_OFFLINE);
    BOOL bIsWorker = FALSE;
    BOOL bNonNestedAsync = FALSE;
    BOOL isLocal;
    BOOL isAsync;
    BOOL bFTPSetPerUserItem = FALSE;

    DWORD error = ERROR_SUCCESS;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    bIsWorker = lpThreadInfo->IsAsyncWorkerThread;
    bNonNestedAsync = bIsWorker && (lpThreadInfo->NestedRequests == 1);

    //
    // handle any global proxy settings changes first
    //

    if (InternetSettingsChanged()) {
        ChangeGlobalSettings();
    }

    //
    // handle/refcount munging:
    //
    //  sync:
    //      map hInternet on input (+1 ref)
    //      generate connect handle (1 ref)
    //      if failure && !connect handle
    //          close connect handle (0 refs: delete)
    //      if success
    //          deref hInternet (-1 ref)
    //      else if going async
    //          ref connect handle (2 refs)
    //
    //  async:
    //      hInternet is mapped connect handle (2 refs)
    //      get real hInternet from connect handle parent (2 refs (e.g.))
    //      deref connect handle (1 ref)
    //      if failure
    //          close connect handle (0 refs: delete)
    //      deref open handle (-1 ref)
    //
    // N.B. the final deref of the *indicated* handle on async callback will
    // happen in the async code
    //

    if (bNonNestedAsync) {
        connectHandle = hInternet;
        hInternetMapped = ((HANDLE_OBJECT *)connectHandle)->GetParent();
        hInternet = ((HANDLE_OBJECT *)hInternetMapped)->GetPseudoHandle();
    } else {
        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
        if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
            goto quit;
        }

        //
        // set the info context and clear the last error info
        //

        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
        _InternetClearLastError(lpThreadInfo);
        _InternetSetContext(lpThreadInfo, dwContext);

        //
        // quit now if the handle object is invalidated
        //

        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // validate the handle & discover local/remote & sync/async
        //

        error = RIsHandleLocal(hInternetMapped,
                               &isLocal,
                               &isAsync,
                               TypeInternetHandle
                               );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // we allow all valid flags to be passed in
        //

        if ((dwFlags & ~INTERNET_FLAGS_MASK)
            || (lpszServerName == NULL)
            || (*lpszServerName == '\0')) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    INTERNET_SCHEME schemeType;

    switch (dwService) {
    case INTERNET_SERVICE_FTP:
        schemeType = INTERNET_SCHEME_FTP;
        break;

    case INTERNET_SERVICE_HTTP:
        schemeType = (dwFlags & INTERNET_FLAG_SECURE)
                        ? INTERNET_SCHEME_HTTPS
                        : INTERNET_SCHEME_HTTP;
        break;

    case INTERNET_SERVICE_GOPHER:   // disable gopher by default
        if (GlobalEnableGopher) {
            schemeType = INTERNET_SCHEME_GOPHER;
            break;
        }

    default:
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // validate arguments if we're not in the async thread context, in which
    // case we did this when the original request was made
    //

    if (bNonNestedAsync) {
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
        goto sync_path;
    }

    //
    // app thread or in async worker thread but being called from another
    // async API, such as InternetOpenUrl()
    //

    //
    // special case: if the server name is the NULL pointer or empty string, and
    // the port is 0 AND we have a proxy configured for this protocol then the
    // app is asking to connect directly to the proxy (the proxy server itself
    // had better be in the bypass list!)
    //
    // BUGBUG - not sure if this is really where we want to do this
    //

    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = (INTERNET_HANDLE_OBJECT * )hInternetMapped;

    //
    // if the port value is 0 convert it to the default port for the
    // protocol
    //

    if (nServerPort == INTERNET_INVALID_PORT_NUMBER) {
        switch (dwService) {
        case INTERNET_SERVICE_FTP:
            nServerPort = INTERNET_DEFAULT_FTP_PORT;
            break;

        case INTERNET_SERVICE_GOPHER:
            nServerPort = INTERNET_DEFAULT_GOPHER_PORT;
            break;

        case INTERNET_SERVICE_HTTP:
            if (dwFlags & INTERNET_FLAG_SECURE) {
                nServerPort = INTERNET_DEFAULT_HTTPS_PORT;
            } else {
                nServerPort = INTERNET_DEFAULT_HTTP_PORT;
            }
            break;
        }
    }

    //
    // if we have been given a net (i.e. IP) address, try to convert it to the
    // corresponding host name
    //

    //if (IsNetAddress((LPSTR)lpszServerName)) {
        //lpszServerName = (LPCSTR)MapNetAddressToName((LPSTR)lpszServerName);
        realServerName = (LPSTR)lpszServerName;
    //}

    //
    // we need to get the username and password for the current user before we
    // make the connection proper. The reason for this is that if we leave it
    // to the server, it will end up with a username of "SYSTEM" for all
    // anonymous FTP connects
    //

    if (dwService == INTERNET_SERVICE_FTP) {

        //
        // Make sure we have the correct Proxy-Network Settings, at this point.
        //

        InternetAutodialIfNotLocalHost(NULL, (LPSTR) lpszServerName);

        //
        // check the user name & password. If NULLs were supplied, use the values
        // from the registry
        //

        //
        // Do we need to set this item as per user? If a username was supplied (
        // either cracked from the URL or set on the handle, userName will be
        // non-null. Currently, this is the only criteria for when we set pu.
        //
        // Need to check this BEFORE calling GetEmailNameAndPassword which will
        // plugin "anonymous" if no username provided.
        //

        bFTPSetPerUserItem = userName ? TRUE : FALSE;
        DEBUG_PRINT(FTP,
                    INFO,
                    ("InternetConnectA:FTP: bFTPSetPerUserItem = %d\n",
                    bFTPSetPerUserItem
                    ));

        error = GetEmailNameAndPassword(&userName,
                                        &password,
                                        emailName,
                                        sizeof(emailName)
                                        );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // this is the user name we will use for the object, i.e. either the
        // name supplied, or "anonymous" as mapped above
        //

        realUserName = userName;

        //
        // if this request is going via an FTP proxy, then convert the parameters
        // now. We convert the username to <username>@<servername>, the password
        // remains the same, and the server name & port become the proxy server
        // name and port
        //
        // N.B. We ONLY do this once on the initial (synchronous) path
        //

        AUTO_PROXY_ASYNC_MSG proxyInfoQuery(
            INTERNET_SCHEME_FTP,
            (LPSTR)lpszServerName,
            lstrlen((LPSTR)lpszServerName)
            );

        AUTO_PROXY_ASYNC_MSG *pProxyInfoQuery;

        pProxyInfoQuery = &proxyInfoQuery;


        proxyInfoQuery.SetAvoidAsyncCall(TRUE);

        error = lpInternet->GetProxyInfo(
                    &pProxyInfoQuery
                    );

        if ( error != ERROR_SUCCESS )
        {
            goto quit;
        }

        if ( proxyInfoQuery.IsUseProxy() )
        {
            if (proxyInfoQuery.GetProxyScheme() == INTERNET_SCHEME_FTP)
            {

                int ulen = lstrlen(userName);
                int slen = lstrlen(lpszServerName);

                INET_ASSERT((ulen + slen) < (sizeof(proxyBuf) - 1));

                if ((ulen + slen) < (sizeof(proxyBuf) - 1))
                {
                    memcpy(proxyBuf, userName, ulen);
                    proxyBuf[ulen++] = '@';
                    memcpy(&proxyBuf[ulen], lpszServerName, slen + 1);

                    //
                    // keep a pointer to the real user name for when we
                    // create the object
                    //

                    realUserName = userName;
                    userName = proxyBuf;

                    //
                    // create a copy of the proxy name. We have to do
                    // this in case the current proxy list is replaced
                    // while we are using this string
                    //

                    //
                    // N.B. we can't be here if we determined that the
                    // proxy server was the destination (i.e. we mapped2
                    // the empty server name above)
                    //

                    INET_ASSERT(serverName == NULL);

                    serverName = NewString((LPCSTR)proxyInfoQuery._lpszProxyHostName);

                    if ( serverName == NULL )
                    {
                        error = ERROR_NOT_ENOUGH_MEMORY;
                        goto quit;
                    }

                    //
                    // keep a pointer to the real (origin) server name
                    // for when we create the object
                    //

                    realServerName = (LPSTR)lpszServerName;
                    lpszServerName = serverName;

                    //
                    // BUGBUG - what if proxyPort != nServerPort? Where
                    //          should the port go (user@server:port?)
                    //

                    nServerPort = proxyInfoQuery._nProxyHostPort;

                    //
                    // this request will go via proxy
                    //

                    viaProxy = TRUE;

                }
                else
                {

                    //
                    // blew internal limit
                    //

                    error = ERROR_INTERNET_INTERNAL_ERROR;
                    goto quit;
                }
            }
        }

    }
    else
    {
        if (userName != NULL) {
            if (IsBadStringPtr(userName, INTERNET_MAX_USER_NAME_LENGTH)) {
                error = ERROR_INVALID_PARAMETER;
                goto quit;
            } else if (*userName == '\0') {
                userName = NULL;
            }
        }
        if (password != NULL) {
            if (IsBadStringPtr(password, INTERNET_MAX_PASSWORD_LENGTH)) {
                error = ERROR_INVALID_PASSWORD;
                goto quit;
            } else if (*password == '\0') {
                password = NULL;
            }
        }
    }

    //
    // find the handle object if EXISTING_CONNECT AND we are creating protocol-
    // level connections, else create it
    //

    INET_ASSERT(connectHandle == NULL);
    INET_ASSERT(error == ERROR_SUCCESS);

    if ((dwFlags & INTERNET_FLAG_EXISTING_CONNECT) && bProtocolLevel) {
        connectHandle = FindExistingConnectObject(hInternet,
                                                  realServerName,
                                                  nServerPort,
                                                  realUserName,
                                                  password,
                                                  dwService,
                                                  dwFlags,
                                                  dwContext
                                                  );
    }
    if (connectHandle != NULL) {
        existingConnection = TRUE;
    } else {

        //
        // turn off INTERNET_FLAG_EXISTING_CONNECT if we are creating a cache
        // handle - we don't want the handle to hang around after we delete
        // the request handle (i.e. be set unused by InternetCloseHandle()).
        // N.B. We don't need this flag after this operation, so its safe to
        // remove it from dwFlags
        //

        if (!bProtocolLevel) {
            dwFlags &= ~INTERNET_FLAG_EXISTING_CONNECT;
        }
        error = RMakeInternetConnectObjectHandle(
                    hInternetMapped,
                    &connectHandle,
                    (CONNECT_CLOSE_HANDLE_FUNC)wInternetCloseConnectA,
                    realServerName, // origin server, not proxy
                    nServerPort,
                    realUserName,   // just user name, not user@server
                    password,
                    dwService,
                    dwFlags,
                    dwContext
                    );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // this new handle will be used in callbacks
    //

    _InternetSetObjectHandle(lpThreadInfo,
                             ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle(),
                             connectHandle
                             );

    //
    // based on whether we have been asked to perform async I/O AND we are not
    // in an async worker thread context AND the request is to connect with an
    // FTP service (currently only FTP because this request performs network
    // I/O - gopher and HTTP just allocate & fill in memory) AND there is a
    // valid context value, we will queue the async request, or execute the
    // request synchronously
    //

    //
    // BUGBUG - GetFlags()
    //

    if ((lpInternet->GetInternetOpenFlags() | dwFlags) & INTERNET_FLAG_OFFLINE) {
        error = ERROR_SUCCESS;
        goto quit;
    }

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    //lpServerInfo = pConnect->GetServerInfo();
    DEBUG_PRINT(FTP,
                INFO,
                ("bIsWorker = %d isAsync = %d dwContext %s INC dwService %s ISF bProtocolLevel = %d\n",
                bIsWorker,
                isAsync,
                (dwContext == INTERNET_NO_CALLBACK) ? "==":"!=",
                (dwService == INTERNET_SERVICE_FTP) ? "==":"!=",
                bProtocolLevel));

    if (!bIsWorker
        && isAsync
        && (dwContext != INTERNET_NO_CALLBACK)
        && ((dwService == INTERNET_SERVICE_FTP) ? bProtocolLevel : FALSE)) {

        // If we determined item should be set pu, do so now
        pConnect->SetPerUserItem(bFTPSetPerUserItem);
        DEBUG_PRINT(FTP,
                    INFO,
                    ("InternetConnectA:Async Path: SetPerUserItem to %\r\n\
                    <pConnect = 0x%x> <connectHandle = 0x%x>\r\n",
                    pConnect->IsPerUserItem(), pConnect, connectHandle));
        CFsm_FtpConnect * pFsm;

        pFsm = new CFsm_FtpConnect(lpszServerName,
                                   userName,
                                   password,
                                   nServerPort,
                                   dwService,
                                   dwFlags,
                                   dwContext
                                   );
        if (pFsm != NULL &&
            pFsm->GetError() == ERROR_SUCCESS)
        {
            BOOL bDerefConnect = TRUE;

            error = pConnect->Reference();

            if (error == ERROR_ACCESS_DENIED)
            {
                bDerefConnect = FALSE;
            }
            else if (error == ERROR_SUCCESS)
            {
                error = pFsm->QueueWorkItem();
                if (error == ERROR_IO_PENDING) {
                    hInternetMapped = NULL;
                    bDerefConnect = FALSE;
                }
            }
            if (bDerefConnect) {
                pConnect->Dereference();
            }
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;

            if ( pFsm )
            {
                error = pFsm->GetError();
                delete pFsm;
                pFsm = NULL;
            }
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);

        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;
    }

sync_path:

    if (bProtocolLevel && !existingConnection) {

        //
        // generate the protocol-level connect 'object' if required (for FTP).
        // This simply creates a memory object
        //

        HINTERNET protocolConnectHandle = NULL;

        INET_ASSERT(error == ERROR_SUCCESS);

        if (dwService == INTERNET_SERVICE_FTP) {
            error = wFtpConnect(lpszServerName,
                                nServerPort,
                                userName,
                                password,
                                dwService,
                                dwFlags,
                                &protocolConnectHandle
                                );
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        }

        //
        // associate the protocol-level handle and INTERNET_CONNECT_HANDLE_OBJECT
        //

        pConnect->SetConnectHandle(protocolConnectHandle);

        // If we determined item should be set pu, do so now
        pConnect->SetPerUserItem(bFTPSetPerUserItem);
        DEBUG_PRINT(FTP,
                    INFO,
                    ("InternetConnectA:Sync Path:SetPerUserItem to %d\r\n\
                        <pConnect = 0x%x> <protocolConnectHandle = 0x%x> <connectHandle = 0x%x>\r\n",
                    pConnect->IsPerUserItem(), pConnect, protocolConnectHandle, connectHandle));


        // for all connect types, get the server info and resolve the server
        // name. If we can't resolve the name then we fail this request
        //

        //lpServerInfo = pConnect->GetServerInfo();
        //if ((lpServerInfo != NULL) && !lpServerInfo->IsNameResolved()) {
        //    error = pConnect->SetServerInfo(schemeType, FALSE, FALSE);
        //    if (error != ERROR_SUCCESS) {
        //        goto quit;
        //    }
        //}

        //
        // if we succeeded in creating the connect object and this is an FTP
        // request then we will now attempt to connect to the server proper.
        //
        // We don't need to do this for gopher and HTTP because (currently) they
        // don't make server connections until we perform some other action,
        // like find file, e.g.
        //

        if (dwService == INTERNET_SERVICE_FTP) {
            error = wFtpMakeConnection(protocolConnectHandle,
                                       userName,
                                       password
                                       );
        }
    }

quit:

    _InternetDecNestingCount(1);

    //
    // free the buffer we used to hold the proxy name if we had to map the
    // empty string to a proxy name
    //

    if (serverName != NULL) {
        DEL_STRING(serverName);
    }

done:

    if (error == ERROR_SUCCESS) {

        //
        // set the via proxy flag
        //

        ((INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle)->SetViaProxy(viaProxy);

        //
        // success - return generated pseudo-handle
        //

        connectHandle = ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle();

        //
        // created a handle. If we are generating protocol-level connections
        // then flush the existing connection cache
        //

        if (bProtocolLevel) {
            FlushExistingConnectObjects(hInternet);
        }
    } else {
        if (bNonNestedAsync
            && (/*((HANDLE_OBJECT *)connectHandle)->Dereference()
                ||*/ ((HANDLE_OBJECT *)connectHandle)->IsInvalidated())) {
            error = ERROR_INTERNET_OPERATION_CANCELLED;
        }

        //
        // if we are not pending an async request but we created a handle object
        // then close it
        //

        if ((error != ERROR_IO_PENDING) && (connectHandle != NULL)) {

            //
            // use _InternetCloseHandle() to close the handle: it doesn't clear
            // out the last error text, so that an app can find out what the
            // server sent us in the event of an FTP login failure
            //


            if (bNonNestedAsync) {

                //
                // this handle deref'd at async completion
                //

                hInternetMapped = NULL;
            }
            else
            {
                _InternetCloseHandle(((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle());
            }
        }
        connectHandle = NULL;
    }
    if (hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }
    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE_API(connectHandle);
    return connectHandle;
}



INTERNETAPI_(HINTERNET) InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens an URL. This consists of creating a handle to the type of item
    identified by the URL - directory or file

Arguments:

    hInternet       - root Internet handle

    lpszUrl         - pointer to the URL to use to open the item

    lpszHeaders     - headers to send to HTTP server. May be NULL

    dwHeadersLength - length of lpszHeaders. May be -1 if the app wants us to
                      perform the strlen()

    dwFlags         - open flags (cache/nocache, etc.)

    dwContext       - app-supplied context value for call-backs

Return Value:

    HINTERNET
        Success - open handle to item described by URL

        Failure - NULL. Use GetLastError() to get more information about why the
                  call failed. There may be error text returned from the server
                  (in the case of a gopher or FTP URL)

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetOpenUrlA",
                     "%#x, %q, %.80q, %d, %#08x, %#x",
                     hInternet,
                     lpszUrl,
                     lpszHeaders,
                     dwHeadersLength,
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD error;
    DWORD nestingLevel = 0;
    HINTERNET hInternetMapped = NULL;
    HINTERNET hUrlMapped = NULL;
    HINTERNET hUrl = NULL;

    PROXY_STATE * pProxyState = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto quit;
    }

    //
    // get the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
        goto quit;
    }

    //
    // set the info context and clear the last error info
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    _InternetClearLastError(lpThreadInfo);
    _InternetSetContext(lpThreadInfo, dwContext);

    //
    // quit now if the handle object is invalidated
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle & discover async/sync & local/remote
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hInternetMapped,
                           &isLocal,
                           &isAsync,
                           TypeInternetHandle
                           );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate parameters if we're not in the async worker thread context
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {

        //
        // ensure we have good values for the headers pointer and length
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        if (ARGUMENT_PRESENT(lpszHeaders) && (dwHeadersLength == -1)) {
            __try {
                dwHeadersLength = lstrlen(lpszHeaders);
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                error = ERROR_INVALID_PARAMETER;
            }
            ENDEXCEPT
            if (error != ERROR_SUCCESS) {
                goto quit;
            }
        } else if (!ARGUMENT_PRESENT(lpszHeaders) || (dwHeadersLength == 0)) {
            lpszHeaders = NULL;
            dwHeadersLength = 0;
        }
        if (!ARGUMENT_PRESENT(lpszUrl)
        || (*lpszUrl == '\0')
//        || !IsValidUrl(lpszUrl)
        || (dwFlags & ~INTERNET_FLAGS_MASK)) {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
    }

    //
    // determine if this is a http request or FTP request - either http URL, or via http proxy.
    // or via another protocol.
    // For any Async request, we must go async in order to determine proxy information
    //

    bDeref = FALSE;
    hUrl = hInternet;

    if (isAsync
    && !lpThreadInfo->IsAsyncWorkerThread
    && (dwContext != INTERNET_NO_CALLBACK))
    {
        CFsm_ParseUrlForHttp *pFsm;

        pFsm = new CFsm_ParseUrlForHttp(&hUrl,
                                       (INTERNET_HANDLE_OBJECT *)hInternetMapped,
                                       lpszUrl,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwFlags,
                                       dwContext
                                       );

        if (pFsm != NULL) {
            // IE6 BUG #27905
            // check if ctor of CFsm_ParseUrlForHttp encountered an error
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                // first call will not be on this API's thread context
                pFsm->ClearOnApiCall();
                error = pFsm->QueueWorkItem();
            } else {
                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    } else {
        bDeref = TRUE;
        CFsm_ParseUrlForHttp *pFsm;

        pFsm = new CFsm_ParseUrlForHttp(&hUrl,
                                       (INTERNET_HANDLE_OBJECT *)hInternetMapped,
                                       lpszUrl,
                                       lpszHeaders,
                                       dwHeadersLength,
                                       dwFlags,
                                       dwContext
                                       );
        if (pFsm != NULL) {
            // IE6 BUG #27905
            // check if ctor of CFsm_ParseUrlForHttp encountered an error
            error = pFsm->GetError();
            if (error == ERROR_SUCCESS) {
                error = DoFsm(pFsm);
            } else {
                delete pFsm;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if ( error == ERROR_IO_PENDING )
    {
        bDeref = FALSE;
    }

quit:

    if (bDeref && hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }

    if ( lpThreadInfo != NULL ) {
        _InternetDecNestingCount(nestingLevel);
    }

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        hUrl = NULL;
    }

    DEBUG_LEAVE_API(hUrl);

    return hUrl;
}




INTERNETAPI_(BOOL) InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    This functions reads the next block of data from the file object. The
    following handle/data types are supported:

        TypeGopherFileHandle        - raw gopher file data
        TypeGopherFileHandleHtml    - HTML-encapsulated gopher file data
        TypeGopherFindHandleHtml    - HTML-encapsulated gopher directory data
        TypeFtpFileHandle           - raw FTP file data
        TypeFtpFileHandleHtml       - HTML-encapsulated FTP file data
        TypeFtpFindHandleHtml       - HTML-encapsulated FTP directory data

Arguments:

    hFile                   - handle returned from Open function

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - size of lpBuffer in BYTEs

    lpdwNumberOfBytesRead   - returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetReadFile",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    BOOL bEndRead = TRUE;
    HINTERNET_HANDLE_TYPE handleType = TypeWildHandle;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFileMapped, &context);

    if (!lpThreadInfo->IsAsyncWorkerThread) {

        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle and retrieve its type
    //

    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // we should not get an error - we already believe the handle object
        // is valid and of the type just retrieved!
        //

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // ensure correct handle type
    //

    if ((handleType != TypeHttpRequestHandle)
    && (handleType != TypeFtpFileHandle)
    && (handleType != TypeGopherFileHandle)
    && (handleType != TypeFtpFindHandleHtml)
    && (handleType != TypeGopherFindHandleHtml)
    && (handleType != TypeFtpFileHandleHtml)
    && (handleType != TypeGopherFileHandleHtml)
    && (handleType != TypeFileRequestHandle)) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        goto quit;
    }

    //
    // validate parameters
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {
        error = ProbeAndSetDword(lpdwNumberOfBytesRead, 0);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
        error = ProbeWriteBuffer(lpBuffer, dwNumberOfBytesToRead);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        *lpdwNumberOfBytesRead = 0;

        if (((handleType == TypeFtpFindHandleHtml) ||
            (handleType == TypeGopherFindHandleHtml)) &&
            ((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                            IsCacheReadInProgress())
        {
            error = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                                        ReadCache((LPBYTE)lpBuffer,
                                        dwNumberOfBytesToRead,
                                        &bytesRead);
            success = (error == ERROR_SUCCESS);
            goto quit;
        }

        if (handleType == TypeHttpRequestHandle) {

            HTTP_REQUEST_HANDLE_OBJECT *lpRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hFileMapped;

            // See if request can be fulfilled from file system.
            if (lpRequest->AttemptReadFromFile
                (lpBuffer, dwNumberOfBytesToRead, &bytesRead)) {
                success = TRUE;
                goto quit;
            }

        } // end if (handleType == TypeHttpRequestHandle)

        else
        {
            //
            // trap a zero-length buffer before we go to the trouble of going async.
            // Maintain compatibility with base ReadFile(), although this is
            // POTENTIALLY A BUG. ReadFile() is *supposed* to return TRUE and number
            // of bytes read equal to zero to indicate end-of-file, but it will also
            // return TRUE and zero if a read of zero bytes is requested. According
            // to MarkL, that's the way it is. Good enough for me...
            //
            // For http, AttemptToReadFromFile traps zero-length reads

            if (dwNumberOfBytesToRead == 0) {

                //
                // *lpdwNumberOfBytesRead and error should have been correctly set
                // during parameter validation
                //

                INET_ASSERT(*lpdwNumberOfBytesRead == 0);
                INET_ASSERT(error == ERROR_SUCCESS);

                success = TRUE;
                goto quit;
            }
        } // end else (handleType != TypeHttpRequestHandle)

    } // end if (!lpThreadInfo->IsAsyncWorkerThread)

    //
    // the request will only be made asynchronously if more data is requested
    // than is immediately available AND we haven't reached end of file
    //

    DWORD available;

    available = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->AvailableDataLength();

    BOOL eof;

    eof = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsEndOfFile();

    if (!lpThreadInfo->IsAsyncWorkerThread
    && isAsync
    && (context != INTERNET_NO_CALLBACK)
    && (dwNumberOfBytesToRead > available)
    && !eof
    && (handleType != TypeHttpRequestHandle)
    && (handleType != TypeFileRequestHandle)) {

        // MakeAsyncRequest
        CFsm_InternetReadFile * pFsm;

        pFsm = new CFsm_InternetReadFile(hFile, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                bEndRead = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;

        //
        // we're going synchronous - set the error so we do the right thing when
        // we exit
        //

        error = ERROR_SUCCESS;
    } else if ((available >= dwNumberOfBytesToRead) || eof) {

        DEBUG_PRINT(API,
                    INFO,
                    ("immediate read: %d requested, %d available. EOF = %B\n",
                    dwNumberOfBytesToRead,
                    available,
                    eof
                    ));

    }

    INET_ASSERT(error == ERROR_SUCCESS);

    //
    // just call the underlying API: return whatever it returns, and let it
    // handle setting the last error
    //

    switch (handleType) {
    case TypeFtpFileHandle:
        success = FtpReadFile(hFileMapped,
                              lpBuffer,
                              dwNumberOfBytesToRead,
                              &bytesRead
                              );
        break;

    case TypeGopherFileHandle:
        success = GopherReadFile(hFileMapped,
                                 lpBuffer,
                                 dwNumberOfBytesToRead,
                                 &bytesRead
                                 );
        break;

    case TypeFtpFindHandleHtml:
    case TypeGopherFindHandleHtml:

        //
        // HTML handle types - convert underlying data to HTML document
        //

        success = ReadHtmlUrlData(hFileMapped,
                                  lpBuffer,
                                  dwNumberOfBytesToRead,
                                  &bytesRead
                                  );

        if (((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->IsCacheWriteInProgress())
        {
            DWORD errorCache;

            if (success) {


                if (bytesRead) {

                    errorCache = ((INTERNET_CONNECT_HANDLE_OBJECT *)hFileMapped)->
                                    WriteCache(
                                        (LPBYTE)lpBuffer,
                                        bytesRead
                                    );
                }
                else {
                    errorCache = ERROR_NO_MORE_FILES;
                }

            }
            else {
                errorCache = GetLastError();
            }

            // if the thing failed because the caller passed in
            // insufficient buffer for internetreadfile
            // then we should do nothing

            if ((errorCache != ERROR_SUCCESS)&&
                (errorCache != ERROR_INSUFFICIENT_BUFFER)) {
                if (handleType == TypeFtpFindHandleHtml) {

                    // we save extension in the index file
                    // this is used to differentiate between html directory
                    // entry from the non-html one for the same url

                    InbLocalEndCacheWrite(  hFileMapped,
                                            "htm",  // save extension in index file
                                            (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
                else {
                    InbGopherLocalEndCacheWrite(  hFileMapped,
                                                "htm",
                                                (errorCache == ERROR_NO_MORE_FILES)
                                         );
                }
            }
        }

        break;


    case TypeFtpFileHandleHtml:
    case TypeGopherFileHandleHtml:

        //
        // HTML handle types - convert underlying data to HTML document
        //

        success = ReadHtmlUrlData(hFileMapped,
                                  lpBuffer,
                                  dwNumberOfBytesToRead,
                                  &bytesRead
                                  );
        break;

    case TypeHttpRequestHandle:

        {
            //HTTP_REQUEST_HANDLE_OBJECT * lpRequest;
            //
            //lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
            //
            //error = lpRequest->QuickSyncRead(
            //                lpBuffer,
            //                dwNumberOfBytesToRead,
            //                lpdwNumberOfBytesRead,
            //                0
            //                );
            //
            //if ( error == ERROR_IO_PENDING )
            //{
                error = DoFsm(new CFsm_ReadFile(lpBuffer,
                                                dwNumberOfBytesToRead,
                                                lpdwNumberOfBytesRead
                                                ));
            //}

            success = (error == ERROR_SUCCESS) ? TRUE : FALSE;
            bEndRead = FALSE;
            break;
        }

    case TypeFileRequestHandle:

        success = ReadFile(
                    ((INTERNET_FILE_HANDLE_OBJECT *) hFileMapped)->GetFileHandle(),
                    lpBuffer,
                    dwNumberOfBytesToRead,
                    &bytesRead,
                    NULL // overlapped I/O
                    );

        if (!success)
        {
            error = GetLastError();
        }
        else
        {
            error = ERROR_SUCCESS;
        }

        break;

    case TypeFtpFindHandle:
    case TypeGopherFindHandle:

        //
        // you cannot receive RAW directory data using this API. You have
        // to call InternetFindNextFile()
        //

    default:

        //
        // the handle is a valid handle (or else RGetHandleType() would
        // have returned ERROR_INVALID_HANDLE), but this operation is
        // inconsistent with the handle type. Return a more prosaic error
        // code
        //

        error = ERROR_INTERNET_INVALID_OPERATION;
        break;
    }

quit:

    _InternetDecNestingCount(nestingLevel);;

    if (bEndRead) {

        //
        // if handleType is not HttpRequest or File then we are making this
        // request in the context of an uninterruptable async worker thread.
        // HTTP and file requests use the normal mechanism. In the case of non-
        // HTTP and file requests, we need to treat the request as if it were
        // sync and deref the handle
        //

        ReadFile_End(!lpThreadInfo->IsAsyncWorkerThread
                     || !((handleType == TypeHttpRequestHandle)
                          || (handleType == TypeFileRequestHandle)),
                     success,
                     hFileMapped,
                     bytesRead,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     );
    }

    if (lpThreadInfo && !lpThreadInfo->IsAsyncWorkerThread) {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_READ_FILE,
                 bytesRead,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

done:

    //
    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    //

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    )

/*++

Routine Description:

    Common end-of-read processing:

        - update bytes read parameter
        - dump data if logging & API data requested
        - dereference handle if not async request

Arguments:

    bDeref                  - TRUE if handle should be dereferenced (should be
                              FALSE for async request)

    bSuccess                - TRUE if Read completed successfully

    hFileMapped             - mapped file handle

    dwBytesRead             - number of bytes read

    lpBuffer                - into this buffer

    dwNumberOfBytesToRead   - originally requested bytes to read

    lpdwNumberOfBytesRead   - where bytes read is stored

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_INET,
                 None,
                 "ReadFile_End",
                 "%B, %B, %#x, %d, %#x, %d, %#x",
                 bDeref,
                 bSuccess,
                 hFileMapped,
                 dwBytesRead,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    if (bSuccess) {

        //
        // update the amount of immediate data available only if we succeeded
        //

        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->ReduceAvailableDataLength(dwBytesRead);

        if (lpdwNumberOfBytesRead != NULL) {
            *lpdwNumberOfBytesRead = dwBytesRead;

            DEBUG_PRINT(API,
                        INFO,
                        ("*lpdwNumberOfBytesRead = %d\n",
                        *lpdwNumberOfBytesRead
                        ));

            //
            // dump API data only if requested
            //

            IF_DEBUG_CONTROL(DUMP_API_DATA) {
                DEBUG_DUMP_API(API,
                               "Received data:\n",
                               lpBuffer,
                               *lpdwNumberOfBytesRead
                               );
            }
        }
        if (dwBytesRead < dwNumberOfBytesToRead) {

            DEBUG_PRINT(API,
                        INFO,
                        ("(!) bytes read (%d) < bytes requested (%d)\n",
                        dwBytesRead,
                        dwNumberOfBytesToRead
                        ));

        }
    }

    //
    // if async request, handle will be deref'd after REQUEST_COMPLETE callback
    // is delivered
    //

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    PERF_LOG(PE_CLIENT_REQUEST_END,
             AR_INTERNET_READ_FILE,
             dwBytesRead,
             0,
             (!bDeref && hFileMapped) ? ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle() : NULL
             );

    DEBUG_LEAVE(0);
}


DWORD
CFsm_ReadFile::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFile::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFile * stateMachine = (CFsm_ReadFile *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFile_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFile_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFile & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }
    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 fsm.m_dwBytesRead,
                 fsm.m_lpBuffer,
                 fsm.m_dwNumberOfBytesToRead,
                 fsm.m_lpdwNumberOfBytesRead
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetReadFileExA(
    IN HINTERNET hFile,
    OUT LPINTERNET_BUFFERSA lpBuffersOut,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetReadFileExA",
                     "%#x, %#x [%#x, %d], %#x, %#x",
                     hFile,
                     lpBuffersOut,
                     (lpBuffersOut ? lpBuffersOut->lpvBuffer : NULL),
                     (lpBuffersOut ? lpBuffersOut->dwBufferLength : 0),
                     dwFlags,
                     dwContext
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    LPVOID lpBuffer = NULL;
    DWORD dwNumberOfBytesToRead;
    BOOL bEndRead = TRUE;
    BOOL success = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto done;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFileMapped, &context);

    if (!lpThreadInfo->IsAsyncWorkerThread) {

        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto done;
    }

    //
    // validate handle and retrieve its type
    //

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto done;
    }

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // we should not get an error - we already believe the handle object
        // is valid and of the type just retrieved!
        //

        INET_ASSERT(FALSE);

        goto done;
    }

    //
    // only accepting HTTP handles currently
    //

    if (handleType != TypeHttpRequestHandle) {
        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        goto done;
    }

    HTTP_REQUEST_HANDLE_OBJECT * lpRequest;

    lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;

    //
    // validate params
    //

    if (lpBuffersOut->dwStructSize != sizeof(INTERNET_BUFFERS)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    lpBuffer = lpBuffersOut->lpvBuffer;
    dwNumberOfBytesToRead = lpBuffersOut->dwBufferLength;

    INET_ASSERT(dwNumberOfBytesToRead > 0);

    //
    // See if request can be fulfilled from file system.
    //

    if (lpRequest->AttemptReadFromFile(lpBuffer,
                                       dwNumberOfBytesToRead,
                                       &bytesRead)) {
        error = ERROR_SUCCESS;
        goto quit;
    }

    //
    // trap a zero-length buffer before we go to the trouble of going async.
    // Maintain compatibility with base ReadFile(), although this is
    // POTENTIALLY A BUG. ReadFile() is *supposed* to return TRUE and number
    // of bytes read equal to zero to indicate end-of-file, but it will also
    // return TRUE and zero if a read of zero bytes is requested. According
    // to MarkL, that's the way it is. Good enough for me...
    //
    // For http, AttemptToReadFromFile traps zero-length reads

    if (dwNumberOfBytesToRead == 0) {

        //
        // *lpdwNumberOfBytesRead and error should have been correctly set
        // during parameter validation
        //

        INET_ASSERT(error == ERROR_SUCCESS);

        goto quit;
    }

    //error = lpRequest->QuickSyncRead(
    //                lpBuffer,
    //                dwNumberOfBytesToRead,
    //                &bytesRead,
    //                SF_NO_WAIT
    //                );
    //
    //if ( error == ERROR_IO_PENDING )
    //{
        error = DoFsm(new CFsm_ReadFileEx(lpBuffersOut,
                                          dwFlags,
                                          dwContext
                                          ));
    //}

    if (error == ERROR_SUCCESS) {
        bytesRead = lpBuffersOut->dwBufferLength;
    }
    bEndRead = FALSE;

quit:

    _InternetDecNestingCount(nestingLevel);;

    if (bEndRead) {
        ReadFile_End(TRUE,
                     (error == ERROR_SUCCESS),
                     hFileMapped,
                     bytesRead,
                     lpBuffersOut->lpvBuffer,
                     dwNumberOfBytesToRead,
                     &lpBuffersOut->dwBufferLength
                     );

    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


DWORD
CFsm_ReadFileEx::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFileEx::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFileEx * stateMachine = (CFsm_ReadFileEx *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFileEx_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFileEx_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFileEx & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        fsm.m_dwNumberOfBytesToRead = fsm.m_lpBuffersOut->dwBufferLength;
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffersOut->lpvBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             (fsm.m_dwFlags & IRF_NO_WAIT)
                               ? SF_NO_WAIT
                               : 0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }

    //
    // if we are asynchronously completing a no-wait read then we don't update
    // any app parameters - we simply return the indication that we completed.
    // The app will then make another no-wait read to get the data
    //

    BOOL bNoOutput;

    bNoOutput = ((fsm.m_dwFlags & IRF_NO_WAIT)
                && fsm.GetThreadInfo()->IsAsyncWorkerThread)
                    ? TRUE
                    : FALSE;

    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 bNoOutput ? 0    : fsm.m_dwBytesRead,
                 bNoOutput ? NULL : fsm.m_lpBuffersOut->lpvBuffer,
                 bNoOutput ? 0    : fsm.m_dwNumberOfBytesToRead,
                 bNoOutput ? NULL : &fsm.m_lpBuffersOut->dwBufferLength
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetWriteFile(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    This function write next block of data to the internet file. Currently it
    supports the following protocol data:

        FtpWriteFile
        HttpWriteFile
        FileWriteFile

Arguments:

    hFile                       - handle that was obtained by OpenFile Call

    lpBuffer                    - pointer to the data buffer

    dwNumberOfBytesToWrite      - number of bytes in the above buffer

    lpdwNumberOfBytesWritten    -  pointer to a DWORD where the number of bytes
                                   of data actually written is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetWriteFile",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToWrite,
                     lpdwNumberOfBytesWritten
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fNeedDeref = TRUE;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFileMapped, &context);
    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate handle and retrieve its type
    //

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // we should not get an error - we already believe the handle object
        // is valid and of the type just retrieved!
        //

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // validate parameters - write length cannot be 0
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {
        if (dwNumberOfBytesToWrite != 0) {
            error = ProbeReadBuffer((LPVOID)lpBuffer, dwNumberOfBytesToWrite);
            if (error == ERROR_SUCCESS) {
                error = ProbeAndSetDword(lpdwNumberOfBytesWritten, 0);
            }
        } else {
            error = ERROR_INVALID_PARAMETER;
        }
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }


    // # 62953
    // If the authentication state of the handle is Negotiate,
    // don't submit data to the server but return success.
    // ** Added test for NTLM or Negotiate - Adriaanc.
    if (handleType == TypeHttpRequestHandle)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest;
        pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hFileMapped;

        if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE
            && !((PLUG_CTX*) (pRequest->GetAuthCtx()))->_fNTLMProxyAuth
            && !(pRequest->GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_DPA))
        {
            *lpdwNumberOfBytesWritten = dwNumberOfBytesToWrite;
            error = ERROR_SUCCESS;
            success = TRUE;
            goto quit;
        }
    }
    //
    // we have to do some work. If the file object handle was created with
    // async I/O capability then we will queue an async request, otherwise
    // we will process the request synchronously
    //

    if (isAsync
    && !lpThreadInfo->IsAsyncWorkerThread
    && (handleType != TypeHttpRequestHandle)
    && (handleType != TypeFileRequestHandle)) {

        // MakeAsyncRequest
        CFsm_InternetWriteFile * pFsm;

        pFsm = new CFsm_InternetWriteFile(hFile, lpBuffer, dwNumberOfBytesToWrite, lpdwNumberOfBytesWritten);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if ( error == ERROR_IO_PENDING ) {
                fNeedDeref = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;

        //
        // we're going synchronous. Change error to ERROR_SUCCESS so that we do
        // the right thing at quit
        //

        error = ERROR_SUCCESS;
    }

    INET_ASSERT(error == ERROR_SUCCESS);

    switch (handleType) {
    case TypeFtpFileHandle:
        success = FtpWriteFile(hFileMapped,
                               (LPVOID)lpBuffer,
                               dwNumberOfBytesToWrite,
                               lpdwNumberOfBytesWritten
                               );
        break;

    case TypeHttpRequestHandle:
        error = HttpWriteData(hFileMapped,
                               (LPVOID)lpBuffer,
                               dwNumberOfBytesToWrite,
                               lpdwNumberOfBytesWritten,
                               0
                               );
        //
        // Don't Derefrence if we're going pending cause the FSM will do
        //  it for us.
        //

        if ( error == ERROR_IO_PENDING )
        {
            fNeedDeref = FALSE;
        }
        success = (error == ERROR_SUCCESS) ? TRUE : FALSE;
        //bEndRead = FALSE;
        break;

    case TypeFileRequestHandle:

        success = WriteFile(((INTERNET_FILE_HANDLE_OBJECT *) hFileMapped)->GetFileHandle(),
                               (LPVOID)lpBuffer,
                               dwNumberOfBytesToWrite,
                               lpdwNumberOfBytesWritten,
                               NULL // overlapped I/O
                               );

        if ( !success )
        {
            error = GetLastError();
        }
        else
        {
            error = ERROR_SUCCESS;
        }

        break;

    default:
        error = ERROR_INVALID_HANDLE;
        break;
    }

quit:

    if (hFileMapped != NULL && fNeedDeref) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) InternetWriteFileExA(
    IN HINTERNET hFile,
    IN LPINTERNET_BUFFERSA lpBuffersIn,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


INTERNETAPI_(DWORD) InternetSetFilePointer(
    IN HINTERNET hFile,
    IN LONG lDistanceToMove,
    IN PVOID pReserved,
    IN DWORD dwMoveMethod,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sets a file position for InternetReadFile.  It is a synchronous call,
    however subsequent calls to InternetReadFile may block or return
    pending if the data is not available from the cache and the server
    does not support random access.

Arguments:

    hFile
        A valid handle returned from a previous call to InternetOpenUrl
        or a handle returned from HttpOpenRequest for a GET or HEAD method
        and passed to HttpSendRequest.  The handle must have been created
        without INTERNET_FLAG_DONT_CACHE.

    lDistanceToMove

        Specifies the number of bytes to move the file pointer. A positive
        value moves the pointer forward in the file and a negative value
        moves it backward.

pReserved
        Reserved, pass NULL.

dwMoveMethod
        Specifies the starting point for the file pointer move. This
        parameter can be one of the following values:

        Value            Meaning
        FILE_BEGIN       The starting point is zero or the beginning of the file.
                         If FILE_BEGIN is specified, DistanceToMove is interpreted
                         as an unsigned location for the new file pointer.
        FILE_CURRENT     The current value of the file pointer is the starting point.
        FILE_END         The current end-of-file position is the starting point.
                         This method will fail if the content length is unknown.

Return Value:

    -1 on failure, else the current file position.

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Int,
                     "InternetSetFilePointer",
                     "%#x, %#x, %#x, %#x %#x",
                     hFile,
                     lDistanceToMove,
                     pReserved,
                     dwMoveMethod,
                     dwContext
                     ));

    DWORD dwNewPosition = (DWORD) -1L;
    DWORD error;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    // Validate parameters...

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    HINTERNET_HANDLE_TYPE handleType;
    error = RGetHandleType(hFileMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    switch (handleType) {
        // case TypeFtpFileHandle:
        // case TypeGopherFileHandle:
        case TypeHttpRequestHandle:
            break;
        default:
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT *lpRequest;
    lpRequest = (HTTP_REQUEST_HANDLE_OBJECT *) hFileMapped;
    dwNewPosition = lpRequest->SetStreamPointer (lDistanceToMove, dwMoveMethod);

quit:

    if (hFileMapped != NULL) {
        DereferenceObject((LPVOID)hFileMapped);
    }

done:

    DEBUG_LEAVE_API(dwNewPosition);

    return dwNewPosition;
}



INTERNETAPI_(BOOL) InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Determines the amount of data currently available to be read on the handle

Arguments:

    hFile                       - handle of internet object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

    dwFlags                     - flags controlling operation - FUTURE

    dwContext                   - used to differentiate multiple requests - FUTURE

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryDataAvailable",
                     "%#x, %#x, %#x, %#x",
                     hFile,
                     lpdwNumberOfBytesAvailable,
                     dwFlags,
                     dwContext
                     ));

    BOOL success;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL bDeref = TRUE;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        bDeref = FALSE;
        goto quit;
    }

    INET_ASSERT(hFile);

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    PERF_LOG(PE_CLIENT_REQUEST_START,
             AR_INTERNET_QUERY_DATA_AVAILABLE,
             lpThreadInfo->ThreadId,
             hFile
             );

    //
    // validate parameters
    //

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL)) {
        goto quit;
    }

    INET_ASSERT(hFileMapped);

    //
    // set the context and handle values in the per-thread info block (this API
    // can't return extended error info, so we don't care about it)
    //

    _InternetSetContext(lpThreadInfo,
                        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->GetContext()
                        );
    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);

    //
    // if the handle is invalid, quit now
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate rest of parameters
    //

    error = ProbeAndSetDword(lpdwNumberOfBytesAvailable, 0);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // get the handle type
    //

    HINTERNET_HANDLE_TYPE handleType;

    handleType = ((HANDLE_OBJECT *)hFileMapped)->GetHandleType();

    //
    // find out if we're sync or async
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFileMapped, &isLocal, &isAsync, TypeWildHandle);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    // WinSE 4998.  If there's no context on the handle, force the request to be synchronous.
    //
    if (isAsync && lpThreadInfo->Context == INTERNET_NO_CALLBACK)
    {
        DEBUG_PRINT(API,
                    ERROR,
                    ("Zero context: Call is Synchronous\n"
                    ));
        isAsync = FALSE;
    }

    //
    // since the async worker thread doesn't come back through this API, the
    // following test is sufficient. Note that we only go async if there is
    // no data currently available on the handle
    //

    BOOL dataAvailable;

    dataAvailable = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable();

    BOOL eof;

    eof = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsEndOfFile();

    if ((handleType != TypeHttpRequestHandle)
    && isAsync
    && !dataAvailable
    && !eof) {

        INET_ASSERT(hFileMapped);

        // MakeAsyncRequest
        CFsm_InternetQueryDataAvailable * pFsm;

        pFsm = new CFsm_InternetQueryDataAvailable(hFileMapped, lpdwNumberOfBytesAvailable, dwFlags, dwContext);
        if (pFsm != NULL) {
            error = pFsm->QueueWorkItem();
            if (error == ERROR_IO_PENDING) {
                bDeref = FALSE;
            }
        } else {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        //
        // if we're here then ERROR_SUCCESS cannot have been returned from
        // the above calls
        //

        INET_ASSERT(error != ERROR_SUCCESS);


        DEBUG_PRINT(FTP,
                    INFO,
                    ("processing request asynchronously: error = %d\n",
                    error
                    ));

        goto quit;

        //
        // we will continue along the synchronous path, in which case we
        // need to set error back to ERROR_SUCCESS so that our exit
        // processing (at quit) does the right thing
        //

        error = ERROR_SUCCESS;
    } else if (dataAvailable || eof) {

        DWORD available;

        available = ((INTERNET_HANDLE_OBJECT *)hFileMapped)->AvailableDataLength();

        //
        // we have immediate data; if the handle type is FTP or gopher find and
        // the data is coming from cache, then we only want to indicate that a
        // single (fixed-length) find structure is available
        //

        switch (((HANDLE_OBJECT *)hFileMapped)->GetHandleType()) {
        case TypeFtpFindHandle:
            available = min(available, sizeof(WIN32_FIND_DATA));
            break;

        case TypeGopherFindHandle:
            available = min(available, sizeof(GOPHER_FIND_DATA));
            break;
        }

        DEBUG_PRINT(API,
                    INFO,
                    ("%d bytes are immediately available\n",
                    available
                    ));

        *lpdwNumberOfBytesAvailable = available;
        success = TRUE;
        goto finish;
    }

    INET_ASSERT(hFileMapped);

    //
    // sync path. wInternetQueryDataAvailable will set the last error code
    // if it fails
    //

    if (handleType == TypeHttpRequestHandle) {
        error = DoFsm(new CFsm_QueryAvailable(lpdwNumberOfBytesAvailable,
                                              dwFlags,
                                              dwContext
                                              ));
        if (error == ERROR_SUCCESS) {
            success = TRUE;
        } else {
            if (error == ERROR_IO_PENDING) {
                bDeref = FALSE;
            }
            goto quit;
        }
    } else {
        success = wInternetQueryDataAvailable(hFileMapped,
                                              lpdwNumberOfBytesAvailable,
                                              dwFlags,
                                              dwContext
                                              );
    }

finish:

    DEBUG_PRINT_API(API,
                    INFO,
                    ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                    lpdwNumberOfBytesAvailable,
                    *lpdwNumberOfBytesAvailable
                    ));

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (lpThreadInfo) {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_QUERY_DATA_AVAILABLE,
                 *lpdwNumberOfBytesAvailable,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    DEBUG_LEAVE_API(success);

    return success;

    //
    // we only come here if we are returning an error before calling
    // wInternetQueryDataAvailable
    //

    INET_ASSERT(error != ERROR_SUCCESS);

quit:

    DEBUG_ERROR(API, error);

    SetLastError(error);
    success = FALSE;

    goto finish;
}


DWORD
CFsm_QueryAvailable::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_QueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_QueryAvailable * stateMachine = (CFsm_QueryAvailable *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = QueryAvailable_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_QueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.GetMappedHandle();

    if (fsm.GetState() == FSM_STATE_INIT) {
        error = pRequest->QueryDataAvailable(fsm.m_lpdwNumberOfBytesAvailable);
    }
    if (error == ERROR_SUCCESS) {
        pRequest->SetAvailableDataLength(*fsm.m_lpdwNumberOfBytesAvailable);

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    *fsm.m_lpdwNumberOfBytesAvailable
                    ));

        fsm.SetApiData(*fsm.m_lpdwNumberOfBytesAvailable);
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}


INTERNETAPI_(BOOL) InternetFindNextFileA(
    IN HINTERNET hFind,
    OUT LPVOID lpBuffer
    )

/*++

Routine Description:

    Returns the next directory entry in the listing identified by the handle

Arguments:

    hFind       - find handle, as returned by e.g. FtpFindFirstFile()

    lpBuffer    - pointer to buffer where next directory entry information will
                  be written. Contents of buffer may be different depending on
                  type of directory request, and protocol used (FTP/gopher/etc.)

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetFindNextFileA",
                     "%#x, %#x",
                     hFind,
                     lpBuffer
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fDeref = TRUE;
    HINTERNET hFindMapped = NULL;

    if (!GlobalDataInitialized) {
        error = ERROR_INTERNET_NOT_INITIALIZED;
        goto done;
    }

    //
    // we need the per-thread info block on all paths
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    //
    // map the handle
    //

    error = MapHandleToAddress(hFind, (LPVOID *)&hFindMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFindMapped == NULL)) {
        goto quit;
    }

    //
    // set the context, handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    DWORD_PTR context;

    RGetContext(hFindMapped, &context);
    _InternetSetContext(lpThreadInfo, context);
    _InternetSetObjectHandle(lpThreadInfo, hFind, hFindMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // retrieve handle type, and validate in the process
    //

    HINTERNET_HANDLE_TYPE handleType;

    error = RGetHandleType(hFindMapped, &handleType);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // get async/sync and local/remote
    //

    BOOL isLocal;
    BOOL isAsync;

    error = RIsHandleLocal(hFindMapped, &isLocal, &isAsync, handleType);
    if (error != ERROR_SUCCESS) {

        //
        // this should never happen - we just successfully called
        // RGetHandleType(), so RIsHandleLocal() should have worked too
        //

        DEBUG_PRINT(INET,
                    ERROR,
                    ("RIsHandleLocal() returns %d\n",
                    error
                    ));

        INET_ASSERT(FALSE);

        goto quit;
    }

    //
    // make sure the handle type is valid for this request. We only support
    // FTP find handle and gopher find handle (both raw data)
    //

    if (!((handleType == TypeFtpFindHandle)
    || (handleType == TypeGopherFindHandle))) {
        error = ERROR_INTERNET_INVALID_OPERATION;
        goto quit;
    }

    //
    // if we're not in an async worker thread context then probe the buffer. If
    // we are in the async worker thread context, then we've already validated
    // the buffer. If is has since become invalid, then the app will fail
    //

    if (!lpThreadInfo->IsAsyncWorkerThread) {
        error = ProbeWriteBuffer(lpBuffer,
                                 (handleType == TypeFtpFindHandle)
                                    ? sizeof(WIN32_FIND_DATA)
                                    : sizeof(GOPHER_FIND_DATA)
                                 );
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // if this is an async request and we are not an async worker thread
        // then queue the request
        //

        if (isAsync) {

            // MakeAsyncRequest
            CFsm_InternetFindNextFile * pFsm;

            pFsm = new CFsm_InternetFindNextFile(hFind, lpBuffer);
            if (pFsm != NULL) {
                error = pFsm->QueueWorkItem();
                if ( error == ERROR_IO_PENDING ) {
                    fDeref = FALSE;
                }
            } else {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            //
            // if we're here then ERROR_SUCCESS cannot have been returned from
            // the above calls
            //

            INET_ASSERT(error != ERROR_SUCCESS);


            DEBUG_PRINT(FTP,
                        INFO,
                        ("processing request asynchronously: error = %d\n",
                        error
                        ));

            goto quit;

            //
            // we will continue along the synchronous path, in which case we
            // need to set error back to ERROR_SUCCESS so that our exit
            // processing (at quit) does the right thing
            //

            error = ERROR_SUCCESS;
        }
    }

    //
    // dispatch to the underlying API. Return what the API returns, and let
    // the API SetLastError()
    //
    // N.B. We have already checked the handle type above, and we know at
    // this stage that we have a correct handle type
    //

    INET_ASSERT(error == ERROR_SUCCESS);

    switch (handleType) {
    case TypeFtpFindHandle:
        success = FtpFindNextFileA(hFindMapped,
                                   (LPWIN32_FIND_DATA)lpBuffer
                                   );
        break;

    case TypeGopherFindHandle:
        success = GopherFindNextA(hFindMapped,
                                  (LPGOPHER_FIND_DATA)lpBuffer
                                  );
        break;
    }

quit:

    if (hFindMapped != NULL && fDeref) {
        DereferenceObject((LPVOID)hFindMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    //
    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    //

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE_API(success);
    return success;
}



INTERNETAPI_(BOOL) InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwErrorCategory,
    IN LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    This function returns the per-thread last internet error description text
    or server response.

    If this function is successful, *lpdwBufferLength contains the string length
    of lpszBuffer.

    If this function returns a failure indication, *lpdwBufferLength contains
    the number of BYTEs required to hold the response text

Arguments:

    lpdwErrorCategory   - pointer to DWORD location where the error catagory is
                          returned

    lpszBuffer          - pointer to buffer where the error text is returned

    lpdwBufferLength    - IN: length of lpszBuffer
                          OUT: number of characters in lpszBuffer if successful
                          else size of buffer required to hold response text

Return Value:

    BOOL
        Success - TRUE
                    lpszBuffer contains the error text. The caller must check
                    *lpdwBufferLength: if 0 then there was no text to return

        Failure - FALSE
                    Call GetLastError() for more information

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoA",
                     "%#x, %#x, %#x [%d]",
                     lpdwErrorCategory,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    BOOL success;
    DWORD textLength;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    //
    // validate parameters
    //

    if (IsBadWritePtr(lpdwErrorCategory, sizeof(*lpdwErrorCategory))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszBuffer)
        ? IsBadWritePtr(lpszBuffer, *lpdwBufferLength)
        : FALSE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the buffer pointer is NULL then its the same as a zero-length buffer
    //

    if (!ARGUMENT_PRESENT(lpszBuffer)) {
        *lpdwBufferLength = 0;
    } else if (*lpdwBufferLength != 0) {
        *lpszBuffer = '\0';
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(INET,
                    ERROR,
                    ("failed to get INTERNET_THREAD_INFO\n"
                    ));

        INET_ASSERT(FALSE);

        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    //
    // there may not be any error text for this thread - either no server
    // error/response has been received, or the error text has been cleared by
    // an intervening API
    //

    if (lpThreadInfo->hErrorText != NULL) {

        //
        // copy as much as we can fit in the user supplied buffer
        //

        textLength = lpThreadInfo->ErrorTextLength;
        if (*lpdwBufferLength) {

            LPBYTE errorText;

            errorText = (LPBYTE)LOCK_MEMORY(lpThreadInfo->hErrorText);
            if (errorText != NULL) {
                textLength = min(textLength, *lpdwBufferLength) - 1;
                memcpy(lpszBuffer, errorText, textLength);

                //
                // the error text should always be zero terminated, so the
                // calling app can treat it as a string
                //

                lpszBuffer[textLength] = '\0';

                UNLOCK_MEMORY(lpThreadInfo->hErrorText);

                if (textLength == lpThreadInfo->ErrorTextLength - 1) {
                    error = ERROR_SUCCESS;
                } else {

                    //
                    // returned length is amount of buffer required
                    //

                    textLength = lpThreadInfo->ErrorTextLength;
                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            } else {

                DEBUG_PRINT(INET,
                            ERROR,
                            ("failed to lock hErrorText (%#x): %d\n",
                            lpThreadInfo->hErrorText,
                            GetLastError()
                            ));

                error = ERROR_INTERNET_INTERNAL_ERROR;
            }
        } else {

            //
            // user's buffer is not large enough to hold the info. We'll
            // let them know the required length
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        INET_ASSERT(lpThreadInfo->ErrorTextLength == 0);

        textLength = 0;
        error = ERROR_SUCCESS;
    }

    *lpdwErrorCategory = lpThreadInfo->ErrorNumber;
    *lpdwBufferLength = textLength;

    IF_DEBUG(ANY) {
        if ((error == ERROR_SUCCESS)
        || ((textLength != 0) && (lpszBuffer != NULL))) {

            DEBUG_DUMP_API(API,
                           "Last Response Info:\n",
                           lpszBuffer,
                           textLength
                           );

        }
    }

quit:
    success = (error == ERROR_SUCCESS);
    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackCore(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback,
    IN BOOL fType
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DWORD dwErr = ERROR_SUCCESS;
    INTERNET_STATUS_CALLBACK previousCallback = INTERNET_INVALID_STATUS_CALLBACK;
    HINTERNET hObjectMapped = NULL;

    if (!GlobalDataInitialized) {
        dwErr = GlobalDataInitialize();
        if (dwErr != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    if ((lpfnInternetCallback != NULL) && IsBadCodePtr((FARPROC)lpfnInternetCallback))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (!hInternet)
    {
        dwErr = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        goto cleanup;
    }

    //
    // map the handle
    //

    dwErr = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwErr == ERROR_SUCCESS)
    {
        //
        // swap the new and previous handle object status callbacks, ONLY
        // if there are no pending requests on this handle
        //
        previousCallback = lpfnInternetCallback;
        dwErr = RExchangeStatusCallback(hObjectMapped, &previousCallback, fType);
    }

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(API, dwErr);
    }
    return previousCallback;
}


INTERNETAPI_(INTERNET_STATUS_CALLBACK) InternetSetStatusCallbackA(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER_API((DBG_INET,
                 Pointer,
                 "InternetSetStatusCallbackA",
                 "%#x, %#x",
                 hInternet,
                 lpfnInternetCallback
                 ));

    INTERNET_STATUS_CALLBACK previousCallback = InternetSetStatusCallbackCore(
                                                    hInternet,
                                                    lpfnInternetCallback,
                                                    FALSE
                                                    );

    DEBUG_LEAVE_API(previousCallback);
    return previousCallback;
}


//
//INTERNETAPI_(BOOL) InternetCancelAsyncRequest(
//    IN DWORD dwAsyncId
//    )
//
///*++
//
//Routine Description:
//
//    Cancels an outstanding async request
//
//Arguments:
//
//    dwAsyncId   - identifier of the async I/O request
//
//Return Value:
//
//    BOOL
//        Success - TRUE
//                    Request was cancelled
//
//        Failure - FALSE
//                    Call GetLastError() for more information
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_INET,
//                 Bool,
//                 "InternetCancelAsyncRequest",
//                 "%d",
//                 dwAsyncId
//                 ));
//
//    DWORD error;
//    BOOL success;
//
//    error = CancelAsyncRequest(dwAsyncId);
//    if (error != ERROR_SUCCESS) {
//
//        DEBUG_ERROR(INET, error);
//
//        SetLastError(error);
//        success = FALSE;
//    } else {
//        success = TRUE;
//    }
//
//    DEBUG_LEAVE(success);
//
//    return success;
//}

//
// private functions
//


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET hConnect,
    IN DWORD dwService
    )

/*++

Routine Description:

    The obverse of InternetConnect(). Closes the handle created in
    InternetConnect()

Arguments:

    hConnect    - protocol handle created in InternetConnect()

    dwService   - service required. Controls type of handle generated.
                  May be one of:
                    - INTERNET_SERVICE_FTP
                    - INTERNET_SERVICE_GOPHER
                    - INTERNET_SERVICE_HTTP

Return Value:

    Success - ERROR_SUCCESS

    Failure - ERROR_INVALID_PARAMETER
                Incorrect dwService parameter (*never* expect this)

              Windows error
              Wininet error
              WSA error
                Error from protocol-specific disconnect function
--*/

{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "wInternetCloseConnectA",
                 "%#x, %d",
                 hConnect,
                 dwService
                 ));

    DWORD error;

    switch (dwService) {
    case INTERNET_SERVICE_FTP :
        error = wFtpDisconnect(hConnect, CF_EXPEDITED_CLOSE);
        break;

    case INTERNET_SERVICE_GOPHER :
        //error = wGopherDisconnect(hConnect);
        error = ERROR_SUCCESS;
        break;

    case INTERNET_SERVICE_HTTP:
        //error = wHttpConnectClose((LPHINTERNET)hConnect);
        error = ERROR_SUCCESS;
        break;

    default:
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
GetEmailNameAndPassword(
    IN OUT LPSTR* lplpszUserName,
    IN OUT LPSTR* lplpszPassword,
    OUT LPSTR EmailName,
    IN DWORD EmailNameLength
    )

/*++

Routine Description:

    Gets the login name and password for the FTP server (but can be used for any
    other protocol)

Arguments:

    lplpszUserName  - IN: pointer to pointer to user name
                      OUT: pointer to pointer to user name; may be modified

    lplpszPassword  - IN: pointer to pointer to password
                      OUT: pointer to pointer to password; may be modified

    EmailName       - pointer to buffer in which to store password if
                      "anonymous" returned for login name

    EmailNameLength - length of EmailName

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_PARAMETER

--*/

{
    DWORD error;
    LPSTR lpszUserName;
    LPSTR lpszPassword;

    lpszUserName = *lplpszUserName;
    lpszPassword = *lplpszPassword;

    //
    // validate username and password arguments. Valid combinations are:
    // (N.B. NULL means NULL pointer or NUL string)
    //
    //  lpszUsername    lpszPassword    Result
    //
    //      NULL            NULL        "anonymous", "emailname@domain"
    //      !NULL           NULL        lpszUserName, NULL
    //      NULL            !NULL       ERROR
    //      !NULL           !NULL       lpszUserName, lpszPassword
    //

    error = ERROR_SUCCESS;
    if (lpszUserName != NULL) {
        if (IsBadStringPtr(lpszUserName, INTERNET_MAX_USER_NAME_LENGTH)) {
            error = ERROR_INVALID_PARAMETER;
        } else if (*lpszUserName == '\0') {
            lpszUserName = NULL;
        }
    }
    if (error == ERROR_SUCCESS) {
        if (lpszPassword != NULL) {
            if (IsBadStringPtr(lpszPassword, INTERNET_MAX_PASSWORD_LENGTH)) {
                error = ERROR_INVALID_PASSWORD;
            } else if (*lpszPassword == '\0') {
                lpszPassword = NULL;
            }
        }
    }
    if (error == ERROR_SUCCESS) {
        if (lpszPassword == NULL) {
            if (lpszUserName == NULL) {

                DWORD length;

                //
                // both name and password are null pointers. We will convert to
                // "anonymous", "EmailName@DomainName"
                //

                //
                // because we don't require a client to be running TCP/IP, we
                // may be unable to get a domain name. Hence we now require the
                // EmailName entry in the registry to contain the entire
                // EmailName@DomainName string, including the '@'. If this is
                // not available, then we will just return an error
                //

                lpszUserName = "anonymous";
                length = EmailNameLength;
                error = GetMyEmailName(EmailName, &EmailNameLength);
                if (error == ERROR_SUCCESS) {
                    lpszPassword = EmailName;
                }
            } else {
                lpszPassword = "";
            }
        } else if (lpszUserName == NULL) {
            error = ERROR_INVALID_PARAMETER;
        }
    }

    *lplpszUserName = lpszUserName;
    *lplpszPassword = lpszPassword;

    return error;
}


INTERNETAPI_(DWORD) InternetAttemptConnect(
    IN DWORD dwReserved
    )

/*++

Routine Description:

    This routine attempts to make a loopback socket
    Clients call this to either invoke the dialdialog or to see whether
    they are connected to the net (??).

    4/29/97 (darrenmi) This function now calls InternetAutodial to see if a
    connection needs to be made.

    This function
Arguments:


    dwReserved  - ?

Return Value:

    DWORD

        Windows error code, or sockets error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Dword,
                     "InternetAttemptConnect",
                     "%d",
                     dwReserved
                     ));

    DWORD error = ERROR_SUCCESS;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    if(!InternetAutodial(0, 0)) {
        error = ERROR_GEN_FAILURE;
    }

quit:
    DEBUG_LEAVE_API(error);
    return error;
}


INTERNETAPI_(BOOL) InternetLockRequestFile(
    IN HINTERNET hInternet,
    OUT HANDLE *lphLockReqHandle
    )

/*++

Routine Description:

    This routine allows the caller to place a lock on the file that he is
    using  by doing a CreateFile. This ensures that if this file is associated
    with this url, and another download on this url tries to commit another
    file, then this file won't vanish because the cache does a safe delete
    when updating or deleting the cache entry.
    The caller can then call the InternetUnlockRequestFile to give wininet
    the permission to delete this file if not committed to the cache.

Arguments:
    hInternet            request object which is doing the download
    lphLocReqHandle     place to return LockRequestHandle

Return Value:
    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetLockRequest",
                     "%#x, %#x",
                     hInternet,
                     lphLockReqHandle
                     ));

    DWORD error, dwSize, dwUrlLenPlus1, dwFileLenPlus1;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * pConnect;
    LPLOCK_REQUEST_INFO lpLockReqInfo = NULL;
    LPSTR lpSource;
    BOOL locked = FALSE;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternet, FALSE);
    if (error == ERROR_SUCCESS) {
        hObjectMapped = hInternet;
        pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
        error = RGetHandleType(hInternet, &handleType);
    }
    if (error != ERROR_SUCCESS) {
        goto Cleanup;
    }

    if ((handleType ==    TypeGenericHandle)||
        (handleType ==    TypeInternetHandle)||
        (handleType ==    TypeFtpConnectHandle)||
        (handleType ==    TypeGopherConnectHandle)||
        (handleType ==    TypeHttpConnectHandle) ||
        (handleType ==    TypeFileRequestHandle)) {

        error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    EnterCriticalSection(&LockRequestFileCritSec);
    locked = TRUE;

    //
    // If a lock handle was already created, simply increment the refcount.
    //

    if(lpLockReqInfo = (LPLOCK_REQUEST_INFO)(pConnect->GetLockRequestHandle())) {

        lpLockReqInfo->dwCount++;
        *lphLockReqHandle = (HANDLE)lpLockReqInfo;
        error = ERROR_SUCCESS;
        goto Cleanup;
    }

    //
    // Record the URL and associated filename in the lock handle.
    //

    lpSource = pConnect->GetDataFileName();
    if (!lpSource) {
        error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    dwSize = sizeof(LOCK_REQUEST_INFO)
            +(dwUrlLenPlus1 = lstrlen(pConnect->GetCacheKey())+1)
            +(dwFileLenPlus1 = lstrlen(lpSource)+1)+3;  // atmost 3 bytes slop

    lpLockReqInfo = (LPLOCK_REQUEST_INFO)ALLOCATE_MEMORY(LPTR,  dwSize);
    if (!lpLockReqInfo) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    lpLockReqInfo->dwSignature = LOCK_REQUEST_SIGNATURE;
    lpLockReqInfo->dwSize = dwSize;
    lpLockReqInfo->fNoCacheLookup = FALSE;

    memcpy(lpLockReqInfo->rgBuff, pConnect->GetCacheKey(), dwUrlLenPlus1);
    lpLockReqInfo->UrlName = lpLockReqInfo->rgBuff;

    // align filename to DWORD
    lpLockReqInfo->FileName = &(lpLockReqInfo->rgBuff[((dwUrlLenPlus1+sizeof(DWORD)) & ~(3))]);
    memcpy(lpLockReqInfo->FileName, lpSource, dwFileLenPlus1);

    DEBUG_PRINT(INET,
                INFO,
                ("Url==%s, File== %s\n",
                lpLockReqInfo->UrlName,
                lpLockReqInfo->FileName
                ));

    //
    // Open the file so it will not be deleted upon cache entry delete/update.
    //

    lpLockReqInfo->hFile = CreateFile (
                                lpSource,
                                GENERIC_READ,
                                FILE_SHARE_READ|FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
    if (lpLockReqInfo->hFile == INVALID_HANDLE_VALUE) {
        error = GetLastError();
        goto Cleanup;
    }

    //
    // Set refcount to 2, one for connect handle and the other for lock handle.
    // Whichever one is closed last will perform cleanup.
    //

    lpLockReqInfo->dwCount = 2;
    *lphLockReqHandle = (HANDLE)lpLockReqInfo;
    pConnect->SetLockRequestHandle((HANDLE)lpLockReqInfo);

    // Check to see if this file corresponds to an installed cache
    // entry. If so, set fNoDelete so unlocking cannot delete the file.
    // Note - because installed cache entries are generally not downloaded
    // by wininet this is ok to do - it is only necessary to check if there
    // is a cache entry in the request object and if it is an installed type.
    if (handleType == TypeHttpRequestHandle)
    {
        LPCACHE_ENTRY_INFO pcei;
        pcei = ((HTTP_REQUEST_HANDLE_OBJECT*) pConnect)->GetCacheEntryInfo();
        if (pcei)
        {
            if (pcei->CacheEntryType & INSTALLED_CACHE_ENTRY)
                lpLockReqInfo->fNoDelete = TRUE;
        }
    }

    error = ERROR_SUCCESS;

Cleanup:
    BOOL fRet = (error==ERROR_SUCCESS);

    if (!fRet) {

        if (lpLockReqInfo) {
            FREE_MEMORY(lpLockReqInfo);
        }

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    else {
        DEBUG_PRINT(INET,
                    INFO,
                    ("Url==%s, File== %s RefCount=%d, Handle = %#x\n",
                    lpLockReqInfo->UrlName,
                    lpLockReqInfo->FileName,
                    lpLockReqInfo->dwCount,
                    *lphLockReqHandle
                    ));

    }

    if (locked) {
        LeaveCriticalSection(&LockRequestFileCritSec);
    }

    if (hObjectMapped) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) InternetUnlockRequestFile(
    IN HANDLE hLockHandle
    )

/*++

Routine Description:

    This routine allows the caller to unlock a request file that was locked
    using the InternetLockRequestFile routine. This allows the file
    to be deleted after the request object is long gone.

Arguments:

    hLockHandle     Lock Request Handle that was returned in InternetLockRequestFile

Return Value:

    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetUnlockRequest",
                     "%#x",
                     hLockHandle
                     ));

    DWORD error, dwUrlLen, dwFileNameLen;
    LPLOCK_REQUEST_INFO lpLockReqInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    EnterCriticalSection(&LockRequestFileCritSec);

    lpLockReqInfo = (LPLOCK_REQUEST_INFO)hLockHandle;

    __try {
        if (lpLockReqInfo->dwSignature == LOCK_REQUEST_SIGNATURE) {

            DEBUG_PRINT(INET,
                        INFO,
                        ("Url==%s, File== %s, refcount=%d\n",
                        lpLockReqInfo->UrlName,
                        lpLockReqInfo->FileName,
                        lpLockReqInfo->dwCount
                        ));

            if (--lpLockReqInfo->dwCount == 0) {

                if (!CloseHandle(lpLockReqInfo->hFile)) {

                    DEBUG_PRINT(INET,
                                ERROR,
                                ("Error=%d while Closing OpenHandle for file=%s for url=%s\n",
                                GetLastError(),
                                lpLockReqInfo->FileName,
                                lpLockReqInfo->UrlName
                                ));

                    }

                if (!lpLockReqInfo->fNoDelete) {

                    //
                    // Validate URL and filename.
                    //

                    dwUrlLen = lstrlen(lpLockReqInfo->UrlName);
                    dwFileNameLen =  lstrlen(lpLockReqInfo->FileName);

                    //
                    // Check if there is a cache entry for the URL.
                    //

                    DWORD dwSize;
                    LPINTERNET_CACHE_ENTRY_INFO pCEI;
                    char buf[sizeof(INTERNET_CACHE_ENTRY_INFO)+MAX_PATH+1];

                    pCEI = (LPINTERNET_CACHE_ENTRY_INFO)buf;
                    dwSize = sizeof(buf);

                    if (lpLockReqInfo->fNoCacheLookup) {

                        error = ERROR_FILE_NOT_FOUND;

                    } else {
                        // Grab info and
                        // Check if the filename actually matches.
                        error = GetUrlCacheEntryInfoEx(lpLockReqInfo->UrlName,
                                            pCEI,
                                            &dwSize,
                                            NULL,
                                            NULL,
                                            NULL,
                                            INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY) ?
                                     (lstrcmpi(lpLockReqInfo->FileName, pCEI->lpszLocalFileName) ?
                                              ERROR_FILE_NOT_FOUND
                                            : ERROR_SUCCESS)
                                   : GetLastError();
                    } // end else if (!lpLockReqInfo->fNoCacheLookup)

                    if (error != ERROR_SUCCESS) {

                        //
                        // The file was not committed to cache, so attempt to delete it.
                        //

                        DEBUG_PRINT(INET, INFO,("deleting %q\n",lpLockReqInfo->FileName));

                        if (!DeleteFile(lpLockReqInfo->FileName)) {

                            DEBUG_PRINT(INET,
                                        ERROR,
                                        ("Error=%d while deleting file=%s for url=%s\n",
                                        GetLastError(),
                                        lpLockReqInfo->FileName,
                                        lpLockReqInfo->UrlName
                                        ));

                            if (lpLockReqInfo->fNoCacheLookup) {

                                switch (GetLastError()) {
                                    case ERROR_SHARING_VIOLATION:
                                    case ERROR_ACCESS_DENIED:
                                        UrlCacheAddLeakFile (lpLockReqInfo->FileName);
                                }
                            }

                        } // end if (!DeleteFile(...))
                    }
                } // end if (!lpLockReqInfo->fNoDelete)

                FREE_MEMORY(lpLockReqInfo);
                error = ERROR_SUCCESS;

            } else {

                DEBUG_PRINT(INET,
                            INFO,
                            ("Quitting after decrementing refcount, new refcount=%d\n",
                            lpLockReqInfo->dwCount
                            ));

                error = ERROR_SUCCESS;
            }
        } else {
            error = ERROR_INVALID_PARAMETER;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT

    LeaveCriticalSection(&LockRequestFileCritSec);

quit:
    BOOL fRet = (error==ERROR_SUCCESS);

    if  (fRet) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(fRet);

    return fRet;
}


INTERNETAPI_(BOOL) InternetCheckConnectionA(
    IN LPCSTR lpszUrl,
    IN DWORD dwFlags,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    This routine tells the caller whether he can establish a connection to the
    network. If no URL is specified and dwFlags are set to NULL then wininet
        a) checks whether it has an outstanding socket connection and if so
            then the API returns TRUE.
        b) If there are no outstanding socket connections then a check
           is made in the wininet serverdatabase for servers which were
           connected to in the recent past. If one is found then the API returns TRUE.

        If neither a) or b) succeeds the API returns FALSE.

Arguments:

    lpszUrl     this parameter is an indication to the API to attempt
                a specific host. The use of this parameter is based on the
                flags set in the dwFlags parameter

    dwFlags     a bitwise OR of the following flags

                    INTERNET_FLAG_ICC_FORCE_CONNECTION - force a connection
                    A sockets connection is attempted in the following order
                    1) If lpszUrl is non-NULL then a host value is extracted
                       fromt it used that to ping the specific host
                    2) If the lpszUrl parameter is NULL then if there is an
                       entry in the wininet's internal server database for
                       the nearest server, it is used to do the pinging

                    If neither of these are available then ERROR_NOT_CONNECTED is
                    returned in GetLastError()

    dwReserved  reserved

Return Value:

    TRUE - Success
    FALSE - failure, GetLastError returns the error code

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetCheckConnectionA",
                     "%s %x",
                     lpszUrl,
                     dwFlags
                     ));

    DWORD           dwError = ERROR_SUCCESS;
    LPSTR           lpszHostName;
    DWORD           dwHostNameLen;
    INTERNET_PORT   ServerPort = INTERNET_DEFAULT_HTTP_PORT;
    INTERNET_SCHEME ustScheme = INTERNET_SCHEME_HTTP;
    ICSocket *pSocket = NULL;
    char            buff[INTERNET_MAX_HOST_NAME_LENGTH+1];
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET   hInternet = NULL, hConnect = NULL, hConnectMapped = NULL;
    CServerInfo * lpServerInfo = NULL;

    if (!GlobalDataInitialized) {
        dwError = GlobalDataInitialize();
        if (dwError != ERROR_SUCCESS) {
            goto Cleanup;
        }
    }

    // if the main sockets database thinks we are
    // unconditionally offline, then let us give that to the user
    //if(vSocketsDatabase.IsOffline())
    //{
    //
    //    dwError = ERROR_NOT_CONNECTED;
    //}
    //else
    {

        // We are not explicitly in offline mode

        lpServerInfo = FindNearestServer();

        if (dwFlags & FLAG_ICC_FORCE_CONNECTION) {

            buff[0] = 0;

            if (lpszUrl) {

                if (((dwError = CrackUrl(
                            (LPSTR)lpszUrl,            // url
                            lstrlen(lpszUrl),   // url length
                            FALSE,              // escape the URL ?
                            &ustScheme,         // scheme type
                            NULL,               // scheme name
                            NULL,               // scheme length
                            &lpszHostName,      // hostname pointer
                            &dwHostNameLen,     // hostname length
                            &ServerPort,        // port
                            NULL,               // UserName
                            NULL,               // UserName Length
                            NULL,               // Password
                            NULL,               // Password Length
                            NULL,               // Path
                            NULL,               // Path Length
                            NULL,               // Extra
                            NULL,               // Extra Length
                            NULL                // have port?
                            )) == ERROR_SUCCESS)&&
                                (dwHostNameLen<=INTERNET_MAX_HOST_NAME_LENGTH))
                {
                    memcpy(buff, lpszHostName, dwHostNameLen);
                    buff[dwHostNameLen] = 0;

                    // make sure we have a valid scheme
                    if(INTERNET_SCHEME_UNKNOWN == ustScheme)
                    {
                        ustScheme = INTERNET_SCHEME_HTTP;
                    }

                    // make sure we have a valid port
                    if(0 == ServerPort)
                    {
                        switch(ustScheme)
                        {
                        case INTERNET_SCHEME_FTP:
                            ServerPort = INTERNET_DEFAULT_FTP_PORT;
                            break;
                        case INTERNET_SCHEME_HTTPS:
                            ServerPort = INTERNET_DEFAULT_HTTPS_PORT;
                            break;
                        default:
                            ServerPort = INTERNET_DEFAULT_HTTP_PORT;
                            break;
                        }
                    }

                    // for our purposes, HTTPS == HTTP
                    if(INTERNET_SCHEME_HTTPS == ustScheme)
                    {
                        ustScheme = INTERNET_SCHEME_HTTP;
                    }

                    // we need the serverinfo struct for this server, not
                    // the nearest one that we already found
                    if(lpServerInfo)
                    {
                        lpServerInfo->Dereference();
                    }

                    lpServerInfo = FindServerInfo(buff);
                    if(!lpServerInfo)
                    {
                        // new CServerInfo has ref count 1 already
                        // we need to raise it so another thread won't go ahead and destroy this.
                        LockSerializedList(&GlobalServerInfoList);
                        lpServerInfo = new CServerInfo(buff, &dwError, INTERNET_SERVICE_HTTP, 0);
                        if(NULL == lpServerInfo)
                        {
                            dwError = ERROR_NOT_ENOUGH_MEMORY;
                            goto Cleanup;
                        }
                        else if (dwError != ERROR_SUCCESS)
                        {
                            delete lpServerInfo;
                            lpServerInfo = NULL;
                        }
                        else
                        {
                            lpServerInfo->Reference();
                        }
                        UnlockSerializedList(&GlobalServerInfoList);
                    }
                }
            }
            else {
                if (lpServerInfo) {

                    buff[sizeof(buff)-1] = 0;

                    strncpy(buff, lpServerInfo->GetHostName(), sizeof(buff)-1);
                }
                else
                {
                    // FORCE but no server to try - set error
                    dwError = ERROR_INTERNET_INVALID_OPERATION;
                    goto Cleanup;
                }
            }

            if (buff[0] && lpServerInfo) {

                // we have a host name, ping it.

                // This threadinfo/InternetOpen stuff is being done
                // because the ICSocket class is intertwined with
                // an internet handle, so we are just getting round that
                // difficulty. Ideally, ICSocket should have been a
                // standalone sockets class

                lpThreadInfo = InternetGetThreadInfo();

                if (lpThreadInfo == NULL) {

                    INET_ASSERT(FALSE);

                    dwError = ERROR_INTERNET_INTERNAL_ERROR;
                    goto Cleanup;
                }


                hInternet = InternetOpen("Internal",
                                            0,
                                            NULL,
                                            NULL,
                                            0
                                            );
                if (!hInternet) {
                    dwError = GetLastError();
                    goto Cleanup;
                }

                hConnect = InternetConnect(hInternet,
                                            buff,
                                            ServerPort,
                                            NULL,
                                            NULL,
                                            ustScheme,
                                            0,
                                            0);
                if (!hConnect) {
                    dwError = GetLastError();
                    goto Cleanup;
                }

                dwError = MapHandleToAddress(hConnect, (LPVOID *)&hConnectMapped, FALSE);

                if (dwError != ERROR_SUCCESS) {
                    goto Cleanup;
                }

                _InternetSetObjectHandle(lpThreadInfo, hConnect, hConnectMapped);

                // Ping the server
                if (pSocket = new ICSocket()) {

                    pSocket->SetPort(ServerPort);

                    dwError = pSocket->SocketConnect(
                        GetTimeoutValue(INTERNET_OPTION_CONNECT_TIMEOUT),
                        GetTimeoutValue(INTERNET_OPTION_CONNECT_RETRIES),
                        0,
                        lpServerInfo
                        );

                    if (dwError == ERROR_SUCCESS) {
                        pSocket->Disconnect();
                    }
                }
                else {

                    dwError = ERROR_NOT_ENOUGH_MEMORY;

                }

            }

        }
        else{
            // caller doesn't ask us to force a connection
            // do the best we can and tell him

            dwError = (/*vSocketsDatabase.GetSocketCount() ||*/ lpServerInfo)?
                      ERROR_SUCCESS:
                      ERROR_NOT_CONNECTED;

        }

    }

Cleanup:

    if (lpServerInfo)
    {
        lpServerInfo->Dereference();
    }
    if (pSocket) {

        pSocket->Dereference();

    }
    if (hConnectMapped) {

        DereferenceObject((LPVOID)hConnectMapped);

    }
    if (hConnect) {

        InternetCloseHandle(hConnect);

    }
    if (hInternet) {

        InternetCloseHandle(hInternet);

    }

    BOOL fRet = (dwError==ERROR_SUCCESS);
    if (FALSE == fRet) {
        SetLastError(dwError);
        DEBUG_ERROR(API, dwError);
    }
    DEBUG_LEAVE_API(fRet);

    return (fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\inetapiu.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.h

Abstract:

    Prototypes for inetapiu.cxx

Author:

    Richard L Firth (rfirth) 17-Feb-1996

Revision History:

    17-Feb-1996 rfirth
        Created

--*/

//
// prototypes
//

//BOOL
//wInternetQueryDataAvailable(
//    IN LPVOID hFileMapped,
//    OUT LPDWORD lpdwNumberOfBytesAvailable,
//    IN DWORD dwFlags,
//    IN DWORD_PTR dwContext
//    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\rashelp.cxx ===
/////////////////////////////////////////////////////////////////////////////
//
// RAS API wrappers for wide/ansi
//
// Works on all 9x and NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

#include "wininetp.h"
#include "rashelp.h"
#include "autodial.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
ENUM_TYPE GetOSVersion::_EnumType = ENUM_NONE;

GetOSVersion::GetOSVersion()
{
    if(_EnumType == ENUM_NONE)
    {
        if(0 == GlobalPlatformType)
            GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        // figure out which kind of enumeration we're doing - start with multibyte
        _EnumType = ENUM_MULTIBYTE;

        if(PLATFORM_TYPE_WINNT == GlobalPlatformType)
        {
            if(TRUE == GlobalPlatformVersion5)
                _EnumType = ENUM_WIN2K;
            else
                _EnumType = ENUM_UNICODE;
        }
    }
}

GetOSVersion::~GetOSVersion()
{
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        dwStructSize = sizeof(RASENTRYNAMEA);
        break;
    case ENUM_UNICODE:
        dwStructSize = sizeof(RASENTRYNAMEW);
        break;
    case ENUM_WIN2K:
        dwStructSize = sizeof(W2KRASENTRYNAMEW);
        break;
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
    if(_preList)
    {
        do
        {
            // set up list
            _preList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            if(ENUM_MULTIBYTE == _EnumType)
            {
                _dwLastError = _RasEnumEntriesA(
                                NULL,
                                NULL,
                                (LPRASENTRYNAMEA)_preList,
                                &dwBufSize,
                                &_dwEntries
                                );
            }
            else
            {
                _dwLastError = _RasEnumEntriesW(
                                NULL,
                                NULL,
                                (LPRASENTRYNAMEW)_preList,
                                &dwBufSize,
                                &_dwEntries
                                );
            }

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_preList);
                _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _preList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_preList && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_preList);
        _preList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_preList)
    {
        LocalFree(_preList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPWSTR
RasEnumHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_preList[dwConnectionNum].szEntryName)
        {
            MultiByteToWideChar(CP_ACP, 0, _preList[dwConnectionNum].szEntryName,
                -1, _szCurrentEntryW, RAS_MaxEntryName + 1);
            pwszName = _szCurrentEntryW;
        }
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_preList[dwConnectionNum].szEntryName)
            pszName = _preList[dwConnectionNum].szEntryName;
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    }

    return pszName;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEnumConnHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEnumConnHelp::RasEnumConnHelp()
{
    DWORD           dwBufSize;

    // init
    _dwConnections = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwStructSize = sizeof(RASCONNA);
        break;
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASCONNW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASCONNW);
        break;
    }

    // allocate space for MAX_CONNECTION entries
    dwBufSize = MAX_CONNECTION * _dwStructSize;
    _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
    if(_pRasCon == NULL)
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasEnumConnHelp::~RasEnumConnHelp()
{
    if(_pRasCon)
    {
        LocalFree(_pRasCon);
        _pRasCon = NULL;
    }
}

DWORD RasEnumConnHelp::Enum()
{
    DWORD           dwBufSize;

    _dwLastError = 0;

    if(_pRasCon)
    {
        dwBufSize = MAX_CONNECTION * _dwStructSize;
        do
        {
            // set up list
            _pRasCon[0].dwSize = _dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            switch(_EnumType)
            {
                case ENUM_MULTIBYTE:
                    _dwLastError = _RasEnumConnectionsA((LPRASCONNA)_pRasCon, &dwBufSize, &_dwConnections);
                    break;
                case ENUM_UNICODE:
                case ENUM_WIN2K:
                    _dwLastError = _RasEnumConnectionsW((LPRASCONNW)_pRasCon, &dwBufSize, &_dwConnections);
                    break;
            }

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_pRasCon);
                _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _pRasCon)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetConnectionsCount()
{
    return _dwConnections;
}

LPWSTR
RasEnumConnHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_pRasCon[dwConnectionNum].szEntryName)
        {
            MultiByteToWideChar(CP_ACP, 0, _pRasCon[dwConnectionNum].szEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1);
            pwszName = _szEntryNameW;
        }
        break;
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumConnHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        if(*_pRasCon[dwConnectionNum].szEntryName)
            pszName = _pRasCon[dwConnectionNum].szEntryName;
        break;
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW )_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    }

    return pszName;
}

LPWSTR
RasEnumConnHelp::GetLastEntryW(DWORD dwConnectionNum)
{
    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameW;
}

LPSTR
RasEnumConnHelp::GetLastEntryA(DWORD dwConnectionNum)
{
    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameA;
}

HRASCONN
RasEnumConnHelp::GetHandle(DWORD dwConnectionNum)
{
    HRASCONN hTemp;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        hTemp = _pRasCon[dwConnectionNum].hrasconn;
        break;
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    }

    return hTemp;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEntryPropHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEntryPropHelp::RasEntryPropHelp()
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwStructSize = sizeof(RASENTRYA);
        break;
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASENTRYW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASENTRYW);
        break;
    }

    _pRasEntry = (LPRASENTRYA)LocalAlloc(LPTR, _dwStructSize * 2);
    if(_pRasEntry)
    {
        _pRasEntry->dwSize = _dwStructSize;
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_pRasEntry && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
    return;
}

RasEntryPropHelp::~RasEntryPropHelp()
{
    if(_pRasEntry)
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
}

DWORD RasEntryPropHelp::GetError()
{
    return _dwLastError;
}

DWORD RasEntryPropHelp::GetA(LPSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwLastError = _RasGetEntryPropertiesA(NULL, lpszEntryName, (LPRASENTRYA)_pRasEntry, &dwSize, NULL, NULL);
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1 );
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1);
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

DWORD RasEntryPropHelp::GetW(LPWSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        WideCharToMultiByte(CP_ACP, 0, lpszEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
        _dwLastError = _RasGetEntryPropertiesA(NULL, _szEntryNameA, (LPRASENTRYA)_pRasEntry, &dwSize, NULL, NULL);
        break;
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

LPWSTR RasEntryPropHelp::GetDeviceTypeW(VOID)
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szDeviceType)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szDeviceType, -1, _szDeviceTypeW, RAS_MaxDeviceType  + 1);
                lpwstr = _szDeviceTypeW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetDeviceTypeA(VOID)
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szDeviceType)
                lpstr = _pRasEntry->szDeviceType;
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodiallDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialDll)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szAutodialDll, -1, _szAutodialDllW, MAX_PATH);
                lpwstr = _szAutodialDllW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodiallDllA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialDll)
                lpstr = _pRasEntry->szAutodialDll;
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodialFuncW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialFunc)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szAutodialFunc, -1, _szAutodialFuncW, RAS_MaxDeviceType  + 1);
                lpwstr = _szAutodialFuncW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodialFuncA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAutodialFunc)
                lpstr = _pRasEntry->szAutodialFunc;
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetCustomDialDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:    // Not in Win9x
            break;
        case ENUM_UNICODE:      // Not is NT4
            break;
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry  ;
            if(*lpTemp->szCustomDialDll)
                lpwstr = lpTemp->szCustomDialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPWSTR RasEntryPropHelp::GetPhoneNumberW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szLocalPhoneNumber)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szLocalPhoneNumber, -1, _szPhoneNumberW, RAS_MaxPhoneNumber);
                lpwstr = _szPhoneNumberW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        }
    }

    return lpwstr;
}


DWORD RasEntryPropHelp::GetCountryCode()
{
    DWORD dwCode = 0;

    if(_pRasEntry)
    {
        // country code is at the same place for all versions of the struct,
        // so take the shortcut
        dwCode = _pRasEntry->dwCountryCode;
    }

    return dwCode;
}

DWORD RasEntryPropHelp::GetOptions()
{
    DWORD dwOptions = 0;

    if(_pRasEntry)
    {
        // dwfOptions is at the same place for all versions of the struct,
        // so take the shortcut
        dwOptions = _pRasEntry->dwfOptions;
    }

    return dwOptions;
}

LPWSTR RasEntryPropHelp::GetAreaCodeW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(*_pRasEntry->szAreaCode)
            {
                MultiByteToWideChar(CP_ACP, 0, _pRasEntry->szAreaCode, -1, _szAreaCodeW, RAS_MaxAreaCode);
                lpwstr = _szAreaCodeW;
            }
            break;
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        }
    }

    return lpwstr;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasEntryDialParamsHelp::RasEntryDialParamsHelp()
{
    // init
    _dwLastError = 0;
    _pRasDialParamsA = NULL;

    if(_EnumType == ENUM_MULTIBYTE)
    {
        _pRasDialParamsA = (LPRASDIALPARAMSA)LocalAlloc(LPTR, sizeof(RASDIALPARAMSA));
        if(_pRasDialParamsA == NULL)
        {
            _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            _pRasDialParamsA->dwSize = sizeof(RASDIALPARAMSA);
        }
    }
    return;
}

RasEntryDialParamsHelp::~RasEntryDialParamsHelp()
{
    _dwLastError = 0;

    if(_pRasDialParamsA)
    {
        LocalFree(_pRasDialParamsA);
        _pRasDialParamsA= NULL;
    }
}

DWORD RasEntryDialParamsHelp::GetError()
{
    return _dwLastError;
}

DWORD RasEntryDialParamsHelp::SetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, BOOL fRemovePassword)
{
    _dwLastError = 1;

    if(lprasdialparams)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            if(_pRasDialParamsA)
            {
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szEntryName, -1, _pRasDialParamsA->szEntryName, RAS_MaxEntryName  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szPhoneNumber, -1, _pRasDialParamsA->szPhoneNumber, RAS_MaxPhoneNumber  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szCallbackNumber, -1, _pRasDialParamsA->szCallbackNumber, RAS_MaxCallbackNumber  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szUserName, -1, _pRasDialParamsA->szUserName, UNLEN  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szPassword, -1, _pRasDialParamsA->szPassword, PWLEN  , NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szDomain, -1, _pRasDialParamsA->szDomain, DNLEN  , NULL, NULL);
                _dwLastError = _RasSetEntryDialParamsA(NULL, _pRasDialParamsA, fRemovePassword);
            }
            break;
        case ENUM_UNICODE:
        case ENUM_WIN2K:
            _dwLastError = _RasSetEntryDialParamsW(NULL, lprasdialparams, fRemovePassword);
            break;
        }
    }

    return _dwLastError;
}

DWORD RasEntryDialParamsHelp::GetW(LPCWSTR lpszPhonebook, LPRASDIALPARAMSW lprasdialparams, LPBOOL pfRemovePassword)
{
    _dwLastError = 1;

    if(lprasdialparams)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            WideCharToMultiByte(CP_ACP, 0, lprasdialparams->szEntryName, -1, _pRasDialParamsA->szEntryName, RAS_MaxEntryName, NULL, NULL);
            _dwLastError = _RasGetEntryDialParamsA(NULL, _pRasDialParamsA, pfRemovePassword);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szEntryName, -1, lprasdialparams->szEntryName, RAS_MaxEntryName);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szPhoneNumber, -1, lprasdialparams->szPhoneNumber, RAS_MaxPhoneNumber);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szCallbackNumber, -1, lprasdialparams->szCallbackNumber, RAS_MaxCallbackNumber);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szUserName, -1, lprasdialparams->szUserName, UNLEN);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szPassword, -1, lprasdialparams->szPassword, PWLEN);
            MultiByteToWideChar(CP_ACP, 0, _pRasDialParamsA->szDomain, -1, lprasdialparams->szDomain, DNLEN);
            break;
        case ENUM_UNICODE:
        case ENUM_WIN2K:
            _dwLastError = _RasGetEntryDialParamsW(NULL, lprasdialparams, pfRemovePassword);
            break;
        }
    }

    return _dwLastError;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasGetConnectStatusHelp::RasGetConnectStatusHelp(HRASCONN hrasconn)
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_MULTIBYTE:
        _dwStructSize = sizeof(RASCONNSTATUSA);
        break;
    case ENUM_UNICODE:
    case ENUM_WIN2K:
        _dwStructSize = sizeof(RASCONNSTATUSW);
        break;
    }

    _pRasConnStatus = (LPRASCONNSTATUSA)LocalAlloc(LPTR, _dwStructSize);
    if(_pRasConnStatus)
    {
        _pRasConnStatus->dwSize = _dwStructSize;

        if(_EnumType == ENUM_MULTIBYTE)
        {
            _dwLastError = _RasGetConnectStatusA(hrasconn, (LPRASCONNSTATUSA)_pRasConnStatus);
        }
        else
        {
            _dwLastError = _RasGetConnectStatusW(hrasconn, (LPRASCONNSTATUSW)_pRasConnStatus);
        }

        if(_pRasConnStatus && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_pRasConnStatus);
            _pRasConnStatus = NULL;
        }
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasGetConnectStatusHelp::~RasGetConnectStatusHelp()
{
    _dwLastError = 0;
    if(_pRasConnStatus)
    {
        LocalFree(_pRasConnStatus);
        _pRasConnStatus = NULL;
    }
}

DWORD RasGetConnectStatusHelp::GetError()
{
    return _dwLastError;
}

RASCONNSTATE RasGetConnectStatusHelp::ConnState()
{
    RASCONNSTATE hConnState = (RASCONNSTATE)NULL;

    if(_pRasConnStatus)
    {
        if(_EnumType == ENUM_MULTIBYTE)
        {
            hConnState = _pRasConnStatus->rasconnstate;
        }
        else
        {
            LPRASCONNSTATUSW lpTemp = (LPRASCONNSTATUSW)_pRasConnStatus;
            hConnState = lpTemp->rasconnstate;
        }
    }

    return hConnState;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasDialHelp::RasDialHelp(LPRASDIALEXTENSIONS lpRDE, LPWSTR lpszPB, LPRASDIALPARAMSW lpRDPW,  DWORD dwType, LPVOID lpvNot, LPHRASCONN lphRasCon)
{
    // init
    _dwLastError = 1;
    _pRasDialParams = NULL;
    _lpszPhonebookA = NULL;

    if(lpRDPW)
    {
        switch(_EnumType)
        {
        case ENUM_MULTIBYTE:
            _pRasDialParams = (LPRASDIALPARAMSA)LocalAlloc(LPTR, sizeof(RASDIALPARAMSA));
            if(_pRasDialParams)
            {
                if(lpszPB)
                    _lpszPhonebookA = (LPSTR)LocalAlloc(LPTR, (lstrlenW(lpszPB)+1) * sizeof(CHAR));
                _pRasDialParams->dwSize = sizeof(RASDIALPARAMSA);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szEntryName, -1, _pRasDialParams->szEntryName, RAS_MaxEntryName, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szPhoneNumber, -1, _pRasDialParams->szPhoneNumber, RAS_MaxPhoneNumber, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szCallbackNumber, -1, _pRasDialParams->szCallbackNumber, RAS_MaxCallbackNumber, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szUserName, -1, _pRasDialParams->szUserName, UNLEN, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szPassword, -1, _pRasDialParams->szPassword, PWLEN, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, lpRDPW->szDomain, -1, _pRasDialParams->szDomain, DNLEN, NULL, NULL);
                _dwLastError = _RasDialA(lpRDE, _lpszPhonebookA, _pRasDialParams, dwType, lpvNot, lphRasCon);
            }
            else
            {
                _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
        case ENUM_WIN2K:
        case ENUM_UNICODE:
            _pRasDialParams = (LPRASDIALPARAMSA)LocalAlloc(LPTR, sizeof(NT4RASDIALPARAMSW));
            if(_pRasDialParams)
            {
                LPNT4RASDIALPARAMSW pRDPW = (LPNT4RASDIALPARAMSW)_pRasDialParams;
                pRDPW->dwSize = sizeof(NT4RASDIALPARAMSW);
                StrCpyNW(pRDPW->szEntryName, lpRDPW->szEntryName, RAS_MaxEntryName);
                StrCpyNW(pRDPW->szPhoneNumber, lpRDPW->szPhoneNumber, RAS_MaxPhoneNumber);
                StrCpyNW(pRDPW->szCallbackNumber, lpRDPW->szCallbackNumber, RAS_MaxCallbackNumber);
                StrCpyNW(pRDPW->szUserName, lpRDPW->szUserName, UNLEN);
                StrCpyNW(pRDPW->szPassword, lpRDPW->szPassword, PWLEN);
                StrCpyNW(pRDPW->szDomain, lpRDPW->szDomain, DNLEN);
                _dwLastError = _RasDialW(lpRDE, lpszPB, (LPRASDIALPARAMSW)pRDPW, dwType, lpvNot, lphRasCon);
            }
            else
            {
                _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
        }

        if(_pRasDialParams && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_pRasDialParams);
            _pRasDialParams = NULL;
        }
        if(_lpszPhonebookA && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_lpszPhonebookA);
            _lpszPhonebookA = NULL;
        }
    }
    return;
}

RasDialHelp::~RasDialHelp()
{
    _dwLastError = 0;
    if(_pRasDialParams)
    {
        LocalFree(_pRasDialParams);
        _pRasDialParams = NULL;
    }
    if(_lpszPhonebookA)
    {
        LocalFree(_lpszPhonebookA);
        _lpszPhonebookA = NULL;
    }
}

DWORD RasDialHelp::GetError()
{
    return _dwLastError;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\proxreg.cxx ===
#include "wininetp.h"
#include "autodial.h"

const CHAR szRegPathConnections[] = REGSTR_PATH_INTERNET_SETTINGS "\\Connections";
static const CHAR szRegValProxyEnabled[] = REGSTR_VAL_PROXYENABLE;
static const CHAR szLegacyAutoConfigURL[] = "AutoConfigURL";

// when we haven't looked up dial-up override for autodetect
#define UNKNOWN_AUTODETECT      ((DWORD)(-1))

// Internet Settings reg value do determine dial-up override for autodetect
static const CHAR szDialupAutodetect[] = "DialupAutodetect";

// base hkey we use for settings.  May be per user or per machine.
CRefdKey* g_prkBase = NULL;

// type for RtlConvertSidToUnicodeString, exported from ntdll.dll
typedef NTSTATUS (* PCONVERTSID)(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );

// some winsock stacks fault if we do a gethostbyname(NULL).  If we come
// accross one of these, don't do any more autodetecting.
BOOL g_fGetHostByNameNULLFails = FALSE;

//
// IsConnectionMatch - a worker function to simply some logic elsewhere,
//  it just handles Connection Name Matching.
//

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2)
{
    if ( lpszConnection1 == NULL && 
         lpszConnection2 == NULL) 
    {
        return TRUE;
    }

    if ( lpszConnection1 && lpszConnection2 &&
         stricmp(lpszConnection1, lpszConnection2) == 0 )
    {
        return TRUE;
    }

    return FALSE;
}

//
// Decide whether or not autodiscovery is turned based on IEAK setting.
// Only used when upgrading or creating settings for a new connectoid.
//
BOOL
EnableAutodiscoverForDialup(
    VOID
    )
{
    static DWORD dwDialUpAutodetect = UNKNOWN_AUTODETECT;

    if(UNKNOWN_AUTODETECT == dwDialUpAutodetect)
    {
        DWORD   dwType, dwSize = sizeof(DWORD);

        if(ERROR_SUCCESS !=
            SHGetValue(HKEY_CURRENT_USER, INTERNET_POLICY_KEY,
            szDialupAutodetect, &dwType, &dwDialUpAutodetect, &dwSize))
        {
            // not set
            dwDialUpAutodetect = 0;
        }
    }

    return (BOOL)dwDialUpAutodetect;
}

///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    Commit();

    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;
    }

    lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                regsam, NULL, &_hkey, &dwDisposition);
    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            // nothing there - make zero size buffer
            _dwBufferLimit = 0;
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::Encrpyt(
    )
{
    return 0;
}


DWORD
CRegBlob::Decrypt(
    )
{
    return 0;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = _dwBufferLimit + ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


///////////////////////////////////////////////////////////////////////////
//
// Helpers to read and write proxy settings
//
///////////////////////////////////////////////////////////////////////////

//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

#define MAX_SID_STRING 256


//
// Function Declarations
//

BOOL
InitClientUserString (
    LPWSTR pString
    )

/*++

Routine Description:

Arguments:

    pString - output string of current user

Return Value:

    TRUE = success,
    FALSE = fail

    Returns in pString a ansi string if the impersonated client's
    SID can be expanded successfully into  Unicode string. If the conversion
    was unsuccessful, returns FALSE.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "InitClientUserString",
                 "%#x",
                 pString
                 ));

    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    BOOL        Status;
    DWORD       dwLastError;
    UNICODE_STRING UnicodeString;
    HMODULE     hNtDll;
    PCONVERTSID pRtlConvertSid;

    /*
    if (GlobalIsProcessNtService)
    {
        char    szUserName[10];
        DWORD   cbUserNameSize = ARRAYSIZE(szUserName);
        GlobalUserName.Get(szUserName,&cbUserNameSize);
        if (0 == lstrcmpi(szUserName, "SYSTEM"))
        {
            DEBUG_PRINT(DIALUP, INFO, ("User Profile = %s(env = %d)\n",
                        szUserName, GlobalIsProcessNtService
                        ));
            
            wcscpy(pString, L".default");

            DEBUG_PRINT(DIALUP, INFO, ("User SID = %ws\n",
                        pString
                        ));

            DEBUG_LEAVE(TRUE);
            return TRUE;
        }
    }
    */
    
    //
    // get RtlConvertSideToUnicodeString entry point in NTDLL
    //
    hNtDll = LoadLibrary("ntdll.dll");
    if(NULL == hNtDll)
    {
        return FALSE;
    }

    pRtlConvertSid = (PCONVERTSID)GetProcAddress(hNtDll, "RtlConvertSidToUnicodeString");
    if(NULL == pRtlConvertSid)
    {
        FreeLibrary(hNtDll);
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // We can use OpenThreadToken because this server thread
    // is impersonating a client
    //
    Status = OpenThreadToken(
                GetCurrentThread(),
                TOKEN_READ,
                TRUE,                // Open as self
                &TokenHandle
                );
    dwLastError = GetLastError();

    if( Status == FALSE )
    {
        DEBUG_PRINT(DIALUP, INFO, ("OpenThreadToken() failed: Error=%d\n",
                    dwLastError
                    ));

        Status = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_READ,
                    &TokenHandle
                    );
        dwLastError = GetLastError();

        if( Status == FALSE )
        {
            DEBUG_LEAVE(FALSE);
            return FALSE ;
        }
    }

    //
    // Notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure
    //
    Status = GetTokenInformation( TokenHandle,
                                  TokenUser,
                                  TokenInformation,
                                  sizeof( TokenInformation ),
                                  &ReturnLength
                                   );
    dwLastError = GetLastError();
    CloseHandle( TokenHandle );

    if ( Status == FALSE ) {
        DEBUG_PRINT(DIALUP, INFO, ("GetTokenInformation failed: Error=%d\n",
                    dwLastError
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // Convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.
    //

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_SID_STRING;
    UnicodeString.Buffer = pString;

    Status = (*pRtlConvertSid)(
                 &UnicodeString,
                 ((PTOKEN_USER)TokenInformation)->User.Sid,
                 FALSE );
    FreeLibrary(hNtDll);

    if( !NT_SUCCESS( Status )){
        DEBUG_PRINT(DIALUP, INFO, ("RtlConvertSidToUnicodeString failed: Error=%d\n",
                    Status
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    
    DEBUG_PRINT(DIALUP, INFO, ("User SID = %ws\n",
                pString
                ));

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    )

/*++

Routine Description:

Arguments:

Returns:

---*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "GetClientUserHandle",
                 "%#x",
                 samDesired
                 ));

    HKEY   hKeyClient;
    WCHAR  String[MAX_SID_STRING];
    LONG   ReturnValue;

    if (!InitClientUserString(String)) {
        DEBUG_LEAVE(0);
        return NULL ;
    }

    //
    // We now have the Unicode string representation of the
    // local client's Sid we'll use this string to open a handle
    // to the client's key in  the registry.

    ReturnValue = RegOpenKeyExW( HKEY_USERS,
                                 String,
                                 0,
                                 samDesired,
                                 &hKeyClient );

    //
    // If we couldn't get a handle to the local key
    // for some reason, return a NULL handle indicating
    // failure to obtain a handle to the key
    //

    if ( ReturnValue != ERROR_SUCCESS )
    {
        DEBUG_PRINT(DIALUP, INFO, ("RegOpenKeyW failed: Error=%d\n",
                    ReturnValue
                    ));

        DEBUG_ERROR(DIALUP, ReturnValue);
        SetLastError( ReturnValue );

        DEBUG_LEAVE(0);
        return NULL;
    }

    DEBUG_LEAVE(hKeyClient);
    return( hKeyClient );
}

CRefdKey*
FindBaseProxyKey(
    VOID
    )

/*
** Determine whether proxy settings live in HKLM or HKCU
**
** Returns HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE
**
** Checks \HKLM\SW\MS\Win\CV\Internet Settings\ProxySettingsPerUser.  If
** exists and is zero, use HKLM otherwise use HKCU.
*/

{
    // grab the cached value
    CRefdKey* prk = (CRefdKey*)InterlockedExchangePointer((void**)&g_prkBase, NULL);

    if (prk == NULL)
    {
        HKEY hkeyBase = NULL;
        BOOL bSetNewCachedValue = FALSE;
        DWORD  dwType, dwValue, dwSize = sizeof(DWORD);

        if(ERROR_SUCCESS ==
            SHGetValue(HKEY_LOCAL_MACHINE, INTERNET_POLICY_KEY,
            TEXT("ProxySettingsPerUser"), &dwType, &dwValue, &dwSize) &&
            0 == dwValue)
        {
            hkeyBase = HKEY_LOCAL_MACHINE;
            bSetNewCachedValue = TRUE;
        }
        else
        {
            //
            // Find an HKCU equivalent for this process
            //
            if(PLATFORM_TYPE_WIN95 == GlobalPlatformType ||
               NULL == (hkeyBase = GetClientUserHandle(KEY_QUERY_VALUE | KEY_SET_VALUE)))
            {
                BOOL fLocalSystem = FALSE;
                if (GlobalIsProcessNtService)
                {
                    char    szUserName[20];
                    DWORD   cbUserNameSize = ARRAYSIZE(szUserName);
                    GlobalUserName.Get(szUserName,&cbUserNameSize);
                    if (0 == lstrcmpi(szUserName, "SYSTEM") ||
                        0 == lstrcmpi(szUserName, "LOCAL SERVICE") || 
                        0 == lstrcmpi(szUserName, "NETWORK SERVICE"))
                    {
                        fLocalSystem = TRUE;
                    }
                }
                
                if (!fLocalSystem)
                {
                    hkeyBase = HKEY_CURRENT_USER;
                    bSetNewCachedValue = TRUE;
                }
            }
            else if (!GlobalIsProcessNtService)
            {
                // only cache the CRefdKey if we are not a service
                bSetNewCachedValue = TRUE;
            }
        }

        if (hkeyBase)
        {
            prk = new CRefdKey(hkeyBase);

            if (prk)
            {
                if (bSetNewCachedValue)
                {
                    // addref it again since we are going to try and stick it in the global
                    prk->AddRef();

                    if (InterlockedCompareExchangePointer((void **)&g_prkBase, prk, 0))
                    {
                        // someone beat us in the race to fill in g_prkBase, release ours since we
                        // failed to set it into g_prkBase
                        prk->Release();
                    }
                }
            }
            else
            {
                // we failed to create a CRefdKey, so close the hkeyBase if it is not a predefined handle
                if ((hkeyBase != HKEY_LOCAL_MACHINE) &&
                    (hkeyBase != HKEY_CURRENT_USER))
                {
                    RegCloseKey(hkeyBase);
                }
            }
        }
    }
    else
    {
        // addref the global and put it back
        prk->AddRef();
        CRefdKey* prkOld = (CRefdKey*)InterlockedExchangePointer((void**)&g_prkBase, prk);
        if (prkOld)
        {
            // someone also stuck a cached value in g_prkBase! Since we just put ours back
            // in the global cache, we need to release theirs.
            prkOld->Release();
        }
    }

    return prk;
}

BOOL
CloseBaseProxyKey(
    CRefdKey* prk
    )
{
    if (prk)
    {
        prk->Release();
        return TRUE;
    }

    return FALSE;
}

DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    DWORD   i;
    BOOL    fSave = FALSE, fLanConnection = FALSE;
    CRefdKey* prkBase = NULL;
    DWORD   dwStructVersion;

    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "ReadProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // take mutex
    WaitForSingleObject(g_hProxyRegMutex, INFINITE);

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        fLanConnection = TRUE;
        pszConnectionName = "DefaultConnectionSettings";
    }

    // figure out base key
    prkBase = FindBaseProxyKey();
    if (prkBase == NULL)
    {
        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(prkBase->GetKey(), szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&dwStructVersion, sizeof(DWORD)) ||
         (dwStructVersion < INTERNET_PROXY_INFO_EX_VERSION))
    {
        // blob didn't exist or in correct format - set default values

        // If not on a lan connection and we're set to inherit lan settings
        if(!fLanConnection && GlobalUseLanSettings)
        {
            // Ensure we're reading the LAN proxy information.
            pInfo->lpszConnectionName = NULL;

            // Get proxy settings into pInfo
            lRes = ReadProxySettings(pInfo);
            if(lRes)
            {
                error = lRes;
                goto quit;
            }

            // Restore connection name
            pInfo->lpszConnectionName = pszSavedConnectionName;
        }
        else
        {
#ifndef UNIX
            //
            // All lan connections and overridden dial-ups get autodetect
            //
            if(fLanConnection || EnableAutodiscoverForDialup())
            {
                pInfo->dwFlags |= PROXY_TYPE_AUTO_DETECT;
            }
#else
            ;
#endif /* UNIX */
        }
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
        r.ReadString(&pInfo->lpszAutoconfigUrl);
        r.ReadBytes(&pInfo->dwAutoDiscoveryFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszLastKnownGoodAutoConfigUrl);
        r.ReadBytes(&pInfo->ftLastKnownDetectTime, sizeof(FILETIME));

        // read interface ips
        r.ReadBytes(&pInfo->dwDetectedInterfaceIpCount, sizeof(DWORD));
        if(pInfo->dwDetectedInterfaceIpCount)
        {
            pInfo->pdwDetectedInterfaceIp = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD) * pInfo->dwDetectedInterfaceIpCount);
            if(pInfo->pdwDetectedInterfaceIp)
            {
                for(i=0; i<pInfo->dwDetectedInterfaceIpCount; i++)
                {
                    r.ReadBytes(&pInfo->pdwDetectedInterfaceIp[i], sizeof(DWORD));
                }
            }
        }

        r.ReadString(&pInfo->lpszAutoconfigSecondaryUrl);
        r.ReadBytes(&pInfo->dwAutoconfigReloadDelayMins, sizeof(DWORD));
    }

    // Netware hack.  Don't ever allow autodiscovery to be turned on if
    // we're running the netware client.  It faults and it isn't useful
    // anyway.
    //
    // Some other stacks may also fault.  If we find one, don't autodetect.
    if(GlobalRunningNovellClient32 || g_fGetHostByNameNULLFails)
    {
        pInfo->dwFlags &= ~PROXY_TYPE_AUTO_DETECT;

        // save this back so we don't ever try again
        fSave = TRUE;
    }

    DEBUG_PRINT(DIALUP, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s, acu=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>"),
                    (pInfo->lpszAutoconfigUrl ? pInfo->lpszAutoconfigUrl : "<none>")
                    ));

    if(fSave)
    {
        WriteProxySettings(pInfo, TRUE);
    }

quit:
    CloseBaseProxyKey(prkBase);
    // free mutex
    ReleaseMutex(g_hProxyRegMutex);
    DEBUG_LEAVE(error);
    return error;
}


DWORD
WriteProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo,
    BOOL fForceUpdate
    )

// serialize this.  Only write if dwCurrentSettingsVersion member has been
// incremented by exactly 1.

{
    DEBUG_ENTER((DBG_DIALUP,
                 Dword,
                 "WriteProxySettings",
                 "%#x, %B",
                 pInfo,
                 fForceUpdate                 
                 ));

    CRegBlob    r(TRUE);
    CRegBlob    CurrentVersion(FALSE);
    LPCSTR      pszConnectionName;
    long        lRes;
    DWORD       i;
    DWORD       dwCurrentVersion;
    DWORD       dwCurrentStructSize;
    DWORD       error = ERROR_SUCCESS;
    DWORD       dwStructVersion = INTERNET_PROXY_INFO_EX_VERSION;
    CRefdKey*   prkBase = NULL;

    //
    // verify pInfo
    //
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        r.Abandon();
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // take mutex
    WaitForSingleObject(g_hProxyRegMutex, INFINITE);

    //
    // figure out connection name  (NULL == 'network')
    //
    pszConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        pszConnectionName = "DefaultConnectionSettings";
    }

    //
    // For forced update changes, turn off this FLAG since,
    //  any major change in settings indicates a possible FIX
    //  for detection issues.
    //

    if ( fForceUpdate ) {
        pInfo->dwAutoDiscoveryFlags &= ~(AUTO_PROXY_FLAG_DETECTION_SUSPECT);
    }

    DEBUG_PRINT(DIALUP, INFO, ("conn=%s, vers=%u, flag=%X, a-flag=%X, prox=%s, by=%s, acu=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    pInfo->dwAutoDiscoveryFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>"),
                    (pInfo->lpszAutoconfigUrl ? pInfo->lpszAutoconfigUrl : "<none>")
                    ));

    // figure out base key
    prkBase = FindBaseProxyKey();

    if (prkBase == NULL)
    {
        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    //
    // Get current version and verify another write hasn't happened
    //
    // Second dword is version
    //
    lRes = CurrentVersion.Init(prkBase->GetKey(), szRegPathConnections, pszConnectionName);
    if(lRes || IsInGUIModeSetup())
    {
        r.Abandon();
        error = lRes;
        goto quit;
    }

    dwCurrentStructSize = sizeof(*pInfo);
    dwCurrentVersion    = 0;

    CurrentVersion.ReadBytes(&dwCurrentStructSize, sizeof(DWORD)); // struct size
    CurrentVersion.ReadBytes(&dwCurrentVersion, sizeof(DWORD)); // actual version

    if(dwCurrentVersion != pInfo->dwCurrentSettingsVersion)
    {
        // someone else has written since this read.  If we aren't in force
        // mode, bail out
        if((fForceUpdate == FALSE) &&
           (dwCurrentStructSize >= sizeof(*pInfo)))
        {
            r.Abandon();
            error = ERROR_INVALID_DATA;
            goto quit;
        }

        // update to most recent version
        pInfo->dwCurrentSettingsVersion = dwCurrentVersion;
    }

    //
    // increment version
    //
    pInfo->dwCurrentSettingsVersion++;

    //
    // init blob
    //
    lRes = r.Init(prkBase->GetKey(), szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        r.Abandon();
        error = lRes;
        goto quit;
    }

    //
    // write fields to blob
    //

    r.WriteBytes(&dwStructVersion, sizeof(DWORD)); // used for data format checking
    r.WriteBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
    r.WriteBytes(&pInfo->dwFlags, sizeof(DWORD));
    r.WriteString(pInfo->lpszProxy);
    r.WriteString(pInfo->lpszProxyBypass);
    r.WriteString(pInfo->lpszAutoconfigUrl);
    r.WriteBytes(&pInfo->dwAutoDiscoveryFlags, sizeof(DWORD));
    r.WriteString(pInfo->lpszLastKnownGoodAutoConfigUrl);
    r.WriteBytes(&pInfo->ftLastKnownDetectTime, sizeof(FILETIME));

    //
    // write interface ip list
    //
    r.WriteBytes(&pInfo->dwDetectedInterfaceIpCount, sizeof(DWORD));
    for(i=0; i<pInfo->dwDetectedInterfaceIpCount; i++)
    {
        r.WriteBytes(&pInfo->pdwDetectedInterfaceIp[i], sizeof(DWORD));
    }

    r.WriteString(pInfo->lpszAutoconfigSecondaryUrl);
    r.WriteBytes(&pInfo->dwAutoconfigReloadDelayMins, sizeof(DWORD));

quit:
    CloseBaseProxyKey(prkBase);
    // free mutex
    ReleaseMutex(g_hProxyRegMutex);

    DEBUG_LEAVE(error);

    return error;
}

void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    if(pInfo->lpszAutoconfigUrl)              GlobalFree((LPSTR) pInfo->lpszAutoconfigUrl);
    if(pInfo->lpszLastKnownGoodAutoConfigUrl) GlobalFree((LPSTR) pInfo->lpszLastKnownGoodAutoConfigUrl);
    if(pInfo->pdwDetectedInterfaceIp)         GlobalFree(pInfo->pdwDetectedInterfaceIp);
    memset(pInfo, 0, sizeof(INTERNET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}


DWORD
SetPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info, info_temp;
    DWORD   i, dwError = ERROR_SUCCESS;
    BOOL fCommit = FALSE;
    LPSTR   pszCopy, pszNew;
    BOOL    fFreeCopy = FALSE;

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);

    if ( hInternet == NULL )
    {
        //
        // If auto-proxy thread then try to get the settings
        //  from the auto-proxy thread
        //

        if ( ! fIsAutoProxyThread || 
             ! GlobalProxyInfo.GetAutoProxyThreadSettings(&info) ||
             ! IsConnectionMatch(info.lpszConnectionName, pList->pszConnection))
        {
            fFreeCopy = TRUE;            
            info.lpszConnectionName = pList->pszConnection;
            CheckForUpgrade();
            dwError = ReadProxySettings(&info);
            if (dwError != ERROR_SUCCESS)
            {
                return dwError;
            }
        }
    }

    // loop through option list and set members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pszNew = NULL;

        switch(pList->pOptions[i].dwOption)
        {        
        case INTERNET_PER_CONN_PROXY_SERVER:
        case INTERNET_PER_CONN_PROXY_BYPASS:
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:        
            // make a copy of the string passed in for these guys
            pszCopy = pList->pOptions[i].Value.pszValue;
            if(pszCopy)
            {
                pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
                if(pszNew)
                {
                    lstrcpy(pszNew, pszCopy);
                }
                else
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    pList->dwOptionError = i;
                }
            }
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            info.dwFlags = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            info.dwAutoDiscoveryFlags = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
            info.dwAutoconfigReloadDelayMins = pList->pOptions[i].Value.dwValue;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            if(info.lpszProxy)
                GlobalFree((LPSTR)info.lpszProxy);
            info.lpszProxy = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            if(info.lpszProxyBypass)
                GlobalFree((LPSTR)info.lpszProxyBypass);
            info.lpszProxyBypass = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
            if(info.lpszAutoconfigUrl)
                GlobalFree((LPSTR)info.lpszAutoconfigUrl);
            info.lpszAutoconfigUrl = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            if(info.lpszAutoconfigSecondaryUrl)
                GlobalFree((LPSTR)info.lpszAutoconfigSecondaryUrl);
            info.lpszAutoconfigSecondaryUrl = pszNew;
            fCommit = TRUE;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
            dwError = ERROR_INTERNET_OPTION_NOT_SETTABLE;
            pList->dwOptionError = i;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
            dwError = ERROR_INTERNET_OPTION_NOT_SETTABLE;
            pList->dwOptionError = i;
            break;
        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        if(dwError)
        {
            fCommit = FALSE;
            break;
        }
    }

    if(fCommit)
    {
        if ( hInternet == NULL ) 
        {

            memset(&info_temp, 0, sizeof(info_temp));
            info_temp.dwStructSize = sizeof(info_temp);

            if ( ! fIsAutoProxyThread ||
                 ! GlobalProxyInfo.GetAutoProxyThreadSettings(&info_temp) ||
                 ! IsConnectionMatch(info_temp.lpszConnectionName, pList->pszConnection) ||
                 ! GlobalProxyInfo.SetAutoProxyThreadSettings(&info))
                 
            { 
                WriteProxySettings(&info, TRUE);

                // update legacy settings with new values
                info.lpszConnectionName = LEGACY_SAVE_NAME;
                WriteLegacyProxyInfo(szRegPathInternetSettings, &info, TRUE);
                WriteProxySettings(&info, TRUE);
            }
        } 
        else 
        {
            GlobalProxyInfo.SetProxySettings(&info, TRUE);
        }
    }

    if ( fFreeCopy ) {
        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return dwError;
}



DWORD
QueryPerConnOptions(
    HINTERNET hInternet,
    BOOL fIsAutoProxyThread,
    LPINTERNET_PER_CONN_OPTION_LISTA pList
    )
{
    INTERNET_PROXY_INFO_EX  info;
    LPCSTR   pszCopy;
    LPSTR    pszNew;
    DWORD    i, dwError = ERROR_SUCCESS;
    BOOL     fFreeCopy = FALSE;

    pList->dwOptionError = 0;

    memset(&info, 0, sizeof(info));
    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = pList->pszConnection;

    if ( hInternet == NULL ) 
    {
        if ( ! fIsAutoProxyThread ||                          
             ! GlobalProxyInfo.GetAutoProxyThreadSettings(&info) ||
             ! IsConnectionMatch(info.lpszConnectionName, pList->pszConnection)) 
        { 
            CheckForUpgrade();
            dwError = ReadProxySettings(&info);
            if (dwError != ERROR_SUCCESS)
            {
                return dwError;
            }
            fFreeCopy = TRUE;
        }
    }
    else 
    {
        GlobalProxyInfo.GetProxySettings(&info, FALSE);
    }

    // loop through option list and fill in members
    for(i=0; i<pList->dwOptionCount; i++)
    {
        pList->pOptions[i].Value.pszValue = NULL;
        pszCopy = NULL;

        switch(pList->pOptions[i].dwOption)
        {
        case INTERNET_PER_CONN_FLAGS:
            pList->pOptions[i].Value.dwValue = info.dwFlags;
            break;
        case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
            pList->pOptions[i].Value.dwValue = info.dwAutoDiscoveryFlags;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
            pList->pOptions[i].Value.dwValue = info.dwAutoconfigReloadDelayMins;
            break;
        case INTERNET_PER_CONN_PROXY_SERVER:
            pszCopy = info.lpszProxy;
            break;
        case INTERNET_PER_CONN_PROXY_BYPASS:
            pszCopy = info.lpszProxyBypass;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_URL:
            pszCopy = info.lpszAutoconfigUrl;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            pszCopy = info.lpszAutoconfigSecondaryUrl;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
            pszCopy = info.lpszLastKnownGoodAutoConfigUrl;
            break;
        case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
            *(LONGLONG *) &(pList->pOptions[i].Value.ftValue) = *(LONGLONG *) &(info.ftLastKnownDetectTime);
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            pList->dwOptionError = i;
            break;
        }

        // if this is a string value, make a copy of the string for the
        // caller
        if(pszCopy)
        {
            // make a copy of the string and stick it in the option
            pszNew = (LPSTR)GlobalAlloc(GPTR, lstrlen(pszCopy) + 1);
            if(pszNew)
            {
                lstrcpy(pszNew, pszCopy);
                pList->pOptions[i].Value.pszValue = pszNew;
            }
            else
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                pList->dwOptionError = i;
            }
        }

        if(dwError)
        {
            break;
        }
    }

    if (dwError)
    {
        // If an error has occurred, we should get rid of any strings that
        // we've allocated.
        for (i=0; i<pList->dwOptionError; i++)
        {
            switch(pList->pOptions[i].dwOption)
            {
            case INTERNET_PER_CONN_PROXY_SERVER:
            case INTERNET_PER_CONN_PROXY_BYPASS:
            case INTERNET_PER_CONN_AUTOCONFIG_URL:
            case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
            case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                if (pList->pOptions[i].Value.pszValue)
                {
                    GlobalFree(pList->pOptions[i].Value.pszValue);
                    pList->pOptions[i].Value.pszValue = NULL;
                }
                break;

            default:
                break;
            }
        }
    }

    if ( fFreeCopy ) {
        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return dwError;
}


BOOL
ReadLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy
    )

/*++

Routine Description:

    Reads legacy proxy information from a specified key.

Arguments:

    pszKey      - key from which to read proxy info
    pProxy      - pointer to PROXY structure to store info

Return Value:

    BOOL
        TRUE    - success
        FALSE   - failed

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "ReadLegacyProxyInfo",
                 "%#x (%q), %#x",
                 pszKey,
                 pszKey,
                 pProxy
                 ));

    BOOL    fSuccess = FALSE;
    HKEY    hKey;
    CRefdKey* prkBase;
    DWORD   dwSize, dwValue;

    pProxy->dwFlags = PROXY_TYPE_DIRECT;

    prkBase = FindBaseProxyKey();

    if(prkBase && 
       (ERROR_SUCCESS == REGOPENKEYEX(prkBase->GetKey(), pszKey, NULL,
                                KEY_READ, &hKey))) {
        // read enable
        dwSize = sizeof(DWORD);
        if(ERROR_SUCCESS != RegQueryValueEx(hKey, szRegValProxyEnabled,
                    NULL, NULL, (LPBYTE)&dwValue, &dwSize)) {
            dwValue = 0;
        }
        if(dwValue)
        {
            pProxy->dwFlags |= PROXY_TYPE_PROXY;
        }

        // read server
        dwSize = INTERNET_MAX_URL_LENGTH;
        pProxy->lpszProxy = (LPSTR)GlobalAlloc(GMEM_FIXED, dwSize);
        if(pProxy->lpszProxy)
        {
            if(ERROR_SUCCESS != RegQueryValueEx(hKey, REGSTR_VAL_PROXYSERVER,
                NULL, NULL, (LPBYTE)pProxy->lpszProxy, &dwSize) ||
                (dwSize == 0) ||
                (*pProxy->lpszProxy == '\0'))
            {
                GlobalFree((LPVOID)pProxy->lpszProxy);
                pProxy->lpszProxy = NULL;
            }
        }

        // read override
        dwSize = INTERNET_MAX_URL_LENGTH;
        pProxy->lpszProxyBypass = (LPSTR)GlobalAlloc(GMEM_FIXED, dwSize);
        if(pProxy->lpszProxyBypass)
        {
            if(ERROR_SUCCESS != RegQueryValueEx(hKey, REGSTR_VAL_PROXYOVERRIDE,
                NULL, NULL, (LPBYTE)pProxy->lpszProxyBypass, &dwSize) ||
                (dwSize == 0) ||
                (*pProxy->lpszProxyBypass == '\0'))
            {
                GlobalFree((LPVOID)pProxy->lpszProxyBypass);
                pProxy->lpszProxyBypass = NULL;
            }
        }
        

        // read autoconfig URL
        dwSize = INTERNET_MAX_URL_LENGTH;
        pProxy->lpszAutoconfigUrl = (LPSTR)GlobalAlloc(GMEM_FIXED, dwSize);
        if(pProxy->lpszAutoconfigUrl)
        {
            if(ERROR_SUCCESS != RegQueryValueEx(hKey, szLegacyAutoConfigURL,
                NULL, NULL, (LPBYTE)pProxy->lpszAutoconfigUrl, &dwSize) ||
                (dwSize == 0) ||
                (*pProxy->lpszAutoconfigUrl == '\0'))
            {
                // clear out
                GlobalFree((LPVOID)pProxy->lpszAutoconfigUrl);
                pProxy->lpszAutoconfigUrl = NULL;
            }
            else
            {
                // turn on if there's an URL
                pProxy->dwFlags |= PROXY_TYPE_AUTO_PROXY_URL;
            }
        }

        REGCLOSEKEY(hKey);
        fSuccess = TRUE;
    }

    DEBUG_PRINT(DIALUP, INFO, ("flag=%x, prox=%s, by=%s, acu=%s\n", 
                    pProxy->dwFlags,
                    (pProxy->lpszProxy ? pProxy->lpszProxy : "<none>"),
                    (pProxy->lpszProxyBypass ? pProxy->lpszProxyBypass : "<none>"),
                    (pProxy->lpszAutoconfigUrl ? pProxy->lpszAutoconfigUrl : "<none>")
                    ));

    CloseBaseProxyKey(prkBase);

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}


BOOL
WriteLegacyProxyInfo(
    IN LPCTSTR pszKey,
    LPINTERNET_PROXY_INFO_EX pProxy,
    IN BOOL    fOverwrite
    )

/*++

Routine Description:

    Writes legacy proxy info a specified key

Arguments:

    pszKey      - key to write proxy inf to
    pProxy      - pointer to PROXY structure containing info to write
    fOverwrite  - If TRUE, overwrite existing info. otherwise only create

Return Value:

    BOOL
        TRUE    - success
        FALSE   - failed

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "WriteLegacyProxyInfo",
                 "%#x (%q), %#x, %B",
                 pszKey,
                 pszKey,
                 pProxy,
                 fOverwrite
                 ));

    BOOL    fSuccess = FALSE;
    HKEY    hKey;
    CRefdKey* prkBase;
    DWORD   dwDisposition, dwValue;

    prkBase = FindBaseProxyKey();
    if (!prkBase)
    {
        goto quit;
    }

    if (IsInGUIModeSetup())
    {
        fSuccess = TRUE;  // don't return a failure, just skip
        goto quit;
    }

    DEBUG_PRINT(DIALUP, INFO, ("flag=%x, prox=%s, by=%s, acu=%s\n", 
                    pProxy->dwFlags,
                    (pProxy->lpszProxy ? pProxy->lpszProxy : "<none>"),
                    (pProxy->lpszProxyBypass ? pProxy->lpszProxyBypass : "<none>"),
                    (pProxy->lpszAutoconfigUrl ? pProxy->lpszAutoconfigUrl : "<none>")
                    ));

    if(ERROR_SUCCESS == REGCREATEKEYEX(prkBase->GetKey(), pszKey, 0, "", 0,
                KEY_WRITE, NULL, &hKey, &dwDisposition)) {

        fSuccess = TRUE;

        //
        // if we're not supposed to overwrite, check enable key.  If it
        // exists, bail
        //
        if(FALSE == fOverwrite) {
            DWORD dwEnable, dwSize = sizeof(DWORD);
            if(ERROR_SUCCESS == RegQueryValueEx(hKey, szRegValProxyEnabled,
                    NULL, NULL, (LPBYTE)&dwEnable, &dwSize)) {
                REGCLOSEKEY(hKey);
                DEBUG_PRINT(DIALUP, INFO, ("Overwrite not set.\n"));
                goto quit;
            }
        }

        // write enable
        dwValue = 0;
        if(pProxy->dwFlags & PROXY_TYPE_PROXY)
            dwValue = 1;
        DEBUG_PRINT(DIALUP, INFO, ("Setting legacy enabled=%d\n", dwValue));
        if(ERROR_SUCCESS != RegSetValueEx(hKey, szRegValProxyEnabled, 0,
                    REG_DWORD, (BYTE *)&dwValue, sizeof(DWORD)))
            fSuccess = FALSE;

        // write server
        if(pProxy->lpszProxy)
        {
            if(ERROR_SUCCESS != RegSetValueEx(hKey, REGSTR_VAL_PROXYSERVER, 0,
                    REG_SZ, (BYTE *)pProxy->lpszProxy,
                    lstrlen(pProxy->lpszProxy)))
                fSuccess = FALSE;
        }
        else
        {
            RegDeleteValue(hKey, REGSTR_VAL_PROXYSERVER);
            DEBUG_PRINT(DIALUP, INFO, ("Deleting legacy server\n"));
        }

        // write override
        if(pProxy->lpszProxyBypass)
        {
            if(ERROR_SUCCESS != RegSetValueEx(hKey, REGSTR_VAL_PROXYOVERRIDE, 0,
                    REG_SZ, (BYTE *)pProxy->lpszProxyBypass,
                    lstrlen(pProxy->lpszProxyBypass)))
                fSuccess = FALSE;
        }
        else
        {
            RegDeleteValue(hKey, REGSTR_VAL_PROXYOVERRIDE);
            DEBUG_PRINT(DIALUP, INFO, ("Deleting legacy override\n"));
        }

        // write autoconfig url
        if( (pProxy->dwFlags & PROXY_TYPE_AUTO_PROXY_URL) &&
             pProxy->lpszAutoconfigUrl)
        {
            if(ERROR_SUCCESS != RegSetValueEx(hKey, szLegacyAutoConfigURL, 0,
                REG_SZ, (BYTE *)pProxy->lpszAutoconfigUrl,
                lstrlen(pProxy->lpszAutoconfigUrl)))
            {
                fSuccess = FALSE;
            }
        }
        else
        {
            RegDeleteValue(hKey, szLegacyAutoConfigURL);
            DEBUG_PRINT(DIALUP, INFO, ("Deleting legacy autoconfig url\n"));
        }

        REGCLOSEKEY(hKey);
    }

    //
    // duplicate proxy enable reg settings to HKEY_CURRENT_CONFIG so 
    // shell doesn't blow away the setting when it migrates.
    //
    dwValue = (pProxy->dwFlags & PROXY_TYPE_PROXY) ? 1 : 0;
    SHSetValue(HKEY_CURRENT_CONFIG, pszKey, szRegValProxyEnabled,
        REG_DWORD, &dwValue, sizeof(DWORD));

quit:
    CloseBaseProxyKey(prkBase);

    DEBUG_LEAVE(fSuccess);
    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\millenras.h ===
/* Copyright (c) 1999, Microsoft Corporation, all rights reserved
**
** autodial.h
** Autodial remote access external API
** Public header for external API clients
**
*/

#ifndef _MILLEN_AUTODIAL_H_
#define _MILLEN_AUTODIAL_H_

// First two match WinInet
#define RAS_INTERNET_AUTODIAL_FORCE_DIAL        0x00000001
#define RAS_INTERNET_AUTODIAL_UNATTENDED        0x00000002
// #define RAS_INTERNET_AUTODIAL_FAILIFSECURITYCHECK 0x0000004

#define RAS_INTERNET_AUTODIAL_NO_TRAY_ICON      0x00000010
#define RAS_INTERNET_AUTODIAL_NO_REDIAL         0x00000020
#define RAS_INTERNET_AUTODIAL_ALLOW_OFFLINE     0x00000040
#define RAS_INTERNET_AUTODIAL_RECONNECT         0x00000080 
#define RAS_INTERNET_AUTODIAL_RESERVED          0x80000000

#define RAS_INTERNET_AUTODIAL_FLAGS_MASK        RAS_INTERNET_AUTODIAL_UNATTENDED | \
                                                RAS_INTERNET_AUTODIAL_FORCE_DIAL | \
                                                RAS_INTERNET_AUTODIAL_NO_TRAY_ICON | \
                                                RAS_INTERNET_AUTODIAL_NO_REDIAL | \
                                                RAS_INTERNET_AUTODIAL_ALLOW_OFFLINE | \
                                                RAS_INTERNET_AUTODIAL_RECONNECT | \
                                                RAS_INTERNET_AUTODIAL_RESERVED

DWORD APIENTRY RasInternetDialA( HWND, LPSTR, DWORD, DWORD *, DWORD );

DWORD APIENTRY RasRegisterAutodialCallbackA( DWORD, DWORD, LPVOID, LPHANDLE, DWORD );

DWORD APIENTRY RasUnregisterAutodialCallbackA( HANDLE );

BOOL APIENTRY RasInternetAutodialA( DWORD, HWND );

BOOL APIENTRY RasInternetAutodialHangUpA( DWORD );

DWORD APIENTRY RasInternetHangUpA( DWORD, DWORD );


#define RAS_INTERNET_CONNECTION_MODEM           0x01
#define RAS_INTERNET_CONNECTION_LAN             0x02
#define RAS_INTERNET_CONNECTION_PROXY           0x04
#define RAS_INTERNET_CONNECTION_MODEM_BUSY      0x08  /* no longer used */
#define RAS_INTERNET_RAS_INSTALLED              0x10
#define RAS_INTERNET_CONNECTION_OFFLINE         0x20
#define RAS_INTERNET_CONNECTION_CONFIGURED      0x40

BOOL APIENTRY RasInternetGetConnectedStateExA(
    OUT LPDWORD lpdwFlags,
    OUT LPSTR lpszConnectionName,
    IN DWORD dwBufLen,
    IN DWORD dwReserved
    );


// Taken from WinInet.h

// Custom dial handler prototype
typedef DWORD (FAR PASCAL * PFNCUSTOMDIALHANDLER) (HWND, LPCSTR, DWORD, LPDWORD);

// Flags for custom dial handler
#define INTERNET_CUSTOMDIAL_CONNECT         0
#define INTERNET_CUSTOMDIAL_UNATTENDED      1
#define INTERNET_CUSTOMDIAL_DISCONNECT      2
#define INTERNET_CUSTOMDIAL_SHOWOFFLINE     4

// Custom dial handler supported functionality flags
#define INTERNET_CUSTOMDIAL_SAFE_FOR_UNATTENDED 1
#define INTERNET_CUSTOMDIAL_WILL_SUPPLY_STATE   2
#define INTERNET_CUSTOMDIAL_CAN_HANGUP          4

// Settings for autodial
//
#define RAS_AUTODIAL_OPT_NONE           0x00000000  // No options
#define RAS_AUTODIAL_OPT_NEVER          0x00000001  // Never Autodial
#define RAS_AUTODIAL_OPT_ALWAYS         0x00000002  // Autodial regardless
#define RAS_AUTODIAL_OPT_DEMAND         0x00000004  // Autodial on demand
#define RAS_AUTODIAL_OPT_NOPROMPT       0x00000010  // Dial without prompting

DWORD      WINAPI RnaGetDefaultAutodialConnection(LPBYTE lpBuf, DWORD cb, LPDWORD lpdwOptions);
DWORD      WINAPI RnaSetDefaultAutodialConnection(LPSTR szEntry, DWORD dwOptions);

// Auto disconnect managment

typedef struct  tagAutoDisInfo {
    DWORD       dwSize;
    BOOL        fIdleDisPromptDisabled;
    BOOL        fDisconnectOnExit;
    DWORD       dwIdleTimeoutSec;  // Auto disconnect time, 0 = disabled
} AUTODISINFO, *PAUTODISINFO, FAR* LPAUTODISINFO;


DWORD NEAR PASCAL RnaGetAutoDisconnectInfoA (
    LPSTR   lpszPhonebook,      
    LPSTR        szEntry,       
    LPAUTODISINFO lpadi);
    
DWORD NEAR PASCAL RnaSetAutoDisconnectInfoA (
    LPSTR   lpszPhonebook,      
    LPSTR        szEntry,       
    LPAUTODISINFO lpadi);


#ifdef UNICODE
#define RasInternetDial                 RasInternetDialW
#define RasRegisterAutodialCallback     RasRegisterAutodialCallbackW
#define RasUnregisterAutodialCallback   RasUnregisterAutodialCallbackW
#define RasInternetAutodial             RasInternetAutodialW
#define RasInternetAutodialHangUp       RasInternetAutodialHangUpW
#define RasInternetHangUp               RasInternetUpW
#define RasInternetGetConnectedStateEx  RasInternetGetConnectedStateExW
#else
#define RasInternetDial                 RasInternetDialA
#define RasRegisterAutodialCallback     RasRegisterAutodialCallbackA
#define RasUnregisterAutodialCallback   RasUnregisterAutodialCallbackA
#define RasInternetAutodial             RasInternetAutodialA
#define RasInternetAutodialHangUp       RasInternetAutodialHangUpA
#define RasInternetHangUp               RasInternetHangUpA
#define RasInternetGetConnectedStateEx  RasInternetGetConnectedStateExA
#endif


#endif // _AUTODIAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\options.cxx ===
/*++

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    options.cxx

Abstract:

    Contains the Internet*Option APIs

    Contents:
        InternetQueryOptionA
        InternetSetOptionA
        InternetSetOptionExA
        InternetQueryOptionW
        InternetSetOptionW
        InternetSetOptionExW
        (FValidCacheHandleType)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana

    07-Jul-1998 Forked by akabir

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "inetapiu.h"
#include "autodial.h"
#include "msident.h"
#include "secinit.h"


extern HANDLE g_hDialEvent;

//
// private macros
//

//
// IS_PER_THREAD_OPTION - options applicable to the thread (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

//#define IS_PER_THREAD_OPTION(option)                        \
//    (( ((option) == INTERNET_OPTION_SERVER_ERROR_CALLBACK)  \
//    || ((option) == INTERNET_OPTION_ASYNC_ID)               \
//    || ((option) == INTERNET_OPTION_EXTENDED_ERROR)         \
//    ) ? TRUE : FALSE)

#define IS_PER_THREAD_OPTION(option)                        \
    (( ((option) == INTERNET_OPTION_ASYNC_ID)               \
    || ((option) == INTERNET_OPTION_EXTENDED_ERROR)         \
    || ((option) == INTERNET_OPTION_PER_CONNECTION_OPTION)  \
    ) ? TRUE : FALSE)

//
// IS_PER_PROCESS_OPTION - options applicable to the process (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_PROCESS_OPTION(option)                       \
    (( ((option) == INTERNET_OPTION_GET_DEBUG_INFO)         \
    || ((option) == INTERNET_OPTION_SET_DEBUG_INFO)         \
    || ((option) == INTERNET_OPTION_GET_HANDLE_COUNT)       \
    || ((option) == INTERNET_OPTION_CONNECT_TIMEOUT)        \
    || ((option) == INTERNET_OPTION_CONNECT_RETRIES)        \
    || ((option) == INTERNET_OPTION_CONNECT_BACKOFF)        \
    || ((option) == INTERNET_OPTION_SEND_TIMEOUT)           \
    || ((option) == INTERNET_OPTION_RECEIVE_TIMEOUT)        \
    || ((option) == INTERNET_OPTION_DATA_SEND_TIMEOUT)      \
    || ((option) == INTERNET_OPTION_DATA_RECEIVE_TIMEOUT)   \
    || ((option) == INTERNET_OPTION_FROM_CACHE_TIMEOUT)     \
    || ((option) == INTERNET_OPTION_REFRESH)                \
    || ((option) == INTERNET_OPTION_PROXY)                  \
    || ((option) == INTERNET_OPTION_SETTINGS_CHANGED)       \
    || ((option) == INTERNET_OPTION_PROXY_SETTINGS_CHANGED) \
    || ((option) == INTERNET_OPTION_VERSION)                \
    || ((option) == INTERNET_OPTION_END_BROWSER_SESSION)    \
    || ((option) == INTERNET_OPTION_RESET_URLCACHE_SESSION) \
    || ((option) == INTERNET_OPTION_OFFLINE_TIMEOUT)        \
    || ((option) == INTERNET_OPTION_LINE_STATE)             \
    || ((option) == INTERNET_OPTION_IDLE_STATE)             \
    || ((option) == INTERNET_OPTION_OFFLINE_SEMANTICS)      \
    || ((option) == INTERNET_OPTION_HTTP_VERSION)           \
    || ((option) == INTERNET_OPTION_BYPASS_EDITED_ENTRY)    \
    || ((option) == INTERNET_OPTION_MAX_CONNS_PER_SERVER)   \
    || ((option) == INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER)    \
    || ((option) == INTERNET_OPTION_DIGEST_AUTH_UNLOAD)    \
    || ((option) == INTERNET_OPTION_IDENTITY)    \
    || ((option) == INTERNET_OPTION_REMOVE_IDENTITY)    \
    || ((option) == INTERNET_OPTION_ALTER_IDENTITY)    \
    || ((option) == INTERNET_OPTION_SUPPRESS_BEHAVIOR)    \
    || ((option) == INTERNET_OPTION_PER_CONNECTION_OPTION)  \
    || ((option) == INTERNET_OPTION_AUTODIAL_CONNECTION)  \
    || ((option) == INTERNET_OPTION_AUTODIAL_MODE)  \
    || ((option) == INTERNET_OPTION_USERNAME)  \
    || ((option) == INTERNET_OPTION_PASSWORD)  \
    || ((option) == INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS) \
    || ((option) == INTERNET_OPTION_ACTIVATE_WORKER_THREADS) \
    || ((option) == INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS) \
    ) ? TRUE : FALSE)

//
// IS_DEBUG_OPTION - the set of debug-specific options
//

#define IS_DEBUG_OPTION(option)                     \
    (( ((option) >= INTERNET_FIRST_DEBUG_OPTION)    \
    && ((option) <= INTERNET_LAST_DEBUG_OPTION)     \
    ) ? TRUE : FALSE)

//
// IS_VALID_OPTION - the set of known option values, for a HINTERNET, thread, or
// process. In the retail version, debug options are invalid
//

#if INET_DEBUG

#define IS_VALID_OPTION(option)             \
    (((((option) >= INTERNET_FIRST_OPTION)  \
    && ((option) <= INTERNET_LAST_OPTION_INTERNAL))  \
    || IS_DEBUG_OPTION(option)              \
    ) ? TRUE : FALSE)

#else

#define IS_VALID_OPTION(option)             \
    (((((option) >= INTERNET_FIRST_OPTION)  \
    && ((option) <= INTERNET_LAST_OPTION_INTERNAL))  \
    ) ? TRUE : FALSE)

#endif // INET_DEBUG

//
// IS_CONNECT_HANDLE_TYPE - TRUE if handle type contains INTERNET_CONNECT_HANDLE_OBJECT
//

#define IS_CONNECT_HANDLE_TYPE(handleType)          \
    ((handleType == TypeHttpRequestHandle)          \
     || (handleType == TypeHttpConnectHandle)       \
     || (handleType == TypeFtpConnectHandle)        \
     || (handleType == TypeFtpFileHandle)           \
     || (handleType == TypeFtpFindHandle)           \
     || (handleType == TypeFtpFileHandleHtml)       \
     || (handleType == TypeFtpFindHandleHtml)       \
     || (handleType == TypeGopherConnectHandle)     \
     || (handleType == TypeGopherFileHandle)        \
     || (handleType == TypeGopherFindHandle)        \
     || (handleType == TypeGopherFileHandleHtml)    \
     || (handleType == TypeGopherFindHandleHtml))

//
// private prototypes
//

PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    );

PRIVATE
VOID
InitIPCOList(LPINTERNET_PER_CONN_OPTION_LISTW plistW, LPINTERNET_PER_CONN_OPTION_LISTA plistA)
{
    plistA->dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
    plistA->dwOptionCount = plistW->dwOptionCount;
    if (plistW->pszConnection && *plistW->pszConnection)
    {
        SHUnicodeToAnsi(plistW->pszConnection, plistA->pszConnection, RAS_MaxEntryName + 1);
    }
    else
    {
        plistA->pszConnection = NULL;
    }
}

//
// functions
//


INTERNETAPI_(BOOL) InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns information about various handle-specific variables

Arguments:

    hInternet           - handle of object for which information will be
                          returned

    dwOption            - the handle-specific INTERNET_OPTION to query

    lpBuffer            - pointer to a buffer which will receive results

    lpdwBufferLength    - IN: number of bytes available in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_INTERNET_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INSUFFICIENT_BUFFER
                        lpBuffer is not large enough to hold the requested
                        information; *lpdwBufferLength contains the number of
                        bytes needed

                    ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                        The handle is the wrong type for the requested option

                    ERROR_INTERNET_INVALID_OPTION
                        The option is unrecognized

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryOptionA",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD error;
    BOOL success;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize = 0;
    LPVOID lpSource;
    DWORD dwValue;
    DWORD_PTR dwPtrValue;
    HANDLE hValue;
    HINTERNET hObjectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT * lphRequest;
    BOOL isString = FALSE;
    INTERNET_DIAGNOSTIC_SOCKET_INFO socketInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto done;
    }

    //
    // validate parameters
    //

    if (!ARGUMENT_PRESENT(lpdwBufferLength)) {
        error = ERROR_INVALID_PARAMETER;
        goto done;
    }

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    //
    // validate the handle and get its type
    //

    HINTERNET hOriginal;

    hOriginal = hInternet;
    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternet, FALSE);
        if (error == ERROR_SUCCESS) {
            hObjectMapped = hInternet;
            lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_INTERNET_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    : ERROR_INTERNET_INVALID_OPTION
                    ;
    }

    //
    // if the option and handle combination is valid then query the option value
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    switch (dwOption) {
    case INTERNET_OPTION_CALLBACK:
        requiredSize = sizeof(INTERNET_STATUS_CALLBACK);
        if (hInternet != NULL) {
            error = RGetStatusCallback(hInternet,
                                       (LPINTERNET_STATUS_CALLBACK)&dwValue
                                       );
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INVALID_HANDLE;
        }
        break;

    case INTERNET_OPTION_CONNECT_TIMEOUT:
    case INTERNET_OPTION_CONNECT_RETRIES:
    case INTERNET_OPTION_CONNECT_BACKOFF:
    case INTERNET_OPTION_SEND_TIMEOUT:
    case INTERNET_OPTION_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        requiredSize = sizeof(DWORD);

        //
        // remember hInternet in the INTERNET_THREAD_INFO then call
        // GetTimeoutValue(). If hInternet refers to a valid Internet
        // object handle, then the relevant timeout value will be
        // returned from that, else we will return the global value
        // corresponding to the requested option
        //

        InternetSetObjectHandle(hOriginal, hInternet);
        dwValue = GetTimeoutValue(dwOption);
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_HANDLE_TYPE:
        requiredSize = sizeof(dwValue);
        switch (handleType) {
        case TypeInternetHandle:
            dwValue = INTERNET_HANDLE_TYPE_INTERNET;
            break;

        case TypeFtpConnectHandle:
            dwValue = INTERNET_HANDLE_TYPE_CONNECT_FTP;
            break;

        case TypeFtpFindHandle:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FIND;
            break;

        case TypeFtpFindHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FIND_HTML;
            break;

        case TypeFtpFileHandle:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FILE;
            break;

        case TypeFtpFileHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_FTP_FILE_HTML;
            break;

        case TypeGopherConnectHandle:
            dwValue = INTERNET_HANDLE_TYPE_CONNECT_GOPHER;
            break;

        case TypeGopherFindHandle:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FIND;
            break;

        case TypeGopherFindHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML;
            break;

        case TypeGopherFileHandle:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FILE;
            break;

        case TypeGopherFileHandleHtml:
            dwValue = INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML;
            break;

        case TypeHttpConnectHandle:
            dwValue = INTERNET_HANDLE_TYPE_CONNECT_HTTP;
            break;

        case TypeHttpRequestHandle:
            dwValue = INTERNET_HANDLE_TYPE_HTTP_REQUEST;
            break;

        case TypeFileRequestHandle:
            dwValue = INTERNET_HANDLE_TYPE_FILE_REQUEST;
            break;

        default:
            error = ERROR_INTERNET_INTERNAL_ERROR;
            break;
        }
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_CONTEXT_VALUE:
    case INTERNET_OPTION_CONTEXT_VALUE_OLD: // see InternetSetOption
        requiredSize = sizeof(DWORD_PTR);
        error = RGetContext(hInternet, &dwPtrValue);
        lpSource = (LPVOID)&dwPtrValue;
        break;

    //case INTERNET_OPTION_NAME_RES_THREAD:
    //    requiredSize = sizeof(BOOL);
    //    lpSource = (LPVOID)&MultiThreadedNameResolution;
    //    break;

    case INTERNET_OPTION_READ_BUFFER_SIZE:
    case INTERNET_OPTION_WRITE_BUFFER_SIZE:
        if (IS_CONNECT_HANDLE_TYPE(handleType)) {
            requiredSize = sizeof(DWORD);
            error = RGetBufferSize(hInternet, dwOption, &dwValue);
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    //case INTERNET_OPTION_GATEWAY_NAME:
    //    error = ERROR_CALL_NOT_IMPLEMENTED;
    //    break;

    case INTERNET_OPTION_ASYNC_ID:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_ASYNC_PRIORITY:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    //case INTERNET_OPTION_ASYNC_REQUEST_COUNT:
    //    requiredSize = sizeof(dwValue);
    //    error = RGetAsyncRequestCount(hInternet, &dwValue);
    //    lpSource = (LPVOID)&dwValue;
    //    break;

    case INTERNET_OPTION_PARENT_HANDLE:
        hInternet = ((HANDLE_OBJECT *)hInternet)->GetParent();
        if (hInternet != NULL) {
            hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        }
        requiredSize = sizeof(hInternet);
        lpSource = (LPVOID)&hInternet;
        break;

    case INTERNET_OPTION_KEEP_CONNECTION:
        if (handleType == TypeHttpConnectHandle) {
            requiredSize = sizeof(BOOL);

            //
            // we return TRUE or FALSE based on whether the connect
            // object believes the server supports Keep-Alive
            //

            //dwValue = RGetKeepAliveState(hInternet);
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_REQUEST_FLAGS:
        requiredSize = sizeof(dwValue);
        if (FValidCacheHandleType(handleType)) {
            dwValue = 0;
            if (lphRequest->IsFromCache()) {
                dwValue |= INTERNET_REQFLAG_FROM_CACHE;
                if (lphRequest->IsNetFailed()) {
                    dwValue |= INTERNET_REQFLAG_NET_TIMEOUT;
                }
            }
            if (lphRequest->IsViaProxy()) {
                dwValue |= INTERNET_REQFLAG_VIA_PROXY;
            }
            if (lphRequest->IsNoHeaders()) {
                dwValue |= INTERNET_REQFLAG_NO_HEADERS;
            }
            if (lphRequest->IsCacheWriteDisabled()) {
                dwValue |= INTERNET_REQFLAG_CACHE_WRITE_DISABLED;
            }
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_EXTENDED_ERROR:
        requiredSize = sizeof(lpThreadInfo->dwMappedErrorCode);
        lpSource = (LPVOID)&lpThreadInfo->dwMappedErrorCode;
        break;

    case INTERNET_OPTION_OFFLINE_MODE:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_CACHE_STREAM_HANDLE:
        requiredSize = sizeof(HANDLE);
        if (FValidCacheHandleType(handleType)) {
            error = lphRequest->GetCacheStream((LPBYTE)&hValue,
                                               sizeof(hValue)
                                               );
            lpSource = (LPVOID)&hValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    BOOL fUser, fProxy;

    case INTERNET_OPTION_USERNAME:
        fUser = IS_USER;
        fProxy = IS_SERVER;
        goto callGetUserOrPass;

    case INTERNET_OPTION_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_SERVER;
        goto callGetUserOrPass;

    case INTERNET_OPTION_PROXY_USERNAME:
        fUser = IS_USER;
        fProxy = IS_PROXY;
        goto callGetUserOrPass;

    case INTERNET_OPTION_PROXY_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_PROXY;
        goto callGetUserOrPass;

callGetUserOrPass:

        if (hInternet && (handleType != TypeInternetHandle)
            && (handleType != TypeFileRequestHandle)) {
            lpSource = lphRequest->GetUserOrPass(fUser, fProxy);
            isString = TRUE;
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;


    case INTERNET_OPTION_ASYNC:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_IDENTITY:
        lpSource = (LPVOID)&GlobalIdentityGuid;
        requiredSize = sizeof(GlobalIdentityGuid);
        break;
    
    case INTERNET_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            dwValue = lphHttpRqst->GetSecureFlags();

            DEBUG_PRINT(INET,
                        INFO,
                        ("SECURITY_FLAGS: %X\n",
                        dwValue
                        ));


            error = ERROR_SUCCESS;
        }

        break;


    case INTERNET_OPTION_DATAFILE_NAME:
        if ((handleType == TypeHttpRequestHandle)
        || (handleType == TypeFtpFindHandle)
        || (handleType == TypeFtpFindHandleHtml)
        || (handleType == TypeFtpFileHandle)
        || (handleType == TypeFtpFileHandleHtml)
        || (handleType == TypeGopherFindHandle)
        || (handleType == TypeGopherFindHandleHtml)
        || (handleType == TypeGopherFileHandle)
        || (handleType == TypeGopherFileHandleHtml)
        || (handleType == TypeFileRequestHandle )) {

            //
            // DATAFILE_NAME is slightly different from the other string
            // options: if the name is not present then we return an error
            // to the effect that we couldn't find it. The others just
            // return an empty string
            //

            if ( handleType != TypeFileRequestHandle ) {  
                lpSource = lphRequest->GetDataFileName();
            }
            else {
                lpSource = 
                   ((INTERNET_FILE_HANDLE_OBJECT *)lphRequest)->GetDataFileName();
            }

            if (lpSource != NULL) {
                isString = TRUE;

                INET_ASSERT(error == ERROR_SUCCESS);

            } else {
                error = ERROR_INTERNET_ITEM_NOT_FOUND;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_URL:

        //
        // return the URL associated with the request handle. This may be
        // different from the original URL due to redirections
        //

        if ((handleType == TypeHttpRequestHandle)
        || (handleType == TypeFtpFindHandle)
        || (handleType == TypeFtpFindHandleHtml)
        || (handleType == TypeFtpFileHandle)
        || (handleType == TypeFtpFileHandleHtml)
        || (handleType == TypeGopherFindHandle)
        || (handleType == TypeGopherFindHandleHtml)
        || (handleType == TypeGopherFileHandle)
        || (handleType == TypeGopherFileHandleHtml)) {

            //
            // only these handle types (retrieved object handles) can have
            // associated URLs
            //

            lpSource = lphRequest->GetURL();
            isString = TRUE;

            INET_ASSERT(error == ERROR_SUCCESS);

        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;
    case INTERNET_OPTION_SECURITY_CERTIFICATE:

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO siInfo;
            INTERNET_CERTIFICATE_INFO ciInfo;
            DWORD dwciInfoSize = sizeof(INTERNET_CERTIFICATE_INFO);

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&siInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&siInfo, &ciInfo, &dwciInfoSize);
                if(siInfo.pCertificate)
                {
                    CertFreeCertificateContext(siInfo.pCertificate);
                }

                if ( error == ERROR_SUCCESS )
                {
                    LPTSTR szResult = NULL;
                    DWORD cchNeedLen = 0;


                    szResult = FormatCertInfo(
                                &ciInfo
                                );

                    if (NULL == szResult)
                    {
                        error = ERROR_INTERNET_INVALID_OPERATION;
                        goto secOptEnd;
                    }

                    cchNeedLen = lstrlen(szResult) + 1;
                    if (*lpdwBufferLength < cchNeedLen)
                    {
                        error = ERROR_INSUFFICIENT_BUFFER;
                        goto secOptEnd;
                    }

                    if (ARGUMENT_PRESENT(lpBuffer))
                    {
                        memcpy(
                            lpBuffer,
                            szResult,
                            (cchNeedLen) * sizeof(TCHAR));
                        cchNeedLen--;
                    }

secOptEnd:
                    if (NULL != szResult) {
                        FREE_MEMORY(szResult);
                    }
                    if (NULL != ciInfo.lpszSubjectInfo) {
                        LocalFree(ciInfo.lpszSubjectInfo);
                    }
                    if (NULL != ciInfo.lpszIssuerInfo) {
                        LocalFree(ciInfo.lpszIssuerInfo);
                    }
                    if (NULL != ciInfo.lpszSignatureAlgName) {
                        LocalFree(ciInfo.lpszSignatureAlgName);
                    }
                    if (NULL != ciInfo.lpszEncryptionAlgName) {
                        LocalFree(ciInfo.lpszEncryptionAlgName);
                    }
                    if (NULL != ciInfo.lpszProtocolName) {
                        LocalFree(ciInfo.lpszProtocolName);
                    }

                    *lpdwBufferLength = cchNeedLen;
                    requiredSize = *lpdwBufferLength;
                }

                goto quit;
            }
            else
            {
                error = ERROR_INTERNET_INVALID_OPERATION;
            }
        }
        break;

    case INTERNET_OPTION_SECURITY_CONNECTION_INFO:
        //
        // Caller is expected to pass in an INTERNET_SECURITY_CONNECTION_INFO structure.

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_SECURITY_CONNECTION_INFO)) {
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            LPINTERNET_SECURITY_CONNECTION_INFO lpSecConnInfo;
            INTERNET_SECURITY_INFO ciInfo;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            lpSecConnInfo = (LPINTERNET_SECURITY_CONNECTION_INFO)lpBuffer;
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);

            if ((error = lphHttpRqst->GetSecurityInfo(&ciInfo)) == ERROR_SUCCESS) {
                // Set up that data members in the structure passed in.
                lpSecConnInfo->fSecure = TRUE;

                lpSecConnInfo->dwProtocol = ciInfo.dwProtocol;
                lpSecConnInfo->aiCipher = ciInfo.aiCipher;
                lpSecConnInfo->dwCipherStrength = ciInfo.dwCipherStrength;
                lpSecConnInfo->aiHash = ciInfo.aiHash;
                lpSecConnInfo->dwHashStrength = ciInfo.dwHashStrength;
                lpSecConnInfo->aiExch = ciInfo.aiExch;
                lpSecConnInfo->dwExchStrength = ciInfo.dwExchStrength;

                if (ciInfo.pCertificate)
                {
                    CertFreeCertificateContext(ciInfo.pCertificate);
                }

            } else if (error == ERROR_INTERNET_INTERNAL_ERROR)  {
                // This implies we are not secure.
                error = ERROR_SUCCESS;
                lpSecConnInfo->fSecure = FALSE;
            }

            lpSecConnInfo->dwSize = requiredSize;
            *lpdwBufferLength = requiredSize;
        }

        goto quit;


    case INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT:

        //
        // Allocates memory that caller is expected to free.
        //

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        } else {
            LPTSTR szResult = NULL;
            DWORD cchNeedLen = 0;
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&cInfo, (LPINTERNET_CERTIFICATE_INFO)lpBuffer, lpdwBufferLength);
                if(cInfo.pCertificate)
                {
                    CertFreeCertificateContext(cInfo.pCertificate);
                }
                goto quit;
            }
            else
            {
                error = ERROR_INTERNET_INVALID_OPERATION;
            }
        }
        break;

    case INTERNET_OPTION_SECURITY_KEY_BITNESS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO secInfo;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            if (ERROR_SUCCESS != lphHttpRqst->GetSecurityInfo(&secInfo)) {
                error = ERROR_INTERNET_INVALID_OPERATION;
            } else {
                dwValue = secInfo.dwCipherStrength;
                CertFreeCertificateContext(secInfo.pCertificate);

                INET_ASSERT (error == ERROR_SUCCESS);

                DEBUG_PRINT(INET,
                            INFO,
                            ("SECURITY_KEY_BITNESS: %X\n",
                            dwValue
                            ));

            }
        }

        break;


    case INTERNET_OPTION_PROXY:
        if (!ARGUMENT_PRESENT(hInternet)) {

            if (!GlobalProxyInfo.IsModifiedInProcess())
            {
                FixProxySettingsForCurrentConnection(
                    FALSE
                    );
            }

            error = GlobalProxyInfo.GetProxyStringInfo(lpBuffer, lpdwBufferLength);
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else if (handleType == TypeInternetHandle) {

            //
            // GetProxyInfo() will return the data, or calculate the buffer
            // length required
            //

            error = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetProxyStringInfo(
                lpBuffer,
                lpdwBufferLength
                );
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_VERSION:
        requiredSize = sizeof(InternetVersionInfo);
        lpSource = (LPVOID)&InternetVersionInfo;
        break;

    case INTERNET_OPTION_USER_AGENT:
        if (handleType == TypeInternetHandle) {
            lpSource = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetUserAgent();
            isString = TRUE;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_LINE_STATE:

        if(InternetSettingsChanged())
        {
            ChangeGlobalSettings();     // refreshes GlobalDllState
        }

        requiredSize = sizeof(DWORD);
        lpSource = (LPVOID)&dwValue;
        dwValue = GlobalDllState
                & (INTERNET_LINE_STATE_MASK | INTERNET_STATE_OFFLINE_USER);
        break;

    case INTERNET_OPTION_IDLE_STATE:
        requiredSize = sizeof(DWORD);
        lpSource = (LPVOID)&dwValue;
        dwValue = GlobalDllState & INTERNET_STATE_IDLE;
        break;

    case INTERNET_OPTION_OFFLINE_SEMANTICS:
        requiredSize = sizeof(DWORD);
        dwValue = FALSE;
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
        if (handleType == TypeHttpRequestHandle) {
                        lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
                        lpSource = lphRequest->GetSecondaryCacheKey();
                        isString = TRUE;
                } else {
                        error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
                }
        break;

    case INTERNET_OPTION_CALLBACK_FILTER:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_CONNECT_TIME:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_SEND_THROUGHPUT:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_RECEIVE_THROUGHPUT:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(dwValue);
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetPriority();
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_HTTP_VERSION:
        requiredSize = sizeof(HttpVersionInfo);
        lpSource = (LPVOID)&HttpVersionInfo;
        break;

    case INTERNET_OPTION_NET_SPEED:
        break;

    case INTERNET_OPTION_BYPASS_EDITED_ENTRY:
        requiredSize = sizeof(BOOL);
        dwValue = GlobalBypassEditedEntry;
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_DIAGNOSTIC_SOCKET_INFO:

        //
        // internal option
        //

        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(socketInfo);
            lpSource = (LPVOID)&socketInfo;

            HTTP_REQUEST_HANDLE_OBJECT * pReq;

            pReq = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            socketInfo.Socket = pReq->GetSocket();
            socketInfo.SourcePort = pReq->GetSourcePort();
            socketInfo.DestPort = pReq->GetDestPort();
            socketInfo.Flags = (pReq->FromKeepAlivePool()
                                    ? IDSI_FLAG_KEEP_ALIVE : 0)
                                | (pReq->IsSecure()
                                    ? IDSI_FLAG_SECURE : 0)
                                | (pReq->IsRequestUsingProxy()
                                    ? IDSI_FLAG_PROXY : 0)
                                | (pReq->IsTunnel()
                                    ? IDSI_FLAG_TUNNEL : 0);
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_CACHE_TIMESTAMPS:
        if (handleType == TypeHttpRequestHandle) {
            if (*lpdwBufferLength == sizeof(INTERNET_CACHE_TIMESTAMPS)) {
                INTERNET_CACHE_TIMESTAMPS* ts =
                    (INTERNET_CACHE_TIMESTAMPS*)lpBuffer;
                BOOL bU1;
                BOOL bU2;
                BOOL bU3;
                FILETIME ftPostCheck;

                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    GetTimeStampsForCache(
                        &(ts->ftExpires),
                        &(ts->ftLastModified),
                        &ftPostCheck,
                        &bU1, &bU2, &bU3 );
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        goto quit;
        break;

    case INTERNET_OPTION_DISABLE_AUTODIAL:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_AUTODIAL_MODE:
        requiredSize = sizeof(DWORD);
        dwValue = GetAutodialMode();
        lpSource = (LPVOID)&dwValue;
        break;

    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        error = GetAutodialConnection((LPSTR)lpBuffer, *lpdwBufferLength);
        isString = TRUE;
        lpSource = lpBuffer;
        requiredSize = *lpdwBufferLength;
        break;

    // IE5 #23845: Wininet: Various auth related feature requests for FP
    // This will return TRUE if post data will be sent on a request.
    case INTERNET_OPTION_DETECT_POST_SEND:
        if (handleType == TypeHttpRequestHandle)
        {
            requiredSize = sizeof(DWORD);
            lpSource = (LPVOID)&dwValue;
            HTTP_REQUEST_HANDLE_OBJECT *pRequest;
            pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;

            if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE
                && !((PLUG_CTX*)(pRequest->GetAuthCtx()))->_fNTLMProxyAuth
                && !(pRequest->GetAuthCtx()->GetSchemeType() == AUTHCTX::SCHEME_DPA))
            {
                dwValue = 0;
            }
            else
            {
                dwValue = 1;
            }
        }
        else
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_MAX_CONNS_PER_SERVER:
        if( !hInternet )  {
            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;
            dwValue = GlobalMaxConnectionsPerServer;
        }
        else
            error = ERROR_INTERNET_INVALID_OPERATION;

        break;

    case INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if( !hInternet ) {
            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;
            dwValue = GlobalMaxConnectionsPer1_0Server;
        }
        else
            error = ERROR_INTERNET_INVALID_OPERATION;

        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = QueryPerConnOptions(hInternet,
                                        lpThreadInfo->IsAutoProxyProxyThread,
                                        (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);

            requiredSize = *lpdwBufferLength;
            goto quit;
        }

    case INTERNET_OPTION_COOKIES_3RD_PARTY:
        if (handleType == TypeHttpRequestHandle)
        {
            requiredSize = sizeof(DWORD);
            lpSource = (LPVOID)&dwValue;
            dwValue = (DWORD) ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->Is3rdPartyCookies();
        }
        else
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

#if INET_DEBUG

    case INTERNET_OPTION_GET_DEBUG_INFO:
        error = InternetGetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     lpdwBufferLength
                                     );

        //
        // everything updated, so quit without going through common buffer
        // processing
        //

        goto quit;
        break;

    case INTERNET_OPTION_GET_HANDLE_COUNT:
        requiredSize = sizeof(DWORD);
        dwValue = InternetHandleCount();
        lpSource = (LPVOID)&dwValue;
        break;

#endif // INET_DEBUG

    default:
        requiredSize = 0;
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    //
    // if we have a buffer and enough space, then copy the data
    //

    if (error == ERROR_SUCCESS) {

        //
        // if we are returning a string, calculate the amount of space
        // required to hold it
        //

        if (isString) {
            if (lpSource != NULL) {
                requiredSize = lstrlen((LPCSTR)lpSource) + 1;
            } else {

                //
                // option string is NULL: return an empty string
                //

                lpSource = "";
                requiredSize = 1;
            }
        }

        INET_ASSERT(lpSource != NULL);

        if ((*lpdwBufferLength >= requiredSize)
        && ARGUMENT_PRESENT(lpBuffer)) {
            memcpy(lpBuffer, lpSource, requiredSize);
            if (isString) {

                //
                // string copied successfully. Returned length is string
                // length, not buffer length, i.e. drop 1 for '\0'
                //

                --requiredSize;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
    }

quit:

    //
    // return the amount the app needs to supply, or the amount of data in the
    // buffer, depending on success/failure status
    //

    *lpdwBufferLength = requiredSize;

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error == ERROR_SUCCESS) {
        success = TRUE;

        IF_DEBUG(API) {

            if (isString) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("returning %q (%d chars)\n",
                                lpBuffer,
                                requiredSize
                                ));

            } else {

                DEBUG_DUMP_API(API,
                               "option data:\n",
                               lpBuffer,
                               requiredSize
                               );

            }
        }
    } else {

        DEBUG_ERROR(API, error);

        IF_DEBUG(API) {

            if (error == ERROR_INSUFFICIENT_BUFFER) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("*lpdwBufferLength (%#x)= %d\n",
                                lpdwBufferLength,
                                *lpdwBufferLength
                                ));

            }
        }

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) InternetQueryOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet           -

    dwOption            -

    lpBuffer            -

    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetQueryOptionW",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBuffer;

    switch (dwOption)
    {
    case INTERNET_OPTION_USERNAME:
    case INTERNET_OPTION_PASSWORD:
    case INTERNET_OPTION_DATAFILE_NAME:
    case INTERNET_OPTION_URL:
    case INTERNET_OPTION_USER_AGENT:
    case INTERNET_OPTION_PROXY_USERNAME:
    case INTERNET_OPTION_PROXY_PASSWORD:
    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        if (lpBuffer)
        {
            mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
            mpBuffer.psStr = (LPSTR)ALLOC_BYTES(mpBuffer.dwAlloc*sizeof(CHAR));
            if (!mpBuffer.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (LPVOID)mpBuffer.psStr,
                                  &mpBuffer.dwSize
                                 );
        if (fResult)
        {
            *lpdwBufferLength = MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1,
                        NULL, 0);
            if (*lpdwBufferLength*sizeof(WCHAR)<=mpBuffer.dwAlloc && lpBuffer)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, *lpdwBufferLength);
                (*lpdwBufferLength)--;
            }
            else
            {
                *lpdwBufferLength *= sizeof(WCHAR);
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }
        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);

            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;
                listA.pOptions[i].Value.pszValue = NULL;
                plistW->pOptions[i].Value.pszValue = NULL;
            }

            fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (PVOID)&listA,
                                  lpdwBufferLength);

            // Now, convert from ansi to unicode

            if (fResult)
            {
                for (DWORD i=0; i<listA.dwOptionCount; i++)
                {
                    switch (listA.pOptions[i].dwOption)
                    {
                    case INTERNET_PER_CONN_FLAGS:
                    case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                    case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                        plistW->pOptions[i].Value.dwValue = listA.pOptions[i].Value.dwValue;
                        break;

                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                        plistW->pOptions[i].Value.ftValue = listA.pOptions[i].Value.ftValue;
                        break;
                    
                    case INTERNET_PER_CONN_PROXY_SERVER:
                    case INTERNET_PER_CONN_PROXY_BYPASS:
                    case INTERNET_PER_CONN_AUTOCONFIG_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                    case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                        if (listA.pOptions[i].Value.pszValue && *listA.pOptions[i].Value.pszValue)
                        {
                            DWORD cc = MultiByteToWideChar(CP_ACP, 
                                                           0, 
                                                           listA.pOptions[i].Value.pszValue, 
                                                           -1,
                                                           NULL,
                                                           0);
                            plistW->pOptions[i].Value.pszValue = (PWSTR)GlobalAlloc(GPTR, cc*sizeof(WCHAR));
                            if (!plistW->pOptions[i].Value.pszValue)
                            {
                                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                                goto iopco_cleanup;
                            }
                            MultiByteToWideChar(CP_ACP, 
                                                0, 
                                                listA.pOptions[i].Value.pszValue, 
                                                -1,
                                                plistW->pOptions[i].Value.pszValue,
                                                cc);
                        }
                        break;

                    default:
                        INET_ASSERT(FALSE);
                        dwErr = ERROR_INVALID_PARAMETER;
                        goto iopco_cleanup;
                        break;
                    }
                }
            }
            else
            {
                plistW->dwOptionError = listA.dwOptionError;
            }
            
        iopco_cleanup:
            // Free all the allocated buffers
            for (i=0; i<listA.dwOptionCount; i++)
            {
                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    // These should have been converted from ansi to unicode
                    // and can be freed now
                    if (listA.pOptions[i].Value.pszValue)
                    {
                        GlobalFree(listA.pOptions[i].Value.pszValue);
                    }
                    // No point in passing back buffers in the event of an error
                    // condition
                    if (dwErr && plistW->pOptions[i].Value.pszValue)
                    {
                        GlobalFree(plistW->pOptions[i].Value.pszValue);
                    }
                    break;

                default:
                    // No need to do anything
                    break;
                }
            }
        }
        break;

    default:
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  lpdwBufferLength
                                 );
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific INTERNET_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_INTERNET_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INTERNET_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_INTERNET_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INTERNET_BAD_OPTION_LENGTH
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionA",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD error;
    BOOL success = TRUE;
    HINTERNET_HANDLE_TYPE handleType;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD requiredSize;
    HINTERNET hObjectMapped = NULL;
    INTERNET_CONNECT_HANDLE_OBJECT *lphRequest;

    //
    // Auth code can query on connect handle by walking up from request handle,
    // unbeknownst to the client, who might try to set the option concurrently.
    // Ideally access would be serialized only for the four combinations of
    // {user,pass} and {server,proxy}, but unconditional keeps the code simple.
    //

    //AuthLock();

    //
    // validate parameters
    //

    if ((dwBufferLength == 0) || IsBadReadPtr(lpBuffer, dwBufferLength)) {


        switch (dwOption) {

            //
            // these options don't require a buffer - don't fail request because
            // no buffer supplied
            //

            case INTERNET_OPTION_SETTINGS_CHANGED:
            case INTERNET_OPTION_PROXY_SETTINGS_CHANGED:
            case INTERNET_OPTION_END_BROWSER_SESSION:
            case INTERNET_OPTION_RESET_URLCACHE_SESSION:
            case INTERNET_OPTION_REFRESH:
            case INTERNET_OPTION_DIGEST_AUTH_UNLOAD:
            case INTERNET_OPTION_IGNORE_OFFLINE:
            case INTERNET_OPTION_EXEMPT_CONNECTION_LIMIT:
            case INTERNET_OPTION_DISABLE_PASSPORT_AUTH:
            case INTERNET_OPTION_ENABLE_PASSPORT_AUTH:
            case INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS:
            case INTERNET_OPTION_ACTIVATE_WORKER_THREADS:
            case INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS:
                break;

            default:
                error = ERROR_INVALID_PARAMETER;
                goto quit;
        }
    }

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    //
    // validate the handle and get its type
    //

    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hInternet, FALSE);
        if (error == ERROR_SUCCESS) {
            hObjectMapped = hInternet;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        lpThreadInfo = InternetGetThreadInfo();
        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_INTERNET_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_INTERNET_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_INTERNET_INCORRECT_HANDLE_TYPE
                    : ERROR_INTERNET_INVALID_OPTION
                    ;
    }

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // if the option and handle combination is valid then set the option value
    //

    switch (dwOption) {
    case INTERNET_OPTION_CALLBACK:
    case INTERNET_OPTION_HANDLE_TYPE:
    //case INTERNET_OPTION_GATEWAY_NAME:
    case INTERNET_OPTION_KEEP_CONNECTION:
    case INTERNET_OPTION_ASYNC_ID:
    case INTERNET_OPTION_ASYNC_REQUEST_COUNT:
    case INTERNET_OPTION_ASYNC_QUEUE_DEPTH:
    case INTERNET_OPTION_WORKER_THREAD_TIMEOUT:
    case INTERNET_OPTION_IDLE_STATE:
    case INTERNET_OPTION_CONNECT_TIME:
    case INTERNET_OPTION_SEND_THROUGHPUT:
    case INTERNET_OPTION_RECEIVE_THROUGHPUT:
    case INTERNET_OPTION_NET_SPEED:

        //
        // these options cannot be set by this function
        //

        error = ERROR_INTERNET_OPTION_NOT_SETTABLE;
        break;

    case INTERNET_OPTION_HIBERNATE_INACTIVE_WORKER_THREADS:

        if (!g_bDisableHibernation)
        {
            g_bHibernating = TRUE;
        }
        break;
        
    case INTERNET_OPTION_ACTIVATE_WORKER_THREADS:
    
        if (g_bHibernating)
        {
            InterruptSelect();
            GlobalProxyInfo.ActivateAutoproxyThread();
        }
        break;

    case INTERNET_OPTION_RESTORE_WORKER_THREAD_DEFAULTS:

        if (g_bHibernating)
        {
            g_bHibernating = FALSE;
            InterruptSelect();
            GlobalProxyInfo.ActivateAutoproxyThread();
        }
        break;
        
    case INTERNET_OPTION_BYPASS_EDITED_ENTRY:
        requiredSize = sizeof(BOOL);
        if (dwBufferLength != requiredSize) {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            break;
        }
        // Only support global, not per handle yet
        if (hInternet != NULL) {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            break;
        }

        // Made it this far, so buffer is right size and handle is NULL
        GlobalBypassEditedEntry = *(LPBOOL)lpBuffer;
        break;


    case INTERNET_OPTION_CONNECT_TIMEOUT:
    case INTERNET_OPTION_CONNECT_RETRIES:
    case INTERNET_OPTION_CONNECT_BACKOFF:
    case INTERNET_OPTION_SEND_TIMEOUT:
    case INTERNET_OPTION_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_DATA_SEND_TIMEOUT:
    case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
    case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
        requiredSize = sizeof(DWORD);
        if (dwBufferLength != requiredSize) {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            break;
        }

        //
        // if hInternet is NULL then the app is requesting that we set the
        // global timeout values, not handle-specific ones
        //

        if (hInternet == NULL) {
            switch (dwOption) {
            case INTERNET_OPTION_CONNECT_TIMEOUT:
                GlobalConnectTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_CONNECT_RETRIES:
                GlobalConnectRetries = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_SEND_TIMEOUT:
                GlobalSendTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_RECEIVE_TIMEOUT:
                GlobalReceiveTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_DATA_SEND_TIMEOUT:
                GlobalDataSendTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_DATA_RECEIVE_TIMEOUT:
                GlobalDataReceiveTimeout = *(LPDWORD)lpBuffer;
                break;

            case INTERNET_OPTION_FROM_CACHE_TIMEOUT:
                GlobalFromCacheTimeout = *(LPDWORD)lpBuffer;
                break;
            }
            break;
        }


        //
        // we have a non-NULL context handle: the app wants to set specific
        // protocol timeouts
        //

        switch (handleType) {
        case TypeInternetHandle:
        case TypeFtpConnectHandle:
        case TypeFtpFindHandle:
        case TypeFtpFindHandleHtml:
        case TypeFtpFileHandle:
        case TypeFtpFileHandleHtml:
        case TypeGopherConnectHandle:
        case TypeGopherFindHandle:
        case TypeGopherFindHandleHtml:
        case TypeGopherFileHandle:
        case TypeGopherFileHandleHtml:
        case TypeHttpConnectHandle:
        case TypeHttpRequestHandle:

            //
            // N.B. For some of these handle types, setting a timeout etc.
            // value will have absolutely no affect (we have already gotten
            // the information after connecting, sending etc.), but we'll
            // allow the app to go ahead anyway (its benign)
            //

            error = RSetTimeout(hInternet,
                                dwOption,
                                *(LPDWORD)lpBuffer
                                );
            break;

        default:

            //
            // any other handle type (?) cannot have timeouts set for it
            //

            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case INTERNET_OPTION_CONTEXT_VALUE:

        //
        // BUGBUG - can't change context if async operation is pending
        //

        if (dwBufferLength == sizeof(lpThreadInfo->Context)) {
            error = RSetContext(hInternet, *((DWORD*) lpBuffer));
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_NAME_RES_THREAD:
        //if (dwBufferLength == sizeof(MultiThreadedNameResolution)) {
        //    MultiThreadedNameResolution = (BOOL)(*(LPDWORD)lpBuffer != 0);
        //} else {
        //    error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        //}
        break;

    case INTERNET_OPTION_READ_BUFFER_SIZE:
    case INTERNET_OPTION_WRITE_BUFFER_SIZE:
        if (IS_CONNECT_HANDLE_TYPE(handleType)) {
            if (dwBufferLength == sizeof(DWORD)) {

                DWORD bufferSize;

                bufferSize = *(LPDWORD)lpBuffer;
                if (bufferSize > 0) {
                    error = RSetBufferSize(hInternet, dwOption, bufferSize);
                } else {

                    //
                    // the read/write buffer size cannot be set to 0
                    //

                    error = ERROR_INVALID_PARAMETER;
                }
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    BOOL fUser, fProxy;

    case INTERNET_OPTION_ASYNC_PRIORITY:
        error = ERROR_CALL_NOT_IMPLEMENTED;
        break;

    case INTERNET_OPTION_AUTH_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetAuthFlag(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case INTERNET_OPTION_USERNAME:
        fUser = IS_USER;
        fProxy = IS_SERVER;
        goto callSetUserOrPass;


    case INTERNET_OPTION_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_SERVER;
        goto callSetUserOrPass;

    case INTERNET_OPTION_PROXY_USERNAME:
        fUser = IS_USER;
        fProxy = IS_PROXY;
        goto callSetUserOrPass;

    case INTERNET_OPTION_PROXY_PASSWORD:
        fUser = IS_PASS;
        fProxy = IS_PROXY;
        goto callSetUserOrPass;


callSetUserOrPass:

        if (hInternet == 0)
        {
            if (!fProxy)
            {
                AuthLock();
                SetUserOrPass ((LPSTR)lpBuffer, fUser);
                TimeStampCreds();
                AuthUnlock();
            }
            else
            {
                error = ERROR_INVALID_PARAMETER;
            }
            error = ERROR_SUCCESS;
        }
        else if (handleType != TypeInternetHandle) {
            AuthLock();
            lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
            lphRequest->SetUserOrPass ((LPSTR)lpBuffer, fUser, fProxy);
            lphRequest->TimeStampCreds();
            AuthUnlock();
            error = ERROR_SUCCESS;
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }

    break;

    case INTERNET_OPTION_DISABLE_PASSPORT_AUTH:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->DisableTweener();
            error = ERROR_SUCCESS;
        }
                    
        break;

    case INTERNET_OPTION_ENABLE_PASSPORT_AUTH:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->EnableTweener();
            error = ERROR_SUCCESS;
        }
                    
        break;
    
    case INTERNET_OPTION_EXEMPT_CONNECTION_LIMIT:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->ExemptConnLimit();
            error = ERROR_SUCCESS;
        }
                    
        break;

    case INTERNET_OPTION_CLIENT_CERT_CONTEXT:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(CERT_CONTEXT))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            CERT_CONTEXT_ARRAY* pArray = pRequest->GetCertContextArray();
            if (!pArray)
            {
                pArray = new CERT_CONTEXT_ARRAY;
                pRequest->SetCertContextArray(pArray);
            }

            if (!pArray)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
            {
                error = LoadSecurity();
                if (ERROR_SUCCESS == error)
                {
                    pArray->Reset();
                    pArray->AddCertContext((PCCERT_CONTEXT) lpBuffer);
                    pArray->SelectCertContext(0);
                    error = ERROR_SUCCESS;
                }
                else
                {
                    pRequest->SetCertContextArray(NULL);
                }
            }
        }
        break;
    
    case INTERNET_OPTION_SECURITY_SELECT_CLIENT_CERT:

    // This option sets an index into an internal wininet structure.
    // This is worthless to apps because there is no way to guarantee
    // they enum the cert store the same as wininet, especially if the
    // server returns a list of acceptable CA to filter by.  This has
    // been superseded by INTERNET_OPTION_CLIENT_CERT_CONTEXT above.

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            CERT_CONTEXT_ARRAY* pCertContextArray;
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            pCertContextArray =
                lphHttpRqst->GetCertContextArray();

            if ( ! pCertContextArray )
            {
                error = ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP;
            }
            else
            {

                if ( (*((LPINT)lpBuffer) < (INT) pCertContextArray->GetArraySize() )
                      || *((LPINT)lpBuffer) == -1 )
                {
                    pCertContextArray->SelectCertContext( *((LPDWORD)lpBuffer) );

                    error = ERROR_SUCCESS;
                }
                else
                {
                    error = ERROR_INVALID_PARAMETER;
                }
            }
        }
        break;

    case INTERNET_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecureFlags(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case INTERNET_OPTION_REFRESH:

        //
        // BUGBUG - can only accept global or InternetOpen() handles currently
        //

        if (!ARGUMENT_PRESENT(hInternet)) {
            if (!GlobalProxyInfo.IsModifiedInProcess()) {
                FixProxySettingsForCurrentConnection(TRUE);
                error = ERROR_SUCCESS;
            } else {
                INET_ASSERT(error == ERROR_SUCCESS);
            }
        } else if (handleType == TypeInternetHandle) {
            error = ((INTERNET_HANDLE_OBJECT *)hInternet)->Refresh(0);
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_PROXY:
        if ((handleType == TypeInternetHandle) || !ARGUMENT_PRESENT(hInternet)) {

            LPINTERNET_PROXY_INFO lpInfo = (LPINTERNET_PROXY_INFO)lpBuffer;

            //
            // validate parameters
            //

            if (dwBufferLength != sizeof(*lpInfo)) {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            } else if (!((lpInfo->dwAccessType == INTERNET_OPEN_TYPE_DIRECT)
                || (lpInfo->dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                || (lpInfo->dwAccessType == INTERNET_OPEN_TYPE_PRECONFIG))
            || ((lpInfo->dwAccessType == INTERNET_OPEN_TYPE_PROXY)
                && ((lpInfo->lpszProxy == NULL) || (*lpInfo->lpszProxy == '\0')))) {
                error = ERROR_INVALID_PARAMETER;
            } else {
                if (!ARGUMENT_PRESENT(hInternet)) {

                    INTERNET_PROXY_INFO_EX info;
                    memset(&info, 0, sizeof(info));
                    info.dwFlags = PROXY_TYPE_DIRECT;
                    

                    switch (lpInfo->dwAccessType) {
                        case INTERNET_OPEN_TYPE_PRECONFIG:
                            FixProxySettingsForCurrentConnection(TRUE);
                            error = ERROR_SUCCESS;
                            goto quit;
                        case INTERNET_OPEN_TYPE_DIRECT:
                            info.dwFlags |= PROXY_TYPE_DIRECT;
                            break;
                        case INTERNET_OPEN_TYPE_PROXY:     
                            info.dwFlags |= PROXY_TYPE_PROXY;
                            info.lpszProxy = lpInfo->lpszProxy;
                            info.lpszProxyBypass = lpInfo->lpszProxyBypass;
                            break;
                    }                    
                    GlobalProxyInfo.SetProxySettings(&info, TRUE ); 

                } else {
                    error = ((INTERNET_HANDLE_OBJECT *)hInternet)->SetProxyInfo(
                                lpInfo->dwAccessType,
                                lpInfo->lpszProxy,
                                lpInfo->lpszProxyBypass
                                );
                }
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_SETTINGS_CHANGED:
        {
            DWORD dwVer;

            IncrementCurrentSettingsVersion(&dwVer);
            // eat the update settings for this process,
            //  since calling ChangeGlobalSettings should suffice
            InternetSettingsChanged(); 
            ChangeGlobalSettings();
            PurgeKeepAlives(PKA_NOW);
        }

        break;

    case INTERNET_OPTION_PROXY_SETTINGS_CHANGED:
        {
            DWORD dwVer;

            IncrementCurrentSettingsVersion(&dwVer);
            // eat the update settings for this process,
            //  since calling ChangeGlobalSettings should suffice
            InternetSettingsChanged(); 
            ChangeGlobalSettings();
            // PurgeKeepAlives(PKA_NOW);
        }

        break;
    
    case INTERNET_OPTION_USER_AGENT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        } else {
            if (handleType == TypeInternetHandle) {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->SetUserAgent((LPSTR)lpBuffer);
            } else {
                error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
            }
        }
        break;

    case INTERNET_OPTION_END_BROWSER_SESSION:

        //
        // Flush the in-memory password cache and drop any keep-alive
        // sockets which had authorization (IIS retains the credentials.
        //

        AuthFlush();
        PurgeKeepAlives (PKA_AUTH_FAILED);

        if(g_hDialEvent)
        {
            WaitForSingleObject(g_hDialEvent, INFINITE);
            CloseHandle(g_hDialEvent);
        }

        //
        // Empty the content cache if registry key is set.
        //

        UrlCacheFlush();

        //
        // Flush session cookies.
        //

        PurgeCookieJarOfStaleCookies();

        //
        // Purge Proxy Script Cache
        //

        UPDATE_GLOBAL_PROXY_VERSION();

        //
        // Flush all cached SSL Certificates.
        //

        //GlobalCertCache.ClearList();

        //
        // Need to close global keys
        // 
        ResetAutodialModule();
        CloseInternetSettingsKey();

        //
        // Make sure cert key is reset, too
        //
        CloseMyCertStore();

    // Look out: intentional fall through.

    case INTERNET_OPTION_RESET_URLCACHE_SESSION:

    // Look out: intentional fall through.

        //
        // Restart the session used for cache syncmode.
        //

        GetCurrentGmtTime ((LPFILETIME)&dwdwSessionStartTime);
        dwdwSessionStartTime -= dwdwSessionStartTimeDefaultDelta;
        
        error = ERROR_SUCCESS;
        break;

    case INTERNET_OPTION_DIGEST_AUTH_UNLOAD:
        if (DIGEST_CTX::g_pFuncTbl)
        {
            DIGEST_CTX::Logoff();
            DIGEST_CTX::g_pFuncTbl = NULL;
        }            
        break;

    case INTERNET_OPTION_LINE_STATE:
        if (dwBufferLength == sizeof(INTERNET_ONLINE_OFFLINE_INFO)) {

            LPINTERNET_ONLINE_OFFLINE_INFO lpInfo;
            DWORD state;

            lpInfo = (LPINTERNET_ONLINE_OFFLINE_INFO)lpBuffer;
            state = lpInfo->dwOfflineState;

            //
            // we allow app to pass in INTERNET_STATE_OFFLINE_USER and interpret
            // it as same as INTERNET_STATE_OFFLINE
            //

            if (state == INTERNET_STATE_OFFLINE_USER) {
                state = INTERNET_STATE_OFFLINE;
            }
            if (((state == INTERNET_STATE_ONLINE)
            || (state == INTERNET_STATE_OFFLINE))
            && ((lpInfo->dwFlags & ~ISO_FORCE_OFFLINE) == 0)) {
                error = SetOfflineUserState(state,
                                            (lpInfo->dwFlags & ISO_FORCE_OFFLINE)
                                                ? TRUE
                                                : FALSE
                                            );

                // update registry value
                InternetWriteRegistryDword("GlobalUserOffline",
                        ((state == INTERNET_STATE_ONLINE) ? 0 : 1));

                // notification
                DWORD dwOp = CACHE_NOTIFY_SET_OFFLINE;
                if( state == INTERNET_STATE_ONLINE )
                {
                    dwOp = CACHE_NOTIFY_SET_ONLINE;
                }

                UrlCacheSendNotification(dwOp);

                // invalidate global info so other instances pick it up
                DWORD dwVer;
                IncrementCurrentSettingsVersion(&dwVer);

            } else {
                error = ERROR_INVALID_PARAMETER;
            }
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_OFFLINE_SEMANTICS:
        break;

    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
                if( handleType == TypeHttpRequestHandle ) {
                        lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
                        if (!lphRequest->SetSecondaryCacheKey((LPSTR) lpBuffer)) {
                                error = ERROR_NOT_ENOUGH_MEMORY;
                        } else {
                                INET_ASSERT (error == ERROR_SUCCESS);
                        }
                } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }

        break;

    case INTERNET_OPTION_CALLBACK_FILTER:
        error = ERROR_NOT_SUPPORTED;
        break;

    case INTERNET_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(LONG)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetPriority(*(LPLONG)lpBuffer);
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_HTTP_VERSION:
        if (dwBufferLength == sizeof(HTTP_VERSION_INFO)) {
            HttpVersionInfo = *(LPHTTP_VERSION_INFO)lpBuffer;
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_ERROR_MASK:
        lphRequest = (INTERNET_CONNECT_HANDLE_OBJECT *)hInternet;
        if (dwBufferLength == sizeof(DWORD)) {
            if ( *((LPDWORD) lpBuffer) & ~(INTERNET_ERROR_MASK_INSERT_CDROM |
                                           INTERNET_ERROR_MASK_COMBINED_SEC_CERT |
                                           INTERNET_ERROR_MASK_LOGIN_FAILURE_DISPLAY_ENTITY_BODY)) {

                error = ERROR_INVALID_PARAMETER;
            } else {
                lphRequest->SetErrorMask(*(LPDWORD) lpBuffer);
            }
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_CODEPAGE:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(DWORD)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetCodePage(*(LPDWORD)lpBuffer);
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_SEND_UTF8_SERVERNAME_TO_PROXY:
        if (!GlobalSendUTF8ServerToProxy)
        {
            error = ERROR_INTERNET_INVALID_OPTION;
        }
        else if (handleType != TypeHttpRequestHandle) 
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength != sizeof(DWORD))
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        else            
        {
            ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                SetSendUTF8ServerNameToProxy(*(LPDWORD)lpBuffer);
        }
        break;
        
    case INTERNET_OPTION_DISABLE_AUTODIAL:
        if (dwBufferLength == sizeof(DWORD)) {

            DWORD dwValue = *(LPDWORD)lpBuffer;

            SetAutodialEnable(dwValue == 0);
        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_AUTODIAL_MODE:
        if(dwBufferLength == sizeof(DWORD))
        {
            SetAutodialMode(*(LPDWORD)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        if(dwBufferLength > 0)
        {
            SetAutodialConnection((LPSTR)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    // Override to disable NTLM preauth.
    case INTERNET_OPTION_DISABLE_NTLM_PREAUTH:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(DWORD)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetDisableNTLMPreauth(*(LPDWORD)lpBuffer);
            } else {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_MAX_CONNS_PER_SERVER:
        if (dwBufferLength == sizeof(DWORD)) {
            DWORD dwValue = *(LPDWORD)lpBuffer;

            if( !hInternet )
            {
                GlobalMaxConnectionsPerServer = dwValue;
                // begin a-thkesa: 
                // Using NULL should affect the whole process.
                // As per the bug, its not affecting the visited sites.
                // so browse through the server info and set the new limits to all server.
                // WindSE BUG: 243039 & Windows 612742
                CServerInfo * lpServerInfo;
                LockSerializedList(&GlobalServerInfoList);
                for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
                    lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
                    lpServerInfo = lpServerInfo->Next()) 
                {
                    lpServerInfo->SetNewLimit(dwValue); 
                }
                UnlockSerializedList(&GlobalServerInfoList);
                //end: a-thkesa.
            }
            else
                error = ERROR_INTERNET_INVALID_OPERATION;

        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;


        break;
    case INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (dwBufferLength == sizeof(DWORD)) {
            DWORD dwValue = *(LPDWORD)lpBuffer;

            if( !hInternet )
            {
                GlobalMaxConnectionsPer1_0Server = dwValue;
                // begin a-thkesa: 
                // Using NULL should affect the whole process.
                // As per the bug, its not affecting the visited sites.
                // so browse through the server info and set the new limits to all server.
                // WindSE BUG: 243039 & Windows 612742
                CServerInfo * lpServerInfo;
                LockSerializedList(&GlobalServerInfoList);
                for (lpServerInfo = (CServerInfo *)HeadOfSerializedList(&GlobalServerInfoList);
                    lpServerInfo != (CServerInfo *)SlSelf(&GlobalServerInfoList);
                    lpServerInfo = lpServerInfo->Next()) 
                {
                    lpServerInfo->SetNewLimit(dwValue); 
                }
                UnlockSerializedList(&GlobalServerInfoList);
                //end: a-thkesa.
            }
            else
                error = ERROR_INTERNET_INVALID_OPERATION;

        } else {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }

        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (handleType != TypeInternetHandle) {
                hInternet = NULL;
            }

            error = SetPerConnOptions(hInternet, 
                lpThreadInfo? lpThreadInfo->IsAutoProxyProxyThread : FALSE,
                                      (LPINTERNET_PER_CONN_OPTION_LIST)lpBuffer);
            break;
        }
     
    case INTERNET_OPTION_IGNORE_OFFLINE:
        if (handleType == TypeHttpRequestHandle) {
            ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->SetIgnoreOffline();
        } else {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_IDENTITY:
        if (dwBufferLength==sizeof(IUserIdentity2 *))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else if (dwBufferLength==sizeof(GUID))
        {
            error = SwitchIdentity((GUID*)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_REMOVE_IDENTITY:
        if (dwBufferLength==sizeof(GUID))
        {
            error = RemoveIdentity((GUID*)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;
        
    case INTERNET_OPTION_ALTER_IDENTITY:
        if (dwBufferLength==sizeof(DWORD))
        {
            error = AlterIdentity(*(LPDWORD)lpBuffer);
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_SUPPRESS_BEHAVIOR:
        if (dwBufferLength==sizeof(DWORD))
        {
            error = ERROR_SUCCESS;
            switch (*(LPDWORD)lpBuffer)
            {
            case INTERNET_SUPPRESS_RESET_ALL:
                GlobalSuppressCookiesPolicy = FALSE;
                break;
                
            case INTERNET_SUPPRESS_COOKIE_POLICY:
                GlobalSuppressCookiesPolicy = TRUE;
                break;
                
            case INTERNET_SUPPRESS_COOKIE_POLICY_RESET:
                GlobalSuppressCookiesPolicy = FALSE;
                break;

            default:
                error = ERROR_INVALID_PARAMETER;
                break;
            }
        }
        else
        {
            error = ERROR_INTERNET_BAD_OPTION_LENGTH;
        }
        break;

    case INTERNET_OPTION_COOKIES_3RD_PARTY:
        if(handleType == TypeHttpRequestHandle)
        {
            if(sizeof(DWORD) == dwBufferLength)
            {
                BOOL f3rdParty = *(BOOL *)lpBuffer;

                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->Set3rdPartyCookies(f3rdParty);
            }
            else
            {
                error = ERROR_INTERNET_BAD_OPTION_LENGTH;
            }
        }
        else
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        break;

    case INTERNET_OPTION_SOCKET_SEND_BUFFER_LENGTH:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_INTERNET_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSocketSendBufferLength(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;


#if INET_DEBUG
    case INTERNET_OPTION_SET_DEBUG_INFO:
        error = InternetSetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     dwBufferLength
                                     );
        break;

#endif // INET_DEBUG

    default:

        //
        // this option is not recognized
        //

        error = ERROR_INTERNET_INVALID_OPTION;
    }

quit:

    //AuthUnlock();

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);

    return success;
}


INTERNETAPI_(BOOL) InternetSetOptionW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionW",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    switch (dwOption)
    {
    case INTERNET_OPTION_USERNAME:
    case INTERNET_OPTION_PASSWORD:
    case INTERNET_OPTION_DATAFILE_NAME:
    case INTERNET_OPTION_URL:
    case INTERNET_OPTION_USER_AGENT:
    case INTERNET_OPTION_PROXY_USERNAME:
    case INTERNET_OPTION_PROXY_PASSWORD:
    case INTERNET_OPTION_SECONDARY_CACHE_KEY:
    case INTERNET_OPTION_AUTODIAL_CONNECTION:
        ALLOC_MB((LPWSTR)lpBuffer, dwBufferLength, mpBuffer);
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI((LPWSTR)lpBuffer, mpBuffer);
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  mpBuffer.psStr,
                                  mpBuffer.dwSize
                                 );
        break;

    case INTERNET_OPTION_PER_CONNECTION_OPTION:
        {
            if (!lpBuffer)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }

            INTERNET_PER_CONN_OPTION_LISTA listA;
            LPINTERNET_PER_CONN_OPTION_LISTW plistW = (LPINTERNET_PER_CONN_OPTION_LISTW)lpBuffer;
            CHAR szEntryA[RAS_MaxEntryName + 1];
            listA.pszConnection = szEntryA;
            
            InitIPCOList(plistW, &listA);
            listA.pOptions = (LPINTERNET_PER_CONN_OPTIONA)_alloca(sizeof(INTERNET_PER_CONN_OPTIONA)*listA.dwOptionCount);
            
            for (DWORD i=0; i<listA.dwOptionCount; i++)
            {
                listA.pOptions[i].dwOption = plistW->pOptions[i].dwOption;

                switch (listA.pOptions[i].dwOption)
                {
                case INTERNET_PER_CONN_FLAGS:
                case INTERNET_PER_CONN_AUTODISCOVERY_FLAGS:
                case INTERNET_PER_CONN_AUTOCONFIG_RELOAD_DELAY_MINS:
                    listA.pOptions[i].Value.dwValue = plistW->pOptions[i].Value.dwValue;
                    break;

                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_TIME:
                    listA.pOptions[i].Value.ftValue = plistW->pOptions[i].Value.ftValue;
                    break;
                    
                case INTERNET_PER_CONN_PROXY_SERVER:
                case INTERNET_PER_CONN_PROXY_BYPASS:
                case INTERNET_PER_CONN_AUTOCONFIG_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL:
                case INTERNET_PER_CONN_AUTOCONFIG_LAST_DETECT_URL:
                    if (plistW->pOptions[i].Value.pszValue && *plistW->pOptions[i].Value.pszValue)
                    {
                        // ** WARNING ** NO UTF8 ENCODING HERE
                        DWORD cb = WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        0, 
                                        0,
                                        NULL,
                                        NULL);
                        listA.pOptions[i].Value.pszValue = (PSTR)_alloca(cb);
                        WideCharToMultiByte(CP_ACP, 
                                        0, 
                                        plistW->pOptions[i].Value.pszValue,
                                        -1,
                                        listA.pOptions[i].Value.pszValue, 
                                        cb,
                                        NULL,
                                        NULL);
                    }
                    else
                    {
                        listA.pOptions[i].Value.pszValue = NULL; 
                    }
                    break;
                    
                default:
                    dwErr = ERROR_INVALID_PARAMETER;
                    goto cleanup;
                    break;
                }
            }
            fResult = InternetSetOptionA(hInternet,
                              dwOption,
                              (PVOID)&listA,
                              dwBufferLength);
            plistW->dwOptionError = listA.dwOptionError;
        }
        break;

    default:
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  dwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI_(BOOL) InternetSetOptionExA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific INTERNET_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

    dwFlags             - flags controlling operation. Possible values are:

                            ISO_GLOBAL      - set this option globally. The
                                              shared Wininet data segment will
                                              be updated with this value

                            ISO_REGISTRY    - this value will be written to the
                                              registry for the corresponding
                                              entry

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_INTERNET_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INTERNET_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_INTERNET_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INTERNET_BAD_OPTION_LENGTH
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionExA",
                     "%#x, %s (%d), %#x [%#x], %d, %#x",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength,
                     dwFlags
                     ));

    BOOL success;

    //
    // validate parameters
    //

    //
    // currently, dwFlags MBZ
    //

    if (dwFlags == 0) {
        success = InternetSetOptionA(hInternet,
                                     dwOption,
                                     lpBuffer,
                                     dwBufferLength
                                     );
    } else {
        DEBUG_ERROR(INET, ERROR_INVALID_PARAMETER);
        SetLastError(ERROR_INVALID_PARAMETER);
        success = FALSE;
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI_(BOOL) InternetSetOptionExW(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

    dwFlags         -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "InternetSetOptionExW",
                     "%#x, %s (%d), %#x [%#x], %d, %#x",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength,
                     dwFlags
                     ));

    BOOL fResult = FALSE;

    if (dwFlags)
    {
        DEBUG_ERROR(INET, ERROR_INVALID_PARAMETER);
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    else
    {
        fResult = InternetSetOptionW(hInternet,
                                     dwOption,
                                     lpBuffer,
                                     dwBufferLength
                                     );
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    )
{
    return ((hType != TypeInternetHandle)   &&
            (hType != TypeFtpConnectHandle) &&
            (hType != TypeGopherConnectHandle) &&
            (hType != TypeFileRequestHandle) &&
            (hType != TypeHttpConnectHandle));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\parseurl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.cxx

Abstract:

    Contains functions to parse the basic URLs - FTP, Gopher, HTTP.

    An URL parser simply acts as a macro: it must break out the protocol-specific
    information from the URL and initiate opening the identified resource: all
    this can be accomplished by calling the relevant Internet protocol APIs.

    Code in this module is based on RFC1738

    Contents:
        IsValidUrl
        DoesSchemeRequireSlashes
        ParseUrl
        CrackUrl
        EncodeUrlPath
        (HexCharToNumber)
        (NumberToHexChar)
        DecodeUrl
        DecodeUrlInSitu
        DecodeUrlStringInSitu
        GetUrlAddressInfo
        GetUrlAddress
        MapUrlSchemeName
        MapUrlScheme
        MapUrlSchemeToName

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Apr-1995
        Created

--*/

#include <wininetp.h>
#include "autodial.h"

//
// private manifests
//

#define RESERVED    SAFE

//
// private macros
//

//#define HEX_CHAR_TO_NUMBER(ch) \
//    ((ch <= '9') \
//        ? (ch - '0') \
//        : ((ch >= 'a') \
//            ? ((ch - 'a') + 10) \
//            : ((ch - 'A') + 10)))

#define NUMBER_TO_HEX_CHAR(n) \
    (((n) <= 9) ? ((char)(n) + '0') : (((char)(n) - 10) + 'A'))

#define IS_UNSAFE_URL_CHARACTER(Char, Scheme) \
    (((UCHAR)(Char) <= 0x20) || ((UCHAR)(Char) >= 0x7f) \
    || (SafetyList[(Char) - 0x21] & (UNSAFE | Scheme)))

//
// private types
//

//
// private prototypes
//

PRIVATE
char
HexCharToNumber(
    IN char ch
    );

PRIVATE
char
NumberToHexChar(
    IN int Number
    );

PRIVATE
DWORD
ParseFileUrl(
    IN OUT LPHINTERNET lphInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    );


//
// private data
//

//
// SafetyList - the list of characters above 0x20 and below 0x7f that are
// classified as safe, unsafe or scheme-specific. Safe characters do not need
// to be escaped for any URL scheme. Unsafe characters must be escaped for all
// URL schemes. Scheme-specific characters need only be escaped for the relevant
// scheme(s)
//

PRIVATE
UCHAR
SafetyList[] = {

    //
    // UNSAFE: 0x00..0x20
    //

    SAFE,                       // 0x21 (!)
    UNSAFE,                     // 0x22 (")
    UNSAFE,                     // 0x23 (#)
    SAFE,                       // 0x24 ($)
    UNSAFE,                     // 0x25 (%)
    RESERVED,                   // 0x26 (&)
    SAFE,                       // 0x27 (')
    SAFE,                       // 0x28 (()
    SAFE,                       // 0x29 ())
    SAFE,                       // 0x2A (*)
    SCHEME_GOPHER,              // 0x2B (+)
    SAFE,                       // 0x2C (,)
    SAFE,                       // 0x2D (-)
    SAFE,                       // 0x2E (.)
    RESERVED,                   // 0x2F (/)
    SAFE,                       // 0x30 (0)
    SAFE,                       // 0x31 (1)
    SAFE,                       // 0x32 (2)
    SAFE,                       // 0x33 (3)
    SAFE,                       // 0x34 (4)
    SAFE,                       // 0x35 (5)
    SAFE,                       // 0x36 (6)
    SAFE,                       // 0x37 (7)
    SAFE,                       // 0x38 (8)
    SAFE,                       // 0x39 (9)
    RESERVED,                   // 0x3A (:)
    RESERVED,                   // 0x3B (;)
    UNSAFE,                     // 0x3C (<)
    RESERVED,                   // 0x3D (=)
    UNSAFE,                     // 0x3E (>)
    RESERVED | SCHEME_GOPHER,   // 0x3F (?)
    RESERVED,                   // 0x40 (@)
    SAFE,                       // 0x41 (A)
    SAFE,                       // 0x42 (B)
    SAFE,                       // 0x43 (C)
    SAFE,                       // 0x44 (D)
    SAFE,                       // 0x45 (E)
    SAFE,                       // 0x46 (F)
    SAFE,                       // 0x47 (G)
    SAFE,                       // 0x48 (H)
    SAFE,                       // 0x49 (I)
    SAFE,                       // 0x4A (J)
    SAFE,                       // 0x4B (K)
    SAFE,                       // 0x4C (L)
    SAFE,                       // 0x4D (M)
    SAFE,                       // 0x4E (N)
    SAFE,                       // 0x4F (O)
    SAFE,                       // 0x50 (P)
    SAFE,                       // 0x51 (Q)
    SAFE,                       // 0x42 (R)
    SAFE,                       // 0x43 (S)
    SAFE,                       // 0x44 (T)
    SAFE,                       // 0x45 (U)
    SAFE,                       // 0x46 (V)
    SAFE,                       // 0x47 (W)
    SAFE,                       // 0x48 (X)
    SAFE,                       // 0x49 (Y)
    SAFE,                       // 0x5A (Z)
    UNSAFE,                     // 0x5B ([)
    UNSAFE,                     // 0x5C (\)
    UNSAFE,                     // 0x5D (])
    UNSAFE,                     // 0x5E (^)
    SAFE,                       // 0x5F (_)
    UNSAFE,                     // 0x60 (`)
    SAFE,                       // 0x61 (a)
    SAFE,                       // 0x62 (b)
    SAFE,                       // 0x63 (c)
    SAFE,                       // 0x64 (d)
    SAFE,                       // 0x65 (e)
    SAFE,                       // 0x66 (f)
    SAFE,                       // 0x67 (g)
    SAFE,                       // 0x68 (h)
    SAFE,                       // 0x69 (i)
    SAFE,                       // 0x6A (j)
    SAFE,                       // 0x6B (k)
    SAFE,                       // 0x6C (l)
    SAFE,                       // 0x6D (m)
    SAFE,                       // 0x6E (n)
    SAFE,                       // 0x6F (o)
    SAFE,                       // 0x70 (p)
    SAFE,                       // 0x71 (q)
    SAFE,                       // 0x72 (r)
    SAFE,                       // 0x73 (s)
    SAFE,                       // 0x74 (t)
    SAFE,                       // 0x75 (u)
    SAFE,                       // 0x76 (v)
    SAFE,                       // 0x77 (w)
    SAFE,                       // 0x78 (x)
    SAFE,                       // 0x79 (y)
    SAFE,                       // 0x7A (z)
    UNSAFE,                     // 0x7B ({)
    UNSAFE,                     // 0x7C (|)
    UNSAFE,                     // 0x7D (})
    UNSAFE                      // 0x7E (~)

    //
    // UNSAFE: 0x7F..0xFF
    //

};

//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD SchemeFlags;
    BOOL NeedSlashes;
    LPFN_URL_PARSER SchemeParser;
    DWORD OpenFlags;
} URL_SCHEME_INFO;


PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,           0,  INTERNET_SCHEME_DEFAULT,    0,              FALSE,  NULL,           0,
    "ftp",          3,  INTERNET_SCHEME_FTP,        SCHEME_FTP,     TRUE,   ParseFtpUrl,    0,
    "gopher",       6,  INTERNET_SCHEME_GOPHER,     SCHEME_GOPHER,  TRUE,   ParseGopherUrl, 0,
    "http",         4,  INTERNET_SCHEME_HTTP,       SCHEME_HTTP,    TRUE,   ParseHttpUrl,   0,
    "https",        5,  INTERNET_SCHEME_HTTPS,      SCHEME_HTTP,    TRUE,   ParseHttpUrl,   INTERNET_FLAG_SECURE,
    "file",         4,  INTERNET_SCHEME_FILE,       0,              TRUE,   ParseFileUrl,   0,
    "news",         4,  INTERNET_SCHEME_NEWS,       0,              FALSE,  NULL,           0,
    "mailto",       6,  INTERNET_SCHEME_MAILTO,     0,              FALSE,  NULL,           0,
    "socks",        5,  INTERNET_SCHEME_SOCKS,      0,              FALSE,  NULL,           0,
    "javascript",   10, INTERNET_SCHEME_JAVASCRIPT, 0,              FALSE,  NULL,           0,
    "vbscript",     8,  INTERNET_SCHEME_VBSCRIPT,   0,              FALSE,  NULL,           0,
    "res",          3,  INTERNET_SCHEME_RES,        0,              TRUE,   NULL,           0
};

#define NUMBER_OF_URL_SCHEMES   ARRAY_ELEMENTS(UrlSchemeList)

BOOL ScanSchemes(LPTSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (strnicmp(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

//
// functions
//


BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Determines whether an URL has a valid format

Arguments:

    lpszUrl - pointer to URL to check.

    Assumes:    1. lpszUrl is non-NULL, non-empty string

Return Value:

    BOOL

--*/

{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');

    while (*lpszUrl != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszUrl, SCHEME_ANY)) {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}

BOOL IsValidHostName(IN LPCSTR lpszUrl, IN DWORD dwLength)
{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');
    INET_ASSERT(dwLength != '\0');

    while (*lpszUrl != '\0' && dwLength--) 
    {
        if (((UCHAR)(*lpszUrl) < 0x20))
        {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}


BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    )

/*++

Routine Description:

    Determines whether a protocol scheme requires slashes

Arguments:

    lpszScheme      - pointer to protocol scheme in question
                      (does not include ':' or slashes, just scheme name)

    dwUrlLength     - if not 0, string length of lpszScheme

Return Value:

    BOOL

--*/

{
    DWORD i;

    //
    // if dwSchemeLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwSchemeLength == 0) {
        dwSchemeLength = strlen(lpszScheme);
    }

    if (ScanSchemes(lpszScheme, dwSchemeLength, &i))
    {
        return UrlSchemeList[i].NeedSlashes;
    }
    return bHasHostName;
}



PRIVATE
DWORD
ParseFileUrl(
    IN OUT LPHINTERNET lphInternet,
    IN LPSTR Url,
    IN DWORD SchemeLength,
    IN LPSTR Headers,
    IN DWORD HeadersLength,
    IN DWORD OpenFlags,
    IN DWORD_PTR Context
    )

/*++

Routine Description:

    URL parser for generic File URLs. Support function for InternetOpenUrl() and
    ParseUrl().

    This is a macro function that just cracks the URL and calls Win32 File APIs to
    do the work

Arguments:

    lphInternet     - IN: pointer to InternetOpen handle
                      OUT: if successful handle of opened item, else undefined

    Url             - pointer to string containing FTP URL to open

    SchemeLength    - length of the URL scheme, exluding "://"

    Headers         - unused for FTP

    HeadersLength   - unused for FTP

    OpenFlags       - optional flags for opening a file (cache/no-cache, etc.)

    Context         - app-supplied context value for call-backs

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_FTP,
                 Dword,
                 "ParseFileUrl",
                 "%#x [%#x], %q, %d, %#x, %d, %#x, %#x",
                 lphInternet,
                 *lphInternet,
                 Url,
                 SchemeLength,
                 Headers,
                 HeadersLength,
                 OpenFlags,
                 Context
                 ));

    UNREFERENCED_PARAMETER(Headers);
    UNREFERENCED_PARAMETER(HeadersLength);


    DWORD urlLength;
    DWORD error = ERROR_SUCCESS;
    HINTERNET hInternetMapped = NULL;
    HANDLE hFileHandle;
    INTERNET_FILE_HANDLE_OBJECT *pFileHandleObj;

    //
    // parse "file://" component of the Url.
    //

    Url += SchemeLength + sizeof("://") - 1;

    //
    // BUGBUG - this function should receive the handle already mapped
    //

    error = MapHandleToAddress(*lphInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    INET_ASSERT(hInternetMapped != NULL);

    hFileHandle = CreateFile( Url,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL, // security attributes
                              OPEN_EXISTING,
                              FILE_FLAG_SEQUENTIAL_SCAN/*FILE_ATTRIBUTE_NORMAL*/,
                              NULL // handle to file attributes
                              );

    if ( hFileHandle == INVALID_HANDLE_VALUE)
    {
        error = GetLastError();
        goto quit;
    }

    pFileHandleObj = new INTERNET_FILE_HANDLE_OBJECT(
                                (INTERNET_HANDLE_OBJECT *)hInternetMapped,
                                Url,
                                hFileHandle,
                                OpenFlags,
                                Context
                                );

    if ( pFileHandleObj == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Link File Handle object to Internet Open handle.
    //

    RSetParentHandle(pFileHandleObj, hInternetMapped, FALSE);

    //
    // return the new file handle
    //

    *lphInternet = pFileHandleObj->GetPseudoHandle();

quit:

    if ( hInternetMapped != NULL )
    {
        DereferenceObject((LPVOID)hInternetMapped);
    }

    DEBUG_LEAVE(error);

    return error;
}

DWORD
CFsm_ParseUrlForHttp::ScanProxyUrl(
    IN CFsm_ParseUrlForHttp * Fsm
    )
/*++

Routine Description:

    Attempts to Determine what Protocol should be used for a given
      navigation on an URL, maps the scheme (FTP, HTTP, etc) to
      protocol parser

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/


{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "ScanProxyUrl",
                 "%#x",
                 Fsm
                 ));

    CFsm_ParseUrlForHttp & fsm = *Fsm;
    DWORD error = ERROR_SUCCESS;

    //
    // get parser based on the protocol name
    //

    for (fsm.m_dwSchemeLength = 0; fsm.m_lpcszUrl[fsm.m_dwSchemeLength] != ':'; ++fsm.m_dwSchemeLength) {
        if (fsm.m_lpcszUrl[fsm.m_dwSchemeLength] == '\0') {

            //
            // no ':' in URL
            //

            error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
            goto quit;
        }
    }

    DWORD i;

    if (ScanSchemes((LPSTR)fsm.m_lpcszUrl, fsm.m_dwSchemeLength, &i))
    {
        fsm.m_SchemeType = UrlSchemeList[i].SchemeType;
        fsm.m_dwFlags   |= UrlSchemeList[i].OpenFlags;
        fsm.m_pUrlParser = UrlSchemeList[i].SchemeParser;
    }

    //
    // we are only supporting Internet URL schemes, so the next token in the
    // URL should be "://"
    //

    if ((fsm.m_pUrlParser == NULL) ||
        (memcmp(&fsm.m_lpcszUrl[fsm.m_dwSchemeLength], "://", 3) != 0))
    {
        error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
        goto quit;
    }


    //
    // allocate a new URL that can be overwritten by the parsers (to avoid
    // having to allocate buffers/use stack buffers for the various sub-
    // strings contained within the URL)
    //

    fsm.m_lpszUrlCopy = NEW_STRING((LPSTR)fsm.m_lpcszUrl);
    if (fsm.m_lpszUrlCopy == NULL)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ParseUrlForHttp::BuildProxyMessage(
    IN CFsm_ParseUrlForHttp * Fsm
    )

/*++

Routine Description:

    Assembles the necessary parsed URL info that will be used
      for resolving and requesting proxy info

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DWORD error = ERROR_SUCCESS;

    CFsm_ParseUrlForHttp & fsm = *Fsm;

    LPSTR currentUrl;
    DWORD currentUrlLength;
    INTERNET_SCHEME currentScheme;
    LPSTR currentHostName;
    DWORD currentHostNameLength;
    INTERNET_PORT currentHostNamePort;

    //
    // Gather the URL off the handle
    //

    currentUrl = (LPSTR) fsm.m_lpcszUrl;
    currentUrlLength = lstrlen(currentUrl);

    //
    // crack the current URL
    //

    error = CrackUrl(currentUrl,
                     currentUrlLength,
                     FALSE, // don't escape URL-path
                     &currentScheme,
                     NULL,  // don't care about Scheme Name
                     NULL,
                     &currentHostName,
                     &currentHostNameLength,
                     &currentHostNamePort,
                     NULL,  // don't care about user name
                     NULL,
                     NULL,  // or password
                     NULL,
                     NULL,
                     NULL,
                     NULL,  // no extra
                     NULL,
                     NULL
                     );

    if ( error == ERROR_SUCCESS )
    {
        fsm.m_pProxyInfoQuery->SetProxyMsg(
            currentScheme,
            currentUrl,
            currentUrlLength,
            currentHostName,
            currentHostNameLength,
            currentHostNamePort
            );
    }

    return error;
}

DWORD
CFsm_ParseUrlForHttp::QueryProxySettings(
    IN CFsm_ParseUrlForHttp * Fsm,
    IN BOOL fCallback
    )
/*++

Routine Description:

    Calls internal proxy methods to determine what
     proxy (if any) a given request should use

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DWORD error = ERROR_SUCCESS;

    CFsm_ParseUrlForHttp & fsm = *Fsm;
    INTERNET_HANDLE_OBJECT * pMapped = (INTERNET_HANDLE_OBJECT *)fsm.m_hInternetMapped;

    if ( ! fCallback ) {
        fsm.m_pProxyInfoQuery->SetBlockUntilCompletetion(TRUE);
    }

    error = pMapped->GetProxyInfo(
                &fsm.m_pProxyInfoQuery
                );

    if ( error != ERROR_SUCCESS ) {
        goto quit;
    }

    if ( fsm.m_pProxyInfoQuery->IsUseProxy() &&
          (fsm.m_pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_HTTP ||
           fsm.m_pProxyInfoQuery->GetProxyScheme() == INTERNET_SCHEME_DEFAULT))
    {
        fsm.m_pUrlParser = ParseHttpUrl;
    }

quit:

    return error;
}


DWORD
CFsm_ParseUrlForHttp::CompleteParseUrl(
    IN CFsm_ParseUrlForHttp * Fsm,
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD error
    )

/*++

Routine Description:

    Handles the return code path after a protcol parser is
        called.  Needs to patch up ref counts and handle
        Html Handle types.

Arguments:

    Fsm - Containing the current request info
    lpThreadInfo - thread info
    error - Current error code in the parser

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    HINTERNET hUrlMapped = NULL;
    CFsm_ParseUrlForHttp & fsm = *Fsm;

    //
    // use our handle value in case the caller doesn't expect the input
    // handle to be modified
    //

    if (error == ERROR_SUCCESS) {

        //
        // map the new URL (Ftp,Gopher,etc) handle
        //

        error = MapHandleToAddress(fsm.m_hInternet, (LPVOID *)&hUrlMapped, FALSE);
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        //
        // we successfully created the handle object. If we are to return
        // HTML data (default) for this handle then we need to modify the
        // handle object to be the correct type
        //

        if ((fsm.m_pUrlParser != ParseHttpUrl) &&
           !(fsm.m_dwFlags & INTERNET_FLAG_RAW_DATA)) {

            DWORD handleError;

            //
            // RSetHtmlHandleType() does the right thing - it will set the
            // handle object to be HTML if the handle object is of a type
            // which can be set to HTML. Otherwise it will return an error
            //

            handleError = RSetHtmlHandleType(hUrlMapped);

            //
            // if ERROR_INTERNET_INVALID_OPERATION is returned then that is
            // OK, it just means the handle is not a type that we can convert
            // to HTML. Subsequent calls to InternetReadFile() will go the
            // normal route
            //

            if (handleError != ERROR_INTERNET_INVALID_OPERATION) {
                error = handleError;

                INET_ASSERT((error == ERROR_SUCCESS) || (error == ERROR_INVALID_HANDLE));

                //
                // if we successfully set the HTML handle type then we need
                // to associate the URL with the handle - we need the URL
                // when we create the HTML document in InternetReadFile().
                // RSetUrl() will create a copy of the URL and attach it to
                // the handle object
                //

                if (error == ERROR_SUCCESS) {
                    error = RSetUrl(hUrlMapped, (LPSTR)fsm.m_lpszUrlCopy);

                    INET_ASSERT(error == ERROR_SUCCESS);
                }
            }
        }

        //
        // BUGBUG - we may have some cleaning up to do if RSetHtmlHandleType()
        //          returns ERROR_INVALID_HANDLE (couldn't happen!) or if
        //          RSetUrl() fails (also couldn't happen!)
        //

    }

    //
    // Non-HTTP based parsers can sometimes polute the thread info
    //  structure with the wrong handle value (i.e. they may leave a Find handle,
    //   instead of the internet handle)
    //

    if (lpThreadInfo->IsAsyncWorkerThread)
    {
        _InternetSetObjectHandle(lpThreadInfo, fsm.m_hInternetCopy, fsm.m_hInternetMapped);
        _InternetSetContext(lpThreadInfo, fsm.m_dwContext);
    }

quit:

    if (hUrlMapped != NULL) {
        DereferenceObject((LPVOID)hUrlMapped);
    }

    return error;
}


#ifdef EXTENDED_ERROR_HTML
#error Not completed
DWORD
CFsm_ParseUrlForHttp::ExtendedErrorHtml(
    DWORD error
    )
{
    //
    // if we got extended error info AND we requested an FTP entity AND
    // we are not returning raw data then we will return the error info
    // as HTML. We need to generate a handle for this info
    //

    if ((error == ERROR_INTERNET_EXTENDED_ERROR)
    && !(OpenFlags & INTERNET_FLAG_RAW_DATA)
    && (protocolScheme == INTERNET_SCHEME_FTP)) {

        //
        // first we have to create a dummy connect handle object
        //

        HINTERNET hConnect = NULL;

        InternetSetObjectHandle(pMapped->GetPseudoHandle(), hMapped);
        InternetSetContext(INTERNET_NO_CALLBACK);
        error = RMakeInternetConnectObjectHandle(
            pMapped,
            &hConnect,
            NULL,                   // close function
            //hostName,               // server name
            NULL,
            0,                      // server port
            NULL,                   // user name
            NULL,                   // password
            INTERNET_SERVICE_FTP,
            0,                      // flags
            INTERNET_NO_CALLBACK    // context
            );
        if (error == ERROR_SUCCESS) {
            InternetSetObjectHandle(
                ((HANDLE_OBJECT *)hConnect)->GetPseudoHandle(),
                hConnect
                );
            InternetSetContext(Context);
            error = RMakeFtpErrorObjectHandle(hConnect, hInternet);
        }

        //
        // if we failed to generate the handle then just return the
        // original error & let the caller sort it out
        //

        if (error == ERROR_SUCCESS) {

            //
            // link child & parent so that InternetCloseHandle() on the
            // child (error) handle also derefs the parent (connect)
            // handle
            //

            RSetParentHandle(*hInternet, hConnect, TRUE);

            //
            // return the pseudo handle, not the object address
            //

            *hInternet = ((HANDLE_OBJECT *)(*hInternet))->GetPseudoHandle();
        } else {
            if (hConnect != NULL) {
                _InternetCloseHandleNoContext(
                    ((HANDLE_OBJECT *)hConnect)->GetPseudoHandle()
                    );
            }
            error = ERROR_INTERNET_EXTENDED_ERROR;
        }
    }
}
#endif // def EXTENDED_ERROR_HTML





DWORD
CFsm_ParseUrlForHttp::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ParseUrlForHttp::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ParseUrlForHttp * stateMachine = (CFsm_ParseUrlForHttp *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ParseUrlForHttp_Fsm(stateMachine);
        break;

    default:
        error = ERROR_INTERNET_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_INTERNET_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
ParseUrlForHttp_Fsm(
    IN CFsm_ParseUrlForHttp * Fsm
    )

/*++

Routine Description:

    The Root FSM that handles HTTP, FTP, and all other protcols
        for InternetOpenUrl

Arguments:

    Fsm - Containing the current request info

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    The URL passed in could not be parsed

--*/

{
    DEBUG_ENTER((DBG_UTIL,
                 Dword,
                 "ParseUrlForHttp_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ParseUrlForHttp & fsm = *Fsm;
    DWORD error = fsm.GetError();
    FSM_STATE state = fsm.GetState();
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL fOnApiCall = fsm.IsOnApiCall(); // Is the API on the stack?

    AUTO_PROXY_ASYNC_MSG proxyInfoQuery;
    DWORD schemeLength;
    INTERNET_SCHEME protocolScheme;
    INTERNET_HANDLE_OBJECT * pMapped = (INTERNET_HANDLE_OBJECT *)fsm.m_hInternetMapped;

    fsm.ClearOnApiCall();

    if (fsm.IsInvalid()) {
        goto quit;
    }

    if (state != FSM_STATE_INIT)
    {
        state = fsm.GetFunctionState();
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_INTERNET_INTERNAL_ERROR;
        goto quit;
    }

    switch (state)
    {
        case FSM_STATE_INIT:
        case FSM_STATE_1:
            {
                fsm.SetFunctionState(FSM_STATE_1);

                error = fsm.ScanProxyUrl(Fsm);

                if ( error != ERROR_SUCCESS) {
                    goto quit;
                }

                fsm.m_pProxyInfoQuery = &proxyInfoQuery;

                error = fsm.BuildProxyMessage(Fsm);

                if ( error != ERROR_SUCCESS ) {
                    goto quit;
                }


                if (fsm.m_pUrlParser == ParseFileUrl)
                {
                    LPFN_URL_PARSER parser = fsm.m_pUrlParser;

                    //
                    // call the FILE Parser right away
                    //

                    error = parser(&fsm.m_hInternet,
                                   fsm.m_lpszUrlCopy,
                                   fsm.m_dwSchemeLength,
                                   (LPSTR)fsm.m_lpcszHeaders,
                                   fsm.m_dwHeadersLength,
                                   fsm.m_dwFlags,
                                   fsm.m_dwContext
                                   );
                    goto quit;
                }

                if(0 == (pMapped->GetInternetOpenFlags() & INTERNET_FLAG_OFFLINE))
                {
                    InternetAutodialIfNotLocalHost(fsm.m_lpszUrlCopy, NULL);
                }

                fsm.SetFunctionState(FSM_STATE_2);
                error = fsm.QueryProxySettings(Fsm, FALSE);
                if ( error != ERROR_SUCCESS ) {
                    goto quit;
                } else {
                    fsm.SetFunctionState(FSM_STATE_3);
                }

                // fall through...
            }

        case FSM_STATE_2:
            {
                if ( fsm.GetFunctionState() == FSM_STATE_2 ) {
                    fsm.SetFunctionState(FSM_STATE_3);
                    error = fsm.QueryProxySettings(Fsm, TRUE);
                    if ( error != ERROR_SUCCESS ) {
                        goto quit;
                    }
                }

                // fall through...
            }

        case FSM_STATE_3:
            {

                fsm.SetFunctionState(FSM_STATE_4);

                if ( fsm.m_pUrlParser == ParseHttpUrl)
                {
                    DWORD dwFlags = fsm.m_dwFlags;

                    //
                    // call the protocol-specific parser to open the entity identified
                    // by the URL
                    //

                    fsm.SetBlocking(FALSE);
                    _InternetIncNestingCount();

                    if  (dwFlags & INTERNET_FLAG_RESYNCHRONIZE
                        && (fsm.m_pProxyInfoQuery->GetUrlScheme() == INTERNET_SCHEME_FTP
                        ||  fsm.m_pProxyInfoQuery->GetUrlScheme() == INTERNET_SCHEME_GOPHER)) {

                        //
                        // For ftp and gopher via proxy, there is no if-modified-since,
                        // so we force a reload, otherwise proxy may serve stale data.
                        //

                        dwFlags |= INTERNET_FLAG_RELOAD;
                    }

                    //
                    // remove local proxy info, before going pending
                    //

                    if ( !fsm.m_pProxyInfoQuery->IsAlloced()) {
                        fsm.m_pProxyInfoQuery = NULL;
                    }

                    error = DoFsm(new CFsm_ParseHttpUrl(&fsm.m_hInternet,
                                                        fsm.m_lpszUrlCopy,
                                                        fsm.m_dwSchemeLength,
                                                        (LPSTR)fsm.m_lpcszHeaders,
                                                        fsm.m_dwHeadersLength,
                                                        dwFlags,
                                                        fsm.m_dwContext
                                                        ));
                    _InternetDecNestingCount(1);
                    if (error == ERROR_IO_PENDING) {
                        goto quit;
                    }
                }
                else if (fsm.m_pUrlParser != NULL)
                {
                    LPFN_URL_PARSER parser = fsm.m_pUrlParser;

                    fsm.SetBlocking(TRUE);
                    _InternetIncNestingCount();

                    //
                    // call the protocol-specific parser to open the entity identified
                    // by the URL
                    //

                    error = parser(&fsm.m_hInternet,
                                   fsm.m_lpszUrlCopy,
                                   fsm.m_dwSchemeLength,
                                   (LPSTR)fsm.m_lpcszHeaders,
                                   fsm.m_dwHeadersLength,
                                   fsm.m_dwFlags,
                                   fsm.m_dwContext
                                   );

#ifdef EXTENDED_ERROR_HTML
                    error = fsm.ExtendedErrorHtml(Fsm, error);
#endif
                    _InternetDecNestingCount(1);

                    //if ( error != ERROR_SUCCESS ) {
                    //    goto quit;
                    //}

                }
                else
                {
                    error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
                }
            }

        case FSM_STATE_4:
            {

                error = fsm.CompleteParseUrl(Fsm, lpThreadInfo, error);

                //
                // and free the copy of the URL
                //

                if ( fsm.m_lpszUrlCopy ) {
                    DEL_STRING(fsm.m_lpszUrlCopy);
                }

                //if (fsm.m_pProxyState) {
                //    if (pMapped->RedoSendRequest(&error, fsm.m_pProxyState)) {
                //        fsm.SetNextState(FSM_STATE_INIT);
                //        goto retry_with_different_proxy;
                //    }
                //    fsm.m_pProxyState = NULL;
                //}
            }

    } // end of switch(state)
quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();

        if ( fsm.m_pProxyInfoQuery &&
             fsm.m_pProxyInfoQuery->IsAlloced() )
        {
            delete fsm.m_pProxyInfoQuery;
            fsm.m_pProxyInfoQuery = NULL;
        }

        fsm.m_pProxyInfoQuery = NULL;  // just in case

        if (fsm.m_pProxyState) {
            delete fsm.m_pProxyState;
        }

        //
        // only deref hInternet if we are in sync mode, otherwise it is done in
        // async request completion
        //
        // BUGBUG - RLF 05/17/97
        //
        // Need to fix this - it is confusing and error-prone. Right fix is to
        // do like old async code does - additional ref when starting async
        // request && additional deref when completing async processing
        //

        if (!fOnApiCall &&
            (fsm.m_hInternetMapped != NULL))
        {
            fsm.m_hInternetMapped = NULL;
        }
        if (error == ERROR_SUCCESS) {
            if (fsm.GetThreadInfo()->IsAsyncWorkerThread) {

                //
                // async request - return handle in FSM - lphInternet points
                // into app thread's stack - original request completed with
                // pending so we can't return it there
                //

                fsm.SetApiResult(fsm.m_hInternet);
            } else {

                //
                // sync request - app thread's stack is still there so we are
                // safe to return the handle through the pointer
                //

                *fsm.m_lphInternet = fsm.m_hInternet;
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error;
    DWORD schemeLength;
    INTERNET_SCHEME schemeType;

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = strlen(lpszUrl);
    }

    //
    // get parser based on the protocol name
    //

    for (schemeLength = 0; lpszUrl[schemeLength] != ':'; ++schemeLength) {
        if ((dwUrlLength == 0) || (lpszUrl[schemeLength] == '\0')) {

            //
            // no ':' in URL? Bogus (dude)
            //

            error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
            goto quit;
        }
        --dwUrlLength;
    }

    DWORD i;
    int skip;
    BOOL isGeneric;
    BOOL needSlashes;
    BOOL haveSlashes;

    isGeneric = FALSE;
    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = INTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(lpszUrl, schemeLength, &i))
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength > 3) && (memcmp(&lpszUrl[schemeLength], "://", 3) == 0)) {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    if (schemeType == INTERNET_SCHEME_FILE)
        isGeneric = TRUE;

    if (schemeType == INTERNET_SCHEME_NEWS ||
        schemeType == INTERNET_SCHEME_UNKNOWN) {

        //
        //  urls can be hierarchical or opaque.  if the slashes
        //  exist, then we should assume hierarchical
        //  when we dont know the scheme or it is news:.
        //  otherwise it is opaque (isGeneric)
        //

        needSlashes = haveSlashes;
        isGeneric = !haveSlashes;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if ((!haveSlashes && !needSlashes) || (haveSlashes && needSlashes)) {
        if (ARGUMENT_PRESENT(lpSchemeType)) {
            *lpSchemeType = schemeType;
        }
        if (ARGUMENT_PRESENT(lpszSchemeName)) {
            *lpszSchemeName = lpszUrl;
            *lpdwSchemeNameLength = schemeLength;
        }
        lpszUrl += schemeLength + skip;
        dwUrlLength -= skip;

        if (INTERNET_SCHEME_RES == schemeType) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            PTSTR psz = lpszUrl;
            while (*lpszUrl && *lpszUrl!='/')
                lpszUrl++;

            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = psz;
                *lpdwHostNameLength = PtrDiff32(lpszUrl, psz);
                dwUrlLength -= *lpdwHostNameLength;
                error = DecodeUrlInSitu(*lpszHostName, lpdwHostNameLength);
           }
        } else if (isGeneric) {
            if (ARGUMENT_PRESENT(lpszUserName)) {
                *lpszUserName = NULL;
                *lpdwUserNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszPassword)) {
                *lpszPassword = NULL;
                *lpdwPasswordLength = 0;
            }
            if (ARGUMENT_PRESENT(lpszHostName)) {
                *lpszHostName = NULL;
                *lpdwHostNameLength = 0;
            }
            if (ARGUMENT_PRESENT(lpServerPort)) {
                *lpServerPort = 0;
            }
            error = ERROR_SUCCESS;
        } else {
            error = GetUrlAddress(&lpszUrl,
                                  &dwUrlLength,
                                  lpszUserName,
                                  lpdwUserNameLength,
                                  lpszPassword,
                                  lpdwPasswordLength,
                                  lpszHostName,
                                  lpdwHostNameLength,
                                  lpServerPort,
                                  pHavePort
                                  );
        }
        if (bEscape && (error == ERROR_SUCCESS)) {
            error = DecodeUrlInSitu(lpszUrl, &dwUrlLength);
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszExtraInfo)) {
            *lpdwExtraInfoLength = 0;
            for (i = 0; i < (int)dwUrlLength; i++) {
                if (lpszUrl[i] == '?' || lpszUrl[i] == '#') {
                    *lpszExtraInfo = &lpszUrl[i];
                    *lpdwExtraInfoLength = dwUrlLength - i;
                    dwUrlLength -= *lpdwExtraInfoLength;
                }
            }
        }
        if ((error == ERROR_SUCCESS) && ARGUMENT_PRESENT(lpszUrlPath)) {
            *lpszUrlPath = lpszUrl;
            *lpdwUrlPathLength = dwUrlLength;
        }
    } else {
        error = ERROR_INTERNET_UNRECOGNIZED_SCHEME;
    }

quit:

    return error;
}


DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR EncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    )

/*++

Routine Description:

    Encodes an URL-path. That is, escapes the string. Creates a new URL-path in
    which all the 'unsafe' and reserved characters for this scheme have been
    converted to escape sequences

Arguments:

    Flags                   - controlling expansion

    SchemeFlags             - which scheme we are encoding for -
                              SCHEME_HTTP, etc.

    UrlPath                 - pointer to the unescaped string

    UrlPathLength           - length of Url

    EncodedUrlPath          - pointer to buffer where encoded URL will be
                              written

    EncodedUrlPathLength    - IN: size of EncodedUrlPath
                              OUT: number of bytes written to EncodedUrlPath

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    UrlPathLength not large enough to store encoded URL path

--*/

{
    DWORD error;
    DWORD len;

    len = *EncodedUrlPathLength;
    while (len > 0) {

        UCHAR ch;

        ch = (UCHAR)*UrlPath++;
        if (ch == '\0') {

            //
            // end of input URL. Done
            //

            break;
        }

        //
        // check whether this character is safe. For now, we encode all unsafe
        // and scheme-specific characters the same way (i.e. irrespective of
        // scheme)
        //
        // We are allowing '/' to be copied unmodified
        //

        if (IS_UNSAFE_URL_CHARACTER(ch, SchemeFlags)
        && !((ch == '/') && (Flags & NO_ENCODE_PATH_SEP))) {
            if (len < 3) {

                //
                // set the length to zero so that we return
                // ERROR_INSUFFICIENT_BUFFER
                //

                len = 0;
                break;
            }
            *EncodedUrlPath++ = '%';
            //*EncodedUrlPath++ = NumberToHexChar((int)ch / 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch / 16);
            //*EncodedUrlPath++ = NumberToHexChar((int)ch % 16);
            *EncodedUrlPath++ = NUMBER_TO_HEX_CHAR((int)ch % 16);
            len -= 2; // extra --len below
        } else {
            *EncodedUrlPath++ = (signed char)ch;
        }
        --len;
    }
    if (len >= 1) {
        *EncodedUrlPath = '\0';
        *EncodedUrlPathLength -= len;
        error = ERROR_SUCCESS;
    } else {
        error = ERROR_INSUFFICIENT_BUFFER;
    }
    return error;
}


PRIVATE
char
HexCharToNumber(
    IN char ch
    )

/*++

Routine Description:

    Converts an ANSI character in the range '0'..'9' 'A'..'F' 'a'..'f' to its
    corresponding hexadecimal value (0..f)

Arguments:

    ch  - character to convert

Return Value:

    char
        hexadecimal value of ch, as an 8-bit (signed) character value

--*/

{
    return (ch <= '9') ? (ch - '0')
                       : ((ch >= 'a') ? ((ch - 'a') + 10) : ((ch - 'A') + 10));
}


PRIVATE
char
NumberToHexChar(
    IN int Number
    )

/*++

Routine Description:

    Converts a number in the range 0..15 to its ASCII character hex representation
    ('0'..'F')

Arguments:

    Number  - to convert

Return Value:

    char
        character in above range

--*/

{
    return (Number <= 9) ? (char)('0' + Number) : (char)('A' + (Number - 10));
}


DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {

        char ch;

        if (*Url == '%') {

            //
            // BUGBUG - would %00 ever appear in an URL?
            //

            ++Url;
            if (isxdigit(*Url)) {
                ch = HexCharToNumber(*Url++) << 4;
                if (isxdigit(*Url)) {
                    ch |= HexCharToNumber(*Url++);
                } else {
                    return ERROR_INTERNET_INVALID_URL;
                }
            } else {
                return ERROR_INTERNET_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}


DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD stringLength;

    stringLength = *BufferLength;
    if (memchr(BufferAddress, '%', stringLength)) {
        return DecodeUrl(BufferAddress,
                         stringLength,
                         BufferAddress,
                         BufferLength
                         );
    } else {

        //
        // no escape character in the string, just return success
        //

        return ERROR_SUCCESS;
    }
}


DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Performs DecodeUrlInSitu() on a string and zero terminates it

    Assumes: 1. Even if no decoding is performed, *BufferLength is large enough
                to fit an extra '\0' character

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string, excluding '\0'

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error;

    error = DecodeUrlInSitu(BufferAddress, BufferLength);
    if (error == ERROR_SUCCESS) {
        BufferAddress[*BufferLength] = '\0';
    }
    return error;
}


DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL

--*/

{
    LPSTR pString;
    LPSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString != '/') && (*pString != '\0') && (length != 0)) {
        if (*pString == '%') {

            //
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //

            *partEscape = TRUE;
        }
        if (*pString == ':') {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                return ERROR_INTERNET_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_INTERNET_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    LPSTR pAt;
    DWORD urlLength;
    LPSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    char portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPSTR pPortNumber;
    DWORD error;
    LPSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = strlen(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    if (GlobalMBCSAPIforCrack)
    {
        BOOL bFound = FALSE;
        for (pAt = pUrl; pAt < (pUrl+urlLength); pAt = CharNext(pAt))
        {
            if (*pAt == '/')
            {
                break;
            }
            else if (*pAt == '@')
            {
                bFound = TRUE;
                break;
            }
        }
        if (!bFound)
            pAt = NULL;
    }
    else
    {
        for (DWORD i = 0; i < urlLength; ++i) {
            if (pUrl[i] == '/') {
                break;
            } else if (pUrl[i] == '@') {
                pAt = &pUrl[i];
                break;
            }
        }
    }

    if (pAt != NULL) {

        DWORD addressPartLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        INET_ASSERT(addressPartLength == 0);
        INET_ASSERT(pUrl == pAt);

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword)) {

            //
            // convert the password in situ
            //

            if (part2Escape) {

                INET_ASSERT(userName != NULL);
                INET_ASSERT(userNameLength != 0);
                INET_ASSERT(password != NULL);
                INET_ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {

        //
        // no '@' therefore no username or password
        //

        if (ARGUMENT_PRESENT(lpszUserName)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (ARGUMENT_PRESENT(lpszPassword)) {

            INET_ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_INTERNET_INVALID_URL;
//  }

    if (ARGUMENT_PRESENT(lpszHostName)) {

        INET_ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }

            if(!IsValidHostName(hostName, hostNameLength))
            {
                return ERROR_INTERNET_INVALID_URL;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (ARGUMENT_PRESENT(lpPort)) {
        if (portNumberLength != 0) {

            DWORD i;
            DWORD port;

            INET_ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!isdigit(*pPortNumber)) {
                    return ERROR_INTERNET_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - '0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535)
                {
                    return ERROR_INTERNET_INVALID_URL;
                }
            }
            *lpPort = (INTERNET_PORT)port;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
            if (ARGUMENT_PRESENT(pHavePort)) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName      - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1) {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    DWORD i;
    if (ScanSchemes(lpszSchemeName, dwSchemeNameLength, &i))
    {
        return UrlSchemeList[i].SchemeType;
    }
    return INTERNET_SCHEME_UNKNOWN;
}


LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme                  - enumerated scheme type to map

    lpdwSchemeNameLength    - pointer to returned length of scheme name

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        *lpdwSchemeNameLength = UrlSchemeList[Scheme].SchemeLength;
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}


LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme  - enumerated scheme type to map

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\makefile.inc ===
!if "$(BUILD_PRODUCT)" == "IE"
MC_INC = -A
!endif

$(O)\inetmsg.rc $(O)\inetmsg.h $(O)\msg00001.bin : inetmsg.mc
    mc $(MC_INC) -v -d -r $(O) -h $(O) inetmsg.mc

$(SDK_INC_PATH)\inetmsg.h : $(O)\inetmsg.h
   $(PUBLISH_CMD) {$?=$@}

#wininet.sym: wininet.map
#    mapsym -o wininet.sym wininet.map

wininet.rc : $(O)\selfreg_wininet.inf
wininet.rc : ..\inetui\inetui.rc
wininet.rc : *.ico

$(O)\selfreg_wininet.inf : selfreg.inx
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\wininet\dll\registry.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

    Contents:
        EnsureInternetSettingsKeyCached
        CloseInternetSettingsKey
        GetMyEmailName
        InternetGetComputerName
        InternetDeleteRegistryValue
        InternetReadRegistryDword
        InternetWriteRegistryDword
        InternetReadRegistryString
        InternetWriteRegistryString
        InternetReadRegistryBinary
        (InternetReadRegistryDwordKey)
        (InternetReadRegistryStringKey)
        (InternetReadRegistryBinaryKey)
        (InternetGetPrivateProfileString)
        (ReadRegistryOemString)
        (WriteRegistryDword)
        ReadRegistryDword
        GetFileExtensionFromMimeType
        CreateMimeExclusionTableForCache
        DestroyMimeExclusionTableForCache
        CreateHeaderExclusionTableForCache
        DestroyHeaderExclusionTableForCache
        (CreateTableFromRegistryList)
        (CreateStringArrayFromDelimitedList)

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Environment:

    Win32(s) user-level DLL

Revision History:

    20-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

char vszDelimiters[] = ";, ";

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    );

//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );


PRIVATE
DWORD
CreateTableFromRegistryList(
    IN LPSTR   lpszParameter,       // wininet registry parameter
    OUT LPSTR   *lplpszList,        // Delimited List
    OUT LPSTR   **lplprgszTable,    // Pointer table pointing into the list
    OUT DWORD   **lplpdwTableSizes, // Pointer to table containing sizes of string elements
    OUT LPDWORD lpdwCount           // count of elements in the table
    );

PRIVATE
DWORD
CreateStringArrayFromDelimitedList(
    IN  LPSTR   lpszDelimitedList,
    IN  LPSTR   lpszDelimiters,
    IN  LPSTR   *lprgszStringArray,
    OUT LPDWORD lpdwCount
    );


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

//
// private data
//

PRIVATE CRefdKey* g_prkInternetSettings = NULL;


//
// functions
//

CRefdKey*
OpenInternetSettingsKey(
    VOID
    )
{
    CRefdKey* prk = NULL;
    HKEY hkInternetSettings = NULL;
    DWORD dwDisposition;

    REGCREATEKEYEX(HKEY_CURRENT_USER,
                   INTERNET_SETTINGS_KEY,
                   0,     // reserved
                   NULL,  // class
                   0,     // options
                   KEY_READ | KEY_WRITE,
                   NULL,  // security attributes
                   &hkInternetSettings,
                   &dwDisposition
                   );

    if (hkInternetSettings)
    {
        prk = new CRefdKey(hkInternetSettings);

        if (!prk)
        {
            // we failed to create a ref'd key, so close the key we opened
            REGCLOSEKEY(hkInternetSettings);
        }
    }

    return prk;
}


CRefdKey*
GetInternetSettingsKey(
    VOID
    )
{
    CRefdKey* prk;

    EnterCriticalSection(&GeneralInitCritSec);

    prk = g_prkInternetSettings;
    if (prk)
    {
        prk->AddRef();
    }
    else
    {
        prk = OpenInternetSettingsKey();
        if (prk)
        {
            // addref once more for sticking in in the global
            prk->AddRef();

            // cache this value in the global
            g_prkInternetSettings = prk;
        }
    }

    LeaveCriticalSection(&GeneralInitCritSec);

    return prk;
}


VOID
EnsureInternetSettingsKeyCached(
    VOID
    )

/*++

Routine Description:

    Ensures that the registry key for the Internet Settings branch is 
    cached and ready to be used

Arguments:

    None.

Return Value:

    None.

--*/

{
    CRefdKey* prk;

    DEBUG_ENTER((DBG_REGISTRY,
                 None,
                 "EnsureInternetSettingsKeyCached",
                 NULL
                 ));

    // just get the key and release it to ensure that it has been cached in g_prkInternetSettings
    prk = GetInternetSettingsKey();
    if (prk)
    {
        prk->Release();
    }
}



DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "CloseInternetSettingsKey",
                 NULL
                 ));

    CRefdKey* prk;

    EnterCriticalSection (&GeneralInitCritSec);

    prk = g_prkInternetSettings;
    if (prk)
    {
        g_prkInternetSettings = NULL;

        prk->Release();
    }

    LeaveCriticalSection (&GeneralInitCritSec);

    DEBUG_LEAVE(ERROR_SUCCESS);

    return ERROR_SUCCESS;
}


DWORD
GetMyEmailName(
    OUT LPSTR EmailName,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Retrieve the user's email name from the appropriate place in the registry

Arguments:

    EmailName   - place to store email name

    Length      - IN: length of EmailName
                  OUT: returned length of EmailName (in characters, minus
                       trailing NUL)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                  ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "GetMyEmailName",
                 "%#x, %#x [%d]",
                 EmailName,
                 Length,
                 *Length
                 ));

    DWORD error;

    //
    // for the EmailName, we first try HKEY_CURRENT_USER. If that fails then we
    // try the same branch of the HKEY_LOCAL_MACHINE tree. If that fails,
    // invent something
    //

    static HKEY KeysToTry[2] = {HKEY_CURRENT_USER, HKEY_LOCAL_MACHINE};
    int i;

    //
    // in the event we cannot find EmailName in both HKEY_CURRENT_USER and
    // HKEY_LOCAL_MACHINE trees, then we return this default
    //

    static char DefaultEmailName[] = DEFAULT_EMAIL_NAME;

    for (i = 0; i < ARRAY_ELEMENTS(KeysToTry); ++i) {
        error = InternetReadRegistryStringKey(KeysToTry[i],
                                              "EmailName",
                                              EmailName,
                                              Length
                                              );
        if (error == ERROR_SUCCESS) {
            break;
        }
    }
    if (error != ERROR_SUCCESS) {
        if (IsPlatformWinNT()) {

            //
            // only NT supports GetUserName()
            //

            if (GetUserName(EmailName, Length)) {

                //
                // we return the length as if the result from strlen/wcslen
                //

                *Length -= sizeof(char);

                DEBUG_PRINT(REGISTRY,
                            INFO,
                            ("GetUserName() returns %q\n",
                            EmailName
                            ));

                error = ERROR_SUCCESS;
            } else {

                //
                // BUGBUG - what's the required length?
                //

                error = GetLastError();
            }
        } else {

            //
            // Win95 & Win32s: have to do something different
            //

        }

        //
        // if we still don't have an email name, we use an internal default
        //

        if (error != ERROR_SUCCESS) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("Cannot find EmailName: using default (%s)\n",
                        DefaultEmailName
                        ));

            if (*Length >= sizeof(DEFAULT_EMAIL_NAME)) {
                memcpy(EmailName, DefaultEmailName, sizeof(DEFAULT_EMAIL_NAME));

                //
                // success - returned length as if from strlen()
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME) - 1;
                error = ERROR_SUCCESS;
            } else {

                //
                // failure - returned length is the required buffer size
                //

                *Length = sizeof(DEFAULT_EMAIL_NAME);
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetGetComputerName(
//    OUT LPSTR Buffer,
//    IN OUT LPDWORD Length
//    )
//
///*++
//
//Routine Description:
//
//    Platform-dependent function that returns this computer's name
//
//Arguments:
//
//    Buffer  - pointer to buffer where name is returned
//
//    Length  - IN: number of bytes in Buffer
//              OUT: number of characters in computer name, exluding terminating
//              NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - Win32 error
//
//--*/
//
//{
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//        error = InternetGetPrivateProfileString(SYSTEM_INI_FILE_NAME,
//                                                NETWORK_SECTION_NAME,
//                                                COMPUTER_NAME_VALUE,
//                                                Buffer,
//                                                Length
//                                                );
//    } else {
//        if (GetComputerName(Buffer, Length)) {
//            error = ERROR_SUCCESS;
//        } else {
//            error = GetLastError();
//        }
//    }
//    return error;
//}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_CURRENT_USER,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}

#ifdef WININET6

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity 
                ? WriteIDRegDword(ParameterName, ParameterValue)
                : InternetWriteRegistryDword(ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    If we're in an identity-mode, we'll read from the special location.
    Otherwise, read from the old location.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity
                ? ReadIDRegDword(ParameterName, ParameterValue)
                : InternetReadRegistryDwordKey(HKEY_CURRENT_USER, ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}
#endif


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    CRefdKey* prk = GetInternetSettingsKey();

    if (prk != NULL) {
        error = WriteRegistryDword(prk->GetKey(),
                                   ParameterName,
                                   ParameterValue
                                   );
        prk->Release();

    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetWriteRegistryString(
//    IN LPCSTR ParameterName,
//    IN LPSTR ParameterValue
//    )
//
///*++
//
//Routine Description:
//
//    Writes a string to the Internet Client registry key on NT/Win95, or writes
//    the corresponding value to SYSTEM.INI on Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to string to write
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetWriteRegistryString",
//                 "%.40q, %.80q",
//                 ParameterName,
//                 ParameterValue
//                 ));
//
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//
//        BOOL ok;
//
//        ok = WritePrivateProfileString(INTERNET_CLIENT_KEY,
//                                       ParameterName,
//                                       ParameterValue,
//                                       SYSTEM_INI_FILE_NAME
//                                       );
//        error = ok ? ERROR_SUCCESS : GetLastError();
//    } else {
//
//        //
//        // BUGBUG - currently, nothing needs to write to registry if NT or Win95
//        //
//
//        INET_ASSERT(FALSE);
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinary",
//                 "%q, %#x, %#x [%d]",
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//
//    error = InternetReadRegistryBinaryKey(HKEY_CURRENT_USER,
//                                          ParameterName,
//                                          ParameterValue,
//                                          ParameterLength
//                                          );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    CRefdKey* prk = GetInternetSettingsKey();
    BOOL bOpenedKey = FALSE;
    HKEY hkSettings = NULL;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &hkSettings
                             );
        if (error == ERROR_SUCCESS) {
            bOpenedKey = TRUE;
        }
    } else if (prk) {
        hkSettings = prk->GetKey();
    } else {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(hkSettings,
                                  ParameterName,
                                  ParameterValue
                                  );
    }
    
    if (bOpenedKey) {
        REGCLOSEKEY(hkSettings);
    }

    if (prk) {
        prk->Release();
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    CRefdKey* prk = GetInternetSettingsKey();
    BOOL bOpenedKey = FALSE;
    HKEY hkSettings = NULL;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             INTERNET_SETTINGS_KEY,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &hkSettings
                             );
        if (error == ERROR_SUCCESS) {
            bOpenedKey = TRUE;
        }
    } else if (prk) {
        hkSettings = prk->GetKey();
    } else {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(hkSettings,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
    }
    
    if (bOpenedKey) {
        REGCLOSEKEY(hkSettings);
    }

    if (prk) {
        prk->Release();
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}

//
//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinaryKey",
//                 "%s (%x), %q, %#x, %#x [%d]",
//                 (ParameterKey == HKEY_LOCAL_MACHINE)
//                    ? "HKEY_LOCAL_MACHINE"
//                    : (ParameterKey == HKEY_CURRENT_USER)
//                        ? "HKEY_CURRENT_USER"
//                        : "???",
//                 ParameterKey,
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//    HKEY clientKey;
//
//    //
//    // open the registry key containing the Internet client values (this is
//    // in the same place on NT and Win95)
//    //
//
//    error = REGOPENKEYEX(ParameterKey,
//                         INTERNET_SETTINGS_KEY,
//                         0, // reserved
//                         KEY_QUERY_VALUE,
//                         &clientKey
//                         );
//
//    if (error == ERROR_SUCCESS) {
//
//        DWORD valueType;
//
//        error = RegQueryValueEx(clientKey,
//                                ParameterName,
//                                NULL,   // reserved
//                                &valueType,
//                                ParameterValue,
//                                ParameterLength
//                                );
//        REGCLOSEKEY(clientKey);
//    }
//
//    DEBUG_PRINT(REGISTRY,
//                INFO,
//                ("InternetReadRegistryBinaryKey(%q): length = %d\n",
//                ParameterName,
//                *ParameterLength
//                ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads an string out of an INI file. Mainly just for Win32s
//
//Arguments:
//
//    IniFileName     - name of INI file to read
//
//    SectionName     - name of section in INI file to read
//
//    ParameterName   - name of entry in section to read
//
//    ParameterValue  - returned string
//
//    ParameterLength - IN: Length of ParameterValue
//                      OUT: Number of characters in ParameterValue, excluding
//                           terminating NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                  ERROR_FILE_NOT_FOUND
//
//--*/
//
//{
//    DWORD error;
//    DWORD nChars;
//
//    nChars = GetPrivateProfileString(SectionName,
//                                     ParameterName,
//                                     "",                // lpszDefault
//                                     ParameterValue,
//                                     *ParameterLength,
//                                     IniFileName
//                                     );
//    if (nChars > 0) {
//        *ParameterLength = nChars;
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_PATH_NOT_FOUND;
//    }
//    return error;
//}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_INTERNET_BAD_REGISTRY_PARAMETER
                    Inconsistent registry contents

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    LPSTR str;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_INTERNET_BAD_REGISTRY_PARAMETER;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}


BOOL
GetFileExtensionFromMimeType(
    LPCSTR  lpszMimeType,
    DWORD   dwMimeLen,
    LPSTR   lpszFileExtension,
    LPDWORD lpdwExtLen
    )
{
    HKEY    hKey = NULL;
    LPSTR   lpszMimeKey = (LPSTR)_alloca(sizeof(MIME_TO_FILE_EXTENSION_KEY)+dwMimeLen);

    memcpy(lpszMimeKey, MIME_TO_FILE_EXTENSION_KEY,
            sizeof(MIME_TO_FILE_EXTENSION_KEY)-1);
    memcpy(lpszMimeKey + sizeof(MIME_TO_FILE_EXTENSION_KEY) - 1, lpszMimeType,
            dwMimeLen);
    lpszMimeKey[sizeof(MIME_TO_FILE_EXTENSION_KEY) + dwMimeLen - 1] = '\0';

    if (REGOPENKEYEX(HKEY_CLASSES_ROOT,
                               lpszMimeKey,
                               0,
                               KEY_QUERY_VALUE,
                               &hKey)==ERROR_SUCCESS)
    {
        DWORD dwType, dwError = RegQueryValueEx(hKey,
                                EXTENSION_VALUE,
                                NULL,
                                &dwType,
                                (LPBYTE)lpszFileExtension,
                                lpdwExtLen);
        REGCLOSE